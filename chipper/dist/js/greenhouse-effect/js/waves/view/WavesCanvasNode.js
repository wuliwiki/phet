// Copyright 2020-2022, University of Colorado Boulder

/**
 * WavesCanvasNode is a Scenery CanvasNode used to render sinusoidal waves that represent different frequencies of light
 * moving around on the screen.
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */

import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import { CanvasNode } from '../../../../scenery/js/imports.js';
import GreenhouseEffectColors from '../../common/GreenhouseEffectColors.js';
import GreenhouseEffectConstants from '../../common/GreenhouseEffectConstants.js';
import greenhouseEffect from '../../greenhouseEffect.js';
import WavesModel from '../model/WavesModel.js';

// constants
const TWO_PI = 2 * Math.PI;
const WAVE_SEGMENT_INCREMENT = 2; // in screen coordinates
const WAVE_MAX_LINE_WIDTH = 8;
class WavesCanvasNode extends CanvasNode {
  /**
   * @param model
   * @param modelViewTransform
   * @param [options]
   */
  constructor(model, modelViewTransform, options) {
    super(options);
    this.model = model;
    this.modelViewTransform = modelViewTransform;
    const modelVisibleWavelength = WavesModel.REAL_TO_RENDERING_WAVELENGTH_MAP.get(GreenhouseEffectConstants.VISIBLE_WAVELENGTH);
    assert && assert(modelVisibleWavelength !== undefined);
    const modelInfraredWavelength = WavesModel.REAL_TO_RENDERING_WAVELENGTH_MAP.get(GreenhouseEffectConstants.INFRARED_WAVELENGTH);
    assert && assert(modelInfraredWavelength !== undefined);

    // Create a Map with the parameters for drawing the different types of waves.
    this.waveRenderingParameters = new Map([[GreenhouseEffectConstants.VISIBLE_WAVELENGTH, {
      baseColorProperty: GreenhouseEffectColors.sunlightColorProperty,
      amplitude: modelViewTransform.modelToViewDeltaX(WavesModel.WAVE_AMPLITUDE_FOR_RENDERING),
      wavelength: modelViewTransform.modelToViewDeltaX(modelVisibleWavelength)
    }], [GreenhouseEffectConstants.INFRARED_WAVELENGTH, {
      baseColorProperty: GreenhouseEffectColors.infraredColorProperty,
      amplitude: modelViewTransform.modelToViewDeltaX(WavesModel.WAVE_AMPLITUDE_FOR_RENDERING),
      wavelength: modelViewTransform.modelToViewDeltaX(modelInfraredWavelength)
    }]]);
  }
  paintCanvas(context) {
    this.model.waveGroup.forEach(wave => this.drawWave(context, wave));
  }

  /**
   * function to draw a sinusoidal wave on a canvas
   */
  drawWave(context, wave) {
    // convenience variables
    const modelViewTransform = this.modelViewTransform;
    const startPoint = modelViewTransform.modelToViewPosition(wave.startPoint);
    const renderingParameters = this.waveRenderingParameters.get(wave.wavelength);
    const amplitude = renderingParameters.amplitude;
    const wavelength = renderingParameters.wavelength;
    const baseColor = renderingParameters.baseColorProperty.value;

    // Set the context up with its initial values.  The stroke style may change as the wave intensity varies.
    let waveIntensity = wave.intensityAtStart;
    context.lineCap = 'round';
    context.lineWidth = waveIntensityToLineWidth(waveIntensity);
    context.strokeStyle = baseColor.withAlpha(waveIntensityToAlpha(wave.intensityAtStart)).toCSS();
    context.beginPath();

    // vectors used in the calculation process
    const unitVector = new Vector2(wave.propagationDirection.x, -wave.propagationDirection.y);
    const unitNormal = unitVector.perpendicular;
    let firstSegment = true;
    const totalLengthInView = modelViewTransform.modelToViewDeltaX(wave.length);
    const phaseOffsetAtStart = (wave.phaseOffsetAtOrigin + modelViewTransform.modelToViewDeltaX(wave.startPoint.distance(wave.origin)) / wavelength * TWO_PI) % TWO_PI;
    const intensityChanges = wave.intensityChanges;
    let nextIntensityChangeIndex = 0;
    let nextIntensityChangePosition = this.getIntensityChangeXPosition(nextIntensityChangeIndex, wave, amplitude, wavelength);

    // Get the amount of compensation needed in the x direction so that the wave will appear to originate from a
    // horizontal region.
    const compensatedStartingXValue = WavesCanvasNode.getXCompensationForTilt(amplitude, wavelength, phaseOffsetAtStart, wave.propagationDirection.getAngle());

    // Render the wave, changing the thickness if and when the intensity of the wave changes.
    for (let x = compensatedStartingXValue; x <= totalLengthInView; x += WAVE_SEGMENT_INCREMENT) {
      const y = amplitude * Math.sin(x / wavelength * TWO_PI + phaseOffsetAtStart);

      // Translate and rotate the periodic wave to match the position and orientation of the wave model.  Vector math
      // seems too slow here, shows up in profiler at 15% or so, so some optimization has been done.
      const traversePointX = startPoint.x + x * unitVector.x;
      const traversePointY = startPoint.y + x * unitVector.y;
      const ptX = traversePointX + y * unitNormal.x;
      const ptY = traversePointY + y * unitNormal.y;

      // Draw the next segment of the waveform.
      if (firstSegment) {
        context.moveTo(ptX, ptY);
        firstSegment = false;
      } else {
        context.lineTo(ptX, ptY);
      }
      if (x >= nextIntensityChangePosition) {
        // The rendering has reached the point of the next intensity change.  Draw what we've got so far, and then
        // adjust the line width to represent this change.
        context.stroke();
        context.beginPath();
        context.moveTo(ptX, ptY);
        waveIntensity = intensityChanges[nextIntensityChangeIndex].postChangeIntensity;
        context.lineWidth = waveIntensityToLineWidth(waveIntensity);
        context.strokeStyle = baseColor.withAlpha(waveIntensityToAlpha(waveIntensity)).toCSS();

        // Set up the next intensity change if there is one.
        nextIntensityChangeIndex++;
        nextIntensityChangePosition = this.getIntensityChangeXPosition(nextIntensityChangeIndex, wave, amplitude, wavelength);
      }
    }
    context.stroke();
  }

  /**
   * Get the X value in scaled view coordinates at which this intensity change should be rendered when drawing the
   * provided wave.  If this intensity change is anchored to an attenuator, it is compensated to look like it is
   * occurring along a horizontal line, see https://github.com/phetsims/greenhouse-effect/issues/66.
   * @param index - index of the intensity change of interest
   * @param wave - wave on which the intensity change may exist
   * @param amplitudeInView
   * @param wavelengthInView
   */
  getIntensityChangeXPosition(index, wave, amplitudeInView, wavelengthInView) {
    const intensityChange = wave.intensityChanges[index];
    const intensityChangeDistanceFromStart = intensityChange ? intensityChange.distanceFromStart : Number.POSITIVE_INFINITY;
    let xPosition = this.modelViewTransform.modelToViewDeltaX(intensityChangeDistanceFromStart);
    if (xPosition !== Number.POSITIVE_INFINITY && intensityChange.anchoredTo) {
      const phaseAtNominalXPosition = wave.getPhaseAt(intensityChangeDistanceFromStart + wave.origin.distance(wave.startPoint));
      xPosition += WavesCanvasNode.getXCompensationForTilt(amplitudeInView, wavelengthInView, phaseAtNominalXPosition, wave.propagationDirection.getAngle());
    }
    return xPosition;
  }

  /**
   * Get a value that represents the amount that the x value that is being provided to a sine function should be
   * adjusted so that the sine wave will look like it is originating from a horizontal line.  Think of this as a sort of
   * computational clipping.  For more information on why this is necessary and what it does, please see
   * https://github.com/phetsims/greenhouse-effect/issues/66.
   *
   * This is not an exact solution, it's an approximation that works resonably well.  I (jbphet) spent a couple of hours
   * trying to come up with an analytical, closed form solution, but didn't get there, and some poking around on line
   * led me to believe that it's not an easy problem, so I came up with this, which seems to work well enough for the
   * needs of this sim.
   *
   * Note that this algorithm assumes the waves are generated by a sine function, not a cosine.
   *
   * @param amplitudeInView
   * @param wavelengthInView
   * @param phase - in radians
   * @param propagationAngle - in radians, 0 is straight to the right
   */
  static getXCompensationForTilt(amplitudeInView, wavelengthInView, phase, propagationAngle) {
    // The following would probably be easier to understand if vectors were used, but for performance reasons we wanted
    // to avoid the memory allocations.
    const startPointY = amplitudeInView * Math.sin(phase);
    const rotatedYPosition = startPointY * Math.cos(propagationAngle);
    return propagationAngle > 0 ? -rotatedYPosition : rotatedYPosition;
  }
}
greenhouseEffect.register('WavesCanvasNode', WavesCanvasNode);
const waveIntensityToLineWidth = waveIntensity => {
  // TODO: Are there performance costs for using non-integer line widths?  We need to make this determination and decide
  //       whether to use integer or floating point values.  See https://github.com/phetsims/greenhouse-effect/issues/84.
  // return Math.ceil( waveIntensity * WAVE_MAX_LINE_WIDTH );
  return Utils.clamp(waveIntensity * WAVE_MAX_LINE_WIDTH, 0.5, WAVE_MAX_LINE_WIDTH);
};

// helper function for setting the opacity as a function of the intensity
const waveIntensityToAlpha = waveIntensity => {
  return Math.min(waveIntensity + 0.25, 1);
};
export default WavesCanvasNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJVdGlscyIsIlZlY3RvcjIiLCJDYW52YXNOb2RlIiwiR3JlZW5ob3VzZUVmZmVjdENvbG9ycyIsIkdyZWVuaG91c2VFZmZlY3RDb25zdGFudHMiLCJncmVlbmhvdXNlRWZmZWN0IiwiV2F2ZXNNb2RlbCIsIlRXT19QSSIsIk1hdGgiLCJQSSIsIldBVkVfU0VHTUVOVF9JTkNSRU1FTlQiLCJXQVZFX01BWF9MSU5FX1dJRFRIIiwiV2F2ZXNDYW52YXNOb2RlIiwiY29uc3RydWN0b3IiLCJtb2RlbCIsIm1vZGVsVmlld1RyYW5zZm9ybSIsIm9wdGlvbnMiLCJtb2RlbFZpc2libGVXYXZlbGVuZ3RoIiwiUkVBTF9UT19SRU5ERVJJTkdfV0FWRUxFTkdUSF9NQVAiLCJnZXQiLCJWSVNJQkxFX1dBVkVMRU5HVEgiLCJhc3NlcnQiLCJ1bmRlZmluZWQiLCJtb2RlbEluZnJhcmVkV2F2ZWxlbmd0aCIsIklORlJBUkVEX1dBVkVMRU5HVEgiLCJ3YXZlUmVuZGVyaW5nUGFyYW1ldGVycyIsIk1hcCIsImJhc2VDb2xvclByb3BlcnR5Iiwic3VubGlnaHRDb2xvclByb3BlcnR5IiwiYW1wbGl0dWRlIiwibW9kZWxUb1ZpZXdEZWx0YVgiLCJXQVZFX0FNUExJVFVERV9GT1JfUkVOREVSSU5HIiwid2F2ZWxlbmd0aCIsImluZnJhcmVkQ29sb3JQcm9wZXJ0eSIsInBhaW50Q2FudmFzIiwiY29udGV4dCIsIndhdmVHcm91cCIsImZvckVhY2giLCJ3YXZlIiwiZHJhd1dhdmUiLCJzdGFydFBvaW50IiwibW9kZWxUb1ZpZXdQb3NpdGlvbiIsInJlbmRlcmluZ1BhcmFtZXRlcnMiLCJiYXNlQ29sb3IiLCJ2YWx1ZSIsIndhdmVJbnRlbnNpdHkiLCJpbnRlbnNpdHlBdFN0YXJ0IiwibGluZUNhcCIsImxpbmVXaWR0aCIsIndhdmVJbnRlbnNpdHlUb0xpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwid2l0aEFscGhhIiwid2F2ZUludGVuc2l0eVRvQWxwaGEiLCJ0b0NTUyIsImJlZ2luUGF0aCIsInVuaXRWZWN0b3IiLCJwcm9wYWdhdGlvbkRpcmVjdGlvbiIsIngiLCJ5IiwidW5pdE5vcm1hbCIsInBlcnBlbmRpY3VsYXIiLCJmaXJzdFNlZ21lbnQiLCJ0b3RhbExlbmd0aEluVmlldyIsImxlbmd0aCIsInBoYXNlT2Zmc2V0QXRTdGFydCIsInBoYXNlT2Zmc2V0QXRPcmlnaW4iLCJkaXN0YW5jZSIsIm9yaWdpbiIsImludGVuc2l0eUNoYW5nZXMiLCJuZXh0SW50ZW5zaXR5Q2hhbmdlSW5kZXgiLCJuZXh0SW50ZW5zaXR5Q2hhbmdlUG9zaXRpb24iLCJnZXRJbnRlbnNpdHlDaGFuZ2VYUG9zaXRpb24iLCJjb21wZW5zYXRlZFN0YXJ0aW5nWFZhbHVlIiwiZ2V0WENvbXBlbnNhdGlvbkZvclRpbHQiLCJnZXRBbmdsZSIsInNpbiIsInRyYXZlcnNlUG9pbnRYIiwidHJhdmVyc2VQb2ludFkiLCJwdFgiLCJwdFkiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJwb3N0Q2hhbmdlSW50ZW5zaXR5IiwiaW5kZXgiLCJhbXBsaXR1ZGVJblZpZXciLCJ3YXZlbGVuZ3RoSW5WaWV3IiwiaW50ZW5zaXR5Q2hhbmdlIiwiaW50ZW5zaXR5Q2hhbmdlRGlzdGFuY2VGcm9tU3RhcnQiLCJkaXN0YW5jZUZyb21TdGFydCIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwieFBvc2l0aW9uIiwiYW5jaG9yZWRUbyIsInBoYXNlQXROb21pbmFsWFBvc2l0aW9uIiwiZ2V0UGhhc2VBdCIsInBoYXNlIiwicHJvcGFnYXRpb25BbmdsZSIsInN0YXJ0UG9pbnRZIiwicm90YXRlZFlQb3NpdGlvbiIsImNvcyIsInJlZ2lzdGVyIiwiY2xhbXAiLCJtaW4iXSwic291cmNlcyI6WyJXYXZlc0NhbnZhc05vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogV2F2ZXNDYW52YXNOb2RlIGlzIGEgU2NlbmVyeSBDYW52YXNOb2RlIHVzZWQgdG8gcmVuZGVyIHNpbnVzb2lkYWwgd2F2ZXMgdGhhdCByZXByZXNlbnQgZGlmZmVyZW50IGZyZXF1ZW5jaWVzIG9mIGxpZ2h0XHJcbiAqIG1vdmluZyBhcm91bmQgb24gdGhlIHNjcmVlbi5cclxuICpcclxuICogQGF1dGhvciBKb2huIEJsYW5jbyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgTW9kZWxWaWV3VHJhbnNmb3JtMiBmcm9tICcuLi8uLi8uLi8uLi9waGV0Y29tbW9uL2pzL3ZpZXcvTW9kZWxWaWV3VHJhbnNmb3JtMi5qcyc7XHJcbmltcG9ydCB7IENhbnZhc05vZGUsIENhbnZhc05vZGVPcHRpb25zLCBDb2xvclByb3BlcnR5IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IEdyZWVuaG91c2VFZmZlY3RDb2xvcnMgZnJvbSAnLi4vLi4vY29tbW9uL0dyZWVuaG91c2VFZmZlY3RDb2xvcnMuanMnO1xyXG5pbXBvcnQgR3JlZW5ob3VzZUVmZmVjdENvbnN0YW50cyBmcm9tICcuLi8uLi9jb21tb24vR3JlZW5ob3VzZUVmZmVjdENvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBncmVlbmhvdXNlRWZmZWN0IGZyb20gJy4uLy4uL2dyZWVuaG91c2VFZmZlY3QuanMnO1xyXG5pbXBvcnQgV2F2ZSBmcm9tICcuLi9tb2RlbC9XYXZlLmpzJztcclxuaW1wb3J0IFdhdmVzTW9kZWwgZnJvbSAnLi4vbW9kZWwvV2F2ZXNNb2RlbC5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgVFdPX1BJID0gMiAqIE1hdGguUEk7XHJcbmNvbnN0IFdBVkVfU0VHTUVOVF9JTkNSRU1FTlQgPSAyOyAvLyBpbiBzY3JlZW4gY29vcmRpbmF0ZXNcclxuY29uc3QgV0FWRV9NQVhfTElORV9XSURUSCA9IDg7XHJcblxyXG50eXBlIFJlbmRlcmluZ1BhcmFtZXRlcnMgPSB7XHJcbiAgYmFzZUNvbG9yUHJvcGVydHk6IENvbG9yUHJvcGVydHk7XHJcbiAgYW1wbGl0dWRlOiBudW1iZXI7XHJcbiAgd2F2ZWxlbmd0aDogbnVtYmVyO1xyXG59O1xyXG5cclxuY2xhc3MgV2F2ZXNDYW52YXNOb2RlIGV4dGVuZHMgQ2FudmFzTm9kZSB7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBtb2RlbDogV2F2ZXNNb2RlbDtcclxuICBwcml2YXRlIHJlYWRvbmx5IG1vZGVsVmlld1RyYW5zZm9ybTogTW9kZWxWaWV3VHJhbnNmb3JtMjtcclxuICBwcml2YXRlIHJlYWRvbmx5IHdhdmVSZW5kZXJpbmdQYXJhbWV0ZXJzOiBNYXA8bnVtYmVyLCBSZW5kZXJpbmdQYXJhbWV0ZXJzPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIG1vZGVsXHJcbiAgICogQHBhcmFtIG1vZGVsVmlld1RyYW5zZm9ybVxyXG4gICAqIEBwYXJhbSBbb3B0aW9uc11cclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIG1vZGVsOiBXYXZlc01vZGVsLCBtb2RlbFZpZXdUcmFuc2Zvcm06IE1vZGVsVmlld1RyYW5zZm9ybTIsIG9wdGlvbnM6IENhbnZhc05vZGVPcHRpb25zICkge1xyXG4gICAgc3VwZXIoIG9wdGlvbnMgKTtcclxuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgIHRoaXMubW9kZWxWaWV3VHJhbnNmb3JtID0gbW9kZWxWaWV3VHJhbnNmb3JtO1xyXG5cclxuICAgIGNvbnN0IG1vZGVsVmlzaWJsZVdhdmVsZW5ndGggPSBXYXZlc01vZGVsLlJFQUxfVE9fUkVOREVSSU5HX1dBVkVMRU5HVEhfTUFQLmdldCggR3JlZW5ob3VzZUVmZmVjdENvbnN0YW50cy5WSVNJQkxFX1dBVkVMRU5HVEggKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG1vZGVsVmlzaWJsZVdhdmVsZW5ndGggIT09IHVuZGVmaW5lZCApO1xyXG5cclxuICAgIGNvbnN0IG1vZGVsSW5mcmFyZWRXYXZlbGVuZ3RoID0gV2F2ZXNNb2RlbC5SRUFMX1RPX1JFTkRFUklOR19XQVZFTEVOR1RIX01BUC5nZXQoIEdyZWVuaG91c2VFZmZlY3RDb25zdGFudHMuSU5GUkFSRURfV0FWRUxFTkdUSCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggbW9kZWxJbmZyYXJlZFdhdmVsZW5ndGggIT09IHVuZGVmaW5lZCApO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIE1hcCB3aXRoIHRoZSBwYXJhbWV0ZXJzIGZvciBkcmF3aW5nIHRoZSBkaWZmZXJlbnQgdHlwZXMgb2Ygd2F2ZXMuXHJcbiAgICB0aGlzLndhdmVSZW5kZXJpbmdQYXJhbWV0ZXJzID0gbmV3IE1hcChcclxuICAgICAgW1xyXG4gICAgICAgIFtcclxuICAgICAgICAgIEdyZWVuaG91c2VFZmZlY3RDb25zdGFudHMuVklTSUJMRV9XQVZFTEVOR1RILFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBiYXNlQ29sb3JQcm9wZXJ0eTogR3JlZW5ob3VzZUVmZmVjdENvbG9ycy5zdW5saWdodENvbG9yUHJvcGVydHksXHJcbiAgICAgICAgICAgIGFtcGxpdHVkZTogbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3RGVsdGFYKCBXYXZlc01vZGVsLldBVkVfQU1QTElUVURFX0ZPUl9SRU5ERVJJTkcgKSxcclxuICAgICAgICAgICAgd2F2ZWxlbmd0aDogbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3RGVsdGFYKCBtb2RlbFZpc2libGVXYXZlbGVuZ3RoISApXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBbXHJcbiAgICAgICAgICBHcmVlbmhvdXNlRWZmZWN0Q29uc3RhbnRzLklORlJBUkVEX1dBVkVMRU5HVEgsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGJhc2VDb2xvclByb3BlcnR5OiBHcmVlbmhvdXNlRWZmZWN0Q29sb3JzLmluZnJhcmVkQ29sb3JQcm9wZXJ0eSxcclxuICAgICAgICAgICAgYW1wbGl0dWRlOiBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdEZWx0YVgoIFdhdmVzTW9kZWwuV0FWRV9BTVBMSVRVREVfRk9SX1JFTkRFUklORyApLFxyXG4gICAgICAgICAgICB3YXZlbGVuZ3RoOiBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdEZWx0YVgoIG1vZGVsSW5mcmFyZWRXYXZlbGVuZ3RoISApXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgICBdXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG92ZXJyaWRlIHBhaW50Q2FudmFzKCBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgKTogdm9pZCB7XHJcbiAgICB0aGlzLm1vZGVsLndhdmVHcm91cC5mb3JFYWNoKCB3YXZlID0+IHRoaXMuZHJhd1dhdmUoIGNvbnRleHQsIHdhdmUgKSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogZnVuY3Rpb24gdG8gZHJhdyBhIHNpbnVzb2lkYWwgd2F2ZSBvbiBhIGNhbnZhc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgZHJhd1dhdmUoIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgd2F2ZTogV2F2ZSApOiB2b2lkIHtcclxuXHJcbiAgICAvLyBjb252ZW5pZW5jZSB2YXJpYWJsZXNcclxuICAgIGNvbnN0IG1vZGVsVmlld1RyYW5zZm9ybSA9IHRoaXMubW9kZWxWaWV3VHJhbnNmb3JtO1xyXG4gICAgY29uc3Qgc3RhcnRQb2ludCA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1Bvc2l0aW9uKCB3YXZlLnN0YXJ0UG9pbnQgKTtcclxuICAgIGNvbnN0IHJlbmRlcmluZ1BhcmFtZXRlcnMgPSB0aGlzLndhdmVSZW5kZXJpbmdQYXJhbWV0ZXJzLmdldCggd2F2ZS53YXZlbGVuZ3RoICk7XHJcbiAgICBjb25zdCBhbXBsaXR1ZGUgPSByZW5kZXJpbmdQYXJhbWV0ZXJzIS5hbXBsaXR1ZGU7XHJcbiAgICBjb25zdCB3YXZlbGVuZ3RoID0gcmVuZGVyaW5nUGFyYW1ldGVycyEud2F2ZWxlbmd0aDtcclxuICAgIGNvbnN0IGJhc2VDb2xvciA9IHJlbmRlcmluZ1BhcmFtZXRlcnMhLmJhc2VDb2xvclByb3BlcnR5LnZhbHVlO1xyXG5cclxuICAgIC8vIFNldCB0aGUgY29udGV4dCB1cCB3aXRoIGl0cyBpbml0aWFsIHZhbHVlcy4gIFRoZSBzdHJva2Ugc3R5bGUgbWF5IGNoYW5nZSBhcyB0aGUgd2F2ZSBpbnRlbnNpdHkgdmFyaWVzLlxyXG4gICAgbGV0IHdhdmVJbnRlbnNpdHkgPSB3YXZlLmludGVuc2l0eUF0U3RhcnQ7XHJcbiAgICBjb250ZXh0LmxpbmVDYXAgPSAncm91bmQnO1xyXG4gICAgY29udGV4dC5saW5lV2lkdGggPSB3YXZlSW50ZW5zaXR5VG9MaW5lV2lkdGgoIHdhdmVJbnRlbnNpdHkgKTtcclxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBiYXNlQ29sb3Iud2l0aEFscGhhKCB3YXZlSW50ZW5zaXR5VG9BbHBoYSggd2F2ZS5pbnRlbnNpdHlBdFN0YXJ0ICkgKS50b0NTUygpO1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuXHJcbiAgICAvLyB2ZWN0b3JzIHVzZWQgaW4gdGhlIGNhbGN1bGF0aW9uIHByb2Nlc3NcclxuICAgIGNvbnN0IHVuaXRWZWN0b3IgPSBuZXcgVmVjdG9yMiggd2F2ZS5wcm9wYWdhdGlvbkRpcmVjdGlvbi54LCAtd2F2ZS5wcm9wYWdhdGlvbkRpcmVjdGlvbi55ICk7XHJcbiAgICBjb25zdCB1bml0Tm9ybWFsID0gdW5pdFZlY3Rvci5wZXJwZW5kaWN1bGFyO1xyXG5cclxuICAgIGxldCBmaXJzdFNlZ21lbnQgPSB0cnVlO1xyXG4gICAgY29uc3QgdG90YWxMZW5ndGhJblZpZXcgPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdEZWx0YVgoIHdhdmUubGVuZ3RoICk7XHJcbiAgICBjb25zdCBwaGFzZU9mZnNldEF0U3RhcnQgPSAoIHdhdmUucGhhc2VPZmZzZXRBdE9yaWdpbiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3RGVsdGFYKCB3YXZlLnN0YXJ0UG9pbnQuZGlzdGFuY2UoIHdhdmUub3JpZ2luICkgKSApIC9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F2ZWxlbmd0aCAqIFRXT19QSSApICUgVFdPX1BJO1xyXG4gICAgY29uc3QgaW50ZW5zaXR5Q2hhbmdlcyA9IHdhdmUuaW50ZW5zaXR5Q2hhbmdlcztcclxuICAgIGxldCBuZXh0SW50ZW5zaXR5Q2hhbmdlSW5kZXggPSAwO1xyXG4gICAgbGV0IG5leHRJbnRlbnNpdHlDaGFuZ2VQb3NpdGlvbiA9IHRoaXMuZ2V0SW50ZW5zaXR5Q2hhbmdlWFBvc2l0aW9uKFxyXG4gICAgICBuZXh0SW50ZW5zaXR5Q2hhbmdlSW5kZXgsXHJcbiAgICAgIHdhdmUsXHJcbiAgICAgIGFtcGxpdHVkZSxcclxuICAgICAgd2F2ZWxlbmd0aFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGFtb3VudCBvZiBjb21wZW5zYXRpb24gbmVlZGVkIGluIHRoZSB4IGRpcmVjdGlvbiBzbyB0aGF0IHRoZSB3YXZlIHdpbGwgYXBwZWFyIHRvIG9yaWdpbmF0ZSBmcm9tIGFcclxuICAgIC8vIGhvcml6b250YWwgcmVnaW9uLlxyXG4gICAgY29uc3QgY29tcGVuc2F0ZWRTdGFydGluZ1hWYWx1ZSA9IFdhdmVzQ2FudmFzTm9kZS5nZXRYQ29tcGVuc2F0aW9uRm9yVGlsdChcclxuICAgICAgYW1wbGl0dWRlLFxyXG4gICAgICB3YXZlbGVuZ3RoLFxyXG4gICAgICBwaGFzZU9mZnNldEF0U3RhcnQsXHJcbiAgICAgIHdhdmUucHJvcGFnYXRpb25EaXJlY3Rpb24uZ2V0QW5nbGUoKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBSZW5kZXIgdGhlIHdhdmUsIGNoYW5naW5nIHRoZSB0aGlja25lc3MgaWYgYW5kIHdoZW4gdGhlIGludGVuc2l0eSBvZiB0aGUgd2F2ZSBjaGFuZ2VzLlxyXG4gICAgZm9yICggbGV0IHggPSBjb21wZW5zYXRlZFN0YXJ0aW5nWFZhbHVlOyB4IDw9IHRvdGFsTGVuZ3RoSW5WaWV3OyB4ICs9IFdBVkVfU0VHTUVOVF9JTkNSRU1FTlQgKSB7XHJcblxyXG4gICAgICBjb25zdCB5ID0gYW1wbGl0dWRlICogTWF0aC5zaW4oIHggLyB3YXZlbGVuZ3RoICogVFdPX1BJICsgcGhhc2VPZmZzZXRBdFN0YXJ0ICk7XHJcblxyXG4gICAgICAvLyBUcmFuc2xhdGUgYW5kIHJvdGF0ZSB0aGUgcGVyaW9kaWMgd2F2ZSB0byBtYXRjaCB0aGUgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSB3YXZlIG1vZGVsLiAgVmVjdG9yIG1hdGhcclxuICAgICAgLy8gc2VlbXMgdG9vIHNsb3cgaGVyZSwgc2hvd3MgdXAgaW4gcHJvZmlsZXIgYXQgMTUlIG9yIHNvLCBzbyBzb21lIG9wdGltaXphdGlvbiBoYXMgYmVlbiBkb25lLlxyXG4gICAgICBjb25zdCB0cmF2ZXJzZVBvaW50WCA9IHN0YXJ0UG9pbnQueCArIHggKiB1bml0VmVjdG9yLng7XHJcbiAgICAgIGNvbnN0IHRyYXZlcnNlUG9pbnRZID0gc3RhcnRQb2ludC55ICsgeCAqIHVuaXRWZWN0b3IueTtcclxuICAgICAgY29uc3QgcHRYID0gdHJhdmVyc2VQb2ludFggKyB5ICogdW5pdE5vcm1hbC54O1xyXG4gICAgICBjb25zdCBwdFkgPSB0cmF2ZXJzZVBvaW50WSArIHkgKiB1bml0Tm9ybWFsLnk7XHJcblxyXG4gICAgICAvLyBEcmF3IHRoZSBuZXh0IHNlZ21lbnQgb2YgdGhlIHdhdmVmb3JtLlxyXG4gICAgICBpZiAoIGZpcnN0U2VnbWVudCApIHtcclxuICAgICAgICBjb250ZXh0Lm1vdmVUbyggcHRYLCBwdFkgKTtcclxuICAgICAgICBmaXJzdFNlZ21lbnQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBjb250ZXh0LmxpbmVUbyggcHRYLCBwdFkgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCB4ID49IG5leHRJbnRlbnNpdHlDaGFuZ2VQb3NpdGlvbiApIHtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJlbmRlcmluZyBoYXMgcmVhY2hlZCB0aGUgcG9pbnQgb2YgdGhlIG5leHQgaW50ZW5zaXR5IGNoYW5nZS4gIERyYXcgd2hhdCB3ZSd2ZSBnb3Qgc28gZmFyLCBhbmQgdGhlblxyXG4gICAgICAgIC8vIGFkanVzdCB0aGUgbGluZSB3aWR0aCB0byByZXByZXNlbnQgdGhpcyBjaGFuZ2UuXHJcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGNvbnRleHQubW92ZVRvKCBwdFgsIHB0WSApO1xyXG4gICAgICAgIHdhdmVJbnRlbnNpdHkgPSBpbnRlbnNpdHlDaGFuZ2VzWyBuZXh0SW50ZW5zaXR5Q2hhbmdlSW5kZXggXS5wb3N0Q2hhbmdlSW50ZW5zaXR5O1xyXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gd2F2ZUludGVuc2l0eVRvTGluZVdpZHRoKCB3YXZlSW50ZW5zaXR5ICk7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGJhc2VDb2xvci53aXRoQWxwaGEoIHdhdmVJbnRlbnNpdHlUb0FscGhhKCB3YXZlSW50ZW5zaXR5ICkgKS50b0NTUygpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdXAgdGhlIG5leHQgaW50ZW5zaXR5IGNoYW5nZSBpZiB0aGVyZSBpcyBvbmUuXHJcbiAgICAgICAgbmV4dEludGVuc2l0eUNoYW5nZUluZGV4Kys7XHJcbiAgICAgICAgbmV4dEludGVuc2l0eUNoYW5nZVBvc2l0aW9uID0gdGhpcy5nZXRJbnRlbnNpdHlDaGFuZ2VYUG9zaXRpb24oXHJcbiAgICAgICAgICBuZXh0SW50ZW5zaXR5Q2hhbmdlSW5kZXgsXHJcbiAgICAgICAgICB3YXZlLFxyXG4gICAgICAgICAgYW1wbGl0dWRlLFxyXG4gICAgICAgICAgd2F2ZWxlbmd0aFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBYIHZhbHVlIGluIHNjYWxlZCB2aWV3IGNvb3JkaW5hdGVzIGF0IHdoaWNoIHRoaXMgaW50ZW5zaXR5IGNoYW5nZSBzaG91bGQgYmUgcmVuZGVyZWQgd2hlbiBkcmF3aW5nIHRoZVxyXG4gICAqIHByb3ZpZGVkIHdhdmUuICBJZiB0aGlzIGludGVuc2l0eSBjaGFuZ2UgaXMgYW5jaG9yZWQgdG8gYW4gYXR0ZW51YXRvciwgaXQgaXMgY29tcGVuc2F0ZWQgdG8gbG9vayBsaWtlIGl0IGlzXHJcbiAgICogb2NjdXJyaW5nIGFsb25nIGEgaG9yaXpvbnRhbCBsaW5lLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2dyZWVuaG91c2UtZWZmZWN0L2lzc3Vlcy82Ni5cclxuICAgKiBAcGFyYW0gaW5kZXggLSBpbmRleCBvZiB0aGUgaW50ZW5zaXR5IGNoYW5nZSBvZiBpbnRlcmVzdFxyXG4gICAqIEBwYXJhbSB3YXZlIC0gd2F2ZSBvbiB3aGljaCB0aGUgaW50ZW5zaXR5IGNoYW5nZSBtYXkgZXhpc3RcclxuICAgKiBAcGFyYW0gYW1wbGl0dWRlSW5WaWV3XHJcbiAgICogQHBhcmFtIHdhdmVsZW5ndGhJblZpZXdcclxuICAgKi9cclxuICBwcml2YXRlIGdldEludGVuc2l0eUNoYW5nZVhQb3NpdGlvbiggaW5kZXg6IG51bWJlciwgd2F2ZTogV2F2ZSwgYW1wbGl0dWRlSW5WaWV3OiBudW1iZXIsIHdhdmVsZW5ndGhJblZpZXc6IG51bWJlciApOiBudW1iZXIge1xyXG4gICAgY29uc3QgaW50ZW5zaXR5Q2hhbmdlID0gd2F2ZS5pbnRlbnNpdHlDaGFuZ2VzWyBpbmRleCBdO1xyXG4gICAgY29uc3QgaW50ZW5zaXR5Q2hhbmdlRGlzdGFuY2VGcm9tU3RhcnQgPSBpbnRlbnNpdHlDaGFuZ2UgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlbnNpdHlDaGFuZ2UuZGlzdGFuY2VGcm9tU3RhcnQgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICBsZXQgeFBvc2l0aW9uID0gdGhpcy5tb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdEZWx0YVgoIGludGVuc2l0eUNoYW5nZURpc3RhbmNlRnJvbVN0YXJ0ICk7XHJcbiAgICBpZiAoIHhQb3NpdGlvbiAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmIGludGVuc2l0eUNoYW5nZS5hbmNob3JlZFRvICkge1xyXG4gICAgICBjb25zdCBwaGFzZUF0Tm9taW5hbFhQb3NpdGlvbiA9IHdhdmUuZ2V0UGhhc2VBdChcclxuICAgICAgICBpbnRlbnNpdHlDaGFuZ2VEaXN0YW5jZUZyb21TdGFydCArIHdhdmUub3JpZ2luLmRpc3RhbmNlKCB3YXZlLnN0YXJ0UG9pbnQgKVxyXG4gICAgICApO1xyXG4gICAgICB4UG9zaXRpb24gKz0gV2F2ZXNDYW52YXNOb2RlLmdldFhDb21wZW5zYXRpb25Gb3JUaWx0KFxyXG4gICAgICAgIGFtcGxpdHVkZUluVmlldyxcclxuICAgICAgICB3YXZlbGVuZ3RoSW5WaWV3LFxyXG4gICAgICAgIHBoYXNlQXROb21pbmFsWFBvc2l0aW9uLFxyXG4gICAgICAgIHdhdmUucHJvcGFnYXRpb25EaXJlY3Rpb24uZ2V0QW5nbGUoKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHhQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgYW1vdW50IHRoYXQgdGhlIHggdmFsdWUgdGhhdCBpcyBiZWluZyBwcm92aWRlZCB0byBhIHNpbmUgZnVuY3Rpb24gc2hvdWxkIGJlXHJcbiAgICogYWRqdXN0ZWQgc28gdGhhdCB0aGUgc2luZSB3YXZlIHdpbGwgbG9vayBsaWtlIGl0IGlzIG9yaWdpbmF0aW5nIGZyb20gYSBob3Jpem9udGFsIGxpbmUuICBUaGluayBvZiB0aGlzIGFzIGEgc29ydCBvZlxyXG4gICAqIGNvbXB1dGF0aW9uYWwgY2xpcHBpbmcuICBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB3aHkgdGhpcyBpcyBuZWNlc3NhcnkgYW5kIHdoYXQgaXQgZG9lcywgcGxlYXNlIHNlZVxyXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9ncmVlbmhvdXNlLWVmZmVjdC9pc3N1ZXMvNjYuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIG5vdCBhbiBleGFjdCBzb2x1dGlvbiwgaXQncyBhbiBhcHByb3hpbWF0aW9uIHRoYXQgd29ya3MgcmVzb25hYmx5IHdlbGwuICBJIChqYnBoZXQpIHNwZW50IGEgY291cGxlIG9mIGhvdXJzXHJcbiAgICogdHJ5aW5nIHRvIGNvbWUgdXAgd2l0aCBhbiBhbmFseXRpY2FsLCBjbG9zZWQgZm9ybSBzb2x1dGlvbiwgYnV0IGRpZG4ndCBnZXQgdGhlcmUsIGFuZCBzb21lIHBva2luZyBhcm91bmQgb24gbGluZVxyXG4gICAqIGxlZCBtZSB0byBiZWxpZXZlIHRoYXQgaXQncyBub3QgYW4gZWFzeSBwcm9ibGVtLCBzbyBJIGNhbWUgdXAgd2l0aCB0aGlzLCB3aGljaCBzZWVtcyB0byB3b3JrIHdlbGwgZW5vdWdoIGZvciB0aGVcclxuICAgKiBuZWVkcyBvZiB0aGlzIHNpbS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIGFsZ29yaXRobSBhc3N1bWVzIHRoZSB3YXZlcyBhcmUgZ2VuZXJhdGVkIGJ5IGEgc2luZSBmdW5jdGlvbiwgbm90IGEgY29zaW5lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFtcGxpdHVkZUluVmlld1xyXG4gICAqIEBwYXJhbSB3YXZlbGVuZ3RoSW5WaWV3XHJcbiAgICogQHBhcmFtIHBoYXNlIC0gaW4gcmFkaWFuc1xyXG4gICAqIEBwYXJhbSBwcm9wYWdhdGlvbkFuZ2xlIC0gaW4gcmFkaWFucywgMCBpcyBzdHJhaWdodCB0byB0aGUgcmlnaHRcclxuICAgKi9cclxuICBwcml2YXRlIHN0YXRpYyBnZXRYQ29tcGVuc2F0aW9uRm9yVGlsdCggYW1wbGl0dWRlSW5WaWV3OiBudW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhdmVsZW5ndGhJblZpZXc6IG51bWJlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGhhc2U6IG51bWJlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRpb25BbmdsZTogbnVtYmVyICk6IG51bWJlciB7XHJcblxyXG4gICAgLy8gVGhlIGZvbGxvd2luZyB3b3VsZCBwcm9iYWJseSBiZSBlYXNpZXIgdG8gdW5kZXJzdGFuZCBpZiB2ZWN0b3JzIHdlcmUgdXNlZCwgYnV0IGZvciBwZXJmb3JtYW5jZSByZWFzb25zIHdlIHdhbnRlZFxyXG4gICAgLy8gdG8gYXZvaWQgdGhlIG1lbW9yeSBhbGxvY2F0aW9ucy5cclxuICAgIGNvbnN0IHN0YXJ0UG9pbnRZID0gYW1wbGl0dWRlSW5WaWV3ICogTWF0aC5zaW4oIHBoYXNlICk7XHJcbiAgICBjb25zdCByb3RhdGVkWVBvc2l0aW9uID0gc3RhcnRQb2ludFkgKiBNYXRoLmNvcyggcHJvcGFnYXRpb25BbmdsZSApO1xyXG5cclxuICAgIHJldHVybiBwcm9wYWdhdGlvbkFuZ2xlID4gMCA/IC1yb3RhdGVkWVBvc2l0aW9uIDogcm90YXRlZFlQb3NpdGlvbjtcclxuICB9XHJcbn1cclxuXHJcbmdyZWVuaG91c2VFZmZlY3QucmVnaXN0ZXIoICdXYXZlc0NhbnZhc05vZGUnLCBXYXZlc0NhbnZhc05vZGUgKTtcclxuXHJcblxyXG5jb25zdCB3YXZlSW50ZW5zaXR5VG9MaW5lV2lkdGggPSAoIHdhdmVJbnRlbnNpdHk6IG51bWJlciApOiBudW1iZXIgPT4ge1xyXG5cclxuICAvLyBUT0RPOiBBcmUgdGhlcmUgcGVyZm9ybWFuY2UgY29zdHMgZm9yIHVzaW5nIG5vbi1pbnRlZ2VyIGxpbmUgd2lkdGhzPyAgV2UgbmVlZCB0byBtYWtlIHRoaXMgZGV0ZXJtaW5hdGlvbiBhbmQgZGVjaWRlXHJcbiAgLy8gICAgICAgd2hldGhlciB0byB1c2UgaW50ZWdlciBvciBmbG9hdGluZyBwb2ludCB2YWx1ZXMuICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2dyZWVuaG91c2UtZWZmZWN0L2lzc3Vlcy84NC5cclxuICAvLyByZXR1cm4gTWF0aC5jZWlsKCB3YXZlSW50ZW5zaXR5ICogV0FWRV9NQVhfTElORV9XSURUSCApO1xyXG4gIHJldHVybiBVdGlscy5jbGFtcCggd2F2ZUludGVuc2l0eSAqIFdBVkVfTUFYX0xJTkVfV0lEVEgsIDAuNSwgV0FWRV9NQVhfTElORV9XSURUSCApO1xyXG59O1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBzZXR0aW5nIHRoZSBvcGFjaXR5IGFzIGEgZnVuY3Rpb24gb2YgdGhlIGludGVuc2l0eVxyXG5jb25zdCB3YXZlSW50ZW5zaXR5VG9BbHBoYSA9ICggd2F2ZUludGVuc2l0eTogbnVtYmVyICk6IG51bWJlciA9PiB7XHJcbiAgcmV0dXJuIE1hdGgubWluKCB3YXZlSW50ZW5zaXR5ICsgMC4yNSwgMSApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2F2ZXNDYW52YXNOb2RlO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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