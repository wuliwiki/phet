// Copyright 2017-2023, University of Colorado Boulder

/**
 * Abstract base class for challenge factories in both the 'Graphing Lines' and 'Graphing Slope-Intercept' sims.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import dotRandom from '../../../../dot/js/dotRandom.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import optionize from '../../../../phet-core/js/optionize.js';
import GLConstants from '../../common/GLConstants.js';
import Line from '../../common/model/Line.js';
import graphingLines from '../../graphingLines.js';
export default class BaseChallengeFactory {
  constructor(providedOptions) {
    const options = optionize()({
      xRange: GLConstants.X_AXIS_RANGE,
      yRange: GLConstants.Y_AXIS_RANGE
    }, providedOptions);
    this.xRange = options.xRange;
    this.yRange = options.yRange;
  }

  /**
   * Creates challenges for the factory's game level.
   */

  /**
   * Convenience function for creating a line, give a slope and intercept.
   */
  createSlopeInterceptLine(slope, intercept) {
    return Line.createSlopeIntercept(slope.numerator, slope.denominator, intercept);
  }

  /**
   * Convenience function for creating a line, give a point and slope.
   */
  createPointSlopeLine(point, slope) {
    return Line.createPointSlope(point.x, point.y, slope.numerator, slope.denominator);
  }

  /**
   * Picks a point that keeps the slope indicator on the graph.
   */
  static choosePointForSlope(slope, graphXRange, graphYRange) {
    const rise = slope.numerator;
    const run = slope.denominator;

    // x
    const minX = run >= 0 ? graphXRange.min : graphXRange.min - run;
    const maxX = run >= 0 ? graphXRange.max - run : graphXRange.max;
    const x = Utils.roundSymmetric(minX + dotRandom.nextDouble() * (maxX - minX));
    assert && assert(x >= minX && x <= maxX, `x out of range: ${x}`);

    // y
    const minY = rise >= 0 ? graphYRange.min : graphYRange.min - rise;
    const maxY = rise >= 0 ? graphYRange.max - rise : graphYRange.max;
    const y = Utils.roundSymmetric(minY + dotRandom.nextDouble() * (maxY - minY));
    assert && assert(y >= minY && y <= maxY, `y out of range: ${y}`);
    return new Vector2(x, y);
  }

  /**
   * Picks a point (x1,x2) on the graph that results in the slope indicator (x2,y2) being off the graph.
   * This forces the user to invert the slope.
   */
  static choosePointForSlopeInversion(slope, graphXRange, graphYRange) {
    const rise = slope.numerator;
    const run = slope.denominator;

    // x1 coordinates
    const minX1 = run >= 0 ? graphXRange.max - run + 1 : graphXRange.min;
    const maxX1 = run >= 0 ? graphXRange.max : graphXRange.min - run - 1;
    const x1 = Utils.roundSymmetric(minX1 + dotRandom.nextDouble() * (maxX1 - minX1));
    assert && assert(x1 >= minX1 && x1 <= maxX1, `x1 out of range: ${x1}`);

    // y1 coordinates
    const minY1 = rise >= 0 ? graphYRange.max - rise + 1 : graphYRange.min;
    const maxY1 = rise >= 0 ? graphYRange.max : graphYRange.min - rise - 1;
    const y1 = Utils.roundSymmetric(minY1 + dotRandom.nextDouble() * (maxY1 - minY1));
    assert && assert(y1 >= minY1 && y1 <= maxY1, `y1 out of range: ${y1}`);

    // compute (x2,y2) for validation
    const x2 = x1 + run;
    const y2 = y1 + rise;

    // (x1,y1) must be on the graph, (x2,y2) must be off the graph
    assert && assert(graphXRange.contains(x1) && !graphXRange.contains(x2));
    assert && assert(graphYRange.contains(y1) && !graphYRange.contains(y2));
    return new Vector2(x1, y1);
  }
}
graphingLines.register('BaseChallengeFactory', BaseChallengeFactory);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3RSYW5kb20iLCJVdGlscyIsIlZlY3RvcjIiLCJvcHRpb25pemUiLCJHTENvbnN0YW50cyIsIkxpbmUiLCJncmFwaGluZ0xpbmVzIiwiQmFzZUNoYWxsZW5nZUZhY3RvcnkiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJ4UmFuZ2UiLCJYX0FYSVNfUkFOR0UiLCJ5UmFuZ2UiLCJZX0FYSVNfUkFOR0UiLCJjcmVhdGVTbG9wZUludGVyY2VwdExpbmUiLCJzbG9wZSIsImludGVyY2VwdCIsImNyZWF0ZVNsb3BlSW50ZXJjZXB0IiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJjcmVhdGVQb2ludFNsb3BlTGluZSIsInBvaW50IiwiY3JlYXRlUG9pbnRTbG9wZSIsIngiLCJ5IiwiY2hvb3NlUG9pbnRGb3JTbG9wZSIsImdyYXBoWFJhbmdlIiwiZ3JhcGhZUmFuZ2UiLCJyaXNlIiwicnVuIiwibWluWCIsIm1pbiIsIm1heFgiLCJtYXgiLCJyb3VuZFN5bW1ldHJpYyIsIm5leHREb3VibGUiLCJhc3NlcnQiLCJtaW5ZIiwibWF4WSIsImNob29zZVBvaW50Rm9yU2xvcGVJbnZlcnNpb24iLCJtaW5YMSIsIm1heFgxIiwieDEiLCJtaW5ZMSIsIm1heFkxIiwieTEiLCJ4MiIsInkyIiwiY29udGFpbnMiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkJhc2VDaGFsbGVuZ2VGYWN0b3J5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE3LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGNoYWxsZW5nZSBmYWN0b3JpZXMgaW4gYm90aCB0aGUgJ0dyYXBoaW5nIExpbmVzJyBhbmQgJ0dyYXBoaW5nIFNsb3BlLUludGVyY2VwdCcgc2ltcy5cclxuICpcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgZG90UmFuZG9tIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9kb3RSYW5kb20uanMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IFJhbmdlIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9SYW5nZS5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IEZyYWN0aW9uIGZyb20gJy4uLy4uLy4uLy4uL3BoZXRjb21tb24vanMvbW9kZWwvRnJhY3Rpb24uanMnO1xyXG5pbXBvcnQgR0xDb25zdGFudHMgZnJvbSAnLi4vLi4vY29tbW9uL0dMQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IExpbmUgZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL0xpbmUuanMnO1xyXG5pbXBvcnQgZ3JhcGhpbmdMaW5lcyBmcm9tICcuLi8uLi9ncmFwaGluZ0xpbmVzLmpzJztcclxuaW1wb3J0IENoYWxsZW5nZSBmcm9tICcuL0NoYWxsZW5nZS5qcyc7XHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0ge1xyXG4gIHhSYW5nZT86IFJhbmdlOyAvLyByYW5nZSBvZiB0aGUgZ3JhcGgncyB4LWF4aXNcclxuICB5UmFuZ2U/OiBSYW5nZTsgLy8gcmFuZ2Ugb2YgdGhlIGdyYXBoJ3MgeS1heGlzXHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBCYXNlQ2hhbGxlbmdlRmFjdG9yeU9wdGlvbnMgPSBTZWxmT3B0aW9ucztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEJhc2VDaGFsbGVuZ2VGYWN0b3J5IHtcclxuXHJcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHhSYW5nZTogUmFuZ2U7XHJcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHlSYW5nZTogUmFuZ2U7XHJcblxyXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvciggcHJvdmlkZWRPcHRpb25zPzogQmFzZUNoYWxsZW5nZUZhY3RvcnlPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8QmFzZUNoYWxsZW5nZUZhY3RvcnlPcHRpb25zLCBTZWxmT3B0aW9ucz4oKSgge1xyXG4gICAgICB4UmFuZ2U6IEdMQ29uc3RhbnRzLlhfQVhJU19SQU5HRSxcclxuICAgICAgeVJhbmdlOiBHTENvbnN0YW50cy5ZX0FYSVNfUkFOR0VcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMueFJhbmdlID0gb3B0aW9ucy54UmFuZ2U7XHJcbiAgICB0aGlzLnlSYW5nZSA9IG9wdGlvbnMueVJhbmdlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBjaGFsbGVuZ2VzIGZvciB0aGUgZmFjdG9yeSdzIGdhbWUgbGV2ZWwuXHJcbiAgICovXHJcbiAgcHVibGljIGFic3RyYWN0IGNyZWF0ZUNoYWxsZW5nZXMoKTogQ2hhbGxlbmdlW107XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIGxpbmUsIGdpdmUgYSBzbG9wZSBhbmQgaW50ZXJjZXB0LlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBjcmVhdGVTbG9wZUludGVyY2VwdExpbmUoIHNsb3BlOiBGcmFjdGlvbiwgaW50ZXJjZXB0OiBudW1iZXIgKTogTGluZSB7XHJcbiAgICByZXR1cm4gTGluZS5jcmVhdGVTbG9wZUludGVyY2VwdCggc2xvcGUubnVtZXJhdG9yLCBzbG9wZS5kZW5vbWluYXRvciwgaW50ZXJjZXB0ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBsaW5lLCBnaXZlIGEgcG9pbnQgYW5kIHNsb3BlLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBjcmVhdGVQb2ludFNsb3BlTGluZSggcG9pbnQ6IFZlY3RvcjIsIHNsb3BlOiBGcmFjdGlvbiApOiBMaW5lIHtcclxuICAgIHJldHVybiBMaW5lLmNyZWF0ZVBvaW50U2xvcGUoIHBvaW50LngsIHBvaW50LnksIHNsb3BlLm51bWVyYXRvciwgc2xvcGUuZGVub21pbmF0b3IgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBpY2tzIGEgcG9pbnQgdGhhdCBrZWVwcyB0aGUgc2xvcGUgaW5kaWNhdG9yIG9uIHRoZSBncmFwaC5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgc3RhdGljIGNob29zZVBvaW50Rm9yU2xvcGUoIHNsb3BlOiBGcmFjdGlvbiwgZ3JhcGhYUmFuZ2U6IFJhbmdlLCBncmFwaFlSYW5nZTogUmFuZ2UgKTogVmVjdG9yMiB7XHJcblxyXG4gICAgY29uc3QgcmlzZSA9IHNsb3BlLm51bWVyYXRvcjtcclxuICAgIGNvbnN0IHJ1biA9IHNsb3BlLmRlbm9taW5hdG9yO1xyXG5cclxuICAgIC8vIHhcclxuICAgIGNvbnN0IG1pblggPSAoIHJ1biA+PSAwICkgPyBncmFwaFhSYW5nZS5taW4gOiBncmFwaFhSYW5nZS5taW4gLSBydW47XHJcbiAgICBjb25zdCBtYXhYID0gKCBydW4gPj0gMCApID8gZ3JhcGhYUmFuZ2UubWF4IC0gcnVuIDogZ3JhcGhYUmFuZ2UubWF4O1xyXG4gICAgY29uc3QgeCA9IFV0aWxzLnJvdW5kU3ltbWV0cmljKCBtaW5YICsgKCBkb3RSYW5kb20ubmV4dERvdWJsZSgpICogKCBtYXhYIC0gbWluWCApICkgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHggPj0gbWluWCAmJiB4IDw9IG1heFgsIGB4IG91dCBvZiByYW5nZTogJHt4fWAgKTtcclxuXHJcbiAgICAvLyB5XHJcbiAgICBjb25zdCBtaW5ZID0gKCByaXNlID49IDAgKSA/IGdyYXBoWVJhbmdlLm1pbiA6IGdyYXBoWVJhbmdlLm1pbiAtIHJpc2U7XHJcbiAgICBjb25zdCBtYXhZID0gKCByaXNlID49IDAgKSA/IGdyYXBoWVJhbmdlLm1heCAtIHJpc2UgOiBncmFwaFlSYW5nZS5tYXg7XHJcbiAgICBjb25zdCB5ID0gVXRpbHMucm91bmRTeW1tZXRyaWMoIG1pblkgKyAoIGRvdFJhbmRvbS5uZXh0RG91YmxlKCkgKiAoIG1heFkgLSBtaW5ZICkgKSApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggeSA+PSBtaW5ZICYmIHkgPD0gbWF4WSwgYHkgb3V0IG9mIHJhbmdlOiAke3l9YCApO1xyXG5cclxuICAgIHJldHVybiBuZXcgVmVjdG9yMiggeCwgeSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGlja3MgYSBwb2ludCAoeDEseDIpIG9uIHRoZSBncmFwaCB0aGF0IHJlc3VsdHMgaW4gdGhlIHNsb3BlIGluZGljYXRvciAoeDIseTIpIGJlaW5nIG9mZiB0aGUgZ3JhcGguXHJcbiAgICogVGhpcyBmb3JjZXMgdGhlIHVzZXIgdG8gaW52ZXJ0IHRoZSBzbG9wZS5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgc3RhdGljIGNob29zZVBvaW50Rm9yU2xvcGVJbnZlcnNpb24oIHNsb3BlOiBGcmFjdGlvbiwgZ3JhcGhYUmFuZ2U6IFJhbmdlLCBncmFwaFlSYW5nZTogUmFuZ2UgKTogVmVjdG9yMiB7XHJcblxyXG4gICAgY29uc3QgcmlzZSA9IHNsb3BlLm51bWVyYXRvcjtcclxuICAgIGNvbnN0IHJ1biA9IHNsb3BlLmRlbm9taW5hdG9yO1xyXG5cclxuICAgIC8vIHgxIGNvb3JkaW5hdGVzXHJcbiAgICBjb25zdCBtaW5YMSA9ICggcnVuID49IDAgKSA/IGdyYXBoWFJhbmdlLm1heCAtIHJ1biArIDEgOiBncmFwaFhSYW5nZS5taW47XHJcbiAgICBjb25zdCBtYXhYMSA9ICggcnVuID49IDAgKSA/IGdyYXBoWFJhbmdlLm1heCA6IGdyYXBoWFJhbmdlLm1pbiAtIHJ1biAtIDE7XHJcbiAgICBjb25zdCB4MSA9IFV0aWxzLnJvdW5kU3ltbWV0cmljKCBtaW5YMSArICggZG90UmFuZG9tLm5leHREb3VibGUoKSAqICggbWF4WDEgLSBtaW5YMSApICkgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHgxID49IG1pblgxICYmIHgxIDw9IG1heFgxLCBgeDEgb3V0IG9mIHJhbmdlOiAke3gxfWAgKTtcclxuXHJcbiAgICAvLyB5MSBjb29yZGluYXRlc1xyXG4gICAgY29uc3QgbWluWTEgPSAoIHJpc2UgPj0gMCApID8gZ3JhcGhZUmFuZ2UubWF4IC0gcmlzZSArIDEgOiBncmFwaFlSYW5nZS5taW47XHJcbiAgICBjb25zdCBtYXhZMSA9ICggcmlzZSA+PSAwICkgPyBncmFwaFlSYW5nZS5tYXggOiBncmFwaFlSYW5nZS5taW4gLSByaXNlIC0gMTtcclxuICAgIGNvbnN0IHkxID0gVXRpbHMucm91bmRTeW1tZXRyaWMoIG1pblkxICsgKCBkb3RSYW5kb20ubmV4dERvdWJsZSgpICogKCBtYXhZMSAtIG1pblkxICkgKSApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggeTEgPj0gbWluWTEgJiYgeTEgPD0gbWF4WTEsIGB5MSBvdXQgb2YgcmFuZ2U6ICR7eTF9YCApO1xyXG5cclxuICAgIC8vIGNvbXB1dGUgKHgyLHkyKSBmb3IgdmFsaWRhdGlvblxyXG4gICAgY29uc3QgeDIgPSB4MSArIHJ1bjtcclxuICAgIGNvbnN0IHkyID0geTEgKyByaXNlO1xyXG5cclxuICAgIC8vICh4MSx5MSkgbXVzdCBiZSBvbiB0aGUgZ3JhcGgsICh4Mix5MikgbXVzdCBiZSBvZmYgdGhlIGdyYXBoXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBncmFwaFhSYW5nZS5jb250YWlucyggeDEgKSAmJiAhZ3JhcGhYUmFuZ2UuY29udGFpbnMoIHgyICkgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGdyYXBoWVJhbmdlLmNvbnRhaW5zKCB5MSApICYmICFncmFwaFlSYW5nZS5jb250YWlucyggeTIgKSApO1xyXG5cclxuICAgIHJldHVybiBuZXcgVmVjdG9yMiggeDEsIHkxICk7XHJcbiAgfVxyXG59XHJcblxyXG5ncmFwaGluZ0xpbmVzLnJlZ2lzdGVyKCAnQmFzZUNoYWxsZW5nZUZhY3RvcnknLCBCYXNlQ2hhbGxlbmdlRmFjdG9yeSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxTQUFTLE1BQU0saUNBQWlDO0FBQ3ZELE9BQU9DLEtBQUssTUFBTSw2QkFBNkI7QUFFL0MsT0FBT0MsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxPQUFPQyxTQUFTLE1BQU0sdUNBQXVDO0FBRTdELE9BQU9DLFdBQVcsTUFBTSw2QkFBNkI7QUFDckQsT0FBT0MsSUFBSSxNQUFNLDRCQUE0QjtBQUM3QyxPQUFPQyxhQUFhLE1BQU0sd0JBQXdCO0FBVWxELGVBQWUsTUFBZUMsb0JBQW9CLENBQUM7RUFLdkNDLFdBQVdBLENBQUVDLGVBQTZDLEVBQUc7SUFFckUsTUFBTUMsT0FBTyxHQUFHUCxTQUFTLENBQTJDLENBQUMsQ0FBRTtNQUNyRVEsTUFBTSxFQUFFUCxXQUFXLENBQUNRLFlBQVk7TUFDaENDLE1BQU0sRUFBRVQsV0FBVyxDQUFDVTtJQUN0QixDQUFDLEVBQUVMLGVBQWdCLENBQUM7SUFFcEIsSUFBSSxDQUFDRSxNQUFNLEdBQUdELE9BQU8sQ0FBQ0MsTUFBTTtJQUM1QixJQUFJLENBQUNFLE1BQU0sR0FBR0gsT0FBTyxDQUFDRyxNQUFNO0VBQzlCOztFQUVBO0FBQ0Y7QUFDQTs7RUFHRTtBQUNGO0FBQ0E7RUFDWUUsd0JBQXdCQSxDQUFFQyxLQUFlLEVBQUVDLFNBQWlCLEVBQVM7SUFDN0UsT0FBT1osSUFBSSxDQUFDYSxvQkFBb0IsQ0FBRUYsS0FBSyxDQUFDRyxTQUFTLEVBQUVILEtBQUssQ0FBQ0ksV0FBVyxFQUFFSCxTQUFVLENBQUM7RUFDbkY7O0VBRUE7QUFDRjtBQUNBO0VBQ1lJLG9CQUFvQkEsQ0FBRUMsS0FBYyxFQUFFTixLQUFlLEVBQVM7SUFDdEUsT0FBT1gsSUFBSSxDQUFDa0IsZ0JBQWdCLENBQUVELEtBQUssQ0FBQ0UsQ0FB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