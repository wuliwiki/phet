// Copyright 2013-2022, University of Colorado Boulder

/**
 * A drag handler for something that is movable and constrained to some (optional) bounds.
 * Copied from ph-scale\js\common\view\MovableDragHandler.js
 * Changes:
 * 1. Removed model view transform, this assumes nodes are moved directly
 * 2. Removed movable API, this class just moves nodes directly
 *
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Sam Reid (PhET Interactive Simulations)
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import merge from '../../../../phet-core/js/merge.js';
import { SimpleDragHandler } from '../../../../scenery/js/imports.js';
import fractionComparison from '../../fractionComparison.js';

/**
 * @deprecated - please use DragListener for new code
 */
class NodeDragHandler extends SimpleDragHandler {
  /**
   * @param {Node} node
   * @param {Object} [options]
   */
  constructor(node, options) {
    options = merge({
      startDrag: () => {},
      drag: () => {},
      endDrag: () => {/* do nothing */} // use this to do things at the end of dragging, like 'snapping'
    }, options);
    let startOffset; // where the drag started, relative to the Movable's origin, in parent view coordinates

    super({
      allowTouchSnag: true,
      // note where the drag started
      start: event => {
        startOffset = event.currentTarget.globalToParentPoint(event.pointer.point).minusXY(node.x, node.y);
        options.startDrag();
      },
      // change the position, adjust for starting offset, constrain to drag bounds
      drag: event => {
        const parentPoint = event.currentTarget.globalToParentPoint(event.pointer.point).minus(startOffset);
        const constrainedPosition = constrainBounds(parentPoint, options.dragBounds);
        node.setTranslation(constrainedPosition);
        options.drag(event);
      },
      end: event => {
        options.endDrag(event);
      }
    });
  }
}
fractionComparison.register('NodeDragHandler', NodeDragHandler);

/**
 * Constrains a point to some bounds.
 * @param {Vector2} point
 * @param {Bounds2} bounds
 */
const constrainBounds = (point, bounds) => {
  if (_.isUndefined(bounds) || bounds.containsCoordinates(point.x, point.y)) {
    return point;
  } else {
    const xConstrained = Math.max(Math.min(point.x, bounds.maxX), bounds.x);
    const yConstrained = Math.max(Math.min(point.y, bounds.maxY), bounds.y);
    return new Vector2(xConstrained, yConstrained);
  }
};
export default NodeDragHandler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwibWVyZ2UiLCJTaW1wbGVEcmFnSGFuZGxlciIsImZyYWN0aW9uQ29tcGFyaXNvbiIsIk5vZGVEcmFnSGFuZGxlciIsImNvbnN0cnVjdG9yIiwibm9kZSIsIm9wdGlvbnMiLCJzdGFydERyYWciLCJkcmFnIiwiZW5kRHJhZyIsInN0YXJ0T2Zmc2V0IiwiYWxsb3dUb3VjaFNuYWciLCJzdGFydCIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsImdsb2JhbFRvUGFyZW50UG9pbnQiLCJwb2ludGVyIiwicG9pbnQiLCJtaW51c1hZIiwieCIsInkiLCJwYXJlbnRQb2ludCIsIm1pbnVzIiwiY29uc3RyYWluZWRQb3NpdGlvbiIsImNvbnN0cmFpbkJvdW5kcyIsImRyYWdCb3VuZHMiLCJzZXRUcmFuc2xhdGlvbiIsImVuZCIsInJlZ2lzdGVyIiwiYm91bmRzIiwiXyIsImlzVW5kZWZpbmVkIiwiY29udGFpbnNDb29yZGluYXRlcyIsInhDb25zdHJhaW5lZCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJtYXhYIiwieUNvbnN0cmFpbmVkIiwibWF4WSJdLCJzb3VyY2VzIjpbIk5vZGVEcmFnSGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMy0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBBIGRyYWcgaGFuZGxlciBmb3Igc29tZXRoaW5nIHRoYXQgaXMgbW92YWJsZSBhbmQgY29uc3RyYWluZWQgdG8gc29tZSAob3B0aW9uYWwpIGJvdW5kcy5cclxuICogQ29waWVkIGZyb20gcGgtc2NhbGVcXGpzXFxjb21tb25cXHZpZXdcXE1vdmFibGVEcmFnSGFuZGxlci5qc1xyXG4gKiBDaGFuZ2VzOlxyXG4gKiAxLiBSZW1vdmVkIG1vZGVsIHZpZXcgdHJhbnNmb3JtLCB0aGlzIGFzc3VtZXMgbm9kZXMgYXJlIG1vdmVkIGRpcmVjdGx5XHJcbiAqIDIuIFJlbW92ZWQgbW92YWJsZSBBUEksIHRoaXMgY2xhc3MganVzdCBtb3ZlcyBub2RlcyBkaXJlY3RseVxyXG4gKlxyXG4gKiBAYXV0aG9yIENocmlzIE1hbGxleSAoUGl4ZWxab29tLCBJbmMuKVxyXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCB7IFNpbXBsZURyYWdIYW5kbGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IGZyYWN0aW9uQ29tcGFyaXNvbiBmcm9tICcuLi8uLi9mcmFjdGlvbkNvbXBhcmlzb24uanMnO1xyXG5cclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkIC0gcGxlYXNlIHVzZSBEcmFnTGlzdGVuZXIgZm9yIG5ldyBjb2RlXHJcbiAqL1xyXG5jbGFzcyBOb2RlRHJhZ0hhbmRsZXIgZXh0ZW5kcyBTaW1wbGVEcmFnSGFuZGxlciB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvciggbm9kZSwgb3B0aW9ucyApIHtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuICAgICAgc3RhcnREcmFnOiAoKSA9PiB7fSxcclxuICAgICAgZHJhZzogKCkgPT4ge30sXHJcbiAgICAgIGVuZERyYWc6ICgpID0+IHsgLyogZG8gbm90aGluZyAqLyB9ICAvLyB1c2UgdGhpcyB0byBkbyB0aGluZ3MgYXQgdGhlIGVuZCBvZiBkcmFnZ2luZywgbGlrZSAnc25hcHBpbmcnXHJcbiAgICB9LCBvcHRpb25zICk7XHJcblxyXG4gICAgbGV0IHN0YXJ0T2Zmc2V0OyAvLyB3aGVyZSB0aGUgZHJhZyBzdGFydGVkLCByZWxhdGl2ZSB0byB0aGUgTW92YWJsZSdzIG9yaWdpbiwgaW4gcGFyZW50IHZpZXcgY29vcmRpbmF0ZXNcclxuXHJcbiAgICBzdXBlcigge1xyXG5cclxuICAgICAgYWxsb3dUb3VjaFNuYWc6IHRydWUsXHJcblxyXG4gICAgICAvLyBub3RlIHdoZXJlIHRoZSBkcmFnIHN0YXJ0ZWRcclxuICAgICAgc3RhcnQ6IGV2ZW50ID0+IHtcclxuICAgICAgICBzdGFydE9mZnNldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2xvYmFsVG9QYXJlbnRQb2ludCggZXZlbnQucG9pbnRlci5wb2ludCApLm1pbnVzWFkoIG5vZGUueCwgbm9kZS55ICk7XHJcbiAgICAgICAgb3B0aW9ucy5zdGFydERyYWcoKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIGNoYW5nZSB0aGUgcG9zaXRpb24sIGFkanVzdCBmb3Igc3RhcnRpbmcgb2Zmc2V0LCBjb25zdHJhaW4gdG8gZHJhZyBib3VuZHNcclxuICAgICAgZHJhZzogZXZlbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBvaW50ID0gZXZlbnQuY3VycmVudFRhcmdldC5nbG9iYWxUb1BhcmVudFBvaW50KCBldmVudC5wb2ludGVyLnBvaW50ICkubWludXMoIHN0YXJ0T2Zmc2V0ICk7XHJcbiAgICAgICAgY29uc3QgY29uc3RyYWluZWRQb3NpdGlvbiA9IGNvbnN0cmFpbkJvdW5kcyggcGFyZW50UG9pbnQsIG9wdGlvbnMuZHJhZ0JvdW5kcyApO1xyXG4gICAgICAgIG5vZGUuc2V0VHJhbnNsYXRpb24oIGNvbnN0cmFpbmVkUG9zaXRpb24gKTtcclxuICAgICAgICBvcHRpb25zLmRyYWcoIGV2ZW50ICk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBlbmQ6IGV2ZW50ID0+IHtcclxuICAgICAgICBvcHRpb25zLmVuZERyYWcoIGV2ZW50ICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcbmZyYWN0aW9uQ29tcGFyaXNvbi5yZWdpc3RlciggJ05vZGVEcmFnSGFuZGxlcicsIE5vZGVEcmFnSGFuZGxlciApO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cmFpbnMgYSBwb2ludCB0byBzb21lIGJvdW5kcy5cclxuICogQHBhcmFtIHtWZWN0b3IyfSBwb2ludFxyXG4gKiBAcGFyYW0ge0JvdW5kczJ9IGJvdW5kc1xyXG4gKi9cclxuY29uc3QgY29uc3RyYWluQm91bmRzID0gKCBwb2ludCwgYm91bmRzICkgPT4ge1xyXG4gIGlmICggXy5pc1VuZGVmaW5lZCggYm91bmRzICkgfHwgYm91bmRzLmNvbnRhaW5zQ29vcmRpbmF0ZXMoIHBvaW50LngsIHBvaW50LnkgKSApIHtcclxuICAgIHJldHVybiBwb2ludDtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICBjb25zdCB4Q29uc3RyYWluZWQgPSBNYXRoLm1heCggTWF0aC5taW4oIHBvaW50LngsIGJvdW5kcy5tYXhYICksIGJvdW5kcy54ICk7XHJcbiAgICBjb25zdCB5Q29uc3RyYWluZWQgPSBNYXRoLm1heCggTWF0aC5taW4oIHBvaW50LnksIGJvdW5kcy5tYXhZICksIGJvdW5kcy55ICk7XHJcbiAgICByZXR1cm4gbmV3IFZlY3RvcjIoIHhDb25zdHJhaW5lZCwgeUNvbnN0cmFpbmVkICk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9kZURyYWdIYW5kbGVyO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsS0FBSyxNQUFNLG1DQUFtQztBQUNyRCxTQUFTQyxpQkFBaUIsUUFBUSxtQ0FBbUM7QUFDckUsT0FBT0Msa0JBQWtCLE1BQU0sNkJBQTZCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxlQUFlLFNBQVNGLGlCQUFpQixDQUFDO0VBRTlDO0FB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