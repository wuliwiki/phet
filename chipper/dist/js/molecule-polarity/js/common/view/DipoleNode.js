// Copyright 2014-2022, University of Colorado Boulder

/**
 * DipoleNode is the base class for the visual representation of 2D dipoles.
 * The dipole is created at (0,0) with proper length and orientation, and the subtype is responsible
 * for positioning the dipole.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Dimension2 from '../../../../dot/js/Dimension2.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import Vector2Property from '../../../../dot/js/Vector2Property.js';
import { Shape } from '../../../../kite/js/imports.js';
import optionize from '../../../../phet-core/js/optionize.js';
import { Path } from '../../../../scenery/js/imports.js';
import moleculePolarity from '../../moleculePolarity.js';
import MPConstants from '../MPConstants.js';

// constants
// Note: heights are parallel to dipole axis, widths are perpendicular.
const REFERENCE_MAGNITUDE = MPConstants.ELECTRONEGATIVITY_RANGE.getLength(); // model value
const REFERENCE_LENGTH = 135; // view size that corresponds to REFERENCE_MAGNITUDE
const HEAD_SIZE = new Dimension2(12, 20); // similar to Jmol
const CROSS_SIZE = new Dimension2(10, 10); // similar to Jmol
const REFERENCE_CROSS_OFFSET = 20; // offset from the tail of the arrow when arrow length is REFERENCE_LENGTH
const TAIL_WIDTH = 4; // similar to Jmol
const FRACTIONAL_HEAD_HEIGHT = 0.4; // when the head height is more than FRACTIONAL_HEAD_HEIGHT * length, a 'unit dipole' will be scaled.

export default class DipoleNode extends Path {
  referenceMagnitude = REFERENCE_MAGNITUDE;
  referenceLength = REFERENCE_LENGTH;
  constructor(dipoleProperty, providedOptions) {
    const options = optionize()({
      // PathOptions
      fill: 'black',
      stroke: 'black'
    }, providedOptions);
    super(null, options);
    dipoleProperty.link(dipole => {
      if (dipole.magnitude === 0) {
        this.shape = null;
      } else {
        // Determine parameters for the shape.
        const desiredLength = dipole.magnitude * (REFERENCE_LENGTH / REFERENCE_MAGNITUDE);
        let adjustedLength = desiredLength;
        let scale = 1;
        if (HEAD_SIZE.height > FRACTIONAL_HEAD_HEIGHT * desiredLength) {
          // We'll be drawing a unit dipole and scaling it.
          adjustedLength = HEAD_SIZE.height / FRACTIONAL_HEAD_HEIGHT;
          scale = desiredLength / adjustedLength;
        }
        const crossOffset = scale * REFERENCE_CROSS_OFFSET * adjustedLength / REFERENCE_LENGTH;
        const crossWidth = scale * CROSS_SIZE.width * adjustedLength / REFERENCE_LENGTH;

        // Draw a dipole that points from left to right, starting at upper-left end of tail and moving clockwise.
        this.shape = new Shape().moveTo(0, -TAIL_WIDTH / 2).lineTo(crossOffset, -TAIL_WIDTH / 2).lineTo(crossOffset, -CROSS_SIZE.height / 2).lineTo(crossOffset + crossWidth, -CROSS_SIZE.height / 2).lineTo(crossOffset + crossWidth, -TAIL_WIDTH / 2).lineTo(adjustedLength - HEAD_SIZE.height, -TAIL_WIDTH / 2).lineTo(adjustedLength - HEAD_SIZE.height, -HEAD_SIZE.width / 2).lineTo(adjustedLength, 0).lineTo(adjustedLength - HEAD_SIZE.height, HEAD_SIZE.width / 2).lineTo(adjustedLength - HEAD_SIZE.height, TAIL_WIDTH / 2).lineTo(crossOffset + crossWidth, TAIL_WIDTH / 2).lineTo(crossOffset + crossWidth, CROSS_SIZE.height / 2).lineTo(crossOffset, CROSS_SIZE.height / 2).lineTo(crossOffset, TAIL_WIDTH / 2).lineTo(0, TAIL_WIDTH / 2).close();

        // Adjust for proper scale and orientation.
        this.setScaleMagnitude(scale, scale);
        this.setRotation(dipole.angle);
      }
    });
  }
  dispose() {
    assert && assert(false, 'dispose is not supported, exists for the lifetime of the sim');
    super.dispose();
  }

  /**
   * Creates a dipole icon, with arrow pointing to the right.
   */
  static createIcon(options) {
    return new DipoleNode(new Vector2Property(new Vector2(0.65, 0)), options);
  }
}
moleculePolarity.register('DipoleNode', DipoleNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEaW1lbnNpb24yIiwiVmVjdG9yMiIsIlZlY3RvcjJQcm9wZXJ0eSIsIlNoYXBlIiwib3B0aW9uaXplIiwiUGF0aCIsIm1vbGVjdWxlUG9sYXJpdHkiLCJNUENvbnN0YW50cyIsIlJFRkVSRU5DRV9NQUdOSVRVREUiLCJFTEVDVFJPTkVHQVRJVklUWV9SQU5HRSIsImdldExlbmd0aCIsIlJFRkVSRU5DRV9MRU5HVEgiLCJIRUFEX1NJWkUiLCJDUk9TU19TSVpFIiwiUkVGRVJFTkNFX0NST1NTX09GRlNFVCIsIlRBSUxfV0lEVEgiLCJGUkFDVElPTkFMX0hFQURfSEVJR0hUIiwiRGlwb2xlTm9kZSIsInJlZmVyZW5jZU1hZ25pdHVkZSIsInJlZmVyZW5jZUxlbmd0aCIsImNvbnN0cnVjdG9yIiwiZGlwb2xlUHJvcGVydHkiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwiZmlsbCIsInN0cm9rZSIsImxpbmsiLCJkaXBvbGUiLCJtYWduaXR1ZGUiLCJzaGFwZSIsImRlc2lyZWRMZW5ndGgiLCJhZGp1c3RlZExlbmd0aCIsInNjYWxlIiwiaGVpZ2h0IiwiY3Jvc3NPZmZzZXQiLCJjcm9zc1dpZHRoIiwid2lkdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZSIsInNldFNjYWxlTWFnbml0dWRlIiwic2V0Um90YXRpb24iLCJhbmdsZSIsImRpc3Bvc2UiLCJhc3NlcnQiLCJjcmVhdGVJY29uIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJEaXBvbGVOb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE0LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIERpcG9sZU5vZGUgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIHRoZSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgMkQgZGlwb2xlcy5cclxuICogVGhlIGRpcG9sZSBpcyBjcmVhdGVkIGF0ICgwLDApIHdpdGggcHJvcGVyIGxlbmd0aCBhbmQgb3JpZW50YXRpb24sIGFuZCB0aGUgc3VidHlwZSBpcyByZXNwb25zaWJsZVxyXG4gKiBmb3IgcG9zaXRpb25pbmcgdGhlIGRpcG9sZS5cclxuICpcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBEaW1lbnNpb24yIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9EaW1lbnNpb24yLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgVmVjdG9yMlByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUsIHsgRW1wdHlTZWxmT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgUGlja09wdGlvbmFsIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9QaWNrT3B0aW9uYWwuanMnO1xyXG5pbXBvcnQgeyBOb2RlLCBQYXRoLCBQYXRoT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBtb2xlY3VsZVBvbGFyaXR5IGZyb20gJy4uLy4uL21vbGVjdWxlUG9sYXJpdHkuanMnO1xyXG5pbXBvcnQgTVBDb25zdGFudHMgZnJvbSAnLi4vTVBDb25zdGFudHMuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbi8vIE5vdGU6IGhlaWdodHMgYXJlIHBhcmFsbGVsIHRvIGRpcG9sZSBheGlzLCB3aWR0aHMgYXJlIHBlcnBlbmRpY3VsYXIuXHJcbmNvbnN0IFJFRkVSRU5DRV9NQUdOSVRVREUgPSBNUENvbnN0YW50cy5FTEVDVFJPTkVHQVRJVklUWV9SQU5HRS5nZXRMZW5ndGgoKTsgLy8gbW9kZWwgdmFsdWVcclxuY29uc3QgUkVGRVJFTkNFX0xFTkdUSCA9IDEzNTsgLy8gdmlldyBzaXplIHRoYXQgY29ycmVzcG9uZHMgdG8gUkVGRVJFTkNFX01BR05JVFVERVxyXG5jb25zdCBIRUFEX1NJWkUgPSBuZXcgRGltZW5zaW9uMiggMTIsIDIwICk7IC8vIHNpbWlsYXIgdG8gSm1vbFxyXG5jb25zdCBDUk9TU19TSVpFID0gbmV3IERpbWVuc2lvbjIoIDEwLCAxMCApOyAvLyBzaW1pbGFyIHRvIEptb2xcclxuY29uc3QgUkVGRVJFTkNFX0NST1NTX09GRlNFVCA9IDIwOyAvLyBvZmZzZXQgZnJvbSB0aGUgdGFpbCBvZiB0aGUgYXJyb3cgd2hlbiBhcnJvdyBsZW5ndGggaXMgUkVGRVJFTkNFX0xFTkdUSFxyXG5jb25zdCBUQUlMX1dJRFRIID0gNDsgLy8gc2ltaWxhciB0byBKbW9sXHJcbmNvbnN0IEZSQUNUSU9OQUxfSEVBRF9IRUlHSFQgPSAwLjQ7IC8vIHdoZW4gdGhlIGhlYWQgaGVpZ2h0IGlzIG1vcmUgdGhhbiBGUkFDVElPTkFMX0hFQURfSEVJR0hUICogbGVuZ3RoLCBhICd1bml0IGRpcG9sZScgd2lsbCBiZSBzY2FsZWQuXHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0gRW1wdHlTZWxmT3B0aW9ucztcclxuXHJcbmV4cG9ydCB0eXBlIERpcG9sZU5vZGVPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBQaWNrT3B0aW9uYWw8UGF0aE9wdGlvbnMsICd2aXNpYmxlUHJvcGVydHknIHwgJ2ZpbGwnPjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpcG9sZU5vZGUgZXh0ZW5kcyBQYXRoIHtcclxuXHJcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHJlZmVyZW5jZU1hZ25pdHVkZSA9IFJFRkVSRU5DRV9NQUdOSVRVREU7XHJcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHJlZmVyZW5jZUxlbmd0aCA9IFJFRkVSRU5DRV9MRU5HVEg7XHJcblxyXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvciggZGlwb2xlUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PFZlY3RvcjI+LCBwcm92aWRlZE9wdGlvbnM/OiBEaXBvbGVOb2RlT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPERpcG9sZU5vZGVPcHRpb25zLCBTZWxmT3B0aW9ucywgUGF0aE9wdGlvbnM+KCkoIHtcclxuXHJcbiAgICAgIC8vIFBhdGhPcHRpb25zXHJcbiAgICAgIGZpbGw6ICdibGFjaycsXHJcbiAgICAgIHN0cm9rZTogJ2JsYWNrJ1xyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgc3VwZXIoIG51bGwsIG9wdGlvbnMgKTtcclxuXHJcbiAgICBkaXBvbGVQcm9wZXJ0eS5saW5rKCBkaXBvbGUgPT4ge1xyXG4gICAgICBpZiAoIGRpcG9sZS5tYWduaXR1ZGUgPT09IDAgKSB7XHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBwYXJhbWV0ZXJzIGZvciB0aGUgc2hhcGUuXHJcbiAgICAgICAgY29uc3QgZGVzaXJlZExlbmd0aCA9IGRpcG9sZS5tYWduaXR1ZGUgKiAoIFJFRkVSRU5DRV9MRU5HVEggLyBSRUZFUkVOQ0VfTUFHTklUVURFICk7XHJcbiAgICAgICAgbGV0IGFkanVzdGVkTGVuZ3RoID0gZGVzaXJlZExlbmd0aDtcclxuICAgICAgICBsZXQgc2NhbGUgPSAxO1xyXG4gICAgICAgIGlmICggSEVBRF9TSVpFLmhlaWdodCA+IEZSQUNUSU9OQUxfSEVBRF9IRUlHSFQgKiBkZXNpcmVkTGVuZ3RoICkge1xyXG4gICAgICAgICAgLy8gV2UnbGwgYmUgZHJhd2luZyBhIHVuaXQgZGlwb2xlIGFuZCBzY2FsaW5nIGl0LlxyXG4gICAgICAgICAgYWRqdXN0ZWRMZW5ndGggPSBIRUFEX1NJWkUuaGVpZ2h0IC8gRlJBQ1RJT05BTF9IRUFEX0hFSUdIVDtcclxuICAgICAgICAgIHNjYWxlID0gZGVzaXJlZExlbmd0aCAvIGFkanVzdGVkTGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjcm9zc09mZnNldCA9IHNjYWxlICogUkVGRVJFTkNFX0NST1NTX09GRlNFVCAqIGFkanVzdGVkTGVuZ3RoIC8gUkVGRVJFTkNFX0xFTkdUSDtcclxuICAgICAgICBjb25zdCBjcm9zc1dpZHRoID0gc2NhbGUgKiBDUk9TU19TSVpFLndpZHRoICogYWRqdXN0ZWRMZW5ndGggLyBSRUZFUkVOQ0VfTEVOR1RIO1xyXG5cclxuICAgICAgICAvLyBEcmF3IGEgZGlwb2xlIHRoYXQgcG9pbnRzIGZyb20gbGVmdCB0byByaWdodCwgc3RhcnRpbmcgYXQgdXBwZXItbGVmdCBlbmQgb2YgdGFpbCBhbmQgbW92aW5nIGNsb2Nrd2lzZS5cclxuICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFNoYXBlKClcclxuICAgICAgICAgIC5tb3ZlVG8oIDAsIC1UQUlMX1dJRFRIIC8gMiApXHJcbiAgICAgICAgICAubGluZVRvKCBjcm9zc09mZnNldCwgLVRBSUxfV0lEVEggLyAyIClcclxuICAgICAgICAgIC5saW5lVG8oIGNyb3NzT2Zmc2V0LCAtQ1JPU1NfU0laRS5oZWlnaHQgLyAyIClcclxuICAgICAgICAgIC5saW5lVG8oIGNyb3NzT2Zmc2V0ICsgY3Jvc3NXaWR0aCwgLUNST1NTX1NJWkUuaGVpZ2h0IC8gMiApXHJcbiAgICAgICAgICAubGluZVRvKCBjcm9zc09mZnNldCArIGNyb3NzV2lkdGgsIC1UQUlMX1dJRFRIIC8gMiApXHJcbiAgICAgICAgICAubGluZVRvKCBhZGp1c3RlZExlbmd0aCAtIEhFQURfU0laRS5oZWlnaHQsIC1UQUlMX1dJRFRIIC8gMiApXHJcbiAgICAgICAgICAubGluZVRvKCBhZGp1c3RlZExlbmd0aCAtIEhFQURfU0laRS5oZWlnaHQsIC1IRUFEX1NJWkUud2lkdGggLyAyIClcclxuICAgICAgICAgIC5saW5lVG8oIGFkanVzdGVkTGVuZ3RoLCAwIClcclxuICAgICAgICAgIC5saW5lVG8oIGFkanVzdGVkTGVuZ3RoIC0gSEVBRF9TSVpFLmhlaWdodCwgSEVBRF9TSVpFLndpZHRoIC8gMiApXHJcbiAgICAgICAgICAubGluZVRvKCBhZGp1c3RlZExlbmd0aCAtIEhFQURfU0laRS5oZWlnaHQsIFRBSUxfV0lEVEggLyAyIClcclxuICAgICAgICAgIC5saW5lVG8oIGNyb3NzT2Zmc2V0ICsgY3Jvc3NXaWR0aCwgVEFJTF9XSURUSCAvIDIgKVxyXG4gICAgICAgICAgLmxpbmVUbyggY3Jvc3NPZmZzZXQgKyBjcm9zc1dpZHRoLCBDUk9TU19TSVpFLmhlaWdodCAvIDIgKVxyXG4gICAgICAgICAgLmxpbmVUbyggY3Jvc3NPZmZzZXQsIENST1NTX1NJWkUuaGVpZ2h0IC8gMiApXHJcbiAgICAgICAgICAubGluZVRvKCBjcm9zc09mZnNldCwgVEFJTF9XSURUSCAvIDIgKVxyXG4gICAgICAgICAgLmxpbmVUbyggMCwgVEFJTF9XSURUSCAvIDIgKVxyXG4gICAgICAgICAgLmNsb3NlKCk7XHJcblxyXG4gICAgICAgIC8vIEFkanVzdCBmb3IgcHJvcGVyIHNjYWxlIGFuZCBvcmllbnRhdGlvbi5cclxuICAgICAgICB0aGlzLnNldFNjYWxlTWFnbml0dWRlKCBzY2FsZSwgc2NhbGUgKTtcclxuICAgICAgICB0aGlzLnNldFJvdGF0aW9uKCBkaXBvbGUuYW5nbGUgKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ2Rpc3Bvc2UgaXMgbm90IHN1cHBvcnRlZCwgZXhpc3RzIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbScgKTtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBkaXBvbGUgaWNvbiwgd2l0aCBhcnJvdyBwb2ludGluZyB0byB0aGUgcmlnaHQuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIHN0YXRpYyBjcmVhdGVJY29uKCBvcHRpb25zPzogRGlwb2xlTm9kZU9wdGlvbnMgKTogTm9kZSB7XHJcbiAgICByZXR1cm4gbmV3IERpcG9sZU5vZGUoIG5ldyBWZWN0b3IyUHJvcGVydHkoIG5ldyBWZWN0b3IyKCAwLjY1LCAwICkgKSwgb3B0aW9ucyApO1xyXG4gIH1cclxufVxyXG5cclxubW9sZWN1bGVQb2xhcml0eS5yZWdpc3RlciggJ0RpcG9sZU5vZGUnLCBEaXBvbGVOb2RlICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQSxPQUFPQSxVQUFVLE1BQU0sa0NBQWtDO0FBQ3pELE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsZUFBZSxNQUFNLHVDQUF1QztBQUNuRSxTQUFTQyxLQUFLLFFBQVEsZ0NBQWdDO0FBQ3RELE9BQU9DLFNBQVMsTUFBNEIsdUNBQXVDO0FBRW5GLFNBQWVDLElBQUksUUFBcUIsbUNBQW1DO0FBQzNFLE9BQU9DLGdCQUFnQixNQUFNLDJCQUEyQjtBQUN4RCxPQUFPQyxXQUFXLE1BQU0sbUJBQW1COztBQUUzQztBQUNBO0FBQ0EsTUFBTUMsbUJBQW1CLEdBQUdELFdBQVcsQ0FBQ0UsdUJBQXVCLENBQUNDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3RSxNQUFNQyxnQkFBZ0IsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUM5QixNQUFNQyxTQUFTLEdBQUcsSUFBSVosVUFBVSxDQUFFLEVBQUUsRUFBRSxFQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzVDLE1BQU1hLFVBQVUsR0FBRyxJQUFJYixVQUFVLENBQUUsRUFBRSxFQUFFLEVBQUcsQ0FBQyxDQUFDLENBQUM7QUFDN0MsTUFB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