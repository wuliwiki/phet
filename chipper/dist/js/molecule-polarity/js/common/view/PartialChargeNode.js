// Copyright 2014-2022, University of Colorado Boulder

/**
 * Visual representations of partial charge, a delta symbol followed by either + or -.
 * Controls its own position in global coordinates, so clients should not attempt to position it.
 * Uses static factory methods to supply the needed instances for the sim.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import PhetFont from '../../../../scenery-phet/js/PhetFont.js';
import { Node, Text } from '../../../../scenery/js/imports.js';
import moleculePolarity from '../../moleculePolarity.js';
import MoleculePolarityStrings from '../../MoleculePolarityStrings.js';
import MPConstants from '../MPConstants.js';
import DerivedProperty from '../../../../axon/js/DerivedProperty.js';

// constants
const REFERENCE_MAGNITUDE = MPConstants.ELECTRONEGATIVITY_RANGE.getLength();
const REFERENCE_SCALE = 1;
export default class PartialChargeNode extends Node {
  constructor(atom, unitVectorFunction, providedOptions) {
    super(providedOptions);
    const stringProperty = new DerivedProperty([atom.partialChargeProperty, MoleculePolarityStrings.deltaPlusStringProperty, MoleculePolarityStrings.deltaMinusStringProperty], (partialCharge, deltaPlusString, deltaMinusString) => partialCharge > 0 ? deltaPlusString : deltaMinusString);

    // labelText has a maxWidth for i18n. Then wrap chargeNode, so that we can scale it.
    const labelText = new Text(stringProperty, {
      font: new PhetFont(32),
      fill: 'black',
      maxWidth: 50
    });
    const chargeNode = new Node({
      children: [labelText]
    });
    this.addChild(chargeNode);
    this.update = () => {
      const partialCharge = atom.partialChargeProperty.value;

      // invisible if dipole is zero
      const partialChargeVisible = partialCharge !== 0;
      labelText.visible = partialChargeVisible;

      // Only update if the partial charge is visible
      if (partialChargeVisible) {
        // size proportional to bond dipole magnitude
        const scale = Math.abs(REFERENCE_SCALE * partialCharge / REFERENCE_MAGNITUDE);
        if (scale !== 0) {
          chargeNode.setScaleMagnitude(scale);
          chargeNode.centerX = 0;
          chargeNode.centerY = 0;
        }

        // A vector that points in the direction we will need to move the charge node.
        const unitVector = unitVectorFunction();

        // Compute the amount to move the partial charge node
        const multiplier = atom.diameter / 2 + Math.max(this.width, this.height) / 2 + 3;
        const relativeOffset = unitVector.timesScalar(multiplier);
        this.translation = atom.positionProperty.value.plus(relativeOffset);
      }
    };

    // Changing any of these Properties requires an update.
    atom.partialChargeProperty.link(this.update.bind(this));
    atom.positionProperty.link(this.update.bind(this));
    labelText.boundsProperty.link(this.update.bind(this));

    // Update when this Node becomes visible
    this.visibleProperty.link(visible => visible && this.update());
  }
  dispose() {
    assert && assert(false, 'dispose is not supported, exists for the lifetime of the sim');
    super.dispose();
  }

  /**
   * Partial charge for an atom that participates in a single bond.
   * It's partial charge is the opposite of the charge of the other atom in the bond.
   * The charge is placed along the axis of the bond, away from the atom.
   */
  static createOppositePartialChargeNode(atom, bond, options) {
    return new PartialChargeNode(atom, () => {
      // along the bond axis, in the direction of the atom
      let v = atom.positionProperty.value.minus(bond.getCenter());

      /*
       * Avoid the case where pressing Reset All causes the atoms to swap positions, temporarily resulting
       * in a zero-magnitude vector when the first atom has moved but the second atom hasn't moved yet.
       * This sorts itthis out when both atoms have moved.
       */
      if (v.magnitude > 0) {
        v = v.normalize();
      }
      return v;
    }, options);
  }

  /**
   * Partial charge for an atom that participates in more than one bond.
   * Its partial charge is the composite of charges contributed by other atoms in the bonds.
   * The charge is placed along the axis of the molecular dipole, on the opposite side of the atom from the dipole.
   */
  static createCompositePartialChargeNode(atom, molecule, options) {
    const node = new PartialChargeNode(atom, () => {
      if (molecule.dipoleProperty.value.magnitude > 0) {
        return molecule.dipoleProperty.value.rotated(Math.PI).normalize();
      } else {
        // can't normalize a zero-magnitude vector, so create our own with the proper angle
        return new Vector2(1, molecule.dipoleProperty.value.angle);
      }
    }, options);
    molecule.dipoleProperty.link(node.update.bind(this));
    return node;
  }
}
moleculePolarity.register('PartialChargeNode', PartialChargeNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiUGhldEZvbnQiLCJOb2RlIiwiVGV4dCIsIm1vbGVjdWxlUG9sYXJpdHkiLCJNb2xlY3VsZVBvbGFyaXR5U3RyaW5ncyIsIk1QQ29uc3RhbnRzIiwiRGVyaXZlZFByb3BlcnR5IiwiUkVGRVJFTkNFX01BR05JVFVERSIsIkVMRUNUUk9ORUdBVElWSVRZX1JBTkdFIiwiZ2V0TGVuZ3RoIiwiUkVGRVJFTkNFX1NDQUxFIiwiUGFydGlhbENoYXJnZU5vZGUiLCJjb25zdHJ1Y3RvciIsImF0b20iLCJ1bml0VmVjdG9yRnVuY3Rpb24iLCJwcm92aWRlZE9wdGlvbnMiLCJzdHJpbmdQcm9wZXJ0eSIsInBhcnRpYWxDaGFyZ2VQcm9wZXJ0eSIsImRlbHRhUGx1c1N0cmluZ1Byb3BlcnR5IiwiZGVsdGFNaW51c1N0cmluZ1Byb3BlcnR5IiwicGFydGlhbENoYXJnZSIsImRlbHRhUGx1c1N0cmluZyIsImRlbHRhTWludXNTdHJpbmciLCJsYWJlbFRleHQiLCJmb250IiwiZmlsbCIsIm1heFdpZHRoIiwiY2hhcmdlTm9kZSIsImNoaWxkcmVuIiwiYWRkQ2hpbGQiLCJ1cGRhdGUiLCJ2YWx1ZSIsInBhcnRpYWxDaGFyZ2VWaXNpYmxlIiwidmlzaWJsZSIsInNjYWxlIiwiTWF0aCIsImFicyIsInNldFNjYWxlTWFnbml0dWRlIiwiY2VudGVyWCIsImNlbnRlclkiLCJ1bml0VmVjdG9yIiwibXVsdGlwbGllciIsImRpYW1ldGVyIiwibWF4Iiwid2lkdGgiLCJoZWlnaHQiLCJyZWxhdGl2ZU9mZnNldCIsInRpbWVzU2NhbGFyIiwidHJhbnNsYXRpb24iLCJwb3NpdGlvblByb3BlcnR5IiwicGx1cyIsImxpbmsiLCJiaW5kIiwiYm91bmRzUHJvcGVydHkiLCJ2aXNpYmxlUHJvcGVydHkiLCJkaXNwb3NlIiwiYXNzZXJ0IiwiY3JlYXRlT3Bwb3NpdGVQYXJ0aWFsQ2hhcmdlTm9kZSIsImJvbmQiLCJvcHRpb25zIiwidiIsIm1pbnVzIiwiZ2V0Q2VudGVyIiwibWFnbml0dWRlIiwibm9ybWFsaXplIiwiY3JlYXRlQ29tcG9zaXRlUGFydGlhbENoYXJnZU5vZGUiLCJtb2xlY3VsZSIsIm5vZGUiLCJkaXBvbGVQcm9wZXJ0eSIsInJvdGF0ZWQiLCJQSSIsImFuZ2xlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJQYXJ0aWFsQ2hhcmdlTm9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNC0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBWaXN1YWwgcmVwcmVzZW50YXRpb25zIG9mIHBhcnRpYWwgY2hhcmdlLCBhIGRlbHRhIHN5bWJvbCBmb2xsb3dlZCBieSBlaXRoZXIgKyBvciAtLlxyXG4gKiBDb250cm9scyBpdHMgb3duIHBvc2l0aW9uIGluIGdsb2JhbCBjb29yZGluYXRlcywgc28gY2xpZW50cyBzaG91bGQgbm90IGF0dGVtcHQgdG8gcG9zaXRpb24gaXQuXHJcbiAqIFVzZXMgc3RhdGljIGZhY3RvcnkgbWV0aG9kcyB0byBzdXBwbHkgdGhlIG5lZWRlZCBpbnN0YW5jZXMgZm9yIHRoZSBzaW0uXHJcbiAqXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqL1xyXG5cclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBFbXB0eVNlbGZPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBQaWNrT3B0aW9uYWwgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL1BpY2tPcHRpb25hbC5qcyc7XHJcbmltcG9ydCBQaGV0Rm9udCBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvUGhldEZvbnQuanMnO1xyXG5pbXBvcnQgeyBOb2RlLCBOb2RlT3B0aW9ucywgVGV4dCB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBtb2xlY3VsZVBvbGFyaXR5IGZyb20gJy4uLy4uL21vbGVjdWxlUG9sYXJpdHkuanMnO1xyXG5pbXBvcnQgTW9sZWN1bGVQb2xhcml0eVN0cmluZ3MgZnJvbSAnLi4vLi4vTW9sZWN1bGVQb2xhcml0eVN0cmluZ3MuanMnO1xyXG5pbXBvcnQgQXRvbSBmcm9tICcuLi9tb2RlbC9BdG9tLmpzJztcclxuaW1wb3J0IEJvbmQgZnJvbSAnLi4vbW9kZWwvQm9uZC5qcyc7XHJcbmltcG9ydCBNUENvbnN0YW50cyBmcm9tICcuLi9NUENvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBNb2xlY3VsZSBmcm9tICcuLi9tb2RlbC9Nb2xlY3VsZS5qcyc7XHJcbmltcG9ydCBEZXJpdmVkUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9EZXJpdmVkUHJvcGVydHkuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IFJFRkVSRU5DRV9NQUdOSVRVREUgPSBNUENvbnN0YW50cy5FTEVDVFJPTkVHQVRJVklUWV9SQU5HRS5nZXRMZW5ndGgoKTtcclxuY29uc3QgUkVGRVJFTkNFX1NDQUxFID0gMTtcclxuXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSBFbXB0eVNlbGZPcHRpb25zO1xyXG5cclxudHlwZSBQYXJ0aWFsQ2hhcmdlTm9kZU9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIFBpY2tPcHRpb25hbDxOb2RlT3B0aW9ucywgJ3Zpc2libGVQcm9wZXJ0eSc+O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydGlhbENoYXJnZU5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgcHJpdmF0ZSByZWFkb25seSB1cGRhdGU6ICgpID0+IHZvaWQ7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggYXRvbTogQXRvbSwgdW5pdFZlY3RvckZ1bmN0aW9uOiAoKSA9PiBWZWN0b3IyLCBwcm92aWRlZE9wdGlvbnM/OiBQYXJ0aWFsQ2hhcmdlTm9kZU9wdGlvbnMgKSB7XHJcblxyXG4gICAgc3VwZXIoIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIGNvbnN0IHN0cmluZ1Byb3BlcnR5ID0gbmV3IERlcml2ZWRQcm9wZXJ0eSggW1xyXG4gICAgICAgIGF0b20ucGFydGlhbENoYXJnZVByb3BlcnR5LFxyXG4gICAgICAgIE1vbGVjdWxlUG9sYXJpdHlTdHJpbmdzLmRlbHRhUGx1c1N0cmluZ1Byb3BlcnR5LFxyXG4gICAgICAgIE1vbGVjdWxlUG9sYXJpdHlTdHJpbmdzLmRlbHRhTWludXNTdHJpbmdQcm9wZXJ0eVxyXG4gICAgICBdLCAoIHBhcnRpYWxDaGFyZ2U6IG51bWJlciwgZGVsdGFQbHVzU3RyaW5nOiBzdHJpbmcsIGRlbHRhTWludXNTdHJpbmc6IHN0cmluZyApID0+XHJcbiAgICAgICAgKCBwYXJ0aWFsQ2hhcmdlID4gMCApID8gZGVsdGFQbHVzU3RyaW5nIDogZGVsdGFNaW51c1N0cmluZ1xyXG4gICAgKTtcclxuXHJcbiAgICAvLyBsYWJlbFRleHQgaGFzIGEgbWF4V2lkdGggZm9yIGkxOG4uIFRoZW4gd3JhcCBjaGFyZ2VOb2RlLCBzbyB0aGF0IHdlIGNhbiBzY2FsZSBpdC5cclxuICAgIGNvbnN0IGxhYmVsVGV4dCA9IG5ldyBUZXh0KCBzdHJpbmdQcm9wZXJ0eSwge1xyXG4gICAgICBmb250OiBuZXcgUGhldEZvbnQoIDMyICksXHJcbiAgICAgIGZpbGw6ICdibGFjaycsXHJcbiAgICAgIG1heFdpZHRoOiA1MFxyXG4gICAgfSApO1xyXG4gICAgY29uc3QgY2hhcmdlTm9kZSA9IG5ldyBOb2RlKCB7XHJcbiAgICAgIGNoaWxkcmVuOiBbIGxhYmVsVGV4dCBdXHJcbiAgICB9ICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCBjaGFyZ2VOb2RlICk7XHJcblxyXG4gICAgdGhpcy51cGRhdGUgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHBhcnRpYWxDaGFyZ2UgPSBhdG9tLnBhcnRpYWxDaGFyZ2VQcm9wZXJ0eS52YWx1ZTtcclxuXHJcbiAgICAgIC8vIGludmlzaWJsZSBpZiBkaXBvbGUgaXMgemVyb1xyXG4gICAgICBjb25zdCBwYXJ0aWFsQ2hhcmdlVmlzaWJsZSA9ICggcGFydGlhbENoYXJnZSAhPT0gMCApO1xyXG5cclxuICAgICAgbGFiZWxUZXh0LnZpc2libGUgPSBwYXJ0aWFsQ2hhcmdlVmlzaWJsZTtcclxuXHJcbiAgICAgIC8vIE9ubHkgdXBkYXRlIGlmIHRoZSBwYXJ0aWFsIGNoYXJnZSBpcyB2aXNpYmxlXHJcbiAgICAgIGlmICggcGFydGlhbENoYXJnZVZpc2libGUgKSB7XHJcblxyXG4gICAgICAgIC8vIHNpemUgcHJvcG9ydGlvbmFsIHRvIGJvbmQgZGlwb2xlIG1hZ25pdHVkZVxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5hYnMoIFJFRkVSRU5DRV9TQ0FMRSAqIHBhcnRpYWxDaGFyZ2UgLyBSRUZFUkVOQ0VfTUFHTklUVURFICk7XHJcbiAgICAgICAgaWYgKCBzY2FsZSAhPT0gMCApIHtcclxuICAgICAgICAgIGNoYXJnZU5vZGUuc2V0U2NhbGVNYWduaXR1ZGUoIHNjYWxlICk7XHJcbiAgICAgICAgICBjaGFyZ2VOb2RlLmNlbnRlclggPSAwO1xyXG4gICAgICAgICAgY2hhcmdlTm9kZS5jZW50ZXJZID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEEgdmVjdG9yIHRoYXQgcG9pbnRzIGluIHRoZSBkaXJlY3Rpb24gd2Ugd2lsbCBuZWVkIHRvIG1vdmUgdGhlIGNoYXJnZSBub2RlLlxyXG4gICAgICAgIGNvbnN0IHVuaXRWZWN0b3IgPSB1bml0VmVjdG9yRnVuY3Rpb24oKTtcclxuXHJcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYW1vdW50IHRvIG1vdmUgdGhlIHBhcnRpYWwgY2hhcmdlIG5vZGVcclxuICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gKCBhdG9tLmRpYW1ldGVyIC8gMiApICsgKCBNYXRoLm1heCggdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQgKSAvIDIgKSArIDM7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVPZmZzZXQgPSB1bml0VmVjdG9yLnRpbWVzU2NhbGFyKCBtdWx0aXBsaWVyICk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvbiA9IGF0b20ucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS5wbHVzKCByZWxhdGl2ZU9mZnNldCApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENoYW5naW5nIGFueSBvZiB0aGVzZSBQcm9wZXJ0aWVzIHJlcXVpcmVzIGFuIHVwZGF0ZS5cclxuICAgIGF0b20ucGFydGlhbENoYXJnZVByb3BlcnR5LmxpbmsoIHRoaXMudXBkYXRlLmJpbmQoIHRoaXMgKSApO1xyXG4gICAgYXRvbS5wb3NpdGlvblByb3BlcnR5LmxpbmsoIHRoaXMudXBkYXRlLmJpbmQoIHRoaXMgKSApO1xyXG4gICAgbGFiZWxUZXh0LmJvdW5kc1Byb3BlcnR5LmxpbmsoIHRoaXMudXBkYXRlLmJpbmQoIHRoaXMgKSApO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB3aGVuIHRoaXMgTm9kZSBiZWNvbWVzIHZpc2libGVcclxuICAgIHRoaXMudmlzaWJsZVByb3BlcnR5LmxpbmsoIHZpc2libGUgPT4gdmlzaWJsZSAmJiB0aGlzLnVwZGF0ZSgpICk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCAnZGlzcG9zZSBpcyBub3Qgc3VwcG9ydGVkLCBleGlzdHMgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgc2ltJyApO1xyXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFydGlhbCBjaGFyZ2UgZm9yIGFuIGF0b20gdGhhdCBwYXJ0aWNpcGF0ZXMgaW4gYSBzaW5nbGUgYm9uZC5cclxuICAgKiBJdCdzIHBhcnRpYWwgY2hhcmdlIGlzIHRoZSBvcHBvc2l0ZSBvZiB0aGUgY2hhcmdlIG9mIHRoZSBvdGhlciBhdG9tIGluIHRoZSBib25kLlxyXG4gICAqIFRoZSBjaGFyZ2UgaXMgcGxhY2VkIGFsb25nIHRoZSBheGlzIG9mIHRoZSBib25kLCBhd2F5IGZyb20gdGhlIGF0b20uXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVPcHBvc2l0ZVBhcnRpYWxDaGFyZ2VOb2RlKCBhdG9tOiBBdG9tLCBib25kOiBCb25kLCBvcHRpb25zPzogUGFydGlhbENoYXJnZU5vZGVPcHRpb25zICk6IE5vZGUge1xyXG4gICAgcmV0dXJuIG5ldyBQYXJ0aWFsQ2hhcmdlTm9kZSggYXRvbSwgKCkgPT4ge1xyXG5cclxuICAgICAgLy8gYWxvbmcgdGhlIGJvbmQgYXhpcywgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgYXRvbVxyXG4gICAgICBsZXQgdiA9IGF0b20ucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS5taW51cyggYm9uZC5nZXRDZW50ZXIoKSApO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICogQXZvaWQgdGhlIGNhc2Ugd2hlcmUgcHJlc3NpbmcgUmVzZXQgQWxsIGNhdXNlcyB0aGUgYXRvbXMgdG8gc3dhcCBwb3NpdGlvbnMsIHRlbXBvcmFyaWx5IHJlc3VsdGluZ1xyXG4gICAgICAgKiBpbiBhIHplcm8tbWFnbml0dWRlIHZlY3RvciB3aGVuIHRoZSBmaXJzdCBhdG9tIGhhcyBtb3ZlZCBidXQgdGhlIHNlY29uZCBhdG9tIGhhc24ndCBtb3ZlZCB5ZXQuXHJcbiAgICAgICAqIFRoaXMgc29ydHMgaXR0aGlzIG91dCB3aGVuIGJvdGggYXRvbXMgaGF2ZSBtb3ZlZC5cclxuICAgICAgICovXHJcbiAgICAgIGlmICggdi5tYWduaXR1ZGUgPiAwICkge1xyXG4gICAgICAgIHYgPSB2Lm5vcm1hbGl6ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2O1xyXG4gICAgfSwgb3B0aW9ucyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFydGlhbCBjaGFyZ2UgZm9yIGFuIGF0b20gdGhhdCBwYXJ0aWNpcGF0ZXMgaW4gbW9yZSB0aGFuIG9uZSBib25kLlxyXG4gICAqIEl0cyBwYXJ0aWFsIGNoYXJnZSBpcyB0aGUgY29tcG9zaXRlIG9mIGNoYXJnZXMgY29udHJpYnV0ZWQgYnkgb3RoZXIgYXRvbXMgaW4gdGhlIGJvbmRzLlxyXG4gICAqIFRoZSBjaGFyZ2UgaXMgcGxhY2VkIGFsb25nIHRoZSBheGlzIG9mIHRoZSBtb2xlY3VsYXIgZGlwb2xlLCBvbiB0aGUgb3Bwb3NpdGUgc2lkZSBvZiB0aGUgYXRvbSBmcm9tIHRoZSBkaXBvbGUuXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVDb21wb3NpdGVQYXJ0aWFsQ2hhcmdlTm9kZSggYXRvbTogQXRvbSwgbW9sZWN1bGU6IE1vbGVjdWxlLCBvcHRpb25zPzogUGFydGlhbENoYXJnZU5vZGVPcHRpb25zICk6IE5vZGUge1xyXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBQYXJ0aWFsQ2hhcmdlTm9kZSggYXRvbSwgKCkgPT4ge1xyXG4gICAgICBpZiAoIG1vbGVjdWxlLmRpcG9sZVByb3BlcnR5LnZhbHVlLm1hZ25pdHVkZSA+IDAgKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbGVjdWxlLmRpcG9sZVByb3BlcnR5LnZhbHVlLnJvdGF0ZWQoIE1hdGguUEkgKS5ub3JtYWxpemUoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyBjYW4ndCBub3JtYWxpemUgYSB6ZXJvLW1hZ25pdHVkZSB2ZWN0b3IsIHNvIGNyZWF0ZSBvdXIgb3duIHdpdGggdGhlIHByb3BlciBhbmdsZVxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMiggMSwgbW9sZWN1bGUuZGlwb2xlUHJvcGVydHkudmFsdWUuYW5nbGUgKTtcclxuICAgICAgfVxyXG4gICAgfSwgb3B0aW9ucyApO1xyXG4gICAgbW9sZWN1bGUuZGlwb2xlUHJvcGVydHkubGluayggbm9kZS51cGRhdGUuYmluZCggdGhpcyApICk7XHJcbiAgICByZXR1cm4gbm9kZTtcclxuICB9XHJcbn1cclxuXHJcbm1vbGVjdWxlUG9sYXJpdHkucmVnaXN0ZXIoICdQYXJ0aWFsQ2hhcmdlTm9kZScsIFBhcnRpYWxDaGFyZ2VOb2RlICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxPQUFPLE1BQU0sK0JBQStCO0FBR25ELE9BQU9DLFFBQVEsTUFBTSx5Q0FBeUM7QUFDOUQsU0FBU0MsSUFBSSxFQUFlQyxJQUFJLFFBQVEsbUNBQW1DO0FBQzNFLE9BQU9DLGdCQUFnQixNQUFNLDJCQUEyQjtBQUN4RCxPQUFPQyx1QkFBdUIsTUFBTSxrQ0FBa0M7QUFHdEUsT0FBT0MsV0FBVyxNQUFNLG1CQUFtQjtBQUUzQyxPQUFPQyxlQUFlLE1BQU0sd0NBQXdDOztBQUVwRTtBQUNBLE1BQU1DLG1CQUFtQixHQUFHRixXQUFXLENBQUNHLHVCQUF1QixDQUFDQyxTQUFTLENBQUMsQ0FBQztBQUMzRSxNQUFNQyxlQUFlLEdBQUcsQ0FBQztBQU16QixlQUFlLE1BQU1DLGlCQUFpQixTQUFTVixJQUFJLENBQUM7RUFJM0NXLFdBQVdBLENBQUVDLElBQVUsRUFBRUMsa0JBQWlDLEVBQUVDLGVBQTBDLEVBQUc7SUFFOUcsS0FBSyxDQUFFQSxlQUFnQixDQUFDO0lBRXhCLE1BQU1DLGNBQWMsR0FBRyxJQUFJVixlQUFlLENBQUUsQ0FDeENPLElBQUksQ0FBQ0kscUJBQXFCLEVBQzFCYix1QkFBdUIsQ0FBQ2MsdUJBQXVCLEVBQy9DZCx1QkFBdUIsQ0FBQ2Usd0JBQXdCLENBQ2pELEVBQUUsQ0FBRUMsYUFBcUIsRUFBRUMsZUFBdUIsRUFBRUMsZ0JBQXdCLEtBQ3pFRixhQUFhLEdBQUcsQ0FBQyxHQUFLQyxlQUFlLEdBQUdDLGdCQUM5QyxDQUFDOztJQUVEO0lBQ0EsTUFBTUMsU0FBUyxHQUFHLElBQUlyQixJQUFJLENBQUVjLGNBQWMsRUFBRTtNQUMxQ1EsSUFBSSxFQUFFLElBQUl4QixRQUFRLENBQUUsRUFBRyxDQUFD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