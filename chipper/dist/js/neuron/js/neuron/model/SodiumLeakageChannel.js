// Copyright 2014-2021, University of Colorado Boulder

/**
 * Model representation of a membrane channel through which sodium 'leaks', meaning that it is always passing through
 * and there is no gating action.
 *
 * @author John Blanco
 * @author Sharfudeen Ashraf (for Ghent University)
 */

import dotRandom from '../../../../dot/js/dotRandom.js';
import { Color } from '../../../../scenery/js/imports.js';
import neuron from '../../neuron.js';
import MathUtils from '../common/MathUtils.js';
import NeuronConstants from '../common/NeuronConstants.js';
import AbstractLeakChannel from './AbstractLeakChannel.js';
import MembraneChannelTypes from './MembraneChannelTypes.js';
import MembraneCrossingDirection from './MembraneCrossingDirection.js';
import ParticleType from './ParticleType.js';
import PieSliceShapedCaptureZone from './PieSliceShapedCaptureZone.js';

// constants
const CHANNEL_HEIGHT = NeuronConstants.MEMBRANE_THICKNESS * 1.2; // In nanometers.
const CHANNEL_WIDTH = NeuronConstants.MEMBRANE_THICKNESS * 0.50; // In nanometers.
const BASE_COLOR = Color.interpolateRGBA(NeuronConstants.SODIUM_COLOR, Color.YELLOW, 0.5);
const DEFAULT_PARTICLE_VELOCITY = 7000; // In nanometers per sec of sim time.

// Controls the rate of leakage when no action potential is occurring.
// Higher values mean more leakage, with 1 as the max.
const NOMINAL_LEAK_LEVEL = 0.005;

// A scaling factor that is used to normalize the amount of leak channel
// current to a value between 0 and 1.  This value was determined by
// testing the Hodgkin-Huxley model.
const PEAK_NEGATIVE_CURRENT = 3.44;
class SodiumLeakageChannel extends AbstractLeakChannel {
  /**
   * @param {number} channelWidth
   * @param {NeuronModel} modelContainingParticles
   * @param {ModifiedHodgkinHuxleyModel} hodgkinHuxleyModel
   */
  constructor(modelContainingParticles, hodgkinHuxleyModel) {
    super(CHANNEL_WIDTH, CHANNEL_HEIGHT, modelContainingParticles);
    this.previousNormalizedLeakCurrent = 0;
    this.hodgkinHuxleyModel = hodgkinHuxleyModel;

    // Set the speed at which particles will move through the channel.
    this.setParticleVelocity(DEFAULT_PARTICLE_VELOCITY);

    // Set up the capture zones for this channel.
    this.setExteriorCaptureZone(new PieSliceShapedCaptureZone(this.getCenterPosition(), CHANNEL_WIDTH * 5, 0, Math.PI * 0.6));
    this.setInteriorCaptureZone(new PieSliceShapedCaptureZone(this.getCenterPosition(), CHANNEL_WIDTH * 5, Math.PI, Math.PI * 0.8));

    // Update the capture times.
    this.updateParticleCaptureRate(NOMINAL_LEAK_LEVEL);
    this.channelColor = BASE_COLOR.colorUtilsDarker(0.15);

    // Start the capture timer now, since leak channels are always
    // capturing particles.
    this.restartCaptureCountdownTimer(false);
  }

  // @public, @override
  stepInTime(dt) {
    const prevOpenness = this.openness;
    const prevInActivationAmt = this.inactivationAmount;
    super.stepInTime(dt);
    // Since this is a leak channel, it is always open, so the openness
    // is not updated as it is for the gated channels.  However, we DO
    // want more sodium to flow through when the leak current in the
    // HH model goes up, so the following code accomplishes that goal.

    let normalizedLeakCurrent = MathUtils.round(this.hodgkinHuxleyModel.get_l_current() / PEAK_NEGATIVE_CURRENT, 2);
    if (normalizedLeakCurrent <= 0.01) {
      // Only pay attention to negative values for the current, which
      // we will map to sodium flow back into the cell.  This is a
      // bit of hollywooding.
      normalizedLeakCurrent = Math.max(normalizedLeakCurrent, -1);
      if (normalizedLeakCurrent !== this.previousNormalizedLeakCurrent) {
        this.previousNormalizedLeakCurrent = normalizedLeakCurrent;
        this.updateParticleCaptureRate(Math.max(Math.abs(normalizedLeakCurrent), NOMINAL_LEAK_LEVEL));
      }
    }
    this.notifyIfMembraneStateChanged(prevOpenness, prevInActivationAmt);
  }

  // @public, @override
  getChannelColor() {
    return this.channelColor;
  }

  // @public, @override
  getEdgeColor() {
    return BASE_COLOR;
  }

  // @public, @override
  getParticleTypeToCapture() {
    return ParticleType.SODIUM_ION;
  }

  // @public, @override
  chooseCrossingDirection() {
    let result = MembraneCrossingDirection.OUT_TO_IN;
    if (this.previousNormalizedLeakCurrent === 0) {
      // The cell is idle, not recovering from an action potential, so
      // everyone once in a while a sodium atom should leak the opposite
      // direction.  This was requested by the IPHY people in the review
      // held mid-April 2010.
      if (dotRandom.nextDouble() < 0.2) {
        result = MembraneCrossingDirection.IN_TO_OUT;
      }
    }
    return result;
  }

  // @public, @override
  getChannelType() {
    return MembraneChannelTypes.SODIUM_LEAKAGE_CHANNEL;
  }

  /**
   * Update the rate of particle capture based on the supplied normalized value.
   * @param {number} normalizedRate - A value between 0 and 1 where 0 represents the minimum capture rate for
   * particles and 1 represents the max.
   * @private
   */
  updateParticleCaptureRate(normalizedRate) {
    if (normalizedRate <= 0.001) {
      // No captures at this rate.
      this.setMinInterCaptureTime(Number.POSITIVE_INFINITY);
      this.setMaxInterCaptureTime(Number.POSITIVE_INFINITY);
      this.restartCaptureCountdownTimer(false);
    } else {
      // Tweak the following values for different behavior.
      const absoluteMinInterCaptureTime = 0.0002;
      const variableMinInterCaptureTime = 0.002;
      const captureTimeRange = 0.005;
      const minInterCaptureTime = absoluteMinInterCaptureTime + (1 - normalizedRate) * variableMinInterCaptureTime;
      this.setMinInterCaptureTime(minInterCaptureTime);
      this.setMaxInterCaptureTime(minInterCaptureTime + (1 - normalizedRate) * captureTimeRange);
      if (this.getCaptureCountdownTimer() > this.getMaxInterCaptureTime()) {
        // Only restart the capture countdown if the current values is
        // higher than the max.
        this.restartCaptureCountdownTimer(false);
      }
    }
  }
}
neuron.register('SodiumLeakageChannel', SodiumLeakageChannel);
export default SodiumLeakageChannel;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3RSYW5kb20iLCJDb2xvciIsIm5ldXJvbiIsIk1hdGhVdGlscyIsIk5ldXJvbkNvbnN0YW50cyIsIkFic3RyYWN0TGVha0NoYW5uZWwiLCJNZW1icmFuZUNoYW5uZWxUeXBlcyIsIk1lbWJyYW5lQ3Jvc3NpbmdEaXJlY3Rpb24iLCJQYXJ0aWNsZVR5cGUiLCJQaWVTbGljZVNoYXBlZENhcHR1cmVab25lIiwiQ0hBTk5FTF9IRUlHSFQiLCJNRU1CUkFORV9USElDS05FU1MiLCJDSEFOTkVMX1dJRFRIIiwiQkFTRV9DT0xPUiIsImludGVycG9sYXRlUkdCQSIsIlNPRElVTV9DT0xPUiIsIllFTExPVyIsIkRFRkFVTFRfUEFSVElDTEVfVkVMT0NJVFkiLCJOT01JTkFMX0xFQUtfTEVWRUwiLCJQRUFLX05FR0FUSVZFX0NVUlJFTlQiLCJTb2RpdW1MZWFrYWdlQ2hhbm5lbCIsImNvbnN0cnVjdG9yIiwibW9kZWxDb250YWluaW5nUGFydGljbGVzIiwiaG9kZ2tpbkh1eGxleU1vZGVsIiwicHJldmlvdXNOb3JtYWxpemVkTGVha0N1cnJlbnQiLCJzZXRQYXJ0aWNsZVZlbG9jaXR5Iiwic2V0RXh0ZXJpb3JDYXB0dXJlWm9uZSIsImdldENlbnRlclBvc2l0aW9uIiwiTWF0aCIsIlBJIiwic2V0SW50ZXJpb3JDYXB0dXJlWm9uZSIsInVwZGF0ZVBhcnRpY2xlQ2FwdHVyZVJhdGUiLCJjaGFubmVsQ29sb3IiLCJjb2xvclV0aWxzRGFya2VyIiwicmVzdGFydENhcHR1cmVDb3VudGRvd25UaW1lciIsInN0ZXBJblRpbWUiLCJkdCIsInByZXZPcGVubmVzcyIsIm9wZW5uZXNzIiwicHJldkluQWN0aXZhdGlvbkFtdCIsImluYWN0aXZhdGlvbkFtb3VudCIsIm5vcm1hbGl6ZWRMZWFrQ3VycmVudCIsInJvdW5kIiwiZ2V0X2xfY3VycmVudCIsIm1heCIsImFicyIsIm5vdGlmeUlmTWVtYnJhbmVTdGF0ZUNoYW5nZWQiLCJnZXRDaGFubmVsQ29sb3IiLCJnZXRFZGdlQ29sb3IiLCJnZXRQYXJ0aWNsZVR5cGVUb0NhcHR1cmUiLCJTT0RJVU1fSU9OIiwiY2hvb3NlQ3Jvc3NpbmdEaXJlY3Rpb24iLCJyZXN1bHQiLCJPVVRfVE9fSU4iLCJuZXh0RG91YmxlIiwiSU5fVE9fT1VUIiwiZ2V0Q2hhbm5lbFR5cGUiLCJTT0RJVU1fTEVBS0FHRV9DSEFOTkVMIiwibm9ybWFsaXplZFJhdGUiLCJzZXRNaW5JbnRlckNhcHR1cmVUaW1lIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJzZXRNYXhJbnRlckNhcHR1cmVUaW1lIiwiYWJzb2x1dGVNaW5JbnRlckNhcHR1cmVUaW1lIiwidmFyaWFibGVNaW5JbnRlckNhcHR1cmVUaW1lIiwiY2FwdHVyZVRpbWVSYW5nZSIsIm1pbkludGVyQ2FwdHVyZVRpbWUiLCJnZXRDYXB0dXJlQ291bnRkb3duVGltZXIiLCJnZXRNYXhJbnRlckNhcHR1cmVUaW1lIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJTb2RpdW1MZWFrYWdlQ2hhbm5lbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNC0yMDIxLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBNb2RlbCByZXByZXNlbnRhdGlvbiBvZiBhIG1lbWJyYW5lIGNoYW5uZWwgdGhyb3VnaCB3aGljaCBzb2RpdW0gJ2xlYWtzJywgbWVhbmluZyB0aGF0IGl0IGlzIGFsd2F5cyBwYXNzaW5nIHRocm91Z2hcclxuICogYW5kIHRoZXJlIGlzIG5vIGdhdGluZyBhY3Rpb24uXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICogQGF1dGhvciBTaGFyZnVkZWVuIEFzaHJhZiAoZm9yIEdoZW50IFVuaXZlcnNpdHkpXHJcbiAqL1xyXG5cclxuaW1wb3J0IGRvdFJhbmRvbSBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvZG90UmFuZG9tLmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgbmV1cm9uIGZyb20gJy4uLy4uL25ldXJvbi5qcyc7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnLi4vY29tbW9uL01hdGhVdGlscy5qcyc7XHJcbmltcG9ydCBOZXVyb25Db25zdGFudHMgZnJvbSAnLi4vY29tbW9uL05ldXJvbkNvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBBYnN0cmFjdExlYWtDaGFubmVsIGZyb20gJy4vQWJzdHJhY3RMZWFrQ2hhbm5lbC5qcyc7XHJcbmltcG9ydCBNZW1icmFuZUNoYW5uZWxUeXBlcyBmcm9tICcuL01lbWJyYW5lQ2hhbm5lbFR5cGVzLmpzJztcclxuaW1wb3J0IE1lbWJyYW5lQ3Jvc3NpbmdEaXJlY3Rpb24gZnJvbSAnLi9NZW1icmFuZUNyb3NzaW5nRGlyZWN0aW9uLmpzJztcclxuaW1wb3J0IFBhcnRpY2xlVHlwZSBmcm9tICcuL1BhcnRpY2xlVHlwZS5qcyc7XHJcbmltcG9ydCBQaWVTbGljZVNoYXBlZENhcHR1cmVab25lIGZyb20gJy4vUGllU2xpY2VTaGFwZWRDYXB0dXJlWm9uZS5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgQ0hBTk5FTF9IRUlHSFQgPSBOZXVyb25Db25zdGFudHMuTUVNQlJBTkVfVEhJQ0tORVNTICogMS4yOyAvLyBJbiBuYW5vbWV0ZXJzLlxyXG5jb25zdCBDSEFOTkVMX1dJRFRIID0gTmV1cm9uQ29uc3RhbnRzLk1FTUJSQU5FX1RISUNLTkVTUyAqIDAuNTA7IC8vIEluIG5hbm9tZXRlcnMuXHJcbmNvbnN0IEJBU0VfQ09MT1IgPSBDb2xvci5pbnRlcnBvbGF0ZVJHQkEoIE5ldXJvbkNvbnN0YW50cy5TT0RJVU1fQ09MT1IsIENvbG9yLllFTExPVywgMC41ICk7XHJcbmNvbnN0IERFRkFVTFRfUEFSVElDTEVfVkVMT0NJVFkgPSA3MDAwOyAvLyBJbiBuYW5vbWV0ZXJzIHBlciBzZWMgb2Ygc2ltIHRpbWUuXHJcblxyXG4vLyBDb250cm9scyB0aGUgcmF0ZSBvZiBsZWFrYWdlIHdoZW4gbm8gYWN0aW9uIHBvdGVudGlhbCBpcyBvY2N1cnJpbmcuXHJcbi8vIEhpZ2hlciB2YWx1ZXMgbWVhbiBtb3JlIGxlYWthZ2UsIHdpdGggMSBhcyB0aGUgbWF4LlxyXG5jb25zdCBOT01JTkFMX0xFQUtfTEVWRUwgPSAwLjAwNTtcclxuXHJcbi8vIEEgc2NhbGluZyBmYWN0b3IgdGhhdCBpcyB1c2VkIHRvIG5vcm1hbGl6ZSB0aGUgYW1vdW50IG9mIGxlYWsgY2hhbm5lbFxyXG4vLyBjdXJyZW50IHRvIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiAgVGhpcyB2YWx1ZSB3YXMgZGV0ZXJtaW5lZCBieVxyXG4vLyB0ZXN0aW5nIHRoZSBIb2Rna2luLUh1eGxleSBtb2RlbC5cclxuY29uc3QgUEVBS19ORUdBVElWRV9DVVJSRU5UID0gMy40NDtcclxuXHJcbmNsYXNzIFNvZGl1bUxlYWthZ2VDaGFubmVsIGV4dGVuZHMgQWJzdHJhY3RMZWFrQ2hhbm5lbCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsV2lkdGhcclxuICAgKiBAcGFyYW0ge05ldXJvbk1vZGVsfSBtb2RlbENvbnRhaW5pbmdQYXJ0aWNsZXNcclxuICAgKiBAcGFyYW0ge01vZGlmaWVkSG9kZ2tpbkh1eGxleU1vZGVsfSBob2Rna2luSHV4bGV5TW9kZWxcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggbW9kZWxDb250YWluaW5nUGFydGljbGVzLCBob2Rna2luSHV4bGV5TW9kZWwgKSB7XHJcbiAgICBzdXBlciggQ0hBTk5FTF9XSURUSCwgQ0hBTk5FTF9IRUlHSFQsIG1vZGVsQ29udGFpbmluZ1BhcnRpY2xlcyApO1xyXG4gICAgdGhpcy5wcmV2aW91c05vcm1hbGl6ZWRMZWFrQ3VycmVudCA9IDA7XHJcbiAgICB0aGlzLmhvZGdraW5IdXhsZXlNb2RlbCA9IGhvZGdraW5IdXhsZXlNb2RlbDtcclxuXHJcbiAgICAvLyBTZXQgdGhlIHNwZWVkIGF0IHdoaWNoIHBhcnRpY2xlcyB3aWxsIG1vdmUgdGhyb3VnaCB0aGUgY2hhbm5lbC5cclxuICAgIHRoaXMuc2V0UGFydGljbGVWZWxvY2l0eSggREVGQVVMVF9QQVJUSUNMRV9WRUxPQ0lUWSApO1xyXG5cclxuICAgIC8vIFNldCB1cCB0aGUgY2FwdHVyZSB6b25lcyBmb3IgdGhpcyBjaGFubmVsLlxyXG4gICAgdGhpcy5zZXRFeHRlcmlvckNhcHR1cmVab25lKCBuZXcgUGllU2xpY2VTaGFwZWRDYXB0dXJlWm9uZSggdGhpcy5nZXRDZW50ZXJQb3NpdGlvbigpLCBDSEFOTkVMX1dJRFRIICogNSwgMCwgTWF0aC5QSSAqIDAuNiApICk7XHJcbiAgICB0aGlzLnNldEludGVyaW9yQ2FwdHVyZVpvbmUoIG5ldyBQaWVTbGljZVNoYXBlZENhcHR1cmVab25lKCB0aGlzLmdldENlbnRlclBvc2l0aW9uKCksIENIQU5ORUxfV0lEVEggKiA1LCBNYXRoLlBJLCBNYXRoLlBJICogMC44ICkgKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIGNhcHR1cmUgdGltZXMuXHJcbiAgICB0aGlzLnVwZGF0ZVBhcnRpY2xlQ2FwdHVyZVJhdGUoIE5PTUlOQUxfTEVBS19MRVZFTCApO1xyXG4gICAgdGhpcy5jaGFubmVsQ29sb3IgPSBCQVNFX0NPTE9SLmNvbG9yVXRpbHNEYXJrZXIoIDAuMTUgKTtcclxuXHJcbiAgICAvLyBTdGFydCB0aGUgY2FwdHVyZSB0aW1lciBub3csIHNpbmNlIGxlYWsgY2hhbm5lbHMgYXJlIGFsd2F5c1xyXG4gICAgLy8gY2FwdHVyaW5nIHBhcnRpY2xlcy5cclxuICAgIHRoaXMucmVzdGFydENhcHR1cmVDb3VudGRvd25UaW1lciggZmFsc2UgKTtcclxuICB9XHJcblxyXG4gIC8vIEBwdWJsaWMsIEBvdmVycmlkZVxyXG4gIHN0ZXBJblRpbWUoIGR0ICkge1xyXG4gICAgY29uc3QgcHJldk9wZW5uZXNzID0gdGhpcy5vcGVubmVzcztcclxuICAgIGNvbnN0IHByZXZJbkFjdGl2YXRpb25BbXQgPSB0aGlzLmluYWN0aXZhdGlvbkFtb3VudDtcclxuXHJcbiAgICBzdXBlci5zdGVwSW5UaW1lKCBkdCApO1xyXG4gICAgLy8gU2luY2UgdGhpcyBpcyBhIGxlYWsgY2hhbm5lbCwgaXQgaXMgYWx3YXlzIG9wZW4sIHNvIHRoZSBvcGVubmVzc1xyXG4gICAgLy8gaXMgbm90IHVwZGF0ZWQgYXMgaXQgaXMgZm9yIHRoZSBnYXRlZCBjaGFubmVscy4gIEhvd2V2ZXIsIHdlIERPXHJcbiAgICAvLyB3YW50IG1vcmUgc29kaXVtIHRvIGZsb3cgdGhyb3VnaCB3aGVuIHRoZSBsZWFrIGN1cnJlbnQgaW4gdGhlXHJcbiAgICAvLyBISCBtb2RlbCBnb2VzIHVwLCBzbyB0aGUgZm9sbG93aW5nIGNvZGUgYWNjb21wbGlzaGVzIHRoYXQgZ29hbC5cclxuXHJcbiAgICBsZXQgbm9ybWFsaXplZExlYWtDdXJyZW50ID0gTWF0aFV0aWxzLnJvdW5kKCB0aGlzLmhvZGdraW5IdXhsZXlNb2RlbC5nZXRfbF9jdXJyZW50KCkgLyBQRUFLX05FR0FUSVZFX0NVUlJFTlQsIDIgKTtcclxuICAgIGlmICggbm9ybWFsaXplZExlYWtDdXJyZW50IDw9IDAuMDEgKSB7XHJcbiAgICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBuZWdhdGl2ZSB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50LCB3aGljaFxyXG4gICAgICAvLyB3ZSB3aWxsIG1hcCB0byBzb2RpdW0gZmxvdyBiYWNrIGludG8gdGhlIGNlbGwuICBUaGlzIGlzIGFcclxuICAgICAgLy8gYml0IG9mIGhvbGx5d29vZGluZy5cclxuICAgICAgbm9ybWFsaXplZExlYWtDdXJyZW50ID0gTWF0aC5tYXgoIG5vcm1hbGl6ZWRMZWFrQ3VycmVudCwgLTEgKTtcclxuICAgICAgaWYgKCBub3JtYWxpemVkTGVha0N1cnJlbnQgIT09IHRoaXMucHJldmlvdXNOb3JtYWxpemVkTGVha0N1cnJlbnQgKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c05vcm1hbGl6ZWRMZWFrQ3VycmVudCA9IG5vcm1hbGl6ZWRMZWFrQ3VycmVudDtcclxuICAgICAgICB0aGlzLnVwZGF0ZVBhcnRpY2xlQ2FwdHVyZVJhdGUoIE1hdGgubWF4KCBNYXRoLmFicyggbm9ybWFsaXplZExlYWtDdXJyZW50ICksIE5PTUlOQUxfTEVBS19MRVZFTCApICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm5vdGlmeUlmTWVtYnJhbmVTdGF0ZUNoYW5nZWQoIHByZXZPcGVubmVzcywgcHJldkluQWN0aXZhdGlvbkFtdCApO1xyXG4gIH1cclxuXHJcbiAgLy8gQHB1YmxpYywgQG92ZXJyaWRlXHJcbiAgZ2V0Q2hhbm5lbENvbG9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbENvbG9yO1xyXG4gIH1cclxuXHJcbiAgLy8gQHB1YmxpYywgQG92ZXJyaWRlXHJcbiAgZ2V0RWRnZUNvbG9yKCkge1xyXG4gICAgcmV0dXJuIEJBU0VfQ09MT1I7XHJcbiAgfVxyXG5cclxuICAvLyBAcHVibGljLCBAb3ZlcnJpZGVcclxuICBnZXRQYXJ0aWNsZVR5cGVUb0NhcHR1cmUoKSB7XHJcbiAgICByZXR1cm4gUGFydGljbGVUeXBlLlNPRElVTV9JT047XHJcbiAgfVxyXG5cclxuICAvLyBAcHVibGljLCBAb3ZlcnJpZGVcclxuICBjaG9vc2VDcm9zc2luZ0RpcmVjdGlvbigpIHtcclxuICAgIGxldCByZXN1bHQgPSBNZW1icmFuZUNyb3NzaW5nRGlyZWN0aW9uLk9VVF9UT19JTjtcclxuICAgIGlmICggdGhpcy5wcmV2aW91c05vcm1hbGl6ZWRMZWFrQ3VycmVudCA9PT0gMCApIHtcclxuICAgICAgLy8gVGhlIGNlbGwgaXMgaWRsZSwgbm90IHJlY292ZXJpbmcgZnJvbSBhbiBhY3Rpb24gcG90ZW50aWFsLCBzb1xyXG4gICAgICAvLyBldmVyeW9uZSBvbmNlIGluIGEgd2hpbGUgYSBzb2RpdW0gYXRvbSBzaG91bGQgbGVhayB0aGUgb3Bwb3NpdGVcclxuICAgICAgLy8gZGlyZWN0aW9uLiAgVGhpcyB3YXMgcmVxdWVzdGVkIGJ5IHRoZSBJUEhZIHBlb3BsZSBpbiB0aGUgcmV2aWV3XHJcbiAgICAgIC8vIGhlbGQgbWlkLUFwcmlsIDIwMTAuXHJcbiAgICAgIGlmICggZG90UmFuZG9tLm5leHREb3VibGUoKSA8IDAuMiApIHtcclxuICAgICAgICByZXN1bHQgPSBNZW1icmFuZUNyb3NzaW5nRGlyZWN0aW9uLklOX1RPX09VVDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8vIEBwdWJsaWMsIEBvdmVycmlkZVxyXG4gIGdldENoYW5uZWxUeXBlKCkge1xyXG4gICAgcmV0dXJuIE1lbWJyYW5lQ2hhbm5lbFR5cGVzLlNPRElVTV9MRUFLQUdFX0NIQU5ORUw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIHJhdGUgb2YgcGFydGljbGUgY2FwdHVyZSBiYXNlZCBvbiB0aGUgc3VwcGxpZWQgbm9ybWFsaXplZCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFJhdGUgLSBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMSB3aGVyZSAwIHJlcHJlc2VudHMgdGhlIG1pbmltdW0gY2FwdHVyZSByYXRlIGZvclxyXG4gICAqIHBhcnRpY2xlcyBhbmQgMSByZXByZXNlbnRzIHRoZSBtYXguXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICB1cGRhdGVQYXJ0aWNsZUNhcHR1cmVSYXRlKCBub3JtYWxpemVkUmF0ZSApIHtcclxuICAgIGlmICggbm9ybWFsaXplZFJhdGUgPD0gMC4wMDEgKSB7XHJcbiAgICAgIC8vIE5vIGNhcHR1cmVzIGF0IHRoaXMgcmF0ZS5cclxuICAgICAgdGhpcy5zZXRNaW5JbnRlckNhcHR1cmVUaW1lKCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgKTtcclxuICAgICAgdGhpcy5zZXRNYXhJbnRlckNhcHR1cmVUaW1lKCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgKTtcclxuICAgICAgdGhpcy5yZXN0YXJ0Q2FwdHVyZUNvdW50ZG93blRpbWVyKCBmYWxzZSApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIFR3ZWFrIHRoZSBmb2xsb3dpbmcgdmFsdWVzIGZvciBkaWZmZXJlbnQgYmVoYXZpb3IuXHJcbiAgICAgIGNvbnN0IGFic29sdXRlTWluSW50ZXJDYXB0dXJlVGltZSA9IDAuMDAwMjtcclxuICAgICAgY29uc3QgdmFyaWFibGVNaW5JbnRlckNhcHR1cmVUaW1lID0gMC4wMDI7XHJcbiAgICAgIGNvbnN0IGNhcHR1cmVUaW1lUmFuZ2UgPSAwLjAwNTtcclxuICAgICAgY29uc3QgbWluSW50ZXJDYXB0dXJlVGltZSA9IGFic29sdXRlTWluSW50ZXJDYXB0dXJlVGltZSArICggMSAtIG5vcm1hbGl6ZWRSYXRlICkgKiAoIHZhcmlhYmxlTWluSW50ZXJDYXB0dXJlVGltZSApO1xyXG4gICAgICB0aGlzLnNldE1pbkludGVyQ2FwdHVyZVRpbWUoIG1pbkludGVyQ2FwdHVyZVRpbWUgKTtcclxuICAgICAgdGhpcy5zZXRNYXhJbnRlckNhcHR1cmVUaW1lKCBtaW5JbnRlckNhcHR1cmVUaW1lICsgKCAxIC0gbm9ybWFsaXplZFJhdGUgKSAqIGNhcHR1cmVUaW1lUmFuZ2UgKTtcclxuXHJcbiAgICAgIGlmICggdGhpcy5nZXRDYXB0dXJlQ291bnRkb3duVGltZXIoKSA+IHRoaXMuZ2V0TWF4SW50ZXJDYXB0dXJlVGltZSgpICkge1xyXG4gICAgICAgIC8vIE9ubHkgcmVzdGFydCB0aGUgY2FwdHVyZSBjb3VudGRvd24gaWYgdGhlIGN1cnJlbnQgdmFsdWVzIGlzXHJcbiAgICAgICAgLy8gaGlnaGVyIHRoYW4gdGhlIG1heC5cclxuICAgICAgICB0aGlzLnJlc3RhcnRDYXB0dXJlQ291bnRkb3duVGltZXIoIGZhbHNlICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm5ldXJvbi5yZWdpc3RlciggJ1NvZGl1bUxlYWthZ2VDaGFubmVsJywgU29kaXVtTGVha2FnZUNo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