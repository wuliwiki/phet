// Copyright 2014-2020, University of Colorado Boulder
/**
 * This is a very specialized motion strategy that is basically a linear motion but that starts at one speed and then
 * changes to another.  It was created for a specific application - getting particles to move quickly away from the exit
 * of a channel with an inactivation gate, and then slowing down.  It may have other applications.
 *
 * @author John Blanco
 * @author Sharfudeen Ashraf (for Ghent University)
 */

import neuron from '../../neuron.js';
import MotionStrategy from './MotionStrategy.js';
class SpeedChangeLinearMotionStrategy extends MotionStrategy {
  /**
   * @param {Vector2} initialVelocity
   * @param {number} speedScaleFactor
   * @param {number} timeAtFirstSpeed
   */
  constructor(initialVelocity, speedScaleFactor, timeAtFirstSpeed) {
    super();
    this.velocityVectorX = initialVelocity.x;
    this.velocityVectorY = initialVelocity.y;
    this.speedScaleFactor = speedScaleFactor;
    this.firstSpeedCountdownTimer = timeAtFirstSpeed;
  }

  // @public, @override
  move(movable, fadableModelElement, dt) {
    movable.setPosition(movable.getPositionX() + this.velocityVectorX * dt, movable.getPositionY() + this.velocityVectorY * dt);
    if (this.firstSpeedCountdownTimer > 0) {
      this.firstSpeedCountdownTimer -= dt;
      if (this.firstSpeedCountdownTimer <= 0) {
        // Scale the speed.
        this.velocityVectorX = this.velocityVectorX * this.speedScaleFactor;
        this.velocityVectorY = this.velocityVectorY * this.speedScaleFactor;
      }
    }
  }
}
neuron.register('SpeedChangeLinearMotionStrategy', SpeedChangeLinearMotionStrategy);
export default SpeedChangeLinearMotionStrategy;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJuZXVyb24iLCJNb3Rpb25TdHJhdGVneSIsIlNwZWVkQ2hhbmdlTGluZWFyTW90aW9uU3RyYXRlZ3kiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxWZWxvY2l0eSIsInNwZWVkU2NhbGVGYWN0b3IiLCJ0aW1lQXRGaXJzdFNwZWVkIiwidmVsb2NpdHlWZWN0b3JYIiwieCIsInZlbG9jaXR5VmVjdG9yWSIsInkiLCJmaXJzdFNwZWVkQ291bnRkb3duVGltZXIiLCJtb3ZlIiwibW92YWJsZSIsImZhZGFibGVNb2RlbEVsZW1lbnQiLCJkdCIsInNldFBvc2l0aW9uIiwiZ2V0UG9zaXRpb25YIiwiZ2V0UG9zaXRpb25ZIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJTcGVlZENoYW5nZUxpbmVhck1vdGlvblN0cmF0ZWd5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE0LTIwMjAsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG4vKipcclxuICogVGhpcyBpcyBhIHZlcnkgc3BlY2lhbGl6ZWQgbW90aW9uIHN0cmF0ZWd5IHRoYXQgaXMgYmFzaWNhbGx5IGEgbGluZWFyIG1vdGlvbiBidXQgdGhhdCBzdGFydHMgYXQgb25lIHNwZWVkIGFuZCB0aGVuXHJcbiAqIGNoYW5nZXMgdG8gYW5vdGhlci4gIEl0IHdhcyBjcmVhdGVkIGZvciBhIHNwZWNpZmljIGFwcGxpY2F0aW9uIC0gZ2V0dGluZyBwYXJ0aWNsZXMgdG8gbW92ZSBxdWlja2x5IGF3YXkgZnJvbSB0aGUgZXhpdFxyXG4gKiBvZiBhIGNoYW5uZWwgd2l0aCBhbiBpbmFjdGl2YXRpb24gZ2F0ZSwgYW5kIHRoZW4gc2xvd2luZyBkb3duLiAgSXQgbWF5IGhhdmUgb3RoZXIgYXBwbGljYXRpb25zLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvXHJcbiAqIEBhdXRob3IgU2hhcmZ1ZGVlbiBBc2hyYWYgKGZvciBHaGVudCBVbml2ZXJzaXR5KVxyXG4gKi9cclxuXHJcbmltcG9ydCBuZXVyb24gZnJvbSAnLi4vLi4vbmV1cm9uLmpzJztcclxuaW1wb3J0IE1vdGlvblN0cmF0ZWd5IGZyb20gJy4vTW90aW9uU3RyYXRlZ3kuanMnO1xyXG5cclxuY2xhc3MgU3BlZWRDaGFuZ2VMaW5lYXJNb3Rpb25TdHJhdGVneSBleHRlbmRzIE1vdGlvblN0cmF0ZWd5IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBpbml0aWFsVmVsb2NpdHlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWRTY2FsZUZhY3RvclxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lQXRGaXJzdFNwZWVkXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGluaXRpYWxWZWxvY2l0eSwgc3BlZWRTY2FsZUZhY3RvciwgdGltZUF0Rmlyc3RTcGVlZCApIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLnZlbG9jaXR5VmVjdG9yWCA9IGluaXRpYWxWZWxvY2l0eS54O1xyXG4gICAgdGhpcy52ZWxvY2l0eVZlY3RvclkgPSBpbml0aWFsVmVsb2NpdHkueTtcclxuICAgIHRoaXMuc3BlZWRTY2FsZUZhY3RvciA9IHNwZWVkU2NhbGVGYWN0b3I7XHJcbiAgICB0aGlzLmZpcnN0U3BlZWRDb3VudGRvd25UaW1lciA9IHRpbWVBdEZpcnN0U3BlZWQ7XHJcbiAgfVxyXG5cclxuICAvLyBAcHVibGljLCBAb3ZlcnJpZGVcclxuICBtb3ZlKCBtb3ZhYmxlLCBmYWRhYmxlTW9kZWxFbGVtZW50LCBkdCApIHtcclxuICAgIG1vdmFibGUuc2V0UG9zaXRpb24oIG1vdmFibGUuZ2V0UG9zaXRpb25YKCkgKyB0aGlzLnZlbG9jaXR5VmVjdG9yWCAqIGR0LFxyXG4gICAgICBtb3ZhYmxlLmdldFBvc2l0aW9uWSgpICsgdGhpcy52ZWxvY2l0eVZlY3RvclkgKiBkdCApO1xyXG4gICAgaWYgKCB0aGlzLmZpcnN0U3BlZWRDb3VudGRvd25UaW1lciA+IDAgKSB7XHJcbiAgICAgIHRoaXMuZmlyc3RTcGVlZENvdW50ZG93blRpbWVyIC09IGR0O1xyXG4gICAgICBpZiAoIHRoaXMuZmlyc3RTcGVlZENvdW50ZG93blRpbWVyIDw9IDAgKSB7XHJcbiAgICAgICAgLy8gU2NhbGUgdGhlIHNwZWVkLlxyXG4gICAgICAgIHRoaXMudmVsb2NpdHlWZWN0b3JYID0gdGhpcy52ZWxvY2l0eVZlY3RvclggKiB0aGlzLnNwZWVkU2NhbGVGYWN0b3I7XHJcbiAgICAgICAgdGhpcy52ZWxvY2l0eVZlY3RvclkgPSB0aGlzLnZlbG9jaXR5VmVjdG9yWSAqIHRoaXMuc3BlZWRTY2FsZUZhY3RvcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubmV1cm9uLnJlZ2lzdGVyKCAnU3BlZWRDaGFuZ2VMaW5lYXJNb3Rpb25TdHJhdGVneScsIFNwZWVkQ2hhbmdlTGluZWFyTW90aW9uU3RyYXRlZ3kgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNwZWVkQ2hhbmdlTGluZWFyTW90aW9uU3RyYXRlZ3k7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsTUFBTSxNQUFNLGlCQUFpQjtBQUNwQyxPQUFPQyxjQUFjLE1BQU0scUJBQXFCO0FBRWhELE1BQU1DLCtCQUErQixTQUFTRCxjQUFjLENBQUM7RUFFM0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFRSxXQUFXQSxDQUFFQyxlQUFlLEVBQUVDLGdCQUFnQixFQUFFQyxnQkFBZ0IsRUFBRztJQUNqRSxLQUFLLENBQUMsQ0FBQztJQUNQLElBQUksQ0FBQ0MsZUFBZSxHQUFHSCxlQUFlLENBQUNJLENBQUM7SUFDeEMsSUFBSSxDQUFDQyxlQUFlLEdBQUdMLGVBQWUsQ0FBQ00sQ0FBQztJQUN4QyxJQUFJLENBQUNMLGdCQUFnQixHQUFHQSxnQkFBZ0I7SUFDeEMsSUFBSSxDQUFDTSx3QkFBd0IsR0FBR0wsZ0JBQWdCO0VBQ2xEOztFQUVBO0VBQ0FNLElBQUlBLENBQUVDLE9BQU8sRUFBRUMsbUJBQW1CLEVBQUVDLEVBQUUsRUFBRztJQUN2Q0YsT0FBTyxDQUFDRyxXQUFXLENBQUVILE9BQU8sQ0FBQ0ksWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUNWLGVBQWUsR0FBR1EsRUFBRSxFQUNyRUYsT0FBTyxDQUFDSyxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ1QsZUFBZSxHQUFHTSxFQUFHLENBQUM7SUFDdEQsSUFBSyxJQUFJLENBQUNKLHdCQUF3QixHQUFHLENBQUMsRUFBRztNQUN2QyxJQUFJLENBQUNBLHdCQUF3QixJQUFJSSxFQUFFO01BQ25DLElBQUssSUFBSSxDQUFDSix3QkFBd0IsSUFBSSxDQUFDLEVBQUc7UUFDeEM7UUFDQSxJQUFJLENBQUNKLGVBQWUsR0FBRyxJQUFJLENBQUNBLGVBQWUsR0FBRyxJQUFJLENBQUNGLGdCQUFnQjtRQUNuRSxJQUFJLENBQUNJLGVBQWUsR0FBRyxJQUFJLENBQUNBLGVBQWUsR0FBRyxJQUFJLENBQUNKLGdCQUFnQjtNQUNyRTtJQUNGO0VBQ0Y7QUFDRjtBQUVBTCxNQUFNLENBQUNtQixRQUFRLENBQUUsaUNBQWlDLEVBQUVqQiwrQkFBZ0MsQ0FBQztBQUVyRixlQUFlQSwrQkFBK0IifQ==