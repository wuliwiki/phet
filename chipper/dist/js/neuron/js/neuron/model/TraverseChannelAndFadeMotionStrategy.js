// Copyright 2014-2021, University of Colorado Boulder

/**
 * A motion strategy for traversing a basic membrane channel (i.e. one that has only one gate) and then fading away.
 *
 * @author John Blanco
 * @author Sharfudeen Ashraf (for Ghent University)
 */

import dotRandom from '../../../../dot/js/dotRandom.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import neuron from '../../neuron.js';
import MathUtils from '../common/MathUtils.js';
import NeuronConstants from '../common/NeuronConstants.js';
import MotionStrategy from './MotionStrategy.js';
import TimedFadeAwayStrategy from './TimedFadeAwayStrategy.js';
import WanderAwayThenFadeMotionStrategy from './WanderAwayThenFadeMotionStrategy.js';
class TraverseChannelAndFadeMotionStrategy extends MotionStrategy {
  /**
   * @param {MembraneChannel} channel
   * @param {number} startingPositionX
   * @param {number} startingPositionY
   * @param {number} maxVelocity
   */
  constructor(channel, startingPositionX, startingPositionY, maxVelocity) {
    super();
    maxVelocity = maxVelocity || NeuronConstants.DEFAULT_MAX_VELOCITY;
    this.velocityVector = new Vector2(0, 0);
    this.channel = channel;
    this.maxVelocity = maxVelocity;

    // Holds array of objects with x and y properties (doesn't use vector for performance reasons)
    // http://jsperf.com/object-notation-vs-constructor
    this.traversalPoints = this.createTraversalPoints(channel, startingPositionX, startingPositionY);
    this.currentDestinationIndex = 0;
    this.channelHasBeenEntered = false;
    this.startingPositionX = startingPositionX;
    this.startingPositionY = startingPositionY;
    this.setCourseForCurrentTraversalPoint(startingPositionX, startingPositionY);
  }

  // @public, @override
  move(movableModelElement, fadableModelElement, dt) {
    const currentPositionRefX = movableModelElement.getPositionX();
    const currentPositionRefY = movableModelElement.getPositionY();
    if (dt < 0) {
      this.moveBack(movableModelElement, fadableModelElement, dt);
      return;
    }
    if (!this.channelHasBeenEntered) {
      // Update the flag the tracks whether this particle has made it to the channel and started traversing it.
      this.channelHasBeenEntered = this.channel.isPointInChannel(currentPositionRefX, currentPositionRefY);
    }
    if (this.channel.isOpen() || this.channelHasBeenEntered) {
      // The channel is open, or we are inside it or have gone all the way through, so keep executing this motion strategy.
      if (this.currentDestinationIndex >= this.traversalPoints.length || this.maxVelocity * dt < this.distanceBetweenPosAndTraversalPoint(currentPositionRefX, currentPositionRefY, this.traversalPoints[this.currentDestinationIndex])) {
        // Move according to the current velocity.
        movableModelElement.setPosition(currentPositionRefX + this.velocityVector.x * dt, currentPositionRefY + this.velocityVector.y * dt);
      } else {
        // We are close enough to the destination that we should just position ourself there and update to the next
        // traversal point.
        movableModelElement.setPosition(this.traversalPoints[this.currentDestinationIndex].x, this.traversalPoints[this.currentDestinationIndex].y);
        this.currentDestinationIndex++;
        this.setCourseForCurrentTraversalPoint(movableModelElement.getPositionX(), movableModelElement.getPositionY());
        if (this.currentDestinationIndex === this.traversalPoints.length) {
          // We have traversed through all points and are now
          // presumably on the other side of the membrane, so we need to
          // start fading out of existence.
          fadableModelElement.setFadeStrategy(new TimedFadeAwayStrategy(0.002));

          // Slow down the speed.  Don't do this if it is already
          // moving pretty slowly.
          if (this.maxVelocity / NeuronConstants.DEFAULT_MAX_VELOCITY >= 0.5) {
            this.velocityVector.multiplyScalar(0.2);
          }
        }
      }
    } else {
      // The channel has closed and this element has not yet entered it.
      // Time to replace this motion strategy with a different one.
      movableModelElement.setMotionStrategy(new WanderAwayThenFadeMotionStrategy(this.channel.getCenterPosition(), movableModelElement.getPositionX(), movableModelElement.getPositionY(), 0, 0.002));
    }
  }

  /**
   * The directional movement of the particle is guided by a set of predefined traversal points.  When a particle
   * reaches one of the traversal points, its direction and velocity is recalculated based on the next traversal
   * point's position.  When the particle goes back in time, the "currentDestinationIndex" which is the pointer to the
   * traversal points array needs to be decremented and when the traversal index reaches zero, original starting
   * position needs to be used for finding the reverse direction.
   * @private
   * @param {Particle} movableModelElement
   * @param {Particle} fadableModelElement
   * @param {number} dt
   */
  moveBack(movableModelElement, fadableModelElement, dt) {
    const currentPositionRefX = movableModelElement.getPositionX();
    const currentPositionRefY = movableModelElement.getPositionY();
    const traveledDistance = Math.abs(this.maxVelocity * dt);
    if (this.channelHasBeenEntered) {
      fadableModelElement.setOpacity(1);
    } else {
      fadableModelElement.setFadeStrategy(new TimedFadeAwayStrategy(0.002));
    }

    //check if it should change direction
    if (this.currentDestinationIndex >= this.traversalPoints.length - 1) {
      const distBetweenPosAndCurrentTraversePoint = this.distanceBetweenPosAndTraversalPoint(currentPositionRefX, currentPositionRefY, this.traversalPoints[this.currentDestinationIndex - 1]);
      if (traveledDistance >= distBetweenPosAndCurrentTraversePoint) {
        // The particle is near a traversal point, find the previous traversal point and set the particle's direction towards it.
        this.currentDestinationIndex = this.currentDestinationIndex - 1;
        if (this.currentDestinationIndex >= 1) {
          movableModelElement.setPosition(this.traversalPoints[this.currentDestinationIndex - 1].x, this.traversalPoints[this.currentDestinationIndex - 1].y);
          this.setCourseForCurrentTraversalPoint(movableModelElement.getPositionX(), movableModelElement.getPositionY());
        } else {
          movableModelElement.setPosition(this.traversalPoints[0].x, this.traversalPoints[0].y);
          this.setCourseForCurrentTraversalPoint(this.startingPositionX, this.startingPositionY);
          this.channelHasBeenEntered = !this.channelHasBeenEntered;
        }
      }
    }
    if (this.currentDestinationIndex === 0) {
      //check if it has come close to original position, if yes remove the particle (going back in time before the particle is created)
      const distanceToOriginalPos = MathUtils.distanceBetween(currentPositionRefX, currentPositionRefY, this.startingPositionX, this.startingPositionY);
      if (traveledDistance >= distanceToOriginalPos) {
        fadableModelElement.continueExistingProperty.value = false;
        return;
      }
    }
    movableModelElement.setPosition(currentPositionRefX + this.velocityVector.x * dt, currentPositionRefY + this.velocityVector.y * dt);
  }

  /**
   * Create the points through which a particle must move when traversing
   * this channel.
   * @private
   */
  createTraversalPoints(channel, startingPositionX, startingPositionY) {
    const points = [];
    const ctr = channel.getCenterPosition();
    const r = channel.getChannelSize().height * 0.65; // Make the point a little outside the channel.
    const outerOpeningPosition = {
      x: ctr.x + Math.cos(channel.getRotationalAngle()) * r,
      y: ctr.y + Math.sin(channel.getRotationalAngle()) * r
    };
    const innerOpeningPosition = {
      x: ctr.x - Math.cos(channel.getRotationalAngle()) * r,
      y: ctr.y - Math.sin(channel.getRotationalAngle()) * r
    };
    if (this.distanceBetweenPosAndTraversalPoint(startingPositionX, startingPositionY, innerOpeningPosition) < this.distanceBetweenPosAndTraversalPoint(startingPositionX, startingPositionY, outerOpeningPosition)) {
      points.push(innerOpeningPosition);
      points.push(outerOpeningPosition);
    } else {
      points.push(outerOpeningPosition);
      points.push(innerOpeningPosition);
    }
    return points;
  }

  // @private
  setCourseForCurrentTraversalPoint(currentPositionX, currentPositionY) {
    if (this.currentDestinationIndex < this.traversalPoints.length) {
      const dest = this.traversalPoints[this.currentDestinationIndex];
      this.velocityVector.setXY(dest.x - currentPositionX, dest.y - currentPositionY);
      const scaleFactor = this.maxVelocity / this.velocityVector.magnitude;
      this.velocityVector.multiplyScalar(scaleFactor);
    } else {
      // All points have been traversed.  Change the direction a bit in
      // order to make things look a little more "Brownian".
      this.velocityVector.rotate((dotRandom.nextDouble() - 0.5) * Math.PI * 0.9);
    }
  }

  /**
   * @param {number} posX
   * @param {number} posY
   * @param {Object} traversalPoint - and object literal with x and y properties
   * @private
   */
  distanceBetweenPosAndTraversalPoint(posX, posY, traversalPoint) {
    return MathUtils.distanceBetween(posX, posY, traversalPoint.x, traversalPoint.y);
  }
}
neuron.register('TraverseChannelAndFadeMotionStrategy', TraverseChannelAndFadeMotionStrategy);
export default TraverseChannelAndFadeMotionStrategy;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3RSYW5kb20iLCJWZWN0b3IyIiwibmV1cm9uIiwiTWF0aFV0aWxzIiwiTmV1cm9uQ29uc3RhbnRzIiwiTW90aW9uU3RyYXRlZ3kiLCJUaW1lZEZhZGVBd2F5U3RyYXRlZ3kiLCJXYW5kZXJBd2F5VGhlbkZhZGVNb3Rpb25TdHJhdGVneSIsIlRyYXZlcnNlQ2hhbm5lbEFuZEZhZGVNb3Rpb25TdHJhdGVneSIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbCIsInN0YXJ0aW5nUG9zaXRpb25YIiwic3RhcnRpbmdQb3NpdGlvblkiLCJtYXhWZWxvY2l0eSIsIkRFRkFVTFRfTUFYX1ZFTE9DSVRZIiwidmVsb2NpdHlWZWN0b3IiLCJ0cmF2ZXJzYWxQb2ludHMiLCJjcmVhdGVUcmF2ZXJzYWxQb2ludHMiLCJjdXJyZW50RGVzdGluYXRpb25JbmRleCIsImNoYW5uZWxIYXNCZWVuRW50ZXJlZCIsInNldENvdXJzZUZvckN1cnJlbnRUcmF2ZXJzYWxQb2ludCIsIm1vdmUiLCJtb3ZhYmxlTW9kZWxFbGVtZW50IiwiZmFkYWJsZU1vZGVsRWxlbWVudCIsImR0IiwiY3VycmVudFBvc2l0aW9uUmVmWCIsImdldFBvc2l0aW9uWCIsImN1cnJlbnRQb3NpdGlvblJlZlkiLCJnZXRQb3NpdGlvblkiLCJtb3ZlQmFjayIsImlzUG9pbnRJbkNoYW5uZWwiLCJpc09wZW4iLCJsZW5ndGgiLCJkaXN0YW5jZUJldHdlZW5Qb3NBbmRUcmF2ZXJzYWxQb2ludCIsInNldFBvc2l0aW9uIiwieCIsInkiLCJzZXRGYWRlU3RyYXRlZ3kiLCJtdWx0aXBseVNjYWxhciIsInNldE1vdGlvblN0cmF0ZWd5IiwiZ2V0Q2VudGVyUG9zaXRpb24iLCJ0cmF2ZWxlZERpc3RhbmNlIiwiTWF0aCIsImFicyIsInNldE9wYWNpdHkiLCJkaXN0QmV0d2VlblBvc0FuZEN1cnJlbnRUcmF2ZXJzZVBvaW50IiwiZGlzdGFuY2VUb09yaWdpbmFsUG9zIiwiZGlzdGFuY2VCZXR3ZWVuIiwiY29udGludWVFeGlzdGluZ1Byb3BlcnR5IiwidmFsdWUiLCJwb2ludHMiLCJjdHIiLCJyIiwiZ2V0Q2hhbm5lbFNpemUiLCJoZWlnaHQiLCJvdXRlck9wZW5pbmdQb3NpdGlvbiIsImNvcyIsImdldFJvdGF0aW9uYWxBbmdsZSIsInNpbiIsImlubmVyT3BlbmluZ1Bvc2l0aW9uIiwicHVzaCIsImN1cnJlbnRQb3NpdGlvblgiLCJjdXJyZW50UG9zaXRpb25ZIiwiZGVzdCIsInNldFhZIiwic2NhbGVGYWN0b3IiLCJtYWduaXR1ZGUiLCJyb3RhdGUiLCJuZXh0RG91YmxlIiwiUEkiLCJwb3NYIiwicG9zWSIsInRyYXZlcnNhbFBvaW50IiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJUcmF2ZXJzZUNoYW5uZWxBbmRGYWRlTW90aW9uU3RyYXRlZ3kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTQtMjAyMSwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSBtb3Rpb24gc3RyYXRlZ3kgZm9yIHRyYXZlcnNpbmcgYSBiYXNpYyBtZW1icmFuZSBjaGFubmVsIChpLmUuIG9uZSB0aGF0IGhhcyBvbmx5IG9uZSBnYXRlKSBhbmQgdGhlbiBmYWRpbmcgYXdheS5cclxuICpcclxuICogQGF1dGhvciBKb2huIEJsYW5jb1xyXG4gKiBAYXV0aG9yIFNoYXJmdWRlZW4gQXNocmFmIChmb3IgR2hlbnQgVW5pdmVyc2l0eSlcclxuICovXHJcblxyXG5pbXBvcnQgZG90UmFuZG9tIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9kb3RSYW5kb20uanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBuZXVyb24gZnJvbSAnLi4vLi4vbmV1cm9uLmpzJztcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tICcuLi9jb21tb24vTWF0aFV0aWxzLmpzJztcclxuaW1wb3J0IE5ldXJvbkNvbnN0YW50cyBmcm9tICcuLi9jb21tb24vTmV1cm9uQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IE1vdGlvblN0cmF0ZWd5IGZyb20gJy4vTW90aW9uU3RyYXRlZ3kuanMnO1xyXG5pbXBvcnQgVGltZWRGYWRlQXdheVN0cmF0ZWd5IGZyb20gJy4vVGltZWRGYWRlQXdheVN0cmF0ZWd5LmpzJztcclxuaW1wb3J0IFdhbmRlckF3YXlUaGVuRmFkZU1vdGlvblN0cmF0ZWd5IGZyb20gJy4vV2FuZGVyQXdheVRoZW5GYWRlTW90aW9uU3RyYXRlZ3kuanMnO1xyXG5cclxuY2xhc3MgVHJhdmVyc2VDaGFubmVsQW5kRmFkZU1vdGlvblN0cmF0ZWd5IGV4dGVuZHMgTW90aW9uU3RyYXRlZ3kge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge01lbWJyYW5lQ2hhbm5lbH0gY2hhbm5lbFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydGluZ1Bvc2l0aW9uWFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydGluZ1Bvc2l0aW9uWVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhWZWxvY2l0eVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBjaGFubmVsLCBzdGFydGluZ1Bvc2l0aW9uWCwgc3RhcnRpbmdQb3NpdGlvblksIG1heFZlbG9jaXR5ICkge1xyXG5cclxuICAgIHN1cGVyKCk7XHJcbiAgICBtYXhWZWxvY2l0eSA9IG1heFZlbG9jaXR5IHx8IE5ldXJvbkNvbnN0YW50cy5ERUZBVUxUX01BWF9WRUxPQ0lUWTtcclxuICAgIHRoaXMudmVsb2NpdHlWZWN0b3IgPSBuZXcgVmVjdG9yMiggMCwgMCApO1xyXG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcclxuICAgIHRoaXMubWF4VmVsb2NpdHkgPSBtYXhWZWxvY2l0eTtcclxuXHJcbiAgICAvLyBIb2xkcyBhcnJheSBvZiBvYmplY3RzIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIChkb2Vzbid0IHVzZSB2ZWN0b3IgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpXHJcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9vYmplY3Qtbm90YXRpb24tdnMtY29uc3RydWN0b3JcclxuICAgIHRoaXMudHJhdmVyc2FsUG9pbnRzID0gdGhpcy5jcmVhdGVUcmF2ZXJzYWxQb2ludHMoIGNoYW5uZWwsIHN0YXJ0aW5nUG9zaXRpb25YLCBzdGFydGluZ1Bvc2l0aW9uWSApO1xyXG4gICAgdGhpcy5jdXJyZW50RGVzdGluYXRpb25JbmRleCA9IDA7XHJcbiAgICB0aGlzLmNoYW5uZWxIYXNCZWVuRW50ZXJlZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuc3RhcnRpbmdQb3NpdGlvblggPSBzdGFydGluZ1Bvc2l0aW9uWDtcclxuICAgIHRoaXMuc3RhcnRpbmdQb3NpdGlvblkgPSBzdGFydGluZ1Bvc2l0aW9uWTtcclxuXHJcbiAgICB0aGlzLnNldENvdXJzZUZvckN1cnJlbnRUcmF2ZXJzYWxQb2ludCggc3RhcnRpbmdQb3NpdGlvblgsIHN0YXJ0aW5nUG9zaXRpb25ZICk7XHJcbiAgfVxyXG5cclxuICAvLyBAcHVibGljLCBAb3ZlcnJpZGVcclxuICBtb3ZlKCBtb3ZhYmxlTW9kZWxFbGVtZW50LCBmYWRhYmxlTW9kZWxFbGVtZW50LCBkdCApIHtcclxuXHJcbiAgICBjb25zdCBjdXJyZW50UG9zaXRpb25SZWZYID0gbW92YWJsZU1vZGVsRWxlbWVudC5nZXRQb3NpdGlvblgoKTtcclxuICAgIGNvbnN0IGN1cnJlbnRQb3NpdGlvblJlZlkgPSBtb3ZhYmxlTW9kZWxFbGVtZW50LmdldFBvc2l0aW9uWSgpO1xyXG5cclxuICAgIGlmICggZHQgPCAwICkge1xyXG4gICAgICB0aGlzLm1vdmVCYWNrKCBtb3ZhYmxlTW9kZWxFbGVtZW50LCBmYWRhYmxlTW9kZWxFbGVtZW50LCBkdCApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCAhdGhpcy5jaGFubmVsSGFzQmVlbkVudGVyZWQgKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZmxhZyB0aGUgdHJhY2tzIHdoZXRoZXIgdGhpcyBwYXJ0aWNsZSBoYXMgbWFkZSBpdCB0byB0aGUgY2hhbm5lbCBhbmQgc3RhcnRlZCB0cmF2ZXJzaW5nIGl0LlxyXG4gICAgICB0aGlzLmNoYW5uZWxIYXNCZWVuRW50ZXJlZCA9IHRoaXMuY2hhbm5lbC5pc1BvaW50SW5DaGFubmVsKCBjdXJyZW50UG9zaXRpb25SZWZYLCBjdXJyZW50UG9zaXRpb25SZWZZICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCB0aGlzLmNoYW5uZWwuaXNPcGVuKCkgfHwgdGhpcy5jaGFubmVsSGFzQmVlbkVudGVyZWQgKSB7XHJcblxyXG4gICAgICAvLyBUaGUgY2hhbm5lbCBpcyBvcGVuLCBvciB3ZSBhcmUgaW5zaWRlIGl0IG9yIGhhdmUgZ29uZSBhbGwgdGhlIHdheSB0aHJvdWdoLCBzbyBrZWVwIGV4ZWN1dGluZyB0aGlzIG1vdGlvbiBzdHJhdGVneS5cclxuICAgICAgaWYgKCB0aGlzLmN1cnJlbnREZXN0aW5hdGlvbkluZGV4ID49IHRoaXMudHJhdmVyc2FsUG9pbnRzLmxlbmd0aCB8fFxyXG4gICAgICAgICAgIHRoaXMubWF4VmVsb2NpdHkgKiBkdCA8IHRoaXMuZGlzdGFuY2VCZXR3ZWVuUG9zQW5kVHJhdmVyc2FsUG9pbnQoXHJcbiAgICAgICAgICBjdXJyZW50UG9zaXRpb25SZWZYLFxyXG4gICAgICAgICAgY3VycmVudFBvc2l0aW9uUmVmWSxcclxuICAgICAgICAgIHRoaXMudHJhdmVyc2FsUG9pbnRzWyB0aGlzLmN1cnJlbnREZXN0aW5hdGlvbkluZGV4IF0gKSApIHtcclxuXHJcbiAgICAgICAgLy8gTW92ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdmVsb2NpdHkuXHJcbiAgICAgICAgbW92YWJsZU1vZGVsRWxlbWVudC5zZXRQb3NpdGlvbiggY3VycmVudFBvc2l0aW9uUmVmWCArIHRoaXMudmVsb2NpdHlWZWN0b3IueCAqIGR0LFxyXG4gICAgICAgICAgY3VycmVudFBvc2l0aW9uUmVmWSArIHRoaXMudmVsb2NpdHlWZWN0b3IueSAqIGR0ICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFdlIGFyZSBjbG9zZSBlbm91Z2ggdG8gdGhlIGRlc3RpbmF0aW9uIHRoYXQgd2Ugc2hvdWxkIGp1c3QgcG9zaXRpb24gb3Vyc2VsZiB0aGVyZSBhbmQgdXBkYXRlIHRvIHRoZSBuZXh0XHJcbiAgICAgICAgLy8gdHJhdmVyc2FsIHBvaW50LlxyXG4gICAgICAgIG1vdmFibGVNb2RlbEVsZW1lbnQuc2V0UG9zaXRpb24oIHRoaXMudHJhdmVyc2FsUG9pbnRzWyB0aGlzLmN1cnJlbnREZXN0aW5hdGlvbkluZGV4IF0ueCxcclxuICAgICAgICAgIHRoaXMudHJhdmVyc2FsUG9pbnRzWyB0aGlzLmN1cnJlbnREZXN0aW5hdGlvbkluZGV4IF0ueSApO1xyXG4gICAgICAgIHRoaXMuY3VycmVudERlc3RpbmF0aW9uSW5kZXgrKztcclxuICAgICAgICB0aGlzLnNldENvdXJzZUZvckN1cnJlbnRUcmF2ZXJzYWxQb2ludCggbW92YWJsZU1vZGVsRWxlbWVudC5nZXRQb3NpdGlvblgoKSwgbW92YWJsZU1vZGVsRWxlbWVudC5nZXRQb3NpdGlvblkoKSApO1xyXG4gICAgICAgIGlmICggdGhpcy5jdXJyZW50RGVzdGluYXRpb25JbmRleCA9PT0gdGhpcy50cmF2ZXJzYWxQb2ludHMubGVuZ3RoICkge1xyXG4gICAgICAgICAgLy8gV2UgaGF2ZSB0cmF2ZXJzZWQgdGhyb3VnaCBhbGwgcG9pbnRzIGFuZCBhcmUgbm93XHJcbiAgICAgICAgICAvLyBwcmVzdW1hYmx5IG9uIHRoZSBvdGhlciBzaWRlIG9mIHRoZSBtZW1icmFuZSwgc28gd2UgbmVlZCB0b1xyXG4gICAgICAgICAgLy8gc3RhcnQgZmFkaW5nIG91dCBvZiBleGlzdGVuY2UuXHJcbiAgICAgICAgICBmYWRhYmxlTW9kZWxFbGVtZW50LnNldEZhZGVTdHJhdGVneSggbmV3IFRpbWVkRmFkZUF3YXlTdHJhdGVneSggMC4wMDIgKSApO1xyXG5cclxuICAgICAgICAgIC8vIFNsb3cgZG93biB0aGUgc3BlZWQuICBEb24ndCBkbyB0aGlzIGlmIGl0IGlzIGFscmVhZHlcclxuICAgICAgICAgIC8vIG1vdmluZyBwcmV0dHkgc2xvd2x5LlxyXG4gICAgICAgICAgaWYgKCB0aGlzLm1heFZlbG9jaXR5IC8gTmV1cm9uQ29uc3RhbnRzLkRFRkFVTFRfTUFYX1ZFTE9DSVRZID49IDAuNSApIHtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVZlY3Rvci5tdWx0aXBseVNjYWxhciggMC4yICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gVGhlIGNoYW5uZWwgaGFzIGNsb3NlZCBhbmQgdGhpcyBlbGVtZW50IGhhcyBub3QgeWV0IGVudGVyZWQgaXQuXHJcbiAgICAgIC8vIFRpbWUgdG8gcmVwbGFjZSB0aGlzIG1vdGlvbiBzdHJhdGVneSB3aXRoIGEgZGlmZmVyZW50IG9uZS5cclxuICAgICAgbW92YWJsZU1vZGVsRWxlbWVudC5zZXRNb3Rpb25TdHJhdGVneSggbmV3IFdhbmRlckF3YXlUaGVuRmFkZU1vdGlvblN0cmF0ZWd5KCB0aGlzLmNoYW5uZWwuZ2V0Q2VudGVyUG9zaXRpb24oKSxcclxuICAgICAgICBtb3ZhYmxlTW9kZWxFbGVtZW50LmdldFBvc2l0aW9uWCgpLCBtb3ZhYmxlTW9kZWxFbGVtZW50LmdldFBvc2l0aW9uWSgpLCAwLCAwLjAwMiApICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZGlyZWN0aW9uYWwgbW92ZW1lbnQgb2YgdGhlIHBhcnRpY2xlIGlzIGd1aWRlZCBieSBhIHNldCBvZiBwcmVkZWZpbmVkIHRyYXZlcnNhbCBwb2ludHMuICBXaGVuIGEgcGFydGljbGVcclxuICAgKiByZWFjaGVzIG9uZSBvZiB0aGUgdHJhdmVyc2FsIHBvaW50cywgaXRzIGRpcmVjdGlvbiBhbmQgdmVsb2NpdHkgaXMgcmVjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBuZXh0IHRyYXZlcnNhbFxyXG4gICAqIHBvaW50J3MgcG9zaXRpb24uICBXaGVuIHRoZSBwYXJ0aWNsZSBnb2VzIGJhY2sgaW4gdGltZSwgdGhlIFwiY3VycmVudERlc3RpbmF0aW9uSW5kZXhcIiB3aGljaCBpcyB0aGUgcG9pbnRlciB0byB0aGVcclxuICAgKiB0cmF2ZXJzYWwgcG9pbnRzIGFycmF5IG5lZWRzIHRvIGJlIGRlY3JlbWVudGVkIGFuZCB3aGVuIHRoZSB0cmF2ZXJzYWwgaW5kZXggcmVhY2hlcyB6ZXJvLCBvcmlnaW5hbCBzdGFydGluZ1xyXG4gICAqIHBvc2l0aW9uIG5lZWRzIHRvIGJlIHVzZWQgZm9yIGZpbmRpbmcgdGhlIHJldmVyc2UgZGlyZWN0aW9uLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtQYXJ0aWNsZX0gbW92YWJsZU1vZGVsRWxlbWVudFxyXG4gICAqIEBwYXJhbSB7UGFydGljbGV9IGZhZGFibGVNb2RlbEVsZW1lbnRcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHRcclxuICAgKi9cclxuICBtb3ZlQmFjayggbW92YWJsZU1vZGVsRWxlbWVudCwgZmFkYWJsZU1vZGVsRWxlbWVudCwgZHQgKSB7XHJcbiAgICBjb25zdCBjdXJyZW50UG9zaXRpb25SZWZYID0gbW92YWJsZU1vZGVsRWxlbWVudC5nZXRQb3NpdGlvblgoKTtcclxuICAgIGNvbnN0IGN1cnJlbnRQb3NpdGlvblJlZlkgPSBtb3ZhYmxlTW9kZWxFbGVtZW50LmdldFBvc2l0aW9uWSgpO1xyXG5cclxuICAgIGNvbnN0IHRyYXZlbGVkRGlzdGFuY2UgPSBNYXRoLmFicyggdGhpcy5tYXhWZWxvY2l0eSAqIGR0ICk7XHJcblxyXG4gICAgaWYgKCB0aGlzLmNoYW5uZWxIYXNCZWVuRW50ZXJlZCApIHtcclxuICAgICAgZmFkYWJsZU1vZGVsRWxlbWVudC5zZXRPcGFjaXR5KCAxICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgZmFkYWJsZU1vZGVsRWxlbWVudC5zZXRGYWRlU3RyYXRlZ3koIG5ldyBUaW1lZEZhZGVBd2F5U3RyYXRlZ3koIDAuMDAyICkgKTtcclxuICAgIH1cclxuXHJcbiAgICAvL2NoZWNrIGlmIGl0IHNob3VsZCBjaGFuZ2UgZGlyZWN0aW9uXHJcbiAgICBpZiAoIHRoaXMuY3VycmVudERlc3RpbmF0aW9uSW5kZXggPj0gdGhpcy50cmF2ZXJzYWxQb2ludHMubGVuZ3RoIC0gMSApIHtcclxuICAgICAgY29uc3QgZGlzdEJldHdlZW5Qb3NBbmRDdXJyZW50VHJhdmVyc2VQb2ludCA9IHRoaXMuZGlzdGFuY2VCZXR3ZWVuUG9zQW5kVHJhdmVyc2FsUG9pbnQoIGN1cnJlbnRQb3NpdGlvblJlZlgsIGN1cnJlbnRQb3NpdGlvblJlZlksIHRoaXMudHJhdmVyc2FsUG9pbnRzWyB0aGlzLmN1cnJlbnREZXN0aW5hdGlvbkluZGV4IC0gMSBdICk7XHJcbiAgICAgIGlmICggdHJhdmVsZWREaXN0YW5jZSA+PSBkaXN0QmV0d2VlblBvc0FuZEN1cnJlbnRUcmF2ZXJzZVBvaW50ICkge1xyXG5cclxuICAgICAgICAvLyBUaGUgcGFydGljbGUgaXMgbmVhciBhIHRyYXZlcnNhbCBwb2ludCwgZmluZCB0aGUgcHJldmlvdXMgdHJhdmVyc2FsIHBvaW50IGFuZCBzZXQgdGhlIHBhcnRpY2xlJ3MgZGlyZWN0aW9uIHRvd2FyZHMgaXQuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGVzdGluYXRpb25JbmRleCA9IHRoaXMuY3VycmVudERlc3RpbmF0aW9uSW5kZXggLSAxO1xyXG4gICAgICAgIGlmICggdGhpcy5jdXJyZW50RGVzdGluYXRpb25JbmRleCA+PSAxICkge1xyXG4gICAgICAgICAgbW92YWJsZU1vZGVsRWxlbWVudC5zZXRQb3NpdGlvbiggdGhpcy50cmF2ZXJzYWxQb2ludHNbIHRoaXMuY3VycmVudERlc3RpbmF0aW9uSW5kZXggLSAxIF0ueCwgdGhpcy50cmF2ZXJzYWxQb2ludHNbIHRoaXMuY3VycmVudERlc3RpbmF0aW9uSW5kZXggLSAxIF0ueSApO1xyXG4gICAgICAgICAgdGhpcy5zZXRDb3Vyc2VGb3JDdXJyZW50VHJhdmVyc2FsUG9pbnQoIG1vdmFibGVNb2RlbEVsZW1lbnQuZ2V0UG9zaXRpb25YKCksIG1vdmFibGVNb2RlbEVsZW1lbnQuZ2V0UG9zaXRpb25ZKCkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBtb3ZhYmxlTW9kZWxFbGVtZW50LnNldFBvc2l0aW9uKCB0aGlzLnRyYXZlcnNhbFBvaW50c1sgMCBdLngsIHRoaXMudHJhdmVyc2FsUG9pbnRzWyAwIF0ueSApO1xyXG4gICAgICAgICAgdGhpcy5zZXRDb3Vyc2VGb3JDdXJyZW50VHJhdmVyc2FsUG9pbnQoIHRoaXMuc3RhcnRpbmdQb3NpdGlvblgsIHRoaXMuc3RhcnRpbmdQb3NpdGlvblkgKTtcclxuICAgICAgICAgIHRoaXMuY2hhbm5lbEhhc0JlZW5FbnRlcmVkID0gIXRoaXMuY2hhbm5lbEhhc0JlZW5FbnRlcmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICggdGhpcy5jdXJyZW50RGVzdGluYXRpb25JbmRleCA9PT0gMCApIHtcclxuICAgICAgLy9jaGVjayBpZiBpdCBoYXMgY29tZSBjbG9zZSB0byBvcmlnaW5hbCBwb3NpdGlvbiwgaWYgeWVzIHJlbW92ZSB0aGUgcGFydGljbGUgKGdvaW5nIGJhY2sgaW4gdGltZSBiZWZvcmUgdGhlIHBhcnRpY2xlIGlzIGNyZWF0ZWQpXHJcbiAgICAgIGNvbnN0IGRpc3RhbmNlVG9PcmlnaW5hbFBvcyA9IE1hdGhVdGlscy5kaXN0YW5jZUJldHdlZW4oIGN1cnJlbnRQb3NpdGlvblJlZlgsIGN1cnJlbnRQb3NpdGlvblJlZlksIHRoaXMuc3RhcnRpbmdQb3NpdGlvblgsIHRoaXMuc3RhcnRpbmdQb3NpdGlvblkgKTtcclxuICAgICAgaWYgKCB0cmF2ZWxlZERpc3RhbmNlID49IGRpc3RhbmNlVG9PcmlnaW5hbFBvcyApIHtcclxuICAgICAgICBmYWRhYmxlTW9kZWxFbGVtZW50LmNvbnRpbnVlRXhpc3RpbmdQcm9wZXJ0eS52YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG1vdmFibGVNb2RlbEVsZW1lbnQuc2V0UG9zaXRpb24oIGN1cnJlbnRQb3NpdGlvblJlZlggKyB0aGlzLnZlbG9jaXR5VmVjdG9yLnggKiBkdCxcclxuICAgICAgY3VycmVudFBvc2l0aW9uUmVmWSArIHRoaXMudmVsb2NpdHlWZWN0b3IueSAqIGR0ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIHBvaW50cyB0aHJvdWdoIHdoaWNoIGEgcGFydGljbGUgbXVzdCBtb3ZlIHdoZW4gdHJhdmVyc2luZ1xyXG4gICAqIHRoaXMgY2hhbm5lbC5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGNyZWF0ZVRyYXZlcnNhbFBvaW50cyggY2hhbm5lbCwgc3RhcnRpbmdQb3NpdGlvblgsIHN0YXJ0aW5nUG9zaXRpb25ZICkge1xyXG4gICAgY29uc3QgcG9pbnRzID0gW107XHJcbiAgICBjb25zdCBjdHIgPSBjaGFubmVsLmdldENlbnRlclBvc2l0aW9uKCk7XHJcbiAgICBjb25zdCByID0gY2hhbm5lbC5nZXRDaGFubmVsU2l6ZSgpLmhlaWdodCAqIDAuNjU7IC8vIE1ha2UgdGhlIHBvaW50IGEgbGl0dGxlIG91dHNpZGUgdGhlIGNoYW5uZWwuXHJcbiAgICBjb25zdCBvdXRlck9wZW5pbmdQb3NpdGlvbiA9IHtcclxuICAgICAgeDogY3RyLnggKyBNYXRoLmNvcyggY2hhbm5lbC5nZXRSb3RhdGlvbmFsQW5nbGUoKSApICogcixcclxuICAgICAgeTogY3RyLnkgKyBNYXRoLnNpbiggY2hhbm5lbC5nZXRSb3RhdGlvbmFsQW5nbGUoKSApICogclxyXG4gICAgfTtcclxuICAgIGNvbnN0IGlubmVyT3BlbmluZ1Bvc2l0aW9uID0ge1xyXG4gICAgICB4OiBjdHIueCAtIE1hdGguY29zKCBjaGFubmVsLmdldFJvdGF0aW9uYWxBbmdsZSgpICkgKiByLFxyXG4gICAgICB5OiBjdHIueSAtIE1hdGguc2luKCBjaGFubmVsLmdldFJvdGF0aW9uYWxBbmdsZSgpICkgKiByXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICggdGhpcy5kaXN0YW5jZUJldHdlZW5Qb3NBbmRUcmF2ZXJzYWxQb2ludCggc3RhcnRpbmdQb3NpdGlvblgsIHN0YXJ0aW5nUG9zaXRpb25ZLCBpbm5lck9wZW5pbmdQb3NpdGlvbiApIDwgdGhpcy5kaXN0YW5jZUJldHdlZW5Qb3NBbmRUcmF2ZXJzYWxQb2ludCggc3RhcnRpbmdQb3NpdGlvblgsIHN0YXJ0aW5nUG9zaXRpb25ZLCBvdXRlck9wZW5pbmdQb3NpdGlvbiApICkge1xyXG4gICAgICBwb2ludHMucHVzaCggaW5uZXJPcGVuaW5nUG9zaXRpb24gKTtcclxuICAgICAgcG9pbnRzLnB1c2goIG91dGVyT3BlbmluZ1Bvc2l0aW9uICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcG9pbnRzLnB1c2goIG91dGVyT3BlbmluZ1Bvc2l0aW9uICk7XHJcbiAgICAgIHBvaW50cy5wdXNoKCBpbm5lck9wZW5pbmdQb3NpdGlvbiApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2ludHM7XHJcbiAgfVxyXG5cclxuICAvLyBAcHJpdmF0ZVxyXG4gIHNldENvdXJzZUZvckN1cnJlbnRUcmF2ZXJzYWxQb2ludCggY3VycmVudFBvc2l0aW9uWCwgY3VycmVudFBvc2l0aW9uWSApIHtcclxuICAgIGlmICggdGhpcy5jdXJyZW50RGVzdGluYXRpb25JbmRleCA8IHRoaXMudHJhdmVyc2FsUG9pbnRzLmxlbmd0aCApIHtcclxuICAgICAgY29uc3QgZGVzdCA9IHRoaXMudHJhdmVyc2FsUG9pbnRzWyB0aGlzLmN1cnJlbnREZXN0aW5hdGlvbkluZGV4IF07XHJcbiAgICAgIHRoaXMudmVsb2NpdHlWZWN0b3Iuc2V0WFkoIGRlc3QueCAtIGN1cnJlbnRQb3NpdGlvblgsIGRlc3QueSAtIGN1cnJlbnRQb3NpdGlvblkgKTtcclxuICAgICAgY29uc3Qgc2NhbGVGYWN0b3IgPSB0aGlzLm1heFZlbG9jaXR5IC8gdGhpcy52ZWxvY2l0eVZlY3Rvci5tYWduaXR1ZGU7XHJcbiAgICAgIHRoaXMudmVsb2NpdHlWZWN0b3IubXVsdGlwbHlTY2FsYXIoIHNjYWxlRmFjdG9yICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gQWxsIHBvaW50cyBoYXZlIGJlZW4gdHJhdmVyc2VkLiAgQ2hhbmdlIHRoZSBkaXJlY3Rpb24gYSBiaXQgaW5cclxuICAgICAgLy8gb3JkZXIgdG8gbWFrZSB0aGluZ3MgbG9vayBhIGxpdHRsZSBtb3JlIFwiQnJvd25pYW5cIi5cclxuICAgICAgdGhpcy52ZWxvY2l0eVZlY3Rvci5yb3RhdGUoICggZG90UmFuZG9tLm5leHREb3VibGUoKSAtIDAuNSApICogTWF0aC5QSSAqIDAuOSApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1hcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zWVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmF2ZXJzYWxQb2ludCAtIGFuZCBvYmplY3QgbGl0ZXJhbCB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZGlzdGFuY2VCZXR3ZWVuUG9zQW5kVHJhdmVyc2FsUG9pbnQoIHBvc1gsIHBvc1ksIHRyYXZlcnNhbFBvaW50ICkge1xyXG4gICAgcmV0dXJuIE1hdGhVdGlscy5kaXN0YW5jZUJldHdlZW4oIHBvc1gsIHBvc1ksIHRyYXZlcnNhbFBvaW50LngsIHRyYXZlcnNhbFBvaW50LnkgKTtcclxuICB9XHJcbn1cclxuXHJcbm5ldXJvbi5yZWdpc3RlciggJ1RyYXZlcnNlQ2hhbm5lbEFuZEZhZGVNb3Rpb25TdHJhdGVneScsIFRyYXZlcnNlQ2hhbm5lbEFuZEZhZGVNb3Rpb25TdHJhdGVneSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVHJhdmVyc2VDaGFubmVsQW5kRmFkZU1vdGlvblN0cmF0ZWd5O1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxTQUFTLE1BQU0saUNBQWlDO0FBQ3ZELE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsTUFBTSxNQUFNLGlCQUFpQjtBQUNwQyxPQUFPQyxTQUFTLE1BQU0sd0JBQXdCO0FBQzlDLE9BQU9DLGVBQWUsTUFBTSw4QkFBOEI7QUFDMUQsT0FBT0MsY0FBYyxNQUFNLHFCQUFxQjtBQUNoRCxPQUFPQyxxQkFBcUIsTUFBTSw0QkFBNEI7QUFDOUQsT0FBT0MsZ0NBQWdDLE1BQU0sdUNBQXVDO0FBRXBGLE1BQU1DLG9DQUFvQyxTQUFTSCxjQUFjLENBQUM7RUFFaEU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VJLFdBQVdBLENBQUVDLE9BQU8sRUFBRUMsaUJBQWlCLEVBQUVDLGlCQUFpQixFQUFFQyxXQUFXLEVBQUc7SUFFeEUsS0FBSyxDQUFDLENBQUM7SUFDUEEsV0FBVyxHQUFHQSxXQUFXLElBQUlULGVBQWUsQ0FBQ1Usb0JBQW9CO0lBQ2pFLElBQUksQ0FBQ0MsY0FBYyxHQUFHLElBQUlkLE9BQU8sQ0FBRSxDQUFDLEVBQUUsQ0FBRSxDQUFDO0lBQ3pDLElBQUksQ0FBQ1MsT0FBTyxHQUFHQSxPQUFPO0lBQ3RCLElBQUksQ0FBQ0csV0FBVyxHQUFHQSxXQUFXOztJQUU5QjtJQUNBO0lBQ0EsSUFBSSxDQUFDRyxlQUFlLEdBQUcsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBRVAsT0FBTyxFQUFFQyxpQkFBaUIsRUFBRUMsaUJBQWtCLENBQUM7SUFDbEcsSUFBSSxDQUFDTSx1QkFBdUIsR0FBRyxDQUFDO0lBQ2hDLElBQUksQ0FBQ0MscUJBQXFCLEdBQUcsS0FBSztJQUVsQyxJQUFJLENBQUNSLGlCQUFpQixHQUFHQSxpQkFBaUI7SUFDMUMsSUFBSSxD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