// Copyright 2014-2020, University of Colorado Boulder

/**
 * Class that defines the behavior of the action potential that travels
 * along the membrane before reaching the position of the transverse cross
 * section.  This is essentially just a shape that is intended to look
 * like something moving along the outer membrane.  The shape moves for a
 * while, then reaches the cross section, and then lingers there for a
 * bit.

 * @author John Blanco
 * @author Sharfudeen Ashraf (for Ghent University)
 */

import Emitter from '../../../../axon/js/Emitter.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import neuron from '../../neuron.js';
import TravelingActionPotentialState from './TravelingActionPotentialState.js';

// constants
const TRAVELING_TIME = 0.0020; // In seconds of sim time (not wall time).
const LINGER_AT_CROSS_SECTION_TIME = 0.0005; // In seconds of sim time (not wall time).
const NUM_CURVE_POINTS = 20; // number of points used to approximate the curve of the axon body

/**
 * A function that takes a proportion between 0 and 1, an array of points, and an output array, and sets the output
 * array value to be a weighted interpolation between the two closest points in the array.
 */
function calculateInterpolatedPoint(proportion, points, outputPoint) {
  assert && assert(proportion >= 0 && proportion <= 1, 'proportion is out of range');
  const unroundedClosestPointIndex = proportion * (points.length - 1);
  const closestPointIndex = Utils.roundSymmetric(unroundedClosestPointIndex);
  const nextClosestPointIndex = unroundedClosestPointIndex % 1 >= 0.5 ? closestPointIndex - 1 : closestPointIndex + 1;
  const weight = 1 - Math.abs(closestPointIndex - unroundedClosestPointIndex);
  const closestPoint = points[closestPointIndex];
  const nextClosestPoint = points[nextClosestPointIndex];
  outputPoint.setX(weight * closestPoint.x + (1 - weight) * nextClosestPoint.x);
  outputPoint.setY(weight * closestPoint.y + (1 - weight) * nextClosestPoint.y);
}
class TravelingActionPotential {
  /**
   * @param {AxonMembrane} axonMembrane
   */
  constructor(axonMembrane) {
    this.axonMembrane = axonMembrane; // @private

    // @public - events emitted as the action potential changes
    this.shapeChanged = new Emitter();
    this.crossSectionReached = new Emitter();
    this.lingeringCompleted = new Emitter();

    // @public - describes the shape of the action potential
    this.shapeDescription = {
      mode: 'curve',
      // valid values are 'curve' and 'circle'
      startPoint: new Vector2(0, 0),
      controlPoint1: new Vector2(0, 0),
      controlPoint2: new Vector2(0, 0),
      endPoint: new Vector2(0, 0),
      circleCenter: axonMembrane.crossSectionCircleCenter,
      circleRadius: 0
    };
    this.travelTimeCountdownTimer = TRAVELING_TIME; // @private
    this.lingerCountdownTimer = 0; // @private
    this.upperCurvePoints = new Array(NUM_CURVE_POINTS); // @private
    this.lowerCurvePoints = new Array(NUM_CURVE_POINTS); // @private
    this.curveMidPoint = new Vector2(0, 0); // @private, pre-allocated for performance reasons

    // Set up the points that will be used to determine the ends of the action potential curve.  These are calculated
    // during construction instead of in real time as a performance optimization.
    for (let i = 0; i < NUM_CURVE_POINTS; i++) {
      this.upperCurvePoints[i] = axonMembrane.evaluateCurve(axonMembrane.getCurveA(), i / (NUM_CURVE_POINTS - 1));
      this.lowerCurvePoints[i] = axonMembrane.evaluateCurve(axonMembrane.getCurveB(), i / (NUM_CURVE_POINTS - 1));
    }

    // create the initial shape
    this.updateShapeDescription(); // Also create an initialize Shape
  }

  /**
   * Step this model component forward by the specified time.  This will update the shape such that it will appear to
   * move down the axon membrane.
   * @public
   * @param {number} dt
   */
  stepInTime(dt) {
    if (this.travelTimeCountdownTimer > 0) {
      this.travelTimeCountdownTimer -= dt;
      this.updateShapeDescription();
      if (this.travelTimeCountdownTimer <= 0) {
        // We've reached the cross section and will now linger there for a bit.
        this.crossSectionReached.emit();
        this.lingerCountdownTimer = LINGER_AT_CROSS_SECTION_TIME;
      }
    } else if (this.lingerCountdownTimer > 0) {
      this.lingerCountdownTimer -= dt;
      if (this.lingerCountdownTimer <= 0) {
        this.lingeringCompleted.emit();
      } else {
        this.updateShapeDescription();
      }
    }
  }

  /**
   * Update the information that describes the shape of the action potential.
   *
   * NOTE: An attempt was made to generalize this so that it would work for pretty much any shape of the axon body,
   * but this turned out to be a lot of work, so ultimately we went with a simpler implementation that makes some
   * assumptions about the axon body shape.  If significant changes are made to the axon body shape, this routine will
   * need to be updated.
   * @private
   */
  updateShapeDescription() {
    if (this.travelTimeCountdownTimer > 0) {
      // Depict the traveling action potential as a curved line moving down the axon.  Start by calculating the start
      // and end points.
      this.shapeDescription.mode = 'curve';
      const travelAmtFactor = Math.max(1 - this.travelTimeCountdownTimer / TRAVELING_TIME, 0);
      calculateInterpolatedPoint(travelAmtFactor, this.upperCurvePoints, this.shapeDescription.startPoint);
      const startPoint = this.shapeDescription.startPoint;
      calculateInterpolatedPoint(travelAmtFactor, this.lowerCurvePoints, this.shapeDescription.endPoint);
      const endPoint = this.shapeDescription.endPoint;
      this.curveMidPoint.setXY((startPoint.x + endPoint.x) / 2, (startPoint.y + endPoint.y) / 2);
      // The exponents used in the control point distances were empirically determined and can be adjusted to make the
      // top or bottom more or less curved as the potential moves down the membrane.
      const ctrlPoint1Distance = endPoint.distance(startPoint) * 0.7 * Math.pow(travelAmtFactor, 1.8);
      const ctrlPoint2Distance = endPoint.distance(startPoint) * 0.7 * Math.pow(travelAmtFactor, 0.8);
      const perpendicularAngle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x) + Math.PI / 2;
      this.shapeDescription.controlPoint1.setXY(this.curveMidPoint.x + ctrlPoint1Distance * Math.cos(perpendicularAngle + Math.PI / 6), this.curveMidPoint.y + ctrlPoint1Distance * Math.sin(perpendicularAngle + Math.PI / 6));
      this.shapeDescription.controlPoint2.setXY(this.curveMidPoint.x + ctrlPoint2Distance * Math.cos(perpendicularAngle - Math.PI / 6), this.curveMidPoint.y + ctrlPoint2Distance * Math.sin(perpendicularAngle - Math.PI / 6));
    } else {
      // The action potential is "lingering" at the point of the cross section.  Define the shape as a circle that
      // changes shape a bit. This is done when the action potential has essentially reached the point of the cross
      // section.
      this.shapeDescription.mode = 'circle';

      // Make the shape a little bigger than the cross section so that it can be seen behind it, and have it grow
      // while it is there.
      const growthFactor = (1 - Math.abs(this.lingerCountdownTimer / LINGER_AT_CROSS_SECTION_TIME - 0.5) * 2) * 0.04 + 1;
      this.shapeDescription.circleRadius = this.axonMembrane.crossSectionCircleRadius * growthFactor;
    }
    this.shapeChanged.emit();
  }

  /**
   * Set the state from a (probably previously captured) version of the internal state.
   * @public
   */
  setState(state) {
    this.travelTimeCountdownTimer = state.getTravelTimeCountdownTimer();
    this.lingerCountdownTimer = state.getLingerCountdownTimer();
    this.updateShapeDescription();
  }

  /**
   * Get the state, generally for use in setting the state later for some sort of playback.
   * @public
   */
  getState() {
    return new TravelingActionPotentialState(this.travelTimeCountdownTimer, this.lingerCountdownTimer);
  }
}
neuron.register('TravelingActionPotential', TravelingActionPotential);
export default TravelingActionPotential;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFbWl0dGVyIiwiVXRpbHMiLCJWZWN0b3IyIiwibmV1cm9uIiwiVHJhdmVsaW5nQWN0aW9uUG90ZW50aWFsU3RhdGUiLCJUUkFWRUxJTkdfVElNRSIsIkxJTkdFUl9BVF9DUk9TU19TRUNUSU9OX1RJTUUiLCJOVU1fQ1VSVkVfUE9JTlRTIiwiY2FsY3VsYXRlSW50ZXJwb2xhdGVkUG9pbnQiLCJwcm9wb3J0aW9uIiwicG9pbnRzIiwib3V0cHV0UG9pbnQiLCJhc3NlcnQiLCJ1bnJvdW5kZWRDbG9zZXN0UG9pbnRJbmRleCIsImxlbmd0aCIsImNsb3Nlc3RQb2ludEluZGV4Iiwicm91bmRTeW1tZXRyaWMiLCJuZXh0Q2xvc2VzdFBvaW50SW5kZXgiLCJ3ZWlnaHQiLCJNYXRoIiwiYWJzIiwiY2xvc2VzdFBvaW50IiwibmV4dENsb3Nlc3RQb2ludCIsInNldFgiLCJ4Iiwic2V0WSIsInkiLCJUcmF2ZWxpbmdBY3Rpb25Qb3RlbnRpYWwiLCJjb25zdHJ1Y3RvciIsImF4b25NZW1icmFuZSIsInNoYXBlQ2hhbmdlZCIsImNyb3NzU2VjdGlvblJlYWNoZWQiLCJsaW5nZXJpbmdDb21wbGV0ZWQiLCJzaGFwZURlc2NyaXB0aW9uIiwibW9kZSIsInN0YXJ0UG9pbnQiLCJjb250cm9sUG9pbnQxIiwiY29udHJvbFBvaW50MiIsImVuZFBvaW50IiwiY2lyY2xlQ2VudGVyIiwiY3Jvc3NTZWN0aW9uQ2lyY2xlQ2VudGVyIiwiY2lyY2xlUmFkaXVzIiwidHJhdmVsVGltZUNvdW50ZG93blRpbWVyIiwibGluZ2VyQ291bnRkb3duVGltZXIiLCJ1cHBlckN1cnZlUG9pbnRzIiwiQXJyYXkiLCJsb3dlckN1cnZlUG9pbnRzIiwiY3VydmVNaWRQb2ludCIsImkiLCJldmFsdWF0ZUN1cnZlIiwiZ2V0Q3VydmVBIiwiZ2V0Q3VydmVCIiwidXBkYXRlU2hhcGVEZXNjcmlwdGlvbiIsInN0ZXBJblRpbWUiLCJkdCIsImVtaXQiLCJ0cmF2ZWxBbXRGYWN0b3IiLCJtYXgiLCJzZXRYWSIsImN0cmxQb2ludDFEaXN0YW5jZSIsImRpc3RhbmNlIiwicG93IiwiY3RybFBvaW50MkRpc3RhbmNlIiwicGVycGVuZGljdWxhckFuZ2xlIiwiYXRhbjIiLCJQSSIsImNvcyIsInNpbiIsImdyb3d0aEZhY3RvciIsImNyb3NzU2VjdGlvbkNpcmNsZVJhZGl1cyIsInNldFN0YXRlIiwic3RhdGUiLCJnZXRUcmF2ZWxUaW1lQ291bnRkb3duVGltZXIiLCJnZXRMaW5nZXJDb3VudGRvd25UaW1lciIsImdldFN0YXRlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJUcmF2ZWxpbmdBY3Rpb25Qb3RlbnRpYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTQtMjAyMCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQ2xhc3MgdGhhdCBkZWZpbmVzIHRoZSBiZWhhdmlvciBvZiB0aGUgYWN0aW9uIHBvdGVudGlhbCB0aGF0IHRyYXZlbHNcclxuICogYWxvbmcgdGhlIG1lbWJyYW5lIGJlZm9yZSByZWFjaGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHRyYW5zdmVyc2UgY3Jvc3NcclxuICogc2VjdGlvbi4gIFRoaXMgaXMgZXNzZW50aWFsbHkganVzdCBhIHNoYXBlIHRoYXQgaXMgaW50ZW5kZWQgdG8gbG9va1xyXG4gKiBsaWtlIHNvbWV0aGluZyBtb3ZpbmcgYWxvbmcgdGhlIG91dGVyIG1lbWJyYW5lLiAgVGhlIHNoYXBlIG1vdmVzIGZvciBhXHJcbiAqIHdoaWxlLCB0aGVuIHJlYWNoZXMgdGhlIGNyb3NzIHNlY3Rpb24sIGFuZCB0aGVuIGxpbmdlcnMgdGhlcmUgZm9yIGFcclxuICogYml0LlxyXG5cclxuICogQGF1dGhvciBKb2huIEJsYW5jb1xyXG4gKiBAYXV0aG9yIFNoYXJmdWRlZW4gQXNocmFmIChmb3IgR2hlbnQgVW5pdmVyc2l0eSlcclxuICovXHJcblxyXG5pbXBvcnQgRW1pdHRlciBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0VtaXR0ZXIuanMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgbmV1cm9uIGZyb20gJy4uLy4uL25ldXJvbi5qcyc7XHJcbmltcG9ydCBUcmF2ZWxpbmdBY3Rpb25Qb3RlbnRpYWxTdGF0ZSBmcm9tICcuL1RyYXZlbGluZ0FjdGlvblBvdGVudGlhbFN0YXRlLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBUUkFWRUxJTkdfVElNRSA9IDAuMDAyMDsgLy8gSW4gc2Vjb25kcyBvZiBzaW0gdGltZSAobm90IHdhbGwgdGltZSkuXHJcbmNvbnN0IExJTkdFUl9BVF9DUk9TU19TRUNUSU9OX1RJTUUgPSAwLjAwMDU7IC8vIEluIHNlY29uZHMgb2Ygc2ltIHRpbWUgKG5vdCB3YWxsIHRpbWUpLlxyXG5jb25zdCBOVU1fQ1VSVkVfUE9JTlRTID0gMjA7IC8vIG51bWJlciBvZiBwb2ludHMgdXNlZCB0byBhcHByb3hpbWF0ZSB0aGUgY3VydmUgb2YgdGhlIGF4b24gYm9keVxyXG5cclxuLyoqXHJcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHByb3BvcnRpb24gYmV0d2VlbiAwIGFuZCAxLCBhbiBhcnJheSBvZiBwb2ludHMsIGFuZCBhbiBvdXRwdXQgYXJyYXksIGFuZCBzZXRzIHRoZSBvdXRwdXRcclxuICogYXJyYXkgdmFsdWUgdG8gYmUgYSB3ZWlnaHRlZCBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdGhlIHR3byBjbG9zZXN0IHBvaW50cyBpbiB0aGUgYXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVJbnRlcnBvbGF0ZWRQb2ludCggcHJvcG9ydGlvbiwgcG9pbnRzLCBvdXRwdXRQb2ludCApIHtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBwcm9wb3J0aW9uID49IDAgJiYgcHJvcG9ydGlvbiA8PSAxLCAncHJvcG9ydGlvbiBpcyBvdXQgb2YgcmFuZ2UnICk7XHJcbiAgY29uc3QgdW5yb3VuZGVkQ2xvc2VzdFBvaW50SW5kZXggPSBwcm9wb3J0aW9uICogKCBwb2ludHMubGVuZ3RoIC0gMSApO1xyXG4gIGNvbnN0IGNsb3Nlc3RQb2ludEluZGV4ID0gVXRpbHMucm91bmRTeW1tZXRyaWMoIHVucm91bmRlZENsb3Nlc3RQb2ludEluZGV4ICk7XHJcbiAgY29uc3QgbmV4dENsb3Nlc3RQb2ludEluZGV4ID0gdW5yb3VuZGVkQ2xvc2VzdFBvaW50SW5kZXggJSAxID49IDAuNSA/IGNsb3Nlc3RQb2ludEluZGV4IC0gMSA6IGNsb3Nlc3RQb2ludEluZGV4ICsgMTtcclxuICBjb25zdCB3ZWlnaHQgPSAxIC0gTWF0aC5hYnMoIGNsb3Nlc3RQb2ludEluZGV4IC0gdW5yb3VuZGVkQ2xvc2VzdFBvaW50SW5kZXggKTtcclxuICBjb25zdCBjbG9zZXN0UG9pbnQgPSBwb2ludHNbIGNsb3Nlc3RQb2ludEluZGV4IF07XHJcbiAgY29uc3QgbmV4dENsb3Nlc3RQb2ludCA9IHBvaW50c1sgbmV4dENsb3Nlc3RQb2ludEluZGV4IF07XHJcbiAgb3V0cHV0UG9pbnQuc2V0WCggd2VpZ2h0ICogY2xvc2VzdFBvaW50LnggKyAoIDEgLSB3ZWlnaHQgKSAqIG5leHRDbG9zZXN0UG9pbnQueCApO1xyXG4gIG91dHB1dFBvaW50LnNldFkoIHdlaWdodCAqIGNsb3Nlc3RQb2ludC55ICsgKCAxIC0gd2VpZ2h0ICkgKiBuZXh0Q2xvc2VzdFBvaW50LnkgKTtcclxufVxyXG5cclxuY2xhc3MgVHJhdmVsaW5nQWN0aW9uUG90ZW50aWFsIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtBeG9uTWVtYnJhbmV9IGF4b25NZW1icmFuZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBheG9uTWVtYnJhbmUgKSB7XHJcblxyXG4gICAgdGhpcy5heG9uTWVtYnJhbmUgPSBheG9uTWVtYnJhbmU7IC8vIEBwcml2YXRlXHJcblxyXG4gICAgLy8gQHB1YmxpYyAtIGV2ZW50cyBlbWl0dGVkIGFzIHRoZSBhY3Rpb24gcG90ZW50aWFsIGNoYW5nZXNcclxuICAgIHRoaXMuc2hhcGVDaGFuZ2VkID0gbmV3IEVtaXR0ZXIoKTtcclxuICAgIHRoaXMuY3Jvc3NTZWN0aW9uUmVhY2hlZCA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICB0aGlzLmxpbmdlcmluZ0NvbXBsZXRlZCA9IG5ldyBFbWl0dGVyKCk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyAtIGRlc2NyaWJlcyB0aGUgc2hhcGUgb2YgdGhlIGFjdGlvbiBwb3RlbnRpYWxcclxuICAgIHRoaXMuc2hhcGVEZXNjcmlwdGlvbiA9IHtcclxuICAgICAgbW9kZTogJ2N1cnZlJywgLy8gdmFsaWQgdmFsdWVzIGFyZSAnY3VydmUnIGFuZCAnY2lyY2xlJ1xyXG4gICAgICBzdGFydFBvaW50OiBuZXcgVmVjdG9yMiggMCwgMCApLFxyXG4gICAgICBjb250cm9sUG9pbnQxOiBuZXcgVmVjdG9yMiggMCwgMCApLFxyXG4gICAgICBjb250cm9sUG9pbnQyOiBuZXcgVmVjdG9yMiggMCwgMCApLFxyXG4gICAgICBlbmRQb2ludDogbmV3IFZlY3RvcjIoIDAsIDAgKSxcclxuICAgICAgY2lyY2xlQ2VudGVyOiBheG9uTWVtYnJhbmUuY3Jvc3NTZWN0aW9uQ2lyY2xlQ2VudGVyLFxyXG4gICAgICBjaXJjbGVSYWRpdXM6IDBcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy50cmF2ZWxUaW1lQ291bnRkb3duVGltZXIgPSBUUkFWRUxJTkdfVElNRTsgLy8gQHByaXZhdGVcclxuICAgIHRoaXMubGluZ2VyQ291bnRkb3duVGltZXIgPSAwOyAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy51cHBlckN1cnZlUG9pbnRzID0gbmV3IEFycmF5KCBOVU1fQ1VSVkVfUE9JTlRTICk7IC8vIEBwcml2YXRlXHJcbiAgICB0aGlzLmxvd2VyQ3VydmVQb2ludHMgPSBuZXcgQXJyYXkoIE5VTV9DVVJWRV9QT0lOVFMgKTsgLy8gQHByaXZhdGVcclxuICAgIHRoaXMuY3VydmVNaWRQb2ludCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7IC8vIEBwcml2YXRlLCBwcmUtYWxsb2NhdGVkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXHJcblxyXG4gICAgLy8gU2V0IHVwIHRoZSBwb2ludHMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBlbmRzIG9mIHRoZSBhY3Rpb24gcG90ZW50aWFsIGN1cnZlLiAgVGhlc2UgYXJlIGNhbGN1bGF0ZWRcclxuICAgIC8vIGR1cmluZyBjb25zdHJ1Y3Rpb24gaW5zdGVhZCBvZiBpbiByZWFsIHRpbWUgYXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBOVU1fQ1VSVkVfUE9JTlRTOyBpKysgKSB7XHJcbiAgICAgIHRoaXMudXBwZXJDdXJ2ZVBvaW50c1sgaSBdID0gYXhvbk1lbWJyYW5lLmV2YWx1YXRlQ3VydmUoIGF4b25NZW1icmFuZS5nZXRDdXJ2ZUEoKSwgaSAvICggTlVNX0NVUlZFX1BPSU5UUyAtIDEgKSApO1xyXG4gICAgICB0aGlzLmxvd2VyQ3VydmVQb2ludHNbIGkgXSA9IGF4b25NZW1icmFuZS5ldmFsdWF0ZUN1cnZlKCBheG9uTWVtYnJhbmUuZ2V0Q3VydmVCKCksIGkgLyAoIE5VTV9DVVJWRV9QT0lOVFMgLSAxICkgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjcmVhdGUgdGhlIGluaXRpYWwgc2hhcGVcclxuICAgIHRoaXMudXBkYXRlU2hhcGVEZXNjcmlwdGlvbigpOyAvLyBBbHNvIGNyZWF0ZSBhbiBpbml0aWFsaXplIFNoYXBlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGVwIHRoaXMgbW9kZWwgY29tcG9uZW50IGZvcndhcmQgYnkgdGhlIHNwZWNpZmllZCB0aW1lLiAgVGhpcyB3aWxsIHVwZGF0ZSB0aGUgc2hhcGUgc3VjaCB0aGF0IGl0IHdpbGwgYXBwZWFyIHRvXHJcbiAgICogbW92ZSBkb3duIHRoZSBheG9uIG1lbWJyYW5lLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHRcclxuICAgKi9cclxuICBzdGVwSW5UaW1lKCBkdCApIHtcclxuICAgIGlmICggdGhpcy50cmF2ZWxUaW1lQ291bnRkb3duVGltZXIgPiAwICkge1xyXG4gICAgICB0aGlzLnRyYXZlbFRpbWVDb3VudGRvd25UaW1lciAtPSBkdDtcclxuICAgICAgdGhpcy51cGRhdGVTaGFwZURlc2NyaXB0aW9uKCk7XHJcbiAgICAgIGlmICggdGhpcy50cmF2ZWxUaW1lQ291bnRkb3duVGltZXIgPD0gMCApIHtcclxuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBjcm9zcyBzZWN0aW9uIGFuZCB3aWxsIG5vdyBsaW5nZXIgdGhlcmUgZm9yIGEgYml0LlxyXG4gICAgICAgIHRoaXMuY3Jvc3NTZWN0aW9uUmVhY2hlZC5lbWl0KCk7XHJcbiAgICAgICAgdGhpcy5saW5nZXJDb3VudGRvd25UaW1lciA9IExJTkdFUl9BVF9DUk9TU19TRUNUSU9OX1RJTUU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCB0aGlzLmxpbmdlckNvdW50ZG93blRpbWVyID4gMCApIHtcclxuICAgICAgdGhpcy5saW5nZXJDb3VudGRvd25UaW1lciAtPSBkdDtcclxuICAgICAgaWYgKCB0aGlzLmxpbmdlckNvdW50ZG93blRpbWVyIDw9IDAgKSB7XHJcbiAgICAgICAgdGhpcy5saW5nZXJpbmdDb21wbGV0ZWQuZW1pdCgpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMudXBkYXRlU2hhcGVEZXNjcmlwdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGluZm9ybWF0aW9uIHRoYXQgZGVzY3JpYmVzIHRoZSBzaGFwZSBvZiB0aGUgYWN0aW9uIHBvdGVudGlhbC5cclxuICAgKlxyXG4gICAqIE5PVEU6IEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gZ2VuZXJhbGl6ZSB0aGlzIHNvIHRoYXQgaXQgd291bGQgd29yayBmb3IgcHJldHR5IG11Y2ggYW55IHNoYXBlIG9mIHRoZSBheG9uIGJvZHksXHJcbiAgICogYnV0IHRoaXMgdHVybmVkIG91dCB0byBiZSBhIGxvdCBvZiB3b3JrLCBzbyB1bHRpbWF0ZWx5IHdlIHdlbnQgd2l0aCBhIHNpbXBsZXIgaW1wbGVtZW50YXRpb24gdGhhdCBtYWtlcyBzb21lXHJcbiAgICogYXNzdW1wdGlvbnMgYWJvdXQgdGhlIGF4b24gYm9keSBzaGFwZS4gIElmIHNpZ25pZmljYW50IGNoYW5nZXMgYXJlIG1hZGUgdG8gdGhlIGF4b24gYm9keSBzaGFwZSwgdGhpcyByb3V0aW5lIHdpbGxcclxuICAgKiBuZWVkIHRvIGJlIHVwZGF0ZWQuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICB1cGRhdGVTaGFwZURlc2NyaXB0aW9uKCkge1xyXG4gICAgaWYgKCB0aGlzLnRyYXZlbFRpbWVDb3VudGRvd25UaW1lciA+IDAgKSB7XHJcbiAgICAgIC8vIERlcGljdCB0aGUgdHJhdmVsaW5nIGFjdGlvbiBwb3RlbnRpYWwgYXMgYSBjdXJ2ZWQgbGluZSBtb3ZpbmcgZG93biB0aGUgYXhvbi4gIFN0YXJ0IGJ5IGNhbGN1bGF0aW5nIHRoZSBzdGFydFxyXG4gICAgICAvLyBhbmQgZW5kIHBvaW50cy5cclxuICAgICAgdGhpcy5zaGFwZURlc2NyaXB0aW9uLm1vZGUgPSAnY3VydmUnO1xyXG4gICAgICBjb25zdCB0cmF2ZWxBbXRGYWN0b3IgPSBNYXRoLm1heCggMSAtIHRoaXMudHJhdmVsVGltZUNvdW50ZG93blRpbWVyIC8gVFJBVkVMSU5HX1RJTUUsIDAgKTtcclxuICAgICAgY2FsY3VsYXRlSW50ZXJwb2xhdGVkUG9pbnQoIHRyYXZlbEFtdEZhY3RvciwgdGhpcy51cHBlckN1cnZlUG9pbnRzLCB0aGlzLnNoYXBlRGVzY3JpcHRpb24uc3RhcnRQb2ludCApO1xyXG4gICAgICBjb25zdCBzdGFydFBvaW50ID0gdGhpcy5zaGFwZURlc2NyaXB0aW9uLnN0YXJ0UG9pbnQ7XHJcbiAgICAgIGNhbGN1bGF0ZUludGVycG9sYXRlZFBvaW50KCB0cmF2ZWxBbXRGYWN0b3IsIHRoaXMubG93ZXJDdXJ2ZVBvaW50cywgdGhpcy5zaGFwZURlc2NyaXB0aW9uLmVuZFBvaW50ICk7XHJcbiAgICAgIGNvbnN0IGVuZFBvaW50ID0gdGhpcy5zaGFwZURlc2NyaXB0aW9uLmVuZFBvaW50O1xyXG4gICAgICB0aGlzLmN1cnZlTWlkUG9pbnQuc2V0WFkoICggc3RhcnRQb2ludC54ICsgZW5kUG9pbnQueCApIC8gMiwgKCBzdGFydFBvaW50LnkgKyBlbmRQb2ludC55ICkgLyAyICk7XHJcbiAgICAgIC8vIFRoZSBleHBvbmVudHMgdXNlZCBpbiB0aGUgY29udHJvbCBwb2ludCBkaXN0YW5jZXMgd2VyZSBlbXBpcmljYWxseSBkZXRlcm1pbmVkIGFuZCBjYW4gYmUgYWRqdXN0ZWQgdG8gbWFrZSB0aGVcclxuICAgICAgLy8gdG9wIG9yIGJvdHRvbSBtb3JlIG9yIGxlc3MgY3VydmVkIGFzIHRoZSBwb3RlbnRpYWwgbW92ZXMgZG93biB0aGUgbWVtYnJhbmUuXHJcbiAgICAgIGNvbnN0IGN0cmxQb2ludDFEaXN0YW5jZSA9IGVuZFBvaW50LmRpc3RhbmNlKCBzdGFydFBvaW50ICkgKiAwLjcgKiBNYXRoLnBvdyggdHJhdmVsQW10RmFjdG9yLCAxLjggKTtcclxuICAgICAgY29uc3QgY3RybFBvaW50MkRpc3RhbmNlID0gZW5kUG9pbnQuZGlzdGFuY2UoIHN0YXJ0UG9pbnQgKSAqIDAuNyAqIE1hdGgucG93KCB0cmF2ZWxBbXRGYWN0b3IsIDAuOCApO1xyXG4gICAgICBjb25zdCBwZXJwZW5kaWN1bGFyQW5nbGUgPSBNYXRoLmF0YW4yKCBlbmRQb2ludC55IC0gc3RhcnRQb2ludC55LCBlbmRQb2ludC54IC0gc3RhcnRQb2ludC54ICkgKyBNYXRoLlBJIC8gMjtcclxuICAgICAgdGhpcy5zaGFwZURlc2NyaXB0aW9uLmNvbnRyb2xQb2ludDEuc2V0WFkoXHJcbiAgICAgICAgdGhpcy5jdXJ2ZU1pZFBvaW50LnggKyBjdHJsUG9pbnQxRGlzdGFuY2UgKiBNYXRoLmNvcyggcGVycGVuZGljdWxhckFuZ2xlICsgTWF0aC5QSSAvIDYgKSxcclxuICAgICAgICB0aGlzLmN1cnZlTWlkUG9pbnQueSArIGN0cmxQb2ludDFEaXN0YW5jZSAqIE1hdGguc2luKCBwZXJwZW5kaWN1bGFyQW5nbGUgKyBNYXRoLlBJIC8gNiApICk7XHJcbiAgICAgIHRoaXMuc2hhcGVEZXNjcmlwdGlvbi5jb250cm9sUG9pbnQyLnNldFhZKFxyXG4gICAgICAgIHRoaXMuY3VydmVNaWRQb2ludC54ICsgY3RybFBvaW50MkRpc3RhbmNlICogTWF0aC5jb3MoIHBlcnBlbmRpY3VsYXJBbmdsZSAtIE1hdGguUEkgLyA2ICksXHJcbiAgICAgICAgdGhpcy5jdXJ2ZU1pZFBvaW50LnkgKyBjdHJsUG9pbnQyRGlzdGFuY2UgKiBNYXRoLnNpbiggcGVycGVuZGljdWxhckFuZ2xlIC0gTWF0aC5QSSAvIDYgKSApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIFRoZSBhY3Rpb24gcG90ZW50aWFsIGlzIFwibGluZ2VyaW5nXCIgYXQgdGhlIHBvaW50IG9mIHRoZSBjcm9zcyBzZWN0aW9uLiAgRGVmaW5lIHRoZSBzaGFwZSBhcyBhIGNpcmNsZSB0aGF0XHJcbiAgICAgIC8vIGNoYW5nZXMgc2hhcGUgYSBiaXQuIFRoaXMgaXMgZG9uZSB3aGVuIHRoZSBhY3Rpb24gcG90ZW50aWFsIGhhcyBlc3NlbnRpYWxseSByZWFjaGVkIHRoZSBwb2ludCBvZiB0aGUgY3Jvc3NcclxuICAgICAgLy8gc2VjdGlvbi5cclxuICAgICAgdGhpcy5zaGFwZURlc2NyaXB0aW9uLm1vZGUgPSAnY2lyY2xlJztcclxuXHJcbiAgICAgIC8vIE1ha2UgdGhlIHNoYXBlIGEgbGl0dGxlIGJpZ2dlciB0aGFuIHRoZSBjcm9zcyBzZWN0aW9uIHNvIHRoYXQgaXQgY2FuIGJlIHNlZW4gYmVoaW5kIGl0LCBhbmQgaGF2ZSBpdCBncm93XHJcbiAgICAgIC8vIHdoaWxlIGl0IGlzIHRoZXJlLlxyXG4gICAgICBjb25zdCBncm93dGhGYWN0b3IgPSAoIDEgLSBNYXRoLmFicyggdGhpcy5saW5nZXJDb3VudGRvd25UaW1lciAvIExJTkdFUl9BVF9DUk9TU19TRUNUSU9OX1RJTUUgLSAwLjUgKSAqIDIgKSAqIDAuMDQgKyAxO1xyXG4gICAgICB0aGlzLnNoYXBlRGVzY3JpcHRpb24uY2lyY2xlUmFkaXVzID0gdGhpcy5heG9uTWVtYnJhbmUuY3Jvc3NTZWN0aW9uQ2lyY2xlUmFkaXVzICogZ3Jvd3RoRmFjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2hhcGVDaGFuZ2VkLmVtaXQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc3RhdGUgZnJvbSBhIChwcm9iYWJseSBwcmV2aW91c2x5IGNhcHR1cmVkKSB2ZXJzaW9uIG9mIHRoZSBpbnRlcm5hbCBzdGF0ZS5cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgc2V0U3RhdGUoIHN0YXRlICkge1xyXG4gICAgdGhpcy50cmF2ZWxUaW1lQ291bnRkb3duVGltZXIgPSBzdGF0ZS5nZXRUcmF2ZWxUaW1lQ291bnRkb3duVGltZXIoKTtcclxuICAgIHRoaXMubGluZ2VyQ291bnRkb3duVGltZXIgPSBzdGF0ZS5nZXRMaW5nZXJDb3VudGRvd25UaW1lcigpO1xyXG4gICAgdGhpcy51cGRhdGVTaGFwZURlc2NyaXB0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXRlLCBnZW5lcmFsbHkgZm9yIHVzZSBpbiBzZXR0aW5nIHRoZSBzdGF0ZSBsYXRlciBmb3Igc29tZSBzb3J0IG9mIHBsYXliYWNrLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBnZXRTdGF0ZSgpIHtcclxuICAgIHJldHVybiBuZXcgVHJhdmVsaW5nQWN0aW9uUG90ZW50aWFsU3RhdGUoIHRoaXMudHJhdmVsVGltZUNvdW50ZG93blRpbWVyLCB0aGlzLmxpbmdlckNvdW50ZG93blRpbWVyICk7XHJcbiAgfVxyXG59XHJcblxyXG5uZXVyb24ucmVnaXN0ZXIoICdUcmF2ZWxpbmdBY3Rpb25Qb3RlbnRpYWwnLCBUcmF2ZWxpbmdBY3Rpb25Qb3RlbnRpYWwgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRyYXZlbGluZ0FjdGlvblBvdGVudGlhbDtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLE9BQU8sTUFBTSxnQ0FBZ0M7QUFDcEQsT0FBT0MsS0FBSyxNQUFNLDZCQUE2QjtBQUMvQyxPQUFPQyxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLE1BQU0sTUFBTSxpQkFBaUI7QUFDcEMsT0FBT0MsNkJBQTZCLE1BQU0sb0NBQW9DOztBQUU5RTtBQUNBLE1BQU1DLGNBQWMsR0FBRyxNQUFNLENBQUMsQ0FBQztBQUMvQixNQUFNQyw0QkFBNEIsR0FBRyxNQUFNLENBQUMsQ0FBQztBQUM3QyxNQUFNQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsQ0FBQzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQywwQkFBMEJBLENBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxXQUFXLEVBQUc7RUFDckVDLE1BQU0sSUFBSUEsTUFBTSxDQUFFSCxVQUFVLElBQUksQ0FBQyxJQUFJQSxVQUFVLElBQUksQ0FBQyxFQUFFLDRCQUE2QixDQUFDO0VBQ3BGLE1BQU1JLDBCQUEwQixHQUFHSixVQUFVLElBQUtDLE1BQU0sQ0FBQ0ksTUFBTSxHQUFHLENBQUMsQ0FBRTtFQUNyRSxNQUFNQyxpQkFBaUIsR0FBR2QsS0FBSyxDQUFDZSxjQUFjLENBQUVILDBCQUEyQixDQUFDO0VBQzVFLE1BQU1JLHFCQUFxQixHQUFHSiwwQkFBMEIsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHRSxpQkFBaUIsR0FBRyxD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