// Copyright 2020-2023, University of Colorado Boulder

/**
 * CurveNode is the view representation of a single Curve, which appears in all screens of the 'Calculus Grapher'
 * simulation. CurveNode is implemented to work for all Curve subclasses, so no CurveNode subclasses are needed.
 *
 * Primary responsibilities are:
 *  - Create a LinePlot to represent the continuous segments of the curve.
 *  - Create a LinePlot to represent the discontinuous vertical dashed lines.
 *  - Create a ScatterPlot from the curve points to represent the discontinuous points.
 *  - Create optional ScatterPlots representing cusp points and all points for debug purposes.
 *  - Create various dataSets from the curve points that can be consumed by LinePlot and ScatterPlot.
 *  - Update itself when curveChangeEmitter sends a signal.
 *
 *  For performance reasons, the bounds method used by bamboo is exposed as an option. If the options.plotBoundsMethod is
 *  set to none, then the options.plotBounds must be provided.
 *
 * For the 'Calculus Grapher' sim, the same Curves instances are used throughout the lifetime of the simulation. Thus,
 * CurveNodes persist for the lifetime of the simulation and links are left as-is. See Curve.js for more background.
 *
 * @author Brandon Li
 * @author Martin Veillette
 */

import optionize, { combineOptions } from '../../../../phet-core/js/optionize.js';
import { Color, Node, ProfileColorProperty } from '../../../../scenery/js/imports.js';
import calculusGrapher from '../../calculusGrapher.js';
import LinePlot from '../../../../bamboo/js/LinePlot.js';
import ScatterPlot from '../../../../bamboo/js/ScatterPlot.js';
import CalculusGrapherQueryParameters from '../CalculusGrapherQueryParameters.js';
import CalculusGrapherPreferences from '../model/CalculusGrapherPreferences.js';
import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import DiscontinuousPointsPlot from './DiscontinuousPointsPlot.js'; // dateset types associated with LinePlot and ScatterPlot

// dateset types associated with LinePlot and ScatterPlot
export default class CurveNode extends Node {
  // The curve that this Node displays

  // Plots the continuous parts of the curve

  // Plots the optional dashed lines that connect discontinuities (see Discontinuities in the Preferences dialog)

  // Plots points at discontinuities

  // These plots are created conditionally for debugging. See ?allPoints and ?cuspPoints.

  constructor(curve, chartTransform, providedOptions) {
    const options = optionize()({
      // SelfOptions
      plotBoundsMethod: 'accurate',
      plotBounds: null,
      phetioVisiblePropertyInstrumented: false // see https://github.com/phetsims/calculus-grapher/issues/225#issuecomment-1472231009
    }, providedOptions);
    assert && assert(options.plotBoundsMethod !== 'none' || options.plotBounds !== null, 'plotBounds must be provided when plotBoundsMethod is none');
    super(options);
    this.curve = curve;
    this.continuousLinePlot = new LinePlot(chartTransform, this.getContinuousLinePlotDataSet(), combineOptions({
      stroke: options.stroke,
      lineWidth: 2,
      boundsMethod: options.plotBoundsMethod
    }, options.continuousLinePlotOptions));
    this.addChild(this.continuousLinePlot);
    this.discontinuousLinePlot = new LinePlot(chartTransform, this.getDiscontinuousLinePlotDataSet(), {
      stroke: options.stroke,
      lineWidth: 2,
      lineDash: [2, 2],
      boundsMethod: options.plotBoundsMethod,
      visibleProperty: new DerivedProperty([CalculusGrapherPreferences.connectDiscontinuitiesProperty], connectDiscontinuities => connectDiscontinuities === 'dashedLine')
    });
    this.addChild(this.discontinuousLinePlot);
    this.discontinuousPointsPlot = new DiscontinuousPointsPlot(chartTransform, this.getDiscontinuousPointsScatterPlotDataSet(), {
      fill: options.discontinuousPointsFill,
      stroke: options.stroke,
      boundsMethod: options.plotBoundsMethod
    });
    this.addChild(this.discontinuousPointsPlot);
    if (options.plotBounds) {
      this.continuousLinePlot.localBounds = options.plotBounds;
      this.discontinuousLinePlot.localBounds = options.plotBounds;
      this.discontinuousPointsPlot.localBounds = options.plotBounds;
    }

    // For debug purposes, draws all points used to approximate the curve.
    if (CalculusGrapherQueryParameters.allPoints) {
      this.allPointsPlot = new ScatterPlot(chartTransform, this.getAllPointsScatterPlotDataSet(), {
        fill: Color.WHITE,
        stroke: Color.BLACK,
        radius: 1
      });
      this.addChild(this.allPointsPlot);
    }

    // For debug purposes, draws cusp points.
    if (CalculusGrapherQueryParameters.cuspPoints) {
      this.cuspPointsPlot = new ScatterPlot(chartTransform, this.getCuspsScatterPlotDataSet(), {
        fill: Color.BLACK,
        stroke: Color.GREEN,
        lineWidth: 1,
        radius: 2
      });
      this.addChild(this.cuspPointsPlot);
    }
    curve.curveChangedEmitter.addListener(this.updateCurveNode.bind(this));

    // If stroke is something we can link to, create a linked element.
    const strokeProperty = options.stroke;
    if (strokeProperty instanceof ProfileColorProperty) {
      this.addLinkedElement(strokeProperty, {
        tandem: options.tandem.createTandem('stroke')
      });
    }
  }
  reset() {
    // GraphNode does not know what specific subclass of CurveNode it creates, so it is necessary to have
    // a reset method in the base class, even though it does nothing.
  }
  updateCurveNode() {
    this.continuousLinePlot.setDataSet(this.getContinuousLinePlotDataSet());
    this.discontinuousLinePlot.setDataSet(this.getDiscontinuousLinePlotDataSet());
    this.discontinuousPointsPlot.setDataSet(this.getDiscontinuousPointsScatterPlotDataSet());

    // optional plots, for debugging
    this.allPointsPlot && this.allPointsPlot.setDataSet(this.getAllPointsScatterPlotDataSet());
    this.cuspPointsPlot && this.cuspPointsPlot.setDataSet(this.getCuspsScatterPlotDataSet());
  }

  // Gets a dataset for continuous portion of curve
  getContinuousLinePlotDataSet() {
    const dataSet = [];
    const points = this.curve.points;
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      dataSet.push(point.getVector());

      //  In the model, a discontinuity is marked by tagging two adjacent points as discontinuous (the real discontinuity is in between the two)
      //  we need to insert a null value between two such adjacent points to break the continuous segments.
      //  The actual points of the discontinuities are included such that the continuous line goes right up to the discontinuity points.
      const isNextPointWithinRange = i + 1 < points.length;
      if (isNextPointWithinRange && point.isDiscontinuous && points[i + 1].isDiscontinuous) {
        dataSet.push(null);
      }
    }
    return dataSet;
  }

  // Gets a dataset for discontinuous line plot (a set of vertical lines)
  getDiscontinuousLinePlotDataSet() {
    // Context: In 'curve', discontinuities come into consecutive pairs. We want to include them
    // as is in the dataSet, but separate pairs with one null value.
    // Our resulting dataset should look like [ null, vec,vec, null, vec,vec, null, vec,vec, null, ...]
    const dataSet = [];
    const points = this.curve.points;

    // Convenience variable that tracks the state of the previous dataPoint in dataSet
    let previousDataPointWasNull = false;
    for (let i = 0; i < points.length; i++) {
      const point = points[i];

      // Add point to the dataSet if the point is discontinuous.
      if (point.isDiscontinuous) {
        dataSet.push(point.getVector());

        // The point added was not null
        previousDataPointWasNull = false;
      }

      // We want to add a null value to the dataSet if the point is not discontinuous.
      // For performance reasons, we do not want to stack the dataSet with multiple adjacent null values
      else if (!previousDataPointWasNull) {
        dataSet.push(null);

        // The point added was null
        previousDataPointWasNull = true;
      }
    }
    return dataSet;
  }

  // Gets a dataset for discontinuous scatter plot ( sets of circles )
  getDiscontinuousPointsScatterPlotDataSet() {
    const dataSet = [];
    const points = this.curve.points;
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      if (point.isDiscontinuous) {
        dataSet.push(point.getVector());
      }
    }
    return dataSet;
  }

  // Gets a dataset for cusp points
  getCuspsScatterPlotDataSet() {
    const dataSet = [];
    const points = this.curve.points;
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      if (point.isCusp) {
        dataSet.push(point.getVector());
      }
    }
    return dataSet;
  }

  // Gets a dataset for all points
  getAllPointsScatterPlotDataSet() {
    return this.curve.points.map(point => point.getVector());
  }
}
calculusGrapher.register('CurveNode', CurveNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJvcHRpb25pemUiLCJjb21iaW5lT3B0aW9ucyIsIkNvbG9yIiwiTm9kZSIsIlByb2ZpbGVDb2xvclByb3BlcnR5IiwiY2FsY3VsdXNHcmFwaGVyIiwiTGluZVBsb3QiLCJTY2F0dGVyUGxvdCIsIkNhbGN1bHVzR3JhcGhlclF1ZXJ5UGFyYW1ldGVycyIsIkNhbGN1bHVzR3JhcGhlclByZWZlcmVuY2VzIiwiRGVyaXZlZFByb3BlcnR5IiwiRGlzY29udGludW91c1BvaW50c1Bsb3QiLCJDdXJ2ZU5vZGUiLCJjb25zdHJ1Y3RvciIsImN1cnZlIiwiY2hhcnRUcmFuc2Zvcm0iLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwicGxvdEJvdW5kc01ldGhvZCIsInBsb3RCb3VuZHMiLCJwaGV0aW9WaXNpYmxlUHJvcGVydHlJbnN0cnVtZW50ZWQiLCJhc3NlcnQiLCJjb250aW51b3VzTGluZVBsb3QiLCJnZXRDb250aW51b3VzTGluZVBsb3REYXRhU2V0Iiwic3Ryb2tlIiwibGluZVdpZHRoIiwiYm91bmRzTWV0aG9kIiwiY29udGludW91c0xpbmVQbG90T3B0aW9ucyIsImFkZENoaWxkIiwiZGlzY29udGludW91c0xpbmVQbG90IiwiZ2V0RGlzY29udGludW91c0xpbmVQbG90RGF0YVNldCIsImxpbmVEYXNoIiwidmlzaWJsZVByb3BlcnR5IiwiY29ubmVjdERpc2NvbnRpbnVpdGllc1Byb3BlcnR5IiwiY29ubmVjdERpc2NvbnRpbnVpdGllcyIsImRpc2NvbnRpbnVvdXNQb2ludHNQbG90IiwiZ2V0RGlzY29udGludW91c1BvaW50c1NjYXR0ZXJQbG90RGF0YVNldCIsImZpbGwiLCJkaXNjb250aW51b3VzUG9pbnRzRmlsbCIsImxvY2FsQm91bmRzIiwiYWxsUG9pbnRzIiwiYWxsUG9pbnRzUGxvdCIsImdldEFsbFBvaW50c1NjYXR0ZXJQbG90RGF0YVNldCIsIldISVRFIiwiQkxBQ0siLCJyYWRpdXMiLCJjdXNwUG9pbnRzIiwiY3VzcFBvaW50c1Bsb3QiLCJnZXRDdXNwc1NjYXR0ZXJQbG90RGF0YVNldCIsIkdSRUVOIiwiY3VydmVDaGFuZ2VkRW1pdHRlciIsImFkZExpc3RlbmVyIiwidXBkYXRlQ3VydmVOb2RlIiwiYmluZCIsInN0cm9rZVByb3BlcnR5IiwiYWRkTGlua2VkRWxlbWVudCIsInRhbmRlbSIsImNyZWF0ZVRhbmRlbSIsInJlc2V0Iiwic2V0RGF0YVNldCIsImRhdGFTZXQiLCJwb2ludHMiLCJpIiwibGVuZ3RoIiwicG9pbnQiLCJwdXNoIiwiZ2V0VmVjdG9yIiwiaXNOZXh0UG9pbnRXaXRoaW5SYW5nZSIsImlzRGlzY29udGludW91cyIsInByZXZpb3VzRGF0YVBvaW50V2FzTnVsbCIsImlzQ3VzcCIsIm1hcCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQ3VydmVOb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIwLTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEN1cnZlTm9kZSBpcyB0aGUgdmlldyByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBDdXJ2ZSwgd2hpY2ggYXBwZWFycyBpbiBhbGwgc2NyZWVucyBvZiB0aGUgJ0NhbGN1bHVzIEdyYXBoZXInXHJcbiAqIHNpbXVsYXRpb24uIEN1cnZlTm9kZSBpcyBpbXBsZW1lbnRlZCB0byB3b3JrIGZvciBhbGwgQ3VydmUgc3ViY2xhc3Nlcywgc28gbm8gQ3VydmVOb2RlIHN1YmNsYXNzZXMgYXJlIG5lZWRlZC5cclxuICpcclxuICogUHJpbWFyeSByZXNwb25zaWJpbGl0aWVzIGFyZTpcclxuICogIC0gQ3JlYXRlIGEgTGluZVBsb3QgdG8gcmVwcmVzZW50IHRoZSBjb250aW51b3VzIHNlZ21lbnRzIG9mIHRoZSBjdXJ2ZS5cclxuICogIC0gQ3JlYXRlIGEgTGluZVBsb3QgdG8gcmVwcmVzZW50IHRoZSBkaXNjb250aW51b3VzIHZlcnRpY2FsIGRhc2hlZCBsaW5lcy5cclxuICogIC0gQ3JlYXRlIGEgU2NhdHRlclBsb3QgZnJvbSB0aGUgY3VydmUgcG9pbnRzIHRvIHJlcHJlc2VudCB0aGUgZGlzY29udGludW91cyBwb2ludHMuXHJcbiAqICAtIENyZWF0ZSBvcHRpb25hbCBTY2F0dGVyUGxvdHMgcmVwcmVzZW50aW5nIGN1c3AgcG9pbnRzIGFuZCBhbGwgcG9pbnRzIGZvciBkZWJ1ZyBwdXJwb3Nlcy5cclxuICogIC0gQ3JlYXRlIHZhcmlvdXMgZGF0YVNldHMgZnJvbSB0aGUgY3VydmUgcG9pbnRzIHRoYXQgY2FuIGJlIGNvbnN1bWVkIGJ5IExpbmVQbG90IGFuZCBTY2F0dGVyUGxvdC5cclxuICogIC0gVXBkYXRlIGl0c2VsZiB3aGVuIGN1cnZlQ2hhbmdlRW1pdHRlciBzZW5kcyBhIHNpZ25hbC5cclxuICpcclxuICogIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB0aGUgYm91bmRzIG1ldGhvZCB1c2VkIGJ5IGJhbWJvbyBpcyBleHBvc2VkIGFzIGFuIG9wdGlvbi4gSWYgdGhlIG9wdGlvbnMucGxvdEJvdW5kc01ldGhvZCBpc1xyXG4gKiAgc2V0IHRvIG5vbmUsIHRoZW4gdGhlIG9wdGlvbnMucGxvdEJvdW5kcyBtdXN0IGJlIHByb3ZpZGVkLlxyXG4gKlxyXG4gKiBGb3IgdGhlICdDYWxjdWx1cyBHcmFwaGVyJyBzaW0sIHRoZSBzYW1lIEN1cnZlcyBpbnN0YW5jZXMgYXJlIHVzZWQgdGhyb3VnaG91dCB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbXVsYXRpb24uIFRodXMsXHJcbiAqIEN1cnZlTm9kZXMgcGVyc2lzdCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW11bGF0aW9uIGFuZCBsaW5rcyBhcmUgbGVmdCBhcy1pcy4gU2VlIEN1cnZlLmpzIGZvciBtb3JlIGJhY2tncm91bmQuXHJcbiAqXHJcbiAqIEBhdXRob3IgQnJhbmRvbiBMaVxyXG4gKiBAYXV0aG9yIE1hcnRpbiBWZWlsbGV0dGVcclxuICovXHJcblxyXG5pbXBvcnQgb3B0aW9uaXplLCB7IGNvbWJpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCB7IENvbG9yLCBOb2RlLCBOb2RlT3B0aW9ucywgUGF0aEJvdW5kc01ldGhvZCwgUHJvZmlsZUNvbG9yUHJvcGVydHksIFRDb2xvciwgVFBhaW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IGNhbGN1bHVzR3JhcGhlciBmcm9tICcuLi8uLi9jYWxjdWx1c0dyYXBoZXIuanMnO1xyXG5pbXBvcnQgQ3VydmUgZnJvbSAnLi4vbW9kZWwvQ3VydmUuanMnO1xyXG5pbXBvcnQgTGluZVBsb3QsIHsgTGluZVBsb3RPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFtYm9vL2pzL0xpbmVQbG90LmpzJztcclxuaW1wb3J0IFNjYXR0ZXJQbG90IGZyb20gJy4uLy4uLy4uLy4uL2JhbWJvby9qcy9TY2F0dGVyUGxvdC5qcyc7XHJcbmltcG9ydCBDaGFydFRyYW5zZm9ybSBmcm9tICcuLi8uLi8uLi8uLi9iYW1ib28vanMvQ2hhcnRUcmFuc2Zvcm0uanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBDYWxjdWx1c0dyYXBoZXJRdWVyeVBhcmFtZXRlcnMgZnJvbSAnLi4vQ2FsY3VsdXNHcmFwaGVyUXVlcnlQYXJhbWV0ZXJzLmpzJztcclxuaW1wb3J0IENhbGN1bHVzR3JhcGhlclByZWZlcmVuY2VzIGZyb20gJy4uL21vZGVsL0NhbGN1bHVzR3JhcGhlclByZWZlcmVuY2VzLmpzJztcclxuaW1wb3J0IERlcml2ZWRQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0Rlcml2ZWRQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBQaWNrT3B0aW9uYWwgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL1BpY2tPcHRpb25hbC5qcyc7XHJcbmltcG9ydCBQaWNrUmVxdWlyZWQgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL1BpY2tSZXF1aXJlZC5qcyc7XHJcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcclxuaW1wb3J0IFN0cmljdE9taXQgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL1N0cmljdE9taXQuanMnO1xyXG5pbXBvcnQgRGlzY29udGludW91c1BvaW50c1Bsb3QgZnJvbSAnLi9EaXNjb250aW51b3VzUG9pbnRzUGxvdC5qcyc7IC8vIGRhdGVzZXQgdHlwZXMgYXNzb2NpYXRlZCB3aXRoIExpbmVQbG90IGFuZCBTY2F0dGVyUGxvdFxyXG5cclxuLy8gZGF0ZXNldCB0eXBlcyBhc3NvY2lhdGVkIHdpdGggTGluZVBsb3QgYW5kIFNjYXR0ZXJQbG90XHJcbnR5cGUgTGluZVBsb3REYXRhU2V0ID0gKCBWZWN0b3IyIHwgbnVsbCApW107XHJcbnR5cGUgU2NhdHRlclBsb3REYXRhU2V0ID0gKCBWZWN0b3IyIClbXTtcclxuXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSB7XHJcblxyXG4gIC8vIEZpbGwgZm9yIHRoZSBjdXJ2ZSBwYXRoXHJcbiAgc3Ryb2tlOiBUQ29sb3I7XHJcblxyXG4gIC8vIEZpbGwgZm9yIGRpc2NvbnRpbnVvdXMgcG9pbnRzLCB3aGljaCBpcyB0eXBpY2FsbHkgdGhlIHNhbWUgYXMgdGhlIGNoYXJ0IG9yIHBhbmVsIGJhY2tncm91bmRcclxuICBkaXNjb250aW51b3VzUG9pbnRzRmlsbDogVFBhaW50O1xyXG5cclxuICAvLyBvcHRpb25zIHByb3BhZ2F0ZWQgdG8gY29udGludW91c0xpbmVQbG90XHJcbiAgY29udGludW91c0xpbmVQbG90T3B0aW9ucz86IFBpY2tPcHRpb25hbDxMaW5lUGxvdCwgJ2xpbmVXaWR0aCcgfCAnbGluZURhc2gnPjtcclxuXHJcbiAgLy8gYm91bmRzTWV0aG9kIHRvIGJlIHVzZWQgd2l0aCBiYW1ib28gcGxvdHMuIE92ZXJyaWRlIHRoaXMgd2hlcmUgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIGlzIG5lZWRlZC5cclxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NhbGN1bHVzLWdyYXBoZXIvaXNzdWVzLzIxMCBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NhbGN1bHVzLWdyYXBoZXIvaXNzdWVzLzIyNlxyXG4gIHBsb3RCb3VuZHNNZXRob2Q/OiBQYXRoQm91bmRzTWV0aG9kO1xyXG5cclxuICAvLyBXaGVuIHBsb3RCb3VuZHNNZXRob2QgaXMgJ25vbmUnLCBwbG90Qm91bmRzIHdpbGwgYmUgcmVxdWlyZWQgdG8gZ2l2ZSBjb3JyZWN0IChwb3RlbnRpYWwpIGJvdW5kcyBmb3IgdGhlIHBsb3QuXHJcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jYWxjdWx1cy1ncmFwaGVyL2lzc3Vlcy8yNTlcclxuICBwbG90Qm91bmRzPzogQm91bmRzMiB8IG51bGw7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBDdXJ2ZU5vZGVPcHRpb25zID0gU2VsZk9wdGlvbnMgJlxyXG4gIFBpY2tPcHRpb25hbDxOb2RlT3B0aW9ucywgJ3Zpc2libGVQcm9wZXJ0eScgfCAnY2xpcEFyZWEnIHwgJ3BoZXRpb0lucHV0RW5hYmxlZFByb3BlcnR5SW5zdHJ1bWVudGVkJyB8ICdyZW5kZXJlcic+ICZcclxuICBQaWNrUmVxdWlyZWQ8Tm9kZU9wdGlvbnMsICd0YW5kZW0nPjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1cnZlTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvLyBUaGUgY3VydmUgdGhhdCB0aGlzIE5vZGUgZGlzcGxheXNcclxuICBwdWJsaWMgcmVhZG9ubHkgY3VydmU6IEN1cnZlO1xyXG5cclxuICAvLyBQbG90cyB0aGUgY29udGludW91cyBwYXJ0cyBvZiB0aGUgY3VydmVcclxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgY29udGludW91c0xpbmVQbG90OiBMaW5lUGxvdDtcclxuXHJcbiAgLy8gUGxvdHMgdGhlIG9wdGlvbmFsIGRhc2hlZCBsaW5lcyB0aGF0IGNvbm5lY3QgZGlzY29udGludWl0aWVzIChzZWUgRGlzY29udGludWl0aWVzIGluIHRoZSBQcmVmZXJlbmNlcyBkaWFsb2cpXHJcbiAgcHJpdmF0ZSByZWFkb25seSBkaXNjb250aW51b3VzTGluZVBsb3Q6IExpbmVQbG90O1xyXG5cclxuICAvLyBQbG90cyBwb2ludHMgYXQgZGlzY29udGludWl0aWVzXHJcbiAgcHJpdmF0ZSByZWFkb25seSBkaXNjb250aW51b3VzUG9pbnRzUGxvdDogRGlzY29udGludW91c1BvaW50c1Bsb3Q7XHJcblxyXG4gIC8vIFRoZXNlIHBsb3RzIGFyZSBjcmVhdGVkIGNvbmRpdGlvbmFsbHkgZm9yIGRlYnVnZ2luZy4gU2VlID9hbGxQb2ludHMgYW5kID9jdXNwUG9pbnRzLlxyXG4gIHByaXZhdGUgcmVhZG9ubHkgYWxsUG9pbnRzUGxvdD86IFNjYXR0ZXJQbG90O1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgY3VzcFBvaW50c1Bsb3Q/OiBTY2F0dGVyUGxvdDtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBjdXJ2ZTogQ3VydmUsIGNoYXJ0VHJhbnNmb3JtOiBDaGFydFRyYW5zZm9ybSwgcHJvdmlkZWRPcHRpb25zOiBDdXJ2ZU5vZGVPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8Q3VydmVOb2RlT3B0aW9ucywgU3RyaWN0T21pdDxTZWxmT3B0aW9ucywgJ2NvbnRpbnVvdXNMaW5lUGxvdE9wdGlvbnMnPiwgTm9kZU9wdGlvbnM+KCkoIHtcclxuXHJcbiAgICAgIC8vIFNlbGZPcHRpb25zXHJcbiAgICAgIHBsb3RCb3VuZHNNZXRob2Q6ICdhY2N1cmF0ZScsXHJcbiAgICAgIHBsb3RCb3VuZHM6IG51bGwsXHJcbiAgICAgIHBoZXRpb1Zpc2libGVQcm9wZXJ0eUluc3RydW1lbnRlZDogZmFsc2UgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jYWxjdWx1cy1ncmFwaGVyL2lzc3Vlcy8yMjUjaXNzdWVjb21tZW50LTE0NzIyMzEwMDlcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG9wdGlvbnMucGxvdEJvdW5kc01ldGhvZCAhPT0gJ25vbmUnIHx8IG9wdGlvbnMucGxvdEJvdW5kcyAhPT0gbnVsbCxcclxuICAgICAgJ3Bsb3RCb3VuZHMgbXVzdCBiZSBwcm92aWRlZCB3aGVuIHBsb3RCb3VuZHNNZXRob2QgaXMgbm9uZScgKTtcclxuXHJcbiAgICBzdXBlciggb3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcclxuXHJcbiAgICB0aGlzLmNvbnRpbnVvdXNMaW5lUGxvdCA9IG5ldyBMaW5lUGxvdCggY2hhcnRUcmFuc2Zvcm0sIHRoaXMuZ2V0Q29udGludW91c0xpbmVQbG90RGF0YVNldCgpLFxyXG4gICAgICBjb21iaW5lT3B0aW9uczxMaW5lUGxvdE9wdGlvbnM+KCB7XHJcbiAgICAgICAgc3Ryb2tlOiBvcHRpb25zLnN0cm9rZSxcclxuICAgICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgICAgYm91bmRzTWV0aG9kOiBvcHRpb25zLnBsb3RCb3VuZHNNZXRob2RcclxuICAgICAgfSwgb3B0aW9ucy5jb250aW51b3VzTGluZVBsb3RPcHRpb25zICkgKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIHRoaXMuY29udGludW91c0xpbmVQbG90ICk7XHJcblxyXG4gICAgdGhpcy5kaXNjb250aW51b3VzTGluZVBsb3QgPSBuZXcgTGluZVBsb3QoIGNoYXJ0VHJhbnNmb3JtLCB0aGlzLmdldERpc2NvbnRpbnVvdXNMaW5lUGxvdERhdGFTZXQoKSwge1xyXG4gICAgICBzdHJva2U6IG9wdGlvbnMuc3Ryb2tlLFxyXG4gICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgIGxpbmVEYXNoOiBbIDIsIDIgXSxcclxuICAgICAgYm91bmRzTWV0aG9kOiBvcHRpb25zLnBsb3RCb3VuZHNNZXRob2QsXHJcbiAgICAgIHZpc2libGVQcm9wZXJ0eTogbmV3IERlcml2ZWRQcm9wZXJ0eSggWyBDYWxjdWx1c0dyYXBoZXJQcmVmZXJlbmNlcy5jb25uZWN0RGlzY29udGludWl0aWVzUHJvcGVydHkgXSxcclxuICAgICAgICBjb25uZWN0RGlzY29udGludWl0aWVzID0+IGNvbm5lY3REaXNjb250aW51aXRpZXMgPT09ICdkYXNoZWRMaW5lJyApXHJcbiAgICB9ICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCB0aGlzLmRpc2NvbnRpbnVvdXNMaW5lUGxvdCApO1xyXG5cclxuICAgIHRoaXMuZGlzY29udGludW91c1BvaW50c1Bsb3QgPSBuZXcgRGlzY29udGludW91c1BvaW50c1Bsb3QoIGNoYXJ0VHJhbnNmb3JtLCB0aGlzLmdldERpc2NvbnRpbnVvdXNQb2ludHNTY2F0dGVyUGxvdERhdGFTZXQoKSwge1xyXG4gICAgICBmaWxsOiBvcHRpb25zLmRpc2NvbnRpbnVvdXNQb2ludHNGaWxsLFxyXG4gICAgICBzdHJva2U6IG9wdGlvbnMuc3Ryb2tlLFxyXG4gICAgICBib3VuZHNNZXRob2Q6IG9wdGlvbnMucGxvdEJvdW5kc01ldGhvZFxyXG4gICAgfSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggdGhpcy5kaXNjb250aW51b3VzUG9pbnRzUGxvdCApO1xyXG5cclxuICAgIGlmICggb3B0aW9ucy5wbG90Qm91bmRzICkge1xyXG4gICAgICB0aGlzLmNvbnRpbnVvdXNMaW5lUGxvdC5sb2NhbEJvdW5kcyA9IG9wdGlvbnMucGxvdEJvdW5kcztcclxuICAgICAgdGhpcy5kaXNjb250aW51b3VzTGluZVBsb3QubG9jYWxCb3VuZHMgPSBvcHRpb25zLnBsb3RCb3VuZHM7XHJcbiAgICAgIHRoaXMuZGlzY29udGludW91c1BvaW50c1Bsb3QubG9jYWxCb3VuZHMgPSBvcHRpb25zLnBsb3RCb3VuZHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9yIGRlYnVnIHB1cnBvc2VzLCBkcmF3cyBhbGwgcG9pbnRzIHVzZWQgdG8gYXBwcm94aW1hdGUgdGhlIGN1cnZlLlxyXG4gICAgaWYgKCBDYWxjdWx1c0dyYXBoZXJRdWVyeVBhcmFtZXRlcnMuYWxsUG9pbnRzICkge1xyXG4gICAgICB0aGlzLmFsbFBvaW50c1Bsb3QgPSBuZXcgU2NhdHRlclBsb3QoIGNoYXJ0VHJhbnNmb3JtLCB0aGlzLmdldEFsbFBvaW50c1NjYXR0ZXJQbG90RGF0YVNldCgpLCB7XHJcbiAgICAgICAgZmlsbDogQ29sb3IuV0hJVEUsXHJcbiAgICAgICAgc3Ryb2tlOiBDb2xvci5CTEFDSyxcclxuICAgICAgICByYWRpdXM6IDFcclxuICAgICAgfSApO1xyXG4gICAgICB0aGlzLmFkZENoaWxkKCB0aGlzLmFsbFBvaW50c1Bsb3QgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGb3IgZGVidWcgcHVycG9zZXMsIGRyYXdzIGN1c3AgcG9pbnRzLlxyXG4gICAgaWYgKCBDYWxjdWx1c0dyYXBoZXJRdWVyeVBhcmFtZXRlcnMuY3VzcFBvaW50cyApIHtcclxuICAgICAgdGhpcy5jdXNwUG9pbnRzUGxvdCA9IG5ldyBTY2F0dGVyUGxvdCggY2hhcnRUcmFuc2Zvcm0sIHRoaXMuZ2V0Q3VzcHNTY2F0dGVyUGxvdERhdGFTZXQoKSwge1xyXG4gICAgICAgIGZpbGw6IENvbG9yLkJMQUNLLFxyXG4gICAgICAgIHN0cm9rZTogQ29sb3IuR1JFRU4sXHJcbiAgICAgICAgbGluZVdpZHRoOiAxLFxyXG4gICAgICAgIHJhZGl1czogMlxyXG4gICAgICB9ICk7XHJcbiAgICAgIHRoaXMuYWRkQ2hpbGQoIHRoaXMuY3VzcFBvaW50c1Bsb3QgKTtcclxuICAgIH1cclxuXHJcbiAgICBjdXJ2ZS5jdXJ2ZUNoYW5nZWRFbWl0dGVyLmFkZExpc3RlbmVyKCB0aGlzLnVwZGF0ZUN1cnZlTm9kZS5iaW5kKCB0aGlzICkgKTtcclxuXHJcbiAgICAvLyBJZiBzdHJva2UgaXMgc29tZXRoaW5nIHdlIGNhbiBsaW5rIHRvLCBjcmVhdGUgYSBsaW5rZWQgZWxlbWVudC5cclxuICAgIGNvbnN0IHN0cm9rZVByb3BlcnR5ID0gb3B0aW9ucy5zdHJva2U7XHJcbiAgICBpZiAoIHN0cm9rZVByb3BlcnR5IGluc3RhbmNlb2YgUHJvZmlsZUNvbG9yUHJvcGVydHkgKSB7XHJcbiAgICAgIHRoaXMuYWRkTGlua2VkRWxlbWVudCggc3Ryb2tlUHJvcGVydHksIHtcclxuICAgICAgICB0YW5kZW06IG9wdGlvbnMudGFuZGVtLmNyZWF0ZVRhbmRlbSggJ3N0cm9rZScgKVxyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAvLyBHcmFwaE5vZGUgZG9lcyBub3Qga25vdyB3aGF0IHNwZWNpZmljIHN1YmNsYXNzIG9mIEN1cnZlTm9kZSBpdCBjcmVhdGVzLCBzbyBpdCBpcyBuZWNlc3NhcnkgdG8gaGF2ZVxyXG4gICAgLy8gYSByZXNldCBtZXRob2QgaW4gdGhlIGJhc2UgY2xhc3MsIGV2ZW4gdGhvdWdoIGl0IGRvZXMgbm90aGluZy5cclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCB1cGRhdGVDdXJ2ZU5vZGUoKTogdm9pZCB7XHJcbiAgICB0aGlzLmNvbnRpbnVvdXNMaW5lUGxvdC5zZXREYXRhU2V0KCB0aGlzLmdldENvbnRpbnVvdXNMaW5lUGxvdERhdGFTZXQoKSApO1xyXG4gICAgdGhpcy5kaXNjb250aW51b3VzTGluZVBsb3Quc2V0RGF0YVNldCggdGhpcy5nZXREaXNjb250aW51b3VzTGluZVBsb3REYXRhU2V0KCkgKTtcclxuICAgIHRoaXMuZGlzY29udGludW91c1BvaW50c1Bsb3Quc2V0RGF0YVNldCggdGhpcy5nZXREaXNjb250aW51b3VzUG9pbnRzU2NhdHRlclBsb3REYXRhU2V0KCkgKTtcclxuXHJcbiAgICAvLyBvcHRpb25hbCBwbG90cywgZm9yIGRlYnVnZ2luZ1xyXG4gICAgdGhpcy5hbGxQb2ludHNQbG90ICYmIHRoaXMuYWxsUG9pbnRzUGxvdC5zZXREYXRhU2V0KCB0aGlzLmdldEFsbFBvaW50c1NjYXR0ZXJQbG90RGF0YVNldCgpICk7XHJcbiAgICB0aGlzLmN1c3BQb2ludHNQbG90ICYmIHRoaXMuY3VzcFBvaW50c1Bsb3Quc2V0RGF0YVNldCggdGhpcy5nZXRDdXNwc1NjYXR0ZXJQbG90RGF0YVNldCgpICk7XHJcbiAgfVxyXG5cclxuICAvLyBHZXRzIGEgZGF0YXNldCBmb3IgY29udGludW91cyBwb3J0aW9uIG9mIGN1cnZlXHJcbiAgcHJpdmF0ZSBnZXRDb250aW51b3VzTGluZVBsb3REYXRhU2V0KCk6IExpbmVQbG90RGF0YVNldCB7XHJcbiAgICBjb25zdCBkYXRhU2V0ID0gW107XHJcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnZlLnBvaW50cztcclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbIGkgXTtcclxuICAgICAgZGF0YVNldC5wdXNoKCBwb2ludC5nZXRWZWN0b3IoKSApO1xyXG5cclxuICAgICAgLy8gIEluIHRoZSBtb2RlbCwgYSBkaXNjb250aW51aXR5IGlzIG1hcmtlZCBieSB0YWdnaW5nIHR3byBhZGphY2VudCBwb2ludHMgYXMgZGlzY29udGludW91cyAodGhlIHJlYWwgZGlzY29udGludWl0eSBpcyBpbiBiZXR3ZWVuIHRoZSB0d28pXHJcbiAgICAgIC8vICB3ZSBuZWVkIHRvIGluc2VydCBhIG51bGwgdmFsdWUgYmV0d2VlbiB0d28gc3VjaCBhZGphY2VudCBwb2ludHMgdG8gYnJlYWsgdGhlIGNvbnRpbnVvdXMgc2VnbWVudHMuXHJcbiAgICAgIC8vICBUaGUgYWN0dWFsIHBvaW50cyBvZiB0aGUgZGlzY29udGludWl0aWVzIGFyZSBpbmNsdWRlZCBzdWNoIHRoYXQgdGhlIGNvbnRpbnVvdXMgbGluZSBnb2VzIHJpZ2h0IHVwIHRvIHRoZSBkaXNjb250aW51aXR5IHBvaW50cy5cclxuICAgICAgY29uc3QgaXNOZXh0UG9pbnRXaXRoaW5SYW5nZSA9IGkgKyAxIDwgcG9pbnRzLmxlbmd0aDtcclxuICAgICAgaWYgKCBpc05leHRQb2ludFdpdGhpblJhbmdlICYmIHBvaW50LmlzRGlzY29udGludW91cyAmJiBwb2ludHNbIGkgKyAxIF0uaXNEaXNjb250aW51b3VzICkge1xyXG4gICAgICAgIGRhdGFTZXQucHVzaCggbnVsbCApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YVNldDtcclxuICB9XHJcblxyXG4gIC8vIEdldHMgYSBkYXRhc2V0IGZvciBkaXNjb250aW51b3VzIGxpbmUgcGxvdCAoYSBzZXQgb2YgdmVydGljYWwgbGluZXMpXHJcbiAgcHJpdmF0ZSBnZXREaXNjb250aW51b3VzTGluZVBsb3REYXRhU2V0KCk6IExpbmVQbG90RGF0YVNldCB7XHJcblxyXG4gICAgLy8gQ29udGV4dDogSW4gJ2N1cnZlJywgZGlzY29udGludWl0aWVzIGNvbWUgaW50byBjb25zZWN1dGl2ZSBwYWlycy4gV2Ugd2FudCB0byBpbmNsdWRlIHRoZW1cclxuICAgIC8vIGFzIGlzIGluIHRoZSBkYXRhU2V0LCBidXQgc2VwYXJhdGUgcGFpcnMgd2l0aCBvbmUgbnVsbCB2YWx1ZS5cclxuICAgIC8vIE91ciByZXN1bHRpbmcgZGF0YXNldCBzaG91bGQgbG9vayBsaWtlIFsgbnVsbCwgdmVjLHZlYywgbnVsbCwgdmVjLHZlYywgbnVsbCwgdmVjLHZlYywgbnVsbCwgLi4uXVxyXG4gICAgY29uc3QgZGF0YVNldDogTGluZVBsb3REYXRhU2V0ID0gW107XHJcblxyXG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5jdXJ2ZS5wb2ludHM7XHJcblxyXG4gICAgLy8gQ29udmVuaWVuY2UgdmFyaWFibGUgdGhhdCB0cmFja3MgdGhlIHN0YXRlIG9mIHRoZSBwcmV2aW91cyBkYXRhUG9pbnQgaW4gZGF0YVNldFxyXG4gICAgbGV0IHByZXZpb3VzRGF0YVBvaW50V2FzTnVsbCA9IGZhbHNlO1xyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1sgaSBdO1xyXG5cclxuICAgICAgLy8gQWRkIHBvaW50IHRvIHRoZSBkYXRhU2V0IGlmIHRoZSBwb2ludCBpcyBkaXNjb250aW51b3VzLlxyXG4gICAgICBpZiAoIHBvaW50LmlzRGlzY29udGludW91cyApIHtcclxuICAgICAgICBkYXRhU2V0LnB1c2goIHBvaW50LmdldFZlY3RvcigpICk7XHJcblxyXG4gICAgICAgIC8vIFRoZSBwb2ludCBhZGRlZCB3YXMgbm90IG51bGxcclxuICAgICAgICBwcmV2aW91c0RhdGFQb2ludFdhc051bGwgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXZSB3YW50IHRvIGFkZCBhIG51bGwgdmFsdWUgdG8gdGhlIGRhdGFTZXQgaWYgdGhlIHBvaW50IGlzIG5vdCBkaXNjb250aW51b3VzLlxyXG4gICAgICAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgZG8gbm90IHdhbnQgdG8gc3RhY2sgdGhlIGRhdGFTZXQgd2l0aCBtdWx0aXBsZSBhZGphY2VudCBudWxsIHZhbHVlc1xyXG4gICAgICBlbHNlIGlmICggIXByZXZpb3VzRGF0YVBvaW50V2FzTnVsbCApIHtcclxuICAgICAgICBkYXRhU2V0LnB1c2goIG51bGwgKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHBvaW50IGFkZGVkIHdhcyBudWxsXHJcbiAgICAgICAgcHJldmlvdXNEYXRhUG9pbnRXYXNOdWxsID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGFTZXQ7XHJcbiAgfVxyXG5cclxuICAvLyBHZXRzIGEgZGF0YXNldCBmb3IgZGlzY29udGludW91cyBzY2F0dGVyIHBsb3QgKCBzZXRzIG9mIGNpcmNsZXMgKVxyXG4gIHByaXZhdGUgZ2V0RGlzY29udGludW91c1BvaW50c1NjYXR0ZXJQbG90RGF0YVNldCgpOiBTY2F0dGVyUGxvdERhdGFTZXQge1xyXG4gICAgY29uc3QgZGF0YVNldCA9IFtdO1xyXG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5jdXJ2ZS5wb2ludHM7XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzWyBpIF07XHJcbiAgICAgIGlmICggcG9pbnQuaXNEaXNjb250aW51b3VzICkge1xyXG4gICAgICAgIGRhdGFTZXQucHVzaCggcG9pbnQuZ2V0VmVjdG9yKCkgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGFTZXQ7XHJcbiAgfVxyXG5cclxuICAvLyBHZXRzIGEgZGF0YXNldCBmb3IgY3VzcCBwb2ludHNcclxuICBwcml2YXRlIGdldEN1c3BzU2NhdHRlclBsb3REYXRhU2V0KCk6IFNjYXR0ZXJQbG90RGF0YVNldCB7XHJcbiAgICBjb25zdCBkYXRhU2V0ID0gW107XHJcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnZlLnBvaW50cztcclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbIGkgXTtcclxuICAgICAgaWYgKCBwb2ludC5pc0N1c3AgKSB7XHJcbiAgICAgICAgZGF0YVNldC5wdXNoKCBwb2ludC5nZXRWZWN0b3IoKSApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YVNldDtcclxuICB9XHJcblxyXG4gIC8vIEdldHMgYSBkYXRhc2V0IGZvciBhbGwgcG9pbnRzXHJcbiAgcHJpdmF0ZSBnZXRBbGxQb2ludHNTY2F0dGVyUGxvdERhdGFTZXQoKTogU2NhdHRlclBsb3REYXRhU2V0IHtcclxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50cy5tYXAoIHBvaW50ID0+IHBvaW50LmdldFZlY3RvcigpICk7XHJcbiAgfVxyXG59XHJcblxyXG5jYWxjdWx1c0dyYXBoZXIu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