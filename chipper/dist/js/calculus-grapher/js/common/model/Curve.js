// Copyright 2020-2023, University of Colorado Boulder

/**
 * Curve is the base class for a single 'curve' that appears in the 'Calculus Grapher' simulation. It provides
 * functionality that is common to all types of curves, and is intended to be sub-classed for type-specific features.
 *
 * Curves are modeled by segmenting the curve into a finite number of CurvePoints that are close together and map out
 * their y-values to the shape of a function. Adjacent CurvePoints are considered to be infinitesimally close
 * enough for derivative and integral computations and are considered to cover 'every' x-value within its domain.
 *
 * Responsibilities are:
 *   - Create an array of CurvePoints for the Curve.
 *   - Create convenience methods to reference and mutate CurvePoints at a given x-value.
 *   - Provide other convenience methods to set the initial value of the curve points.
 *
 * For the 'Calculus Grapher' sim, the same Curves instances are used throughout the lifetime of the simulation, so no
 * dispose method is necessary. An overview for the class hierarchy of Curves is given in
 * https://github.com/phetsims/calculus-grapher/blob/master/doc/implementation-notes.md
 *
 * @author Brandon Li
 * @author Martin Veillette
 */

import Emitter from '../../../../axon/js/Emitter.js';
import Utils from '../../../../dot/js/Utils.js';
import PhetioObject from '../../../../tandem/js/PhetioObject.js';
import calculusGrapher from '../../calculusGrapher.js';
import CalculusGrapherConstants from '../CalculusGrapherConstants.js';
import CalculusGrapherQueryParameters from '../CalculusGrapherQueryParameters.js';
import CurvePoint from './CurvePoint.js';
import optionize from '../../../../phet-core/js/optionize.js';
import Property from '../../../../axon/js/Property.js';
import ArrayIO from '../../../../tandem/js/types/ArrayIO.js';

// Constants
const CURVE_X_RANGE = CalculusGrapherConstants.CURVE_X_RANGE;
const NUMBER_OF_POINTS = CalculusGrapherQueryParameters.numberOfPoints;

// phetioDocumentation for pointsProperty, which varies depending on phetioReadOnly
const DOC_READ_ONLY_TRUE = 'The discrete points that are used to approximate the curve.<br><br>' + 'Note that the value of pointsProperty is very large, and it is not intended to be human-readable.' + ' To improve performance of the simulation, the "Current Value" shown in Studio is not kept up to date.';
const DOC_READ_ONLY_FALSE = DOC_READ_ONLY_TRUE + ' Press the "Get Value" button in Studio if you need to get the current value.';
export default class Curve extends PhetioObject {
  // The collection of points that describe the curve. This is an array of CurvePoint instances that are typically
  // mutated in place, so that we have acceptable performance. If Curve was instantiated with pointsPropertyReadOnly:false,
  // then it is possible to set pointsProperty via PhET-iO.

  // Using an observable Property for the y-value was considered, but it was deemed to be
  // invasive to the performance of the simulation as observers had to listen to the yProperty
  // of all CurvePoints. See https://github.com/phetsims/calculus-grapher/issues/19
  // Range of the x-axis
  // Number of points (evenly-spaced along the x-axis) that will be used to approximate the curve
  // Delta between x coordinate values
  constructor(providedOptions) {
    const options = optionize()({
      // SelfOptions
      xRange: CURVE_X_RANGE,
      numberOfPoints: NUMBER_OF_POINTS,
      // PhetioObjectOptions
      phetioState: false,
      pointsPropertyReadOnly: true
    }, providedOptions);
    super(options);
    this.xRange = options.xRange;
    this.numberOfPoints = options.numberOfPoints;
    this.deltaX = this.xRange.getLength() / (this.numberOfPoints - 1);

    // Initial points, with equally-spaced x values, and y=0.
    const initialPoints = [];
    for (let i = 0; i < this.numberOfPoints; i++) {
      const xNormalized = i / (this.numberOfPoints - 1); // in the range [0,1]
      const x = this.xRange.expandNormalizedValue(xNormalized);
      initialPoints.push(new CurvePoint(x, 0));
    }
    const pointPropertyOptions = {
      tandem: options.tandem.createTandem('pointsProperty'),
      phetioValueType: ArrayIO(CurvePoint.CurvePointIO),
      phetioReadOnly: options.pointsPropertyReadOnly,
      // Excluding derived curves from state is a big performance improvement.
      // See https://github.com/phetsims/calculus-grapher/issues/327#issuecomment-1490428949
      phetioState: !options.pointsPropertyReadOnly,
      phetioFeatured: true,
      phetioDocumentation: options.pointsPropertyReadOnly ? DOC_READ_ONLY_TRUE : DOC_READ_ONLY_FALSE
    };
    if (options.pointsPropertyReadOnly) {
      // The array of CurvePoints is not expected to change for derived Curves, because CurvePoints are mutated in place.
      // So there is only 1 valid value, the initialPoints.
      pointPropertyOptions.validValues = [initialPoints];
    } else {
      // The array of CurvePoints may change via PhET-iO, so verify that the new array is valid.
      pointPropertyOptions.isValidValue = points => isValidPoints(initialPoints, points);
    }
    this.pointsProperty = new Property(initialPoints, pointPropertyOptions);

    // For debugging https://github.com/phetsims/calculus-grapher/issues/327, so we can see which curves
    // have their pointsProperty set when running the State Wrapper.
    phet.log && this.pointsProperty.lazyLink(() => phet.log(`${this.pointsProperty.phetioID} changed`));

    // Emits when the Curve has changed in any form. Instead of listening to a yProperty
    // of every CurvePoint, which was deemed invasive to the performance of the sim, we
    // use an Emitter that emits once after all CurvePoints are set upon manipulation.
    // See https://github.com/phetsims/calculus-grapher/issues/19
    this.curveChangedEmitter = new Emitter();
  }

  /**
   * Since pointsProperty is private, use this method to access the points. It is expected that callers will mutate
   * these points; do not add/remove points. If you mutate these points, be certain that they conform to function
   * isValidPoints, and call curveChangedEmitter.emit() after you have finished mutating.
   */
  get points() {
    return this.pointsProperty.value;
  }

  /**
   * Gets the CurvePoint whose x-value is closest to the given x-value.
   */
  getClosestPointAt(x) {
    assert && assert(Number.isFinite(x), `invalid x: ${x}`);
    return this.points[this.getClosestIndexAt(x)];
  }

  /**
   * Gets the index associated with this point.
   */
  getIndex(point) {
    const normalizedValue = this.xRange.getNormalizedValue(point.x);
    return Utils.roundSymmetric(normalizedValue * (this.numberOfPoints - 1));
  }

  /**
   * Gets the index of the array whose x-value is closest to the given x-value.
   */
  getClosestIndexAt(x) {
    assert && assert(Number.isFinite(x), `invalid x: ${x}`);
    const normalizedValue = this.xRange.getNormalizedValue(x);
    const index = Utils.roundSymmetric(normalizedValue * (this.numberOfPoints - 1));

    // Clamp the index to a point inside our range.
    return Utils.clamp(index, 0, this.points.length - 1);
  }
}

/**
 * Determines whether a new set of points is valid.
 */
function isValidPoints(initialPoints, points) {
  // The number of points must be the same.
  let isValid = initialPoints.length === points.length;

  // All x coordinates must be the same.
  for (let i = 0; i < initialPoints.length && isValid; i++) {
    isValid = initialPoints[i].x === points[i].x;
  }
  return isValid;
}
calculusGrapher.register('Curve', Curve);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFbWl0dGVyIiwiVXRpbHMiLCJQaGV0aW9PYmplY3QiLCJjYWxjdWx1c0dyYXBoZXIiLCJDYWxjdWx1c0dyYXBoZXJDb25zdGFudHMiLCJDYWxjdWx1c0dyYXBoZXJRdWVyeVBhcmFtZXRlcnMiLCJDdXJ2ZVBvaW50Iiwib3B0aW9uaXplIiwiUHJvcGVydHkiLCJBcnJheUlPIiwiQ1VSVkVfWF9SQU5HRSIsIk5VTUJFUl9PRl9QT0lOVFMiLCJudW1iZXJPZlBvaW50cyIsIkRPQ19SRUFEX09OTFlfVFJVRSIsIkRPQ19SRUFEX09OTFlfRkFMU0UiLCJDdXJ2ZSIsImNvbnN0cnVjdG9yIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsInhSYW5nZSIsInBoZXRpb1N0YXRlIiwicG9pbnRzUHJvcGVydHlSZWFkT25seSIsImRlbHRhWCIsImdldExlbmd0aCIsImluaXRpYWxQb2ludHMiLCJpIiwieE5vcm1hbGl6ZWQiLCJ4IiwiZXhwYW5kTm9ybWFsaXplZFZhbHVlIiwicHVzaCIsInBvaW50UHJvcGVydHlPcHRpb25zIiwidGFuZGVtIiwiY3JlYXRlVGFuZGVtIiwicGhldGlvVmFsdWVUeXBlIiwiQ3VydmVQb2ludElPIiwicGhldGlvUmVhZE9ubHkiLCJwaGV0aW9GZWF0dXJlZCIsInBoZXRpb0RvY3VtZW50YXRpb24iLCJ2YWxpZFZhbHVlcyIsImlzVmFsaWRWYWx1ZSIsInBvaW50cyIsImlzVmFsaWRQb2ludHMiLCJwb2ludHNQcm9wZXJ0eSIsInBoZXQiLCJsb2ciLCJsYXp5TGluayIsInBoZXRpb0lEIiwiY3VydmVDaGFuZ2VkRW1pdHRlciIsInZhbHVlIiwiZ2V0Q2xvc2VzdFBvaW50QXQiLCJhc3NlcnQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImdldENsb3Nlc3RJbmRleEF0IiwiZ2V0SW5kZXgiLCJwb2ludCIsIm5vcm1hbGl6ZWRWYWx1ZSIsImdldE5vcm1hbGl6ZWRWYWx1ZSIsInJvdW5kU3ltbWV0cmljIiwiaW5kZXgiLCJjbGFtcCIsImxlbmd0aCIsImlzVmFsaWQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkN1cnZlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIwLTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEN1cnZlIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhIHNpbmdsZSAnY3VydmUnIHRoYXQgYXBwZWFycyBpbiB0aGUgJ0NhbGN1bHVzIEdyYXBoZXInIHNpbXVsYXRpb24uIEl0IHByb3ZpZGVzXHJcbiAqIGZ1bmN0aW9uYWxpdHkgdGhhdCBpcyBjb21tb24gdG8gYWxsIHR5cGVzIG9mIGN1cnZlcywgYW5kIGlzIGludGVuZGVkIHRvIGJlIHN1Yi1jbGFzc2VkIGZvciB0eXBlLXNwZWNpZmljIGZlYXR1cmVzLlxyXG4gKlxyXG4gKiBDdXJ2ZXMgYXJlIG1vZGVsZWQgYnkgc2VnbWVudGluZyB0aGUgY3VydmUgaW50byBhIGZpbml0ZSBudW1iZXIgb2YgQ3VydmVQb2ludHMgdGhhdCBhcmUgY2xvc2UgdG9nZXRoZXIgYW5kIG1hcCBvdXRcclxuICogdGhlaXIgeS12YWx1ZXMgdG8gdGhlIHNoYXBlIG9mIGEgZnVuY3Rpb24uIEFkamFjZW50IEN1cnZlUG9pbnRzIGFyZSBjb25zaWRlcmVkIHRvIGJlIGluZmluaXRlc2ltYWxseSBjbG9zZVxyXG4gKiBlbm91Z2ggZm9yIGRlcml2YXRpdmUgYW5kIGludGVncmFsIGNvbXB1dGF0aW9ucyBhbmQgYXJlIGNvbnNpZGVyZWQgdG8gY292ZXIgJ2V2ZXJ5JyB4LXZhbHVlIHdpdGhpbiBpdHMgZG9tYWluLlxyXG4gKlxyXG4gKiBSZXNwb25zaWJpbGl0aWVzIGFyZTpcclxuICogICAtIENyZWF0ZSBhbiBhcnJheSBvZiBDdXJ2ZVBvaW50cyBmb3IgdGhlIEN1cnZlLlxyXG4gKiAgIC0gQ3JlYXRlIGNvbnZlbmllbmNlIG1ldGhvZHMgdG8gcmVmZXJlbmNlIGFuZCBtdXRhdGUgQ3VydmVQb2ludHMgYXQgYSBnaXZlbiB4LXZhbHVlLlxyXG4gKiAgIC0gUHJvdmlkZSBvdGhlciBjb252ZW5pZW5jZSBtZXRob2RzIHRvIHNldCB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgY3VydmUgcG9pbnRzLlxyXG4gKlxyXG4gKiBGb3IgdGhlICdDYWxjdWx1cyBHcmFwaGVyJyBzaW0sIHRoZSBzYW1lIEN1cnZlcyBpbnN0YW5jZXMgYXJlIHVzZWQgdGhyb3VnaG91dCB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbXVsYXRpb24sIHNvIG5vXHJcbiAqIGRpc3Bvc2UgbWV0aG9kIGlzIG5lY2Vzc2FyeS4gQW4gb3ZlcnZpZXcgZm9yIHRoZSBjbGFzcyBoaWVyYXJjaHkgb2YgQ3VydmVzIGlzIGdpdmVuIGluXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jYWxjdWx1cy1ncmFwaGVyL2Jsb2IvbWFzdGVyL2RvYy9pbXBsZW1lbnRhdGlvbi1ub3Rlcy5tZFxyXG4gKlxyXG4gKiBAYXV0aG9yIEJyYW5kb24gTGlcclxuICogQGF1dGhvciBNYXJ0aW4gVmVpbGxldHRlXHJcbiAqL1xyXG5cclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9FbWl0dGVyLmpzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCBQaGV0aW9PYmplY3QsIHsgUGhldGlvT2JqZWN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy9QaGV0aW9PYmplY3QuanMnO1xyXG5pbXBvcnQgY2FsY3VsdXNHcmFwaGVyIGZyb20gJy4uLy4uL2NhbGN1bHVzR3JhcGhlci5qcyc7XHJcbmltcG9ydCBDYWxjdWx1c0dyYXBoZXJDb25zdGFudHMgZnJvbSAnLi4vQ2FsY3VsdXNHcmFwaGVyQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IENhbGN1bHVzR3JhcGhlclF1ZXJ5UGFyYW1ldGVycyBmcm9tICcuLi9DYWxjdWx1c0dyYXBoZXJRdWVyeVBhcmFtZXRlcnMuanMnO1xyXG5pbXBvcnQgQ3VydmVQb2ludCBmcm9tICcuL0N1cnZlUG9pbnQuanMnO1xyXG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1JhbmdlLmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IFByb3BlcnR5LCB7IFByb3BlcnR5T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgQXJyYXlJTyBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvQXJyYXlJTy5qcyc7XHJcblxyXG4vLyBDb25zdGFudHNcclxuY29uc3QgQ1VSVkVfWF9SQU5HRSA9IENhbGN1bHVzR3JhcGhlckNvbnN0YW50cy5DVVJWRV9YX1JBTkdFO1xyXG5jb25zdCBOVU1CRVJfT0ZfUE9JTlRTID0gQ2FsY3VsdXNHcmFwaGVyUXVlcnlQYXJhbWV0ZXJzLm51bWJlck9mUG9pbnRzO1xyXG5cclxuLy8gcGhldGlvRG9jdW1lbnRhdGlvbiBmb3IgcG9pbnRzUHJvcGVydHksIHdoaWNoIHZhcmllcyBkZXBlbmRpbmcgb24gcGhldGlvUmVhZE9ubHlcclxuY29uc3QgRE9DX1JFQURfT05MWV9UUlVFID1cclxuICAnVGhlIGRpc2NyZXRlIHBvaW50cyB0aGF0IGFyZSB1c2VkIHRvIGFwcHJveGltYXRlIHRoZSBjdXJ2ZS48YnI+PGJyPicgK1xyXG4gICdOb3RlIHRoYXQgdGhlIHZhbHVlIG9mIHBvaW50c1Byb3BlcnR5IGlzIHZlcnkgbGFyZ2UsIGFuZCBpdCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgaHVtYW4tcmVhZGFibGUuJyArXHJcbiAgJyBUbyBpbXByb3ZlIHBlcmZvcm1hbmNlIG9mIHRoZSBzaW11bGF0aW9uLCB0aGUgXCJDdXJyZW50IFZhbHVlXCIgc2hvd24gaW4gU3R1ZGlvIGlzIG5vdCBrZXB0IHVwIHRvIGRhdGUuJztcclxuY29uc3QgRE9DX1JFQURfT05MWV9GQUxTRSA9XHJcbiAgRE9DX1JFQURfT05MWV9UUlVFICtcclxuICAnIFByZXNzIHRoZSBcIkdldCBWYWx1ZVwiIGJ1dHRvbiBpbiBTdHVkaW8gaWYgeW91IG5lZWQgdG8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlLic7XHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0ge1xyXG5cclxuICAvLyBSYW5nZSBvZiB0aGUgeC1heGlzXHJcbiAgeFJhbmdlPzogUmFuZ2U7XHJcblxyXG4gIC8vIE51bWJlciBvZiBwb2ludHMgKGV2ZW5seS1zcGFjZWQgYWxvbmcgdGhlIHgtYXhpcykgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYXBwcm94aW1hdGUgdGhlIGN1cnZlXHJcbiAgbnVtYmVyT2ZQb2ludHM/OiBudW1iZXI7XHJcblxyXG4gIC8vIEZvciBQaEVULUlPLCBpcyBwb2ludHNQcm9wZXJ0eSByZWFkLW9ubHk/XHJcbiAgcG9pbnRzUHJvcGVydHlSZWFkT25seT86IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBDdXJ2ZU9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIFBoZXRpb09iamVjdE9wdGlvbnM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXJ2ZSBleHRlbmRzIFBoZXRpb09iamVjdCB7XHJcblxyXG4gIC8vIFRoZSBjb2xsZWN0aW9uIG9mIHBvaW50cyB0aGF0IGRlc2NyaWJlIHRoZSBjdXJ2ZS4gVGhpcyBpcyBhbiBhcnJheSBvZiBDdXJ2ZVBvaW50IGluc3RhbmNlcyB0aGF0IGFyZSB0eXBpY2FsbHlcclxuICAvLyBtdXRhdGVkIGluIHBsYWNlLCBzbyB0aGF0IHdlIGhhdmUgYWNjZXB0YWJsZSBwZXJmb3JtYW5jZS4gSWYgQ3VydmUgd2FzIGluc3RhbnRpYXRlZCB3aXRoIHBvaW50c1Byb3BlcnR5UmVhZE9ubHk6ZmFsc2UsXHJcbiAgLy8gdGhlbiBpdCBpcyBwb3NzaWJsZSB0byBzZXQgcG9pbnRzUHJvcGVydHkgdmlhIFBoRVQtaU8uXHJcbiAgcHVibGljIHJlYWRvbmx5IHBvaW50c1Byb3BlcnR5OiBQcm9wZXJ0eTxDdXJ2ZVBvaW50W10+O1xyXG5cclxuICAvLyBVc2luZyBhbiBvYnNlcnZhYmxlIFByb3BlcnR5IGZvciB0aGUgeS12YWx1ZSB3YXMgY29uc2lkZXJlZCwgYnV0IGl0IHdhcyBkZWVtZWQgdG8gYmVcclxuICAvLyBpbnZhc2l2ZSB0byB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhlIHNpbXVsYXRpb24gYXMgb2JzZXJ2ZXJzIGhhZCB0byBsaXN0ZW4gdG8gdGhlIHlQcm9wZXJ0eVxyXG4gIC8vIG9mIGFsbCBDdXJ2ZVBvaW50cy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jYWxjdWx1cy1ncmFwaGVyL2lzc3Vlcy8xOVxyXG4gIHB1YmxpYyByZWFkb25seSBjdXJ2ZUNoYW5nZWRFbWl0dGVyOiBFbWl0dGVyO1xyXG5cclxuICAvLyBSYW5nZSBvZiB0aGUgeC1heGlzXHJcbiAgcHVibGljIHJlYWRvbmx5IHhSYW5nZTogUmFuZ2U7XHJcblxyXG4gIC8vIE51bWJlciBvZiBwb2ludHMgKGV2ZW5seS1zcGFjZWQgYWxvbmcgdGhlIHgtYXhpcykgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYXBwcm94aW1hdGUgdGhlIGN1cnZlXHJcbiAgcHVibGljIHJlYWRvbmx5IG51bWJlck9mUG9pbnRzOiBudW1iZXI7XHJcblxyXG4gIC8vIERlbHRhIGJldHdlZW4geCBjb29yZGluYXRlIHZhbHVlc1xyXG4gIHByb3RlY3RlZCByZWFkb25seSBkZWx0YVg6IG51bWJlcjtcclxuXHJcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKCBwcm92aWRlZE9wdGlvbnM6IEN1cnZlT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPEN1cnZlT3B0aW9ucywgU2VsZk9wdGlvbnMsIFBoZXRpb09iamVjdE9wdGlvbnM+KCkoIHtcclxuXHJcbiAgICAgIC8vIFNlbGZPcHRpb25zXHJcbiAgICAgIHhSYW5nZTogQ1VSVkVfWF9SQU5HRSxcclxuICAgICAgbnVtYmVyT2ZQb2ludHM6IE5VTUJFUl9PRl9QT0lOVFMsXHJcblxyXG4gICAgICAvLyBQaGV0aW9PYmplY3RPcHRpb25zXHJcbiAgICAgIHBoZXRpb1N0YXRlOiBmYWxzZSxcclxuICAgICAgcG9pbnRzUHJvcGVydHlSZWFkT25seTogdHJ1ZVxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgc3VwZXIoIG9wdGlvbnMgKTtcclxuXHJcbiAgICB0aGlzLnhSYW5nZSA9IG9wdGlvbnMueFJhbmdlO1xyXG4gICAgdGhpcy5udW1iZXJPZlBvaW50cyA9IG9wdGlvbnMubnVtYmVyT2ZQb2ludHM7XHJcbiAgICB0aGlzLmRlbHRhWCA9IHRoaXMueFJhbmdlLmdldExlbmd0aCgpIC8gKCB0aGlzLm51bWJlck9mUG9pbnRzIC0gMSApO1xyXG5cclxuICAgIC8vIEluaXRpYWwgcG9pbnRzLCB3aXRoIGVxdWFsbHktc3BhY2VkIHggdmFsdWVzLCBhbmQgeT0wLlxyXG4gICAgY29uc3QgaW5pdGlhbFBvaW50czogQ3VydmVQb2ludFtdID0gW107XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLm51bWJlck9mUG9pbnRzOyBpKysgKSB7XHJcbiAgICAgIGNvbnN0IHhOb3JtYWxpemVkID0gaSAvICggdGhpcy5udW1iZXJPZlBvaW50cyAtIDEgKTsgLy8gaW4gdGhlIHJhbmdlIFswLDFdXHJcbiAgICAgIGNvbnN0IHggPSB0aGlzLnhSYW5nZS5leHBhbmROb3JtYWxpemVkVmFsdWUoIHhOb3JtYWxpemVkICk7XHJcbiAgICAgIGluaXRpYWxQb2ludHMucHVzaCggbmV3IEN1cnZlUG9pbnQoIHgsIDAgKSApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBvaW50UHJvcGVydHlPcHRpb25zOiBQcm9wZXJ0eU9wdGlvbnM8Q3VydmVQb2ludFtdPiA9IHtcclxuICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICdwb2ludHNQcm9wZXJ0eScgKSxcclxuICAgICAgcGhldGlvVmFsdWVUeXBlOiBBcnJheUlPKCBDdXJ2ZVBvaW50LkN1cnZlUG9pbnRJTyApLFxyXG4gICAgICBwaGV0aW9SZWFkT25seTogb3B0aW9ucy5wb2ludHNQcm9wZXJ0eVJlYWRPbmx5LFxyXG5cclxuICAgICAgLy8gRXhjbHVkaW5nIGRlcml2ZWQgY3VydmVzIGZyb20gc3RhdGUgaXMgYSBiaWcgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuXHJcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvY2FsY3VsdXMtZ3JhcGhlci9pc3N1ZXMvMzI3I2lzc3VlY29tbWVudC0xNDkwNDI4OTQ5XHJcbiAgICAgIHBoZXRpb1N0YXRlOiAhb3B0aW9ucy5wb2ludHNQcm9wZXJ0eVJlYWRPbmx5LFxyXG4gICAgICBwaGV0aW9GZWF0dXJlZDogdHJ1ZSxcclxuICAgICAgcGhldGlvRG9jdW1lbnRhdGlvbjogb3B0aW9ucy5wb2ludHNQcm9wZXJ0eVJlYWRPbmx5ID8gRE9DX1JFQURfT05MWV9UUlVFIDogRE9DX1JFQURfT05MWV9GQUxTRVxyXG4gICAgfTtcclxuICAgIGlmICggb3B0aW9ucy5wb2ludHNQcm9wZXJ0eVJlYWRPbmx5ICkge1xyXG5cclxuICAgICAgLy8gVGhlIGFycmF5IG9mIEN1cnZlUG9pbnRzIGlzIG5vdCBleHBlY3RlZCB0byBjaGFuZ2UgZm9yIGRlcml2ZWQgQ3VydmVzLCBiZWNhdXNlIEN1cnZlUG9pbnRzIGFyZSBtdXRhdGVkIGluIHBsYWNlLlxyXG4gICAgICAvLyBTbyB0aGVyZSBpcyBvbmx5IDEgdmFsaWQgdmFsdWUsIHRoZSBpbml0aWFsUG9pbnRzLlxyXG4gICAgICBwb2ludFByb3BlcnR5T3B0aW9ucy52YWxpZFZhbHVlcyA9IFsgaW5pdGlhbFBvaW50cyBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcblxyXG4gICAgICAvLyBUaGUgYXJyYXkgb2YgQ3VydmVQb2ludHMgbWF5IGNoYW5nZSB2aWEgUGhFVC1pTywgc28gdmVyaWZ5IHRoYXQgdGhlIG5ldyBhcnJheSBpcyB2YWxpZC5cclxuICAgICAgcG9pbnRQcm9wZXJ0eU9wdGlvbnMuaXNWYWxpZFZhbHVlID0gcG9pbnRzID0+IGlzVmFsaWRQb2ludHMoIGluaXRpYWxQb2ludHMsIHBvaW50cyApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucG9pbnRzUHJvcGVydHkgPSBuZXcgUHJvcGVydHkoIGluaXRpYWxQb2ludHMsIHBvaW50UHJvcGVydHlPcHRpb25zICk7XHJcblxyXG4gICAgLy8gRm9yIGRlYnVnZ2luZyBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvY2FsY3VsdXMtZ3JhcGhlci9pc3N1ZXMvMzI3LCBzbyB3ZSBjYW4gc2VlIHdoaWNoIGN1cnZlc1xyXG4gICAgLy8gaGF2ZSB0aGVpciBwb2ludHNQcm9wZXJ0eSBzZXQgd2hlbiBydW5uaW5nIHRoZSBTdGF0ZSBXcmFwcGVyLlxyXG4gICAgcGhldC5sb2cgJiYgdGhpcy5wb2ludHNQcm9wZXJ0eS5sYXp5TGluayggKCkgPT4gcGhldC5sb2coIGAke3RoaXMucG9pbnRzUHJvcGVydHkucGhldGlvSUR9IGNoYW5nZWRgICkgKTtcclxuXHJcbiAgICAvLyBFbWl0cyB3aGVuIHRoZSBDdXJ2ZSBoYXMgY2hhbmdlZCBpbiBhbnkgZm9ybS4gSW5zdGVhZCBvZiBsaXN0ZW5pbmcgdG8gYSB5UHJvcGVydHlcclxuICAgIC8vIG9mIGV2ZXJ5IEN1cnZlUG9pbnQsIHdoaWNoIHdhcyBkZWVtZWQgaW52YXNpdmUgdG8gdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBzaW0sIHdlXHJcbiAgICAvLyB1c2UgYW4gRW1pdHRlciB0aGF0IGVtaXRzIG9uY2UgYWZ0ZXIgYWxsIEN1cnZlUG9pbnRzIGFyZSBzZXQgdXBvbiBtYW5pcHVsYXRpb24uXHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NhbGN1bHVzLWdyYXBoZXIvaXNzdWVzLzE5XHJcbiAgICB0aGlzLmN1cnZlQ2hhbmdlZEVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2luY2UgcG9pbnRzUHJvcGVydHkgaXMgcHJpdmF0ZSwgdXNlIHRoaXMgbWV0aG9kIHRvIGFjY2VzcyB0aGUgcG9pbnRzLiBJdCBpcyBleHBlY3RlZCB0aGF0IGNhbGxlcnMgd2lsbCBtdXRhdGVcclxuICAgKiB0aGVzZSBwb2ludHM7IGRvIG5vdCBhZGQvcmVtb3ZlIHBvaW50cy4gSWYgeW91IG11dGF0ZSB0aGVzZSBwb2ludHMsIGJlIGNlcnRhaW4gdGhhdCB0aGV5IGNvbmZvcm0gdG8gZnVuY3Rpb25cclxuICAgKiBpc1ZhbGlkUG9pbnRzLCBhbmQgY2FsbCBjdXJ2ZUNoYW5nZWRFbWl0dGVyLmVtaXQoKSBhZnRlciB5b3UgaGF2ZSBmaW5pc2hlZCBtdXRhdGluZy5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0IHBvaW50cygpOiBDdXJ2ZVBvaW50W10ge1xyXG4gICAgcmV0dXJuIHRoaXMucG9pbnRzUHJvcGVydHkudmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBDdXJ2ZVBvaW50IHdob3NlIHgtdmFsdWUgaXMgY2xvc2VzdCB0byB0aGUgZ2l2ZW4geC12YWx1ZS5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0Q2xvc2VzdFBvaW50QXQoIHg6IG51bWJlciApOiBDdXJ2ZVBvaW50IHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIE51bWJlci5pc0Zpbml0ZSggeCApLCBgaW52YWxpZCB4OiAke3h9YCApO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnBvaW50c1sgdGhpcy5nZXRDbG9zZXN0SW5kZXhBdCggeCApIF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBpbmRleCBhc3NvY2lhdGVkIHdpdGggdGhpcyBwb2ludC5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZ2V0SW5kZXgoIHBvaW50OiBDdXJ2ZVBvaW50ICk6IG51bWJlciB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSB0aGlzLnhSYW5nZS5nZXROb3JtYWxpemVkVmFsdWUoIHBvaW50LnggKTtcclxuICAgIHJldHVybiBVdGlscy5yb3VuZFN5bW1ldHJpYyggbm9ybWFsaXplZFZhbHVlICogKCB0aGlzLm51bWJlck9mUG9pbnRzIC0gMSApICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgYXJyYXkgd2hvc2UgeC12YWx1ZSBpcyBjbG9zZXN0IHRvIHRoZSBnaXZlbiB4LXZhbHVlLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBnZXRDbG9zZXN0SW5kZXhBdCggeDogbnVtYmVyICk6IG51bWJlciB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBOdW1iZXIuaXNGaW5pdGUoIHggKSwgYGludmFsaWQgeDogJHt4fWAgKTtcclxuXHJcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSB0aGlzLnhSYW5nZS5nZXROb3JtYWxpemVkVmFsdWUoIHggKTtcclxuXHJcbiAgICBjb25zdCBpbmRleCA9IFV0aWxzLnJvdW5kU3ltbWV0cmljKCBub3JtYWxpemVkVmFsdWUgKiAoIHRoaXMubnVtYmVyT2ZQb2ludHMgLSAxICkgKTtcclxuXHJcbiAgICAvLyBDbGFtcCB0aGUgaW5kZXggdG8gYSBwb2ludCBpbnNpZGUgb3VyIHJhbmdlLlxyXG4gICAgcmV0dXJuIFV0aWxzLmNsYW1wKCBpbmRleCwgMCwgdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciBhIG5ldyBzZXQgb2YgcG9pbnRzIGlzIHZhbGlkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZFBvaW50cyggaW5pdGlhbFBvaW50czogQ3VydmVQb2ludFtdLCBwb2ludHM6IEN1cnZlUG9pbnRbXSApOiBib29sZWFuIHtcclxuXHJcbiAgLy8gVGhlIG51bWJlciBvZiBwb2ludHMgbXVzdCBiZSB0aGUgc2FtZS5cclxuICBsZXQgaXNWYWxpZCA9ICggaW5pdGlhbFBvaW50cy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGggKTtcclxuXHJcbiAgLy8gQWxsIHggY29vcmRpbmF0ZXMgbXVzdCBiZSB0aGUgc2FtZS5cclxuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBpbml0aWFsUG9pbnRzLmxlbmd0aCAmJiBpc1ZhbGlkOyBpKysgKSB7XHJcbiAgICBpc1ZhbGlkID0gKCBpbml0aWFsUG9pbnRzWyBpIF0ueCA9PT0gcG9pbnRzWyBpIF0ueCApO1xyXG4gIH1cclxuICByZXR1cm4gaXNWYWxpZDtcclxufVxyXG5cclxuY2FsY3VsdXNHcmFwaGVyLnJlZ2lzdGVyKCAnQ3VydmUnLCBDdXJ2ZSApO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFNLGdDQUFnQztBQUNwRCxPQUFPQyxLQUFLLE1BQU0sNkJBQTZCO0FBQy9DLE9BQU9DLFlBQVksTUFBK0IsdUNBQXVDO0FBQ3pGLE9BQU9DLGVBQWUsTUFBTSwwQkFBMEI7QUFDdEQsT0FBT0Msd0JBQXdCLE1BQU0sZ0NBQWdDO0FBQ3JFLE9BQU9DLDhCQUE4QixNQUFNLHNDQUFzQztBQUNqRixPQUFPQyxVQUFVLE1BQU0saUJBQWlCO0FBRXhDLE9BQU9DLFNBQVMsTUFBTSx1Q0FBdUM7QUFDN0QsT0FBT0MsUUFBUSxNQUEyQixpQ0FBaUM7QUFDM0UsT0FBT0MsT0FBTyxNQUFNLHdDQUF3Qzs7QUFFNUQ7QUFDQSxNQUFNQyxhQUFhLEdBQUdOLHdCQUF3QixDQUFDTSxhQUFhO0FBQzVELE1BQU1DLGdCQUFnQixHQUFHTiw4QkFBOEIsQ0FBQ08sY0FBYzs7QUFFdEU7QUFDQSxNQUFNQyxrQkFBa0IsR0FDdEIscUVBQXFFLEdBQ3JFLG1HQUFtRyxHQUNuRyx3R0FBd0c7QUFDMUcsTUFB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