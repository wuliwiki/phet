// Copyright 2020-2023, University of Colorado Boulder

/**
 * CurvePoint is a single mutable point of a Curve at a given x-value.
 * Each CurvePoint contains the following information:
 *   - The corresponding y-value and type of the Point.
 *   - All of its previously 'saved' states. When the user finishes manipulating the TransformedCurve, the state of
 *     CurvePoint in the TransformedCurve is saved.
 *
 * For the 'Calculus Grapher' simulation, CurvePoints are used inside of Curve (and its subclasses) to partition the curve
 * into a finite number of close points that map out the general shape and curvature. CurvePoints are created
 * at the start of the sim and are mutated when the Curve changes. CurvePoints are never disposed.
 *
 * @author Brandon Li
 * @author Martin Veillette
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import IOType from '../../../../tandem/js/types/IOType.js';
import NumberIO from '../../../../tandem/js/types/NumberIO.js';
import StringUnionIO from '../../../../tandem/js/types/StringUnionIO.js';
import calculusGrapher from '../../calculusGrapher.js';
import CalculusGrapherConstants from '../CalculusGrapherConstants.js';
const PointTypeValues = ['smooth', 'cusp', 'discontinuous'];

// For capturing the state of a CurvePoint, used to support Undo feature

// PhET-iO state object, for serialization

export default class CurvePoint {
  // The x coordinate is fixed.

  // Using an observable Property for the y-value was considered, but it was deemed to be
  // invasive to the performance of the simulation as observers had to listen to the yProperty
  // of all CurvePoints. See https://github.com/phetsims/calculus-grapher/issues/19
  // Metadata that tells us a bit more about this point
  // The initial y-coordinate, for resetting purposes.
  // An array of this CurvePoint's saved states, for the Undo feature. This is a stack (last in, first out)
  // that has a maximum length. When the maximum length is reached, the oldest saved state is discarded.
  // When save() is called, the current state of this CurvePoint is pushed onto the end of the stack.
  // When undo() is called, the last state that was pushed to the stack is popped off, and used to restore
  // the state of this CurvePoint. Note that this field is not serialized as part of PhET-iO state, see
  // https://github.com/phetsims/calculus-grapher/issues/65
  // Vector2 representation of this CurvePoint, to be used in bamboo data sets. This instance is allocated once
  // at instantiation, then reused to prevent garbage collection.
  constructor(x, y = 0, pointType = 'smooth') {
    assert && assert(Number.isFinite(x), `invalid x: ${x}`);
    this.x = x;
    this.y = y;
    this.pointType = pointType;
    this.initialState = {
      y: y,
      pointType: pointType
    };
    this.undoStack = [];
    this.vector = new Vector2(x, y);
  }

  /**
   * Returns a reference to the Vector2 representation of this CurvePoint. DO NOT MODIFY!
   */
  getVector() {
    this.vector.y = this.y; // defer update of y until we ask for it
    return this.vector;
  }

  /**
   * Returns a boolean that indicates if the y value of a point is finite.
   */
  get isFinite() {
    return Number.isFinite(this.y);
  }
  get isDiscontinuous() {
    return this.pointType === 'discontinuous';
  }
  get isCusp() {
    return this.pointType === 'cusp';
  }

  //----------------------------------------------------------------------------------------

  /**
   * Gets the most-recently saved y-value.
   */
  get lastSavedY() {
    return this.undoStack.length === 0 ? this.initialState.y : _.last(this.undoStack).y;
  }

  /**
   * Gets the most-recently saved point type.
   */
  get lastSavedType() {
    return this.undoStack.length === 0 ? this.initialState.pointType : _.last(this.undoStack).pointType;
  }

  /**
   * Saves the current state of the CurvePoint. This method is invoked when the user finishes manipulating the
   * TransformedCurve. When the undo button is pressed, the Points of the TransformedCurve will be set to their
   * most-recent saved state.
   */
  save() {
    // Save the current state of the CurvePoint.
    this.undoStack.push({
      y: this.y,
      pointType: this.pointType
    });

    // If we've reached the maximum length of our undo stack, remove the oldest state from the stack, which
    // is the first element in the array.
    while (this.undoStack.length > CalculusGrapherConstants.MAX_UNDO) {
      this.undoStack.shift();
    }
  }

  /**
   * Debugging string for the CurvePoint.
   */
  toString() {
    return `CurvePoint[ x: ${this.x}, y: ${this.y}, pointType: ${this.pointType} ]`;
  }
  dispose() {
    assert && assert(false, 'CurvePoint cannot be disposed (exists for the lifetime of the sim)');
  }

  /**
   * Sets the state of this CurvedPoint to its last saved state.
   * This method is invoked when the undo button is pressed, which successively undoes the last action.
   * If the undo stack is empty, this is a no-op.
   */
  undo() {
    if (this.undoStack.length !== 0) {
      const pointState = this.undoStack.pop();
      this.y = pointState.y;
      this.pointType = pointState.pointType;
    }
  }

  // Gets the slope between this point and targetPoint.
  getSlope(targetPoint) {
    assert && assert(targetPoint !== this, 'you need two different points');
    const slope = (this.y - targetPoint.y) / (this.x - targetPoint.x);
    assert && assert(Number.isFinite(slope), 'non finite slope');
    return slope;
  }
  reset() {
    this.y = this.initialState.y;
    this.pointType = this.initialState.pointType;
    this.undoStack.length = 0;
  }

  // undoStack is purposefully not serialized (see https://github.com/phetsims/calculus-grapher/issues/65)
  toStateObject() {
    return {
      x: this.x,
      y: this.y,
      pointType: this.pointType,
      initialY: this.initialState.y,
      initialPointType: this.initialState.pointType
    };
  }
  static fromStateObject(stateObject) {
    const curvePoint = new CurvePoint(stateObject.x, stateObject.initialY, stateObject.initialPointType);
    curvePoint.y = stateObject.y;
    curvePoint.pointType = stateObject.pointType;
    return curvePoint;
  }
  static CurvePointIO = new IOType('CurvePointIO', {
    valueType: CurvePoint,
    stateSchema: {
      x: NumberIO,
      y: NumberIO,
      pointType: StringUnionIO(PointTypeValues),
      initialY: NumberIO,
      initialPointType: StringUnionIO(PointTypeValues)
    },
    toStateObject: curvePoint => curvePoint.toStateObject(),
    fromStateObject: stateObject => CurvePoint.fromStateObject(stateObject),
    documentation: 'describe the point on a curve'
  });
}
calculusGrapher.register('CurvePoint', CurvePoint);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiSU9UeXBlIiwiTnVtYmVySU8iLCJTdHJpbmdVbmlvbklPIiwiY2FsY3VsdXNHcmFwaGVyIiwiQ2FsY3VsdXNHcmFwaGVyQ29uc3RhbnRzIiwiUG9pbnRUeXBlVmFsdWVzIiwiQ3VydmVQb2ludCIsImNvbnN0cnVjdG9yIiwieCIsInkiLCJwb2ludFR5cGUiLCJhc3NlcnQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImluaXRpYWxTdGF0ZSIsInVuZG9TdGFjayIsInZlY3RvciIsImdldFZlY3RvciIsImlzRGlzY29udGludW91cyIsImlzQ3VzcCIsImxhc3RTYXZlZFkiLCJsZW5ndGgiLCJfIiwibGFzdCIsImxhc3RTYXZlZFR5cGUiLCJzYXZlIiwicHVzaCIsIk1BWF9VTkRPIiwic2hpZnQiLCJ0b1N0cmluZyIsImRpc3Bvc2UiLCJ1bmRvIiwicG9pbnRTdGF0ZSIsInBvcCIsImdldFNsb3BlIiwidGFyZ2V0UG9pbnQiLCJzbG9wZSIsInJlc2V0IiwidG9TdGF0ZU9iamVjdCIsImluaXRpYWxZIiwiaW5pdGlhbFBvaW50VHlwZSIsImZyb21TdGF0ZU9iamVjdCIsInN0YXRlT2JqZWN0IiwiY3VydmVQb2ludCIsIkN1cnZlUG9pbnRJTyIsInZhbHVlVHlwZSIsInN0YXRlU2NoZW1hIiwiZG9jdW1lbnRhdGlvbiIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQ3VydmVQb2ludC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMC0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBDdXJ2ZVBvaW50IGlzIGEgc2luZ2xlIG11dGFibGUgcG9pbnQgb2YgYSBDdXJ2ZSBhdCBhIGdpdmVuIHgtdmFsdWUuXHJcbiAqIEVhY2ggQ3VydmVQb2ludCBjb250YWlucyB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uOlxyXG4gKiAgIC0gVGhlIGNvcnJlc3BvbmRpbmcgeS12YWx1ZSBhbmQgdHlwZSBvZiB0aGUgUG9pbnQuXHJcbiAqICAgLSBBbGwgb2YgaXRzIHByZXZpb3VzbHkgJ3NhdmVkJyBzdGF0ZXMuIFdoZW4gdGhlIHVzZXIgZmluaXNoZXMgbWFuaXB1bGF0aW5nIHRoZSBUcmFuc2Zvcm1lZEN1cnZlLCB0aGUgc3RhdGUgb2ZcclxuICogICAgIEN1cnZlUG9pbnQgaW4gdGhlIFRyYW5zZm9ybWVkQ3VydmUgaXMgc2F2ZWQuXHJcbiAqXHJcbiAqIEZvciB0aGUgJ0NhbGN1bHVzIEdyYXBoZXInIHNpbXVsYXRpb24sIEN1cnZlUG9pbnRzIGFyZSB1c2VkIGluc2lkZSBvZiBDdXJ2ZSAoYW5kIGl0cyBzdWJjbGFzc2VzKSB0byBwYXJ0aXRpb24gdGhlIGN1cnZlXHJcbiAqIGludG8gYSBmaW5pdGUgbnVtYmVyIG9mIGNsb3NlIHBvaW50cyB0aGF0IG1hcCBvdXQgdGhlIGdlbmVyYWwgc2hhcGUgYW5kIGN1cnZhdHVyZS4gQ3VydmVQb2ludHMgYXJlIGNyZWF0ZWRcclxuICogYXQgdGhlIHN0YXJ0IG9mIHRoZSBzaW0gYW5kIGFyZSBtdXRhdGVkIHdoZW4gdGhlIEN1cnZlIGNoYW5nZXMuIEN1cnZlUG9pbnRzIGFyZSBuZXZlciBkaXNwb3NlZC5cclxuICpcclxuICogQGF1dGhvciBCcmFuZG9uIExpXHJcbiAqIEBhdXRob3IgTWFydGluIFZlaWxsZXR0ZVxyXG4gKiBAYXV0aG9yIENocmlzIE1hbGxleSAoUGl4ZWxab29tLCBJbmMuKVxyXG4gKi9cclxuXHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IElPVHlwZSBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvSU9UeXBlLmpzJztcclxuaW1wb3J0IE51bWJlcklPIGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy90eXBlcy9OdW1iZXJJTy5qcyc7XHJcbmltcG9ydCBTdHJpbmdVbmlvbklPIGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy90eXBlcy9TdHJpbmdVbmlvbklPLmpzJztcclxuaW1wb3J0IGNhbGN1bHVzR3JhcGhlciBmcm9tICcuLi8uLi9jYWxjdWx1c0dyYXBoZXIuanMnO1xyXG5pbXBvcnQgQ2FsY3VsdXNHcmFwaGVyQ29uc3RhbnRzIGZyb20gJy4uL0NhbGN1bHVzR3JhcGhlckNvbnN0YW50cy5qcyc7XHJcblxyXG5jb25zdCBQb2ludFR5cGVWYWx1ZXMgPSBbICdzbW9vdGgnLCAnY3VzcCcsICdkaXNjb250aW51b3VzJyBdIGFzIGNvbnN0O1xyXG5leHBvcnQgdHlwZSBQb2ludFR5cGUgPSAoIHR5cGVvZiBQb2ludFR5cGVWYWx1ZXMgKVtudW1iZXJdO1xyXG5cclxuLy8gRm9yIGNhcHR1cmluZyB0aGUgc3RhdGUgb2YgYSBDdXJ2ZVBvaW50LCB1c2VkIHRvIHN1cHBvcnQgVW5kbyBmZWF0dXJlXHJcbnR5cGUgQ3VydmVQb2ludFN0YXRlID0ge1xyXG4gIHk6IG51bWJlcjtcclxuICBwb2ludFR5cGU6IFBvaW50VHlwZTtcclxufTtcclxuXHJcbi8vIFBoRVQtaU8gc3RhdGUgb2JqZWN0LCBmb3Igc2VyaWFsaXphdGlvblxyXG5leHBvcnQgdHlwZSBDdXJ2ZVBvaW50U3RhdGVPYmplY3QgPSB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuICBwb2ludFR5cGU6IFBvaW50VHlwZTtcclxuICBpbml0aWFsWTogbnVtYmVyO1xyXG4gIGluaXRpYWxQb2ludFR5cGU6IFBvaW50VHlwZTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1cnZlUG9pbnQge1xyXG5cclxuICAvLyBUaGUgeCBjb29yZGluYXRlIGlzIGZpeGVkLlxyXG4gIHB1YmxpYyByZWFkb25seSB4OiBudW1iZXI7XHJcblxyXG4gIC8vIFVzaW5nIGFuIG9ic2VydmFibGUgUHJvcGVydHkgZm9yIHRoZSB5LXZhbHVlIHdhcyBjb25zaWRlcmVkLCBidXQgaXQgd2FzIGRlZW1lZCB0byBiZVxyXG4gIC8vIGludmFzaXZlIHRvIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgc2ltdWxhdGlvbiBhcyBvYnNlcnZlcnMgaGFkIHRvIGxpc3RlbiB0byB0aGUgeVByb3BlcnR5XHJcbiAgLy8gb2YgYWxsIEN1cnZlUG9pbnRzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NhbGN1bHVzLWdyYXBoZXIvaXNzdWVzLzE5XHJcbiAgcHVibGljIHk6IG51bWJlcjtcclxuXHJcbiAgLy8gTWV0YWRhdGEgdGhhdCB0ZWxscyB1cyBhIGJpdCBtb3JlIGFib3V0IHRoaXMgcG9pbnRcclxuICBwdWJsaWMgcG9pbnRUeXBlOiBQb2ludFR5cGU7XHJcblxyXG4gIC8vIFRoZSBpbml0aWFsIHktY29vcmRpbmF0ZSwgZm9yIHJlc2V0dGluZyBwdXJwb3Nlcy5cclxuICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxTdGF0ZTogQ3VydmVQb2ludFN0YXRlO1xyXG5cclxuICAvLyBBbiBhcnJheSBvZiB0aGlzIEN1cnZlUG9pbnQncyBzYXZlZCBzdGF0ZXMsIGZvciB0aGUgVW5kbyBmZWF0dXJlLiBUaGlzIGlzIGEgc3RhY2sgKGxhc3QgaW4sIGZpcnN0IG91dClcclxuICAvLyB0aGF0IGhhcyBhIG1heGltdW0gbGVuZ3RoLiBXaGVuIHRoZSBtYXhpbXVtIGxlbmd0aCBpcyByZWFjaGVkLCB0aGUgb2xkZXN0IHNhdmVkIHN0YXRlIGlzIGRpc2NhcmRlZC5cclxuICAvLyBXaGVuIHNhdmUoKSBpcyBjYWxsZWQsIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgQ3VydmVQb2ludCBpcyBwdXNoZWQgb250byB0aGUgZW5kIG9mIHRoZSBzdGFjay5cclxuICAvLyBXaGVuIHVuZG8oKSBpcyBjYWxsZWQsIHRoZSBsYXN0IHN0YXRlIHRoYXQgd2FzIHB1c2hlZCB0byB0aGUgc3RhY2sgaXMgcG9wcGVkIG9mZiwgYW5kIHVzZWQgdG8gcmVzdG9yZVxyXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGlzIEN1cnZlUG9pbnQuIE5vdGUgdGhhdCB0aGlzIGZpZWxkIGlzIG5vdCBzZXJpYWxpemVkIGFzIHBhcnQgb2YgUGhFVC1pTyBzdGF0ZSwgc2VlXHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NhbGN1bHVzLWdyYXBoZXIvaXNzdWVzLzY1XHJcbiAgcHJpdmF0ZSByZWFkb25seSB1bmRvU3RhY2s6IEN1cnZlUG9pbnRTdGF0ZVtdO1xyXG5cclxuICAvLyBWZWN0b3IyIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgQ3VydmVQb2ludCwgdG8gYmUgdXNlZCBpbiBiYW1ib28gZGF0YSBzZXRzLiBUaGlzIGluc3RhbmNlIGlzIGFsbG9jYXRlZCBvbmNlXHJcbiAgLy8gYXQgaW5zdGFudGlhdGlvbiwgdGhlbiByZXVzZWQgdG8gcHJldmVudCBnYXJiYWdlIGNvbGxlY3Rpb24uXHJcbiAgcHJpdmF0ZSByZWFkb25seSB2ZWN0b3I6IFZlY3RvcjI7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggeDogbnVtYmVyLCB5ID0gMCwgcG9pbnRUeXBlOiBQb2ludFR5cGUgPSAnc21vb3RoJyApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIE51bWJlci5pc0Zpbml0ZSggeCApLCBgaW52YWxpZCB4OiAke3h9YCApO1xyXG5cclxuICAgIHRoaXMueCA9IHg7XHJcbiAgICB0aGlzLnkgPSB5O1xyXG4gICAgdGhpcy5wb2ludFR5cGUgPSBwb2ludFR5cGU7XHJcblxyXG4gICAgdGhpcy5pbml0aWFsU3RhdGUgPSB7XHJcbiAgICAgIHk6IHksXHJcbiAgICAgIHBvaW50VHlwZTogcG9pbnRUeXBlXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMudW5kb1N0YWNrID0gW107XHJcbiAgICB0aGlzLnZlY3RvciA9IG5ldyBWZWN0b3IyKCB4LCB5ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBWZWN0b3IyIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgQ3VydmVQb2ludC4gRE8gTk9UIE1PRElGWSFcclxuICAgKi9cclxuICBwdWJsaWMgZ2V0VmVjdG9yKCk6IFZlY3RvcjIge1xyXG4gICAgdGhpcy52ZWN0b3IueSA9IHRoaXMueTsgLy8gZGVmZXIgdXBkYXRlIG9mIHkgdW50aWwgd2UgYXNrIGZvciBpdFxyXG4gICAgcmV0dXJuIHRoaXMudmVjdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIHkgdmFsdWUgb2YgYSBwb2ludCBpcyBmaW5pdGUuXHJcbiAgICovXHJcbiAgcHVibGljIGdldCBpc0Zpbml0ZSgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoIHRoaXMueSApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCBpc0Rpc2NvbnRpbnVvdXMoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5wb2ludFR5cGUgPT09ICdkaXNjb250aW51b3VzJztcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgaXNDdXNwKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMucG9pbnRUeXBlID09PSAnY3VzcCc7XHJcbiAgfVxyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbW9zdC1yZWNlbnRseSBzYXZlZCB5LXZhbHVlLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXQgbGFzdFNhdmVkWSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuICggdGhpcy51bmRvU3RhY2subGVuZ3RoID09PSAwICkgPyB0aGlzLmluaXRpYWxTdGF0ZS55IDogXy5sYXN0KCB0aGlzLnVuZG9TdGFjayApIS55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbW9zdC1yZWNlbnRseSBzYXZlZCBwb2ludCB0eXBlLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXQgbGFzdFNhdmVkVHlwZSgpOiBQb2ludFR5cGUge1xyXG4gICAgcmV0dXJuICggdGhpcy51bmRvU3RhY2subGVuZ3RoID09PSAwICkgPyB0aGlzLmluaXRpYWxTdGF0ZS5wb2ludFR5cGUgOiBfLmxhc3QoIHRoaXMudW5kb1N0YWNrICkhLnBvaW50VHlwZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNhdmVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBDdXJ2ZVBvaW50LiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgZmluaXNoZXMgbWFuaXB1bGF0aW5nIHRoZVxyXG4gICAqIFRyYW5zZm9ybWVkQ3VydmUuIFdoZW4gdGhlIHVuZG8gYnV0dG9uIGlzIHByZXNzZWQsIHRoZSBQb2ludHMgb2YgdGhlIFRyYW5zZm9ybWVkQ3VydmUgd2lsbCBiZSBzZXQgdG8gdGhlaXJcclxuICAgKiBtb3N0LXJlY2VudCBzYXZlZCBzdGF0ZS5cclxuICAgKi9cclxuICBwdWJsaWMgc2F2ZSgpOiB2b2lkIHtcclxuXHJcbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBDdXJ2ZVBvaW50LlxyXG4gICAgdGhpcy51bmRvU3RhY2sucHVzaCgge1xyXG4gICAgICB5OiB0aGlzLnksXHJcbiAgICAgIHBvaW50VHlwZTogdGhpcy5wb2ludFR5cGVcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBvdXIgdW5kbyBzdGFjaywgcmVtb3ZlIHRoZSBvbGRlc3Qgc3RhdGUgZnJvbSB0aGUgc3RhY2ssIHdoaWNoXHJcbiAgICAvLyBpcyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkuXHJcbiAgICB3aGlsZSAoIHRoaXMudW5kb1N0YWNrLmxlbmd0aCA+IENhbGN1bHVzR3JhcGhlckNvbnN0YW50cy5NQVhfVU5ETyApIHtcclxuICAgICAgdGhpcy51bmRvU3RhY2suc2hpZnQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlYnVnZ2luZyBzdHJpbmcgZm9yIHRoZSBDdXJ2ZVBvaW50LlxyXG4gICAqL1xyXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGBDdXJ2ZVBvaW50WyB4OiAke3RoaXMueH0sIHk6ICR7dGhpcy55fSwgcG9pbnRUeXBlOiAke3RoaXMucG9pbnRUeXBlfSBdYDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsICdDdXJ2ZVBvaW50IGNhbm5vdCBiZSBkaXNwb3NlZCAoZXhpc3RzIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbSknICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGlzIEN1cnZlZFBvaW50IHRvIGl0cyBsYXN0IHNhdmVkIHN0YXRlLlxyXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdW5kbyBidXR0b24gaXMgcHJlc3NlZCwgd2hpY2ggc3VjY2Vzc2l2ZWx5IHVuZG9lcyB0aGUgbGFzdCBhY3Rpb24uXHJcbiAgICogSWYgdGhlIHVuZG8gc3RhY2sgaXMgZW1wdHksIHRoaXMgaXMgYSBuby1vcC5cclxuICAgKi9cclxuICBwdWJsaWMgdW5kbygpOiB2b2lkIHtcclxuICAgIGlmICggdGhpcy51bmRvU3RhY2subGVuZ3RoICE9PSAwICkge1xyXG4gICAgICBjb25zdCBwb2ludFN0YXRlID0gdGhpcy51bmRvU3RhY2sucG9wKCkhO1xyXG4gICAgICB0aGlzLnkgPSBwb2ludFN0YXRlLnk7XHJcbiAgICAgIHRoaXMucG9pbnRUeXBlID0gcG9pbnRTdGF0ZS5wb2ludFR5cGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBHZXRzIHRoZSBzbG9wZSBiZXR3ZWVuIHRoaXMgcG9pbnQgYW5kIHRhcmdldFBvaW50LlxyXG4gIHB1YmxpYyBnZXRTbG9wZSggdGFyZ2V0UG9pbnQ6IEN1cnZlUG9pbnQgKTogbnVtYmVyIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHRhcmdldFBvaW50ICE9PSB0aGlzLCAneW91IG5lZWQgdHdvIGRpZmZlcmVudCBwb2ludHMnICk7XHJcblxyXG4gICAgY29uc3Qgc2xvcGUgPSAoIHRoaXMueSAtIHRhcmdldFBvaW50LnkgKSAvICggdGhpcy54IC0gdGFyZ2V0UG9pbnQueCApO1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIE51bWJlci5pc0Zpbml0ZSggc2xvcGUgKSwgJ25vbiBmaW5pdGUgc2xvcGUnICk7XHJcbiAgICByZXR1cm4gc2xvcGU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcbiAgICB0aGlzLnkgPSB0aGlzLmluaXRpYWxTdGF0ZS55O1xyXG4gICAgdGhpcy5wb2ludFR5cGUgPSB0aGlzLmluaXRpYWxTdGF0ZS5wb2ludFR5cGU7XHJcbiAgICB0aGlzLnVuZG9TdGFjay5sZW5ndGggPSAwO1xyXG4gIH1cclxuXHJcbiAgLy8gdW5kb1N0YWNrIGlzIHB1cnBvc2VmdWxseSBub3Qgc2VyaWFsaXplZCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jYWxjdWx1cy1ncmFwaGVyL2lzc3Vlcy82NSlcclxuICBwdWJsaWMgdG9TdGF0ZU9iamVjdCgpOiBDdXJ2ZVBvaW50U3RhdGVPYmplY3Qge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogdGhpcy54LFxyXG4gICAgICB5OiB0aGlzLnksXHJcbiAgICAgIHBvaW50VHlwZTogdGhpcy5wb2ludFR5cGUsXHJcbiAgICAgIGluaXRpYWxZOiB0aGlzLmluaXRpYWxTdGF0ZS55LFxyXG4gICAgICBpbml0aWFsUG9pbnRUeXBlOiB0aGlzLmluaXRpYWxTdGF0ZS5wb2ludFR5cGVcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhdGljIGZyb21TdGF0ZU9iamVjdCggc3RhdGVPYmplY3Q6IEN1cnZlUG9pbnRTdGF0ZU9iamVjdCApOiBDdXJ2ZVBvaW50IHtcclxuICAgIGNvbnN0IGN1cnZlUG9pbnQgPSBuZXcgQ3VydmVQb2ludChcclxuICAgICAgc3RhdGVPYmplY3QueCxcclxuICAgICAgc3RhdGVPYmplY3QuaW5pdGlhbFksXHJcbiAgICAgIHN0YXRlT2JqZWN0LmluaXRpYWxQb2ludFR5cGVcclxuICAgICk7XHJcbiAgICBjdXJ2ZVBvaW50LnkgPSBzdGF0ZU9iamVjdC55O1xyXG4gICAgY3VydmVQb2ludC5wb2ludFR5cGUgPSBzdGF0ZU9iamVjdC5wb2ludFR5cGU7XHJcblxyXG4gICAgcmV0dXJuIGN1cnZlUG9pbnQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEN1cnZlUG9pbnRJTyA9IG5ldyBJT1R5cGU8Q3VydmVQb2ludCwgQ3VydmVQb2ludFN0YXRlT2JqZWN0PiggJ0N1cnZlUG9pbnRJTycsIHtcclxuICAgIHZhbHVlVHlwZTogQ3VydmVQb2ludCxcclxuICAgIHN0YXRlU2NoZW1hOiB7XHJcbiAgICAgIHg6IE51bWJlcklPLFxyXG4gICAgICB5OiBOdW1iZXJJTyxcclxuICAgICAgcG9pbnRUeXBlOiBTdHJpbmdVbmlvbklPKCBQb2ludFR5cGVWYWx1ZXMgKSxcclxuICAgICAgaW5pdGlhbFk6IE51bWJlcklPLFxyXG4gICAgICBpbml0aWFsUG9pbnRUeXBlOiBTdHJpbmdVbmlvbklPKCBQb2ludFR5cGVWYWx1ZXMgKVxyXG4gICAgfSxcclxuICAgIHRvU3RhdGVPYmplY3Q6ICggY3VydmVQb2ludDogQ3VydmVQb2ludCApID0+IGN1cnZlUG9pbnQudG9TdGF0ZU9iamVjdCgpLFxyXG4gICAgZnJvbVN0YXRlT2JqZWN0OiAoIHN0YXRlT2JqZWN0OiBDdXJ2ZVBvaW50U3RhdGVPYmplY3QgKSA9PiBDdXJ2ZVBvaW50LmZyb21TdGF0ZU9iamVjdCggc3RhdGVPYmplY3QgKSxcclxuICAgIGRvY3VtZW50YXRpb246ICdkZXNjcmliZSB0aGUgcG9pbnQgb24gYSBjdXJ2ZSdcclxuICB9ICk7XHJcbn1cclxuXHJcbmNhbGN1bHVzR3JhcGhlci5yZWdpc3RlciggJ0N1cnZlUG9pbnQnLCBDdXJ2ZVBvaW50ICk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsTUFBTSxNQUFNLHVDQUF1QztBQUMxRCxPQUFPQyxRQUFRLE1BQU0seUNBQXlDO0FBQzlELE9BQU9DLGFBQWEsTUFBTSw4Q0FBOEM7QUFDeEUsT0FBT0MsZUFBZSxNQUFNLDBCQUEwQjtBQUN0RCxPQUFPQyx3QkFBd0IsTUFBTSxnQ0FBZ0M7QUFFckUsTUFBTUMsZUFBZSxHQUFHLENBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxlQUFlLENBQVc7O0FBR3RFOztBQU1BOztBQVNBLGVBQWUsTUFBTUMsVUFBVSxDQUFDO0VBRTlCOztFQUdBO0VBQ0E7RUFDQTtFQUdBO0VBR0E7RUFHQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFHQTtFQUNBO0VBR09DLFdBQVdBLENBQUVDLENBQVMsRUFBRUMsQ0FBQyxHQUFHLENBQUMsRUFBRUMsU0FBb0IsR0FBRyxRQUFRLEVBQUc7SUFDdEVDLE1BQU0sSUFBSUEsTUFBTSxDQUFFQyxNQUFNLENBQUNDLFFBQVEsQ0FBRUwsQ0FBRSxDQUFDLEVBQUcsY0FBYUEsQ0FBRSxFQUFFLENBQUM7SUFFM0QsSUFBSSxDQUFDQSxDQUFDLEdBQUdBLENBQUM7SUFDVixJQUFJLENBQUNDLENBQUMsR0FBR0EsQ0FBQztJQUNWLElBQUksQ0FBQ0MsU0FBUyxHQUFHQSxTQUFTO0lBRTFCLElBQUksQ0FBQ0ksWUFBWSxHQUFHO01BQ2xCTCxDQUFDLEVBQUVBLENBQUM7TUFDSkMsU0FBUyxFQUFFQTtJQUNiLENBQUM7SUFFRCxJQUFJLENBQUNLLFNBQVMsR0FBRyxFQUFFO0lBQ25C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