// Copyright 2020-2021, University of Colorado Boulder

/**
 * This node draws a static normal mode graph with a fixed amplitude to represent the normal mode.
 * It is based on States of Matter's InteractionPotentialCanvasNode.
 *
 * @author Franco Barpp Gomes (UTFPR)
 */

import Bounds2 from '../../../../dot/js/Bounds2.js';
import Dimension2 from '../../../../dot/js/Dimension2.js';
import merge from '../../../../phet-core/js/merge.js';
import { CanvasNode } from '../../../../scenery/js/imports.js';
import NormalModesColors from '../../common/NormalModesColors.js';
import NormalModesConstants from '../../common/NormalModesConstants.js';
import normalModes from '../../normalModes.js';
class StaticModeGraphCanvasNode extends CanvasNode {
  /**
   * @param {number} normalModeNumber
   * @param {Property.<number>} modeFrequencyProperty
   * @param {Object} [options]
   */
  constructor(normalModeNumber, modeFrequencyProperty, options) {
    options = merge({
      graphSize: new Dimension2(40, 25),
      graphStartX: 0,
      curveResolution: 100
    }, NormalModesColors.MODE_GRAPH_COLORS, options);
    options.canvasBounds = new Bounds2(0, 0, options.graphSize.width, options.graphSize.height);
    super(options);

    // @private {number} - 0 to 9, determines the normal mode represented
    this.normalModeNumber = normalModeNumber;

    // @private {number} - how many points the curve has
    this.curveResolution = options.curveResolution;

    // @private {Dimension2}
    this.graphSize = options.graphSize;

    // @private {Object} - start point of the graph
    this.graphStart = {
      x: options.graphStartX,
      y: this.graphSize.height / 2
    }; // @private

    // @private {number} - x distance between consecutive graph points
    this.xStep = this.graphSize.width / this.curveResolution;

    // @private {Array.<number>}
    this.curveYPositions = new Array(this.curveResolution);

    // @private {String} - curve stroke canvas color
    this.strokeColor = options.strokeColor;

    // @private {String} - reference line (y = 0) stroke canvas color
    this.referenceLineStrokeColor = options.referenceLineStrokeColor;

    // @private {Property.<number>}
    this.modeFrequencyProperty = modeFrequencyProperty;
  }

  /**
   * Paints the static normal mode graph.
   * @param {CanvasRenderingContext2D} context
   * @public
   */
  paintCanvas(context) {
    // draw reference line
    context.beginPath();
    context.strokeStyle = this.referenceLineStrokeColor;
    context.lineWidth = 2;
    context.moveTo(this.graphStart.x, this.graphStart.y);
    context.lineTo(this.graphStart.x + this.graphSize.width, this.graphStart.y);
    context.stroke();

    // plot
    context.beginPath();
    context.moveTo(this.graphStart.x, this.graphStart.y);
    for (let i = 1; i < this.curveYPositions.length; i++) {
      context.lineTo(this.graphStart.x + i * this.xStep, this.curveYPositions[i] + this.graphStart.y);
    }
    context.lineTo(this.graphStart.x + this.graphSize.width, this.graphStart.y);
    context.strokeStyle = this.strokeColor;
    context.lineWidth = 2;
    context.stroke();
  }

  /**
   * Updates the curve.
   * Note that this happens only once. Because it is static, there's no need to keep updating it.
   * @public
   */
  update() {
    const n = this.normalModeNumber;
    const amplitude = 0.075;
    const phase = 0;
    const frequency = this.modeFrequencyProperty.get();
    const time = 0;

    // put a negative sign in front of it because of y coordinate stuff
    const heightFactor = -(2 * this.graphSize.height / 3);

    // this result is the same for all curve positions, so it's more efficient to only run it once
    const cos = Math.cos(frequency * time - phase);
    for (let i = 0; i < this.curveYPositions.length; i++) {
      const x = i / this.curveResolution;
      const sin = Math.sin(x * (n + 1) * Math.PI);
      this.curveYPositions[i] = heightFactor * (amplitude * sin * cos) / NormalModesConstants.MAX_AMPLITUDE;
    }
  }
}
normalModes.register('StaticModeGraphCanvasNode', StaticModeGraphCanvasNode);
export default StaticModeGraphCanvasNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiRGltZW5zaW9uMiIsIm1lcmdlIiwiQ2FudmFzTm9kZSIsIk5vcm1hbE1vZGVzQ29sb3JzIiwiTm9ybWFsTW9kZXNDb25zdGFudHMiLCJub3JtYWxNb2RlcyIsIlN0YXRpY01vZGVHcmFwaENhbnZhc05vZGUiLCJjb25zdHJ1Y3RvciIsIm5vcm1hbE1vZGVOdW1iZXIiLCJtb2RlRnJlcXVlbmN5UHJvcGVydHkiLCJvcHRpb25zIiwiZ3JhcGhTaXplIiwiZ3JhcGhTdGFydFgiLCJjdXJ2ZVJlc29sdXRpb24iLCJNT0RFX0dSQVBIX0NPTE9SUyIsImNhbnZhc0JvdW5kcyIsIndpZHRoIiwiaGVpZ2h0IiwiZ3JhcGhTdGFydCIsIngiLCJ5IiwieFN0ZXAiLCJjdXJ2ZVlQb3NpdGlvbnMiLCJBcnJheSIsInN0cm9rZUNvbG9yIiwicmVmZXJlbmNlTGluZVN0cm9rZUNvbG9yIiwicGFpbnRDYW52YXMiLCJjb250ZXh0IiwiYmVnaW5QYXRoIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJpIiwibGVuZ3RoIiwidXBkYXRlIiwibiIsImFtcGxpdHVkZSIsInBoYXNlIiwiZnJlcXVlbmN5IiwiZ2V0IiwidGltZSIsImhlaWdodEZhY3RvciIsImNvcyIsIk1hdGgiLCJzaW4iLCJQSSIsIk1BWF9BTVBMSVRVREUiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlN0YXRpY01vZGVHcmFwaENhbnZhc05vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAtMjAyMSwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVGhpcyBub2RlIGRyYXdzIGEgc3RhdGljIG5vcm1hbCBtb2RlIGdyYXBoIHdpdGggYSBmaXhlZCBhbXBsaXR1ZGUgdG8gcmVwcmVzZW50IHRoZSBub3JtYWwgbW9kZS5cclxuICogSXQgaXMgYmFzZWQgb24gU3RhdGVzIG9mIE1hdHRlcidzIEludGVyYWN0aW9uUG90ZW50aWFsQ2FudmFzTm9kZS5cclxuICpcclxuICogQGF1dGhvciBGcmFuY28gQmFycHAgR29tZXMgKFVURlBSKVxyXG4gKi9cclxuXHJcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcclxuaW1wb3J0IERpbWVuc2lvbjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL0RpbWVuc2lvbjIuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lcmdlLmpzJztcclxuaW1wb3J0IHsgQ2FudmFzTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBOb3JtYWxNb2Rlc0NvbG9ycyBmcm9tICcuLi8uLi9jb21tb24vTm9ybWFsTW9kZXNDb2xvcnMuanMnO1xyXG5pbXBvcnQgTm9ybWFsTW9kZXNDb25zdGFudHMgZnJvbSAnLi4vLi4vY29tbW9uL05vcm1hbE1vZGVzQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IG5vcm1hbE1vZGVzIGZyb20gJy4uLy4uL25vcm1hbE1vZGVzLmpzJztcclxuXHJcbmNsYXNzIFN0YXRpY01vZGVHcmFwaENhbnZhc05vZGUgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbE1vZGVOdW1iZXJcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5LjxudW1iZXI+fSBtb2RlRnJlcXVlbmN5UHJvcGVydHlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIG5vcm1hbE1vZGVOdW1iZXIsIG1vZGVGcmVxdWVuY3lQcm9wZXJ0eSwgb3B0aW9ucyApIHtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuICAgICAgZ3JhcGhTaXplOiBuZXcgRGltZW5zaW9uMiggNDAsIDI1ICksXHJcbiAgICAgIGdyYXBoU3RhcnRYOiAwLFxyXG4gICAgICBjdXJ2ZVJlc29sdXRpb246IDEwMFxyXG4gICAgfSwgTm9ybWFsTW9kZXNDb2xvcnMuTU9ERV9HUkFQSF9DT0xPUlMsIG9wdGlvbnMgKTtcclxuXHJcbiAgICBvcHRpb25zLmNhbnZhc0JvdW5kcyA9IG5ldyBCb3VuZHMyKCAwLCAwLCBvcHRpb25zLmdyYXBoU2l6ZS53aWR0aCwgb3B0aW9ucy5ncmFwaFNpemUuaGVpZ2h0ICk7XHJcbiAgICBzdXBlciggb3B0aW9ucyApO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtudW1iZXJ9IC0gMCB0byA5LCBkZXRlcm1pbmVzIHRoZSBub3JtYWwgbW9kZSByZXByZXNlbnRlZFxyXG4gICAgdGhpcy5ub3JtYWxNb2RlTnVtYmVyID0gbm9ybWFsTW9kZU51bWJlcjtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7bnVtYmVyfSAtIGhvdyBtYW55IHBvaW50cyB0aGUgY3VydmUgaGFzXHJcbiAgICB0aGlzLmN1cnZlUmVzb2x1dGlvbiA9IG9wdGlvbnMuY3VydmVSZXNvbHV0aW9uO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtEaW1lbnNpb24yfVxyXG4gICAgdGhpcy5ncmFwaFNpemUgPSBvcHRpb25zLmdyYXBoU2l6ZTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7T2JqZWN0fSAtIHN0YXJ0IHBvaW50IG9mIHRoZSBncmFwaFxyXG4gICAgdGhpcy5ncmFwaFN0YXJ0ID0geyB4OiBvcHRpb25zLmdyYXBoU3RhcnRYLCB5OiB0aGlzLmdyYXBoU2l6ZS5oZWlnaHQgLyAyIH07IC8vIEBwcml2YXRlXHJcblxyXG4gICAgLy8gQHByaXZhdGUge251bWJlcn0gLSB4IGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgZ3JhcGggcG9pbnRzXHJcbiAgICB0aGlzLnhTdGVwID0gdGhpcy5ncmFwaFNpemUud2lkdGggLyB0aGlzLmN1cnZlUmVzb2x1dGlvbjtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7QXJyYXkuPG51bWJlcj59XHJcbiAgICB0aGlzLmN1cnZlWVBvc2l0aW9ucyA9IG5ldyBBcnJheSggdGhpcy5jdXJ2ZVJlc29sdXRpb24gKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7U3RyaW5nfSAtIGN1cnZlIHN0cm9rZSBjYW52YXMgY29sb3JcclxuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBvcHRpb25zLnN0cm9rZUNvbG9yO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtTdHJpbmd9IC0gcmVmZXJlbmNlIGxpbmUgKHkgPSAwKSBzdHJva2UgY2FudmFzIGNvbG9yXHJcbiAgICB0aGlzLnJlZmVyZW5jZUxpbmVTdHJva2VDb2xvciA9IG9wdGlvbnMucmVmZXJlbmNlTGluZVN0cm9rZUNvbG9yO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtQcm9wZXJ0eS48bnVtYmVyPn1cclxuICAgIHRoaXMubW9kZUZyZXF1ZW5jeVByb3BlcnR5ID0gbW9kZUZyZXF1ZW5jeVByb3BlcnR5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFpbnRzIHRoZSBzdGF0aWMgbm9ybWFsIG1vZGUgZ3JhcGguXHJcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHRcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcGFpbnRDYW52YXMoIGNvbnRleHQgKSB7XHJcblxyXG4gICAgLy8gZHJhdyByZWZlcmVuY2UgbGluZVxyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLnJlZmVyZW5jZUxpbmVTdHJva2VDb2xvcjtcclxuICAgIGNvbnRleHQubGluZVdpZHRoID0gMjtcclxuICAgIGNvbnRleHQubW92ZVRvKCB0aGlzLmdyYXBoU3RhcnQueCwgdGhpcy5ncmFwaFN0YXJ0LnkgKTtcclxuICAgIGNvbnRleHQubGluZVRvKCB0aGlzLmdyYXBoU3RhcnQueCArIHRoaXMuZ3JhcGhTaXplLndpZHRoLCB0aGlzLmdyYXBoU3RhcnQueSApO1xyXG4gICAgY29udGV4dC5zdHJva2UoKTtcclxuXHJcbiAgICAvLyBwbG90XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oIHRoaXMuZ3JhcGhTdGFydC54LCB0aGlzLmdyYXBoU3RhcnQueSApO1xyXG4gICAgZm9yICggbGV0IGkgPSAxOyBpIDwgdGhpcy5jdXJ2ZVlQb3NpdGlvbnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgIGNvbnRleHQubGluZVRvKCB0aGlzLmdyYXBoU3RhcnQueCArIGkgKiB0aGlzLnhTdGVwLCB0aGlzLmN1cnZlWVBvc2l0aW9uc1sgaSBdICsgdGhpcy5ncmFwaFN0YXJ0LnkgKTtcclxuICAgIH1cclxuICAgIGNvbnRleHQubGluZVRvKCB0aGlzLmdyYXBoU3RhcnQueCArIHRoaXMuZ3JhcGhTaXplLndpZHRoLCB0aGlzLmdyYXBoU3RhcnQueSApO1xyXG5cclxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZUNvbG9yO1xyXG4gICAgY29udGV4dC5saW5lV2lkdGggPSAyO1xyXG4gICAgY29udGV4dC5zdHJva2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIGN1cnZlLlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIGhhcHBlbnMgb25seSBvbmNlLiBCZWNhdXNlIGl0IGlzIHN0YXRpYywgdGhlcmUncyBubyBuZWVkIHRvIGtlZXAgdXBkYXRpbmcgaXQuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHVwZGF0ZSgpIHtcclxuXHJcbiAgICBjb25zdCBuID0gdGhpcy5ub3JtYWxNb2RlTnVtYmVyO1xyXG4gICAgY29uc3QgYW1wbGl0dWRlID0gMC4wNzU7XHJcbiAgICBjb25zdCBwaGFzZSA9IDA7XHJcbiAgICBjb25zdCBmcmVxdWVuY3kgPSB0aGlzLm1vZGVGcmVxdWVuY3lQcm9wZXJ0eS5nZXQoKTtcclxuICAgIGNvbnN0IHRpbWUgPSAwO1xyXG5cclxuICAgIC8vIHB1dCBhIG5lZ2F0aXZlIHNpZ24gaW4gZnJvbnQgb2YgaXQgYmVjYXVzZSBvZiB5IGNvb3JkaW5hdGUgc3R1ZmZcclxuICAgIGNvbnN0IGhlaWdodEZhY3RvciA9IC0oIDIgKiB0aGlzLmdyYXBoU2l6ZS5oZWlnaHQgLyAzICk7XHJcblxyXG4gICAgLy8gdGhpcyByZXN1bHQgaXMgdGhlIHNhbWUgZm9yIGFsbCBjdXJ2ZSBwb3NpdGlvbnMsIHNvIGl0J3MgbW9yZSBlZmZpY2llbnQgdG8gb25seSBydW4gaXQgb25jZVxyXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoIGZyZXF1ZW5jeSAqIHRpbWUgLSBwaGFzZSApO1xyXG5cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuY3VydmVZUG9zaXRpb25zLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICBjb25zdCB4ID0gaSAvIHRoaXMuY3VydmVSZXNvbHV0aW9uO1xyXG5cclxuICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oIHggKiAoIG4gKyAxICkgKiBNYXRoLlBJICk7XHJcbiAgICAgIHRoaXMuY3VydmVZUG9zaXRpb25zWyBpIF0gPSBoZWlnaHRGYWN0b3IgKiAoIGFtcGxpdHVkZSAqIHNpbiAqIGNvcyApIC8gTm9ybWFsTW9kZXNDb25zdGFudHMuTUFYX0FNUExJVFVERTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm5vcm1hbE1vZGVzLnJlZ2lzdGVyKCAnU3RhdGljTW9kZUdyYXBoQ2FudmFzTm9kZScsIFN0YXRpY01vZGVHcmFwaENhbnZhc05vZGUgKTtcclxuZXhwb3J0IGRlZmF1bHQgU3RhdGljTW9kZUdyYXBoQ2FudmFzTm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLFVBQVUsTUFBTSxrQ0FBa0M7QUFDekQsT0FBT0MsS0FBSyxNQUFNLG1DQUFtQztBQUNyRCxTQUFTQyxVQUFVLFFBQVEsbUNBQW1DO0FBQzlELE9BQU9DLGlCQUFpQixNQUFNLG1DQUFtQztBQUNqRSxPQUFPQyxvQkFBb0IsTUFBTSxzQ0FBc0M7QUFDdkUsT0FBT0MsV0FBVyxNQUFNLHNCQUFzQjtBQUU5QyxNQUFNQyx5QkFBeUIsU0FBU0osVUFBVSxDQUFDO0VBRWpEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRUssV0FBV0EsQ0FBRUMsZ0JBQWdCLEVBQUVDLHFCQUFxQixFQUFFQyxPQUFPLEVBQUc7SUFFOURBLE9BQU8sR0FBR1QsS0FBSyxDQUFFO01BQ2ZVLFNBQVMsRUFBRSxJQUFJWCxVQUFVLENBQUUsRUFBRSxFQUFFLEVBQUcsQ0FBQztNQUNuQ1ksV0FBVyxFQUFFLENBQUM7TUFDZEMsZUFBZSxFQUFFO0lBQ25CLENBQUMsRUFBRVYsaUJBQWlCLENBQUNXLGlCQUFpQixFQUFFSixPQUFRLENBQUM7SUFFakRBLE9BQU8sQ0FBQ0ssWUFBWSxHQUFHLElBQUloQixPQUFPLENBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRVcsT0FBTyxDQUFDQyxTQUFTLENBQUNLLEtBQUssRUFBRU4sT0FBTyxDQUFDQyxTQUFTLENBQUNNLE1BQU8sQ0FBQztJQUM3RixLQUFLLENBQUVQLE9BQVEsQ0FBQzs7SUFFaEI7SUFDQSxJQUFJLENBQUNGLGdCQUFnQixHQUFHQSxnQkFBZ0I7O0lBRXhDO0lBQ0EsSUFBSSxDQUFDSyxlQUFlLEdBQUdILE9BQU8sQ0FBQ0csZUFBZTs7SUFFOUM7SUFDQSxJQUFJLENBQUNGLFNBQVMsR0FBR0QsT0FBTyxDQUFDQyxTQUFTOztJQUVsQztJQUNBLElBQUksQ0FBQ08sVUFBVSxHQUFHO01BQUVDLENBQUMsRUFBRVQsT0FBTyxDQUFDRSxXQUFXO01BQUVRLENBQUMsRUFBRSxJQUFJLENBQUNULFNBQVMsQ0FBQ00sTUFBTSxHQUFHO0lBQUUsQ0FBQyxDQUFDLENBQUM7O0lBRTVFO0lBQ0EsSUFBSSxDQUFDSSxLQUFLLEdBQUcsSUFBSSxDQUFDVixTQUFTLENBQUNLLEtBQUssR0FBRyxJQUFJLENBQUNILGVBQWU7O0lBRXhEO0lBQ0EsSUFBSSxDQUFDUyxlQUFlLEdBQUcsSUFBSUMsS0FBSyxDQUFFLElBQUksQ0FBQ1YsZUFBZ0IsQ0FBQzs7SUFFeEQ7SUFDQSxJQUFJLENBQUNXLFdBQVcsR0FBR2QsT0FBTyxDQUFDYyxXQUFXOztJQUV0QztJQUNBLElBQUksQ0FBQ0Msd0JBQXdCLEdBQUdmLE9BQU8sQ0FBQ2Usd0JBQXdCOztJQUVoRTtJQUNBLElBQUksQ0FBQ2hCLHFCQUFxQixHQUFHQSxxQkFBcUI7RUFDcEQ7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFaUIsV0FBV0EsQ0FBRUMsT0FBTyxFQUFHO0lBRXJCO0lBQ0FBLE9BQU8sQ0FBQ0MsU0FBUyxDQUFDLENBQUM7SUFDbkJELE9BQU8sQ0FBQ0UsV0FBVyxHQUFHLElBQUksQ0FBQ0osd0JBQXdCO0lBQ25ERSxPQUFPLENBQUNHLFNBQVMsR0FBRyxDQUFDO0lBQ3JCSCxPQUFPLENBQUNJLE1BQU0sQ0FBRSxJQUFJLENBQUNiLFVBQVUsQ0FBQ0MsQ0FBQyxFQUFFLElBQUksQ0FBQ0QsVUFBVSxDQUFDRSxDQUFFLENBQUM7SUFDdERPLE9BQU8sQ0FBQ0ssTUFBTSxDQUFFLElBQUksQ0FBQ2QsVUFBVSxDQUFDQyxDQUFDLEdBQUcsSUFBSSxDQUFDUixTQUFTLENBQUNLLEtBQUssRUFBRSxJQUFJLENBQUNFLFVBQVUsQ0FBQ0UsQ0FBRSxDQUFDO0lBQzdFTyxPQUFPLENBQUNNLE1BQU0sQ0FBQyxDQUFDOztJQUVoQjtJQUNBTixPQUFPLENBQUNDLFNBQVMsQ0FBQyxDQUFDO0lBQ25CRCxPQUFPLENBQUNJLE1BQU0sQ0FBRSxJQUFJLENBQUNiLFVBQVUsQ0FBQ0MsQ0FBQyxFQUFFLElBQUksQ0FBQ0QsVUFBVSxDQUFDRSxDQUFFLENBQUM7SUFDdEQsS0FBTSxJQUFJYyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUcsSUFBSSxDQUFDWixlQUFlLENBQUNhLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUc7TUFDdERQLE9BQU8sQ0FBQ0ssTUFBTSxDQUFFLElBQUksQ0FBQ2QsVUFBVSxDQUFDQyxDQUFDLEdBQUdlLENBQUMsR0FBRyxJQUFJLENBQUNiLEtBQUssRUFBRSxJQUFJLENBQUNDLGVBQWUsQ0FBRVksQ0FBQyxDQUFFLEdBQUcsSUFBSSxDQUFDaEIsVUFBVSxDQUFDRSxDQUFFLENBQUM7SUFDckc7SUFDQU8sT0FBTyxDQUFDSyxNQUFNLENBQUUsSUFBSSxDQUFDZCxVQUFVLENBQUNDLENBQUMsR0FBRyxJQUFJLENBQUNSLFNBQVMsQ0FBQ0ssS0FBSyxFQUFFLElBQUksQ0FBQ0UsVUFBVSxDQUFDRSxDQUFFLENBQUM7SUFFN0VPLE9BQU8sQ0FBQ0UsV0FBVyxHQUFHLElBQUksQ0FBQ0wsV0FBVztJQUN0Q0csT0FBTyxDQUFDRyxTQUFTLEdBQUcsQ0FBQztJQUNyQkgsT0FBTyxDQUFDTSxNQUFNLENBQUMsQ0FBQztFQUNsQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0VHLE1BQU1BLENBQUEsRUFBRztJQUVQLE1BQU1DLENBQUMsR0FBRyxJQUFJLENBQUM3QixnQkFBZ0I7SUFDL0IsTUFBTThCLFNBQVMsR0FBRyxLQUFLO0lBQ3ZCLE1BQU1DLEtBQUssR0FBRyxDQUFDO0lBQ2YsTUFBTUMsU0FBUyxHQUFHLElBQUksQ0FBQy9CLHFCQUFxQixDQUFDZ0MsR0FBRyxDQUFDLENBQUM7SUFDbEQsTUFBTUMsSUFBSSxHQUFHLENBQUM7O0lBRWQ7SUFDQSxNQUFNQyxZQUFZLEdBQUcsRUFBRyxDQUFDLEdBQUcsSUFBSSxDQUFDaEMsU0FBUyxDQUFDTSxNQUFNLEdBQUcsQ0FBQyxDQUFFOztJQUV2RDtJQUNBLE1BQU0yQixHQUFHLEdBQUdDLElBQUksQ0FBQ0QsR0FBRyxDQUFFSixTQUFTLEdBQUdFLElBQUksR0FBR0gsS0FBTSxDQUFDO0lBRWhELEtBQU0sSUFBSUwsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHLElBQUksQ0FBQ1osZUFBZSxDQUFDYSxNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFHO01BQ3RELE1BQU1mLENBQUMsR0FBR2UsQ0FBQyxHQUFHLElBQUksQ0FBQ3JCLGVBQWU7TUFFbEMsTUFBTWlDLEdBQUcsR0FBR0QsSUFBSSxDQUFDQyxHQUFHLENBQUUzQixDQUFDLElBQUtrQixDQUFDLEdBQUcsQ0FBQyxDQUFFLEdBQUdRLElBQUksQ0FBQ0UsRUFBRyxDQUFDO01BQy9DLElBQUksQ0FBQ3pCLGVBQWUsQ0FBRVksQ0FBQyxDQUFFLEdBQUdTLFlBQVksSUFBS0wsU0FBUyxHQUFHUSxHQUFHLEdBQUdGLEdBQUcsQ0FBRSxHQUFHeEMsb0JBQW9CLENBQUM0QyxhQUFhO0lBQzNHO0VBQ0Y7QUFDRjtBQUVBM0MsV0FBVyxDQUFDNEMsUUFBUSxDQUFFLDJCQUEyQixFQUFFM0MseUJBQTBCLENBQUM7QUFDOUUsZUFBZUEseUJBQXlCIn0=