// Copyright 2020-2022, University of Colorado Boulder

/**
 * The view for the 'One Dimension' Screen.
 *
 * @author Franco Barpp Gomes (UTFPR)
 * @author Thiago de MendonÃ§a Mildemberger (UTFPR)
 */

import Bounds2 from '../../../../dot/js/Bounds2.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import ScreenView from '../../../../joist/js/ScreenView.js';
import merge from '../../../../phet-core/js/merge.js';
import ModelViewTransform2 from '../../../../phetcommon/js/view/ModelViewTransform2.js';
import ResetAllButton from '../../../../scenery-phet/js/buttons/ResetAllButton.js';
import { Node, Rectangle } from '../../../../scenery/js/imports.js';
import Tandem from '../../../../tandem/js/Tandem.js';
import NormalModesColors from '../../common/NormalModesColors.js';
import NormalModesConstants from '../../common/NormalModesConstants.js';
import NormalModesQueryParameters from '../../common/NormalModesQueryParameters.js';
import NormalModesControlPanel from '../../common/view/NormalModesControlPanel.js';
import SpringNode from '../../common/view/SpringNode.js';
import normalModes from '../../normalModes.js';
import MassNode1D from './MassNode1D.js';
import NormalModesAccordionBox from './NormalModesAccordionBox.js';
import NormalModeSpectrumAccordionBox from './NormalModeSpectrumAccordionBox.js';
import WallNode from './WallNode.js';

// constants
const VIEW_SPRING_WIDTH = 745; // width of the spring, in view coordinates

class OneDimensionScreenView extends ScreenView {
  /**
   * @param {OneDimensionModel} model
   * @param {Object} [options]
   */
  constructor(model, options) {
    options = merge({
      tandem: Tandem.REQUIRED
    }, options);
    super(options);

    // TODO https://github.com/phetsims/normal-modes/issues/38 magic numbers
    // The midpoint between leftWall and rightWall
    const viewOrigin = new Vector2(VIEW_SPRING_WIDTH / 2 + NormalModesConstants.SCREEN_VIEW_X_MARGIN + 4, (this.layoutBounds.maxY - 300) / 2);
    const modelViewTransform = ModelViewTransform2.createSinglePointScaleInvertedYMapping(Vector2.ZERO, viewOrigin, VIEW_SPRING_WIDTH / 2);
    const resetAllButton = new ResetAllButton({
      listener: () => {
        this.interruptSubtreeInput(); // cancel interactions that may be in progress
        model.reset();
        resetView();
      },
      right: this.layoutBounds.maxX - NormalModesConstants.SCREEN_VIEW_X_MARGIN,
      bottom: this.layoutBounds.maxY - NormalModesConstants.SCREEN_VIEW_Y_MARGIN,
      tandem: options.tandem.createTandem('resetAllButton')
    });

    // Untitled control panel
    const controlPanel = new NormalModesControlPanel(model, merge({
      right: this.layoutBounds.maxX - NormalModesConstants.SCREEN_VIEW_X_MARGIN - resetAllButton.width - 10,
      top: NormalModesConstants.SCREEN_VIEW_Y_MARGIN,
      cornerRadius: 5,
      xMargin: 8,
      yMargin: 8
    }, NormalModesColors.PANEL_COLORS));

    // Normal Mode Spectrum accordion box
    const normalModeSpectrumAccordionBox = new NormalModeSpectrumAccordionBox(model, merge({
      bottom: this.layoutBounds.maxY - NormalModesConstants.SCREEN_VIEW_Y_MARGIN,
      cornerRadius: 5,
      centerX: viewOrigin.x
    }, NormalModesColors.PANEL_COLORS));

    // Springs
    const springNodesParent = new Node({
      children: model.springs.map(spring => new SpringNode(spring, modelViewTransform, model.springsVisibleProperty, options.tandem.createTandem('springNodes')))
    });

    // Left and right walls
    const leftWallNode = new WallNode(model.masses[0], modelViewTransform, options.tandem.createTandem('leftWallNode'));
    const rightWallNode = new WallNode(model.masses[model.masses.length - 1], modelViewTransform, options.tandem.createTandem('rightWallNode'));

    // Drag bounds for the masses, centered on the walls. Height is adjustable via ?dragBoundsHeight1D.
    // See https://github.com/phetsims/normal-modes/issues/68
    const dragBoundsView = new Bounds2(leftWallNode.right, leftWallNode.centerY - NormalModesQueryParameters.dragBoundsHeight1D / 2, rightWallNode.left, leftWallNode.centerY + NormalModesQueryParameters.dragBoundsHeight1D / 2);
    const dragBoundsModel = modelViewTransform.viewToModelBounds(dragBoundsView);

    // Masses - use slice to ignore the virtual stationary masses at the walls
    const massNodesParent = new Node({
      children: model.masses.slice(1, model.masses.length - 1).map(mass => new MassNode1D(mass, modelViewTransform, model, dragBoundsModel, options.tandem.createTandem('massNodes')))
    });

    // Normal Modes accordion box
    const normalModesAccordionBox = new NormalModesAccordionBox(model, merge({
      top: controlPanel.bottom + 8,
      right: this.layoutBounds.maxX - NormalModesConstants.SCREEN_VIEW_X_MARGIN - resetAllButton.width - 10
    }, NormalModesColors.PANEL_COLORS));
    const screenViewRootNode = new Node({
      children: [controlPanel, normalModesAccordionBox, normalModeSpectrumAccordionBox, resetAllButton, springNodesParent, leftWallNode, rightWallNode, massNodesParent]
    });
    this.addChild(screenViewRootNode);

    // Render the drag bounds
    if (NormalModesQueryParameters.showDragBounds1D) {
      console.log('drawing drag bounds');
      this.addChild(new Rectangle(dragBoundsView, {
        stroke: 'red'
      }));
    }

    // When the number of masses is changed, interrupt any dragging that may be in progress.
    model.numberOfMassesProperty.link(numberOfMasses => {
      massNodesParent.interruptSubtreeInput();
    });
    const resetView = () => {
      normalModeSpectrumAccordionBox.expandedProperty.reset();
      normalModesAccordionBox.expandedProperty.reset();
    };
  }
}
normalModes.register('OneDimensionScreenView', OneDimensionScreenView);
export default OneDimensionScreenView;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiVmVjdG9yMiIsIlNjcmVlblZpZXciLCJtZXJnZSIsIk1vZGVsVmlld1RyYW5zZm9ybTIiLCJSZXNldEFsbEJ1dHRvbiIsIk5vZGUiLCJSZWN0YW5nbGUiLCJUYW5kZW0iLCJOb3JtYWxNb2Rlc0NvbG9ycyIsIk5vcm1hbE1vZGVzQ29uc3RhbnRzIiwiTm9ybWFsTW9kZXNRdWVyeVBhcmFtZXRlcnMiLCJOb3JtYWxNb2Rlc0NvbnRyb2xQYW5lbCIsIlNwcmluZ05vZGUiLCJub3JtYWxNb2RlcyIsIk1hc3NOb2RlMUQiLCJOb3JtYWxNb2Rlc0FjY29yZGlvbkJveCIsIk5vcm1hbE1vZGVTcGVjdHJ1bUFjY29yZGlvbkJveCIsIldhbGxOb2RlIiwiVklFV19TUFJJTkdfV0lEVEgiLCJPbmVEaW1lbnNpb25TY3JlZW5WaWV3IiwiY29uc3RydWN0b3IiLCJtb2RlbCIsIm9wdGlvbnMiLCJ0YW5kZW0iLCJSRVFVSVJFRCIsInZpZXdPcmlnaW4iLCJTQ1JFRU5fVklFV19YX01BUkdJTiIsImxheW91dEJvdW5kcyIsIm1heFkiLCJtb2RlbFZpZXdUcmFuc2Zvcm0iLCJjcmVhdGVTaW5nbGVQb2ludFNjYWxlSW52ZXJ0ZWRZTWFwcGluZyIsIlpFUk8iLCJyZXNldEFsbEJ1dHRvbiIsImxpc3RlbmVyIiwiaW50ZXJydXB0U3VidHJlZUlucHV0IiwicmVzZXQiLCJyZXNldFZpZXciLCJyaWdodCIsIm1heFgiLCJib3R0b20iLCJTQ1JFRU5fVklFV19ZX01BUkdJTiIsImNyZWF0ZVRhbmRlbSIsImNvbnRyb2xQYW5lbCIsIndpZHRoIiwidG9wIiwiY29ybmVyUmFkaXVzIiwieE1hcmdpbiIsInlNYXJnaW4iLCJQQU5FTF9DT0xPUlMiLCJub3JtYWxNb2RlU3BlY3RydW1BY2NvcmRpb25Cb3giLCJjZW50ZXJYIiwieCIsInNwcmluZ05vZGVzUGFyZW50IiwiY2hpbGRyZW4iLCJzcHJpbmdzIiwibWFwIiwic3ByaW5nIiwic3ByaW5nc1Zpc2libGVQcm9wZXJ0eSIsImxlZnRXYWxsTm9kZSIsIm1hc3NlcyIsInJpZ2h0V2FsbE5vZGUiLCJsZW5ndGgiLCJkcmFnQm91bmRzVmlldyIsImNlbnRlclkiLCJkcmFnQm91bmRzSGVpZ2h0MUQiLCJsZWZ0IiwiZHJhZ0JvdW5kc01vZGVsIiwidmlld1RvTW9kZWxCb3VuZHMiLCJtYXNzTm9kZXNQYXJlbnQiLCJzbGljZSIsIm1hc3MiLCJub3JtYWxNb2Rlc0FjY29yZGlvbkJveCIsInNjcmVlblZpZXdSb290Tm9kZSIsImFkZENoaWxkIiwic2hvd0RyYWdCb3VuZHMxRCIsImNvbnNvbGUiLCJsb2ciLCJzdHJva2UiLCJudW1iZXJPZk1hc3Nlc1Byb3BlcnR5IiwibGluayIsIm51bWJlck9mTWFzc2VzIiwiZXhwYW5kZWRQcm9wZXJ0eSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiT25lRGltZW5zaW9uU2NyZWVuVmlldy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMC0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBUaGUgdmlldyBmb3IgdGhlICdPbmUgRGltZW5zaW9uJyBTY3JlZW4uXHJcbiAqXHJcbiAqIEBhdXRob3IgRnJhbmNvIEJhcnBwIEdvbWVzIChVVEZQUilcclxuICogQGF1dGhvciBUaGlhZ28gZGUgTWVuZG9uw6dhIE1pbGRlbWJlcmdlciAoVVRGUFIpXHJcbiAqL1xyXG5cclxuaW1wb3J0IEJvdW5kczIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL0JvdW5kczIuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBTY3JlZW5WaWV3IGZyb20gJy4uLy4uLy4uLy4uL2pvaXN0L2pzL1NjcmVlblZpZXcuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lcmdlLmpzJztcclxuaW1wb3J0IE1vZGVsVmlld1RyYW5zZm9ybTIgZnJvbSAnLi4vLi4vLi4vLi4vcGhldGNvbW1vbi9qcy92aWV3L01vZGVsVmlld1RyYW5zZm9ybTIuanMnO1xyXG5pbXBvcnQgUmVzZXRBbGxCdXR0b24gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS1waGV0L2pzL2J1dHRvbnMvUmVzZXRBbGxCdXR0b24uanMnO1xyXG5pbXBvcnQgeyBOb2RlLCBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgVGFuZGVtIGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy9UYW5kZW0uanMnO1xyXG5pbXBvcnQgTm9ybWFsTW9kZXNDb2xvcnMgZnJvbSAnLi4vLi4vY29tbW9uL05vcm1hbE1vZGVzQ29sb3JzLmpzJztcclxuaW1wb3J0IE5vcm1hbE1vZGVzQ29uc3RhbnRzIGZyb20gJy4uLy4uL2NvbW1vbi9Ob3JtYWxNb2Rlc0NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBOb3JtYWxNb2Rlc1F1ZXJ5UGFyYW1ldGVycyBmcm9tICcuLi8uLi9jb21tb24vTm9ybWFsTW9kZXNRdWVyeVBhcmFtZXRlcnMuanMnO1xyXG5pbXBvcnQgTm9ybWFsTW9kZXNDb250cm9sUGFuZWwgZnJvbSAnLi4vLi4vY29tbW9uL3ZpZXcvTm9ybWFsTW9kZXNDb250cm9sUGFuZWwuanMnO1xyXG5pbXBvcnQgU3ByaW5nTm9kZSBmcm9tICcuLi8uLi9jb21tb24vdmlldy9TcHJpbmdOb2RlLmpzJztcclxuaW1wb3J0IG5vcm1hbE1vZGVzIGZyb20gJy4uLy4uL25vcm1hbE1vZGVzLmpzJztcclxuaW1wb3J0IE1hc3NOb2RlMUQgZnJvbSAnLi9NYXNzTm9kZTFELmpzJztcclxuaW1wb3J0IE5vcm1hbE1vZGVzQWNjb3JkaW9uQm94IGZyb20gJy4vTm9ybWFsTW9kZXNBY2NvcmRpb25Cb3guanMnO1xyXG5pbXBvcnQgTm9ybWFsTW9kZVNwZWN0cnVtQWNjb3JkaW9uQm94IGZyb20gJy4vTm9ybWFsTW9kZVNwZWN0cnVtQWNjb3JkaW9uQm94LmpzJztcclxuaW1wb3J0IFdhbGxOb2RlIGZyb20gJy4vV2FsbE5vZGUuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IFZJRVdfU1BSSU5HX1dJRFRIID0gNzQ1OyAvLyB3aWR0aCBvZiB0aGUgc3ByaW5nLCBpbiB2aWV3IGNvb3JkaW5hdGVzXHJcblxyXG5jbGFzcyBPbmVEaW1lbnNpb25TY3JlZW5WaWV3IGV4dGVuZHMgU2NyZWVuVmlldyB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T25lRGltZW5zaW9uTW9kZWx9IG1vZGVsXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBtb2RlbCwgb3B0aW9ucyApIHtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuICAgICAgdGFuZGVtOiBUYW5kZW0uUkVRVUlSRURcclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICBzdXBlciggb3B0aW9ucyApO1xyXG5cclxuICAgIC8vIFRPRE8gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL25vcm1hbC1tb2Rlcy9pc3N1ZXMvMzggbWFnaWMgbnVtYmVyc1xyXG4gICAgLy8gVGhlIG1pZHBvaW50IGJldHdlZW4gbGVmdFdhbGwgYW5kIHJpZ2h0V2FsbFxyXG4gICAgY29uc3Qgdmlld09yaWdpbiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICBWSUVXX1NQUklOR19XSURUSCAvIDIgKyBOb3JtYWxNb2Rlc0NvbnN0YW50cy5TQ1JFRU5fVklFV19YX01BUkdJTiArIDQsXHJcbiAgICAgICggdGhpcy5sYXlvdXRCb3VuZHMubWF4WSAtIDMwMCApIC8gMlxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBtb2RlbFZpZXdUcmFuc2Zvcm0gPSBNb2RlbFZpZXdUcmFuc2Zvcm0yLmNyZWF0ZVNpbmdsZVBvaW50U2NhbGVJbnZlcnRlZFlNYXBwaW5nKFxyXG4gICAgICBWZWN0b3IyLlpFUk8sIHZpZXdPcmlnaW4sIFZJRVdfU1BSSU5HX1dJRFRIIC8gMlxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCByZXNldEFsbEJ1dHRvbiA9IG5ldyBSZXNldEFsbEJ1dHRvbigge1xyXG4gICAgICBsaXN0ZW5lcjogKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuaW50ZXJydXB0U3VidHJlZUlucHV0KCk7IC8vIGNhbmNlbCBpbnRlcmFjdGlvbnMgdGhhdCBtYXkgYmUgaW4gcHJvZ3Jlc3NcclxuICAgICAgICBtb2RlbC5yZXNldCgpO1xyXG4gICAgICAgIHJlc2V0VmlldygpO1xyXG4gICAgICB9LFxyXG4gICAgICByaWdodDogdGhpcy5sYXlvdXRCb3VuZHMubWF4WCAtIE5vcm1hbE1vZGVzQ29uc3RhbnRzLlNDUkVFTl9WSUVXX1hfTUFSR0lOLFxyXG4gICAgICBib3R0b206IHRoaXMubGF5b3V0Qm91bmRzLm1heFkgLSBOb3JtYWxNb2Rlc0NvbnN0YW50cy5TQ1JFRU5fVklFV19ZX01BUkdJTixcclxuICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICdyZXNldEFsbEJ1dHRvbicgKVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFVudGl0bGVkIGNvbnRyb2wgcGFuZWxcclxuICAgIGNvbnN0IGNvbnRyb2xQYW5lbCA9IG5ldyBOb3JtYWxNb2Rlc0NvbnRyb2xQYW5lbCggbW9kZWwsIG1lcmdlKCB7XHJcbiAgICAgIHJpZ2h0OiB0aGlzLmxheW91dEJvdW5kcy5tYXhYIC0gTm9ybWFsTW9kZXNDb25zdGFudHMuU0NSRUVOX1ZJRVdfWF9NQVJHSU4gLSByZXNldEFsbEJ1dHRvbi53aWR0aCAtIDEwLFxyXG4gICAgICB0b3A6IE5vcm1hbE1vZGVzQ29uc3RhbnRzLlNDUkVFTl9WSUVXX1lfTUFSR0lOLFxyXG4gICAgICBjb3JuZXJSYWRpdXM6IDUsXHJcbiAgICAgIHhNYXJnaW46IDgsXHJcbiAgICAgIHlNYXJnaW46IDhcclxuICAgIH0sIE5vcm1hbE1vZGVzQ29sb3JzLlBBTkVMX0NPTE9SUyApICk7XHJcblxyXG4gICAgLy8gTm9ybWFsIE1vZGUgU3BlY3RydW0gYWNjb3JkaW9uIGJveFxyXG4gICAgY29uc3Qgbm9ybWFsTW9kZVNwZWN0cnVtQWNjb3JkaW9uQm94ID0gbmV3IE5vcm1hbE1vZGVTcGVjdHJ1bUFjY29yZGlvbkJveCggbW9kZWwsIG1lcmdlKCB7XHJcbiAgICAgIGJvdHRvbTogdGhpcy5sYXlvdXRCb3VuZHMubWF4WSAtIE5vcm1hbE1vZGVzQ29uc3RhbnRzLlNDUkVFTl9WSUVXX1lfTUFSR0lOLFxyXG4gICAgICBjb3JuZXJSYWRpdXM6IDUsXHJcbiAgICAgIGNlbnRlclg6IHZpZXdPcmlnaW4ueFxyXG4gICAgfSwgTm9ybWFsTW9kZXNDb2xvcnMuUEFORUxfQ09MT1JTICkgKTtcclxuXHJcbiAgICAvLyBTcHJpbmdzXHJcbiAgICBjb25zdCBzcHJpbmdOb2Rlc1BhcmVudCA9IG5ldyBOb2RlKCB7XHJcbiAgICAgIGNoaWxkcmVuOiBtb2RlbC5zcHJpbmdzLm1hcCggc3ByaW5nID0+IG5ldyBTcHJpbmdOb2RlKFxyXG4gICAgICAgIHNwcmluZywgbW9kZWxWaWV3VHJhbnNmb3JtLCBtb2RlbC5zcHJpbmdzVmlzaWJsZVByb3BlcnR5LCBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICdzcHJpbmdOb2RlcycgKVxyXG4gICAgICApIClcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBMZWZ0IGFuZCByaWdodCB3YWxsc1xyXG4gICAgY29uc3QgbGVmdFdhbGxOb2RlID0gbmV3IFdhbGxOb2RlKFxyXG4gICAgICBtb2RlbC5tYXNzZXNbIDAgXSwgbW9kZWxWaWV3VHJhbnNmb3JtLCBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICdsZWZ0V2FsbE5vZGUnIClcclxuICAgICk7XHJcbiAgICBjb25zdCByaWdodFdhbGxOb2RlID0gbmV3IFdhbGxOb2RlKFxyXG4gICAgICBtb2RlbC5tYXNzZXNbIG1vZGVsLm1hc3Nlcy5sZW5ndGggLSAxIF0sIG1vZGVsVmlld1RyYW5zZm9ybSwgb3B0aW9ucy50YW5kZW0uY3JlYXRlVGFuZGVtKCAncmlnaHRXYWxsTm9kZScgKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBEcmFnIGJvdW5kcyBmb3IgdGhlIG1hc3NlcywgY2VudGVyZWQgb24gdGhlIHdhbGxzLiBIZWlnaHQgaXMgYWRqdXN0YWJsZSB2aWEgP2RyYWdCb3VuZHNIZWlnaHQxRC5cclxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvbm9ybWFsLW1vZGVzL2lzc3Vlcy82OFxyXG4gICAgY29uc3QgZHJhZ0JvdW5kc1ZpZXcgPSBuZXcgQm91bmRzMihcclxuICAgICAgbGVmdFdhbGxOb2RlLnJpZ2h0LFxyXG4gICAgICBsZWZ0V2FsbE5vZGUuY2VudGVyWSAtIE5vcm1hbE1vZGVzUXVlcnlQYXJhbWV0ZXJzLmRyYWdCb3VuZHNIZWlnaHQxRCAvIDIsXHJcbiAgICAgIHJpZ2h0V2FsbE5vZGUubGVmdCxcclxuICAgICAgbGVmdFdhbGxOb2RlLmNlbnRlclkgKyBOb3JtYWxNb2Rlc1F1ZXJ5UGFyYW1ldGVycy5kcmFnQm91bmRzSGVpZ2h0MUQgLyAyXHJcbiAgICApO1xyXG4gICAgY29uc3QgZHJhZ0JvdW5kc01vZGVsID0gbW9kZWxWaWV3VHJhbnNmb3JtLnZpZXdUb01vZGVsQm91bmRzKCBkcmFnQm91bmRzVmlldyApO1xyXG5cclxuICAgIC8vIE1hc3NlcyAtIHVzZSBzbGljZSB0byBpZ25vcmUgdGhlIHZpcnR1YWwgc3RhdGlvbmFyeSBtYXNzZXMgYXQgdGhlIHdhbGxzXHJcbiAgICBjb25zdCBtYXNzTm9kZXNQYXJlbnQgPSBuZXcgTm9kZSgge1xyXG4gICAgICBjaGlsZHJlbjogbW9kZWwubWFzc2VzXHJcbiAgICAgICAgLnNsaWNlKCAxLCBtb2RlbC5tYXNzZXMubGVuZ3RoIC0gMSApXHJcbiAgICAgICAgLm1hcCggbWFzcyA9PlxyXG4gICAgICAgICAgbmV3IE1hc3NOb2RlMUQoIG1hc3MsIG1vZGVsVmlld1RyYW5zZm9ybSwgbW9kZWwsIGRyYWdCb3VuZHNNb2RlbCwgb3B0aW9ucy50YW5kZW0uY3JlYXRlVGFuZGVtKCAnbWFzc05vZGVzJyApICkgKVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIE5vcm1hbCBNb2RlcyBhY2NvcmRpb24gYm94XHJcbiAgICBjb25zdCBub3JtYWxNb2Rlc0FjY29yZGlvbkJveCA9IG5ldyBOb3JtYWxNb2Rlc0FjY29yZGlvbkJveCggbW9kZWwsIG1lcmdlKCB7XHJcbiAgICAgIHRvcDogY29udHJvbFBhbmVsLmJvdHRvbSArIDgsXHJcbiAgICAgIHJpZ2h0OiB0aGlzLmxheW91dEJvdW5kcy5tYXhYIC0gTm9ybWFsTW9kZXNDb25zdGFudHMuU0NSRUVOX1ZJRVdfWF9NQVJHSU4gLSByZXNldEFsbEJ1dHRvbi53aWR0aCAtIDEwXHJcbiAgICB9LCBOb3JtYWxNb2Rlc0NvbG9ycy5QQU5FTF9DT0xPUlMgKSApO1xyXG5cclxuICAgIGNvbnN0IHNjcmVlblZpZXdSb290Tm9kZSA9IG5ldyBOb2RlKCB7XHJcbiAgICAgIGNoaWxkcmVuOiBbXHJcbiAgICAgICAgY29udHJvbFBhbmVsLFxyXG4gICAgICAgIG5vcm1hbE1vZGVzQWNjb3JkaW9uQm94LFxyXG4gICAgICAgIG5vcm1hbE1vZGVTcGVjdHJ1bUFjY29yZGlvbkJveCxcclxuICAgICAgICByZXNldEFsbEJ1dHRvbixcclxuICAgICAgICBzcHJpbmdOb2Rlc1BhcmVudCxcclxuICAgICAgICBsZWZ0V2FsbE5vZGUsXHJcbiAgICAgICAgcmlnaHRXYWxsTm9kZSxcclxuICAgICAgICBtYXNzTm9kZXNQYXJlbnRcclxuICAgICAgXVxyXG4gICAgfSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggc2NyZWVuVmlld1Jvb3ROb2RlICk7XHJcblxyXG4gICAgLy8gUmVuZGVyIHRoZSBkcmFnIGJvdW5kc1xyXG4gICAgaWYgKCBOb3JtYWxNb2Rlc1F1ZXJ5UGFyYW1ldGVycy5zaG93RHJhZ0JvdW5kczFEICkge1xyXG4gICAgICBjb25zb2xlLmxvZyggJ2RyYXdpbmcgZHJhZyBib3VuZHMnICk7XHJcbiAgICAgIHRoaXMuYWRkQ2hpbGQoIG5ldyBSZWN0YW5nbGUoIGRyYWdCb3VuZHNWaWV3LCB7XHJcbiAgICAgICAgc3Ryb2tlOiAncmVkJ1xyXG4gICAgICB9ICkgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXaGVuIHRoZSBudW1iZXIgb2YgbWFzc2VzIGlzIGNoYW5nZWQsIGludGVycnVwdCBhbnkgZHJhZ2dpbmcgdGhhdCBtYXkgYmUgaW4gcHJvZ3Jlc3MuXHJcbiAgICBtb2RlbC5udW1iZXJPZk1hc3Nlc1Byb3BlcnR5LmxpbmsoIG51bWJlck9mTWFzc2VzID0+IHtcclxuICAgICAgbWFzc05vZGVzUGFyZW50LmludGVycnVwdFN1YnRyZWVJbnB1dCgpO1xyXG4gICAgfSApO1xyXG5cclxuICAgIGNvbnN0IHJlc2V0VmlldyA9ICgpID0+IHtcclxuICAgICAgbm9ybWFsTW9kZVNwZWN0cnVtQWNjb3JkaW9uQm94LmV4cGFuZGVkUHJvcGVydHkucmVzZXQoKTtcclxuICAgICAgbm9ybWFsTW9kZXNBY2NvcmRpb25Cb3guZXhwYW5kZWRQcm9wZXJ0eS5yZXNldCgpO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbm5vcm1hbE1vZGVzLnJlZ2lzdGVyKCAnT25lRGltZW5zaW9uU2NyZWVuVmlldycsIE9uZURpbWVuc2lvblNjcmVlblZpZXcgKTtcclxuZXhwb3J0IGRlZmF1bHQgT25lRGltZW5zaW9uU2NyZWVuVmlldzsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsVUFBVSxNQUFNLG9DQUFvQztBQUMzRCxPQUFPQyxLQUFLLE1BQU0sbUNBQW1DO0FBQ3JELE9BQU9DLG1CQUFtQixNQUFNLHVEQUF1RDtBQUN2RixPQUFPQyxjQUFjLE1BQU0sdURBQXVEO0FBQ2xGLFNBQVNDLElBQUksRUFBRUMsU0FBUyxRQUFRLG1DQUFtQztBQUNuRSxPQUFPQyxNQUFNLE1BQU0saUNBQWlDO0FBQ3BELE9BQU9DLGlCQUFpQixNQUFNLG1DQUFtQztBQUNqRSxPQUFPQyxvQkFBb0IsTUFBTSxzQ0FBc0M7QUFDdkUsT0FBT0MsMEJBQTBCLE1BQU0sNENBQTRDO0FBQ25GLE9BQU9DLHVCQUF1QixNQUFNLDhDQUE4QztBQUNsRixPQUFPQyxVQUFVLE1BQU0saUNBQWlDO0FBQ3hELE9BQU9DLFdBQVcsTUFBTSxzQkFBc0I7QUFDOUMsT0FBT0MsVUFBVSxNQUFNLGlCQUFpQjtBQUN4QyxPQUFPQyx1QkFBdUIsTUFBTSw4QkFBOEI7QUFDbEUsT0FBT0MsOEJBQThCLE1BQU0scUNBQXFDO0FBQ2hGLE9BQU9DLFFBQVEsTUFBTSxlQUFlOztBQUVwQztBQUNBLE1BQU1DLGlCQUFpQixHQUFHLEdBQUcsQ0FBQyxDQUFDOztBQUUvQixNQUFNQyxzQkFBc0IsU0FBU2xCLFVBQVUsQ0FBQztFQUU5QztBQUNGO0FBQ0E7QUFDQTtFQUNFbUIsV0FBV0EsQ0FBRUMsS0FBSyxFQUFFQyxPQUFPLEVBQUc7SUFFNUJBLE9BQU8sR0FBR3BCLEtBQUssQ0FBRTtNQUNmcUIsTUFBTSxFQUFFaEIsTUFBTSxDQUFDaUI7SUFDakIsQ0FBQyxFQUFFRixPQUFRLENBQUM7SUFFWixLQUFLLENBQUVBLE9BQVEsQ0FBQzs7SUFFaEI7SUFDQTtJQUNBLE1BQU1HLFVBQVUsR0FBRyxJQUFJekIsT0FBTyxDQUM1QmtCLGlCQUFpQixHQUFHLENBQUMsR0FBR1Qsb0JBQW9CLENBQUNpQixvQkFBb0IsR0FBRyxDQUFDLEVBQ3JFLENBQUUsSUFBSSxDQUFDQyxZQUFZLENBQUNDLElBQUksR0FBRyxHQUFHLElBQUssQ0FDckMsQ0FBQztJQUVELE1BQU1DLGtCQUFrQixHQUFHMUIsbUJBQW1CLENBQUMyQixzQ0FBc0MsQ0FDbkY5QixPQUFPLENBQUMrQixJQUFJLEVBQUVOLFVBQVUsRUFBRVAsaUJBQWlCLEdBQUcsQ0FDaEQsQ0FBQztJQUVELE1BQU1jLGNBQWMsR0FBRyxJQUFJNUIsY0FBYyxDQUFFO01BQ3pDNkIsUUFBUSxFQUFFQSxDQUFBLEtBQU07UUFDZCxJQUFJLENBQUNDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlCYixLQUFLLENBQUNjLEtBQUssQ0FBQyxDQUFDO1FBQ2JDLFNBQVMsQ0FBQyxDQUFDO01BQ2IsQ0FBQztNQUNEQyxLQUFLLEVBQUUsSUFBSSxDQUFDVixZQUFZLENBQUNXLElBQUksR0FBRzdCLG9CQUFvQixDQUFDaUIsb0JBQW9CO01BQ3pFYSxNQUFNLEVBQUUsSUFBSSxDQUFDWixZQUFZLENBQUNDLElBQUksR0FBR25CLG9CQUFvQixDQUFDK0Isb0JBQW9CO01BQzFFakIsTUFBTSxFQUFFRCxPQUFPLENBQUNDLE1BQU0sQ0FBQ2tCLFlBQVksQ0FBRSxnQkFBaUI7SUFDeEQsQ0FBRSxDQUFDOztJQUVIO0lBQ0EsTUFBTUMsWUFBWSxHQUFHLElBQUkvQix1QkFBdUIsQ0FBRVUsS0FBSyxFQUFFbkIsS0FBSyxDQUFFO01BQzlEbUMsS0FBSyxFQUFFLElBQUksQ0FBQ1YsWUFBWSxDQUFDVyxJQUFJLEdBQUc3QixvQkFBb0IsQ0FBQ2lCLG9CQUFvQixHQUFHTSxjQUFjLENBQUNXLEtBQUssR0FBRyxFQUFFO01BQ3JHQyxHQUFHLEVBQUVuQyxvQkFBb0IsQ0FBQytCLG9CQUFvQjtNQUM5Q0ssWUFBWSxFQUFFLENBQUM7TUFDZkMsT0FBTyxFQUFFLENBQUM7TUFDVkMsT0FBTyxFQUFFO0lBQ1gsQ0FBQyxFQUFFdkMsaUJBQWlCLENBQUN3QyxZQUFhLENBQUUsQ0FBQzs7SUFFckM7SUFDQSxNQUFNQyw4QkFBOEIsR0FBRyxJQUFJakMsOEJBQThCLENBQUVLLEtBQUssRUFBRW5CLEtBQUssQ0FBRTtNQUN2RnFDLE1BQU0sRUFBRSxJQUFJLENBQUNaLFlBQVksQ0FBQ0MsSUFBSSxHQUFHbkIsb0JBQW9CLENBQUMrQixvQkFBb0I7TUFDMUVLLFlBQVksRUFBRSxDQUFDO01BQ2ZLLE9BQU8sRUFBRXpCLFVBQVUsQ0FBQzBCO0lBQ3RCLENBQUMsRUFBRTNDLGlCQUFpQixDQUFDd0MsWUFBYSxDQUFFLENBQUM7O0lBRXJDO0lBQ0EsTUFBTUksaUJBQWlCLEdBQUcsSUFBSS9DLElBQUksQ0FBRTtNQUNsQ2dELFFBQVEsRUFBRWhDLEtBQUssQ0FBQ2lDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFFQyxNQUFNLElBQUksSUFBSTVDLFVBQVUsQ0FDbkQ0QyxNQUFNLEVBQUUzQixrQkFBa0IsRUFBRVIsS0FBSyxDQUFDb0Msc0JBQXNCLEVBQUVuQyxPQUFPLENBQUNDLE1BQU0sQ0FBQ2tCLFlBQVksQ0FBRSxhQUFjLENBQ3ZHLENBQUU7SUFDSixDQUFFLENBQUM7O0lBRUg7SUFDQSxNQUFNaUIsWUFBWSxHQUFHLElBQUl6QyxRQUFRLENBQy9CSSxLQUFLLENBQUNzQyxNQUFNLENBQUUsQ0FBQyxDQUFFLEVBQUU5QixrQkFBa0IsRUFBRVAsT0FBTyxDQUFDQyxNQUFNLENBQUNrQixZQUFZLENBQUUsY0FBZSxDQUNyRixDQUFDO0lBQ0QsTUFBTW1CLGFBQWEsR0FBRyxJQUFJM0MsUUFBUSxDQUNoQ0ksS0FBSyxDQUFDc0MsTUFBTSxDQUFFdEMsS0FBSyxDQUFDc0MsTUFBTSxDQUFDRSxNQUFNLEdBQUcsQ0FBQyxDQUFFLEVBQUVoQyxrQkFBa0IsRUFBRVAsT0FBTyxDQUFDQyxNQUFNLENBQUNrQixZQUFZLENBQUUsZUFBZ0IsQ0FDNUcsQ0FBQzs7SUFFRDtJQUNBO0lBQ0EsTUFBTXFCLGNBQWMsR0FBRyxJQUFJL0QsT0FBTyxDQUNoQzJELFlBQVksQ0FBQ3JCLEtBQUssRUFDbEJxQixZQUFZLENBQUNLLE9BQU8sR0FBR3JELDBCQUEwQixDQUFDc0Qsa0JBQWtCLEdBQUcsQ0FBQyxFQUN4RUosYUFBYSxDQUFDSyxJQUFJLEVBQ2xCUCxZQUFZLENBQUNLLE9BQU8sR0FBR3JELDBCQUEwQixDQUFDc0Qsa0JBQWtCLEdBQUcsQ0FDekUsQ0FBQztJQUNELE1BQU1FLGVBQWUsR0FBR3JDLGtCQUFrQixDQUFDc0MsaUJBQWlCLENBQUVMLGNBQWUsQ0FBQzs7SUFFOUU7SUFDQSxNQUFNTSxlQUFlLEdBQUcsSUFBSS9ELElBQUksQ0FBRTtNQUNoQ2dELFFBQVEsRUFBRWhDLEtBQUssQ0FBQ3NDLE1BQU0sQ0FDbkJVLEtBQUssQ0FBRSxDQUFDLEVBQUVoRCxLQUFLLENBQUNzQyxNQUFNLENBQUNFLE1BQU0sR0FBRyxDQUFFLENBQUMsQ0FDbkNOLEdBQUcsQ0FBRWUsSUFBSSxJQUNSLElBQUl4RCxVQUFVLENBQUV3RCxJQUFJLEVBQUV6QyxrQkFBa0IsRUFBRVIsS0FBSyxFQUFFNkMsZUFBZSxFQUFFNUMsT0FBTyxDQUFDQyxNQUFNLENBQUNrQixZQUFZLENBQUUsV0FBWSxDQUFFLENBQUU7SUFDckgsQ0FBRSxDQUFDOztJQUVIO0lBQ0EsTUFBTThCLHVCQUF1QixHQUFHLElBQUl4RCx1QkFBdUIsQ0FBRU0sS0FBSyxFQUFFbkIsS0FBSyxDQUFFO01BQ3pFMEMsR0FBRyxFQUFFRixZQUFZLENBQUNILE1BQU0sR0FBRyxDQUFDO01BQzVCRixLQUFLLEVBQUUsSUFBSSxDQUFDVixZQUFZLENBQUNXLElBQUksR0FBRzdCLG9CQUFvQixDQUFDaUIsb0JBQW9CLEdBQUdNLGNBQWMsQ0FBQ1csS0FBSyxHQUFHO0lBQ3JHLENBQUMsRUFBRW5DLGlCQUFpQixDQUFDd0MsWUFBYSxDQUFFLENBQUM7SUFFckMsTUFBTXdCLGtCQUFrQixHQUFHLElBQUluRSxJQUFJLENBQUU7TUFDbkNnRCxRQUFRLEVBQUUsQ0FDUlgsWUFBWSxFQUNaNkIsdUJBQXVCLEVBQ3ZCdEIsOEJBQThCLEVBQzlCakIsY0FBYyxFQUNkb0IsaUJBQWlCLEVBQ2pCTSxZQUFZLEVBQ1pFLGFBQWEsRUFDYlEsZUFBZTtJQUVuQixDQUFFLENBQUM7SUFDSCxJQUFJLENBQUNLLFFBQVEsQ0FBRUQsa0JBQW1CLENBQUM7O0lBRW5DO0lBQ0EsSUFBSzlELDBCQUEwQixDQUFDZ0UsZ0JBQWdCLEVBQUc7TUFDakRDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFFLHFCQUFzQixDQUFDO01BQ3BDLElBQUksQ0FBQ0gsUUFBUSxDQUFFLElBQUluRSxTQUFTLENBQUV3RCxjQUFjLEVBQUU7UUFDNUNlLE1BQU0sRUFBRTtNQUNWLENBQUUsQ0FBRSxDQUFDO0lBQ1A7O0lBRUE7SUFDQXhELEtBQUssQ0FBQ3lELHNCQUFzQixDQUFDQyxJQUFJLENBQUVDLGNBQWMsSUFBSTtNQUNuRFosZUFBZSxDQUFDbEMscUJBQXFCLENBQUMsQ0FBQztJQUN6QyxDQUFFLENBQUM7SUFFSCxNQUFNRSxTQUFTLEdBQUdBLENBQUEsS0FBTTtNQUN0QmEsOEJBQThCLENBQUNnQyxnQkFBZ0IsQ0FBQzlDLEtBQUssQ0FBQyxDQUFDO01BQ3ZEb0MsdUJBQXVCLENBQUNVLGdCQUFnQixDQUFDOUMsS0FBSyxDQUFDLENBQUM7SUFDbEQsQ0FBQztFQUNIO0FBQ0Y7QUFFQXRCLFdBQVcsQ0FBQ3FFLFFBQVEsQ0FBRSx3QkFBd0IsRUFBRS9ELHNCQUF1QixDQUFDO0FBQ3hFLGVBQWVBLHNCQUFzQiJ9