// Copyright 2020-2023, University of Colorado Boulder

/**
 * PeriodClockNode is the tool for measuring a harmonic's period in the 'space & time' Domain. It looks like a clock,
 * with a portion of the clock face filled in with the harmonic's color.  The portion filled in represents the portion
 * of the harmonic's period that has elapsed.  The origin is at the center of the clock face.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import { Shape } from '../../../../kite/js/imports.js';
import merge from '../../../../phet-core/js/merge.js';
import AssertUtils from '../../../../phetcommon/js/AssertUtils.js';
import { Circle, Color, Node, Path, Rectangle, RichText } from '../../../../scenery/js/imports.js';
import FMWConstants from '../../common/FMWConstants.js';
import FMWSymbols from '../../common/FMWSymbols.js';
import Domain from '../../common/model/Domain.js';
import Harmonic from '../../common/model/Harmonic.js';
import fourierMakingWaves from '../../fourierMakingWaves.js';
import DiscreteModel from '../model/DiscreteModel.js';
import DiscreteMeasurementToolNode from './DiscreteMeasurementToolNode.js';

// Margins for the translucent background behind the label
const BACKGROUND_X_MARGIN = 2;
const BACKGROUND_Y_MARGIN = 2;
export default class PeriodClockNode extends DiscreteMeasurementToolNode {
  /**
   * @param {DiscreteModel} model
   * @param {Object} [options]
   */
  constructor(model, options) {
    assert && assert(model instanceof DiscreteModel);
    options = merge({
      // DiscreteMeasurementToolNode options
      debugName: 'periodClock'
    }, options);

    // Model properties that we'll be using.
    const tool = model.periodTool;
    const harmonics = model.fourierSeries.harmonics;
    const emphasizedHarmonics = model.harmonicsChart.emphasizedHarmonics;
    const tProperty = model.tProperty;
    const domainProperty = model.domainProperty;

    // The harmonic associated with this tool.
    const harmonicProperty = new DerivedProperty([tool.orderProperty], order => harmonics[order - 1]);
    const clockFaceNode = new ClockFaceNode(harmonicProperty, tProperty);
    const labelStringProperty = new DerivedProperty([FMWSymbols.TStringProperty, harmonicProperty], (T, harmonic) => `${T}<sub>${harmonic.order}</sub>`);
    const labelNode = new RichText(labelStringProperty, {
      font: FMWConstants.TOOL_LABEL_FONT,
      maxWidth: 50
    });

    // Translucent background for the label
    const backgroundNode = new Rectangle(0, 0, 1, 1, {
      fill: Color.grayColor(255, 0.75)
    });
    assert && assert(!options.children, 'PeriodClockNode sets children');
    options.children = [clockFaceNode, backgroundNode, labelNode];
    const relevantDomains = [Domain.SPACE_AND_TIME];
    super(tool, harmonicProperty, emphasizedHarmonics, domainProperty, relevantDomains, options);

    // Synchronize visibility of the clock face, so we can short-circuit updates while it's invisible.
    clockFaceNode.setVisibleProperty(this.visibleProperty);
    labelNode.boundsProperty.link(bounds => {
      // Center the label in the clock face.
      labelNode.left = clockFaceNode.right + BACKGROUND_X_MARGIN + 2;
      labelNode.centerY = clockFaceNode.centerY;

      // Resize the background to fit the label, and keep the label centered in the background.
      backgroundNode.setRect(0, 0, labelNode.width + 2 * BACKGROUND_X_MARGIN, labelNode.height + 2 * BACKGROUND_Y_MARGIN);
      backgroundNode.center = labelNode.center;
    });

    // Pointer areas
    this.localBoundsProperty.link(localBounds => {
      this.mouseArea = localBounds;
      this.touchArea = localBounds.dilated(5);
    });
  }
}

/**
 * ClockFaceNode displays a clock face, with a portion of the clock face filled in with a harmonic's color.
 * The portion filled in represents the portion of the harmonic's period that has elapsed.
 */
class ClockFaceNode extends Node {
  /**
   * @param {ReadOnlyProperty.<Harmonic>} harmonicProperty
   * @param {Property.<number>} tProperty
   * @param {Object} [options]
   */
  constructor(harmonicProperty, tProperty, options) {
    assert && AssertUtils.assertAbstractPropertyOf(harmonicProperty, Harmonic);
    assert && AssertUtils.assertPropertyOf(tProperty, 'number');
    options = merge({
      radius: 15
    }, options);

    // White background circle
    const backgroundNode = new Circle(options.radius, {
      fill: 'white'
    });

    // Partial circle filled with the harmonic's color
    const elapsedTimeNode = new Path(null, {
      fill: harmonicProperty.value.colorProperty,
      stroke: 'black',
      lineWidth: 0.5
    });

    // Black rim in the foreground, to hide any seams
    const rimNode = new Circle(options.radius, {
      stroke: 'black',
      lineWidth: 2
    });
    assert && assert(!options.children, 'ClockFaceNode sets children');
    options.children = [backgroundNode, elapsedTimeNode, rimNode];
    super(options);

    // When the harmonic changes, update the color used to fill in the elapsed time, and
    // update the elapsed time to correspond to the new harmonic's period at the current time t.
    harmonicProperty.link(harmonic => {
      elapsedTimeNode.fill = harmonic.colorProperty;
      if (this.visible) {
        elapsedTimeNode.shape = createElapsedTimeShape(harmonic, tProperty.value, options.radius);
      }
    });

    // When the time changes while the tool is visible, update the elapsed time to correspond to the harmonic's period
    // at the current time t.
    tProperty.link(t => {
      if (this.visible) {
        elapsedTimeNode.shape = createElapsedTimeShape(harmonicProperty.value, t, options.radius);
      }
    });
  }

  /**
   * @public
   * @override
   */
  dispose() {
    assert && assert(false, 'dispose is not supported, exists for the lifetime of the sim');
    super.dispose();
  }
}

/**
 * Creates a partially filled clock face, which represents the portion of a harmonic's period that has elapsed.
 * @param {Harmonic} harmonic
 * @param {number} t
 * @param {number} radius
 * @returns {Shape}
 */
function createElapsedTimeShape(harmonic, t, radius) {
  assert && assert(harmonic instanceof Harmonic);
  assert && AssertUtils.assertNonNegativeNumber(t);
  assert && AssertUtils.assertPositiveNumber(radius);
  const percentTime = t % harmonic.period / harmonic.period;
  const startAngle = -Math.PI / 2; // 12:00
  const endAngle = startAngle + percentTime * 2 * Math.PI;
  return new Shape().moveTo(0, 0).arc(0, 0, radius, startAngle, endAngle).close();
}
fourierMakingWaves.register('PeriodClockNode', PeriodClockNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEZXJpdmVkUHJvcGVydHkiLCJTaGFwZSIsIm1lcmdlIiwiQXNzZXJ0VXRpbHMiLCJDaXJjbGUiLCJDb2xvciIsIk5vZGUiLCJQYXRoIiwiUmVjdGFuZ2xlIiwiUmljaFRleHQiLCJGTVdDb25zdGFudHMiLCJGTVdTeW1ib2xzIiwiRG9tYWluIiwiSGFybW9uaWMiLCJmb3VyaWVyTWFraW5nV2F2ZXMiLCJEaXNjcmV0ZU1vZGVsIiwiRGlzY3JldGVNZWFzdXJlbWVudFRvb2xOb2RlIiwiQkFDS0dST1VORF9YX01BUkdJTiIsIkJBQ0tHUk9VTkRfWV9NQVJHSU4iLCJQZXJpb2RDbG9ja05vZGUiLCJjb25zdHJ1Y3RvciIsIm1vZGVsIiwib3B0aW9ucyIsImFzc2VydCIsImRlYnVnTmFtZSIsInRvb2wiLCJwZXJpb2RUb29sIiwiaGFybW9uaWNzIiwiZm91cmllclNlcmllcyIsImVtcGhhc2l6ZWRIYXJtb25pY3MiLCJoYXJtb25pY3NDaGFydCIsInRQcm9wZXJ0eSIsImRvbWFpblByb3BlcnR5IiwiaGFybW9uaWNQcm9wZXJ0eSIsIm9yZGVyUHJvcGVydHkiLCJvcmRlciIsImNsb2NrRmFjZU5vZGUiLCJDbG9ja0ZhY2VOb2RlIiwibGFiZWxTdHJpbmdQcm9wZXJ0eSIsIlRTdHJpbmdQcm9wZXJ0eSIsIlQiLCJoYXJtb25pYyIsImxhYmVsTm9kZSIsImZvbnQiLCJUT09MX0xBQkVMX0ZPTlQiLCJtYXhXaWR0aCIsImJhY2tncm91bmROb2RlIiwiZmlsbCIsImdyYXlDb2xvciIsImNoaWxkcmVuIiwicmVsZXZhbnREb21haW5zIiwiU1BBQ0VfQU5EX1RJTUUiLCJzZXRWaXNpYmxlUHJvcGVydHkiLCJ2aXNpYmxlUHJvcGVydHkiLCJib3VuZHNQcm9wZXJ0eSIsImxpbmsiLCJib3VuZHMiLCJsZWZ0IiwicmlnaHQiLCJjZW50ZXJZIiwic2V0UmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiY2VudGVyIiwibG9jYWxCb3VuZHNQcm9wZXJ0eSIsImxvY2FsQm91bmRzIiwibW91c2VBcmVhIiwidG91Y2hBcmVhIiwiZGlsYXRlZCIsImFzc2VydEFic3RyYWN0UHJvcGVydHlPZiIsImFzc2VydFByb3BlcnR5T2YiLCJyYWRpdXMiLCJlbGFwc2VkVGltZU5vZGUiLCJ2YWx1ZSIsImNvbG9yUHJvcGVydHkiLCJzdHJva2UiLCJsaW5lV2lkdGgiLCJyaW1Ob2RlIiwidmlzaWJsZSIsInNoYXBlIiwiY3JlYXRlRWxhcHNlZFRpbWVTaGFwZSIsInQiLCJkaXNwb3NlIiwiYXNzZXJ0Tm9uTmVnYXRpdmVOdW1iZXIiLCJhc3NlcnRQb3NpdGl2ZU51bWJlciIsInBlcmNlbnRUaW1lIiwicGVyaW9kIiwic3RhcnRBbmdsZSIsIk1hdGgiLCJQSSIsImVuZEFuZ2xlIiwibW92ZVRvIiwiYXJjIiwiY2xvc2UiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlBlcmlvZENsb2NrTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMC0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBQZXJpb2RDbG9ja05vZGUgaXMgdGhlIHRvb2wgZm9yIG1lYXN1cmluZyBhIGhhcm1vbmljJ3MgcGVyaW9kIGluIHRoZSAnc3BhY2UgJiB0aW1lJyBEb21haW4uIEl0IGxvb2tzIGxpa2UgYSBjbG9jayxcclxuICogd2l0aCBhIHBvcnRpb24gb2YgdGhlIGNsb2NrIGZhY2UgZmlsbGVkIGluIHdpdGggdGhlIGhhcm1vbmljJ3MgY29sb3IuICBUaGUgcG9ydGlvbiBmaWxsZWQgaW4gcmVwcmVzZW50cyB0aGUgcG9ydGlvblxyXG4gKiBvZiB0aGUgaGFybW9uaWMncyBwZXJpb2QgdGhhdCBoYXMgZWxhcHNlZC4gIFRoZSBvcmlnaW4gaXMgYXQgdGhlIGNlbnRlciBvZiB0aGUgY2xvY2sgZmFjZS5cclxuICpcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgRGVyaXZlZFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvRGVyaXZlZFByb3BlcnR5LmpzJztcclxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi8uLi8uLi8uLi9raXRlL2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lcmdlLmpzJztcclxuaW1wb3J0IEFzc2VydFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL3BoZXRjb21tb24vanMvQXNzZXJ0VXRpbHMuanMnO1xyXG5pbXBvcnQgeyBDaXJjbGUsIENvbG9yLCBOb2RlLCBQYXRoLCBSZWN0YW5nbGUsIFJpY2hUZXh0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IEZNV0NvbnN0YW50cyBmcm9tICcuLi8uLi9jb21tb24vRk1XQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IEZNV1N5bWJvbHMgZnJvbSAnLi4vLi4vY29tbW9uL0ZNV1N5bWJvbHMuanMnO1xyXG5pbXBvcnQgRG9tYWluIGZyb20gJy4uLy4uL2NvbW1vbi9tb2RlbC9Eb21haW4uanMnO1xyXG5pbXBvcnQgSGFybW9uaWMgZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL0hhcm1vbmljLmpzJztcclxuaW1wb3J0IGZvdXJpZXJNYWtpbmdXYXZlcyBmcm9tICcuLi8uLi9mb3VyaWVyTWFraW5nV2F2ZXMuanMnO1xyXG5pbXBvcnQgRGlzY3JldGVNb2RlbCBmcm9tICcuLi9tb2RlbC9EaXNjcmV0ZU1vZGVsLmpzJztcclxuaW1wb3J0IERpc2NyZXRlTWVhc3VyZW1lbnRUb29sTm9kZSBmcm9tICcuL0Rpc2NyZXRlTWVhc3VyZW1lbnRUb29sTm9kZS5qcyc7XHJcblxyXG4vLyBNYXJnaW5zIGZvciB0aGUgdHJhbnNsdWNlbnQgYmFja2dyb3VuZCBiZWhpbmQgdGhlIGxhYmVsXHJcbmNvbnN0IEJBQ0tHUk9VTkRfWF9NQVJHSU4gPSAyO1xyXG5jb25zdCBCQUNLR1JPVU5EX1lfTUFSR0lOID0gMjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBlcmlvZENsb2NrTm9kZSBleHRlbmRzIERpc2NyZXRlTWVhc3VyZW1lbnRUb29sTm9kZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7RGlzY3JldGVNb2RlbH0gbW9kZWxcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIG1vZGVsLCBvcHRpb25zICkge1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG1vZGVsIGluc3RhbmNlb2YgRGlzY3JldGVNb2RlbCApO1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG5cclxuICAgICAgLy8gRGlzY3JldGVNZWFzdXJlbWVudFRvb2xOb2RlIG9wdGlvbnNcclxuICAgICAgZGVidWdOYW1lOiAncGVyaW9kQ2xvY2snXHJcbiAgICB9LCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gTW9kZWwgcHJvcGVydGllcyB0aGF0IHdlJ2xsIGJlIHVzaW5nLlxyXG4gICAgY29uc3QgdG9vbCA9IG1vZGVsLnBlcmlvZFRvb2w7XHJcbiAgICBjb25zdCBoYXJtb25pY3MgPSBtb2RlbC5mb3VyaWVyU2VyaWVzLmhhcm1vbmljcztcclxuICAgIGNvbnN0IGVtcGhhc2l6ZWRIYXJtb25pY3MgPSBtb2RlbC5oYXJtb25pY3NDaGFydC5lbXBoYXNpemVkSGFybW9uaWNzO1xyXG4gICAgY29uc3QgdFByb3BlcnR5ID0gbW9kZWwudFByb3BlcnR5O1xyXG4gICAgY29uc3QgZG9tYWluUHJvcGVydHkgPSBtb2RlbC5kb21haW5Qcm9wZXJ0eTtcclxuXHJcbiAgICAvLyBUaGUgaGFybW9uaWMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdG9vbC5cclxuICAgIGNvbnN0IGhhcm1vbmljUHJvcGVydHkgPSBuZXcgRGVyaXZlZFByb3BlcnR5KCBbIHRvb2wub3JkZXJQcm9wZXJ0eSBdLCBvcmRlciA9PiBoYXJtb25pY3NbIG9yZGVyIC0gMSBdICk7XHJcblxyXG4gICAgY29uc3QgY2xvY2tGYWNlTm9kZSA9IG5ldyBDbG9ja0ZhY2VOb2RlKCBoYXJtb25pY1Byb3BlcnR5LCB0UHJvcGVydHkgKTtcclxuXHJcbiAgICBjb25zdCBsYWJlbFN0cmluZ1Byb3BlcnR5ID0gbmV3IERlcml2ZWRQcm9wZXJ0eSggWyBGTVdTeW1ib2xzLlRTdHJpbmdQcm9wZXJ0eSwgaGFybW9uaWNQcm9wZXJ0eSBdLFxyXG4gICAgICAoIFQsIGhhcm1vbmljICkgPT4gYCR7VH08c3ViPiR7aGFybW9uaWMub3JkZXJ9PC9zdWI+YCApO1xyXG5cclxuICAgIGNvbnN0IGxhYmVsTm9kZSA9IG5ldyBSaWNoVGV4dCggbGFiZWxTdHJpbmdQcm9wZXJ0eSwge1xyXG4gICAgICBmb250OiBGTVdDb25zdGFudHMuVE9PTF9MQUJFTF9GT05ULFxyXG4gICAgICBtYXhXaWR0aDogNTBcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBUcmFuc2x1Y2VudCBiYWNrZ3JvdW5kIGZvciB0aGUgbGFiZWxcclxuICAgIGNvbnN0IGJhY2tncm91bmROb2RlID0gbmV3IFJlY3RhbmdsZSggMCwgMCwgMSwgMSwge1xyXG4gICAgICBmaWxsOiBDb2xvci5ncmF5Q29sb3IoIDI1NSwgMC43NSApXHJcbiAgICB9ICk7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIW9wdGlvbnMuY2hpbGRyZW4sICdQZXJpb2RDbG9ja05vZGUgc2V0cyBjaGlsZHJlbicgKTtcclxuICAgIG9wdGlvbnMuY2hpbGRyZW4gPSBbIGNsb2NrRmFjZU5vZGUsIGJhY2tncm91bmROb2RlLCBsYWJlbE5vZGUgXTtcclxuXHJcbiAgICBjb25zdCByZWxldmFudERvbWFpbnMgPSBbIERvbWFpbi5TUEFDRV9BTkRfVElNRSBdO1xyXG5cclxuICAgIHN1cGVyKCB0b29sLCBoYXJtb25pY1Byb3BlcnR5LCBlbXBoYXNpemVkSGFybW9uaWNzLCBkb21haW5Qcm9wZXJ0eSwgcmVsZXZhbnREb21haW5zLCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gU3luY2hyb25pemUgdmlzaWJpbGl0eSBvZiB0aGUgY2xvY2sgZmFjZSwgc28gd2UgY2FuIHNob3J0LWNpcmN1aXQgdXBkYXRlcyB3aGlsZSBpdCdzIGludmlzaWJsZS5cclxuICAgIGNsb2NrRmFjZU5vZGUuc2V0VmlzaWJsZVByb3BlcnR5KCB0aGlzLnZpc2libGVQcm9wZXJ0eSApO1xyXG5cclxuICAgIGxhYmVsTm9kZS5ib3VuZHNQcm9wZXJ0eS5saW5rKCBib3VuZHMgPT4ge1xyXG5cclxuICAgICAgLy8gQ2VudGVyIHRoZSBsYWJlbCBpbiB0aGUgY2xvY2sgZmFjZS5cclxuICAgICAgbGFiZWxOb2RlLmxlZnQgPSBjbG9ja0ZhY2VOb2RlLnJpZ2h0ICsgQkFDS0dST1VORF9YX01BUkdJTiArIDI7XHJcbiAgICAgIGxhYmVsTm9kZS5jZW50ZXJZID0gY2xvY2tGYWNlTm9kZS5jZW50ZXJZO1xyXG5cclxuICAgICAgLy8gUmVzaXplIHRoZSBiYWNrZ3JvdW5kIHRvIGZpdCB0aGUgbGFiZWwsIGFuZCBrZWVwIHRoZSBsYWJlbCBjZW50ZXJlZCBpbiB0aGUgYmFja2dyb3VuZC5cclxuICAgICAgYmFja2dyb3VuZE5vZGUuc2V0UmVjdCggMCwgMCwgbGFiZWxOb2RlLndpZHRoICsgMiAqIEJBQ0tHUk9VTkRfWF9NQVJHSU4sIGxhYmVsTm9kZS5oZWlnaHQgKyAyICogQkFDS0dST1VORF9ZX01BUkdJTiApO1xyXG4gICAgICBiYWNrZ3JvdW5kTm9kZS5jZW50ZXIgPSBsYWJlbE5vZGUuY2VudGVyO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFBvaW50ZXIgYXJlYXNcclxuICAgIHRoaXMubG9jYWxCb3VuZHNQcm9wZXJ0eS5saW5rKCBsb2NhbEJvdW5kcyA9PiB7XHJcbiAgICAgIHRoaXMubW91c2VBcmVhID0gbG9jYWxCb3VuZHM7XHJcbiAgICAgIHRoaXMudG91Y2hBcmVhID0gbG9jYWxCb3VuZHMuZGlsYXRlZCggNSApO1xyXG4gICAgfSApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsb2NrRmFjZU5vZGUgZGlzcGxheXMgYSBjbG9jayBmYWNlLCB3aXRoIGEgcG9ydGlvbiBvZiB0aGUgY2xvY2sgZmFjZSBmaWxsZWQgaW4gd2l0aCBhIGhhcm1vbmljJ3MgY29sb3IuXHJcbiAqIFRoZSBwb3J0aW9uIGZpbGxlZCBpbiByZXByZXNlbnRzIHRoZSBwb3J0aW9uIG9mIHRoZSBoYXJtb25pYydzIHBlcmlvZCB0aGF0IGhhcyBlbGFwc2VkLlxyXG4gKi9cclxuY2xhc3MgQ2xvY2tGYWNlTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1JlYWRPbmx5UHJvcGVydHkuPEhhcm1vbmljPn0gaGFybW9uaWNQcm9wZXJ0eVxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHkuPG51bWJlcj59IHRQcm9wZXJ0eVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggaGFybW9uaWNQcm9wZXJ0eSwgdFByb3BlcnR5LCBvcHRpb25zICkge1xyXG5cclxuICAgIGFzc2VydCAmJiBBc3NlcnRVdGlscy5hc3NlcnRBYnN0cmFjdFByb3BlcnR5T2YoIGhhcm1vbmljUHJvcGVydHksIEhhcm1vbmljICk7XHJcbiAgICBhc3NlcnQgJiYgQXNzZXJ0VXRpbHMuYXNzZXJ0UHJvcGVydHlPZiggdFByb3BlcnR5LCAnbnVtYmVyJyApO1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG4gICAgICByYWRpdXM6IDE1XHJcbiAgICB9LCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gV2hpdGUgYmFja2dyb3VuZCBjaXJjbGVcclxuICAgIGNvbnN0IGJhY2tncm91bmROb2RlID0gbmV3IENpcmNsZSggb3B0aW9ucy5yYWRpdXMsIHtcclxuICAgICAgZmlsbDogJ3doaXRlJ1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFBhcnRpYWwgY2lyY2xlIGZpbGxlZCB3aXRoIHRoZSBoYXJtb25pYydzIGNvbG9yXHJcbiAgICBjb25zdCBlbGFwc2VkVGltZU5vZGUgPSBuZXcgUGF0aCggbnVsbCwge1xyXG4gICAgICBmaWxsOiBoYXJtb25pY1Byb3BlcnR5LnZhbHVlLmNvbG9yUHJvcGVydHksXHJcbiAgICAgIHN0cm9rZTogJ2JsYWNrJyxcclxuICAgICAgbGluZVdpZHRoOiAwLjVcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBCbGFjayByaW0gaW4gdGhlIGZvcmVncm91bmQsIHRvIGhpZGUgYW55IHNlYW1zXHJcbiAgICBjb25zdCByaW1Ob2RlID0gbmV3IENpcmNsZSggb3B0aW9ucy5yYWRpdXMsIHtcclxuICAgICAgc3Ryb2tlOiAnYmxhY2snLFxyXG4gICAgICBsaW5lV2lkdGg6IDJcclxuICAgIH0gKTtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhb3B0aW9ucy5jaGlsZHJlbiwgJ0Nsb2NrRmFjZU5vZGUgc2V0cyBjaGlsZHJlbicgKTtcclxuICAgIG9wdGlvbnMuY2hpbGRyZW4gPSBbIGJhY2tncm91bmROb2RlLCBlbGFwc2VkVGltZU5vZGUsIHJpbU5vZGUgXTtcclxuXHJcbiAgICBzdXBlciggb3B0aW9ucyApO1xyXG5cclxuICAgIC8vIFdoZW4gdGhlIGhhcm1vbmljIGNoYW5nZXMsIHVwZGF0ZSB0aGUgY29sb3IgdXNlZCB0byBmaWxsIGluIHRoZSBlbGFwc2VkIHRpbWUsIGFuZFxyXG4gICAgLy8gdXBkYXRlIHRoZSBlbGFwc2VkIHRpbWUgdG8gY29ycmVzcG9uZCB0byB0aGUgbmV3IGhhcm1vbmljJ3MgcGVyaW9kIGF0IHRoZSBjdXJyZW50IHRpbWUgdC5cclxuICAgIGhhcm1vbmljUHJvcGVydHkubGluayggaGFybW9uaWMgPT4ge1xyXG4gICAgICBlbGFwc2VkVGltZU5vZGUuZmlsbCA9IGhhcm1vbmljLmNvbG9yUHJvcGVydHk7XHJcbiAgICAgIGlmICggdGhpcy52aXNpYmxlICkge1xyXG4gICAgICAgIGVsYXBzZWRUaW1lTm9kZS5zaGFwZSA9IGNyZWF0ZUVsYXBzZWRUaW1lU2hhcGUoIGhhcm1vbmljLCB0UHJvcGVydHkudmFsdWUsIG9wdGlvbnMucmFkaXVzICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBXaGVuIHRoZSB0aW1lIGNoYW5nZXMgd2hpbGUgdGhlIHRvb2wgaXMgdmlzaWJsZSwgdXBkYXRlIHRoZSBlbGFwc2VkIHRpbWUgdG8gY29ycmVzcG9uZCB0byB0aGUgaGFybW9uaWMncyBwZXJpb2RcclxuICAgIC8vIGF0IHRoZSBjdXJyZW50IHRpbWUgdC5cclxuICAgIHRQcm9wZXJ0eS5saW5rKCB0ID0+IHtcclxuICAgICAgaWYgKCB0aGlzLnZpc2libGUgKSB7XHJcbiAgICAgICAgZWxhcHNlZFRpbWVOb2RlLnNoYXBlID0gY3JlYXRlRWxhcHNlZFRpbWVTaGFwZSggaGFybW9uaWNQcm9wZXJ0eS52YWx1ZSwgdCwgb3B0aW9ucy5yYWRpdXMgKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ2Rpc3Bvc2UgaXMgbm90IHN1cHBvcnRlZCwgZXhpc3RzIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbScgKTtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgcGFydGlhbGx5IGZpbGxlZCBjbG9jayBmYWNlLCB3aGljaCByZXByZXNlbnRzIHRoZSBwb3J0aW9uIG9mIGEgaGFybW9uaWMncyBwZXJpb2QgdGhhdCBoYXMgZWxhcHNlZC5cclxuICogQHBhcmFtIHtIYXJtb25pY30gaGFybW9uaWNcclxuICogQHBhcmFtIHtudW1iZXJ9IHRcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xyXG4gKiBAcmV0dXJucyB7U2hhcGV9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVFbGFwc2VkVGltZVNoYXBlKCBoYXJtb25pYywgdCwgcmFkaXVzICkge1xyXG5cclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBoYXJtb25pYyBpbnN0YW5jZW9mIEhhcm1vbmljICk7XHJcbiAgYXNzZXJ0ICYmIEFzc2VydFV0aWxzLmFzc2VydE5vbk5lZ2F0aXZlTnVtYmVyKCB0ICk7XHJcbiAgYXNzZXJ0ICYmIEFzc2VydFV0aWxzLmFzc2VydFBvc2l0aXZlTnVtYmVyKCByYWRpdXMgKTtcclxuXHJcbiAgY29uc3QgcGVyY2VudFRpbWUgPSAoIHQgJSBoYXJtb25pYy5wZXJpb2QgKSAvIGhhcm1vbmljLnBlcmlvZDtcclxuICBjb25zdCBzdGFydEFuZ2xlID0gLU1hdGguUEkgLyAyOyAvLyAxMjowMFxyXG4gIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArICggcGVyY2VudFRpbWUgKiAyICogTWF0aC5QSSApO1xyXG4gIHJldHVybiBuZXcgU2hhcGUoKVxyXG4gICAgLm1vdmVUbyggMCwgMCApXHJcbiAgICAuYXJjKCAwLCAwLCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIClcclxuICAgIC5jbG9zZSgpO1xyXG59XHJcblxyXG5mb3VyaWVyTWFraW5nV2F2ZXMucmVnaXN0ZXIoICdQZXJpb2RDbG9ja05vZGUnLCBQZXJpb2RDbG9ja05vZGUgKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGVBQWUsTUFBTSx3Q0FBd0M7QUFDcEUsU0FBU0MsS0FBSyxRQUFRLGdDQUFnQztBQUN0RCxPQUFPQyxLQUFLLE1BQU0sbUNBQW1DO0FBQ3JELE9BQU9DLFdBQVcsTUFBTSwwQ0FBMEM7QUFDbEUsU0FBU0MsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLFFBQVEsUUFBUSxtQ0FBbUM7QUFDbEcsT0FBT0MsWUFBWSxNQUFNLDhCQUE4QjtBQUN2RCxPQUFPQyxVQUFVLE1BQU0s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