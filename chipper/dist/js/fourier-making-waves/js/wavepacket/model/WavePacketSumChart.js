// Copyright 2021-2023, University of Colorado Boulder

/**
 * WavePacketSumChart is the model for the 'Sum' chart in the 'Wave Packet' screen.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import Vector2Property from '../../../../dot/js/Vector2Property.js';
import FMWConstants from '../../common/FMWConstants.js';
import DomainChart from '../../common/model/DomainChart.js';
import SeriesType from '../../common/model/SeriesType.js';
import fourierMakingWaves from '../../fourierMakingWaves.js';
import WavePacketAxisDescriptions from './WavePacketAxisDescriptions.js';
import WavePacketComponentsChart from './WavePacketComponentsChart.js';
// constants
const EMPTY_DATA_SET = FMWConstants.EMPTY_DATA_SET;
export default class WavePacketSumChart extends DomainChart {
  // whether the envelope of the sum waveform is visible

  // Data set for the sum. One of these dependencies will be EMPTY_DATA_SET and the other will contain points,
  // depending on whether the number of Fourier components is finite or infinite.
  // Data set for the waveform envelope. One of these dependencies will be EMPTY_DATA_SET and the other will
  // contain points, depending on whether the number of Fourier components is finite or infinite.
  // Width displayed by the width indicator. This is loosely based on the getModelWidth method in WavePacketXWidthPlot.java.
  // Position of the width indicator. This is effectively a constant, see below.
  constructor(componentDataSetsProperty, wavePacket, domainProperty, seriesTypeProperty, xAxisDescriptionProperty, widthIndicatorsVisibleProperty, tandem) {
    super(domainProperty, xAxisDescriptionProperty, wavePacket.L, wavePacket.T, tandem);
    this.widthIndicatorsVisibleProperty = widthIndicatorsVisibleProperty;
    this.yAxisDescription = WavePacketAxisDescriptions.SUM_Y_AXIS_DESCRIPTION;
    this.waveformEnvelopeVisibleProperty = new BooleanProperty(true, {
      tandem: tandem.createTandem('waveformEnvelopeVisibleProperty')
    });

    // Data set for the sum of a finite number of components, EMPTY_DATA_SET when the number of components is infinite.
    // This simply takes the data sets for components, and sums the y values (amplitudes) of corresponding x values.
    // Points are ordered by increasing x value.
    const finiteSumDataSetProperty = new DerivedProperty([componentDataSetsProperty], componentDataSets => {
      let dataSet = EMPTY_DATA_SET;
      if (componentDataSets.length > 0) {
        dataSet = createSumDataSet(componentDataSets);
      }
      return dataSet;
    });

    // Data set for the sum of an infinite number of components, EMPTY_DATA_SET when the number of components is finite.
    // Points are ordered by increasing x value.
    const infiniteSumDataSetProperty = new DerivedProperty([wavePacket.componentSpacingProperty, wavePacket.centerProperty, wavePacket.conjugateStandardDeviationProperty, seriesTypeProperty, xAxisDescriptionProperty], (componentSpacing, center, conjugateStandardDeviation, seriesType, xAxisDescription) => {
      let dataSet = EMPTY_DATA_SET;
      if (componentSpacing === 0) {
        dataSet = createWavePacketDataSet(center, conjugateStandardDeviation, seriesType, xAxisDescription.range);
      }
      return dataSet;
    });
    this.sumDataSetProperty = new DerivedProperty([finiteSumDataSetProperty, infiniteSumDataSetProperty], (finiteDataSet, infiniteDataSet) => wavePacket.getNumberOfComponents() === Infinity ? infiniteDataSet : finiteDataSet);

    // {DerivedProperty.<Vector2[]>} Data set for the waveform envelope of a wave packet with infinite
    // components, EMPTY_DATA_SET when the number of components is finite or the envelope is not visible.
    // This is computed using 2 wave packet waveforms USING THE FOURIER COMPONENTS - one for sine, one for cosine -
    // then combining y values. Points are ordered by increasing x value.
    // This is based on the updateEnvelope method in D2CSumView.js.
    const finiteWaveformEnvelopeDataSetProperty = new DerivedProperty([this.waveformEnvelopeVisibleProperty, finiteSumDataSetProperty], (waveformEnvelopeVisible, finiteSumDataSet) => {
      let dataSet = EMPTY_DATA_SET;
      if (waveformEnvelopeVisible && finiteSumDataSet.length > 0) {
        // We'll be using finiteSumDataSet as one of the data sets. It was computed for either a SeriesType,
        // either sine or cosine. Compute the other data set by creating component data sets using the other
        // SeriesType, then summing those data sets.
        const seriesType = seriesTypeProperty.value === SeriesType.SIN ? SeriesType.COS : SeriesType.SIN;
        const otherComponentDataSets = WavePacketComponentsChart.createComponentsDataSets(wavePacket.componentsProperty.value, wavePacket.componentSpacingProperty.value, domainProperty.value, seriesType, xAxisDescriptionProperty.value.range);
        const otherSumDataSet = createSumDataSet(otherComponentDataSets);

        // Combine the 2 data sets to create the envelope.
        dataSet = createEnvelopeDataSet(finiteSumDataSet, otherSumDataSet);
      }
      return dataSet;
    });

    // {DerivedProperty.<Vector2[]>} Data set for the waveform envelope of a wave packet with infinite
    // components, EMPTY_DATA_SET when the number of components is finite or the envelope is not visible.
    // This is computed using 2 wave packet waveforms - one for sine, one for cosine - then combining y values.
    // Points are ordered by increasing x value.
    const infiniteWaveformEnvelopeDataSetProperty = new DerivedProperty([this.waveformEnvelopeVisibleProperty, wavePacket.componentSpacingProperty, wavePacket.centerProperty, wavePacket.conjugateStandardDeviationProperty, seriesTypeProperty, xAxisDescriptionProperty], (waveformEnvelopeVisible, componentSpacing, center, conjugateStandardDeviation, seriesType, xAxisDescription) => {
      let dataSet = EMPTY_DATA_SET;
      if (waveformEnvelopeVisible && componentSpacing === 0) {
        // Compute data sets for the same wave packet, using sin and cos.
        const sinDataSet = createWavePacketDataSet(center, conjugateStandardDeviation, SeriesType.SIN, xAxisDescription.range);
        const cosDataSet = createWavePacketDataSet(center, conjugateStandardDeviation, SeriesType.COS, xAxisDescription.range);
        assert && assert(sinDataSet.length === cosDataSet.length);

        // Combine the 2 data sets to create the envelope.
        dataSet = createEnvelopeDataSet(sinDataSet, cosDataSet);
      }
      return dataSet;
    });
    this.waveformEnvelopeDataSetProperty = new DerivedProperty([finiteWaveformEnvelopeDataSetProperty, infiniteWaveformEnvelopeDataSetProperty], (finiteDataSet, infiniteDataSet) => wavePacket.getNumberOfComponents() === Infinity ? infiniteDataSet : finiteDataSet);
    this.widthIndicatorWidthProperty = new DerivedProperty([wavePacket.conjugateStandardDeviationProperty], conjugateStandardDeviation => 2 * conjugateStandardDeviation);

    // This is a constant, but the view requires a Property. We use validValues to constrain it to 1 value.
    // This is based on the getModelLocation method in WavePacketXWidthPlot.java.
    const widthIndicatorPosition = new Vector2(0, 1 / Math.sqrt(Math.E));
    this.widthIndicatorPositionProperty = new Vector2Property(widthIndicatorPosition, {
      validValues: [widthIndicatorPosition]
    });
  }
  reset() {
    super.reset();
    this.waveformEnvelopeVisibleProperty.reset();
  }
}

/**
 * Create a new data set by summing the y components of data sets. The provided data sets must have the same number
 * of points, and points with the same index must have the same x value.
 */
function createSumDataSet(dataSets) {
  assert && assert(dataSets.length > 0);
  const pointsPerDataSet = dataSets[0].length;
  assert && assert(pointsPerDataSet > 0, 'Data sets must contain points.');
  assert && assert(_.every(dataSets, dataSet => dataSet.length === pointsPerDataSet), 'All data sets much have the same number of points.');
  const dataSet = [];
  for (let i = 0; i < pointsPerDataSet; i++) {
    let sum = 0;
    const x = dataSets[0][i].x;
    for (let j = 0; j < dataSets.length; j++) {
      assert && assert(dataSets[j][i].x === x, 'Points with the same index must have the same x value.');
      sum += dataSets[j][i].y;
    }
    dataSet.push(new Vector2(x, sum));
  }
  return dataSet;
}

/**
 * Creates a data set for a wave packet approximated using an infinite number of Fourier components.
 * This is based on the updateDataSet method in GaussianWavePacketPlot.java.
 * @param center - the wave packet's center
 * @param conjugateStandardDeviation - the wave packet's conjugate standard deviation, a measure of width
 * @param seriesType - sine or cosine
 * @param xRange - range of the Sum chart's x-axis
 */
function createWavePacketDataSet(center, conjugateStandardDeviation, seriesType, xRange) {
  assert && assert(center > 0);
  assert && assert(conjugateStandardDeviation > 0);
  const dataSet = [];
  const numberOfPoints = FMWConstants.MAX_POINTS_PER_DATA_SET + 1;
  const dx = xRange.getLength() / numberOfPoints;
  for (let i = 0; i < numberOfPoints; i++) {
    // x
    const x = xRange.min + i * dx;

    // y = F(x) = exp( -(x^2) / (2 * (dx^2)) ) * sin(k0*x)
    const sinCosTerm = seriesType === SeriesType.SIN ? Math.sin(center * x) : Math.cos(center * x);
    const y = Math.exp(-(x * x) / (2 * (conjugateStandardDeviation * conjugateStandardDeviation))) * sinCosTerm;
    dataSet.push(new Vector2(x, y));
  }
  return dataSet;
}

/**
 * Creates the data set for the waveform envelope. The provided data sets must describe the same wave packet -
 * one computed using sine, the other computed using cosine. They must have the same number of points,
 * and points with the same index must have the same x value.
 * This is based on the updateEnvelope method in D2CSumView.js.
 */
function createEnvelopeDataSet(dataSet1, dataSet2) {
  assert && assert(dataSet1.length > 0);
  assert && assert(dataSet2.length > 0);
  assert && assert(dataSet1.length === dataSet2.length);
  const dataSet = [];
  for (let i = 0; i < dataSet1.length; i++) {
    // x
    const x = dataSet1[i].x;
    assert && assert(x === dataSet2[i].x, 'points with the same index must have the same x value');

    // y = sqrt( y1^2 + yCos^2 )
    const y1 = dataSet1[i].y;
    const y2 = dataSet2[i].y;
    const y = Math.sqrt(y1 * y1 + y2 * y2);
    dataSet.push(new Vector2(x, y));
  }
  return dataSet;
}
fourierMakingWaves.register('WavePacketSumChart', WavePacketSumChart);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJEZXJpdmVkUHJvcGVydHkiLCJWZWN0b3IyIiwiVmVjdG9yMlByb3BlcnR5IiwiRk1XQ29uc3RhbnRzIiwiRG9tYWluQ2hhcnQiLCJTZXJpZXNUeXBlIiwiZm91cmllck1ha2luZ1dhdmVzIiwiV2F2ZVBhY2tldEF4aXNEZXNjcmlwdGlvbnMiLCJXYXZlUGFja2V0Q29tcG9uZW50c0NoYXJ0IiwiRU1QVFlfREFUQV9TRVQiLCJXYXZlUGFja2V0U3VtQ2hhcnQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudERhdGFTZXRzUHJvcGVydHkiLCJ3YXZlUGFja2V0IiwiZG9tYWluUHJvcGVydHkiLCJzZXJpZXNUeXBlUHJvcGVydHkiLCJ4QXhpc0Rlc2NyaXB0aW9uUHJvcGVydHkiLCJ3aWR0aEluZGljYXRvcnNWaXNpYmxlUHJvcGVydHkiLCJ0YW5kZW0iLCJMIiwiVCIsInlBeGlzRGVzY3JpcHRpb24iLCJTVU1fWV9BWElTX0RFU0NSSVBUSU9OIiwid2F2ZWZvcm1FbnZlbG9wZVZpc2libGVQcm9wZXJ0eSIsImNyZWF0ZVRhbmRlbSIsImZpbml0ZVN1bURhdGFTZXRQcm9wZXJ0eSIsImNvbXBvbmVudERhdGFTZXRzIiwiZGF0YVNldCIsImxlbmd0aCIsImNyZWF0ZVN1bURhdGFTZXQiLCJpbmZpbml0ZVN1bURhdGFTZXRQcm9wZXJ0eSIsImNvbXBvbmVudFNwYWNpbmdQcm9wZXJ0eSIsImNlbnRlclByb3BlcnR5IiwiY29uanVnYXRlU3RhbmRhcmREZXZpYXRpb25Qcm9wZXJ0eSIsImNvbXBvbmVudFNwYWNpbmciLCJjZW50ZXIiLCJjb25qdWdhdGVTdGFuZGFyZERldmlhdGlvbiIsInNlcmllc1R5cGUiLCJ4QXhpc0Rlc2NyaXB0aW9uIiwiY3JlYXRlV2F2ZVBhY2tldERhdGFTZXQiLCJyYW5nZSIsInN1bURhdGFTZXRQcm9wZXJ0eSIsImZpbml0ZURhdGFTZXQiLCJpbmZpbml0ZURhdGFTZXQiLCJnZXROdW1iZXJPZkNvbXBvbmVudHMiLCJJbmZpbml0eSIsImZpbml0ZVdhdmVmb3JtRW52ZWxvcGVEYXRhU2V0UHJvcGVydHkiLCJ3YXZlZm9ybUVudmVsb3BlVmlzaWJsZSIsImZpbml0ZVN1bURhdGFTZXQiLCJ2YWx1ZSIsIlNJTiIsIkNPUyIsIm90aGVyQ29tcG9uZW50RGF0YVNldHMiLCJjcmVhdGVDb21wb25lbnRzRGF0YVNldHMiLCJjb21wb25lbnRzUHJvcGVydHkiLCJvdGhlclN1bURhdGFTZXQiLCJjcmVhdGVFbnZlbG9wZURhdGFTZXQiLCJpbmZpbml0ZVdhdmVmb3JtRW52ZWxvcGVEYXRhU2V0UHJvcGVydHkiLCJzaW5EYXRhU2V0IiwiY29zRGF0YVNldCIsImFzc2VydCIsIndhdmVmb3JtRW52ZWxvcGVEYXRhU2V0UHJvcGVydHkiLCJ3aWR0aEluZGljYXRvcldpZHRoUHJvcGVydHkiLCJ3aWR0aEluZGljYXRvclBvc2l0aW9uIiwiTWF0aCIsInNxcnQiLCJFIiwid2lkdGhJbmRpY2F0b3JQb3NpdGlvblByb3BlcnR5IiwidmFsaWRWYWx1ZXMiLCJyZXNldCIsImRhdGFTZXRzIiwicG9pbnRzUGVyRGF0YVNldCIsIl8iLCJldmVyeSIsImkiLCJzdW0iLCJ4IiwiaiIsInkiLCJwdXNoIiwieFJhbmdlIiwibnVtYmVyT2ZQb2ludHMiLCJNQVhfUE9JTlRTX1BFUl9EQVRBX1NFVCIsImR4IiwiZ2V0TGVuZ3RoIiwibWluIiwic2luQ29zVGVybSIsInNpbiIsImNvcyIsImV4cCIsImRhdGFTZXQxIiwiZGF0YVNldDIiLCJ5MSIsInkyIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJXYXZlUGFja2V0U3VtQ2hhcnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogV2F2ZVBhY2tldFN1bUNoYXJ0IGlzIHRoZSBtb2RlbCBmb3IgdGhlICdTdW0nIGNoYXJ0IGluIHRoZSAnV2F2ZSBQYWNrZXQnIHNjcmVlbi5cclxuICpcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgQm9vbGVhblByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvQm9vbGVhblByb3BlcnR5LmpzJztcclxuaW1wb3J0IERlcml2ZWRQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0Rlcml2ZWRQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBFbnVtZXJhdGlvblByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvRW51bWVyYXRpb25Qcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1JhbmdlLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgVmVjdG9yMlByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgVGFuZGVtIGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy9UYW5kZW0uanMnO1xyXG5pbXBvcnQgRk1XQ29uc3RhbnRzIGZyb20gJy4uLy4uL2NvbW1vbi9GTVdDb25zdGFudHMuanMnO1xyXG5pbXBvcnQgRG9tYWluQ2hhcnQgZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL0RvbWFpbkNoYXJ0LmpzJztcclxuaW1wb3J0IFNlcmllc1R5cGUgZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL1Nlcmllc1R5cGUuanMnO1xyXG5pbXBvcnQgZm91cmllck1ha2luZ1dhdmVzIGZyb20gJy4uLy4uL2ZvdXJpZXJNYWtpbmdXYXZlcy5qcyc7XHJcbmltcG9ydCBXYXZlUGFja2V0IGZyb20gJy4vV2F2ZVBhY2tldC5qcyc7XHJcbmltcG9ydCBXYXZlUGFja2V0QXhpc0Rlc2NyaXB0aW9ucyBmcm9tICcuL1dhdmVQYWNrZXRBeGlzRGVzY3JpcHRpb25zLmpzJztcclxuaW1wb3J0IFdhdmVQYWNrZXRDb21wb25lbnRzQ2hhcnQgZnJvbSAnLi9XYXZlUGFja2V0Q29tcG9uZW50c0NoYXJ0LmpzJztcclxuaW1wb3J0IERvbWFpbiBmcm9tICcuLi8uLi9jb21tb24vbW9kZWwvRG9tYWluLmpzJztcclxuaW1wb3J0IEF4aXNEZXNjcmlwdGlvbiBmcm9tICcuLi8uLi9jb21tb24vbW9kZWwvQXhpc0Rlc2NyaXB0aW9uLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBFTVBUWV9EQVRBX1NFVCA9IEZNV0NvbnN0YW50cy5FTVBUWV9EQVRBX1NFVDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhdmVQYWNrZXRTdW1DaGFydCBleHRlbmRzIERvbWFpbkNoYXJ0IHtcclxuXHJcbiAgcHVibGljIHJlYWRvbmx5IHdpZHRoSW5kaWNhdG9yc1Zpc2libGVQcm9wZXJ0eTogUHJvcGVydHk8Ym9vbGVhbj47XHJcbiAgcHVibGljIHJlYWRvbmx5IHlBeGlzRGVzY3JpcHRpb246IEF4aXNEZXNjcmlwdGlvbjtcclxuXHJcbiAgLy8gd2hldGhlciB0aGUgZW52ZWxvcGUgb2YgdGhlIHN1bSB3YXZlZm9ybSBpcyB2aXNpYmxlXHJcbiAgcHVibGljIHJlYWRvbmx5IHdhdmVmb3JtRW52ZWxvcGVWaXNpYmxlUHJvcGVydHk6IFByb3BlcnR5PGJvb2xlYW4+O1xyXG5cclxuICAvLyBEYXRhIHNldCBmb3IgdGhlIHN1bS4gT25lIG9mIHRoZXNlIGRlcGVuZGVuY2llcyB3aWxsIGJlIEVNUFRZX0RBVEFfU0VUIGFuZCB0aGUgb3RoZXIgd2lsbCBjb250YWluIHBvaW50cyxcclxuICAvLyBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbnVtYmVyIG9mIEZvdXJpZXIgY29tcG9uZW50cyBpcyBmaW5pdGUgb3IgaW5maW5pdGUuXHJcbiAgcHVibGljIHJlYWRvbmx5IHN1bURhdGFTZXRQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8VmVjdG9yMltdPjtcclxuXHJcbiAgLy8gRGF0YSBzZXQgZm9yIHRoZSB3YXZlZm9ybSBlbnZlbG9wZS4gT25lIG9mIHRoZXNlIGRlcGVuZGVuY2llcyB3aWxsIGJlIEVNUFRZX0RBVEFfU0VUIGFuZCB0aGUgb3RoZXIgd2lsbFxyXG4gIC8vIGNvbnRhaW4gcG9pbnRzLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbnVtYmVyIG9mIEZvdXJpZXIgY29tcG9uZW50cyBpcyBmaW5pdGUgb3IgaW5maW5pdGUuXHJcbiAgcHVibGljIHJlYWRvbmx5IHdhdmVmb3JtRW52ZWxvcGVEYXRhU2V0UHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PFZlY3RvcjJbXT47XHJcblxyXG4gIC8vIFdpZHRoIGRpc3BsYXllZCBieSB0aGUgd2lkdGggaW5kaWNhdG9yLiBUaGlzIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlIGdldE1vZGVsV2lkdGggbWV0aG9kIGluIFdhdmVQYWNrZXRYV2lkdGhQbG90LmphdmEuXHJcbiAgcHVibGljIHJlYWRvbmx5IHdpZHRoSW5kaWNhdG9yV2lkdGhQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8bnVtYmVyPjtcclxuXHJcbiAgLy8gUG9zaXRpb24gb2YgdGhlIHdpZHRoIGluZGljYXRvci4gVGhpcyBpcyBlZmZlY3RpdmVseSBhIGNvbnN0YW50LCBzZWUgYmVsb3cuXHJcbiAgcHVibGljIHJlYWRvbmx5IHdpZHRoSW5kaWNhdG9yUG9zaXRpb25Qcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8VmVjdG9yMj47XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggY29tcG9uZW50RGF0YVNldHNQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8VmVjdG9yMltdW10+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgd2F2ZVBhY2tldDogV2F2ZVBhY2tldCxcclxuICAgICAgICAgICAgICAgICAgICAgIGRvbWFpblByb3BlcnR5OiBFbnVtZXJhdGlvblByb3BlcnR5PERvbWFpbj4sXHJcbiAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNUeXBlUHJvcGVydHk6IEVudW1lcmF0aW9uUHJvcGVydHk8U2VyaWVzVHlwZT4sXHJcbiAgICAgICAgICAgICAgICAgICAgICB4QXhpc0Rlc2NyaXB0aW9uUHJvcGVydHk6IFByb3BlcnR5PEF4aXNEZXNjcmlwdGlvbj4sXHJcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aEluZGljYXRvcnNWaXNpYmxlUHJvcGVydHk6IFByb3BlcnR5PGJvb2xlYW4+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgdGFuZGVtOiBUYW5kZW0gKSB7XHJcblxyXG4gICAgc3VwZXIoIGRvbWFpblByb3BlcnR5LCB4QXhpc0Rlc2NyaXB0aW9uUHJvcGVydHksIHdhdmVQYWNrZXQuTCwgd2F2ZVBhY2tldC5ULCB0YW5kZW0gKTtcclxuXHJcbiAgICB0aGlzLndpZHRoSW5kaWNhdG9yc1Zpc2libGVQcm9wZXJ0eSA9IHdpZHRoSW5kaWNhdG9yc1Zpc2libGVQcm9wZXJ0eTtcclxuICAgIHRoaXMueUF4aXNEZXNjcmlwdGlvbiA9IFdhdmVQYWNrZXRBeGlzRGVzY3JpcHRpb25zLlNVTV9ZX0FYSVNfREVTQ1JJUFRJT047XHJcblxyXG4gICAgdGhpcy53YXZlZm9ybUVudmVsb3BlVmlzaWJsZVByb3BlcnR5ID0gbmV3IEJvb2xlYW5Qcm9wZXJ0eSggdHJ1ZSwge1xyXG4gICAgICB0YW5kZW06IHRhbmRlbS5jcmVhdGVUYW5kZW0oICd3YXZlZm9ybUVudmVsb3BlVmlzaWJsZVByb3BlcnR5JyApXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gRGF0YSBzZXQgZm9yIHRoZSBzdW0gb2YgYSBmaW5pdGUgbnVtYmVyIG9mIGNvbXBvbmVudHMsIEVNUFRZX0RBVEFfU0VUIHdoZW4gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGlzIGluZmluaXRlLlxyXG4gICAgLy8gVGhpcyBzaW1wbHkgdGFrZXMgdGhlIGRhdGEgc2V0cyBmb3IgY29tcG9uZW50cywgYW5kIHN1bXMgdGhlIHkgdmFsdWVzIChhbXBsaXR1ZGVzKSBvZiBjb3JyZXNwb25kaW5nIHggdmFsdWVzLlxyXG4gICAgLy8gUG9pbnRzIGFyZSBvcmRlcmVkIGJ5IGluY3JlYXNpbmcgeCB2YWx1ZS5cclxuICAgIGNvbnN0IGZpbml0ZVN1bURhdGFTZXRQcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoXHJcbiAgICAgIFsgY29tcG9uZW50RGF0YVNldHNQcm9wZXJ0eSBdLFxyXG4gICAgICBjb21wb25lbnREYXRhU2V0cyA9PiB7XHJcbiAgICAgICAgbGV0IGRhdGFTZXQ6IFZlY3RvcjJbXSA9IEVNUFRZX0RBVEFfU0VUO1xyXG4gICAgICAgIGlmICggY29tcG9uZW50RGF0YVNldHMubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgIGRhdGFTZXQgPSBjcmVhdGVTdW1EYXRhU2V0KCBjb21wb25lbnREYXRhU2V0cyApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YVNldDtcclxuICAgICAgfSApO1xyXG5cclxuICAgIC8vIERhdGEgc2V0IGZvciB0aGUgc3VtIG9mIGFuIGluZmluaXRlIG51bWJlciBvZiBjb21wb25lbnRzLCBFTVBUWV9EQVRBX1NFVCB3aGVuIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBpcyBmaW5pdGUuXHJcbiAgICAvLyBQb2ludHMgYXJlIG9yZGVyZWQgYnkgaW5jcmVhc2luZyB4IHZhbHVlLlxyXG4gICAgY29uc3QgaW5maW5pdGVTdW1EYXRhU2V0UHJvcGVydHkgPSBuZXcgRGVyaXZlZFByb3BlcnR5KFxyXG4gICAgICBbIHdhdmVQYWNrZXQuY29tcG9uZW50U3BhY2luZ1Byb3BlcnR5LCB3YXZlUGFja2V0LmNlbnRlclByb3BlcnR5LCB3YXZlUGFja2V0LmNvbmp1Z2F0ZVN0YW5kYXJkRGV2aWF0aW9uUHJvcGVydHksXHJcbiAgICAgICAgc2VyaWVzVHlwZVByb3BlcnR5LCB4QXhpc0Rlc2NyaXB0aW9uUHJvcGVydHkgXSxcclxuICAgICAgKCBjb21wb25lbnRTcGFjaW5nLCBjZW50ZXIsIGNvbmp1Z2F0ZVN0YW5kYXJkRGV2aWF0aW9uLCBzZXJpZXNUeXBlLCB4QXhpc0Rlc2NyaXB0aW9uICkgPT4ge1xyXG4gICAgICAgIGxldCBkYXRhU2V0OiBWZWN0b3IyW10gPSBFTVBUWV9EQVRBX1NFVDtcclxuICAgICAgICBpZiAoIGNvbXBvbmVudFNwYWNpbmcgPT09IDAgKSB7XHJcbiAgICAgICAgICBkYXRhU2V0ID0gY3JlYXRlV2F2ZVBhY2tldERhdGFTZXQoIGNlbnRlciwgY29uanVnYXRlU3RhbmRhcmREZXZpYXRpb24sIHNlcmllc1R5cGUsIHhBeGlzRGVzY3JpcHRpb24ucmFuZ2UgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGFTZXQ7XHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICB0aGlzLnN1bURhdGFTZXRQcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoXHJcbiAgICAgIFsgZmluaXRlU3VtRGF0YVNldFByb3BlcnR5LCBpbmZpbml0ZVN1bURhdGFTZXRQcm9wZXJ0eSBdLFxyXG4gICAgICAoIGZpbml0ZURhdGFTZXQsIGluZmluaXRlRGF0YVNldCApID0+XHJcbiAgICAgICAgKCB3YXZlUGFja2V0LmdldE51bWJlck9mQ29tcG9uZW50cygpID09PSBJbmZpbml0eSApID8gaW5maW5pdGVEYXRhU2V0IDogZmluaXRlRGF0YVNldFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyB7RGVyaXZlZFByb3BlcnR5LjxWZWN0b3IyW10+fSBEYXRhIHNldCBmb3IgdGhlIHdhdmVmb3JtIGVudmVsb3BlIG9mIGEgd2F2ZSBwYWNrZXQgd2l0aCBpbmZpbml0ZVxyXG4gICAgLy8gY29tcG9uZW50cywgRU1QVFlfREFUQV9TRVQgd2hlbiB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgaXMgZmluaXRlIG9yIHRoZSBlbnZlbG9wZSBpcyBub3QgdmlzaWJsZS5cclxuICAgIC8vIFRoaXMgaXMgY29tcHV0ZWQgdXNpbmcgMiB3YXZlIHBhY2tldCB3YXZlZm9ybXMgVVNJTkcgVEhFIEZPVVJJRVIgQ09NUE9ORU5UUyAtIG9uZSBmb3Igc2luZSwgb25lIGZvciBjb3NpbmUgLVxyXG4gICAgLy8gdGhlbiBjb21iaW5pbmcgeSB2YWx1ZXMuIFBvaW50cyBhcmUgb3JkZXJlZCBieSBpbmNyZWFzaW5nIHggdmFsdWUuXHJcbiAgICAvLyBUaGlzIGlzIGJhc2VkIG9uIHRoZSB1cGRhdGVFbnZlbG9wZSBtZXRob2QgaW4gRDJDU3VtVmlldy5qcy5cclxuICAgIGNvbnN0IGZpbml0ZVdhdmVmb3JtRW52ZWxvcGVEYXRhU2V0UHJvcGVydHkgPSBuZXcgRGVyaXZlZFByb3BlcnR5KFxyXG4gICAgICBbIHRoaXMud2F2ZWZvcm1FbnZlbG9wZVZpc2libGVQcm9wZXJ0eSwgZmluaXRlU3VtRGF0YVNldFByb3BlcnR5IF0sXHJcbiAgICAgICggd2F2ZWZvcm1FbnZlbG9wZVZpc2libGUsIGZpbml0ZVN1bURhdGFTZXQgKSA9PiB7XHJcbiAgICAgICAgbGV0IGRhdGFTZXQ6IFZlY3RvcjJbXSA9IEVNUFRZX0RBVEFfU0VUO1xyXG4gICAgICAgIGlmICggd2F2ZWZvcm1FbnZlbG9wZVZpc2libGUgJiYgZmluaXRlU3VtRGF0YVNldC5sZW5ndGggPiAwICkge1xyXG5cclxuICAgICAgICAgIC8vIFdlJ2xsIGJlIHVzaW5nIGZpbml0ZVN1bURhdGFTZXQgYXMgb25lIG9mIHRoZSBkYXRhIHNldHMuIEl0IHdhcyBjb21wdXRlZCBmb3IgZWl0aGVyIGEgU2VyaWVzVHlwZSxcclxuICAgICAgICAgIC8vIGVpdGhlciBzaW5lIG9yIGNvc2luZS4gQ29tcHV0ZSB0aGUgb3RoZXIgZGF0YSBzZXQgYnkgY3JlYXRpbmcgY29tcG9uZW50IGRhdGEgc2V0cyB1c2luZyB0aGUgb3RoZXJcclxuICAgICAgICAgIC8vIFNlcmllc1R5cGUsIHRoZW4gc3VtbWluZyB0aG9zZSBkYXRhIHNldHMuXHJcbiAgICAgICAgICBjb25zdCBzZXJpZXNUeXBlID0gKCBzZXJpZXNUeXBlUHJvcGVydHkudmFsdWUgPT09IFNlcmllc1R5cGUuU0lOICkgPyBTZXJpZXNUeXBlLkNPUyA6IFNlcmllc1R5cGUuU0lOO1xyXG4gICAgICAgICAgY29uc3Qgb3RoZXJDb21wb25lbnREYXRhU2V0cyA9IFdhdmVQYWNrZXRDb21wb25lbnRzQ2hhcnQuY3JlYXRlQ29tcG9uZW50c0RhdGFTZXRzKFxyXG4gICAgICAgICAgICB3YXZlUGFja2V0LmNvbXBvbmVudHNQcm9wZXJ0eS52YWx1ZSwgd2F2ZVBhY2tldC5jb21wb25lbnRTcGFjaW5nUHJvcGVydHkudmFsdWUsIGRvbWFpblByb3BlcnR5LnZhbHVlLFxyXG4gICAgICAgICAgICBzZXJpZXNUeXBlLCB4QXhpc0Rlc2NyaXB0aW9uUHJvcGVydHkudmFsdWUucmFuZ2VcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBjb25zdCBvdGhlclN1bURhdGFTZXQgPSBjcmVhdGVTdW1EYXRhU2V0KCBvdGhlckNvbXBvbmVudERhdGFTZXRzICk7XHJcblxyXG4gICAgICAgICAgLy8gQ29tYmluZSB0aGUgMiBkYXRhIHNldHMgdG8gY3JlYXRlIHRoZSBlbnZlbG9wZS5cclxuICAgICAgICAgIGRhdGFTZXQgPSBjcmVhdGVFbnZlbG9wZURhdGFTZXQoIGZpbml0ZVN1bURhdGFTZXQsIG90aGVyU3VtRGF0YVNldCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YVNldDtcclxuICAgICAgfSApO1xyXG5cclxuICAgIC8vIHtEZXJpdmVkUHJvcGVydHkuPFZlY3RvcjJbXT59IERhdGEgc2V0IGZvciB0aGUgd2F2ZWZvcm0gZW52ZWxvcGUgb2YgYSB3YXZlIHBhY2tldCB3aXRoIGluZmluaXRlXHJcbiAgICAvLyBjb21wb25lbnRzLCBFTVBUWV9EQVRBX1NFVCB3aGVuIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBpcyBmaW5pdGUgb3IgdGhlIGVudmVsb3BlIGlzIG5vdCB2aXNpYmxlLlxyXG4gICAgLy8gVGhpcyBpcyBjb21wdXRlZCB1c2luZyAyIHdhdmUgcGFja2V0IHdhdmVmb3JtcyAtIG9uZSBmb3Igc2luZSwgb25lIGZvciBjb3NpbmUgLSB0aGVuIGNvbWJpbmluZyB5IHZhbHVlcy5cclxuICAgIC8vIFBvaW50cyBhcmUgb3JkZXJlZCBieSBpbmNyZWFzaW5nIHggdmFsdWUuXHJcbiAgICBjb25zdCBpbmZpbml0ZVdhdmVmb3JtRW52ZWxvcGVEYXRhU2V0UHJvcGVydHkgPSBuZXcgRGVyaXZlZFByb3BlcnR5KFxyXG4gICAgICBbIHRoaXMud2F2ZWZvcm1FbnZlbG9wZVZpc2libGVQcm9wZXJ0eSwgd2F2ZVBhY2tldC5jb21wb25lbnRTcGFjaW5nUHJvcGVydHksIHdhdmVQYWNrZXQuY2VudGVyUHJvcGVydHksXHJcbiAgICAgICAgd2F2ZVBhY2tldC5jb25qdWdhdGVTdGFuZGFyZERldmlhdGlvblByb3BlcnR5LCBzZXJpZXNUeXBlUHJvcGVydHksIHhBeGlzRGVzY3JpcHRpb25Qcm9wZXJ0eSBdLFxyXG4gICAgICAoIHdhdmVmb3JtRW52ZWxvcGVWaXNpYmxlLCBjb21wb25lbnRTcGFjaW5nLCBjZW50ZXIsIGNvbmp1Z2F0ZVN0YW5kYXJkRGV2aWF0aW9uLCBzZXJpZXNUeXBlLCB4QXhpc0Rlc2NyaXB0aW9uICkgPT4ge1xyXG4gICAgICAgIGxldCBkYXRhU2V0OiBWZWN0b3IyW10gPSBFTVBUWV9EQVRBX1NFVDtcclxuICAgICAgICBpZiAoIHdhdmVmb3JtRW52ZWxvcGVWaXNpYmxlICYmIGNvbXBvbmVudFNwYWNpbmcgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgLy8gQ29tcHV0ZSBkYXRhIHNldHMgZm9yIHRoZSBzYW1lIHdhdmUgcGFja2V0LCB1c2luZyBzaW4gYW5kIGNvcy5cclxuICAgICAgICAgIGNvbnN0IHNpbkRhdGFTZXQgPSBjcmVhdGVXYXZlUGFja2V0RGF0YVNldCggY2VudGVyLCBjb25qdWdhdGVTdGFuZGFyZERldmlhdGlvbiwgU2VyaWVzVHlwZS5TSU4sIHhBeGlzRGVzY3JpcHRpb24ucmFuZ2UgKTtcclxuICAgICAgICAgIGNvbnN0IGNvc0RhdGFTZXQgPSBjcmVhdGVXYXZlUGFja2V0RGF0YVNldCggY2VudGVyLCBjb25qdWdhdGVTdGFuZGFyZERldmlhdGlvbiwgU2VyaWVzVHlwZS5DT1MsIHhBeGlzRGVzY3JpcHRpb24ucmFuZ2UgKTtcclxuICAgICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHNpbkRhdGFTZXQubGVuZ3RoID09PSBjb3NEYXRhU2V0Lmxlbmd0aCApO1xyXG5cclxuICAgICAgICAgIC8vIENvbWJpbmUgdGhlIDIgZGF0YSBzZXRzIHRvIGNyZWF0ZSB0aGUgZW52ZWxvcGUuXHJcbiAgICAgICAgICBkYXRhU2V0ID0gY3JlYXRlRW52ZWxvcGVEYXRhU2V0KCBzaW5EYXRhU2V0LCBjb3NEYXRhU2V0ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhU2V0O1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgdGhpcy53YXZlZm9ybUVudmVsb3BlRGF0YVNldFByb3BlcnR5ID0gbmV3IERlcml2ZWRQcm9wZXJ0eShcclxuICAgICAgWyBmaW5pdGVXYXZlZm9ybUVudmVsb3BlRGF0YVNldFByb3BlcnR5LCBpbmZpbml0ZVdhdmVmb3JtRW52ZWxvcGVEYXRhU2V0UHJvcGVydHkgXSxcclxuICAgICAgKCBmaW5pdGVEYXRhU2V0LCBpbmZpbml0ZURhdGFTZXQgKSA9PlxyXG4gICAgICAgICggd2F2ZVBhY2tldC5nZXROdW1iZXJPZkNvbXBvbmVudHMoKSA9PT0gSW5maW5pdHkgKSA/IGluZmluaXRlRGF0YVNldCA6IGZpbml0ZURhdGFTZXRcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy53aWR0aEluZGljYXRvcldpZHRoUHJvcGVydHkgPSBuZXcgRGVyaXZlZFByb3BlcnR5KFxyXG4gICAgICBbIHdhdmVQYWNrZXQuY29uanVnYXRlU3RhbmRhcmREZXZpYXRpb25Qcm9wZXJ0eSBdLFxyXG4gICAgICBjb25qdWdhdGVTdGFuZGFyZERldmlhdGlvbiA9PiAyICogY29uanVnYXRlU3RhbmRhcmREZXZpYXRpb25cclxuICAgICk7XHJcblxyXG4gICAgLy8gVGhpcyBpcyBhIGNvbnN0YW50LCBidXQgdGhlIHZpZXcgcmVxdWlyZXMgYSBQcm9wZXJ0eS4gV2UgdXNlIHZhbGlkVmFsdWVzIHRvIGNvbnN0cmFpbiBpdCB0byAxIHZhbHVlLlxyXG4gICAgLy8gVGhpcyBpcyBiYXNlZCBvbiB0aGUgZ2V0TW9kZWxMb2NhdGlvbiBtZXRob2QgaW4gV2F2ZVBhY2tldFhXaWR0aFBsb3QuamF2YS5cclxuICAgIGNvbnN0IHdpZHRoSW5kaWNhdG9yUG9zaXRpb24gPSBuZXcgVmVjdG9yMiggMCwgMSAvIE1hdGguc3FydCggTWF0aC5FICkgKTtcclxuICAgIHRoaXMud2lkdGhJbmRpY2F0b3JQb3NpdGlvblByb3BlcnR5ID0gbmV3IFZlY3RvcjJQcm9wZXJ0eSggd2lkdGhJbmRpY2F0b3JQb3NpdGlvbiwge1xyXG4gICAgICB2YWxpZFZhbHVlczogWyB3aWR0aEluZGljYXRvclBvc2l0aW9uIF1cclxuICAgIH0gKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBvdmVycmlkZSByZXNldCgpOiB2b2lkIHtcclxuICAgIHN1cGVyLnJlc2V0KCk7XHJcbiAgICB0aGlzLndhdmVmb3JtRW52ZWxvcGVWaXNpYmxlUHJvcGVydHkucmVzZXQoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgZGF0YSBzZXQgYnkgc3VtbWluZyB0aGUgeSBjb21wb25lbnRzIG9mIGRhdGEgc2V0cy4gVGhlIHByb3ZpZGVkIGRhdGEgc2V0cyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyXHJcbiAqIG9mIHBvaW50cywgYW5kIHBvaW50cyB3aXRoIHRoZSBzYW1lIGluZGV4IG11c3QgaGF2ZSB0aGUgc2FtZSB4IHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU3VtRGF0YVNldCggZGF0YVNldHM6IFZlY3RvcjJbXVtdICk6IFZlY3RvcjJbXSB7XHJcbiAgYXNzZXJ0ICYmIGFzc2VydCggZGF0YVNldHMubGVuZ3RoID4gMCApO1xyXG5cclxuICBjb25zdCBwb2ludHNQZXJEYXRhU2V0ID0gZGF0YVNldHNbIDAgXS5sZW5ndGg7XHJcbiAgYXNzZXJ0ICYmIGFzc2VydCggcG9pbnRzUGVyRGF0YVNldCA+IDAsICdEYXRhIHNldHMgbXVzdCBjb250YWluIHBvaW50cy4nICk7XHJcbiAgYXNzZXJ0ICYmIGFzc2VydCggXy5ldmVyeSggZGF0YVNldHMsIGRhdGFTZXQgPT4gZGF0YVNldC5sZW5ndGggPT09IHBvaW50c1BlckRhdGFTZXQgKSxcclxuICAgICdBbGwgZGF0YSBzZXRzIG11Y2ggaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcG9pbnRzLicgKTtcclxuXHJcbiAgY29uc3QgZGF0YVNldCA9IFtdO1xyXG4gIGZvciAoIGxldCBpID0gMDsgaSA8IHBvaW50c1BlckRhdGFTZXQ7IGkrKyApIHtcclxuICAgIGxldCBzdW0gPSAwO1xyXG4gICAgY29uc3QgeCA9IGRhdGFTZXRzWyAwIF1bIGkgXS54O1xyXG4gICAgZm9yICggbGV0IGogPSAwOyBqIDwgZGF0YVNldHMubGVuZ3RoOyBqKysgKSB7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIGRhdGFTZXRzWyBqIF1bIGkgXS54ID09PSB4LCAnUG9pbnRzIHdpdGggdGhlIHNhbWUgaW5kZXggbXVzdCBoYXZlIHRoZSBzYW1lIHggdmFsdWUuJyApO1xyXG4gICAgICBzdW0gKz0gZGF0YVNldHNbIGogXVsgaSBdLnk7XHJcbiAgICB9XHJcbiAgICBkYXRhU2V0LnB1c2goIG5ldyBWZWN0b3IyKCB4LCBzdW0gKSApO1xyXG4gIH1cclxuICByZXR1cm4gZGF0YVNldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkYXRhIHNldCBmb3IgYSB3YXZlIHBhY2tldCBhcHByb3hpbWF0ZWQgdXNpbmcgYW4gaW5maW5pdGUgbnVtYmVyIG9mIEZvdXJpZXIgY29tcG9uZW50cy5cclxuICogVGhpcyBpcyBiYXNlZCBvbiB0aGUgdXBkYXRlRGF0YVNldCBtZXRob2QgaW4gR2F1c3NpYW5XYXZlUGFja2V0UGxvdC5qYXZhLlxyXG4gKiBAcGFyYW0gY2VudGVyIC0gdGhlIHdhdmUgcGFja2V0J3MgY2VudGVyXHJcbiAqIEBwYXJhbSBjb25qdWdhdGVTdGFuZGFyZERldmlhdGlvbiAtIHRoZSB3YXZlIHBhY2tldCdzIGNvbmp1Z2F0ZSBzdGFuZGFyZCBkZXZpYXRpb24sIGEgbWVhc3VyZSBvZiB3aWR0aFxyXG4gKiBAcGFyYW0gc2VyaWVzVHlwZSAtIHNpbmUgb3IgY29zaW5lXHJcbiAqIEBwYXJhbSB4UmFuZ2UgLSByYW5nZSBvZiB0aGUgU3VtIGNoYXJ0J3MgeC1heGlzXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXYXZlUGFja2V0RGF0YVNldCggY2VudGVyOiBudW1iZXIsIGNvbmp1Z2F0ZVN0YW5kYXJkRGV2aWF0aW9uOiBudW1iZXIsIHNlcmllc1R5cGU6IFNlcmllc1R5cGUsIHhSYW5nZTogUmFuZ2UgKTogVmVjdG9yMltdIHtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBjZW50ZXIgPiAwICk7XHJcbiAgYXNzZXJ0ICYmIGFzc2VydCggY29uanVnYXRlU3RhbmRhcmREZXZpYXRpb24gPiAwICk7XHJcblxyXG4gIGNvbnN0IGRhdGFTZXQgPSBbXTtcclxuICBjb25zdCBudW1iZXJPZlBvaW50cyA9IEZNV0NvbnN0YW50cy5NQVhfUE9JTlRTX1BFUl9EQVRBX1NFVCArIDE7XHJcbiAgY29uc3QgZHggPSB4UmFuZ2UuZ2V0TGVuZ3RoKCkgLyBudW1iZXJPZlBvaW50cztcclxuXHJcbiAgZm9yICggbGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZQb2ludHM7IGkrKyApIHtcclxuXHJcbiAgICAvLyB4XHJcbiAgICBjb25zdCB4ID0geFJhbmdlLm1pbiArICggaSAqIGR4ICk7XHJcblxyXG4gICAgLy8geSA9IEYoeCkgPSBleHAoIC0oeF4yKSAvICgyICogKGR4XjIpKSApICogc2luKGswKngpXHJcbiAgICBjb25zdCBzaW5Db3NUZXJtID0gKCBzZXJpZXNUeXBlID09PSBTZXJpZXNUeXBlLlNJTiApID8gTWF0aC5zaW4oIGNlbnRlciAqIHggKSA6IE1hdGguY29zKCBjZW50ZXIgKiB4ICk7XHJcbiAgICBjb25zdCB5ID0gTWF0aC5leHAoIC0oIHggKiB4ICkgLyAoIDIgKiAoIGNvbmp1Z2F0ZVN0YW5kYXJkRGV2aWF0aW9uICogY29uanVnYXRlU3RhbmRhcmREZXZpYXRpb24gKSApICkgKiBzaW5Db3NUZXJtO1xyXG5cclxuICAgIGRhdGFTZXQucHVzaCggbmV3IFZlY3RvcjIoIHgsIHkgKSApO1xyXG4gIH1cclxuICByZXR1cm4gZGF0YVNldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgdGhlIGRhdGEgc2V0IGZvciB0aGUgd2F2ZWZvcm0gZW52ZWxvcGUuIFRoZSBwcm92aWRlZCBkYXRhIHNldHMgbXVzdCBkZXNjcmliZSB0aGUgc2FtZSB3YXZlIHBhY2tldCAtXHJcbiAqIG9uZSBjb21wdXRlZCB1c2luZyBzaW5lLCB0aGUgb3RoZXIgY29tcHV0ZWQgdXNpbmcgY29zaW5lLiBUaGV5IG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcG9pbnRzLFxyXG4gKiBhbmQgcG9pbnRzIHdpdGggdGhlIHNhbWUgaW5kZXggbXVzdCBoYXZlIHRoZSBzYW1lIHggdmFsdWUuXHJcbiAqIFRoaXMgaXMgYmFzZWQgb24gdGhlIHVwZGF0ZUVudmVsb3BlIG1ldGhvZCBpbiBEMkNTdW1WaWV3LmpzLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlRW52ZWxvcGVEYXRhU2V0KCBkYXRhU2V0MTogVmVjdG9yMltdLCBkYXRhU2V0MjogVmVjdG9yMltdICk6IFZlY3RvcjJbXSB7XHJcbiAgYXNzZXJ0ICYmIGFzc2VydCggZGF0YVNldDEubGVuZ3RoID4gMCApO1xyXG4gIGFzc2VydCAmJiBhc3NlcnQoIGRhdGFTZXQyLmxlbmd0aCA+IDAgKTtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBkYXRhU2V0MS5sZW5ndGggPT09IGRhdGFTZXQyLmxlbmd0aCApO1xyXG5cclxuICBjb25zdCBkYXRhU2V0ID0gW107XHJcbiAgZm9yICggbGV0IGkgPSAwOyBpIDwgZGF0YVNldDEubGVuZ3RoOyBpKysgKSB7XHJcblxyXG4gICAgLy8geFxyXG4gICAgY29uc3QgeCA9IGRhdGFTZXQxWyBpIF0ueDtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHggPT09IGRhdGFTZXQyWyBpIF0ueCwgJ3BvaW50cyB3aXRoIHRoZSBzYW1lIGluZGV4IG11c3QgaGF2ZSB0aGUgc2FtZSB4IHZhbHVlJyApO1xyXG5cclxuICAgIC8vIHkgPSBzcXJ0KCB5MV4yICsgeUNvc14yIClcclxuICAgIGNvbnN0IHkxID0gZGF0YVNldDFbIGkgXS55O1xyXG4gICAgY29uc3QgeTIgPSBkYXRhU2V0MlsgaSBdLnk7XHJcbiAgICBjb25zdCB5ID0gTWF0aC5zcXJ0KCAoIHkxICogeTEgKSArICggeTIgKiB5MiApICk7XHJcblxyXG4gICAgZGF0YVNldC5wdXNoKCBuZXcgVmVjdG9yMiggeCwgeSApICk7XHJcbiAgfVxyXG4gIHJldHVybiBkYXRhU2V0O1xyXG59XHJcblxyXG5mb3VyaWVyTWFraW5nV2F2ZXMucmVnaXN0ZXIoICdXYXZlUGFja2V0U3VtQ2hhcnQnLCBXYXZlUGFja2V0U3VtQ2hhcnQgKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsZUFBZSxNQUFNLHdDQUF3QztBQUNwRSxPQUFPQyxlQUFlLE1BQU0sd0NBQXdDO0FBS3BFLE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsZUFBZSxNQUFNLHVDQUF1QztBQUVuRSxPQUFPQyxZQUFZLE1BQU0sOEJBQThCO0FBQ3ZELE9BQU9DLFdBQVcsTUFBTSxtQ0FBbUM7QUFDM0QsT0FBT0MsVUFBVSxNQUFNLGtD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