// Copyright 2020-2023, University of Colorado Boulder

/**
 * AmplitudeSlider is a slider for changing the amplitude of a harmonic. It is a specialization of sun.Slider
 * that is skinned to look like an interactive bar, for display on a bar chart.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import Dimension2 from '../../../../dot/js/Dimension2.js';
import Range from '../../../../dot/js/Range.js';
import Utils from '../../../../dot/js/Utils.js';
import { Shape } from '../../../../kite/js/imports.js';
import merge from '../../../../phet-core/js/merge.js';
import Orientation from '../../../../phet-core/js/Orientation.js';
import { Color, Node, Path, PressListener, Rectangle } from '../../../../scenery/js/imports.js';
import Slider from '../../../../sun/js/Slider.js';
import SliderTrack from '../../../../sun/js/SliderTrack.js';
import Tandem from '../../../../tandem/js/Tandem.js';
import fourierMakingWaves from '../../fourierMakingWaves.js';
import FMWConstants from '../FMWConstants.js';
import EmphasizedHarmonics from '../model/EmphasizedHarmonics.js';
import Harmonic from '../model/Harmonic.js';

// constants
const TRACK_WIDTH = 40; // track height is specified in constructor options

// Dimension2 instances must be swapped, because VSlider rotates its thumb and track -90 degrees.
// So we'll specify the dimensions of our custom thumb and track in vertical orientation, create
// our custom thumb and track in horizontal orientation, and Slider will rotate them into vertical orientation.
// Pretty gross, eh? See https://github.com/phetsims/fourier-making-waves/issues/175
const THUMB_SIZE = new Dimension2(TRACK_WIDTH - 15, 8).swapped();
const THUMB_TOUCH_AREA_DILATION = new Dimension2(10, 4).swapped();
const THUMB_MOUSE_AREA_DILATION = new Dimension2(10, 4).swapped();
export default class AmplitudeSlider extends Slider {
  /**
   * @param {Harmonic} harmonic
   * @param {EmphasizedHarmonics} emphasizedHarmonics
   * @param {Object} [options]
   */
  constructor(harmonic, emphasizedHarmonics, options) {
    assert && assert(harmonic instanceof Harmonic);
    assert && assert(emphasizedHarmonics instanceof EmphasizedHarmonics);
    options = merge({
      // {number} height of the track
      trackHeight: 120,
      // {number} snap to this interval when using mouse/touch, unless the value is min or max
      mouseTouchStep: FMWConstants.DISCRETE_AMPLITUDE_STEP,
      // Slider options
      startDrag: _.noop,
      endDrag: _.noop,
      orientation: Orientation.VERTICAL,
      valueChangeSoundGeneratorOptions: {
        numberOfMiddleThresholds: harmonic.amplitudeProperty.range.getLength() / FMWConstants.DISCRETE_AMPLITUDE_STEP - 1
      },
      // pdom options
      // slider steps, see https://github.com/phetsims/fourier-making-waves/issues/53
      keyboardStep: FMWConstants.DISCRETE_AMPLITUDE_KEYBOARD_STEP,
      // used by all alternative-input devices
      shiftKeyboardStep: FMWConstants.DISCRETE_AMPLITUDE_SHIFT_KEYBOARD_STEP,
      // finer grain, used by keyboard only
      pageKeyboardStep: FMWConstants.DISCRETE_AMPLITUDE_PAGE_KEYBOARD_STEP,
      // coarser grain, used by keyboard only

      // phet-io options
      tandem: Tandem.REQUIRED
    }, options);
    assert && assert(options.shiftKeyboardStep <= options.keyboardStep);
    assert && assert(options.pageKeyboardStep >= options.keyboardStep);
    assert && assert(options.keyboardStep >= options.mouseTouchStep, 'see https://github.com/phetsims/sun/issues/698');
    assert && assert(options.pageKeyboardStep >= options.mouseTouchStep, 'see https://github.com/phetsims/sun/issues/698');
    const amplitudeRange = harmonic.amplitudeProperty.range;
    assert && assert(!options.constrainValue, 'AmplitudeSlider sets constrainValue');
    options.constrainValue = amplitude => {
      if (amplitude !== amplitudeRange.min && amplitude !== amplitudeRange.max) {
        amplitude = Utils.roundToInterval(amplitude, options.mouseTouchStep);
      }
      return amplitude;
    };

    // Custom thumb
    const thumbNode = new GrippyThumb(THUMB_SIZE, harmonic, {
      tandem: options.tandem.createTandem(Slider.THUMB_NODE_TANDEM_NAME)
    });
    thumbNode.touchArea = thumbNode.localBounds.dilatedXY(THUMB_TOUCH_AREA_DILATION.width, THUMB_TOUCH_AREA_DILATION.height);
    thumbNode.mouseArea = thumbNode.localBounds.dilatedXY(THUMB_MOUSE_AREA_DILATION.width, THUMB_MOUSE_AREA_DILATION.height);
    assert && assert(!options.thumbNode, 'AmplitudeSlider sets thumbNode');
    options.thumbNode = thumbNode;

    // Custom track
    const trackNode = new BarTrack(harmonic, amplitudeRange, {
      // Propagate drag behavior to our custom track
      startDrag: options.startDrag,
      endDrag: options.endDrag,
      constrainValue: options.constrainValue,
      // See note above about why swapped is necessary.
      size: new Dimension2(TRACK_WIDTH, options.trackHeight).swapped(),
      tandem: options.tandem.createTandem(Slider.TRACK_NODE_TANDEM_NAME)
    });
    assert && assert(!options.trackNode, 'AmplitudeSlider sets trackNode');
    options.trackNode = trackNode;
    super(harmonic.amplitudeProperty, amplitudeRange, options);

    // Whether this slider has keyboard focus.
    const hasFocusProperty = new BooleanProperty(this.focused);
    this.addInputListener({
      focus: () => {
        hasFocusProperty.value = true;
      },
      blur: () => {
        hasFocusProperty.value = false;
      }
    });

    // {DerivedProperty.<boolean>}
    // The associated harmonic is emphasized if we're interacting with the slider in some way.
    const isEmphasizedProperty = DerivedProperty.or([this.thumbDragListener.isHighlightedProperty, trackNode.isHighlightedProperty, hasFocusProperty]);

    // Emphasize the associated harmonic.
    isEmphasizedProperty.lazyLink(isEmphasized => {
      if (isEmphasized) {
        emphasizedHarmonics.push(this, harmonic);
      } else if (emphasizedHarmonics.includesNode(this)) {
        emphasizedHarmonics.remove(this);
      }
    });

    // Interrupt interaction when visibility changes.
    this.visibleProperty.link(() => this.interruptSubtreeInput());
  }

  /**
   * @public
   * @override
   */
  dispose() {
    assert && assert(false, 'dispose is not supported, exists for the lifetime of the sim');
    super.dispose();
  }
}

/**
 * GrippyThumb is a custom thumb for AmplitudeSlider. It has grippy dots on it that are color-coded to the harmonic.
 * Created in horizontal orientation because VSlider will rotate it -90 degrees to vertical orientation.
 */
class GrippyThumb extends Node {
  /**
   * @param {Dimension2} thumbSize
   * @param {Harmonic} harmonic
   * @param {Object} [options]
   */
  constructor(thumbSize, harmonic, options) {
    assert && assert(thumbSize instanceof Dimension2);
    assert && assert(harmonic instanceof Harmonic);
    options = merge({
      tandem: Tandem.REQUIRED
    }, options);
    const rectangle = new Rectangle(0, 0, thumbSize.width, thumbSize.height, {
      fill: Color.grayColor(200),
      stroke: 'black',
      cornerRadius: 2
    });

    // A row of dots, color-coded to the harmonic
    // Note that this code is actually drawing a column of dots, because VSlider rotates its thumb -90 degrees.
    const numberOfDots = 3;
    const xMargin = 2.5;
    const ySpacing = rectangle.height / (numberOfDots + 1);
    const dotRadius = (rectangle.width - 2 * xMargin) / 2;
    assert && assert(dotRadius > 0, `invalid dotRadius: ${dotRadius}`);
    const dotsShape = new Shape();
    for (let i = 0; i < numberOfDots; i++) {
      const y = i * ySpacing;
      dotsShape.moveTo(dotRadius, y);
      dotsShape.arc(0, y, dotRadius, 0, 2 * Math.PI);
    }
    const dotsNode = new Path(dotsShape, {
      fill: harmonic.colorProperty,
      stroke: 'black',
      lineWidth: 0.5,
      center: rectangle.center
    });
    assert && assert(!options.children, 'GrippyThumb sets children');
    options.children = [rectangle, dotsNode];
    super(options);
  }

  /**
   * @public
   * @override
   */
  dispose() {
    assert && assert(false, 'dispose is not supported, exists for the lifetime of the sim');
    super.dispose();
  }
}

/**
 * BarTrack is a custom track for AmplitudeSlider.
 * It fills a colored bar that grows up and down from the center of the track.
 * Created in horizontal orientation because VSlider will rotate it -90 degrees to vertical orientation.
 */
class BarTrack extends SliderTrack {
  /**
   * @param {Harmonic} harmonic
   * @param {Range} amplitudeRange
   * @param {Object} [options]
   */
  constructor(harmonic, amplitudeRange, options) {
    assert && assert(harmonic instanceof Harmonic);
    assert && assert(amplitudeRange instanceof Range);
    assert && assert(amplitudeRange.getCenter() === 0, 'implementation assumes that range is symmetric');
    options = merge({
      size: new Dimension2(10, 10),
      tandem: Tandem.REQUIRED
    }, options);

    // To improve readability
    const trackWidth = options.size.width;
    const trackHeight = options.size.height;
    const invisibleTrackNode = new Rectangle(0, 0, trackWidth, trackHeight, {
      fill: 'transparent',
      stroke: phet.chipper.queryParameters.dev ? 'red' : null,
      lineWidth: 0.25
    });
    const visibleTrackNode = new Rectangle(0, 0, trackWidth, trackHeight, {
      fill: harmonic.colorProperty,
      stroke: 'black'
    });
    const trackNode = new Node({
      children: [invisibleTrackNode, visibleTrackNode]
    });
    super(harmonic.amplitudeProperty, trackNode, amplitudeRange, options);

    // When the amplitude changes, redraw the track to make it look like a bar extends up or down from amplitude = 0.
    // Note that this code is actually extending left or right, because VSlider rotates its track -90 degrees.
    const amplitudeListener = amplitude => {
      visibleTrackNode.visible = amplitude !== 0;
      if (amplitude === 0) {
        visibleTrackNode.setRect(0, 0, 1, 1);
      } else if (amplitude > 0) {
        const barWidth = trackWidth / 2 * amplitude / amplitudeRange.max;
        visibleTrackNode.setRect(trackWidth / 2, 0, barWidth, trackHeight);
      } else {
        const barWidth = trackWidth / 2 * amplitude / amplitudeRange.min;
        visibleTrackNode.setRect(trackWidth / 2 - barWidth, 0, barWidth, trackHeight);
      }
    };
    harmonic.amplitudeProperty.link(amplitudeListener);

    // When the cursor is over the visible part of the track, it is considered highlighted.
    const visibleTrackPressListener = new PressListener({
      attach: false // so that the DragListener for the track isn't ignored
    });

    visibleTrackNode.addInputListener(visibleTrackPressListener);

    // @public {DerivedProperty.<boolean>}
    // This tells us when the track should be considered highlighted. We can't simply look at
    // this.dragListener.isHighlightedProperty, because that will include the invisible portion of the track.
    // This is used to emphasize the associated harmonic's plot in the Harmonics chart. See isEmphasizedProperty
    // in AmplitudeSlider above.
    this.isHighlightedProperty = new DerivedProperty([this.dragListener.isPressedProperty, visibleTrackPressListener.isOverProperty], (isPressed, isOverVisible) => isPressed || isOverVisible);
  }

  /**
   * @public
   * @override
   */
  dispose() {
    assert && assert(false, 'dispose is not supported, exists for the lifetime of the sim');
    super.dispose();
  }
}
fourierMakingWaves.register('AmplitudeSlider', AmplitudeSlider);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJEZXJpdmVkUHJvcGVydHkiLCJEaW1lbnNpb24yIiwiUmFuZ2UiLCJVdGlscyIsIlNoYXBlIiwibWVyZ2UiLCJPcmllbnRhdGlvbiIsIkNvbG9yIiwiTm9kZSIsIlBhdGgiLCJQcmVzc0xpc3RlbmVyIiwiUmVjdGFuZ2xlIiwiU2xpZGVyIiwiU2xpZGVyVHJhY2siLCJUYW5kZW0iLCJmb3VyaWVyTWFraW5nV2F2ZXMiLCJGTVdDb25zdGFudHMiLCJFbXBoYXNpemVkSGFybW9uaWNzIiwiSGFybW9uaWMiLCJUUkFDS19XSURUSCIsIlRIVU1CX1NJWkUiLCJzd2FwcGVkIiwiVEhVTUJfVE9VQ0hfQVJFQV9ESUxBVElPTiIsIlRIVU1CX01PVVNFX0FSRUFfRElMQVRJT04iLCJBbXBsaXR1ZGVTbGlkZXIiLCJjb25zdHJ1Y3RvciIsImhhcm1vbmljIiwiZW1waGFzaXplZEhhcm1vbmljcyIsIm9wdGlvbnMiLCJhc3NlcnQiLCJ0cmFja0hlaWdodCIsIm1vdXNlVG91Y2hTdGVwIiwiRElTQ1JFVEVfQU1QTElUVURFX1NURVAiLCJzdGFydERyYWciLCJfIiwibm9vcCIsImVuZERyYWciLCJvcmllbnRhdGlvbiIsIlZFUlRJQ0FMIiwidmFsdWVDaGFuZ2VTb3VuZEdlbmVyYXRvck9wdGlvbnMiLCJudW1iZXJPZk1pZGRsZVRocmVzaG9sZHMiLCJhbXBsaXR1ZGVQcm9wZXJ0eSIsInJhbmdlIiwiZ2V0TGVuZ3RoIiwia2V5Ym9hcmRTdGVwIiwiRElTQ1JFVEVfQU1QTElUVURFX0tFWUJPQVJEX1NURVAiLCJzaGlmdEtleWJvYXJkU3RlcCIsIkRJU0NSRVRFX0FNUExJVFVERV9TSElGVF9LRVlCT0FSRF9TVEVQIiwicGFnZUtleWJvYXJkU3RlcCIsIkRJU0NSRVRFX0FNUExJVFVERV9QQUdFX0tFWUJPQVJEX1NURVAiLCJ0YW5kZW0iLCJSRVFVSVJFRCIsImFtcGxpdHVkZVJhbmdlIiwiY29uc3RyYWluVmFsdWUiLCJhbXBsaXR1ZGUiLCJtaW4iLCJtYXgiLCJyb3VuZFRvSW50ZXJ2YWwiLCJ0aHVtYk5vZGUiLCJHcmlwcHlUaHVtYiIsImNyZWF0ZVRhbmRlbSIsIlRIVU1CX05PREVfVEFOREVNX05BTUUiLCJ0b3VjaEFyZWEiLCJsb2NhbEJvdW5kcyIsImRpbGF0ZWRYWSIsIndpZHRoIiwiaGVpZ2h0IiwibW91c2VBcmVhIiwidHJhY2tOb2RlIiwiQmFyVHJhY2siLCJzaXplIiwiVFJBQ0tfTk9ERV9UQU5ERU1fTkFNRSIsImhhc0ZvY3VzUHJvcGVydHkiLCJmb2N1c2VkIiwiYWRkSW5wdXRMaXN0ZW5lciIsImZvY3VzIiwidmFsdWUiLCJibHVyIiwiaXNFbXBoYXNpemVkUHJvcGVydHkiLCJvciIsInRodW1iRHJhZ0xpc3RlbmVyIiwiaXNIaWdobGlnaHRlZFByb3BlcnR5IiwibGF6eUxpbmsiLCJpc0VtcGhhc2l6ZWQiLCJwdXNoIiwiaW5jbHVkZXNOb2RlIiwicmVtb3ZlIiwidmlzaWJsZVByb3BlcnR5IiwibGluayIsImludGVycnVwdFN1YnRyZWVJbnB1dCIsImRpc3Bvc2UiLCJ0aHVtYlNpemUiLCJyZWN0YW5nbGUiLCJmaWxsIiwiZ3JheUNvbG9yIiwic3Ryb2tlIiwiY29ybmVyUmFkaXVzIiwibnVtYmVyT2ZEb3RzIiwieE1hcmdpbiIsInlTcGFjaW5nIiwiZG90UmFkaXVzIiwiZG90c1NoYXBlIiwiaSIsInkiLCJtb3ZlVG8iLCJhcmMiLCJNYXRoIiwiUEkiLCJkb3RzTm9kZSIsImNvbG9yUHJvcGVydHkiLCJsaW5lV2lkdGgiLCJjZW50ZXIiLCJjaGlsZHJlbiIsImdldENlbnRlciIsInRyYWNrV2lkdGgiLCJpbnZpc2libGVUcmFja05vZGUiLCJwaGV0IiwiY2hpcHBlciIsInF1ZXJ5UGFyYW1ldGVycyIsImRldiIsInZpc2libGVUcmFja05vZGUiLCJhbXBsaXR1ZGVMaXN0ZW5lciIsInZpc2libGUiLCJzZXRSZWN0IiwiYmFyV2lkdGgiLCJ2aXNpYmxlVHJhY2tQcmVzc0xpc3RlbmVyIiwiYXR0YWNoIiwiZHJhZ0xpc3RlbmVyIiwiaXNQcmVzc2VkUHJvcGVydHkiLCJpc092ZXJQcm9wZXJ0eSIsImlzUHJlc3NlZCIsImlzT3ZlclZpc2libGUiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkFtcGxpdHVkZVNsaWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMC0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBBbXBsaXR1ZGVTbGlkZXIgaXMgYSBzbGlkZXIgZm9yIGNoYW5naW5nIHRoZSBhbXBsaXR1ZGUgb2YgYSBoYXJtb25pYy4gSXQgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBzdW4uU2xpZGVyXHJcbiAqIHRoYXQgaXMgc2tpbm5lZCB0byBsb29rIGxpa2UgYW4gaW50ZXJhY3RpdmUgYmFyLCBmb3IgZGlzcGxheSBvbiBhIGJhciBjaGFydC5cclxuICpcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgQm9vbGVhblByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvQm9vbGVhblByb3BlcnR5LmpzJztcclxuaW1wb3J0IERlcml2ZWRQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0Rlcml2ZWRQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBEaW1lbnNpb24yIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9EaW1lbnNpb24yLmpzJztcclxuaW1wb3J0IFJhbmdlIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9SYW5nZS5qcyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgT3JpZW50YXRpb24gZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL09yaWVudGF0aW9uLmpzJztcclxuaW1wb3J0IHsgQ29sb3IsIE5vZGUsIFBhdGgsIFByZXNzTGlzdGVuZXIsIFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBTbGlkZXIgZnJvbSAnLi4vLi4vLi4vLi4vc3VuL2pzL1NsaWRlci5qcyc7XHJcbmltcG9ydCBTbGlkZXJUcmFjayBmcm9tICcuLi8uLi8uLi8uLi9zdW4vanMvU2xpZGVyVHJhY2suanMnO1xyXG5pbXBvcnQgVGFuZGVtIGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy9UYW5kZW0uanMnO1xyXG5pbXBvcnQgZm91cmllck1ha2luZ1dhdmVzIGZyb20gJy4uLy4uL2ZvdXJpZXJNYWtpbmdXYXZlcy5qcyc7XHJcbmltcG9ydCBGTVdDb25zdGFudHMgZnJvbSAnLi4vRk1XQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IEVtcGhhc2l6ZWRIYXJtb25pY3MgZnJvbSAnLi4vbW9kZWwvRW1waGFzaXplZEhhcm1vbmljcy5qcyc7XHJcbmltcG9ydCBIYXJtb25pYyBmcm9tICcuLi9tb2RlbC9IYXJtb25pYy5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgVFJBQ0tfV0lEVEggPSA0MDsgLy8gdHJhY2sgaGVpZ2h0IGlzIHNwZWNpZmllZCBpbiBjb25zdHJ1Y3RvciBvcHRpb25zXHJcblxyXG4vLyBEaW1lbnNpb24yIGluc3RhbmNlcyBtdXN0IGJlIHN3YXBwZWQsIGJlY2F1c2UgVlNsaWRlciByb3RhdGVzIGl0cyB0aHVtYiBhbmQgdHJhY2sgLTkwIGRlZ3JlZXMuXHJcbi8vIFNvIHdlJ2xsIHNwZWNpZnkgdGhlIGRpbWVuc2lvbnMgb2Ygb3VyIGN1c3RvbSB0aHVtYiBhbmQgdHJhY2sgaW4gdmVydGljYWwgb3JpZW50YXRpb24sIGNyZWF0ZVxyXG4vLyBvdXIgY3VzdG9tIHRodW1iIGFuZCB0cmFjayBpbiBob3Jpem9udGFsIG9yaWVudGF0aW9uLCBhbmQgU2xpZGVyIHdpbGwgcm90YXRlIHRoZW0gaW50byB2ZXJ0aWNhbCBvcmllbnRhdGlvbi5cclxuLy8gUHJldHR5IGdyb3NzLCBlaD8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9mb3VyaWVyLW1ha2luZy13YXZlcy9pc3N1ZXMvMTc1XHJcbmNvbnN0IFRIVU1CX1NJWkUgPSBuZXcgRGltZW5zaW9uMiggVFJBQ0tfV0lEVEggLSAxNSwgOCApLnN3YXBwZWQoKTtcclxuY29uc3QgVEhVTUJfVE9VQ0hfQVJFQV9ESUxBVElPTiA9IG5ldyBEaW1lbnNpb24yKCAxMCwgNCApLnN3YXBwZWQoKTtcclxuY29uc3QgVEhVTUJfTU9VU0VfQVJFQV9ESUxBVElPTiA9IG5ldyBEaW1lbnNpb24yKCAxMCwgNCApLnN3YXBwZWQoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFtcGxpdHVkZVNsaWRlciBleHRlbmRzIFNsaWRlciB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7SGFybW9uaWN9IGhhcm1vbmljXHJcbiAgICogQHBhcmFtIHtFbXBoYXNpemVkSGFybW9uaWNzfSBlbXBoYXNpemVkSGFybW9uaWNzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBoYXJtb25pYywgZW1waGFzaXplZEhhcm1vbmljcywgb3B0aW9ucyApIHtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBoYXJtb25pYyBpbnN0YW5jZW9mIEhhcm1vbmljICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBlbXBoYXNpemVkSGFybW9uaWNzIGluc3RhbmNlb2YgRW1waGFzaXplZEhhcm1vbmljcyApO1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG5cclxuICAgICAgLy8ge251bWJlcn0gaGVpZ2h0IG9mIHRoZSB0cmFja1xyXG4gICAgICB0cmFja0hlaWdodDogMTIwLFxyXG5cclxuICAgICAgLy8ge251bWJlcn0gc25hcCB0byB0aGlzIGludGVydmFsIHdoZW4gdXNpbmcgbW91c2UvdG91Y2gsIHVubGVzcyB0aGUgdmFsdWUgaXMgbWluIG9yIG1heFxyXG4gICAgICBtb3VzZVRvdWNoU3RlcDogRk1XQ29uc3RhbnRzLkRJU0NSRVRFX0FNUExJVFVERV9TVEVQLFxyXG5cclxuICAgICAgLy8gU2xpZGVyIG9wdGlvbnNcclxuICAgICAgc3RhcnREcmFnOiBfLm5vb3AsXHJcbiAgICAgIGVuZERyYWc6IF8ubm9vcCxcclxuICAgICAgb3JpZW50YXRpb246IE9yaWVudGF0aW9uLlZFUlRJQ0FMLFxyXG4gICAgICB2YWx1ZUNoYW5nZVNvdW5kR2VuZXJhdG9yT3B0aW9uczoge1xyXG4gICAgICAgIG51bWJlck9mTWlkZGxlVGhyZXNob2xkczogKCBoYXJtb25pYy5hbXBsaXR1ZGVQcm9wZXJ0eS5yYW5nZS5nZXRMZW5ndGgoKSAvIEZNV0NvbnN0YW50cy5ESVNDUkVURV9BTVBMSVRVREVfU1RFUCApIC0gMVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gcGRvbSBvcHRpb25zXHJcbiAgICAgIC8vIHNsaWRlciBzdGVwcywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9mb3VyaWVyLW1ha2luZy13YXZlcy9pc3N1ZXMvNTNcclxuICAgICAga2V5Ym9hcmRTdGVwOiBGTVdDb25zdGFudHMuRElTQ1JFVEVfQU1QTElUVURFX0tFWUJPQVJEX1NURVAsIC8vIHVzZWQgYnkgYWxsIGFsdGVybmF0aXZlLWlucHV0IGRldmljZXNcclxuICAgICAgc2hpZnRLZXlib2FyZFN0ZXA6IEZNV0NvbnN0YW50cy5ESVNDUkVURV9BTVBMSVRVREVfU0hJRlRfS0VZQk9BUkRfU1RFUCwgLy8gZmluZXIgZ3JhaW4sIHVzZWQgYnkga2V5Ym9hcmQgb25seVxyXG4gICAgICBwYWdlS2V5Ym9hcmRTdGVwOiBGTVdDb25zdGFudHMuRElTQ1JFVEVfQU1QTElUVURFX1BBR0VfS0VZQk9BUkRfU1RFUCwgLy8gY29hcnNlciBncmFpbiwgdXNlZCBieSBrZXlib2FyZCBvbmx5XHJcblxyXG4gICAgICAvLyBwaGV0LWlvIG9wdGlvbnNcclxuICAgICAgdGFuZGVtOiBUYW5kZW0uUkVRVUlSRURcclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLnNoaWZ0S2V5Ym9hcmRTdGVwIDw9IG9wdGlvbnMua2V5Ym9hcmRTdGVwICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLnBhZ2VLZXlib2FyZFN0ZXAgPj0gb3B0aW9ucy5rZXlib2FyZFN0ZXAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG9wdGlvbnMua2V5Ym9hcmRTdGVwID49IG9wdGlvbnMubW91c2VUb3VjaFN0ZXAsICdzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvNjk4JyApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggb3B0aW9ucy5wYWdlS2V5Ym9hcmRTdGVwID49IG9wdGlvbnMubW91c2VUb3VjaFN0ZXAsICdzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvNjk4JyApO1xyXG5cclxuICAgIGNvbnN0IGFtcGxpdHVkZVJhbmdlID0gaGFybW9uaWMuYW1wbGl0dWRlUHJvcGVydHkucmFuZ2U7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIW9wdGlvbnMuY29uc3RyYWluVmFsdWUsICdBbXBsaXR1ZGVTbGlkZXIgc2V0cyBjb25zdHJhaW5WYWx1ZScgKTtcclxuICAgIG9wdGlvbnMuY29uc3RyYWluVmFsdWUgPSBhbXBsaXR1ZGUgPT4ge1xyXG4gICAgICBpZiAoIGFtcGxpdHVkZSAhPT0gYW1wbGl0dWRlUmFuZ2UubWluICYmIGFtcGxpdHVkZSAhPT0gYW1wbGl0dWRlUmFuZ2UubWF4ICkge1xyXG4gICAgICAgIGFtcGxpdHVkZSA9IFV0aWxzLnJvdW5kVG9JbnRlcnZhbCggYW1wbGl0dWRlLCBvcHRpb25zLm1vdXNlVG91Y2hTdGVwICk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFtcGxpdHVkZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ3VzdG9tIHRodW1iXHJcbiAgICBjb25zdCB0aHVtYk5vZGUgPSBuZXcgR3JpcHB5VGh1bWIoIFRIVU1CX1NJWkUsIGhhcm1vbmljLCB7XHJcbiAgICAgIHRhbmRlbTogb3B0aW9ucy50YW5kZW0uY3JlYXRlVGFuZGVtKCBTbGlkZXIuVEhVTUJfTk9ERV9UQU5ERU1fTkFNRSApXHJcbiAgICB9ICk7XHJcbiAgICB0aHVtYk5vZGUudG91Y2hBcmVhID0gdGh1bWJOb2RlLmxvY2FsQm91bmRzLmRpbGF0ZWRYWSggVEhVTUJfVE9VQ0hfQVJFQV9ESUxBVElPTi53aWR0aCwgVEhVTUJfVE9VQ0hfQVJFQV9ESUxBVElPTi5oZWlnaHQgKTtcclxuICAgIHRodW1iTm9kZS5tb3VzZUFyZWEgPSB0aHVtYk5vZGUubG9jYWxCb3VuZHMuZGlsYXRlZFhZKCBUSFVNQl9NT1VTRV9BUkVBX0RJTEFUSU9OLndpZHRoLCBUSFVNQl9NT1VTRV9BUkVBX0RJTEFUSU9OLmhlaWdodCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIW9wdGlvbnMudGh1bWJOb2RlLCAnQW1wbGl0dWRlU2xpZGVyIHNldHMgdGh1bWJOb2RlJyApO1xyXG4gICAgb3B0aW9ucy50aHVtYk5vZGUgPSB0aHVtYk5vZGU7XHJcblxyXG4gICAgLy8gQ3VzdG9tIHRyYWNrXHJcbiAgICBjb25zdCB0cmFja05vZGUgPSBuZXcgQmFyVHJhY2soIGhhcm1vbmljLCBhbXBsaXR1ZGVSYW5nZSwge1xyXG5cclxuICAgICAgLy8gUHJvcGFnYXRlIGRyYWcgYmVoYXZpb3IgdG8gb3VyIGN1c3RvbSB0cmFja1xyXG4gICAgICBzdGFydERyYWc6IG9wdGlvbnMuc3RhcnREcmFnLFxyXG4gICAgICBlbmREcmFnOiBvcHRpb25zLmVuZERyYWcsXHJcbiAgICAgIGNvbnN0cmFpblZhbHVlOiBvcHRpb25zLmNvbnN0cmFpblZhbHVlLFxyXG5cclxuICAgICAgLy8gU2VlIG5vdGUgYWJvdmUgYWJvdXQgd2h5IHN3YXBwZWQgaXMgbmVjZXNzYXJ5LlxyXG4gICAgICBzaXplOiBuZXcgRGltZW5zaW9uMiggVFJBQ0tfV0lEVEgsIG9wdGlvbnMudHJhY2tIZWlnaHQgKS5zd2FwcGVkKCksXHJcbiAgICAgIHRhbmRlbTogb3B0aW9ucy50YW5kZW0uY3JlYXRlVGFuZGVtKCBTbGlkZXIuVFJBQ0tfTk9ERV9UQU5ERU1fTkFNRSApXHJcbiAgICB9ICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhb3B0aW9ucy50cmFja05vZGUsICdBbXBsaXR1ZGVTbGlkZXIgc2V0cyB0cmFja05vZGUnICk7XHJcbiAgICBvcHRpb25zLnRyYWNrTm9kZSA9IHRyYWNrTm9kZTtcclxuXHJcbiAgICBzdXBlciggaGFybW9uaWMuYW1wbGl0dWRlUHJvcGVydHksIGFtcGxpdHVkZVJhbmdlLCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gV2hldGhlciB0aGlzIHNsaWRlciBoYXMga2V5Ym9hcmQgZm9jdXMuXHJcbiAgICBjb25zdCBoYXNGb2N1c1Byb3BlcnR5ID0gbmV3IEJvb2xlYW5Qcm9wZXJ0eSggdGhpcy5mb2N1c2VkICk7XHJcbiAgICB0aGlzLmFkZElucHV0TGlzdGVuZXIoIHtcclxuICAgICAgZm9jdXM6ICgpID0+IHsgaGFzRm9jdXNQcm9wZXJ0eS52YWx1ZSA9IHRydWU7IH0sXHJcbiAgICAgIGJsdXI6ICgpID0+IHsgaGFzRm9jdXNQcm9wZXJ0eS52YWx1ZSA9IGZhbHNlOyB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8ge0Rlcml2ZWRQcm9wZXJ0eS48Ym9vbGVhbj59XHJcbiAgICAvLyBUaGUgYXNzb2NpYXRlZCBoYXJtb25pYyBpcyBlbXBoYXNpemVkIGlmIHdlJ3JlIGludGVyYWN0aW5nIHdpdGggdGhlIHNsaWRlciBpbiBzb21lIHdheS5cclxuICAgIGNvbnN0IGlzRW1waGFzaXplZFByb3BlcnR5ID0gRGVyaXZlZFByb3BlcnR5Lm9yKFxyXG4gICAgICBbIHRoaXMudGh1bWJEcmFnTGlzdGVuZXIuaXNIaWdobGlnaHRlZFByb3BlcnR5LCB0cmFja05vZGUuaXNIaWdobGlnaHRlZFByb3BlcnR5LCBoYXNGb2N1c1Byb3BlcnR5IF1cclxuICAgICk7XHJcblxyXG4gICAgLy8gRW1waGFzaXplIHRoZSBhc3NvY2lhdGVkIGhhcm1vbmljLlxyXG4gICAgaXNFbXBoYXNpemVkUHJvcGVydHkubGF6eUxpbmsoIGlzRW1waGFzaXplZCA9PiB7XHJcbiAgICAgIGlmICggaXNFbXBoYXNpemVkICkge1xyXG4gICAgICAgIGVtcGhhc2l6ZWRIYXJtb25pY3MucHVzaCggdGhpcywgaGFybW9uaWMgKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICggZW1waGFzaXplZEhhcm1vbmljcy5pbmNsdWRlc05vZGUoIHRoaXMgKSApIHtcclxuICAgICAgICBlbXBoYXNpemVkSGFybW9uaWNzLnJlbW92ZSggdGhpcyApO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gSW50ZXJydXB0IGludGVyYWN0aW9uIHdoZW4gdmlzaWJpbGl0eSBjaGFuZ2VzLlxyXG4gICAgdGhpcy52aXNpYmxlUHJvcGVydHkubGluayggKCkgPT4gdGhpcy5pbnRlcnJ1cHRTdWJ0cmVlSW5wdXQoKSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ2Rpc3Bvc2UgaXMgbm90IHN1cHBvcnRlZCwgZXhpc3RzIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbScgKTtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHcmlwcHlUaHVtYiBpcyBhIGN1c3RvbSB0aHVtYiBmb3IgQW1wbGl0dWRlU2xpZGVyLiBJdCBoYXMgZ3JpcHB5IGRvdHMgb24gaXQgdGhhdCBhcmUgY29sb3ItY29kZWQgdG8gdGhlIGhhcm1vbmljLlxyXG4gKiBDcmVhdGVkIGluIGhvcml6b250YWwgb3JpZW50YXRpb24gYmVjYXVzZSBWU2xpZGVyIHdpbGwgcm90YXRlIGl0IC05MCBkZWdyZWVzIHRvIHZlcnRpY2FsIG9yaWVudGF0aW9uLlxyXG4gKi9cclxuY2xhc3MgR3JpcHB5VGh1bWIgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtEaW1lbnNpb24yfSB0aHVtYlNpemVcclxuICAgKiBAcGFyYW0ge0hhcm1vbmljfSBoYXJtb25pY1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggdGh1bWJTaXplLCBoYXJtb25pYywgb3B0aW9ucyApIHtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aHVtYlNpemUgaW5zdGFuY2VvZiBEaW1lbnNpb24yICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBoYXJtb25pYyBpbnN0YW5jZW9mIEhhcm1vbmljICk7XHJcblxyXG4gICAgb3B0aW9ucyA9IG1lcmdlKCB7XHJcbiAgICAgIHRhbmRlbTogVGFuZGVtLlJFUVVJUkVEXHJcbiAgICB9LCBvcHRpb25zICk7XHJcblxyXG4gICAgY29uc3QgcmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSggMCwgMCwgdGh1bWJTaXplLndpZHRoLCB0aHVtYlNpemUuaGVpZ2h0LCB7XHJcbiAgICAgIGZpbGw6IENvbG9yLmdyYXlDb2xvciggMjAwICksXHJcbiAgICAgIHN0cm9rZTogJ2JsYWNrJyxcclxuICAgICAgY29ybmVyUmFkaXVzOiAyXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gQSByb3cgb2YgZG90cywgY29sb3ItY29kZWQgdG8gdGhlIGhhcm1vbmljXHJcbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBjb2RlIGlzIGFjdHVhbGx5IGRyYXdpbmcgYSBjb2x1bW4gb2YgZG90cywgYmVjYXVzZSBWU2xpZGVyIHJvdGF0ZXMgaXRzIHRodW1iIC05MCBkZWdyZWVzLlxyXG4gICAgY29uc3QgbnVtYmVyT2ZEb3RzID0gMztcclxuICAgIGNvbnN0IHhNYXJnaW4gPSAyLjU7XHJcbiAgICBjb25zdCB5U3BhY2luZyA9IHJlY3RhbmdsZS5oZWlnaHQgLyAoIG51bWJlck9mRG90cyArIDEgKTtcclxuICAgIGNvbnN0IGRvdFJhZGl1cyA9ICggcmVjdGFuZ2xlLndpZHRoIC0gMiAqIHhNYXJnaW4gKSAvIDI7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBkb3RSYWRpdXMgPiAwLCBgaW52YWxpZCBkb3RSYWRpdXM6ICR7ZG90UmFkaXVzfWAgKTtcclxuICAgIGNvbnN0IGRvdHNTaGFwZSA9IG5ldyBTaGFwZSgpO1xyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEb3RzOyBpKysgKSB7XHJcbiAgICAgIGNvbnN0IHkgPSBpICogeVNwYWNpbmc7XHJcbiAgICAgIGRvdHNTaGFwZS5tb3ZlVG8oIGRvdFJhZGl1cywgeSApO1xyXG4gICAgICBkb3RzU2hhcGUuYXJjKCAwLCB5LCBkb3RSYWRpdXMsIDAsIDIgKiBNYXRoLlBJICk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkb3RzTm9kZSA9IG5ldyBQYXRoKCBkb3RzU2hhcGUsIHtcclxuICAgICAgZmlsbDogaGFybW9uaWMuY29sb3JQcm9wZXJ0eSxcclxuICAgICAgc3Ryb2tlOiAnYmxhY2snLFxyXG4gICAgICBsaW5lV2lkdGg6IDAuNSxcclxuICAgICAgY2VudGVyOiByZWN0YW5nbGUuY2VudGVyXHJcbiAgICB9ICk7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIW9wdGlvbnMuY2hpbGRyZW4sICdHcmlwcHlUaHVtYiBzZXRzIGNoaWxkcmVuJyApO1xyXG4gICAgb3B0aW9ucy5jaGlsZHJlbiA9IFsgcmVjdGFuZ2xlLCBkb3RzTm9kZSBdO1xyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCAnZGlzcG9zZSBpcyBub3Qgc3VwcG9ydGVkLCBleGlzdHMgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgc2ltJyApO1xyXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEJhclRyYWNrIGlzIGEgY3VzdG9tIHRyYWNrIGZvciBBbXBsaXR1ZGVTbGlkZXIuXHJcbiAqIEl0IGZpbGxzIGEgY29sb3JlZCBiYXIgdGhhdCBncm93cyB1cCBhbmQgZG93biBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIHRyYWNrLlxyXG4gKiBDcmVhdGVkIGluIGhvcml6b250YWwgb3JpZW50YXRpb24gYmVjYXVzZSBWU2xpZGVyIHdpbGwgcm90YXRlIGl0IC05MCBkZWdyZWVzIHRvIHZlcnRpY2FsIG9yaWVudGF0aW9uLlxyXG4gKi9cclxuY2xhc3MgQmFyVHJhY2sgZXh0ZW5kcyBTbGlkZXJUcmFjayB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7SGFybW9uaWN9IGhhcm1vbmljXHJcbiAgICogQHBhcmFtIHtSYW5nZX0gYW1wbGl0dWRlUmFuZ2VcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGhhcm1vbmljLCBhbXBsaXR1ZGVSYW5nZSwgb3B0aW9ucyApIHtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBoYXJtb25pYyBpbnN0YW5jZW9mIEhhcm1vbmljICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBhbXBsaXR1ZGVSYW5nZSBpbnN0YW5jZW9mIFJhbmdlICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBhbXBsaXR1ZGVSYW5nZS5nZXRDZW50ZXIoKSA9PT0gMCwgJ2ltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhhdCByYW5nZSBpcyBzeW1tZXRyaWMnICk7XHJcblxyXG4gICAgb3B0aW9ucyA9IG1lcmdlKCB7XHJcbiAgICAgIHNpemU6IG5ldyBEaW1lbnNpb24yKCAxMCwgMTAgKSxcclxuICAgICAgdGFuZGVtOiBUYW5kZW0uUkVRVUlSRURcclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBUbyBpbXByb3ZlIHJlYWRhYmlsaXR5XHJcbiAgICBjb25zdCB0cmFja1dpZHRoID0gb3B0aW9ucy5zaXplLndpZHRoO1xyXG4gICAgY29uc3QgdHJhY2tIZWlnaHQgPSBvcHRpb25zLnNpemUuaGVpZ2h0O1xyXG5cclxuICAgIGNvbnN0IGludmlzaWJsZVRyYWNrTm9kZSA9IG5ldyBSZWN0YW5nbGUoIDAsIDAsIHRyYWNrV2lkdGgsIHRyYWNrSGVpZ2h0LCB7XHJcbiAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgIHN0cm9rZTogcGhldC5jaGlwcGVyLnF1ZXJ5UGFyYW1ldGVycy5kZXYgPyAncmVkJyA6IG51bGwsXHJcbiAgICAgIGxpbmVXaWR0aDogMC4yNVxyXG4gICAgfSApO1xyXG5cclxuICAgIGNvbnN0IHZpc2libGVUcmFja05vZGUgPSBuZXcgUmVjdGFuZ2xlKCAwLCAwLCB0cmFja1dpZHRoLCB0cmFja0hlaWdodCwge1xyXG4gICAgICBmaWxsOiBoYXJtb25pYy5jb2xvclByb3BlcnR5LFxyXG4gICAgICBzdHJva2U6ICdibGFjaydcclxuICAgIH0gKTtcclxuXHJcbiAgICBjb25zdCB0cmFja05vZGUgPSBuZXcgTm9kZSgge1xyXG4gICAgICBjaGlsZHJlbjogWyBpbnZpc2libGVUcmFja05vZGUsIHZpc2libGVUcmFja05vZGUgXVxyXG4gICAgfSApO1xyXG5cclxuICAgIHN1cGVyKCBoYXJtb25pYy5hbXBsaXR1ZGVQcm9wZXJ0eSwgdHJhY2tOb2RlLCBhbXBsaXR1ZGVSYW5nZSwgb3B0aW9ucyApO1xyXG5cclxuICAgIC8vIFdoZW4gdGhlIGFtcGxpdHVkZSBjaGFuZ2VzLCByZWRyYXcgdGhlIHRyYWNrIHRvIG1ha2UgaXQgbG9vayBsaWtlIGEgYmFyIGV4dGVuZHMgdXAgb3IgZG93biBmcm9tIGFtcGxpdHVkZSA9IDAuXHJcbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBjb2RlIGlzIGFjdHVhbGx5IGV4dGVuZGluZyBsZWZ0IG9yIHJpZ2h0LCBiZWNhdXNlIFZTbGlkZXIgcm90YXRlcyBpdHMgdHJhY2sgLTkwIGRlZ3JlZXMuXHJcbiAgICBjb25zdCBhbXBsaXR1ZGVMaXN0ZW5lciA9IGFtcGxpdHVkZSA9PiB7XHJcbiAgICAgIHZpc2libGVUcmFja05vZGUudmlzaWJsZSA9ICggYW1wbGl0dWRlICE9PSAwICk7XHJcbiAgICAgIGlmICggYW1wbGl0dWRlID09PSAwICkge1xyXG4gICAgICAgIHZpc2libGVUcmFja05vZGUuc2V0UmVjdCggMCwgMCwgMSwgMSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCBhbXBsaXR1ZGUgPiAwICkge1xyXG4gICAgICAgIGNvbnN0IGJhcldpZHRoID0gKCB0cmFja1dpZHRoIC8gMiApICogYW1wbGl0dWRlIC8gYW1wbGl0dWRlUmFuZ2UubWF4O1xyXG4gICAgICAgIHZpc2libGVUcmFja05vZGUuc2V0UmVjdCggdHJhY2tXaWR0aCAvIDIsIDAsIGJhcldpZHRoLCB0cmFja0hlaWdodCApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGJhcldpZHRoID0gKCB0cmFja1dpZHRoIC8gMiApICogYW1wbGl0dWRlIC8gYW1wbGl0dWRlUmFuZ2UubWluO1xyXG4gICAgICAgIHZpc2libGVUcmFja05vZGUuc2V0UmVjdCggKCB0cmFja1dpZHRoIC8gMiApIC0gYmFyV2lkdGgsIDAsIGJhcldpZHRoLCB0cmFja0hlaWdodCApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgaGFybW9uaWMuYW1wbGl0dWRlUHJvcGVydHkubGluayggYW1wbGl0dWRlTGlzdGVuZXIgKTtcclxuXHJcbiAgICAvLyBXaGVuIHRoZSBjdXJzb3IgaXMgb3ZlciB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZSB0cmFjaywgaXQgaXMgY29uc2lkZXJlZCBoaWdobGlnaHRlZC5cclxuICAgIGNvbnN0IHZpc2libGVUcmFja1ByZXNzTGlzdGVuZXIgPSBuZXcgUHJlc3NMaXN0ZW5lcigge1xyXG4gICAgICBhdHRhY2g6IGZhbHNlIC8vIHNvIHRoYXQgdGhlIERyYWdMaXN0ZW5lciBmb3IgdGhlIHRyYWNrIGlzbid0IGlnbm9yZWRcclxuICAgIH0gKTtcclxuICAgIHZpc2libGVUcmFja05vZGUuYWRkSW5wdXRMaXN0ZW5lciggdmlzaWJsZVRyYWNrUHJlc3NMaXN0ZW5lciApO1xyXG5cclxuICAgIC8vIEBwdWJsaWMge0Rlcml2ZWRQcm9wZXJ0eS48Ym9vbGVhbj59XHJcbiAgICAvLyBUaGlzIHRlbGxzIHVzIHdoZW4gdGhlIHRyYWNrIHNob3VsZCBiZSBjb25zaWRlcmVkIGhpZ2hsaWdodGVkLiBXZSBjYW4ndCBzaW1wbHkgbG9vayBhdFxyXG4gICAgLy8gdGhpcy5kcmFnTGlzdGVuZXIuaXNIaWdobGlnaHRlZFByb3BlcnR5LCBiZWNhdXNlIHRoYXQgd2lsbCBpbmNsdWRlIHRoZSBpbnZpc2libGUgcG9ydGlvbiBvZiB0aGUgdHJhY2suXHJcbiAgICAvLyBUaGlzIGlzIHVzZWQgdG8gZW1waGFzaXplIHRoZSBhc3NvY2lhdGVkIGhhcm1vbmljJ3MgcGxvdCBpbiB0aGUgSGFybW9uaWNzIGNoYXJ0LiBTZWUgaXNFbXBoYXNpemVkUHJvcGVydHlcclxuICAgIC8vIGluIEFtcGxpdHVkZVNsaWRlciBhYm92ZS5cclxuICAgIHRoaXMuaXNIaWdobGlnaHRlZFByb3BlcnR5ID0gbmV3IERlcml2ZWRQcm9wZXJ0eShcclxuICAgICAgWyB0aGlzLmRyYWdMaXN0ZW5lci5pc1ByZXNzZWRQcm9wZXJ0eSwgdmlzaWJsZVRyYWNrUHJlc3NMaXN0ZW5lci5pc092ZXJQcm9wZXJ0eSBdLFxyXG4gICAgICAoIGlzUHJlc3NlZCwgaXNPdmVyVmlzaWJsZSApID0+ICggaXNQcmVzc2VkIHx8IGlzT3ZlclZpc2libGUgKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cclxuICBkaXNwb3NlKCkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsICdkaXNwb3NlIGlzIG5vdCBzdXBwb3J0ZWQsIGV4aXN0cyBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0nICk7XHJcbiAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mb3VyaWVyTWFraW5nV2F2ZXMucmVnaXN0ZXIoICdBbXBsaXR1ZGVTbGlkZXInLCBBbXBsaXR1ZGVTbGlkZXIgKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxlQUFlLE1BQU0sd0NBQXdDO0FBQ3BFLE9BQU9DLGVBQWUsTUFBTSx3Q0FBd0M7QUFDcEUsT0FBT0MsVUFBVSxNQUFNLGtDQUFrQztBQUN6RCxPQUFPQyxLQUFLLE1BQU0sNkJBQTZCO0FBQy9DLE9BQU9DLEtBQUssTUFBTSw2QkFBNkI7QUFDL0MsU0FBU0MsS0FBSyxRQUFRLGdDQUFnQztBQUN0RCxPQUFPQyxLQUFLLE1BQU0sbUNBQW1DO0FBQ3JELE9BQU9DLFdBQVcsTUFBTSx5Q0FBeUM7QUFDakUsU0FBU0MsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsYUFBYSxFQUFFQyxTQUFTLFFBQVEsbUNBQW1DO0FBQy9GLE9BQU9DLE1BQU0sTUFBTSw4QkFBOEI7QUFDakQsT0FBT0MsV0FBVyxNQUFNLG1DQUFtQztBQUMzRCxPQUFPQyxNQUFNLE1BQU0saUNBQWlDO0FBQ3BELE9BQU9DLGtCQUFrQixNQUFNLDZCQUE2QjtBQUM1RCxPQUFPQyxZQUFZLE1BQU0sb0JBQW9CO0FBQzdDLE9BQU9DLG1CQUFtQixNQUFNLGlDQUFpQztBQUNqRSxPQUFPQyxRQUFRLE1BQU0sc0JBQXNCOztBQUUzQztBQUNB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