// Copyright 2015-2022, University of Colorado Boulder

/**
 * Scenery Node that contains an enclosure for a positive, a negative electric charge and an electric sensor.
 *
 * @author Martin Veillette (Berea College)
 */

import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import { HBox, Node, Text } from '../../../../scenery/js/imports.js';
import Panel from '../../../../sun/js/Panel.js';
import chargesAndFields from '../../chargesAndFields.js';
import ChargesAndFieldsStrings from '../../ChargesAndFieldsStrings.js';
import ChargesAndFieldsColors from '../ChargesAndFieldsColors.js';
import ChargesAndFieldsConstants from '../ChargesAndFieldsConstants.js';
import ChargedParticleRepresentationNode from './ChargedParticleRepresentationNode.js';
import ElectricFieldSensorRepresentationNode from './ElectricFieldSensorRepresentationNode.js';
const minusOneNanoCString = ChargesAndFieldsStrings.minusOneNanoC;
const plusOneNanoCString = ChargesAndFieldsStrings.plusOneNanoC;
const sensorsString = ChargesAndFieldsStrings.sensors;
const HORIZONTAL_SPACING = 60;
const VERTICAL_SPACING = 25;
const Y_MARGIN = 10;
class ChargesAndSensorsPanel extends Panel {
  /**
   * Enclosure that contains the charges and sensor
   *
   * @param {ChargesAndFieldsModel} model
   * @param {ChargesAndFieldsScreenView} screenView
   * @param {Function} hookDragHandler - function(modelElement,event) Called when the element is dropped into the play
   *                                     area, hooks up the provided event to the modelElement's corresponding view's
   *                                     drag handler (starts the drag).
   * @param {Property.<boolean>} canAddMoreChargedParticlesProperty - Whether more charged particles can be added.
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Tandem} tandem
   */
  constructor(model, screenView, hookDragHandler, canAddMoreChargedParticlesProperty, modelViewTransform, tandem) {
    // @private {Array.<Node>}
    const draggableItems = [];

    /**
     * @param {Tandem} itemTandem
     * @param {string} label
     * @param {Function} createModelElement - Adds one of these items to the model, and returns the model object.
     * @param {Node} previewNode
     * @param {Property.<boolean>} isVisibleProperty
     */
    function createDraggableItem(itemTandem, label, createModelElement, previewNode, isVisibleProperty) {
      const labelText = new Text(label, {
        font: ChargesAndFieldsConstants.ENCLOSURE_LABEL_FONT,
        fill: ChargesAndFieldsColors.enclosureTextProperty,
        centerX: 0,
        maxWidth: 200
      });
      const node = new Node({
        children: [previewNode, labelText],
        cursor: 'pointer',
        tandem: itemTandem
      });

      // layout
      labelText.top = 0;
      previewNode.centerY = -VERTICAL_SPACING;

      // When pressed, creates a model element and triggers press() on the corresponding view
      node.addInputListener({
        down: event => {
          // Don't try to start drags with a right mouse button or an attached pointer.
          if (!event.canStartPress()) {
            return;
          }

          // Representation node position, so that when being "disposed" it will animate back towards the right place.
          const initialViewPosition = previewNode.getUniqueTrailTo(screenView).getAncestorMatrix().timesVector2(Vector2.ZERO);

          // Create the new model element with its initial position.
          const modelElement = createModelElement(modelViewTransform.viewToModelPosition(initialViewPosition));
          modelElement.isActiveProperty.set(false);

          // Hook up the initial drag to the corresponding view element
          hookDragHandler(modelElement, event);
        }
      });
      node.mouseArea = node.localBounds;
      node.touchArea = node.localBounds.dilatedXY(HORIZONTAL_SPACING / 2, Y_MARGIN);
      isVisibleProperty.linkAttribute(node, 'visible');
      draggableItems.push(node);
      return node;
    }

    // {Property.<boolean>}
    const positiveVisibleProperty = new DerivedProperty([canAddMoreChargedParticlesProperty, model.allowNewPositiveChargesProperty], (canAdd, allowNew) => canAdd && allowNew);

    // {Property.<boolean>}
    const negativeVisibleProperty = new DerivedProperty([canAddMoreChargedParticlesProperty, model.allowNewNegativeChargesProperty], (canAdd, allowNew) => canAdd && allowNew);

    // {Property.<boolean>}
    const electricFieldSensorVisibleProperty = model.allowNewElectricFieldSensorsProperty;
    const hboxContent = new HBox({
      align: 'bottom',
      spacing: HORIZONTAL_SPACING,
      children: [createDraggableItem(tandem.createTandem('positiveCharge'), plusOneNanoCString, initialPosition => model.addPositiveCharge(initialPosition), new ChargedParticleRepresentationNode(1), positiveVisibleProperty), createDraggableItem(tandem.createTandem('negativeCharge'), minusOneNanoCString, initialPosition => model.addNegativeCharge(initialPosition), new ChargedParticleRepresentationNode(-1), negativeVisibleProperty), createDraggableItem(tandem.createTandem('electricFieldSensor'), sensorsString, initialPosition => model.addElectricFieldSensor(initialPosition), new ElectricFieldSensorRepresentationNode(), electricFieldSensorVisibleProperty)]
    });
    super(hboxContent, {
      lineWidth: ChargesAndFieldsConstants.PANEL_LINE_WIDTH,
      cornerRadius: 5,
      stroke: ChargesAndFieldsColors.enclosureBorderProperty,
      fill: ChargesAndFieldsColors.enclosureFillProperty,
      xMargin: HORIZONTAL_SPACING / 2,
      yMargin: Y_MARGIN,
      tandem: tandem
    });
    this.hboxContent = hboxContent;
    draggableItems.forEach(draggableItem => {
      draggableItem.visibleProperty.lazyLink(this.updateChildrenWithVisibility.bind(this));
    });
    this.draggableItems = draggableItems;
    this.updateChildrenWithVisibility();
  }

  /**
   * Ensures visible items are children, and invisible items are removed.
   * @private
   */
  updateChildrenWithVisibility() {
    this.hboxContent.children = this.draggableItems.filter(draggableItem => draggableItem.visible);
  }
}
chargesAndFields.register('ChargesAndSensorsPanel', ChargesAndSensorsPanel);
export default ChargesAndSensorsPanel;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEZXJpdmVkUHJvcGVydHkiLCJWZWN0b3IyIiwiSEJveCIsIk5vZGUiLCJUZXh0IiwiUGFuZWwiLCJjaGFyZ2VzQW5kRmllbGRzIiwiQ2hhcmdlc0FuZEZpZWxkc1N0cmluZ3MiLCJDaGFyZ2VzQW5kRmllbGRzQ29sb3JzIiwiQ2hhcmdlc0FuZEZpZWxkc0NvbnN0YW50cyIsIkNoYXJnZWRQYXJ0aWNsZVJlcHJlc2VudGF0aW9uTm9kZSIsIkVsZWN0cmljRmllbGRTZW5zb3JSZXByZXNlbnRhdGlvbk5vZGUiLCJtaW51c09uZU5hbm9DU3RyaW5nIiwibWludXNPbmVOYW5vQyIsInBsdXNPbmVOYW5vQ1N0cmluZyIsInBsdXNPbmVOYW5vQyIsInNlbnNvcnNTdHJpbmciLCJzZW5zb3JzIiwiSE9SSVpPTlRBTF9TUEFDSU5HIiwiVkVSVElDQUxfU1BBQ0lORyIsIllfTUFSR0lOIiwiQ2hhcmdlc0FuZFNlbnNvcnNQYW5lbCIsImNvbnN0cnVjdG9yIiwibW9kZWwiLCJzY3JlZW5WaWV3IiwiaG9va0RyYWdIYW5kbGVyIiwiY2FuQWRkTW9yZUNoYXJnZWRQYXJ0aWNsZXNQcm9wZXJ0eSIsIm1vZGVsVmlld1RyYW5zZm9ybSIsInRhbmRlbSIsImRyYWdnYWJsZUl0ZW1zIiwiY3JlYXRlRHJhZ2dhYmxlSXRlbSIsIml0ZW1UYW5kZW0iLCJsYWJlbCIsImNyZWF0ZU1vZGVsRWxlbWVudCIsInByZXZpZXdOb2RlIiwiaXNWaXNpYmxlUHJvcGVydHkiLCJsYWJlbFRleHQiLCJmb250IiwiRU5DTE9TVVJFX0xBQkVMX0ZPTlQiLCJmaWxsIiwiZW5jbG9zdXJlVGV4dFByb3BlcnR5IiwiY2VudGVyWCIsIm1heFdpZHRoIiwibm9kZSIsImNoaWxkcmVuIiwiY3Vyc29yIiwidG9wIiwiY2VudGVyWSIsImFkZElucHV0TGlzdGVuZXIiLCJkb3duIiwiZXZlbnQiLCJjYW5TdGFydFByZXNzIiwiaW5pdGlhbFZpZXdQb3NpdGlvbiIsImdldFVuaXF1ZVRyYWlsVG8iLCJnZXRBbmNlc3Rvck1hdHJpeCIsInRpbWVzVmVjdG9yMiIsIlpFUk8iLCJtb2RlbEVsZW1lbnQiLCJ2aWV3VG9Nb2RlbFBvc2l0aW9uIiwiaXNBY3RpdmVQcm9wZXJ0eSIsInNldCIsIm1vdXNlQXJlYSIsImxvY2FsQm91bmRzIiwidG91Y2hBcmVhIiwiZGlsYXRlZFhZIiwibGlua0F0dHJpYnV0ZSIsInB1c2giLCJwb3NpdGl2ZVZpc2libGVQcm9wZXJ0eSIsImFsbG93TmV3UG9zaXRpdmVDaGFyZ2VzUHJvcGVydHkiLCJjYW5BZGQiLCJhbGxvd05ldyIsIm5lZ2F0aXZlVmlzaWJsZVByb3BlcnR5IiwiYWxsb3dOZXdOZWdhdGl2ZUNoYXJnZXNQcm9wZXJ0eSIsImVsZWN0cmljRmllbGRTZW5zb3JWaXNpYmxlUHJvcGVydHkiLCJhbGxvd05ld0VsZWN0cmljRmllbGRTZW5zb3JzUHJvcGVydHkiLCJoYm94Q29udGVudCIsImFsaWduIiwic3BhY2luZyIsImNyZWF0ZVRhbmRlbSIsImluaXRpYWxQb3NpdGlvbiIsImFkZFBvc2l0aXZlQ2hhcmdlIiwiYWRkTmVnYXRpdmVDaGFyZ2UiLCJhZGRFbGVjdHJpY0ZpZWxkU2Vuc29yIiwibGluZVdpZHRoIiwiUEFORUxfTElORV9XSURUSCIsImNvcm5lclJhZGl1cyIsInN0cm9rZSIsImVuY2xvc3VyZUJvcmRlclByb3BlcnR5IiwiZW5jbG9zdXJlRmlsbFByb3BlcnR5IiwieE1hcmdpbiIsInlNYXJnaW4iLCJmb3JFYWNoIiwiZHJhZ2dhYmxlSXRlbSIsInZpc2libGVQcm9wZXJ0eSIsImxhenlMaW5rIiwidXBkYXRlQ2hpbGRyZW5XaXRoVmlzaWJpbGl0eSIsImJpbmQiLCJmaWx0ZXIiLCJ2aXNpYmxlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJDaGFyZ2VzQW5kU2Vuc29yc1BhbmVsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFNjZW5lcnkgTm9kZSB0aGF0IGNvbnRhaW5zIGFuIGVuY2xvc3VyZSBmb3IgYSBwb3NpdGl2ZSwgYSBuZWdhdGl2ZSBlbGVjdHJpYyBjaGFyZ2UgYW5kIGFuIGVsZWN0cmljIHNlbnNvci5cclxuICpcclxuICogQGF1dGhvciBNYXJ0aW4gVmVpbGxldHRlIChCZXJlYSBDb2xsZWdlKVxyXG4gKi9cclxuXHJcbmltcG9ydCBEZXJpdmVkUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9EZXJpdmVkUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IEhCb3gsIE5vZGUsIFRleHQgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgUGFuZWwgZnJvbSAnLi4vLi4vLi4vLi4vc3VuL2pzL1BhbmVsLmpzJztcclxuaW1wb3J0IGNoYXJnZXNBbmRGaWVsZHMgZnJvbSAnLi4vLi4vY2hhcmdlc0FuZEZpZWxkcy5qcyc7XHJcbmltcG9ydCBDaGFyZ2VzQW5kRmllbGRzU3RyaW5ncyBmcm9tICcuLi8uLi9DaGFyZ2VzQW5kRmllbGRzU3RyaW5ncy5qcyc7XHJcbmltcG9ydCBDaGFyZ2VzQW5kRmllbGRzQ29sb3JzIGZyb20gJy4uL0NoYXJnZXNBbmRGaWVsZHNDb2xvcnMuanMnO1xyXG5pbXBvcnQgQ2hhcmdlc0FuZEZpZWxkc0NvbnN0YW50cyBmcm9tICcuLi9DaGFyZ2VzQW5kRmllbGRzQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IENoYXJnZWRQYXJ0aWNsZVJlcHJlc2VudGF0aW9uTm9kZSBmcm9tICcuL0NoYXJnZWRQYXJ0aWNsZVJlcHJlc2VudGF0aW9uTm9kZS5qcyc7XHJcbmltcG9ydCBFbGVjdHJpY0ZpZWxkU2Vuc29yUmVwcmVzZW50YXRpb25Ob2RlIGZyb20gJy4vRWxlY3RyaWNGaWVsZFNlbnNvclJlcHJlc2VudGF0aW9uTm9kZS5qcyc7XHJcblxyXG5jb25zdCBtaW51c09uZU5hbm9DU3RyaW5nID0gQ2hhcmdlc0FuZEZpZWxkc1N0cmluZ3MubWludXNPbmVOYW5vQztcclxuY29uc3QgcGx1c09uZU5hbm9DU3RyaW5nID0gQ2hhcmdlc0FuZEZpZWxkc1N0cmluZ3MucGx1c09uZU5hbm9DO1xyXG5jb25zdCBzZW5zb3JzU3RyaW5nID0gQ2hhcmdlc0FuZEZpZWxkc1N0cmluZ3Muc2Vuc29ycztcclxuXHJcbmNvbnN0IEhPUklaT05UQUxfU1BBQ0lORyA9IDYwO1xyXG5jb25zdCBWRVJUSUNBTF9TUEFDSU5HID0gMjU7XHJcbmNvbnN0IFlfTUFSR0lOID0gMTA7XHJcblxyXG5jbGFzcyBDaGFyZ2VzQW5kU2Vuc29yc1BhbmVsIGV4dGVuZHMgUGFuZWwge1xyXG5cclxuICAvKipcclxuICAgKiBFbmNsb3N1cmUgdGhhdCBjb250YWlucyB0aGUgY2hhcmdlcyBhbmQgc2Vuc29yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NoYXJnZXNBbmRGaWVsZHNNb2RlbH0gbW9kZWxcclxuICAgKiBAcGFyYW0ge0NoYXJnZXNBbmRGaWVsZHNTY3JlZW5WaWV3fSBzY3JlZW5WaWV3XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va0RyYWdIYW5kbGVyIC0gZnVuY3Rpb24obW9kZWxFbGVtZW50LGV2ZW50KSBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBkcm9wcGVkIGludG8gdGhlIHBsYXlcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhLCBob29rcyB1cCB0aGUgcHJvdmlkZWQgZXZlbnQgdG8gdGhlIG1vZGVsRWxlbWVudCdzIGNvcnJlc3BvbmRpbmcgdmlldydzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZyBoYW5kbGVyIChzdGFydHMgdGhlIGRyYWcpLlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHkuPGJvb2xlYW4+fSBjYW5BZGRNb3JlQ2hhcmdlZFBhcnRpY2xlc1Byb3BlcnR5IC0gV2hldGhlciBtb3JlIGNoYXJnZWQgcGFydGljbGVzIGNhbiBiZSBhZGRlZC5cclxuICAgKiBAcGFyYW0ge01vZGVsVmlld1RyYW5zZm9ybTJ9IG1vZGVsVmlld1RyYW5zZm9ybVxyXG4gICAqIEBwYXJhbSB7VGFuZGVtfSB0YW5kZW1cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggbW9kZWwsXHJcbiAgICAgICAgICAgICAgIHNjcmVlblZpZXcsXHJcbiAgICAgICAgICAgICAgIGhvb2tEcmFnSGFuZGxlcixcclxuICAgICAgICAgICAgICAgY2FuQWRkTW9yZUNoYXJnZWRQYXJ0aWNsZXNQcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgbW9kZWxWaWV3VHJhbnNmb3JtLFxyXG4gICAgICAgICAgICAgICB0YW5kZW0gKSB7XHJcblxyXG4gICAgLy8gQHByaXZhdGUge0FycmF5LjxOb2RlPn1cclxuICAgIGNvbnN0IGRyYWdnYWJsZUl0ZW1zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge1RhbmRlbX0gaXRlbVRhbmRlbVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjcmVhdGVNb2RlbEVsZW1lbnQgLSBBZGRzIG9uZSBvZiB0aGVzZSBpdGVtcyB0byB0aGUgbW9kZWwsIGFuZCByZXR1cm5zIHRoZSBtb2RlbCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IHByZXZpZXdOb2RlXHJcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnR5Ljxib29sZWFuPn0gaXNWaXNpYmxlUHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlRHJhZ2dhYmxlSXRlbSggaXRlbVRhbmRlbSwgbGFiZWwsIGNyZWF0ZU1vZGVsRWxlbWVudCwgcHJldmlld05vZGUsIGlzVmlzaWJsZVByb3BlcnR5ICkge1xyXG4gICAgICBjb25zdCBsYWJlbFRleHQgPSBuZXcgVGV4dCggbGFiZWwsIHtcclxuICAgICAgICBmb250OiBDaGFyZ2VzQW5kRmllbGRzQ29uc3RhbnRzLkVOQ0xPU1VSRV9MQUJFTF9GT05ULFxyXG4gICAgICAgIGZpbGw6IENoYXJnZXNBbmRGaWVsZHNDb2xvcnMuZW5jbG9zdXJlVGV4dFByb3BlcnR5LFxyXG4gICAgICAgIGNlbnRlclg6IDAsXHJcbiAgICAgICAgbWF4V2lkdGg6IDIwMFxyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICBjb25zdCBub2RlID0gbmV3IE5vZGUoIHtcclxuICAgICAgICBjaGlsZHJlbjogW1xyXG4gICAgICAgICAgcHJldmlld05vZGUsXHJcbiAgICAgICAgICBsYWJlbFRleHRcclxuICAgICAgICBdLFxyXG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxyXG4gICAgICAgIHRhbmRlbTogaXRlbVRhbmRlbVxyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICAvLyBsYXlvdXRcclxuICAgICAgbGFiZWxUZXh0LnRvcCA9IDA7XHJcbiAgICAgIHByZXZpZXdOb2RlLmNlbnRlclkgPSAtVkVSVElDQUxfU1BBQ0lORztcclxuXHJcbiAgICAgIC8vIFdoZW4gcHJlc3NlZCwgY3JlYXRlcyBhIG1vZGVsIGVsZW1lbnQgYW5kIHRyaWdnZXJzIHByZXNzKCkgb24gdGhlIGNvcnJlc3BvbmRpbmcgdmlld1xyXG4gICAgICBub2RlLmFkZElucHV0TGlzdGVuZXIoIHtcclxuICAgICAgICBkb3duOiBldmVudCA9PiB7XHJcblxyXG4gICAgICAgICAgLy8gRG9uJ3QgdHJ5IHRvIHN0YXJ0IGRyYWdzIHdpdGggYSByaWdodCBtb3VzZSBidXR0b24gb3IgYW4gYXR0YWNoZWQgcG9pbnRlci5cclxuICAgICAgICAgIGlmICggIWV2ZW50LmNhblN0YXJ0UHJlc3MoKSApIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgICAgLy8gUmVwcmVzZW50YXRpb24gbm9kZSBwb3NpdGlvbiwgc28gdGhhdCB3aGVuIGJlaW5nIFwiZGlzcG9zZWRcIiBpdCB3aWxsIGFuaW1hdGUgYmFjayB0b3dhcmRzIHRoZSByaWdodCBwbGFjZS5cclxuICAgICAgICAgIGNvbnN0IGluaXRpYWxWaWV3UG9zaXRpb24gPSBwcmV2aWV3Tm9kZS5nZXRVbmlxdWVUcmFpbFRvKCBzY3JlZW5WaWV3ICkuZ2V0QW5jZXN0b3JNYXRyaXgoKS50aW1lc1ZlY3RvcjIoIFZlY3RvcjIuWkVSTyApO1xyXG5cclxuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IG1vZGVsIGVsZW1lbnQgd2l0aCBpdHMgaW5pdGlhbCBwb3NpdGlvbi5cclxuICAgICAgICAgIGNvbnN0IG1vZGVsRWxlbWVudCA9IGNyZWF0ZU1vZGVsRWxlbWVudCggbW9kZWxWaWV3VHJhbnNmb3JtLnZpZXdUb01vZGVsUG9zaXRpb24oIGluaXRpYWxWaWV3UG9zaXRpb24gKSApO1xyXG4gICAgICAgICAgbW9kZWxFbGVtZW50LmlzQWN0aXZlUHJvcGVydHkuc2V0KCBmYWxzZSApO1xyXG5cclxuICAgICAgICAgIC8vIEhvb2sgdXAgdGhlIGluaXRpYWwgZHJhZyB0byB0aGUgY29ycmVzcG9uZGluZyB2aWV3IGVsZW1lbnRcclxuICAgICAgICAgIGhvb2tEcmFnSGFuZGxlciggbW9kZWxFbGVtZW50LCBldmVudCApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSApO1xyXG5cclxuICAgICAgbm9kZS5tb3VzZUFyZWEgPSBub2RlLmxvY2FsQm91bmRzO1xyXG4gICAgICBub2RlLnRvdWNoQXJlYSA9IG5vZGUubG9jYWxCb3VuZHMuZGlsYXRlZFhZKCBIT1JJWk9OVEFMX1NQQUNJTkcgLyAyLCBZX01BUkdJTiApO1xyXG5cclxuICAgICAgaXNWaXNpYmxlUHJvcGVydHkubGlua0F0dHJpYnV0ZSggbm9kZSwgJ3Zpc2libGUnICk7XHJcblxyXG4gICAgICBkcmFnZ2FibGVJdGVtcy5wdXNoKCBub2RlICk7XHJcblxyXG4gICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB7UHJvcGVydHkuPGJvb2xlYW4+fVxyXG4gICAgY29uc3QgcG9zaXRpdmVWaXNpYmxlUHJvcGVydHkgPSBuZXcgRGVyaXZlZFByb3BlcnR5KFxyXG4gICAgICBbIGNhbkFkZE1vcmVDaGFyZ2VkUGFydGljbGVzUHJvcGVydHksIG1vZGVsLmFsbG93TmV3UG9zaXRpdmVDaGFyZ2VzUHJvcGVydHkgXSxcclxuICAgICAgKCBjYW5BZGQsIGFsbG93TmV3ICkgPT4gY2FuQWRkICYmIGFsbG93TmV3XHJcbiAgICApO1xyXG5cclxuICAgIC8vIHtQcm9wZXJ0eS48Ym9vbGVhbj59XHJcbiAgICBjb25zdCBuZWdhdGl2ZVZpc2libGVQcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoXHJcbiAgICAgIFsgY2FuQWRkTW9yZUNoYXJnZWRQYXJ0aWNsZXNQcm9wZXJ0eSwgbW9kZWwuYWxsb3dOZXdOZWdhdGl2ZUNoYXJnZXNQcm9wZXJ0eSBdLFxyXG4gICAgICAoIGNhbkFkZCwgYWxsb3dOZXcgKSA9PiBjYW5BZGQgJiYgYWxsb3dOZXdcclxuICAgICk7XHJcblxyXG4gICAgLy8ge1Byb3BlcnR5Ljxib29sZWFuPn1cclxuICAgIGNvbnN0IGVsZWN0cmljRmllbGRTZW5zb3JWaXNpYmxlUHJvcGVydHkgPSBtb2RlbC5hbGxvd05ld0VsZWN0cmljRmllbGRTZW5zb3JzUHJvcGVydHk7XHJcblxyXG4gICAgY29uc3QgaGJveENvbnRlbnQgPSBuZXcgSEJveCgge1xyXG4gICAgICBhbGlnbjogJ2JvdHRvbScsXHJcbiAgICAgIHNwYWNpbmc6IEhPUklaT05UQUxfU1BBQ0lORyxcclxuICAgICAgY2hpbGRyZW46IFtcclxuICAgICAgICBjcmVhdGVEcmFnZ2FibGVJdGVtKCB0YW5kZW0uY3JlYXRlVGFuZGVtKCAncG9zaXRpdmVDaGFyZ2UnICksXHJcbiAgICAgICAgICBwbHVzT25lTmFub0NTdHJpbmcsXHJcbiAgICAgICAgICBpbml0aWFsUG9zaXRpb24gPT4gbW9kZWwuYWRkUG9zaXRpdmVDaGFyZ2UoIGluaXRpYWxQb3NpdGlvbiApLFxyXG4gICAgICAgICAgbmV3IENoYXJnZWRQYXJ0aWNsZVJlcHJlc2VudGF0aW9uTm9kZSggMSApLFxyXG4gICAgICAgICAgcG9zaXRpdmVWaXNpYmxlUHJvcGVydHkgKSxcclxuXHJcbiAgICAgICAgY3JlYXRlRHJhZ2dhYmxlSXRlbSggdGFuZGVtLmNyZWF0ZVRhbmRlbSggJ25lZ2F0aXZlQ2hhcmdlJyApLFxyXG4gICAgICAgICAgbWludXNPbmVOYW5vQ1N0cmluZyxcclxuICAgICAgICAgIGluaXRpYWxQb3NpdGlvbiA9PiBtb2RlbC5hZGROZWdhdGl2ZUNoYXJnZSggaW5pdGlhbFBvc2l0aW9uICksXHJcbiAgICAgICAgICBuZXcgQ2hhcmdlZFBhcnRpY2xlUmVwcmVzZW50YXRpb25Ob2RlKCAtMSApLFxyXG4gICAgICAgICAgbmVnYXRpdmVWaXNpYmxlUHJvcGVydHkgKSxcclxuXHJcbiAgICAgICAgY3JlYXRlRHJhZ2dhYmxlSXRlbSggdGFuZGVtLmNyZWF0ZVRhbmRlbSggJ2VsZWN0cmljRmllbGRTZW5zb3InICksXHJcbiAgICAgICAgICBzZW5zb3JzU3RyaW5nLFxyXG4gICAgICAgICAgaW5pdGlhbFBvc2l0aW9uID0+IG1vZGVsLmFkZEVsZWN0cmljRmllbGRTZW5zb3IoIGluaXRpYWxQb3NpdGlvbiApLFxyXG5cclxuICAgICAgICAgIG5ldyBFbGVjdHJpY0ZpZWxkU2Vuc29yUmVwcmVzZW50YXRpb25Ob2RlKCksXHJcbiAgICAgICAgICBlbGVjdHJpY0ZpZWxkU2Vuc29yVmlzaWJsZVByb3BlcnR5IClcclxuICAgICAgXVxyXG4gICAgfSApO1xyXG5cclxuICAgIHN1cGVyKCBoYm94Q29udGVudCwge1xyXG4gICAgICBsaW5lV2lkdGg6IENoYXJnZXNBbmRGaWVsZHNDb25zdGFudHMuUEFORUxfTElORV9XSURUSCxcclxuICAgICAgY29ybmVyUmFkaXVzOiA1LFxyXG4gICAgICBzdHJva2U6IENoYXJnZXNBbmRGaWVsZHNDb2xvcnMuZW5jbG9zdXJlQm9yZGVyUHJvcGVydHksXHJcbiAgICAgIGZpbGw6IENoYXJnZXNBbmRGaWVsZHNDb2xvcnMuZW5jbG9zdXJlRmlsbFByb3BlcnR5LFxyXG4gICAgICB4TWFyZ2luOiBIT1JJWk9OVEFMX1NQQUNJTkcgLyAyLFxyXG4gICAgICB5TWFyZ2luOiBZX01BUkdJTixcclxuICAgICAgdGFuZGVtOiB0YW5kZW1cclxuICAgIH0gKTtcclxuXHJcbiAgICB0aGlzLmhib3hDb250ZW50ID0gaGJveENvbnRlbnQ7XHJcblxyXG4gICAgZHJhZ2dhYmxlSXRlbXMuZm9yRWFjaCggZHJhZ2dhYmxlSXRlbSA9PiB7XHJcbiAgICAgIGRyYWdnYWJsZUl0ZW0udmlzaWJsZVByb3BlcnR5LmxhenlMaW5rKCB0aGlzLnVwZGF0ZUNoaWxkcmVuV2l0aFZpc2liaWxpdHkuYmluZCggdGhpcyApICk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2FibGVJdGVtcyA9IGRyYWdnYWJsZUl0ZW1zO1xyXG5cclxuICAgIHRoaXMudXBkYXRlQ2hpbGRyZW5XaXRoVmlzaWJpbGl0eSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW5zdXJlcyB2aXNpYmxlIGl0ZW1zIGFyZSBjaGlsZHJlbiwgYW5kIGludmlzaWJsZSBpdGVtcyBhcmUgcmVtb3ZlZC5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHVwZGF0ZUNoaWxkcmVuV2l0aFZpc2liaWxpdHkoKSB7XHJcbiAgICB0aGlzLmhib3hDb250ZW50LmNoaWxkcmVuID0gdGhpcy5kcmFnZ2FibGVJdGVtcy5maWx0ZXIoIGRyYWdnYWJsZUl0ZW0gPT4gZHJhZ2dhYmxlSXRlbS52aXNpYmxlICk7XHJcbiAgfVxyXG59XHJcblxyXG5jaGFyZ2VzQW5kRmllbGRzLnJlZ2lzdGVyKCAnQ2hhcmdlc0FuZFNlbnNvcnNQYW5lbCcsIENoYXJnZXNBbmRTZW5zb3JzUGFuZWwgKTtcclxuZXhwb3J0IGRlZmF1bHQgQ2hhcmdlc0FuZFNlbnNvcnNQYW5lbDtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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