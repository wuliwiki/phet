// Copyright 2015-2022, University of Colorado Boulder

/**
 * View object, with a variety of Nodes stored on it to be added by the parent container. Responsible for the drawing
 * of one electricPotentialLine and its accompanying voltage labels
 *
 * A debug option can enabled the view of the (model) position points used to calculate the electric potential line.
 * The (pruned) position points that are used to draw the electric potential line can also be displayed.
 *
 * @author Martin Veillette (Berea College)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */

import Utils from '../../../../dot/js/Utils.js';
import merge from '../../../../phet-core/js/merge.js';
import StringUtils from '../../../../phetcommon/js/util/StringUtils.js';
import { Circle, DragListener, Node, Path, Rectangle, Text } from '../../../../scenery/js/imports.js';
import PhetioObject from '../../../../tandem/js/PhetioObject.js';
import IOType from '../../../../tandem/js/types/IOType.js';
import chargesAndFields from '../../chargesAndFields.js';
import ChargesAndFieldsStrings from '../../ChargesAndFieldsStrings.js';
import ChargesAndFieldsColors from '../ChargesAndFieldsColors.js';
import ChargesAndFieldsConstants from '../ChargesAndFieldsConstants.js';
const pattern0Value1UnitsString = ChargesAndFieldsStrings.pattern['0value']['1units'];
const voltageUnitString = ChargesAndFieldsStrings.voltageUnit;

// constants
// if set to true will show the (model and view) positions use in the calculation of the electric potential lines
const IS_DEBUG = phet.chipper.queryParameters.dev;
class ElectricPotentialLineView extends PhetioObject {
  /**
   * @param {ElectricPotentialLine} electricPotentialLine
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Tandem} tandem
   */
  constructor(electricPotentialLine, modelViewTransform, tandem) {
    super({
      tandem: tandem,
      phetioDynamicElement: true,
      phetioType: IOType.ObjectIO,
      phetioState: false
    });

    // @public (read-only) {Node} - the path of the potential line
    this.path = new Path(modelViewTransform.modelToViewShape(electricPotentialLine.getShape()), {
      stroke: ChargesAndFieldsColors.electricPotentialLineProperty
    });

    // @public (read-only) {Node} - label that says the voltage
    this.voltageLabel = new VoltageLabel(electricPotentialLine, modelViewTransform, tandem.createTandem('voltageLabel'));

    // @public (read-only) {Node|null} - if running in development mode, then display each sample point on the potential line
    this.circles = null;
    if (IS_DEBUG) {
      // create all the circles corresponding to the positions calculated in the model
      const electricPotentialModelCircles = new Circles(electricPotentialLine.positionArray, modelViewTransform, {
        fill: 'pink',
        radius: 1
      });

      // create all the circles corresponding to the positions used to create the shape of the electric potential line
      const electricPotentialViewCircles = new Circles(electricPotentialLine.getPrunedPositionArray(electricPotentialLine.positionArray), modelViewTransform, {
        fill: 'orange'
      });

      // no translatable strings, for debug only
      const text = new Text(`model=${electricPotentialLine.positionArray.length}    view=${electricPotentialLine.getPrunedPositionArray(electricPotentialLine.positionArray).length}`, {
        center: modelViewTransform.modelToViewPosition(electricPotentialLine.position),
        fill: 'green',
        font: ChargesAndFieldsConstants.VOLTAGE_LABEL_FONT
      });
      this.circles = new Node({
        children: [electricPotentialModelCircles, electricPotentialViewCircles, text]
      });
    }
  }

  /**
   * @public
   */
  dispose() {
    this.path.dispose();
    this.voltageLabel.dispose();
    this.circles && this.circles.dispose();
    super.dispose();
  }
}
class VoltageLabel extends Node {
  /**
   * Function that generates a voltage label for the electricPotential line
   * @param {ElectricPotentialLine} electricPotentialLine
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Tandem} tandem
   */
  constructor(electricPotentialLine, modelViewTransform, tandem) {
    super({
      cursor: 'pointer'
    });
    const electricPotential = electricPotentialLine.electricPotential;
    const position = electricPotentialLine.position;
    const dragListener = new DragListener({
      applyOffset: false,
      positionProperty: electricPotentialLine.voltageLabelPositionProperty,
      tandem: tandem.createTandem('dragListener'),
      transform: modelViewTransform,
      start: event => {
        // Move the label to the front of this layer when grabbed by the user.
        this.moveToFront();
      }
    });
    this.addInputListener(dragListener);

    // a smaller electric potential should have more precision
    const electricPotentialValueString = Math.abs(electricPotential) < 1 ? Utils.toFixed(electricPotential, 2) : Utils.toFixed(electricPotential, 1);

    // Create the voltage label for the electricPotential line
    const voltageLabelString = StringUtils.format(pattern0Value1UnitsString, electricPotentialValueString, voltageUnitString);
    const voltageLabelText = new Text(voltageLabelString, {
      font: ChargesAndFieldsConstants.VOLTAGE_LABEL_FONT,
      center: modelViewTransform.modelToViewPosition(position),
      fill: ChargesAndFieldsColors.electricPotentialLineProperty,
      tandem: tandem.createTandem('voltageLabelText')
    });

    // Create a background rectangle for the voltage label
    const backgroundRectangle = new Rectangle(0, 0, voltageLabelText.width * 1.2, voltageLabelText.height * 1.2, 3, 3, {
      center: modelViewTransform.modelToViewPosition(position),
      fill: ChargesAndFieldsColors.voltageLabelBackgroundProperty
    });
    this.addChild(backgroundRectangle); // must go first
    this.addChild(voltageLabelText);

    // finds the closest position on positionArray to the position of the cursor
    const positionFunction = cursorPosition => {
      let smallestDistanceSquared = Number.POSITIVE_INFINITY;
      let closestPosition; // {Vector2}
      electricPotentialLine.positionArray.forEach(position => {
        const distanceSquared = position.distanceSquared(cursorPosition);
        if (distanceSquared < smallestDistanceSquared) {
          smallestDistanceSquared = distanceSquared;
          closestPosition = position;
        }
      });
      if (closestPosition) {
        this.center = modelViewTransform.modelToViewPosition(closestPosition);
      }
    };
    electricPotentialLine.voltageLabelPositionProperty.link(positionFunction);

    // create a dispose function to unlink the color functions
    this.disposeVoltageLabel = () => {
      electricPotentialLine.voltageLabelPositionProperty.unlink(positionFunction);
      dragListener.dispose();
      voltageLabelText.dispose();
      backgroundRectangle.dispose();
    };
  }

  /**
   * Releases references
   * @public
   */
  dispose() {
    this.disposeVoltageLabel();
    super.dispose();
  }
}
class Circles extends Node {
  /**
   * Function that generates an array of Circles with their centers determined by the position array
   * @param {Array.<Vector2>} positionArray
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Object} [options]
   */
  constructor(positionArray, modelViewTransform, options) {
    super();
    options = merge({
      radius: 2
    }, options);

    // create and add all the circles
    positionArray.forEach(position => {
      const circle = new Circle(options.radius, options);
      circle.center = modelViewTransform.modelToViewPosition(position);
      this.addChild(circle);
    });
  }
}
chargesAndFields.register('ElectricPotentialLineView', ElectricPotentialLineView);
export default ElectricPotentialLineView;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJVdGlscyIsIm1lcmdlIiwiU3RyaW5nVXRpbHMiLCJDaXJjbGUiLCJEcmFnTGlzdGVuZXIiLCJOb2RlIiwiUGF0aCIsIlJlY3RhbmdsZSIsIlRleHQiLCJQaGV0aW9PYmplY3QiLCJJT1R5cGUiLCJjaGFyZ2VzQW5kRmllbGRzIiwiQ2hhcmdlc0FuZEZpZWxkc1N0cmluZ3MiLCJDaGFyZ2VzQW5kRmllbGRzQ29sb3JzIiwiQ2hhcmdlc0FuZEZpZWxkc0NvbnN0YW50cyIsInBhdHRlcm4wVmFsdWUxVW5pdHNTdHJpbmciLCJwYXR0ZXJuIiwidm9sdGFnZVVuaXRTdHJpbmciLCJ2b2x0YWdlVW5pdCIsIklTX0RFQlVHIiwicGhldCIsImNoaXBwZXIiLCJxdWVyeVBhcmFtZXRlcnMiLCJkZXYiLCJFbGVjdHJpY1BvdGVudGlhbExpbmVWaWV3IiwiY29uc3RydWN0b3IiLCJlbGVjdHJpY1BvdGVudGlhbExpbmUiLCJtb2RlbFZpZXdUcmFuc2Zvcm0iLCJ0YW5kZW0iLCJwaGV0aW9EeW5hbWljRWxlbWVudCIsInBoZXRpb1R5cGUiLCJPYmplY3RJTyIsInBoZXRpb1N0YXRlIiwicGF0aCIsIm1vZGVsVG9WaWV3U2hhcGUiLCJnZXRTaGFwZSIsInN0cm9rZSIsImVsZWN0cmljUG90ZW50aWFsTGluZVByb3BlcnR5Iiwidm9sdGFnZUxhYmVsIiwiVm9sdGFnZUxhYmVsIiwiY3JlYXRlVGFuZGVtIiwiY2lyY2xlcyIsImVsZWN0cmljUG90ZW50aWFsTW9kZWxDaXJjbGVzIiwiQ2lyY2xlcyIsInBvc2l0aW9uQXJyYXkiLCJmaWxsIiwicmFkaXVzIiwiZWxlY3RyaWNQb3RlbnRpYWxWaWV3Q2lyY2xlcyIsImdldFBydW5lZFBvc2l0aW9uQXJyYXkiLCJ0ZXh0IiwibGVuZ3RoIiwiY2VudGVyIiwibW9kZWxUb1ZpZXdQb3NpdGlvbiIsInBvc2l0aW9uIiwiZm9udCIsIlZPTFRBR0VfTEFCRUxfRk9OVCIsImNoaWxkcmVuIiwiZGlzcG9zZSIsImN1cnNvciIsImVsZWN0cmljUG90ZW50aWFsIiwiZHJhZ0xpc3RlbmVyIiwiYXBwbHlPZmZzZXQiLCJwb3NpdGlvblByb3BlcnR5Iiwidm9sdGFnZUxhYmVsUG9zaXRpb25Qcm9wZXJ0eSIsInRyYW5zZm9ybSIsInN0YXJ0IiwiZXZlbnQiLCJtb3ZlVG9Gcm9udCIsImFkZElucHV0TGlzdGVuZXIiLCJlbGVjdHJpY1BvdGVudGlhbFZhbHVlU3RyaW5nIiwiTWF0aCIsImFicyIsInRvRml4ZWQiLCJ2b2x0YWdlTGFiZWxTdHJpbmciLCJmb3JtYXQiLCJ2b2x0YWdlTGFiZWxUZXh0IiwiYmFja2dyb3VuZFJlY3RhbmdsZSIsIndpZHRoIiwiaGVpZ2h0Iiwidm9sdGFnZUxhYmVsQmFja2dyb3VuZFByb3BlcnR5IiwiYWRkQ2hpbGQiLCJwb3NpdGlvbkZ1bmN0aW9uIiwiY3Vyc29yUG9zaXRpb24iLCJzbWFsbGVzdERpc3RhbmNlU3F1YXJlZCIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiY2xvc2VzdFBvc2l0aW9uIiwiZm9yRWFjaCIsImRpc3RhbmNlU3F1YXJlZCIsImxpbmsiLCJkaXNwb3NlVm9sdGFnZUxhYmVsIiwidW5saW5rIiwib3B0aW9ucyIsImNpcmNsZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRWxlY3RyaWNQb3RlbnRpYWxMaW5lVmlldy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNS0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBWaWV3IG9iamVjdCwgd2l0aCBhIHZhcmlldHkgb2YgTm9kZXMgc3RvcmVkIG9uIGl0IHRvIGJlIGFkZGVkIGJ5IHRoZSBwYXJlbnQgY29udGFpbmVyLiBSZXNwb25zaWJsZSBmb3IgdGhlIGRyYXdpbmdcclxuICogb2Ygb25lIGVsZWN0cmljUG90ZW50aWFsTGluZSBhbmQgaXRzIGFjY29tcGFueWluZyB2b2x0YWdlIGxhYmVsc1xyXG4gKlxyXG4gKiBBIGRlYnVnIG9wdGlvbiBjYW4gZW5hYmxlZCB0aGUgdmlldyBvZiB0aGUgKG1vZGVsKSBwb3NpdGlvbiBwb2ludHMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGVsZWN0cmljIHBvdGVudGlhbCBsaW5lLlxyXG4gKiBUaGUgKHBydW5lZCkgcG9zaXRpb24gcG9pbnRzIHRoYXQgYXJlIHVzZWQgdG8gZHJhdyB0aGUgZWxlY3RyaWMgcG90ZW50aWFsIGxpbmUgY2FuIGFsc28gYmUgZGlzcGxheWVkLlxyXG4gKlxyXG4gKiBAYXV0aG9yIE1hcnRpbiBWZWlsbGV0dGUgKEJlcmVhIENvbGxlZ2UpXHJcbiAqIEBhdXRob3IgTWljaGFlbCBLYXV6bWFubiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCBTdHJpbmdVdGlscyBmcm9tICcuLi8uLi8uLi8uLi9waGV0Y29tbW9uL2pzL3V0aWwvU3RyaW5nVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBDaXJjbGUsIERyYWdMaXN0ZW5lciwgTm9kZSwgUGF0aCwgUmVjdGFuZ2xlLCBUZXh0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IFBoZXRpb09iamVjdCBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvUGhldGlvT2JqZWN0LmpzJztcclxuaW1wb3J0IElPVHlwZSBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvSU9UeXBlLmpzJztcclxuaW1wb3J0IGNoYXJnZXNBbmRGaWVsZHMgZnJvbSAnLi4vLi4vY2hhcmdlc0FuZEZpZWxkcy5qcyc7XHJcbmltcG9ydCBDaGFyZ2VzQW5kRmllbGRzU3RyaW5ncyBmcm9tICcuLi8uLi9DaGFyZ2VzQW5kRmllbGRzU3RyaW5ncy5qcyc7XHJcbmltcG9ydCBDaGFyZ2VzQW5kRmllbGRzQ29sb3JzIGZyb20gJy4uL0NoYXJnZXNBbmRGaWVsZHNDb2xvcnMuanMnO1xyXG5pbXBvcnQgQ2hhcmdlc0FuZEZpZWxkc0NvbnN0YW50cyBmcm9tICcuLi9DaGFyZ2VzQW5kRmllbGRzQ29uc3RhbnRzLmpzJztcclxuXHJcbmNvbnN0IHBhdHRlcm4wVmFsdWUxVW5pdHNTdHJpbmcgPSBDaGFyZ2VzQW5kRmllbGRzU3RyaW5ncy5wYXR0ZXJuWyAnMHZhbHVlJyBdWyAnMXVuaXRzJyBdO1xyXG5jb25zdCB2b2x0YWdlVW5pdFN0cmluZyA9IENoYXJnZXNBbmRGaWVsZHNTdHJpbmdzLnZvbHRhZ2VVbml0O1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbi8vIGlmIHNldCB0byB0cnVlIHdpbGwgc2hvdyB0aGUgKG1vZGVsIGFuZCB2aWV3KSBwb3NpdGlvbnMgdXNlIGluIHRoZSBjYWxjdWxhdGlvbiBvZiB0aGUgZWxlY3RyaWMgcG90ZW50aWFsIGxpbmVzXHJcbmNvbnN0IElTX0RFQlVHID0gcGhldC5jaGlwcGVyLnF1ZXJ5UGFyYW1ldGVycy5kZXY7XHJcblxyXG5jbGFzcyBFbGVjdHJpY1BvdGVudGlhbExpbmVWaWV3IGV4dGVuZHMgUGhldGlvT2JqZWN0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVjdHJpY1BvdGVudGlhbExpbmV9IGVsZWN0cmljUG90ZW50aWFsTGluZVxyXG4gICAqIEBwYXJhbSB7TW9kZWxWaWV3VHJhbnNmb3JtMn0gbW9kZWxWaWV3VHJhbnNmb3JtXHJcbiAgICogQHBhcmFtIHtUYW5kZW19IHRhbmRlbVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBlbGVjdHJpY1BvdGVudGlhbExpbmUsIG1vZGVsVmlld1RyYW5zZm9ybSwgdGFuZGVtICkge1xyXG4gICAgc3VwZXIoIHtcclxuICAgICAgdGFuZGVtOiB0YW5kZW0sXHJcbiAgICAgIHBoZXRpb0R5bmFtaWNFbGVtZW50OiB0cnVlLFxyXG4gICAgICBwaGV0aW9UeXBlOiBJT1R5cGUuT2JqZWN0SU8sXHJcbiAgICAgIHBoZXRpb1N0YXRlOiBmYWxzZVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIEBwdWJsaWMgKHJlYWQtb25seSkge05vZGV9IC0gdGhlIHBhdGggb2YgdGhlIHBvdGVudGlhbCBsaW5lXHJcbiAgICB0aGlzLnBhdGggPSBuZXcgUGF0aCggbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3U2hhcGUoIGVsZWN0cmljUG90ZW50aWFsTGluZS5nZXRTaGFwZSgpICksIHtcclxuICAgICAgc3Ryb2tlOiBDaGFyZ2VzQW5kRmllbGRzQ29sb3JzLmVsZWN0cmljUG90ZW50aWFsTGluZVByb3BlcnR5XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyAocmVhZC1vbmx5KSB7Tm9kZX0gLSBsYWJlbCB0aGF0IHNheXMgdGhlIHZvbHRhZ2VcclxuICAgIHRoaXMudm9sdGFnZUxhYmVsID0gbmV3IFZvbHRhZ2VMYWJlbCggZWxlY3RyaWNQb3RlbnRpYWxMaW5lLCBtb2RlbFZpZXdUcmFuc2Zvcm0sIHRhbmRlbS5jcmVhdGVUYW5kZW0oICd2b2x0YWdlTGFiZWwnICkgKTtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpIHtOb2RlfG51bGx9IC0gaWYgcnVubmluZyBpbiBkZXZlbG9wbWVudCBtb2RlLCB0aGVuIGRpc3BsYXkgZWFjaCBzYW1wbGUgcG9pbnQgb24gdGhlIHBvdGVudGlhbCBsaW5lXHJcbiAgICB0aGlzLmNpcmNsZXMgPSBudWxsO1xyXG5cclxuICAgIGlmICggSVNfREVCVUcgKSB7XHJcblxyXG4gICAgICAvLyBjcmVhdGUgYWxsIHRoZSBjaXJjbGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHBvc2l0aW9ucyBjYWxjdWxhdGVkIGluIHRoZSBtb2RlbFxyXG4gICAgICBjb25zdCBlbGVjdHJpY1BvdGVudGlhbE1vZGVsQ2lyY2xlcyA9IG5ldyBDaXJjbGVzKCBlbGVjdHJpY1BvdGVudGlhbExpbmUucG9zaXRpb25BcnJheSwgbW9kZWxWaWV3VHJhbnNmb3JtLCB7XHJcbiAgICAgICAgZmlsbDogJ3BpbmsnLFxyXG4gICAgICAgIHJhZGl1czogMVxyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICAvLyBjcmVhdGUgYWxsIHRoZSBjaXJjbGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHBvc2l0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGUgc2hhcGUgb2YgdGhlIGVsZWN0cmljIHBvdGVudGlhbCBsaW5lXHJcbiAgICAgIGNvbnN0IGVsZWN0cmljUG90ZW50aWFsVmlld0NpcmNsZXMgPSBuZXcgQ2lyY2xlcyhcclxuICAgICAgICBlbGVjdHJpY1BvdGVudGlhbExpbmUuZ2V0UHJ1bmVkUG9zaXRpb25BcnJheSggZWxlY3RyaWNQb3RlbnRpYWxMaW5lLnBvc2l0aW9uQXJyYXkgKSxcclxuICAgICAgICBtb2RlbFZpZXdUcmFuc2Zvcm0sIHsgZmlsbDogJ29yYW5nZScgfSApO1xyXG5cclxuICAgICAgLy8gbm8gdHJhbnNsYXRhYmxlIHN0cmluZ3MsIGZvciBkZWJ1ZyBvbmx5XHJcbiAgICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCggYG1vZGVsPSR7ZWxlY3RyaWNQb3RlbnRpYWxMaW5lLnBvc2l0aW9uQXJyYXkubGVuZ3RoXHJcbiAgICAgIH0gICAgdmlldz0ke2VsZWN0cmljUG90ZW50aWFsTGluZS5nZXRQcnVuZWRQb3NpdGlvbkFycmF5KCBlbGVjdHJpY1BvdGVudGlhbExpbmUucG9zaXRpb25BcnJheSApLmxlbmd0aH1gLCB7XHJcbiAgICAgICAgY2VudGVyOiBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdQb3NpdGlvbiggZWxlY3RyaWNQb3RlbnRpYWxMaW5lLnBvc2l0aW9uICksXHJcbiAgICAgICAgZmlsbDogJ2dyZWVuJyxcclxuICAgICAgICBmb250OiBDaGFyZ2VzQW5kRmllbGRzQ29uc3RhbnRzLlZPTFRBR0VfTEFCRUxfRk9OVFxyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICB0aGlzLmNpcmNsZXMgPSBuZXcgTm9kZSgge1xyXG4gICAgICAgIGNoaWxkcmVuOiBbXHJcbiAgICAgICAgICBlbGVjdHJpY1BvdGVudGlhbE1vZGVsQ2lyY2xlcyxcclxuICAgICAgICAgIGVsZWN0cmljUG90ZW50aWFsVmlld0NpcmNsZXMsXHJcbiAgICAgICAgICB0ZXh0XHJcbiAgICAgICAgXVxyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHRoaXMucGF0aC5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLnZvbHRhZ2VMYWJlbC5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLmNpcmNsZXMgJiYgdGhpcy5jaXJjbGVzLmRpc3Bvc2UoKTtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFZvbHRhZ2VMYWJlbCBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvKipcclxuICAgKiBGdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIHZvbHRhZ2UgbGFiZWwgZm9yIHRoZSBlbGVjdHJpY1BvdGVudGlhbCBsaW5lXHJcbiAgICogQHBhcmFtIHtFbGVjdHJpY1BvdGVudGlhbExpbmV9IGVsZWN0cmljUG90ZW50aWFsTGluZVxyXG4gICAqIEBwYXJhbSB7TW9kZWxWaWV3VHJhbnNmb3JtMn0gbW9kZWxWaWV3VHJhbnNmb3JtXHJcbiAgICogQHBhcmFtIHtUYW5kZW19IHRhbmRlbVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBlbGVjdHJpY1BvdGVudGlhbExpbmUsIG1vZGVsVmlld1RyYW5zZm9ybSwgdGFuZGVtICkge1xyXG5cclxuICAgIHN1cGVyKCB7IGN1cnNvcjogJ3BvaW50ZXInIH0gKTtcclxuXHJcbiAgICBjb25zdCBlbGVjdHJpY1BvdGVudGlhbCA9IGVsZWN0cmljUG90ZW50aWFsTGluZS5lbGVjdHJpY1BvdGVudGlhbDtcclxuICAgIGNvbnN0IHBvc2l0aW9uID0gZWxlY3RyaWNQb3RlbnRpYWxMaW5lLnBvc2l0aW9uO1xyXG5cclxuICAgIGNvbnN0IGRyYWdMaXN0ZW5lciA9IG5ldyBEcmFnTGlzdGVuZXIoIHtcclxuICAgICAgYXBwbHlPZmZzZXQ6IGZhbHNlLFxyXG4gICAgICBwb3NpdGlvblByb3BlcnR5OiBlbGVjdHJpY1BvdGVudGlhbExpbmUudm9sdGFnZUxhYmVsUG9zaXRpb25Qcm9wZXJ0eSxcclxuICAgICAgdGFuZGVtOiB0YW5kZW0uY3JlYXRlVGFuZGVtKCAnZHJhZ0xpc3RlbmVyJyApLFxyXG4gICAgICB0cmFuc2Zvcm06IG1vZGVsVmlld1RyYW5zZm9ybSxcclxuICAgICAgc3RhcnQ6IGV2ZW50ID0+IHtcclxuXHJcbiAgICAgICAgLy8gTW92ZSB0aGUgbGFiZWwgdG8gdGhlIGZyb250IG9mIHRoaXMgbGF5ZXIgd2hlbiBncmFiYmVkIGJ5IHRoZSB1c2VyLlxyXG4gICAgICAgIHRoaXMubW92ZVRvRnJvbnQoKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG4gICAgdGhpcy5hZGRJbnB1dExpc3RlbmVyKCBkcmFnTGlzdGVuZXIgKTtcclxuXHJcbiAgICAvLyBhIHNtYWxsZXIgZWxlY3RyaWMgcG90ZW50aWFsIHNob3VsZCBoYXZlIG1vcmUgcHJlY2lzaW9uXHJcbiAgICBjb25zdCBlbGVjdHJpY1BvdGVudGlhbFZhbHVlU3RyaW5nID0gKCBNYXRoLmFicyggZWxlY3RyaWNQb3RlbnRpYWwgKSA8IDEgKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMudG9GaXhlZCggZWxlY3RyaWNQb3RlbnRpYWwsIDIgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMudG9GaXhlZCggZWxlY3RyaWNQb3RlbnRpYWwsIDEgKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIHZvbHRhZ2UgbGFiZWwgZm9yIHRoZSBlbGVjdHJpY1BvdGVudGlhbCBsaW5lXHJcbiAgICBjb25zdCB2b2x0YWdlTGFiZWxTdHJpbmcgPSBTdHJpbmdVdGlscy5mb3JtYXQoIHBhdHRlcm4wVmFsdWUxVW5pdHNTdHJpbmcsIGVsZWN0cmljUG90ZW50aWFsVmFsdWVTdHJpbmcsIHZvbHRhZ2VVbml0U3RyaW5nICk7XHJcbiAgICBjb25zdCB2b2x0YWdlTGFiZWxUZXh0ID0gbmV3IFRleHQoIHZvbHRhZ2VMYWJlbFN0cmluZywge1xyXG4gICAgICBmb250OiBDaGFyZ2VzQW5kRmllbGRzQ29uc3RhbnRzLlZPTFRBR0VfTEFCRUxfRk9OVCxcclxuICAgICAgY2VudGVyOiBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdQb3NpdGlvbiggcG9zaXRpb24gKSxcclxuICAgICAgZmlsbDogQ2hhcmdlc0FuZEZpZWxkc0NvbG9ycy5lbGVjdHJpY1BvdGVudGlhbExpbmVQcm9wZXJ0eSxcclxuICAgICAgdGFuZGVtOiB0YW5kZW0uY3JlYXRlVGFuZGVtKCAndm9sdGFnZUxhYmVsVGV4dCcgKVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIGJhY2tncm91bmQgcmVjdGFuZ2xlIGZvciB0aGUgdm9sdGFnZSBsYWJlbFxyXG4gICAgY29uc3QgYmFja2dyb3VuZFJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoIDAsIDAsIHZvbHRhZ2VMYWJlbFRleHQud2lkdGggKiAxLjIsIHZvbHRhZ2VMYWJlbFRleHQuaGVpZ2h0ICogMS4yLCAzLCAzLCB7XHJcbiAgICAgIGNlbnRlcjogbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3UG9zaXRpb24oIHBvc2l0aW9uICksXHJcbiAgICAgIGZpbGw6IENoYXJnZXNBbmRGaWVsZHNDb2xvcnMudm9sdGFnZUxhYmVsQmFja2dyb3VuZFByb3BlcnR5XHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy5hZGRDaGlsZCggYmFja2dyb3VuZFJlY3RhbmdsZSApOyAvLyBtdXN0IGdvIGZpcnN0XHJcbiAgICB0aGlzLmFkZENoaWxkKCB2b2x0YWdlTGFiZWxUZXh0ICk7XHJcblxyXG4gICAgLy8gZmluZHMgdGhlIGNsb3Nlc3QgcG9zaXRpb24gb24gcG9zaXRpb25BcnJheSB0byB0aGUgcG9zaXRpb24gb2YgdGhlIGN1cnNvclxyXG4gICAgY29uc3QgcG9zaXRpb25GdW5jdGlvbiA9IGN1cnNvclBvc2l0aW9uID0+IHtcclxuICAgICAgbGV0IHNtYWxsZXN0RGlzdGFuY2VTcXVhcmVkID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICBsZXQgY2xvc2VzdFBvc2l0aW9uOyAvLyB7VmVjdG9yMn1cclxuICAgICAgZWxlY3RyaWNQb3RlbnRpYWxMaW5lLnBvc2l0aW9uQXJyYXkuZm9yRWFjaCggcG9zaXRpb24gPT4ge1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlU3F1YXJlZCA9IHBvc2l0aW9uLmRpc3RhbmNlU3F1YXJlZCggY3Vyc29yUG9zaXRpb24gKTtcclxuICAgICAgICBpZiAoIGRpc3RhbmNlU3F1YXJlZCA8IHNtYWxsZXN0RGlzdGFuY2VTcXVhcmVkICkge1xyXG4gICAgICAgICAgc21hbGxlc3REaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVNxdWFyZWQ7XHJcbiAgICAgICAgICBjbG9zZXN0UG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gKTtcclxuICAgICAgaWYgKCBjbG9zZXN0UG9zaXRpb24gKSB7XHJcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdQb3NpdGlvbiggY2xvc2VzdFBvc2l0aW9uICk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZWxlY3RyaWNQb3RlbnRpYWxMaW5lLnZvbHRhZ2VMYWJlbFBvc2l0aW9uUHJvcGVydHkubGluayggcG9zaXRpb25GdW5jdGlvbiApO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBhIGRpc3Bvc2UgZnVuY3Rpb24gdG8gdW5saW5rIHRoZSBjb2xvciBmdW5jdGlvbnNcclxuICAgIHRoaXMuZGlzcG9zZVZvbHRhZ2VMYWJlbCA9ICgpID0+IHtcclxuICAgICAgZWxlY3RyaWNQb3RlbnRpYWxMaW5lLnZvbHRhZ2VMYWJlbFBvc2l0aW9uUHJvcGVydHkudW5saW5rKCBwb3NpdGlvbkZ1bmN0aW9uICk7XHJcbiAgICAgIGRyYWdMaXN0ZW5lci5kaXNwb3NlKCk7XHJcbiAgICAgIHZvbHRhZ2VMYWJlbFRleHQuZGlzcG9zZSgpO1xyXG4gICAgICBiYWNrZ3JvdW5kUmVjdGFuZ2xlLmRpc3Bvc2UoKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWxlYXNlcyByZWZlcmVuY2VzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLmRpc3Bvc2VWb2x0YWdlTGFiZWwoKTtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIENpcmNsZXMgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogRnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgYW4gYXJyYXkgb2YgQ2lyY2xlcyB3aXRoIHRoZWlyIGNlbnRlcnMgZGV0ZXJtaW5lZCBieSB0aGUgcG9zaXRpb24gYXJyYXlcclxuICAgKiBAcGFyYW0ge0FycmF5LjxWZWN0b3IyPn0gcG9zaXRpb25BcnJheVxyXG4gICAqIEBwYXJhbSB7TW9kZWxWaWV3VHJhbnNmb3JtMn0gbW9kZWxWaWV3VHJhbnNmb3JtXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBwb3NpdGlvbkFycmF5LCBtb2RlbFZpZXdUcmFuc2Zvcm0sIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuICAgICAgcmFkaXVzOiAyXHJcbiAgICB9LCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gY3JlYXRlIGFuZCBhZGQgYWxsIHRoZSBjaXJjbGVzXHJcbiAgICBwb3NpdGlvbkFycmF5LmZvckVhY2goIHBvc2l0aW9uID0+IHtcclxuICAgICAgY29uc3QgY2lyY2xlID0gbmV3IENpcmNsZSggb3B0aW9ucy5yYWRpdXMsIG9wdGlvbnMgKTtcclxuICAgICAgY2lyY2xlLmNlbnRlciA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1Bvc2l0aW9uKCBwb3NpdGlvbiApO1xyXG4gICAgICB0aGlzLmFkZENoaWxkKCBjaXJjbGUgKTtcclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5jaGFyZ2VzQW5kRmllbGRzLnJlZ2lzdGVyKCAnRWxlY3RyaWNQb3RlbnRpYWxMaW5lVmlldycsIEVsZWN0cmljUG90ZW50aWFsTGluZVZpZXcgKTtcclxuZXhwb3J0IGRlZmF1bHQgRWxlY3RyaWNQb3RlbnRpYWxMaW5lVmlldztcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLEtBQUssTUFBTSw2QkFBNkI7QUFDL0MsT0FBT0MsS0FBSyxNQUFNLG1DQUFtQztBQUNyRCxPQUFPQyxXQUFXLE1BQU0sK0NBQStDO0FBQ3ZFLFNBQVNDLE1BQU0sRUFBRUMsWUFBWSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxJQUFJLFFBQVEsbUNBQW1DO0FBQ3JHLE9BQU9DLFlBQVksTUFBTSx1Q0FBdUM7QUFDaEUsT0FBT0MsTUFBTSxNQUFNLHVDQUF1QztBQUMxRCxPQUFPQyxnQkFBZ0IsTUFBTSwyQkFBMkI7QUFDeEQsT0FBT0MsdUJBQXVCLE1BQU0sa0NBQWtDO0FBQ3RFLE9BQU9DLHNCQUFzQixNQUFNLDhCQUE4QjtBQUNqRSxPQUFPQyx5QkFBeUIsTUFBTSxpQ0FBaUM7QUFFdkUsTUFBTUMseUJBQXlCLEdBQUdILHVCQUF1QixDQUFDSSxPQUFPLENBQUUsUUFBUSxDQUFFLENBQUUs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