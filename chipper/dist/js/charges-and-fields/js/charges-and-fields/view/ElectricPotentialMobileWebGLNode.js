// Copyright 2015-2022, University of Colorado Boulder

/**
 * View for the electric potential Grid Node that displays a two dimensional grid of rectangles that represent the
 * electric potential field, rendering in WebGL.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import ObservableArrayDef from '../../../../axon/js/ObservableArrayDef.js';
import Matrix3 from '../../../../dot/js/Matrix3.js';
import { ShaderProgram, WebGLNode } from '../../../../scenery/js/imports.js';
import chargesAndFields from '../../chargesAndFields.js';
import ChargesAndFieldsColors from '../ChargesAndFieldsColors.js';

// higher values support more particles, but may compromise performance
const MAX_PARTICLES_LIMIT = 32;
const scratchFloatArray = new Float32Array(9);
class ElectricPotentialMobileWebGLNode extends WebGLNode {
  /**
   * @param {ObservableArrayDef.<ChargedParticle>} chargedParticles - all the chargedParticles in this array are active
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Property.<boolean>} isVisibleProperty
   */
  constructor(chargedParticles, modelViewTransform, isVisibleProperty) {
    assert && assert(ObservableArrayDef.isObservableArray(chargedParticles), 'invalid chargedParticles');
    super(ElectricPotentialMobilePainter, {
      layerSplit: true,
      // ensure we're on our own layer
      webglScale: 1 / 16
    });
    this.chargedParticles = chargedParticles;
    this.modelViewTransform = modelViewTransform;
    this.isVisibleProperty = isVisibleProperty;

    // Invalidate paint on a bunch of changes
    const invalidateSelfListener = this.invalidatePaint.bind(this);
    ChargesAndFieldsColors.electricPotentialGridZeroProperty.link(invalidateSelfListener);
    ChargesAndFieldsColors.electricPotentialGridSaturationPositiveProperty.link(invalidateSelfListener);
    ChargesAndFieldsColors.electricPotentialGridSaturationNegativeProperty.link(invalidateSelfListener);
    isVisibleProperty.link(invalidateSelfListener); // visibility change

    // particle added
    // TODO: I've seen this pattern elsewhere in the code
    chargedParticles.addItemAddedListener(particle => particle.positionProperty.link(invalidateSelfListener));

    // particle removed
    chargedParticles.addItemRemovedListener(particle => {
      invalidateSelfListener();
      particle.positionProperty.unlink(invalidateSelfListener);
    });
  }

  /**
   * Detection for how many particles we can support.
   * @public
   */
  static getNumberOfParticlesSupported() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    return ElectricPotentialMobileWebGLNode.particlesSupportedForContext(gl);
  }

  /**
   * @public
   *
   * @param {WebGL2RenderingContext} gl
   * @returns {number}
   */
  static particlesSupportedForContext(gl) {
    const otherVectorCount = 7; // colors, matrix and one extra to be safe
    const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    return Math.min(MAX_PARTICLES_LIMIT, maxVertexUniforms - otherVectorCount);
  }
}
chargesAndFields.register('ElectricPotentialMobileWebGLNode', ElectricPotentialMobileWebGLNode);
class ElectricPotentialMobilePainter {
  /**
   * @param {WebGLRenderingContext} gl
   * @param {WaveWebGLNode} node
   */
  constructor(gl, node) {
    this.gl = gl;
    this.node = node;
    this.maximumNumParticles = ElectricPotentialMobileWebGLNode.particlesSupportedForContext(gl);
    const particleIndices = _.range(this.maximumNumParticles);

    // shader for the display of the data
    this.displayShaderProgram = new ShaderProgram(gl, [
    // vertex shader
    'attribute vec3 aPosition;',
    // vertex attribute
    'varying vec2 vPosition;', 'void main() {', '  vPosition = aPosition.xy;', '  gl_Position = vec4( aPosition, 1 );', '}'].join('\n'), [
    // fragment shader
    'precision mediump float;', 'varying vec2 vPosition;', 'uniform vec3 uZeroColor;', 'uniform vec3 uPositiveColor;', 'uniform vec3 uNegativeColor;', 'uniform mat3 uMatrixInverse;',
    // matrix to transform from normalized-device-coordinates to the model
    'const float kConstant = 9.0;',
    // 'uniform vec3 charge0;', etc.
    _.map(particleIndices, n => `uniform vec3 charge${n};`).join('\n'), 'void main() {',
    // homogeneous model-view transformation
    '  vec2 modelPosition = ( uMatrixInverse * vec3( vPosition, 1 ) ).xy;',
    // compute the total, not worrying about div by zero (will be covered up by charge icon)
    '  float voltage = 0.0;', _.map(particleIndices, n => `  voltage += charge${n}.z * kConstant / length( modelPosition - charge${n}.xy );`).join('\n'),
    // rules to color pulled from ChangesAndFieldsScreenView
    '  if ( voltage > 0.0 ) {', '    voltage = min( voltage / 40.0, 1.0 );',
    // clamp to [0,1]
    '    gl_FragColor = vec4( uPositiveColor * voltage + uZeroColor * ( 1.0 - voltage ), 1.0 );', '  } else {', '    voltage = min( -voltage / 40.0, 1.0 );',
    // clamp to [0,1]
    '    gl_FragColor = vec4( uNegativeColor * voltage + uZeroColor * ( 1.0 - voltage ), 1.0 );', '  }',
    // '  gl_FragColor = vec4( charge0.x, charge0.y, 0.0, 1.0 );',
    '}'].join('\n'), {
      attributes: ['aPosition'],
      uniforms: ['uMatrixInverse', 'uZeroColor', 'uPositiveColor', 'uNegativeColor'].concat(_.map(particleIndices, n => `charge${n}`))
    });

    // we only need one vertex buffer with the same contents for all three shaders!
    this.vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, +1, +1, -1, +1, +1]), gl.STATIC_DRAW);
  }

  /**
   * @public
   *
   * @param {Matrix3} modelViewMatrix
   * @param {Matrix3} projectionMatrix
   * @returns {number} - WebGLNode.PAINTED_NOTHING or WebGLNode.PAINTED_SOMETHING.
   */
  paint(modelViewMatrix, projectionMatrix) {
    const gl = this.gl;
    const displayShaderProgram = this.displayShaderProgram;

    // If we're not visible, clear everything and exit. Our layerSplit above guarantees this won't clear other
    // node's renderings.
    if (!this.node.isVisibleProperty.get()) {
      return WebGLNode.PAINTED_NOTHING;
    }
    displayShaderProgram.use();

    // TODO: reduce allocations
    const projectionMatrixInverse = new Matrix3().set(projectionMatrix).invert();
    const matrixInverse = this.node.modelViewTransform.getInverse().timesMatrix(modelViewMatrix.inverted().multiplyMatrix(projectionMatrixInverse));
    gl.uniformMatrix3fv(displayShaderProgram.uniformLocations.uMatrixInverse, false, matrixInverse.copyToArray(scratchFloatArray));

    // tell the shader our colors / scale
    const zeroColor = ChargesAndFieldsColors.electricPotentialGridZeroProperty.get();
    const positiveColor = ChargesAndFieldsColors.electricPotentialGridSaturationPositiveProperty.get();
    const negativeColor = ChargesAndFieldsColors.electricPotentialGridSaturationNegativeProperty.get();
    gl.uniform3f(displayShaderProgram.uniformLocations.uZeroColor, zeroColor.red / 255, zeroColor.green / 255, zeroColor.blue / 255);
    gl.uniform3f(displayShaderProgram.uniformLocations.uPositiveColor, positiveColor.red / 255, positiveColor.green / 255, positiveColor.blue / 255);
    gl.uniform3f(displayShaderProgram.uniformLocations.uNegativeColor, negativeColor.red / 255, negativeColor.green / 255, negativeColor.blue / 255);

    // update uniforms for the particle position
    const chargedParticleQuantity = this.node.chargedParticles.length;
    for (let i = 0; i < this.maximumNumParticles; i++) {
      const particle = i < chargedParticleQuantity ? this.node.chargedParticles.get(i) : null;
      const uniformLocation = displayShaderProgram.uniformLocations[`charge${i}`];
      if (particle) {
        gl.uniform3f(uniformLocation, particle.positionProperty.get().x, particle.positionProperty.get().y, particle.charge);
      } else {
        gl.uniform3f(uniformLocation, -7.52432, 0, 0); // zero charge, magic constant
      }
    }

    // data to draw 2 triangles that cover the screen
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(displayShaderProgram.attributeLocations.aPosition, 2, gl.FLOAT, false, 0, 0);

    // actually draw it
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    displayShaderProgram.unuse();
    return WebGLNode.PAINTED_SOMETHING;
  }

  /**
   * Releases references
   * @public
   */
  dispose() {
    // clears all of our resources
    this.displayShaderProgram.dispose();
    this.gl.deleteBuffer(this.vertexBuffer);
    this.displayShaderProgram = null;
  }
}
export default ElectricPotentialMobileWebGLNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYnNlcnZhYmxlQXJyYXlEZWYiLCJNYXRyaXgzIiwiU2hhZGVyUHJvZ3JhbSIsIldlYkdMTm9kZSIsImNoYXJnZXNBbmRGaWVsZHMiLCJDaGFyZ2VzQW5kRmllbGRzQ29sb3JzIiwiTUFYX1BBUlRJQ0xFU19MSU1JVCIsInNjcmF0Y2hGbG9hdEFycmF5IiwiRmxvYXQzMkFycmF5IiwiRWxlY3RyaWNQb3RlbnRpYWxNb2JpbGVXZWJHTE5vZGUiLCJjb25zdHJ1Y3RvciIsImNoYXJnZWRQYXJ0aWNsZXMiLCJtb2RlbFZpZXdUcmFuc2Zvcm0iLCJpc1Zpc2libGVQcm9wZXJ0eSIsImFzc2VydCIsImlzT2JzZXJ2YWJsZUFycmF5IiwiRWxlY3RyaWNQb3RlbnRpYWxNb2JpbGVQYWludGVyIiwibGF5ZXJTcGxpdCIsIndlYmdsU2NhbGUiLCJpbnZhbGlkYXRlU2VsZkxpc3RlbmVyIiwiaW52YWxpZGF0ZVBhaW50IiwiYmluZCIsImVsZWN0cmljUG90ZW50aWFsR3JpZFplcm9Qcm9wZXJ0eSIsImxpbmsiLCJlbGVjdHJpY1BvdGVudGlhbEdyaWRTYXR1cmF0aW9uUG9zaXRpdmVQcm9wZXJ0eSIsImVsZWN0cmljUG90ZW50aWFsR3JpZFNhdHVyYXRpb25OZWdhdGl2ZVByb3BlcnR5IiwiYWRkSXRlbUFkZGVkTGlzdGVuZXIiLCJwYXJ0aWNsZSIsInBvc2l0aW9uUHJvcGVydHkiLCJhZGRJdGVtUmVtb3ZlZExpc3RlbmVyIiwidW5saW5rIiwiZ2V0TnVtYmVyT2ZQYXJ0aWNsZXNTdXBwb3J0ZWQiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJnbCIsImdldENvbnRleHQiLCJwYXJ0aWNsZXNTdXBwb3J0ZWRGb3JDb250ZXh0Iiwib3RoZXJWZWN0b3JDb3VudCIsIm1heFZlcnRleFVuaWZvcm1zIiwiZ2V0UGFyYW1ldGVyIiwiTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMiLCJNYXRoIiwibWluIiwicmVnaXN0ZXIiLCJub2RlIiwibWF4aW11bU51bVBhcnRpY2xlcyIsInBhcnRpY2xlSW5kaWNlcyIsIl8iLCJyYW5nZSIsImRpc3BsYXlTaGFkZXJQcm9ncmFtIiwiam9pbiIsIm1hcCIsIm4iLCJhdHRyaWJ1dGVzIiwidW5pZm9ybXMiLCJjb25jYXQiLCJ2ZXJ0ZXhCdWZmZXIiLCJjcmVhdGVCdWZmZXIiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiYnVmZmVyRGF0YSIsIlNUQVRJQ19EUkFXIiwicGFpbnQiLCJtb2RlbFZpZXdNYXRyaXgiLCJwcm9qZWN0aW9uTWF0cml4IiwiZ2V0IiwiUEFJTlRFRF9OT1RISU5HIiwidXNlIiwicHJvamVjdGlvbk1hdHJpeEludmVyc2UiLCJzZXQiLCJpbnZlcnQiLCJtYXRyaXhJbnZlcnNlIiwiZ2V0SW52ZXJzZSIsInRpbWVzTWF0cml4IiwiaW52ZXJ0ZWQiLCJtdWx0aXBseU1hdHJpeCIsInVuaWZvcm1NYXRyaXgzZnYiLCJ1bmlmb3JtTG9jYXRpb25zIiwidU1hdHJpeEludmVyc2UiLCJjb3B5VG9BcnJheSIsInplcm9Db2xvciIsInBvc2l0aXZlQ29sb3IiLCJuZWdhdGl2ZUNvbG9yIiwidW5pZm9ybTNmIiwidVplcm9Db2xvciIsInJlZCIsImdyZWVuIiwiYmx1ZSIsInVQb3NpdGl2ZUNvbG9yIiwidU5lZ2F0aXZlQ29sb3IiLCJjaGFyZ2VkUGFydGljbGVRdWFudGl0eSIsImxlbmd0aCIsImkiLCJ1bmlmb3JtTG9jYXRpb24iLCJ4IiwieSIsImNoYXJnZSIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJhdHRyaWJ1dGVMb2NhdGlvbnMiLCJhUG9zaXRpb24iLCJGTE9BVCIsImRyYXdBcnJheXMiLCJUUklBTkdMRV9TVFJJUCIsInVudXNlIiwiUEFJTlRFRF9TT01FVEhJTkciLCJkaXNwb3NlIiwiZGVsZXRlQnVmZmVyIl0sInNvdXJjZXMiOlsiRWxlY3RyaWNQb3RlbnRpYWxNb2JpbGVXZWJHTE5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVmlldyBmb3IgdGhlIGVsZWN0cmljIHBvdGVudGlhbCBHcmlkIE5vZGUgdGhhdCBkaXNwbGF5cyBhIHR3byBkaW1lbnNpb25hbCBncmlkIG9mIHJlY3RhbmdsZXMgdGhhdCByZXByZXNlbnQgdGhlXHJcbiAqIGVsZWN0cmljIHBvdGVudGlhbCBmaWVsZCwgcmVuZGVyaW5nIGluIFdlYkdMLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XHJcbiAqL1xyXG5cclxuaW1wb3J0IE9ic2VydmFibGVBcnJheURlZiBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL09ic2VydmFibGVBcnJheURlZi5qcyc7XHJcbmltcG9ydCBNYXRyaXgzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9NYXRyaXgzLmpzJztcclxuaW1wb3J0IHsgU2hhZGVyUHJvZ3JhbSwgV2ViR0xOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IGNoYXJnZXNBbmRGaWVsZHMgZnJvbSAnLi4vLi4vY2hhcmdlc0FuZEZpZWxkcy5qcyc7XHJcbmltcG9ydCBDaGFyZ2VzQW5kRmllbGRzQ29sb3JzIGZyb20gJy4uL0NoYXJnZXNBbmRGaWVsZHNDb2xvcnMuanMnO1xyXG5cclxuLy8gaGlnaGVyIHZhbHVlcyBzdXBwb3J0IG1vcmUgcGFydGljbGVzLCBidXQgbWF5IGNvbXByb21pc2UgcGVyZm9ybWFuY2VcclxuY29uc3QgTUFYX1BBUlRJQ0xFU19MSU1JVCA9IDMyO1xyXG5jb25zdCBzY3JhdGNoRmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDkgKTtcclxuXHJcbmNsYXNzIEVsZWN0cmljUG90ZW50aWFsTW9iaWxlV2ViR0xOb2RlIGV4dGVuZHMgV2ViR0xOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlQXJyYXlEZWYuPENoYXJnZWRQYXJ0aWNsZT59IGNoYXJnZWRQYXJ0aWNsZXMgLSBhbGwgdGhlIGNoYXJnZWRQYXJ0aWNsZXMgaW4gdGhpcyBhcnJheSBhcmUgYWN0aXZlXHJcbiAgICogQHBhcmFtIHtNb2RlbFZpZXdUcmFuc2Zvcm0yfSBtb2RlbFZpZXdUcmFuc2Zvcm1cclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5Ljxib29sZWFuPn0gaXNWaXNpYmxlUHJvcGVydHlcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggY2hhcmdlZFBhcnRpY2xlcywgbW9kZWxWaWV3VHJhbnNmb3JtLCBpc1Zpc2libGVQcm9wZXJ0eSApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIE9ic2VydmFibGVBcnJheURlZi5pc09ic2VydmFibGVBcnJheSggY2hhcmdlZFBhcnRpY2xlcyApLCAnaW52YWxpZCBjaGFyZ2VkUGFydGljbGVzJyApO1xyXG5cclxuICAgIHN1cGVyKCBFbGVjdHJpY1BvdGVudGlhbE1vYmlsZVBhaW50ZXIsIHtcclxuICAgICAgbGF5ZXJTcGxpdDogdHJ1ZSwgLy8gZW5zdXJlIHdlJ3JlIG9uIG91ciBvd24gbGF5ZXJcclxuICAgICAgd2ViZ2xTY2FsZTogMSAvIDE2XHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy5jaGFyZ2VkUGFydGljbGVzID0gY2hhcmdlZFBhcnRpY2xlcztcclxuICAgIHRoaXMubW9kZWxWaWV3VHJhbnNmb3JtID0gbW9kZWxWaWV3VHJhbnNmb3JtO1xyXG4gICAgdGhpcy5pc1Zpc2libGVQcm9wZXJ0eSA9IGlzVmlzaWJsZVByb3BlcnR5O1xyXG5cclxuICAgIC8vIEludmFsaWRhdGUgcGFpbnQgb24gYSBidW5jaCBvZiBjaGFuZ2VzXHJcbiAgICBjb25zdCBpbnZhbGlkYXRlU2VsZkxpc3RlbmVyID0gdGhpcy5pbnZhbGlkYXRlUGFpbnQuYmluZCggdGhpcyApO1xyXG4gICAgQ2hhcmdlc0FuZEZpZWxkc0NvbG9ycy5lbGVjdHJpY1BvdGVudGlhbEdyaWRaZXJvUHJvcGVydHkubGluayggaW52YWxpZGF0ZVNlbGZMaXN0ZW5lciApO1xyXG4gICAgQ2hhcmdlc0FuZEZpZWxkc0NvbG9ycy5lbGVjdHJpY1BvdGVudGlhbEdyaWRTYXR1cmF0aW9uUG9zaXRpdmVQcm9wZXJ0eS5saW5rKCBpbnZhbGlkYXRlU2VsZkxpc3RlbmVyICk7XHJcbiAgICBDaGFyZ2VzQW5kRmllbGRzQ29sb3JzLmVsZWN0cmljUG90ZW50aWFsR3JpZFNhdHVyYXRpb25OZWdhdGl2ZVByb3BlcnR5LmxpbmsoIGludmFsaWRhdGVTZWxmTGlzdGVuZXIgKTtcclxuICAgIGlzVmlzaWJsZVByb3BlcnR5LmxpbmsoIGludmFsaWRhdGVTZWxmTGlzdGVuZXIgKTsgLy8gdmlzaWJpbGl0eSBjaGFuZ2VcclxuXHJcbiAgICAvLyBwYXJ0aWNsZSBhZGRlZFxyXG4gICAgLy8gVE9ETzogSSd2ZSBzZWVuIHRoaXMgcGF0dGVybiBlbHNld2hlcmUgaW4gdGhlIGNvZGVcclxuICAgIGNoYXJnZWRQYXJ0aWNsZXMuYWRkSXRlbUFkZGVkTGlzdGVuZXIoIHBhcnRpY2xlID0+IHBhcnRpY2xlLnBvc2l0aW9uUHJvcGVydHkubGluayggaW52YWxpZGF0ZVNlbGZMaXN0ZW5lciApICk7XHJcblxyXG4gICAgLy8gcGFydGljbGUgcmVtb3ZlZFxyXG4gICAgY2hhcmdlZFBhcnRpY2xlcy5hZGRJdGVtUmVtb3ZlZExpc3RlbmVyKCBwYXJ0aWNsZSA9PiB7XHJcbiAgICAgIGludmFsaWRhdGVTZWxmTGlzdGVuZXIoKTtcclxuICAgICAgcGFydGljbGUucG9zaXRpb25Qcm9wZXJ0eS51bmxpbmsoIGludmFsaWRhdGVTZWxmTGlzdGVuZXIgKTtcclxuICAgIH0gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVjdGlvbiBmb3IgaG93IG1hbnkgcGFydGljbGVzIHdlIGNhbiBzdXBwb3J0LlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0TnVtYmVyT2ZQYXJ0aWNsZXNTdXBwb3J0ZWQoKSB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG4gICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApIHx8IGNhbnZhcy5nZXRDb250ZXh0KCAnZXhwZXJpbWVudGFsLXdlYmdsJyApO1xyXG4gICAgcmV0dXJuIEVsZWN0cmljUG90ZW50aWFsTW9iaWxlV2ViR0xOb2RlLnBhcnRpY2xlc1N1cHBvcnRlZEZvckNvbnRleHQoIGdsICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgcGFydGljbGVzU3VwcG9ydGVkRm9yQ29udGV4dCggZ2wgKSB7XHJcbiAgICBjb25zdCBvdGhlclZlY3RvckNvdW50ID0gNzsgLy8gY29sb3JzLCBtYXRyaXggYW5kIG9uZSBleHRyYSB0byBiZSBzYWZlXHJcbiAgICBjb25zdCBtYXhWZXJ0ZXhVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKTtcclxuICAgIHJldHVybiBNYXRoLm1pbiggTUFYX1BBUlRJQ0xFU19MSU1JVCwgbWF4VmVydGV4VW5pZm9ybXMgLSBvdGhlclZlY3RvckNvdW50ICk7XHJcbiAgfVxyXG59XHJcblxyXG5jaGFyZ2VzQW5kRmllbGRzLnJlZ2lzdGVyKCAnRWxlY3RyaWNQb3RlbnRpYWxNb2JpbGVXZWJHTE5vZGUnLCBFbGVjdHJpY1BvdGVudGlhbE1vYmlsZVdlYkdMTm9kZSApO1xyXG5cclxuY2xhc3MgRWxlY3RyaWNQb3RlbnRpYWxNb2JpbGVQYWludGVyIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXHJcbiAgICogQHBhcmFtIHtXYXZlV2ViR0xOb2RlfSBub2RlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGdsLCBub2RlICkge1xyXG4gICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgdGhpcy5ub2RlID0gbm9kZTtcclxuXHJcbiAgICB0aGlzLm1heGltdW1OdW1QYXJ0aWNsZXMgPSBFbGVjdHJpY1BvdGVudGlhbE1vYmlsZVdlYkdMTm9kZS5wYXJ0aWNsZXNTdXBwb3J0ZWRGb3JDb250ZXh0KCBnbCApO1xyXG5cclxuICAgIGNvbnN0IHBhcnRpY2xlSW5kaWNlcyA9IF8ucmFuZ2UoIHRoaXMubWF4aW11bU51bVBhcnRpY2xlcyApO1xyXG5cclxuICAgIC8vIHNoYWRlciBmb3IgdGhlIGRpc3BsYXkgb2YgdGhlIGRhdGFcclxuICAgIHRoaXMuZGlzcGxheVNoYWRlclByb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbSggZ2wsIFtcclxuICAgICAgLy8gdmVydGV4IHNoYWRlclxyXG4gICAgICAnYXR0cmlidXRlIHZlYzMgYVBvc2l0aW9uOycsIC8vIHZlcnRleCBhdHRyaWJ1dGVcclxuICAgICAgJ3ZhcnlpbmcgdmVjMiB2UG9zaXRpb247JyxcclxuICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgICAnICB2UG9zaXRpb24gPSBhUG9zaXRpb24ueHk7JyxcclxuICAgICAgJyAgZ2xfUG9zaXRpb24gPSB2ZWM0KCBhUG9zaXRpb24sIDEgKTsnLFxyXG4gICAgICAnfSdcclxuICAgIF0uam9pbiggJ1xcbicgKSwgW1xyXG4gICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXHJcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlBvc2l0aW9uOycsXHJcbiAgICAgICd1bmlmb3JtIHZlYzMgdVplcm9Db2xvcjsnLFxyXG4gICAgICAndW5pZm9ybSB2ZWMzIHVQb3NpdGl2ZUNvbG9yOycsXHJcbiAgICAgICd1bmlmb3JtIHZlYzMgdU5lZ2F0aXZlQ29sb3I7JyxcclxuICAgICAgJ3VuaWZvcm0gbWF0MyB1TWF0cml4SW52ZXJzZTsnLCAvLyBtYXRyaXggdG8gdHJhbnNmb3JtIGZyb20gbm9ybWFsaXplZC1kZXZpY2UtY29vcmRpbmF0ZXMgdG8gdGhlIG1vZGVsXHJcbiAgICAgICdjb25zdCBmbG9hdCBrQ29uc3RhbnQgPSA5LjA7JyxcclxuICAgICAgLy8gJ3VuaWZvcm0gdmVjMyBjaGFyZ2UwOycsIGV0Yy5cclxuICAgICAgXy5tYXAoIHBhcnRpY2xlSW5kaWNlcywgbiA9PiBgdW5pZm9ybSB2ZWMzIGNoYXJnZSR7bn07YCApLmpvaW4oICdcXG4nICksXHJcbiAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuICAgICAgLy8gaG9tb2dlbmVvdXMgbW9kZWwtdmlldyB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAnICB2ZWMyIG1vZGVsUG9zaXRpb24gPSAoIHVNYXRyaXhJbnZlcnNlICogdmVjMyggdlBvc2l0aW9uLCAxICkgKS54eTsnLFxyXG5cclxuICAgICAgLy8gY29tcHV0ZSB0aGUgdG90YWwsIG5vdCB3b3JyeWluZyBhYm91dCBkaXYgYnkgemVybyAod2lsbCBiZSBjb3ZlcmVkIHVwIGJ5IGNoYXJnZSBpY29uKVxyXG4gICAgICAnICBmbG9hdCB2b2x0YWdlID0gMC4wOycsXHJcbiAgICAgIF8ubWFwKCBwYXJ0aWNsZUluZGljZXMsIG4gPT4gYCAgdm9sdGFnZSArPSBjaGFyZ2Uke259LnogKiBrQ29uc3RhbnQgLyBsZW5ndGgoIG1vZGVsUG9zaXRpb24gLSBjaGFyZ2Uke259Lnh5ICk7YCApLmpvaW4oICdcXG4nICksXHJcblxyXG4gICAgICAvLyBydWxlcyB0byBjb2xvciBwdWxsZWQgZnJvbSBDaGFuZ2VzQW5kRmllbGRzU2NyZWVuVmlld1xyXG4gICAgICAnICBpZiAoIHZvbHRhZ2UgPiAwLjAgKSB7JyxcclxuICAgICAgJyAgICB2b2x0YWdlID0gbWluKCB2b2x0YWdlIC8gNDAuMCwgMS4wICk7JywgLy8gY2xhbXAgdG8gWzAsMV1cclxuICAgICAgJyAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCB1UG9zaXRpdmVDb2xvciAqIHZvbHRhZ2UgKyB1WmVyb0NvbG9yICogKCAxLjAgLSB2b2x0YWdlICksIDEuMCApOycsXHJcbiAgICAgICcgIH0gZWxzZSB7JyxcclxuICAgICAgJyAgICB2b2x0YWdlID0gbWluKCAtdm9sdGFnZSAvIDQwLjAsIDEuMCApOycsIC8vIGNsYW1wIHRvIFswLDFdXHJcbiAgICAgICcgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggdU5lZ2F0aXZlQ29sb3IgKiB2b2x0YWdlICsgdVplcm9Db2xvciAqICggMS4wIC0gdm9sdGFnZSApLCAxLjAgKTsnLFxyXG4gICAgICAnICB9JyxcclxuICAgICAgLy8gJyAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggY2hhcmdlMC54LCBjaGFyZ2UwLnksIDAuMCwgMS4wICk7JyxcclxuICAgICAgJ30nXHJcbiAgICBdLmpvaW4oICdcXG4nICksIHtcclxuICAgICAgYXR0cmlidXRlczogWyAnYVBvc2l0aW9uJyBdLFxyXG4gICAgICB1bmlmb3JtczogWyAndU1hdHJpeEludmVyc2UnLCAndVplcm9Db2xvcicsICd1UG9zaXRpdmVDb2xvcicsICd1TmVnYXRpdmVDb2xvcicgXS5jb25jYXQoXHJcbiAgICAgICAgXy5tYXAoIHBhcnRpY2xlSW5kaWNlcywgbiA9PiBgY2hhcmdlJHtufWAgKSApXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gd2Ugb25seSBuZWVkIG9uZSB2ZXJ0ZXggYnVmZmVyIHdpdGggdGhlIHNhbWUgY29udGVudHMgZm9yIGFsbCB0aHJlZSBzaGFkZXJzIVxyXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIgKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSggW1xyXG4gICAgICAtMSwgLTEsXHJcbiAgICAgIC0xLCArMSxcclxuICAgICAgKzEsIC0xLFxyXG4gICAgICArMSwgKzFcclxuICAgIF0gKSwgZ2wuU1RBVElDX0RSQVcgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TWF0cml4M30gbW9kZWxWaWV3TWF0cml4XHJcbiAgICogQHBhcmFtIHtNYXRyaXgzfSBwcm9qZWN0aW9uTWF0cml4XHJcbiAgICogQHJldHVybnMge251bWJlcn0gLSBXZWJHTE5vZGUuUEFJTlRFRF9OT1RISU5HIG9yIFdlYkdMTm9kZS5QQUlOVEVEX1NPTUVUSElORy5cclxuICAgKi9cclxuICBwYWludCggbW9kZWxWaWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4ICkge1xyXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgY29uc3QgZGlzcGxheVNoYWRlclByb2dyYW0gPSB0aGlzLmRpc3BsYXlTaGFkZXJQcm9ncmFtO1xyXG5cclxuICAgIC8vIElmIHdlJ3JlIG5vdCB2aXNpYmxlLCBjbGVhciBldmVyeXRoaW5nIGFuZCBleGl0LiBPdXIgbGF5ZXJTcGxpdCBhYm92ZSBndWFyYW50ZWVzIHRoaXMgd29uJ3QgY2xlYXIgb3RoZXJcclxuICAgIC8vIG5vZGUncyByZW5kZXJpbmdzLlxyXG4gICAgaWYgKCAhdGhpcy5ub2RlLmlzVmlzaWJsZVByb3BlcnR5LmdldCgpICkge1xyXG4gICAgICByZXR1cm4gV2ViR0xOb2RlLlBBSU5URURfTk9USElORztcclxuICAgIH1cclxuXHJcbiAgICBkaXNwbGF5U2hhZGVyUHJvZ3JhbS51c2UoKTtcclxuXHJcbiAgICAvLyBUT0RPOiByZWR1Y2UgYWxsb2NhdGlvbnNcclxuICAgIGNvbnN0IHByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDMoKS5zZXQoIHByb2plY3Rpb25NYXRyaXggKS5pbnZlcnQoKTtcclxuICAgIGNvbnN0IG1hdHJpeEludmVyc2UgPSB0aGlzLm5vZGUubW9kZWxWaWV3VHJhbnNmb3JtLmdldEludmVyc2UoKS50aW1lc01hdHJpeCggbW9kZWxWaWV3TWF0cml4LmludmVydGVkKCkubXVsdGlwbHlNYXRyaXgoIHByb2plY3Rpb25NYXRyaXhJbnZlcnNlICkgKTtcclxuICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoIGRpc3BsYXlTaGFkZXJQcm9ncmFtLnVuaWZvcm1Mb2NhdGlvbnMudU1hdHJpeEludmVyc2UsIGZhbHNlLCBtYXRyaXhJbnZlcnNlLmNvcHlUb0FycmF5KCBzY3JhdGNoRmxvYXRBcnJheSApICk7XHJcblxyXG4gICAgLy8gdGVsbCB0aGUgc2hhZGVyIG91ciBjb2xvcnMgLyBzY2FsZVxyXG4gICAgY29uc3QgemVyb0NvbG9yID0gQ2hhcmdlc0FuZEZpZWxkc0NvbG9ycy5lbGVjdHJpY1BvdGVudGlhbEdyaWRaZXJvUHJvcGVydHkuZ2V0KCk7XHJcbiAgICBjb25zdCBwb3NpdGl2ZUNvbG9yID0gQ2hhcmdlc0FuZEZpZWxkc0NvbG9ycy5lbGVjdHJpY1BvdGVudGlhbEdyaWRTYXR1cmF0aW9uUG9zaXRpdmVQcm9wZXJ0eS5nZXQoKTtcclxuICAgIGNvbnN0IG5lZ2F0aXZlQ29sb3IgPSBDaGFyZ2VzQW5kRmllbGRzQ29sb3JzLmVsZWN0cmljUG90ZW50aWFsR3JpZFNhdHVyYXRpb25OZWdhdGl2ZVByb3BlcnR5LmdldCgpO1xyXG4gICAgZ2wudW5pZm9ybTNmKCBkaXNwbGF5U2hhZGVyUHJvZ3JhbS51bmlmb3JtTG9jYXRpb25zLnVaZXJvQ29sb3IsIHplcm9Db2xvci5yZWQgLyAyNTUsIHplcm9Db2xvci5ncmVlbiAvIDI1NSwgemVyb0NvbG9yLmJsdWUgLyAyNTUgKTtcclxuICAgIGdsLnVuaWZvcm0zZiggZGlzcGxheVNoYWRlclByb2dyYW0udW5pZm9ybUxvY2F0aW9ucy51UG9zaXRpdmVDb2xvciwgcG9zaXRpdmVDb2xvci5yZWQgLyAyNTUsIHBvc2l0aXZlQ29sb3IuZ3JlZW4gLyAyNTUsIHBvc2l0aXZlQ29sb3IuYmx1ZSAvIDI1NSApO1xyXG4gICAgZ2wudW5pZm9ybTNmKCBkaXNwbGF5U2hhZGVyUHJvZ3JhbS51bmlmb3JtTG9jYXRpb25zLnVOZWdhdGl2ZUNvbG9yLCBuZWdhdGl2ZUNvbG9yLnJlZCAvIDI1NSwgbmVnYXRpdmVDb2xvci5ncmVlbiAvIDI1NSwgbmVnYXRpdmVDb2xvci5ibHVlIC8gMjU1ICk7XHJcblxyXG4gICAgLy8gdXBkYXRlIHVuaWZvcm1zIGZvciB0aGUgcGFydGljbGUgcG9zaXRpb25cclxuICAgIGNvbnN0IGNoYXJnZWRQYXJ0aWNsZVF1YW50aXR5ID0gdGhpcy5ub2RlLmNoYXJnZWRQYXJ0aWNsZXMubGVuZ3RoO1xyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5tYXhpbXVtTnVtUGFydGljbGVzOyBpKysgKSB7XHJcbiAgICAgIGNvbnN0IHBhcnRpY2xlID0gaSA8IGNoYXJnZWRQYXJ0aWNsZVF1YW50aXR5ID8gdGhpcy5ub2RlLmNoYXJnZWRQYXJ0aWNsZXMuZ2V0KCBpICkgOiBudWxsO1xyXG4gICAgICBjb25zdCB1bmlmb3JtTG9jYXRpb24gPSBkaXNwbGF5U2hhZGVyUHJvZ3JhbS51bmlmb3JtTG9jYXRpb25zWyBgY2hhcmdlJHtpfWAgXTtcclxuXHJcbiAgICAgIGlmICggcGFydGljbGUgKSB7XHJcbiAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3JtTG9jYXRpb24sIHBhcnRpY2xlLnBvc2l0aW9uUHJvcGVydHkuZ2V0KCkueCwgcGFydGljbGUucG9zaXRpb25Qcm9wZXJ0eS5nZXQoKS55LCBwYXJ0aWNsZS5jaGFyZ2UgKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1Mb2NhdGlvbiwgLTcuNTI0MzIsIDAsIDAgKTsgLy8gemVybyBjaGFyZ2UsIG1hZ2ljIGNvbnN0YW50XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBkYXRhIHRvIGRyYXcgMiB0cmlhbmdsZXMgdGhhdCBjb3ZlciB0aGUgc2NyZWVuXHJcbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyICk7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBkaXNwbGF5U2hhZGVyUHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnMuYVBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcbiAgICAvLyBhY3R1YWxseSBkcmF3IGl0XHJcbiAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xyXG5cclxuICAgIGRpc3BsYXlTaGFkZXJQcm9ncmFtLnVudXNlKCk7XHJcblxyXG4gICAgcmV0dXJuIFdlYkdMTm9kZS5QQUlOVEVEX1NPTUVUSElORztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbGVhc2VzIHJlZmVyZW5jZXNcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIC8vIGNsZWFycyBhbGwgb2Ygb3VyIHJlc291cmNlc1xyXG4gICAgdGhpcy5kaXNwbGF5U2hhZGVyUHJvZ3JhbS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlciggdGhpcy52ZXJ0ZXhCdWZmZXIgKTtcclxuXHJcbiAgICB0aGlzLmRpc3BsYXlTaGFkZXJQcm9ncmFtID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEVsZWN0cmljUG90ZW50aWFsTW9iaWxlV2ViR0xOb2RlO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxrQkFBa0IsTUFBTSwyQ0FBMkM7QUFDMUUsT0FBT0MsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxTQUFTQyxhQUFhLEVBQUVDLFNBQVMsUUFBUSxtQ0FBbUM7QUFDNUUsT0FBT0MsZ0JBQWdCLE1BQU0sMkJBQTJCO0FBQ3hELE9BQU9DLHNCQUFzQixNQUFNLDhCQUE4Qjs7QUFFakU7QUFDQSxNQUFNQyxtQkFBbUIsR0FBRyxFQUFFO0FBQzlCLE1BQU1D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