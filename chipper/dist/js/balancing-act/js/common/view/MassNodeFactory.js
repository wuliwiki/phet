// Copyright 2013-2022, University of Colorado Boulder

/**
 * Factory type for creating mass nodes for a given Mass objects.  This
 * basically does the type identification necessary to match the model
 * representation with the appropriate view representation (i.e. node).
 *
 * @author John Blanco
 */

import { Rectangle, Text } from '../../../../scenery/js/imports.js';
import balancingAct from '../../balancingAct.js';
import ImageMass from '../model/ImageMass.js';
import BrickStack from '../model/masses/BrickStack.js';
import MysteryMass from '../model/masses/MysteryMass.js';
import BrickStackNode from './BrickStackNode.js';
import ImageMassNode from './ImageMassNode.js';
import MysteryMassNode from './MysteryMassNode.js';
const MassNodeFactory = {
  createMassNode(mass, modelViewTransform, isLabeled, labelVisibleProperty, columnStateProperty) {
    let massNode;
    if (mass instanceof MysteryMass) {
      massNode = new MysteryMassNode(mass, modelViewTransform, isLabeled, labelVisibleProperty, true, columnStateProperty);
    } else if (mass instanceof ImageMass) {
      massNode = new ImageMassNode(mass, modelViewTransform, isLabeled, labelVisibleProperty, true, columnStateProperty);
    } else if (mass instanceof BrickStack) {
      massNode = new BrickStackNode(mass, modelViewTransform, isLabeled, labelVisibleProperty, true, columnStateProperty);
    } else {
      assert && assert(true, 'Error: Unrecognized mass type sent to MassNodeFactory.');
      // In case the ever happens out in the wild, create a fake node.
      const textNode = new Text('Unimplemented Mass Node');
      massNode = new Rectangle(0, 0, textNode.width * 1.3, textNode.height * 1.3, 0, 0, {
        fill: 'pink',
        stroke: 'black'
      });
      textNode.centerY = massNode.height / 2;
      massNode.addChild(textNode);
      massNode.center = modelViewTransform.modelToViewPosition(mass.positionProperty.get());
    }
    return massNode;
  }
};
balancingAct.register('MassNodeFactory', MassNodeFactory);
export default MassNodeFactory;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSZWN0YW5nbGUiLCJUZXh0IiwiYmFsYW5jaW5nQWN0IiwiSW1hZ2VNYXNzIiwiQnJpY2tTdGFjayIsIk15c3RlcnlNYXNzIiwiQnJpY2tTdGFja05vZGUiLCJJbWFnZU1hc3NOb2RlIiwiTXlzdGVyeU1hc3NOb2RlIiwiTWFzc05vZGVGYWN0b3J5IiwiY3JlYXRlTWFzc05vZGUiLCJtYXNzIiwibW9kZWxWaWV3VHJhbnNmb3JtIiwiaXNMYWJlbGVkIiwibGFiZWxWaXNpYmxlUHJvcGVydHkiLCJjb2x1bW5TdGF0ZVByb3BlcnR5IiwibWFzc05vZGUiLCJhc3NlcnQiLCJ0ZXh0Tm9kZSIsIndpZHRoIiwiaGVpZ2h0IiwiZmlsbCIsInN0cm9rZSIsImNlbnRlclkiLCJhZGRDaGlsZCIsImNlbnRlciIsIm1vZGVsVG9WaWV3UG9zaXRpb24iLCJwb3NpdGlvblByb3BlcnR5IiwiZ2V0IiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJNYXNzTm9kZUZhY3RvcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogRmFjdG9yeSB0eXBlIGZvciBjcmVhdGluZyBtYXNzIG5vZGVzIGZvciBhIGdpdmVuIE1hc3Mgb2JqZWN0cy4gIFRoaXNcclxuICogYmFzaWNhbGx5IGRvZXMgdGhlIHR5cGUgaWRlbnRpZmljYXRpb24gbmVjZXNzYXJ5IHRvIG1hdGNoIHRoZSBtb2RlbFxyXG4gKiByZXByZXNlbnRhdGlvbiB3aXRoIHRoZSBhcHByb3ByaWF0ZSB2aWV3IHJlcHJlc2VudGF0aW9uIChpLmUuIG5vZGUpLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgUmVjdGFuZ2xlLCBUZXh0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IGJhbGFuY2luZ0FjdCBmcm9tICcuLi8uLi9iYWxhbmNpbmdBY3QuanMnO1xyXG5pbXBvcnQgSW1hZ2VNYXNzIGZyb20gJy4uL21vZGVsL0ltYWdlTWFzcy5qcyc7XHJcbmltcG9ydCBCcmlja1N0YWNrIGZyb20gJy4uL21vZGVsL21hc3Nlcy9Ccmlja1N0YWNrLmpzJztcclxuaW1wb3J0IE15c3RlcnlNYXNzIGZyb20gJy4uL21vZGVsL21hc3Nlcy9NeXN0ZXJ5TWFzcy5qcyc7XHJcbmltcG9ydCBCcmlja1N0YWNrTm9kZSBmcm9tICcuL0JyaWNrU3RhY2tOb2RlLmpzJztcclxuaW1wb3J0IEltYWdlTWFzc05vZGUgZnJvbSAnLi9JbWFnZU1hc3NOb2RlLmpzJztcclxuaW1wb3J0IE15c3RlcnlNYXNzTm9kZSBmcm9tICcuL015c3RlcnlNYXNzTm9kZS5qcyc7XHJcblxyXG5jb25zdCBNYXNzTm9kZUZhY3RvcnkgPSB7XHJcbiAgY3JlYXRlTWFzc05vZGUoIG1hc3MsIG1vZGVsVmlld1RyYW5zZm9ybSwgaXNMYWJlbGVkLCBsYWJlbFZpc2libGVQcm9wZXJ0eSwgY29sdW1uU3RhdGVQcm9wZXJ0eSApIHtcclxuICAgIGxldCBtYXNzTm9kZTtcclxuICAgIGlmICggbWFzcyBpbnN0YW5jZW9mIE15c3RlcnlNYXNzICkge1xyXG4gICAgICBtYXNzTm9kZSA9IG5ldyBNeXN0ZXJ5TWFzc05vZGUoIG1hc3MsIG1vZGVsVmlld1RyYW5zZm9ybSwgaXNMYWJlbGVkLCBsYWJlbFZpc2libGVQcm9wZXJ0eSwgdHJ1ZSwgY29sdW1uU3RhdGVQcm9wZXJ0eSApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIG1hc3MgaW5zdGFuY2VvZiBJbWFnZU1hc3MgKSB7XHJcbiAgICAgIG1hc3NOb2RlID0gbmV3IEltYWdlTWFzc05vZGUoIG1hc3MsIG1vZGVsVmlld1RyYW5zZm9ybSwgaXNMYWJlbGVkLCBsYWJlbFZpc2libGVQcm9wZXJ0eSwgdHJ1ZSwgY29sdW1uU3RhdGVQcm9wZXJ0eSApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIG1hc3MgaW5zdGFuY2VvZiBCcmlja1N0YWNrICkge1xyXG4gICAgICBtYXNzTm9kZSA9IG5ldyBCcmlja1N0YWNrTm9kZSggbWFzcywgbW9kZWxWaWV3VHJhbnNmb3JtLCBpc0xhYmVsZWQsIGxhYmVsVmlzaWJsZVByb3BlcnR5LCB0cnVlLCBjb2x1bW5TdGF0ZVByb3BlcnR5ICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdHJ1ZSwgJ0Vycm9yOiBVbnJlY29nbml6ZWQgbWFzcyB0eXBlIHNlbnQgdG8gTWFzc05vZGVGYWN0b3J5LicgKTtcclxuICAgICAgLy8gSW4gY2FzZSB0aGUgZXZlciBoYXBwZW5zIG91dCBpbiB0aGUgd2lsZCwgY3JlYXRlIGEgZmFrZSBub2RlLlxyXG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9IG5ldyBUZXh0KCAnVW5pbXBsZW1lbnRlZCBNYXNzIE5vZGUnICk7XHJcbiAgICAgIG1hc3NOb2RlID0gbmV3IFJlY3RhbmdsZSggMCwgMCwgdGV4dE5vZGUud2lkdGggKiAxLjMsIHRleHROb2RlLmhlaWdodCAqIDEuMywgMCwgMCwge1xyXG4gICAgICAgIGZpbGw6ICdwaW5rJyxcclxuICAgICAgICBzdHJva2U6ICdibGFjaydcclxuICAgICAgfSApO1xyXG4gICAgICB0ZXh0Tm9kZS5jZW50ZXJZID0gbWFzc05vZGUuaGVpZ2h0IC8gMjtcclxuICAgICAgbWFzc05vZGUuYWRkQ2hpbGQoIHRleHROb2RlICk7XHJcbiAgICAgIG1hc3NOb2RlLmNlbnRlciA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1Bvc2l0aW9uKCBtYXNzLnBvc2l0aW9uUHJvcGVydHkuZ2V0KCkgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXNzTm9kZTtcclxuICB9XHJcbn07XHJcblxyXG5iYWxhbmNpbmdBY3QucmVnaXN0ZXIoICdNYXNzTm9kZUZhY3RvcnknLCBNYXNzTm9kZUZhY3RvcnkgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1hc3NOb2RlRmFjdG9yeTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVNBLFNBQVMsRUFBRUMsSUFBSSxRQUFRLG1DQUFtQztBQUNuRSxPQUFPQyxZQUFZLE1BQU0sdUJBQXVCO0FBQ2hELE9BQU9DLFNBQVMsTUFBTSx1QkFBdUI7QUFDN0MsT0FBT0MsVUFBVSxNQUFNLCtCQUErQjtBQUN0RCxPQUFPQyxXQUFXLE1BQU0sZ0NBQWdDO0FBQ3hELE9BQU9DLGNBQWMsTUFBTSxxQkFBcUI7QUFDaEQsT0FBT0MsYUFBYSxNQUFNLG9CQUFvQjtBQUM5QyxPQUFPQyxlQUFlLE1BQU0sc0JBQXNCO0FBRWxELE1BQU1DLGVBQWUsR0FBRztFQUN0QkMsY0FBY0EsQ0FBRUMsSUFBSSxFQUFFQyxrQkFBa0IsRUFBRUMsU0FBUyxFQUFFQyxvQkFBb0IsRUFBRUMsbUJBQW1CLEVBQUc7SUFDL0YsSUFBSUMsUUFBUTtJQUNaLElBQUtMLElBQUksWUFBWU4sV0FBVyxFQUFHO01BQ2pDVyxRQUFRLEdBQUcsSUFBSVIsZUFBZSxDQUFFRyxJQUFJLEVBQUVDLGtCQUFrQixFQUFFQyxTQUFTLEVBQUVDLG9CQUFvQixFQUFFLElBQUksRUFBRUMsbUJBQW9CLENBQUM7SUFDeEgsQ0FBQyxNQUNJLElBQUtKLElBQUksWUFBWVIsU0FBUyxFQUFHO01BQ3BDYSxRQUFRLEdBQUcsSUFBSVQsYUFBYSxDQUFFSSxJQUFJLEVBQUVDLGtCQUFrQixFQUFFQyxTQUFTLEVBQUVDLG9CQUFvQixFQUFFLElBQUksRUFBRUMsbUJBQW9CLENBQUM7SUFDdEgsQ0FBQyxNQUNJLElBQUtKLElBQUksWUFBWVAsVUFBVSxFQUFHO01BQ3JDWSxRQUFRLEdBQUcsSUFBSVYsY0FBYyxDQUFFSyxJQUFJLEVBQUVDLGtCQUFrQixFQUFFQyxTQUFTLEVBQUVDLG9CQUFvQixFQUFFLElBQUksRUFBRUMsbUJBQW9CLENBQUM7SUFDdkgsQ0FBQyxNQUNJO01BQ0hFLE1BQU0sSUFBSUEsTUFBTSxDQUFFLElBQUksRUFBRSx3REFBeUQsQ0FBQztNQUNsRjtNQUNBLE1BQU1DLFFBQVEsR0FBRyxJQUFJakIsSUFBSSxDQUFFLHlCQUEwQixDQUFDO01BQ3REZSxRQUFRLEdBQUcsSUFBSWhCLFNBQVMsQ0FBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFa0IsUUFBUSxDQUFDQyxLQUFLLEdBQUcsR0FBRyxFQUFFRCxRQUFRLENBQUNFLE1BQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUNqRkMsSUFBSSxFQUFFLE1BQU07UUFDWkMsTUFBTSxFQUFFO01BQ1YsQ0FBRSxDQUFDO01BQ0hKLFFBQVEsQ0FBQ0ssT0FBTyxHQUFHUCxRQUFRLENBQUNJLE1BQU0sR0FBRyxDQUFDO01BQ3RDSixRQUFRLENBQUNRLFFBQVEsQ0FBRU4sUUFBUyxDQUFDO01BQzdCRixRQUFRLENBQUNTLE1BQU0sR0FBR2Isa0JBQWtCLENBQUNjLG1CQUFtQixDQUFFZixJQUFJLENBQUNnQixnQkFBZ0IsQ0FBQ0MsR0FBRyxDQUFDLENBQUUsQ0FBQztJQUN6RjtJQUNBLE9BQU9aLFFBQVE7RUFDakI7QUFDRixDQUFDO0FBRURkLFlBQVksQ0FBQzJCLFFBQVEsQ0FBRSxpQkFBaUIsRUFBRXBCLGVBQWdCLENBQUM7QUFFM0QsZUFBZUEsZUFBZSJ9