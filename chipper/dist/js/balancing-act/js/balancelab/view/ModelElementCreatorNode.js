// Copyright 2013-2023, University of Colorado Boulder

/**
 * Base type for the Scenery nodes that appear in the view, generally in some sort of toolbox, and that can be clicked
 * on by the user in order to add model elements to the model.
 *
 * @author John Blanco
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import merge from '../../../../phet-core/js/merge.js';
import PhetFont from '../../../../scenery-phet/js/PhetFont.js';
import { DragListener, Node, Text } from '../../../../scenery/js/imports.js';
import Tandem from '../../../../tandem/js/Tandem.js';
import balancingAct from '../../balancingAct.js';

// constants
const CAPTION_OFFSET_FROM_SELECTION_NODE = 4;
const LABEL_FONT = new PhetFont(14);
const MAX_CAPTION_WIDTH_PROPORTION = 1.5; // max width for for the caption as a proportion of the creator node

class ModelElementCreatorNode extends Node {
  /**
   * @param {BasicBalanceScreenView} screenView
   * @param {Object} [options]
   */
  constructor(screenView, options) {
    options = merge({
      cursor: 'pointer',
      tandem: Tandem.REQUIRED
    }, options);
    super(options);
    const self = this;

    // Element in the model that is being moved by the user.  Only non-null if the user performed some action that
    // caused this to be created, such as clicking on this node.
    this.modelElement = null;

    // Offset used when adding an element to the model.  This is useful in making sure that the newly created object
    // isn't positioned in, shall we say, an awkward position with respect to the mouse.
    this.positioningOffset = Vector2.ZERO;

    // Function for translating click and touch events to model coordinates.
    const modelViewTransform = screenView.modelViewTransform;
    const eventToModelPosition = pointerPosition => {
      return modelViewTransform.viewToModelPosition(screenView.globalToLocalPoint(pointerPosition).plus(self.positioningOffset));
    };

    // Create an input listener that will add the model element to the model and then forward events to the view node
    // that is created as a result.
    this.addInputListener(DragListener.createForwardingListener(event => {
      // Determine the initial position where this element should move to after it's created based on the position of
      // the pointer event.
      const initialPosition = eventToModelPosition(event.pointer.point);

      // Create a new mass and add it to the model.  This will cause a view node to be created in the view.
      this.modelElement = this.addElementToModel(initialPosition);

      // Get the view node that should have appeared in the view so that events can be forwarded to its drag handler.
      const modelElementNode = screenView.getNodeForMass(this.modelElement);
      assert && assert(modelElementNode, 'unable to find view node for model element');
      modelElementNode.dragHandler.press(event, modelElementNode);
    }, {
      allowTouchSnag: true,
      tandem: options.tandem.createTandem('dragListener')
    }));
  }

  /**
   * Method overridden by subclasses to add the element that they represent to the model.
   * @public
   */
  addElementToModel() {
    throw new Error('addElementToModel should be implemented in descendant classes.');
  }

  /**
   * @param selectionNode
   * @public
   */
  setSelectionNode(selectionNode) {
    if (this.selectionNode) {
      throw new Error('Can\'t set selectionNode more than once.');
    }
    this.selectionNode = selectionNode;
    this.addChild(selectionNode);
    this.updateLayout();
  }

  /**
   * @param {String} captionText
   * @protected
   */
  setCaption(captionText) {
    this.caption = new Text(captionText, {
      font: LABEL_FONT
    });
    this.addChild(this.caption);
    this.updateLayout();
  }

  /**
   * @private
   */
  updateLayout() {
    // This only does something if both the element node and the caption are set.
    if (this.caption && this.selectionNode) {
      this.caption.maxWidth = this.selectionNode.width * MAX_CAPTION_WIDTH_PROPORTION;
      this.caption.centerX = this.selectionNode.centerX;
      this.caption.top = this.selectionNode.bottom + CAPTION_OFFSET_FROM_SELECTION_NODE;
    }
  }
}
balancingAct.register('ModelElementCreatorNode', ModelElementCreatorNode);
export default ModelElementCreatorNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwibWVyZ2UiLCJQaGV0Rm9udCIsIkRyYWdMaXN0ZW5lciIsIk5vZGUiLCJUZXh0IiwiVGFuZGVtIiwiYmFsYW5jaW5nQWN0IiwiQ0FQVElPTl9PRkZTRVRfRlJPTV9TRUxFQ1RJT05fTk9ERSIsIkxBQkVMX0ZPTlQiLCJNQVhfQ0FQVElPTl9XSURUSF9QUk9QT1JUSU9OIiwiTW9kZWxFbGVtZW50Q3JlYXRvck5vZGUiLCJjb25zdHJ1Y3RvciIsInNjcmVlblZpZXciLCJvcHRpb25zIiwiY3Vyc29yIiwidGFuZGVtIiwiUkVRVUlSRUQiLCJzZWxmIiwibW9kZWxFbGVtZW50IiwicG9zaXRpb25pbmdPZmZzZXQiLCJaRVJPIiwibW9kZWxWaWV3VHJhbnNmb3JtIiwiZXZlbnRUb01vZGVsUG9zaXRpb24iLCJwb2ludGVyUG9zaXRpb24iLCJ2aWV3VG9Nb2RlbFBvc2l0aW9uIiwiZ2xvYmFsVG9Mb2NhbFBvaW50IiwicGx1cyIsImFkZElucHV0TGlzdGVuZXIiLCJjcmVhdGVGb3J3YXJkaW5nTGlzdGVuZXIiLCJldmVudCIsImluaXRpYWxQb3NpdGlvbiIsInBvaW50ZXIiLCJwb2ludCIsImFkZEVsZW1lbnRUb01vZGVsIiwibW9kZWxFbGVtZW50Tm9kZSIsImdldE5vZGVGb3JNYXNzIiwiYXNzZXJ0IiwiZHJhZ0hhbmRsZXIiLCJwcmVzcyIsImFsbG93VG91Y2hTbmFnIiwiY3JlYXRlVGFuZGVtIiwiRXJyb3IiLCJzZXRTZWxlY3Rpb25Ob2RlIiwic2VsZWN0aW9uTm9kZSIsImFkZENoaWxkIiwidXBkYXRlTGF5b3V0Iiwic2V0Q2FwdGlvbiIsImNhcHRpb25UZXh0IiwiY2FwdGlvbiIsImZvbnQiLCJtYXhXaWR0aCIsIndpZHRoIiwiY2VudGVyWCIsInRvcCIsImJvdHRvbSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiTW9kZWxFbGVtZW50Q3JlYXRvck5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQmFzZSB0eXBlIGZvciB0aGUgU2NlbmVyeSBub2RlcyB0aGF0IGFwcGVhciBpbiB0aGUgdmlldywgZ2VuZXJhbGx5IGluIHNvbWUgc29ydCBvZiB0b29sYm94LCBhbmQgdGhhdCBjYW4gYmUgY2xpY2tlZFxyXG4gKiBvbiBieSB0aGUgdXNlciBpbiBvcmRlciB0byBhZGQgbW9kZWwgZWxlbWVudHMgdG8gdGhlIG1vZGVsLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvXHJcbiAqL1xyXG5cclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lcmdlLmpzJztcclxuaW1wb3J0IFBoZXRGb250IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9QaGV0Rm9udC5qcyc7XHJcbmltcG9ydCB7IERyYWdMaXN0ZW5lciwgTm9kZSwgVGV4dCB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBUYW5kZW0gZnJvbSAnLi4vLi4vLi4vLi4vdGFuZGVtL2pzL1RhbmRlbS5qcyc7XHJcbmltcG9ydCBiYWxhbmNpbmdBY3QgZnJvbSAnLi4vLi4vYmFsYW5jaW5nQWN0LmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBDQVBUSU9OX09GRlNFVF9GUk9NX1NFTEVDVElPTl9OT0RFID0gNDtcclxuY29uc3QgTEFCRUxfRk9OVCA9IG5ldyBQaGV0Rm9udCggMTQgKTtcclxuY29uc3QgTUFYX0NBUFRJT05fV0lEVEhfUFJPUE9SVElPTiA9IDEuNTsgLy8gbWF4IHdpZHRoIGZvciBmb3IgdGhlIGNhcHRpb24gYXMgYSBwcm9wb3J0aW9uIG9mIHRoZSBjcmVhdG9yIG5vZGVcclxuXHJcbmNsYXNzIE1vZGVsRWxlbWVudENyZWF0b3JOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7QmFzaWNCYWxhbmNlU2NyZWVuVmlld30gc2NyZWVuVmlld1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvciggc2NyZWVuVmlldywgb3B0aW9ucyApIHtcclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcclxuICAgICAgdGFuZGVtOiBUYW5kZW0uUkVRVUlSRURcclxuICAgIH0sIG9wdGlvbnMgKTtcclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICAvLyBFbGVtZW50IGluIHRoZSBtb2RlbCB0aGF0IGlzIGJlaW5nIG1vdmVkIGJ5IHRoZSB1c2VyLiAgT25seSBub24tbnVsbCBpZiB0aGUgdXNlciBwZXJmb3JtZWQgc29tZSBhY3Rpb24gdGhhdFxyXG4gICAgLy8gY2F1c2VkIHRoaXMgdG8gYmUgY3JlYXRlZCwgc3VjaCBhcyBjbGlja2luZyBvbiB0aGlzIG5vZGUuXHJcbiAgICB0aGlzLm1vZGVsRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgLy8gT2Zmc2V0IHVzZWQgd2hlbiBhZGRpbmcgYW4gZWxlbWVudCB0byB0aGUgbW9kZWwuICBUaGlzIGlzIHVzZWZ1bCBpbiBtYWtpbmcgc3VyZSB0aGF0IHRoZSBuZXdseSBjcmVhdGVkIG9iamVjdFxyXG4gICAgLy8gaXNuJ3QgcG9zaXRpb25lZCBpbiwgc2hhbGwgd2Ugc2F5LCBhbiBhd2t3YXJkIHBvc2l0aW9uIHdpdGggcmVzcGVjdCB0byB0aGUgbW91c2UuXHJcbiAgICB0aGlzLnBvc2l0aW9uaW5nT2Zmc2V0ID0gVmVjdG9yMi5aRVJPO1xyXG5cclxuICAgIC8vIEZ1bmN0aW9uIGZvciB0cmFuc2xhdGluZyBjbGljayBhbmQgdG91Y2ggZXZlbnRzIHRvIG1vZGVsIGNvb3JkaW5hdGVzLlxyXG4gICAgY29uc3QgbW9kZWxWaWV3VHJhbnNmb3JtID0gc2NyZWVuVmlldy5tb2RlbFZpZXdUcmFuc2Zvcm07XHJcbiAgICBjb25zdCBldmVudFRvTW9kZWxQb3NpdGlvbiA9IHBvaW50ZXJQb3NpdGlvbiA9PiB7XHJcbiAgICAgIHJldHVybiBtb2RlbFZpZXdUcmFuc2Zvcm0udmlld1RvTW9kZWxQb3NpdGlvbihcclxuICAgICAgICBzY3JlZW5WaWV3Lmdsb2JhbFRvTG9jYWxQb2ludCggcG9pbnRlclBvc2l0aW9uICkucGx1cyggc2VsZi5wb3NpdGlvbmluZ09mZnNldCApXHJcbiAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENyZWF0ZSBhbiBpbnB1dCBsaXN0ZW5lciB0aGF0IHdpbGwgYWRkIHRoZSBtb2RlbCBlbGVtZW50IHRvIHRoZSBtb2RlbCBhbmQgdGhlbiBmb3J3YXJkIGV2ZW50cyB0byB0aGUgdmlldyBub2RlXHJcbiAgICAvLyB0aGF0IGlzIGNyZWF0ZWQgYXMgYSByZXN1bHQuXHJcbiAgICB0aGlzLmFkZElucHV0TGlzdGVuZXIoIERyYWdMaXN0ZW5lci5jcmVhdGVGb3J3YXJkaW5nTGlzdGVuZXIoXHJcbiAgICAgIGV2ZW50ID0+IHtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBpbml0aWFsIHBvc2l0aW9uIHdoZXJlIHRoaXMgZWxlbWVudCBzaG91bGQgbW92ZSB0byBhZnRlciBpdCdzIGNyZWF0ZWQgYmFzZWQgb24gdGhlIHBvc2l0aW9uIG9mXHJcbiAgICAgICAgLy8gdGhlIHBvaW50ZXIgZXZlbnQuXHJcbiAgICAgICAgY29uc3QgaW5pdGlhbFBvc2l0aW9uID0gZXZlbnRUb01vZGVsUG9zaXRpb24oIGV2ZW50LnBvaW50ZXIucG9pbnQgKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG1hc3MgYW5kIGFkZCBpdCB0byB0aGUgbW9kZWwuICBUaGlzIHdpbGwgY2F1c2UgYSB2aWV3IG5vZGUgdG8gYmUgY3JlYXRlZCBpbiB0aGUgdmlldy5cclxuICAgICAgICB0aGlzLm1vZGVsRWxlbWVudCA9IHRoaXMuYWRkRWxlbWVudFRvTW9kZWwoIGluaXRpYWxQb3NpdGlvbiApO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHZpZXcgbm9kZSB0aGF0IHNob3VsZCBoYXZlIGFwcGVhcmVkIGluIHRoZSB2aWV3IHNvIHRoYXQgZXZlbnRzIGNhbiBiZSBmb3J3YXJkZWQgdG8gaXRzIGRyYWcgaGFuZGxlci5cclxuICAgICAgICBjb25zdCBtb2RlbEVsZW1lbnROb2RlID0gc2NyZWVuVmlldy5nZXROb2RlRm9yTWFzcyggdGhpcy5tb2RlbEVsZW1lbnQgKTtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBtb2RlbEVsZW1lbnROb2RlLCAndW5hYmxlIHRvIGZpbmQgdmlldyBub2RlIGZvciBtb2RlbCBlbGVtZW50JyApO1xyXG5cclxuICAgICAgICBtb2RlbEVsZW1lbnROb2RlLmRyYWdIYW5kbGVyLnByZXNzKCBldmVudCwgbW9kZWxFbGVtZW50Tm9kZSApO1xyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgYWxsb3dUb3VjaFNuYWc6IHRydWUsXHJcbiAgICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICdkcmFnTGlzdGVuZXInIClcclxuICAgICAgfVxyXG4gICAgKSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWV0aG9kIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3NlcyB0byBhZGQgdGhlIGVsZW1lbnQgdGhhdCB0aGV5IHJlcHJlc2VudCB0byB0aGUgbW9kZWwuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGFkZEVsZW1lbnRUb01vZGVsKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCAnYWRkRWxlbWVudFRvTW9kZWwgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGRlc2NlbmRhbnQgY2xhc3Nlcy4nICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gc2VsZWN0aW9uTm9kZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzZXRTZWxlY3Rpb25Ob2RlKCBzZWxlY3Rpb25Ob2RlICkge1xyXG4gICAgaWYgKCB0aGlzLnNlbGVjdGlvbk5vZGUgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvciggJ0NhblxcJ3Qgc2V0IHNlbGVjdGlvbk5vZGUgbW9yZSB0aGFuIG9uY2UuJyApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZWxlY3Rpb25Ob2RlID0gc2VsZWN0aW9uTm9kZTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIHNlbGVjdGlvbk5vZGUgKTtcclxuICAgIHRoaXMudXBkYXRlTGF5b3V0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2FwdGlvblRleHRcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXHJcbiAgc2V0Q2FwdGlvbiggY2FwdGlvblRleHQgKSB7XHJcbiAgICB0aGlzLmNhcHRpb24gPSBuZXcgVGV4dCggY2FwdGlvblRleHQsIHsgZm9udDogTEFCRUxfRk9OVCB9ICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCB0aGlzLmNhcHRpb24gKTtcclxuICAgIHRoaXMudXBkYXRlTGF5b3V0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHVwZGF0ZUxheW91dCgpIHtcclxuXHJcbiAgICAvLyBUaGlzIG9ubHkgZG9lcyBzb21ldGhpbmcgaWYgYm90aCB0aGUgZWxlbWVudCBub2RlIGFuZCB0aGUgY2FwdGlvbiBhcmUgc2V0LlxyXG4gICAgaWYgKCB0aGlzLmNhcHRpb24gJiYgdGhpcy5zZWxlY3Rpb25Ob2RlICkge1xyXG4gICAgICB0aGlzLmNhcHRpb24ubWF4V2lkdGggPSB0aGlzLnNlbGVjdGlvbk5vZGUud2lkdGggKiBNQVhfQ0FQVElPTl9XSURUSF9QUk9QT1JUSU9OO1xyXG4gICAgICB0aGlzLmNhcHRpb24uY2VudGVyWCA9IHRoaXMuc2VsZWN0aW9uTm9kZS5jZW50ZXJYO1xyXG4gICAgICB0aGlzLmNhcHRpb24udG9wID0gdGhpcy5zZWxlY3Rpb25Ob2RlLmJvdHRvbSArIENBUFRJT05fT0ZGU0VUX0ZST01fU0VMRUNUSU9OX05PREU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5iYWxhbmNpbmdBY3QucmVnaXN0ZXIoICdNb2RlbEVsZW1lbnRDcmVhdG9yTm9kZScsIE1vZGVsRWxlbWVudENyZWF0b3JOb2RlICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNb2RlbEVsZW1lbnRDcmVhdG9yTm9kZTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxPQUFPQyxLQUFLLE1BQU0sbUNBQW1DO0FBQ3JELE9BQU9DLFFBQVEsTUFBTSx5Q0FBeUM7QUFDOUQsU0FBU0MsWUFBWSxFQUFFQyxJQUFJLEVBQUVDLElBQUksUUFBUSxtQ0FBbUM7QUFDNUUsT0FBT0MsTUFBTSxNQUFNLGlDQUFpQztBQUNwRCxPQUFPQyxZQUFZLE1BQU0sdUJBQXVCOztBQUVoRDtBQUNBLE1BQU1DLGtDQUFrQyxHQUFHLENBQUM7QUFDNUMsTUFBTUMsVUFBVSxHQUFHLElBQUlQLFFBQVEsQ0FBRSxFQUFHLENBQUM7QUFDckMsTUFBTVEsNEJBQTRCLEdBQUcsR0FBRyxDQUFDLENBQUM7O0FBRTFDLE1BQU1DLHVCQUF1QixTQUFTUCxJQUFJLENBQUM7RUFFekM7QUFDRjtBQUNBO0FBQ0E7RUFDRVEsV0FBV0EsQ0FBRUMsVUFBVSxFQUFFQyxPQUFPLEVBQUc7SUFDakNBLE9BQU8sR0FBR2IsS0FBSyxDQUFFO01BQ2ZjLE1BQU0sRUFBRSxTQUFTO01BQ2pCQyxNQUFNLEVBQUVWLE1BQU0sQ0FBQ1c7SUFDakIsQ0FBQyxFQUFFSCxPQUFRLENBQUM7SUFDWixLQUFLLENBQUVBLE9BQVEsQ0FBQztJQUNoQixNQUFNSSxJQUFJLEdBQUcsSUFBSTs7SUFFakI7SUFDQTtJQUNBLElB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