// Copyright 2021, University of Colorado Boulder

/**
 * Checks status for repos, and prints it out to the console
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

const cloneMissingRepos = require('../common/cloneMissingRepos');
const execute = require('../common/execute');
const getActiveRepos = require('../common/getActiveRepos');
const getBranches = require('../common/getBranches');
const gitCheckout = require('../common/gitCheckout');
const gitIsClean = require('../common/gitIsClean');
const gitPullRebase = require('../common/gitPullRebase');
const gitRevParse = require('../common/gitRevParse');
const npmUpdate = require('../common/npmUpdate');
const winston = require('winston');
const _ = require('lodash');
winston.default.transports.console.level = 'error';

// ANSI escape sequences to move to the right (in the same line) or to apply or reset colors
const moveRight = ' \u001b[42G';
const red = '\u001b[31m';
const green = '\u001b[32m';
const reset = '\u001b[0m';
const repos = getActiveRepos();
const data = {};

// If this is provided, we'll track ALL remote branches, check them out, and pull them (with rebase)
const allBranches = process.argv.includes('--allBranches');
const getStatus = async repo => {
  data[repo] = '';
  try {
    if (await gitIsClean(repo)) {
      if (allBranches) {
        const branches = await getBranches(repo);
        for (const branch of branches) {
          // Only track the remote branch if it hasn't been tracked yet
          if ((await execute('git', ['rev-parse', '--verify', branch], `../${repo}`, {
            errors: 'resolve'
          })).code !== 0) {
            await execute('git', ['branch', '--track', branch, `origin/${branch}`], `../${repo}`);
          }
          await gitCheckout(repo, branch);
          try {
            await gitPullRebase(repo);
          } catch (e) {
            // Likely there is no tracking info set up on the local branch
            await execute('git', ['branch', `--set-upstream-to=origin/${branch}`, branch], `../${repo}`);
            await gitPullRebase(repo);
          }
        }

        // Go back to master
        await gitCheckout(repo, 'master');
      } else {
        await gitCheckout(repo, 'master');
        await gitPullRebase(repo);
      }
    } else if (repo === 'perennial') {
      console.log(`${red}perennial is not clean, skipping pull${reset}`);
    }
    if (repo === 'perennial') {
      await cloneMissingRepos();
    }
    const symbolicRef = (await execute('git', ['symbolic-ref', '-q', 'HEAD'], `../${repo}`)).trim();
    const branch = symbolicRef.replace('refs/heads/', ''); // might be empty string
    const sha = await gitRevParse(repo, 'HEAD');
    const status = await execute('git', ['status', '--porcelain'], `../${repo}`);
    const track = branch ? (await execute('git', ['for-each-ref', '--format=%(push:track,nobracket)', symbolicRef], `../${repo}`)).trim() : '';
    let isGreen = false;
    if (branch) {
      isGreen = !status && branch === 'master' && !track.length;
      if (!isGreen || process.argv.includes('--all')) {
        data[repo] += `${repo}${moveRight}${isGreen ? green : red}${branch}${reset} ${track}\n`;
      }
    } else {
      // if no branch, print our SHA (detached head)
      data[repo] += `${repo}${moveRight}${red}${sha}${reset}\n`;
    }
    if (status) {
      if (!isGreen || process.argv.includes('--all')) {
        data[repo] += status + '\n';
      }
    }
  } catch (e) {
    data[repo] += `${repo} ERROR: ${e}`;
  }
};
(async () => {
  await Promise.all(repos.map(repo => getStatus(repo)));
  repos.forEach(repo => {
    process.stdout.write(data[repo]);
  });
  console.log(`${_.every(repos, repo => !data[repo].length) ? green : red}-----=====] finished pulls [=====-----${reset}\n`);
  await npmUpdate('chipper');
  await npmUpdate('perennial');
  await npmUpdate('perennial-alias');
  console.log(`${_.every(repos, repo => !data[repo].length) ? green : red}-----=====] finished npm [=====-----${reset}\n`);
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjbG9uZU1pc3NpbmdSZXBvcyIsInJlcXVpcmUiLCJleGVjdXRlIiwiZ2V0QWN0aXZlUmVwb3MiLCJnZXRCcmFuY2hlcyIsImdpdENoZWNrb3V0IiwiZ2l0SXNDbGVhbiIsImdpdFB1bGxSZWJhc2UiLCJnaXRSZXZQYXJzZSIsIm5wbVVwZGF0ZSIsIndpbnN0b24iLCJfIiwiZGVmYXVsdCIsInRyYW5zcG9ydHMiLCJjb25zb2xlIiwibGV2ZWwiLCJtb3ZlUmlnaHQiLCJyZWQiLCJncmVlbiIsInJlc2V0IiwicmVwb3MiLCJkYXRhIiwiYWxsQnJhbmNoZXMiLCJwcm9jZXNzIiwiYXJndiIsImluY2x1ZGVzIiwiZ2V0U3RhdHVzIiwicmVwbyIsImJyYW5jaGVzIiwiYnJhbmNoIiwiZXJyb3JzIiwiY29kZSIsImUiLCJsb2ciLCJzeW1ib2xpY1JlZiIsInRyaW0iLCJyZXBsYWNlIiwic2hhIiwic3RhdHVzIiwidHJhY2siLCJpc0dyZWVuIiwibGVuZ3RoIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImZvckVhY2giLCJzdGRvdXQiLCJ3cml0ZSIsImV2ZXJ5Il0sInNvdXJjZXMiOlsibWFzdGVyLXB1bGwtc3RhdHVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgc3RhdHVzIGZvciByZXBvcywgYW5kIHByaW50cyBpdCBvdXQgdG8gdGhlIGNvbnNvbGVcclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmNvbnN0IGNsb25lTWlzc2luZ1JlcG9zID0gcmVxdWlyZSggJy4uL2NvbW1vbi9jbG9uZU1pc3NpbmdSZXBvcycgKTtcclxuY29uc3QgZXhlY3V0ZSA9IHJlcXVpcmUoICcuLi9jb21tb24vZXhlY3V0ZScgKTtcclxuY29uc3QgZ2V0QWN0aXZlUmVwb3MgPSByZXF1aXJlKCAnLi4vY29tbW9uL2dldEFjdGl2ZVJlcG9zJyApO1xyXG5jb25zdCBnZXRCcmFuY2hlcyA9IHJlcXVpcmUoICcuLi9jb21tb24vZ2V0QnJhbmNoZXMnICk7XHJcbmNvbnN0IGdpdENoZWNrb3V0ID0gcmVxdWlyZSggJy4uL2NvbW1vbi9naXRDaGVja291dCcgKTtcclxuY29uc3QgZ2l0SXNDbGVhbiA9IHJlcXVpcmUoICcuLi9jb21tb24vZ2l0SXNDbGVhbicgKTtcclxuY29uc3QgZ2l0UHVsbFJlYmFzZSA9IHJlcXVpcmUoICcuLi9jb21tb24vZ2l0UHVsbFJlYmFzZScgKTtcclxuY29uc3QgZ2l0UmV2UGFyc2UgPSByZXF1aXJlKCAnLi4vY29tbW9uL2dpdFJldlBhcnNlJyApO1xyXG5jb25zdCBucG1VcGRhdGUgPSByZXF1aXJlKCAnLi4vY29tbW9uL25wbVVwZGF0ZScgKTtcclxuY29uc3Qgd2luc3RvbiA9IHJlcXVpcmUoICd3aW5zdG9uJyApO1xyXG5jb25zdCBfID0gcmVxdWlyZSggJ2xvZGFzaCcgKTtcclxuXHJcbndpbnN0b24uZGVmYXVsdC50cmFuc3BvcnRzLmNvbnNvbGUubGV2ZWwgPSAnZXJyb3InO1xyXG5cclxuLy8gQU5TSSBlc2NhcGUgc2VxdWVuY2VzIHRvIG1vdmUgdG8gdGhlIHJpZ2h0IChpbiB0aGUgc2FtZSBsaW5lKSBvciB0byBhcHBseSBvciByZXNldCBjb2xvcnNcclxuY29uc3QgbW92ZVJpZ2h0ID0gJyBcXHUwMDFiWzQyRyc7XHJcbmNvbnN0IHJlZCA9ICdcXHUwMDFiWzMxbSc7XHJcbmNvbnN0IGdyZWVuID0gJ1xcdTAwMWJbMzJtJztcclxuY29uc3QgcmVzZXQgPSAnXFx1MDAxYlswbSc7XHJcblxyXG5jb25zdCByZXBvcyA9IGdldEFjdGl2ZVJlcG9zKCk7XHJcbmNvbnN0IGRhdGEgPSB7fTtcclxuXHJcbi8vIElmIHRoaXMgaXMgcHJvdmlkZWQsIHdlJ2xsIHRyYWNrIEFMTCByZW1vdGUgYnJhbmNoZXMsIGNoZWNrIHRoZW0gb3V0LCBhbmQgcHVsbCB0aGVtICh3aXRoIHJlYmFzZSlcclxuY29uc3QgYWxsQnJhbmNoZXMgPSBwcm9jZXNzLmFyZ3YuaW5jbHVkZXMoICctLWFsbEJyYW5jaGVzJyApO1xyXG5cclxuY29uc3QgZ2V0U3RhdHVzID0gYXN5bmMgcmVwbyA9PiB7XHJcbiAgZGF0YVsgcmVwbyBdID0gJyc7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBpZiAoIGF3YWl0IGdpdElzQ2xlYW4oIHJlcG8gKSApIHtcclxuICAgICAgaWYgKCBhbGxCcmFuY2hlcyApIHtcclxuICAgICAgICBjb25zdCBicmFuY2hlcyA9IGF3YWl0IGdldEJyYW5jaGVzKCByZXBvICk7XHJcbiAgICAgICAgZm9yICggY29uc3QgYnJhbmNoIG9mIGJyYW5jaGVzICkge1xyXG4gICAgICAgICAgLy8gT25seSB0cmFjayB0aGUgcmVtb3RlIGJyYW5jaCBpZiBpdCBoYXNuJ3QgYmVlbiB0cmFja2VkIHlldFxyXG4gICAgICAgICAgaWYgKCAoIGF3YWl0IGV4ZWN1dGUoICdnaXQnLCBbICdyZXYtcGFyc2UnLCAnLS12ZXJpZnknLCBicmFuY2ggXSwgYC4uLyR7cmVwb31gLCB7IGVycm9yczogJ3Jlc29sdmUnIH0gKSApLmNvZGUgIT09IDAgKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGV4ZWN1dGUoICdnaXQnLCBbICdicmFuY2gnLCAnLS10cmFjaycsIGJyYW5jaCwgYG9yaWdpbi8ke2JyYW5jaH1gIF0sIGAuLi8ke3JlcG99YCApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXdhaXQgZ2l0Q2hlY2tvdXQoIHJlcG8sIGJyYW5jaCApO1xyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGdpdFB1bGxSZWJhc2UoIHJlcG8gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNhdGNoKCBlICkge1xyXG5cclxuICAgICAgICAgICAgLy8gTGlrZWx5IHRoZXJlIGlzIG5vIHRyYWNraW5nIGluZm8gc2V0IHVwIG9uIHRoZSBsb2NhbCBicmFuY2hcclxuICAgICAgICAgICAgYXdhaXQgZXhlY3V0ZSggJ2dpdCcsIFsgJ2JyYW5jaCcsIGAtLXNldC11cHN0cmVhbS10bz1vcmlnaW4vJHticmFuY2h9YCwgYnJhbmNoIF0sIGAuLi8ke3JlcG99YCApO1xyXG4gICAgICAgICAgICBhd2FpdCBnaXRQdWxsUmViYXNlKCByZXBvICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHbyBiYWNrIHRvIG1hc3RlclxyXG4gICAgICAgIGF3YWl0IGdpdENoZWNrb3V0KCByZXBvLCAnbWFzdGVyJyApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IGdpdENoZWNrb3V0KCByZXBvLCAnbWFzdGVyJyApO1xyXG4gICAgICAgIGF3YWl0IGdpdFB1bGxSZWJhc2UoIHJlcG8gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIHJlcG8gPT09ICdwZXJlbm5pYWwnICkge1xyXG4gICAgICBjb25zb2xlLmxvZyggYCR7cmVkfXBlcmVubmlhbCBpcyBub3QgY2xlYW4sIHNraXBwaW5nIHB1bGwke3Jlc2V0fWAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIHJlcG8gPT09ICdwZXJlbm5pYWwnICkge1xyXG4gICAgICBhd2FpdCBjbG9uZU1pc3NpbmdSZXBvcygpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN5bWJvbGljUmVmID0gKCBhd2FpdCBleGVjdXRlKCAnZ2l0JywgWyAnc3ltYm9saWMtcmVmJywgJy1xJywgJ0hFQUQnIF0sIGAuLi8ke3JlcG99YCApICkudHJpbSgpO1xyXG4gICAgY29uc3QgYnJhbmNoID0gc3ltYm9saWNSZWYucmVwbGFjZSggJ3JlZnMvaGVhZHMvJywgJycgKTsgLy8gbWlnaHQgYmUgZW1wdHkgc3RyaW5nXHJcbiAgICBjb25zdCBzaGEgPSBhd2FpdCBnaXRSZXZQYXJzZSggcmVwbywgJ0hFQUQnICk7XHJcbiAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBleGVjdXRlKCAnZ2l0JywgWyAnc3RhdHVzJywgJy0tcG9yY2VsYWluJyBdLCBgLi4vJHtyZXBvfWAgKTtcclxuICAgIGNvbnN0IHRyYWNrID0gYnJhbmNoID8gKCBhd2FpdCBleGVjdXRlKCAnZ2l0JywgWyAnZm9yLWVhY2gtcmVmJywgJy0tZm9ybWF0PSUocHVzaDp0cmFjayxub2JyYWNrZXQpJywgc3ltYm9saWNSZWYgXSwgYC4uLyR7cmVwb31gICkgKS50cmltKCkgOiAnJztcclxuXHJcbiAgICBsZXQgaXNHcmVlbiA9IGZhbHNlO1xyXG4gICAgaWYgKCBicmFuY2ggKSB7XHJcbiAgICAgIGlzR3JlZW4gPSAhc3RhdHVzICYmIGJyYW5jaCA9PT0gJ21hc3RlcicgJiYgIXRyYWNrLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmICggIWlzR3JlZW4gfHwgcHJvY2Vzcy5hcmd2LmluY2x1ZGVzKCAnLS1hbGwnICkgKSB7XHJcbiAgICAgICAgZGF0YVsgcmVwbyBdICs9IGAke3JlcG99JHttb3ZlUmlnaHR9JHtpc0dyZWVuID8gZ3JlZW4gOiByZWR9JHticmFuY2h9JHtyZXNldH0gJHt0cmFja31cXG5gO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gaWYgbm8gYnJhbmNoLCBwcmludCBvdXIgU0hBIChkZXRhY2hlZCBoZWFkKVxyXG4gICAgICBkYXRhWyByZXBvIF0gKz0gYCR7cmVwb30ke21vdmVSaWdodH0ke3JlZH0ke3NoYX0ke3Jlc2V0fVxcbmA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCBzdGF0dXMgKSB7XHJcbiAgICAgIGlmICggIWlzR3JlZW4gfHwgcHJvY2Vzcy5hcmd2LmluY2x1ZGVzKCAnLS1hbGwnICkgKSB7XHJcbiAgICAgICAgZGF0YVsgcmVwbyBdICs9IHN0YXR1cyArICdcXG4nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNhdGNoKCBlICkge1xyXG4gICAgZGF0YVsgcmVwbyBdICs9IGAke3JlcG99IEVSUk9SOiAke2V9YDtcclxuICB9XHJcbn07XHJcblxyXG4oIGFzeW5jICgpID0+IHtcclxuICBhd2FpdCBQcm9taXNlLmFsbCggcmVwb3MubWFwKCByZXBvID0+IGdldFN0YXR1cyggcmVwbyApICkgKTtcclxuXHJcbiAgcmVwb3MuZm9yRWFjaCggcmVwbyA9PiB7XHJcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSggZGF0YVsgcmVwbyBdICk7XHJcbiAgfSApO1xyXG5cclxuICBjb25zb2xlLmxvZyggYCR7Xy5ldmVyeSggcmVwb3MsIHJlcG8gPT4gIWRhdGFbIHJlcG8gXS5sZW5ndGggKSA/IGdyZWVuIDogcmVkfS0tLS0tPT09PT1dIGZpbmlzaGVkIHB1bGxzIFs9PT09PS0tLS0tJHtyZXNldH1cXG5gICk7XHJcblxyXG4gIGF3YWl0IG5wbVVwZGF0ZSggJ2NoaXBwZXInICk7XHJcbiAgYXdhaXQgbnBtVXBkYXRlKCAncGVyZW5uaWFsJyApO1xyXG4gIGF3YWl0IG5wbVVwZGF0ZSggJ3BlcmVubmlhbC1hbGlhcycgKTtcclxuXHJcbiAgY29uc29sZS5sb2coIGAke18uZXZlcnkoIHJlcG9zLCByZXBvID0+ICFkYXRhWyByZXBvIF0ubGVuZ3RoICkgPyBncmVlbiA6IHJlZH0tLS0tLT09PT09XSBmaW5pc2hlZCBucG0gWz09PT09LS0tLS0ke3Jlc2V0fVxcbmAgKTtcclxufSApKCk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNQSxpQkFBaUIsR0FBR0MsT0FBTyxDQUFFLDZCQUE4QixDQUFDO0FBQ2xFLE1BQU1DLE9BQU8sR0FBR0QsT0FBTyxDQUFFLG1CQUFvQixDQUFDO0FBQzlDLE1BQU1FLGNBQWMsR0FBR0YsT0FBTyxDQUFFLDBCQUEyQixDQUFDO0FBQzVELE1BQU1HLFdBQVcsR0FBR0gsT0FBTyxDQUFFLHVCQUF3QixDQUFDO0FBQ3RELE1BQU1JLFdBQVcsR0FBR0osT0FBTyxDQUFFLHVCQUF3QixDQUFDO0FBQ3RE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