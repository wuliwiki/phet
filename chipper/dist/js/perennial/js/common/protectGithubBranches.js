// Copyright 2021, University of Colorado Boulder

/**
 * Sets branch protection rules for the provided list of repositories. The default branch protection rules prevent
 * deletion of the branch. There are other things you can do with branch protection rules but we decided not to
 * apply them at this time. See https://github.com/phetsims/special-ops/issues/197 for more information.
 *
 * See https://docs.github.com/en/graphql/reference/input-objects#createbranchprotectionruleinput for documentation
 * of what you can do with protection rules.
 *
 * If rules for the protected patterns already exist they will be deleted and replaced so they can be easily updated.
 *
 * USAGE:
 * protectGithubBranches.protectBranches( [ "my-first-repo", "my-second-repo" ] );
 *
 * of
 *
 * protectGithubBranches.clearBranchProtections( [ "my-first-repo", "my-second-repo" ] );
 *
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

const https = require('https');
const buildLocal = require('./buildLocal');

// protects master, main, and all branche used in production deploys
const BRANCH_NAME_PATTERNS = ['master', 'main', '*[0-9].[0-9]*'];

// Options for the https request to the github graphql server
const options = {
  hostname: 'api.github.com',
  path: '/graphql',
  method: 'POST',
  headers: {
    Authorization: `Bearer ${buildLocal.developerGithubAccessToken}`,
    'Content-Type': 'application/json',
    'user-agent': 'node.js'
  }
};

/**
 * Creates the GraphQL query string to get the existing branch protection rules for the provided repo name under
 * the phetsims project.
 *
 * @param {string} repositoryName
 * @returns {string}
 */
const createBranchProtectionRuleQueryData = repositoryName => {
  return createQueryData(`query BranchProtectionRule {
    repository(owner: "phetsims", name: "${repositoryName}") { 
      branchProtectionRules(first: 100) { 
        nodes {
          # pattern for the rule 
          pattern,
          
          # uniqueID for the rule assigned by github, required to request deletion
          id
        }
      }
    } }`);
};

/**
 * Gets the GraphQL query string that will delete an existing branch protection rule. Use
 * createBranchProtectionRuleQueryData to get the unique IDs for each rule.
 *
 * @param ruleId
 * @returns {string}
 */
const createDeleteBranchProtectionRuleMutationData = ruleId => {
  return createQueryData(`mutation {
    deleteBranchProtectionRule(input:{branchProtectionRuleId: "${ruleId}"} ) {
      clientMutationId
    }
  }`);
};

/**
 * Creates the data string that requests the creation of a new github branch protection rule using a GraphQL query and
 * sent with an HTTPS request. The default rule prevents branch deletion. There are other things that can be
 * constrained or protected for the branch, but we decided not to apply anything else at this time.
 * See https://docs.github.com/en/graphql/reference/input-objects#createbranchprotectionruleinput for list
 * of things you can do with rules.
 *
 * @param {string} repositoryId - Unique ID for the repo, see createRepositoryIdQueryData()
 * @param {string} namePattern - pattern for the rule, all branches matching with fnmatch will be protected
 * @returns {string}
 */
const createRepositoryRuleMutationData = (repositoryId, namePattern) => {
  return createQueryData(`mutation {
    createBranchProtectionRule(input: {
      pattern: "${namePattern}",
      allowsDeletions: false,
  
      repositoryId: "${repositoryId}"
    } )
    
    # I think this specifies the data returned after the server receives the mutation request, not used but required
    # to send the mutation
    {
      branchProtectionRule {
        pattern
      }
    }
    }`);
};

/**
 * Creates the data string that requests the unique ID of a github repository using a GraphQL query sent with an
 * HTTPS request.
 *
 * @param {string} repositoryName - Name of the phetsims repository
 * @returns {string}
 */
const createRepositoryIdQueryData = repositoryName => {
  return createQueryData(`query { repository(owner: "phetsims", name: "${repositoryName}") { id } }`);
};

/**
 * Wraps a query string with additional formatting so that it can be used in a GraphQL query sent with https.
 *
 * @param {string} queryString
 * @returns {string}
 */
const createQueryData = queryString => {
  return JSON.stringify({
    query: queryString
  });
};

/**
 * Returns the unique ID of the provided phetsims repository.
 * @param {string} repositoryName
 * @returns {Promise<string>}
 */
async function getRepositoryId(repositoryName) {
  const handleJSONResponse = jsonResponse => {
    if (!jsonResponse.data || jsonResponse.data.repository === null) {
      throw new Error(`Did not find repository: ${repositoryName}`);
    }
    return jsonResponse.data.repository.id;
  };
  return sendPromisedHttpsRequest(createRepositoryIdQueryData(repositoryName), handleJSONResponse);
}

/**
 * Returns an array of objects, one for each existing branch protection rule for the repository, that has
 * the protection rule pattern and the unique ID for the rule assigned by github.
 *
 * @param {string} repositoryName
 * @returns {Promise<*[]>} - array of nodes with key value pairs of { "pattern": string, "id": string }
 */
async function getExistingBranchProtectionRules(repositoryName) {
  const handleJSONResponse = jsonResponse => {
    if (jsonResponse.errors) {
      throw new Error(jsonResponse.errors);
    }
    if (!jsonResponse.data) {
      throw new Error(`No data returned by getExistingBranchProtectionRules for repo ${repositoryName}`);
    }
    return jsonResponse.data.repository.branchProtectionRules.nodes;
  };
  return sendPromisedHttpsRequest(createBranchProtectionRuleQueryData(repositoryName), handleJSONResponse);
}

/**
 * Creates the protection rule for all branches matching the namePattern for the phetsims repository with the provided
 * unique ID assigned by github.
 *
 * @param {string} repositoryId - unique ID for the repository, use getRepositoryId to get this
 * @param {string} namePattern - The pattern for the rule using fnmatch
 * @returns {Promise<Object>}
 */
async function writeProtectionRule(repositoryId, namePattern) {
  const handleJSONResponse = jsonResponse => {
    if (jsonResponse.errors) {
      throw new Error(jsonResponse.errors);
    }
  };
  return sendPromisedHttpsRequest(createRepositoryRuleMutationData(repositoryId, namePattern), handleJSONResponse);
}

/**
 * Deletes an existing rule. We assume that that by running this we want to overwrite the existing rule.
 *
 * @param {string} ruleId
 * @param {string} namePattern
 * @param {string} repositoryName
 * @returns {Promise<Object>}
 */
async function deleteExistingProtectionRule(ruleId, namePattern, repositoryName) {
  const handleJSONResponse = jsonResponse => {
    if (jsonResponse.errors) {
      throw new Error(jsonResponse.errors);
    } else {
      console.log(`Deleted existing branch protection rule ${namePattern} for repo ${repositoryName}`);
    }
  };
  return sendPromisedHttpsRequest(createDeleteBranchProtectionRuleMutationData(ruleId), handleJSONResponse);
}

/**
 * An async function that will delete all existing rules that match the provided namePattern for the repository.
 * Wrapped in a Promise so we can wait to write new rules until the existing rules are removed. If you try to
 * write over an existing rule without removing it github will respond with an error.
 *
 * @param {*[]} rules
 * @param {string} namePattern
 * @param {string} repositoryName
 * @returns {Promise<unknown[]>}
 */
async function deleteMatchingProtectionRules(rules, namePattern, repositoryName) {
  const promises = [];
  rules.forEach(rule => {
    // only delete rules that match the new pattern we want to protect
    if (rule.pattern === namePattern) {
      promises.push(deleteExistingProtectionRule(rule.id, namePattern, repositoryName));
    }
  });
  return Promise.all(promises);
}

/**
 * Sends a request to github's GraphQL server to query or mutate repository data.
 *
 * @param {string} queryData - the string sent with https
 * @param {function(Object)} handle - handles the JSON response from github
 * @returns {Promise<unknown>}
 */
async function sendPromisedHttpsRequest(queryData, handle) {
  return new Promise((resolve, reject) => {
    const request = https.request(options, response => {
      let responseBody = '';
      response.on('data', d => {
        responseBody += d;
      });
      response.on('end', () => {
        const jsonResponse = JSON.parse(responseBody);
        try {
          const resolveValue = handle(jsonResponse);
          resolve(resolveValue);
        } catch (error) {
          reject(error);
        }
      });
    });
    request.on('error', error => {
      console.error(error);
    });
    request.write(queryData);
    request.end();
  });
}

/**
 * Clear protections for the branches that PhET wants to protect.
 */
async function clearBranchProtections(repositories) {
  for (const repositoryName of repositories) {
    for (const namePattern of BRANCH_NAME_PATTERNS) {
      try {
        const branchProtectionRules = await getExistingBranchProtectionRules(repositoryName);
        await deleteMatchingProtectionRules(branchProtectionRules, namePattern, repositoryName);
      } catch (error) {
        console.log(`Error clearing github protection rule ${namePattern} for ${repositoryName}`);
      }
    }
  }
}

/**
 * Apply branch protection rules to prodcution branches (master, main, release branches).
 */
async function protectBranches(repositories) {
  // if the rule for the protected branch already exists, delete it - we assume that running this again means we
  // want to update rules for each namePattern
  await clearBranchProtections(repositories);
  for (const repositoryName of repositories) {
    // get the unique ID for each repository
    const repositoryId = await getRepositoryId(repositoryName);
    for (const namePattern of BRANCH_NAME_PATTERNS) {
      try {
        await writeProtectionRule(repositoryId, namePattern);
        console.log(`${namePattern} protection rule set for ${repositoryName}`);
      } catch (error) {
        console.log(`Error writing ${namePattern} rule for repo ${repositoryName}:`);
        console.log(error);
        console.log('\n');
      }
    }
  }
}
module.exports = {
  protectBranches: protectBranches,
  clearBranchProtections: clearBranchProtections
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJodHRwcyIsInJlcXVpcmUiLCJidWlsZExvY2FsIiwiQlJBTkNIX05BTUVfUEFUVEVSTlMiLCJvcHRpb25zIiwiaG9zdG5hbWUiLCJwYXRoIiwibWV0aG9kIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJkZXZlbG9wZXJHaXRodWJBY2Nlc3NUb2tlbiIsImNyZWF0ZUJyYW5jaFByb3RlY3Rpb25SdWxlUXVlcnlEYXRhIiwicmVwb3NpdG9yeU5hbWUiLCJjcmVhdGVRdWVyeURhdGEiLCJjcmVhdGVEZWxldGVCcmFuY2hQcm90ZWN0aW9uUnVsZU11dGF0aW9uRGF0YSIsInJ1bGVJZCIsImNyZWF0ZVJlcG9zaXRvcnlSdWxlTXV0YXRpb25EYXRhIiwicmVwb3NpdG9yeUlkIiwibmFtZVBhdHRlcm4iLCJjcmVhdGVSZXBvc2l0b3J5SWRRdWVyeURhdGEiLCJxdWVyeVN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWVyeSIsImdldFJlcG9zaXRvcnlJZCIsImhhbmRsZUpTT05SZXNwb25zZSIsImpzb25SZXNwb25zZSIsImRhdGEiLCJyZXBvc2l0b3J5IiwiRXJyb3IiLCJpZCIsInNlbmRQcm9taXNlZEh0dHBzUmVxdWVzdCIsImdldEV4aXN0aW5nQnJhbmNoUHJvdGVjdGlvblJ1bGVzIiwiZXJyb3JzIiwiYnJhbmNoUHJvdGVjdGlvblJ1bGVzIiwibm9kZXMiLCJ3cml0ZVByb3RlY3Rpb25SdWxlIiwiZGVsZXRlRXhpc3RpbmdQcm90ZWN0aW9uUnVsZSIsImNvbnNvbGUiLCJsb2ciLCJkZWxldGVNYXRjaGluZ1Byb3RlY3Rpb25SdWxlcyIsInJ1bGVzIiwicHJvbWlzZXMiLCJmb3JFYWNoIiwicnVsZSIsInBhdHRlcm4iLCJwdXNoIiwiUHJvbWlzZSIsImFsbCIsInF1ZXJ5RGF0YSIsImhhbmRsZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZXF1ZXN0IiwicmVzcG9uc2UiLCJyZXNwb25zZUJvZHkiLCJvbiIsImQiLCJwYXJzZSIsInJlc29sdmVWYWx1ZSIsImVycm9yIiwid3JpdGUiLCJlbmQiLCJjbGVhckJyYW5jaFByb3RlY3Rpb25zIiwicmVwb3NpdG9yaWVzIiwicHJvdGVjdEJyYW5jaGVzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbInByb3RlY3RHaXRodWJCcmFuY2hlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMSwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogU2V0cyBicmFuY2ggcHJvdGVjdGlvbiBydWxlcyBmb3IgdGhlIHByb3ZpZGVkIGxpc3Qgb2YgcmVwb3NpdG9yaWVzLiBUaGUgZGVmYXVsdCBicmFuY2ggcHJvdGVjdGlvbiBydWxlcyBwcmV2ZW50XHJcbiAqIGRlbGV0aW9uIG9mIHRoZSBicmFuY2guIFRoZXJlIGFyZSBvdGhlciB0aGluZ3MgeW91IGNhbiBkbyB3aXRoIGJyYW5jaCBwcm90ZWN0aW9uIHJ1bGVzIGJ1dCB3ZSBkZWNpZGVkIG5vdCB0b1xyXG4gKiBhcHBseSB0aGVtIGF0IHRoaXMgdGltZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zcGVjaWFsLW9wcy9pc3N1ZXMvMTk3IGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vZ3JhcGhxbC9yZWZlcmVuY2UvaW5wdXQtb2JqZWN0cyNjcmVhdGVicmFuY2hwcm90ZWN0aW9ucnVsZWlucHV0IGZvciBkb2N1bWVudGF0aW9uXHJcbiAqIG9mIHdoYXQgeW91IGNhbiBkbyB3aXRoIHByb3RlY3Rpb24gcnVsZXMuXHJcbiAqXHJcbiAqIElmIHJ1bGVzIGZvciB0aGUgcHJvdGVjdGVkIHBhdHRlcm5zIGFscmVhZHkgZXhpc3QgdGhleSB3aWxsIGJlIGRlbGV0ZWQgYW5kIHJlcGxhY2VkIHNvIHRoZXkgY2FuIGJlIGVhc2lseSB1cGRhdGVkLlxyXG4gKlxyXG4gKiBVU0FHRTpcclxuICogcHJvdGVjdEdpdGh1YkJyYW5jaGVzLnByb3RlY3RCcmFuY2hlcyggWyBcIm15LWZpcnN0LXJlcG9cIiwgXCJteS1zZWNvbmQtcmVwb1wiIF0gKTtcclxuICpcclxuICogb2ZcclxuICpcclxuICogcHJvdGVjdEdpdGh1YkJyYW5jaGVzLmNsZWFyQnJhbmNoUHJvdGVjdGlvbnMoIFsgXCJteS1maXJzdC1yZXBvXCIsIFwibXktc2Vjb25kLXJlcG9cIiBdICk7XHJcbiAqXHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSggJ2h0dHBzJyApO1xyXG5jb25zdCBidWlsZExvY2FsID0gcmVxdWlyZSggJy4vYnVpbGRMb2NhbCcgKTtcclxuXHJcbi8vIHByb3RlY3RzIG1hc3RlciwgbWFpbiwgYW5kIGFsbCBicmFuY2hlIHVzZWQgaW4gcHJvZHVjdGlvbiBkZXBsb3lzXHJcbmNvbnN0IEJSQU5DSF9OQU1FX1BBVFRFUk5TID0gWyAnbWFzdGVyJywgJ21haW4nLCAnKlswLTldLlswLTldKicgXTtcclxuXHJcbi8vIE9wdGlvbnMgZm9yIHRoZSBodHRwcyByZXF1ZXN0IHRvIHRoZSBnaXRodWIgZ3JhcGhxbCBzZXJ2ZXJcclxuY29uc3Qgb3B0aW9ucyA9IHtcclxuICBob3N0bmFtZTogJ2FwaS5naXRodWIuY29tJyxcclxuICBwYXRoOiAnL2dyYXBocWwnLFxyXG4gIG1ldGhvZDogJ1BPU1QnLFxyXG4gIGhlYWRlcnM6IHtcclxuICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtidWlsZExvY2FsLmRldmVsb3BlckdpdGh1YkFjY2Vzc1Rva2VufWAsXHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgJ3VzZXItYWdlbnQnOiAnbm9kZS5qcydcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyB0aGUgR3JhcGhRTCBxdWVyeSBzdHJpbmcgdG8gZ2V0IHRoZSBleGlzdGluZyBicmFuY2ggcHJvdGVjdGlvbiBydWxlcyBmb3IgdGhlIHByb3ZpZGVkIHJlcG8gbmFtZSB1bmRlclxyXG4gKiB0aGUgcGhldHNpbXMgcHJvamVjdC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnlOYW1lXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5jb25zdCBjcmVhdGVCcmFuY2hQcm90ZWN0aW9uUnVsZVF1ZXJ5RGF0YSA9IHJlcG9zaXRvcnlOYW1lID0+IHtcclxuICByZXR1cm4gY3JlYXRlUXVlcnlEYXRhKCBgcXVlcnkgQnJhbmNoUHJvdGVjdGlvblJ1bGUge1xyXG4gICAgcmVwb3NpdG9yeShvd25lcjogXCJwaGV0c2ltc1wiLCBuYW1lOiBcIiR7cmVwb3NpdG9yeU5hbWV9XCIpIHsgXHJcbiAgICAgIGJyYW5jaFByb3RlY3Rpb25SdWxlcyhmaXJzdDogMTAwKSB7IFxyXG4gICAgICAgIG5vZGVzIHtcclxuICAgICAgICAgICMgcGF0dGVybiBmb3IgdGhlIHJ1bGUgXHJcbiAgICAgICAgICBwYXR0ZXJuLFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAjIHVuaXF1ZUlEIGZvciB0aGUgcnVsZSBhc3NpZ25lZCBieSBnaXRodWIsIHJlcXVpcmVkIHRvIHJlcXVlc3QgZGVsZXRpb25cclxuICAgICAgICAgIGlkXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IH1gXHJcbiAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBHcmFwaFFMIHF1ZXJ5IHN0cmluZyB0aGF0IHdpbGwgZGVsZXRlIGFuIGV4aXN0aW5nIGJyYW5jaCBwcm90ZWN0aW9uIHJ1bGUuIFVzZVxyXG4gKiBjcmVhdGVCcmFuY2hQcm90ZWN0aW9uUnVsZVF1ZXJ5RGF0YSB0byBnZXQgdGhlIHVuaXF1ZSBJRHMgZm9yIGVhY2ggcnVsZS5cclxuICpcclxuICogQHBhcmFtIHJ1bGVJZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuY29uc3QgY3JlYXRlRGVsZXRlQnJhbmNoUHJvdGVjdGlvblJ1bGVNdXRhdGlvbkRhdGEgPSBydWxlSWQgPT4ge1xyXG4gIHJldHVybiBjcmVhdGVRdWVyeURhdGEoIGBtdXRhdGlvbiB7XHJcbiAgICBkZWxldGVCcmFuY2hQcm90ZWN0aW9uUnVsZShpbnB1dDp7YnJhbmNoUHJvdGVjdGlvblJ1bGVJZDogXCIke3J1bGVJZH1cIn0gKSB7XHJcbiAgICAgIGNsaWVudE11dGF0aW9uSWRcclxuICAgIH1cclxuICB9YCApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgdGhlIGRhdGEgc3RyaW5nIHRoYXQgcmVxdWVzdHMgdGhlIGNyZWF0aW9uIG9mIGEgbmV3IGdpdGh1YiBicmFuY2ggcHJvdGVjdGlvbiBydWxlIHVzaW5nIGEgR3JhcGhRTCBxdWVyeSBhbmRcclxuICogc2VudCB3aXRoIGFuIEhUVFBTIHJlcXVlc3QuIFRoZSBkZWZhdWx0IHJ1bGUgcHJldmVudHMgYnJhbmNoIGRlbGV0aW9uLiBUaGVyZSBhcmUgb3RoZXIgdGhpbmdzIHRoYXQgY2FuIGJlXHJcbiAqIGNvbnN0cmFpbmVkIG9yIHByb3RlY3RlZCBmb3IgdGhlIGJyYW5jaCwgYnV0IHdlIGRlY2lkZWQgbm90IHRvIGFwcGx5IGFueXRoaW5nIGVsc2UgYXQgdGhpcyB0aW1lLlxyXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vZ3JhcGhxbC9yZWZlcmVuY2UvaW5wdXQtb2JqZWN0cyNjcmVhdGVicmFuY2hwcm90ZWN0aW9ucnVsZWlucHV0IGZvciBsaXN0XHJcbiAqIG9mIHRoaW5ncyB5b3UgY2FuIGRvIHdpdGggcnVsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvc2l0b3J5SWQgLSBVbmlxdWUgSUQgZm9yIHRoZSByZXBvLCBzZWUgY3JlYXRlUmVwb3NpdG9yeUlkUXVlcnlEYXRhKClcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVQYXR0ZXJuIC0gcGF0dGVybiBmb3IgdGhlIHJ1bGUsIGFsbCBicmFuY2hlcyBtYXRjaGluZyB3aXRoIGZubWF0Y2ggd2lsbCBiZSBwcm90ZWN0ZWRcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmNvbnN0IGNyZWF0ZVJlcG9zaXRvcnlSdWxlTXV0YXRpb25EYXRhID0gKCByZXBvc2l0b3J5SWQsIG5hbWVQYXR0ZXJuICkgPT4ge1xyXG4gIHJldHVybiBjcmVhdGVRdWVyeURhdGEoIGBtdXRhdGlvbiB7XHJcbiAgICBjcmVhdGVCcmFuY2hQcm90ZWN0aW9uUnVsZShpbnB1dDoge1xyXG4gICAgICBwYXR0ZXJuOiBcIiR7bmFtZVBhdHRlcm59XCIsXHJcbiAgICAgIGFsbG93c0RlbGV0aW9uczogZmFsc2UsXHJcbiAgXHJcbiAgICAgIHJlcG9zaXRvcnlJZDogXCIke3JlcG9zaXRvcnlJZH1cIlxyXG4gICAgfSApXHJcbiAgICBcclxuICAgICMgSSB0aGluayB0aGlzIHNwZWNpZmllcyB0aGUgZGF0YSByZXR1cm5lZCBhZnRlciB0aGUgc2VydmVyIHJlY2VpdmVzIHRoZSBtdXRhdGlvbiByZXF1ZXN0LCBub3QgdXNlZCBidXQgcmVxdWlyZWRcclxuICAgICMgdG8gc2VuZCB0aGUgbXV0YXRpb25cclxuICAgIHtcclxuICAgICAgYnJhbmNoUHJvdGVjdGlvblJ1bGUge1xyXG4gICAgICAgIHBhdHRlcm5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgfWAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHRoZSBkYXRhIHN0cmluZyB0aGF0IHJlcXVlc3RzIHRoZSB1bmlxdWUgSUQgb2YgYSBnaXRodWIgcmVwb3NpdG9yeSB1c2luZyBhIEdyYXBoUUwgcXVlcnkgc2VudCB3aXRoIGFuXHJcbiAqIEhUVFBTIHJlcXVlc3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvc2l0b3J5TmFtZSAtIE5hbWUgb2YgdGhlIHBoZXRzaW1zIHJlcG9zaXRvcnlcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmNvbnN0IGNyZWF0ZVJlcG9zaXRvcnlJZFF1ZXJ5RGF0YSA9IHJlcG9zaXRvcnlOYW1lID0+IHtcclxuICByZXR1cm4gY3JlYXRlUXVlcnlEYXRhKCBgcXVlcnkgeyByZXBvc2l0b3J5KG93bmVyOiBcInBoZXRzaW1zXCIsIG5hbWU6IFwiJHtyZXBvc2l0b3J5TmFtZX1cIikgeyBpZCB9IH1gICk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JhcHMgYSBxdWVyeSBzdHJpbmcgd2l0aCBhZGRpdGlvbmFsIGZvcm1hdHRpbmcgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiBhIEdyYXBoUUwgcXVlcnkgc2VudCB3aXRoIGh0dHBzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlTdHJpbmdcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmNvbnN0IGNyZWF0ZVF1ZXJ5RGF0YSA9IHF1ZXJ5U3RyaW5nID0+IHtcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoIHtcclxuICAgIHF1ZXJ5OiBxdWVyeVN0cmluZ1xyXG4gIH0gKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgdGhlIHByb3ZpZGVkIHBoZXRzaW1zIHJlcG9zaXRvcnkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvc2l0b3J5TmFtZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVwb3NpdG9yeUlkKCByZXBvc2l0b3J5TmFtZSApIHtcclxuICBjb25zdCBoYW5kbGVKU09OUmVzcG9uc2UgPSBqc29uUmVzcG9uc2UgPT4ge1xyXG4gICAgaWYgKCAhanNvblJlc3BvbnNlLmRhdGEgfHwganNvblJlc3BvbnNlLmRhdGEucmVwb3NpdG9yeSA9PT0gbnVsbCApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCBgRGlkIG5vdCBmaW5kIHJlcG9zaXRvcnk6ICR7cmVwb3NpdG9yeU5hbWV9YCApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBqc29uUmVzcG9uc2UuZGF0YS5yZXBvc2l0b3J5LmlkO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBzZW5kUHJvbWlzZWRIdHRwc1JlcXVlc3QoIGNyZWF0ZVJlcG9zaXRvcnlJZFF1ZXJ5RGF0YSggcmVwb3NpdG9yeU5hbWUgKSwgaGFuZGxlSlNPTlJlc3BvbnNlICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMsIG9uZSBmb3IgZWFjaCBleGlzdGluZyBicmFuY2ggcHJvdGVjdGlvbiBydWxlIGZvciB0aGUgcmVwb3NpdG9yeSwgdGhhdCBoYXNcclxuICogdGhlIHByb3RlY3Rpb24gcnVsZSBwYXR0ZXJuIGFuZCB0aGUgdW5pcXVlIElEIGZvciB0aGUgcnVsZSBhc3NpZ25lZCBieSBnaXRodWIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvc2l0b3J5TmFtZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqW10+fSAtIGFycmF5IG9mIG5vZGVzIHdpdGgga2V5IHZhbHVlIHBhaXJzIG9mIHsgXCJwYXR0ZXJuXCI6IHN0cmluZywgXCJpZFwiOiBzdHJpbmcgfVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0RXhpc3RpbmdCcmFuY2hQcm90ZWN0aW9uUnVsZXMoIHJlcG9zaXRvcnlOYW1lICkge1xyXG4gIGNvbnN0IGhhbmRsZUpTT05SZXNwb25zZSA9IGpzb25SZXNwb25zZSA9PiB7XHJcbiAgICBpZiAoIGpzb25SZXNwb25zZS5lcnJvcnMgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigganNvblJlc3BvbnNlLmVycm9ycyApO1xyXG4gICAgfVxyXG4gICAgaWYgKCAhanNvblJlc3BvbnNlLmRhdGEgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvciggYE5vIGRhdGEgcmV0dXJuZWQgYnkgZ2V0RXhpc3RpbmdCcmFuY2hQcm90ZWN0aW9uUnVsZXMgZm9yIHJlcG8gJHtyZXBvc2l0b3J5TmFtZX1gICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ganNvblJlc3BvbnNlLmRhdGEucmVwb3NpdG9yeS5icmFuY2hQcm90ZWN0aW9uUnVsZXMubm9kZXM7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHNlbmRQcm9taXNlZEh0dHBzUmVxdWVzdCggY3JlYXRlQnJhbmNoUHJvdGVjdGlvblJ1bGVRdWVyeURhdGEoIHJlcG9zaXRvcnlOYW1lICksIGhhbmRsZUpTT05SZXNwb25zZSApO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyB0aGUgcHJvdGVjdGlvbiBydWxlIGZvciBhbGwgYnJhbmNoZXMgbWF0Y2hpbmcgdGhlIG5hbWVQYXR0ZXJuIGZvciB0aGUgcGhldHNpbXMgcmVwb3NpdG9yeSB3aXRoIHRoZSBwcm92aWRlZFxyXG4gKiB1bmlxdWUgSUQgYXNzaWduZWQgYnkgZ2l0aHViLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb3NpdG9yeUlkIC0gdW5pcXVlIElEIGZvciB0aGUgcmVwb3NpdG9yeSwgdXNlIGdldFJlcG9zaXRvcnlJZCB0byBnZXQgdGhpc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVBhdHRlcm4gLSBUaGUgcGF0dGVybiBmb3IgdGhlIHJ1bGUgdXNpbmcgZm5tYXRjaFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gd3JpdGVQcm90ZWN0aW9uUnVsZSggcmVwb3NpdG9yeUlkLCBuYW1lUGF0dGVybiApIHtcclxuICBjb25zdCBoYW5kbGVKU09OUmVzcG9uc2UgPSBqc29uUmVzcG9uc2UgPT4ge1xyXG4gICAgaWYgKCBqc29uUmVzcG9uc2UuZXJyb3JzICkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoIGpzb25SZXNwb25zZS5lcnJvcnMgKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiBzZW5kUHJvbWlzZWRIdHRwc1JlcXVlc3QoIGNyZWF0ZVJlcG9zaXRvcnlSdWxlTXV0YXRpb25EYXRhKCByZXBvc2l0b3J5SWQsIG5hbWVQYXR0ZXJuICksIGhhbmRsZUpTT05SZXNwb25zZSApO1xyXG59XHJcblxyXG4vKipcclxuICogRGVsZXRlcyBhbiBleGlzdGluZyBydWxlLiBXZSBhc3N1bWUgdGhhdCB0aGF0IGJ5IHJ1bm5pbmcgdGhpcyB3ZSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgcnVsZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVJZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVBhdHRlcm5cclxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9zaXRvcnlOYW1lXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVFeGlzdGluZ1Byb3RlY3Rpb25SdWxlKCBydWxlSWQsIG5hbWVQYXR0ZXJuLCByZXBvc2l0b3J5TmFtZSApIHtcclxuICBjb25zdCBoYW5kbGVKU09OUmVzcG9uc2UgPSBqc29uUmVzcG9uc2UgPT4ge1xyXG4gICAgaWYgKCBqc29uUmVzcG9uc2UuZXJyb3JzICkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoIGpzb25SZXNwb25zZS5lcnJvcnMgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyggYERlbGV0ZWQgZXhpc3RpbmcgYnJhbmNoIHByb3RlY3Rpb24gcnVsZSAke25hbWVQYXR0ZXJufSBmb3IgcmVwbyAke3JlcG9zaXRvcnlOYW1lfWAgKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiBzZW5kUHJvbWlzZWRIdHRwc1JlcXVlc3QoIGNyZWF0ZURlbGV0ZUJyYW5jaFByb3RlY3Rpb25SdWxlTXV0YXRpb25EYXRhKCBydWxlSWQgKSwgaGFuZGxlSlNPTlJlc3BvbnNlICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBhc3luYyBmdW5jdGlvbiB0aGF0IHdpbGwgZGVsZXRlIGFsbCBleGlzdGluZyBydWxlcyB0aGF0IG1hdGNoIHRoZSBwcm92aWRlZCBuYW1lUGF0dGVybiBmb3IgdGhlIHJlcG9zaXRvcnkuXHJcbiAqIFdyYXBwZWQgaW4gYSBQcm9taXNlIHNvIHdlIGNhbiB3YWl0IHRvIHdyaXRlIG5ldyBydWxlcyB1bnRpbCB0aGUgZXhpc3RpbmcgcnVsZXMgYXJlIHJlbW92ZWQuIElmIHlvdSB0cnkgdG9cclxuICogd3JpdGUgb3ZlciBhbiBleGlzdGluZyBydWxlIHdpdGhvdXQgcmVtb3ZpbmcgaXQgZ2l0aHViIHdpbGwgcmVzcG9uZCB3aXRoIGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAcGFyYW0geypbXX0gcnVsZXNcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVQYXR0ZXJuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBvc2l0b3J5TmFtZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duW10+fVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlTWF0Y2hpbmdQcm90ZWN0aW9uUnVsZXMoIHJ1bGVzLCBuYW1lUGF0dGVybiwgcmVwb3NpdG9yeU5hbWUgKSB7XHJcblxyXG4gIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgcnVsZXMuZm9yRWFjaCggcnVsZSA9PiB7XHJcblxyXG4gICAgLy8gb25seSBkZWxldGUgcnVsZXMgdGhhdCBtYXRjaCB0aGUgbmV3IHBhdHRlcm4gd2Ugd2FudCB0byBwcm90ZWN0XHJcbiAgICBpZiAoIHJ1bGUucGF0dGVybiA9PT0gbmFtZVBhdHRlcm4gKSB7XHJcbiAgICAgIHByb21pc2VzLnB1c2goIGRlbGV0ZUV4aXN0aW5nUHJvdGVjdGlvblJ1bGUoIHJ1bGUuaWQsIG5hbWVQYXR0ZXJuLCByZXBvc2l0b3J5TmFtZSApICk7XHJcbiAgICB9XHJcbiAgfSApO1xyXG5cclxuICByZXR1cm4gUHJvbWlzZS5hbGwoIHByb21pc2VzICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZW5kcyBhIHJlcXVlc3QgdG8gZ2l0aHViJ3MgR3JhcGhRTCBzZXJ2ZXIgdG8gcXVlcnkgb3IgbXV0YXRlIHJlcG9zaXRvcnkgZGF0YS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5RGF0YSAtIHRoZSBzdHJpbmcgc2VudCB3aXRoIGh0dHBzXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KX0gaGFuZGxlIC0gaGFuZGxlcyB0aGUgSlNPTiByZXNwb25zZSBmcm9tIGdpdGh1YlxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRQcm9taXNlZEh0dHBzUmVxdWVzdCggcXVlcnlEYXRhLCBoYW5kbGUgKSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+IHtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KCBvcHRpb25zLCByZXNwb25zZSA9PiB7XHJcbiAgICAgIGxldCByZXNwb25zZUJvZHkgPSAnJztcclxuXHJcbiAgICAgIHJlc3BvbnNlLm9uKCAnZGF0YScsIGQgPT4ge1xyXG4gICAgICAgIHJlc3BvbnNlQm9keSArPSBkO1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICByZXNwb25zZS5vbiggJ2VuZCcsICgpID0+IHtcclxuICAgICAgICBjb25zdCBqc29uUmVzcG9uc2UgPSBKU09OLnBhcnNlKCByZXNwb25zZUJvZHkgKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZSA9IGhhbmRsZSgganNvblJlc3BvbnNlICk7XHJcbiAgICAgICAgICByZXNvbHZlKCByZXNvbHZlVmFsdWUgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2goIGVycm9yICkge1xyXG4gICAgICAgICAgcmVqZWN0KCBlcnJvciApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIHJlcXVlc3Qub24oICdlcnJvcicsIGVycm9yID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvciggZXJyb3IgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICByZXF1ZXN0LndyaXRlKCBxdWVyeURhdGEgKTtcclxuICAgIHJlcXVlc3QuZW5kKCk7XHJcbiAgfSApO1xyXG59XHJcblxyXG4vKipcclxuICogQ2xlYXIgcHJvdGVjdGlvbnMgZm9yIHRoZSBicmFuY2hlcyB0aGF0IFBoRVQgd2FudHMgdG8gcHJvdGVjdC5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNsZWFyQnJhbmNoUHJvdGVjdGlvbnMoIHJlcG9zaXRvcmllcyApIHtcclxuICBmb3IgKCBjb25zdCByZXBvc2l0b3J5TmFtZSBvZiByZXBvc2l0b3JpZXMgKSB7XHJcbiAgICBmb3IgKCBjb25zdCBuYW1lUGF0dGVybiBvZiBCUkFOQ0hfTkFNRV9QQVRURVJOUyApIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBicmFuY2hQcm90ZWN0aW9uUnVsZXMgPSBhd2FpdCBnZXRFeGlzdGluZ0JyYW5jaFByb3RlY3Rpb25SdWxlcyggcmVwb3NpdG9yeU5hbWUgKTtcclxuICAgICAgICBhd2FpdCBkZWxldGVNYXRjaGluZ1Byb3RlY3Rpb25SdWxlcyggYnJhbmNoUHJvdGVjdGlvblJ1bGVzLCBuYW1lUGF0dGVybiwgcmVwb3NpdG9yeU5hbWUgKTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaCggZXJyb3IgKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coIGBFcnJvciBjbGVhcmluZyBnaXRodWIgcHJvdGVjdGlvbiBydWxlICR7bmFtZVBhdHRlcm59IGZvciAke3JlcG9zaXRvcnlOYW1lfWAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGx5IGJyYW5jaCBwcm90ZWN0aW9uIHJ1bGVzIHRvIHByb2RjdXRpb24gYnJhbmNoZXMgKG1hc3RlciwgbWFpbiwgcmVsZWFzZSBicmFuY2hlcykuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBwcm90ZWN0QnJhbmNoZXMoIHJlcG9zaXRvcmllcyApIHtcclxuXHJcbiAgLy8gaWYgdGhlIHJ1bGUgZm9yIHRoZSBwcm90ZWN0ZWQgYnJhbmNoIGFscmVhZHkgZXhpc3RzLCBkZWxldGUgaXQgLSB3ZSBhc3N1bWUgdGhhdCBydW5uaW5nIHRoaXMgYWdhaW4gbWVhbnMgd2VcclxuICAvLyB3YW50IHRvIHVwZGF0ZSBydWxlcyBmb3IgZWFjaCBuYW1lUGF0dGVyblxyXG4gIGF3YWl0IGNsZWFyQnJhbmNoUHJvdGVjdGlvbnMoIHJlcG9zaXRvcmllcyApO1xyXG5cclxuICBmb3IgKCBjb25zdCByZXBvc2l0b3J5TmFtZSBvZiByZXBvc2l0b3JpZXMgKSB7XHJcblxyXG4gICAgLy8gZ2V0IHRoZSB1bmlxdWUgSUQgZm9yIGVhY2ggcmVwb3NpdG9yeVxyXG4gICAgY29uc3QgcmVwb3NpdG9yeUlkID0gYXdhaXQgZ2V0UmVwb3NpdG9yeUlkKCByZXBvc2l0b3J5TmFtZSApO1xyXG5cclxuICAgIGZvciAoIGNvbnN0IG5hbWVQYXR0ZXJuIG9mIEJSQU5DSF9OQU1FX1BBVFRFUk5TICkge1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCB3cml0ZVByb3RlY3Rpb25SdWxlKCByZXBvc2l0b3J5SWQsIG5hbWVQYXR0ZXJuICk7XHJcbiAgICAgICAgY29uc29sZS5sb2coIGAke25hbWVQYXR0ZXJufSBwcm90ZWN0aW9uIHJ1bGUgc2V0IGZvciAke3JlcG9zaXRvcnlOYW1lfWAgKTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaCggZXJyb3IgKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coIGBFcnJvciB3cml0aW5nICR7bmFtZVBhdHRlcm59IHJ1bGUgZm9yIHJlcG8gJHtyZXBvc2l0b3J5TmFtZX06YCApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCBlcnJvciApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCAnXFxuJyApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBwcm90ZWN0QnJhbmNoZXM6IHByb3RlY3RCcmFuY2hlcyxcclxuICBjbGVhckJyYW5jaFByb3RlY3Rpb25zOiBjbGVhckJyYW5jaFByb3RlY3Rpb25zXHJcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNQSxLQUFLLEdBQUdDLE9BQU8sQ0FBRSxPQUFRLENBQUM7QUFDaEMsTUFBTUMsVUFBVSxHQUFHRCxPQUFPLENBQUUsY0FBZSxDQUFDOztBQUU1QztBQUNBLE1BQU1FLG9CQUFvQixHQUFHLENBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxlQUFlLENBQUU7O0FBRWxFO0FBQ0EsTUFBTUMsT0FBTyxHQUFHO0VBQ2RDLFFBQVEsRUFBRSxnQkFBZ0I7RUFDMUJDLElBQUksRUFBRSxVQUFVO0VBQ2hCQyxNQUFNLEVBQUUsTUFBTTtFQUNkQyxPQUFPLEVBQUU7SUFDUEMsYUFBYSxFQUFHLFVBQVNQLFVBQVUsQ0FBQ1EsMEJBQTJCLEVBQUM7SUFDaEUsY0FBYyxFQUFFLGtCQUFrQjtJQUNsQyxZQUFZLEVBQUU7RUFDaEI7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsbUNBQW1DLEdBQUdDLGNBQWMsSUFBSTtFQUM1RCxPQUFPQyxlQUFlLENBQUc7QUFDM0IsMkNBQTJDRCxjQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQ0UsQ0FBQztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNRSw0Q0FBNEMsR0FBR0MsTUFBTSxJQUFJO0VBQzdELE9BQU9GLGVBQWUsQ0FBRztBQUMzQixpRUFBaUVFLE1BQU87QUFDeEU7QUFDQTtBQUNBLElBQUssQ0FBQztBQUNOLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFD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