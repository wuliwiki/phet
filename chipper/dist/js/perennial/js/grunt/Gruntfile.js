// Copyright 2002-2015, University of Colorado Boulder

/**
 * Grunt configuration file for tasks that have no dependencies on other repos.
 * In particular, grunt checkout-shas and grunt checkout-master can be run from here
 * without worrying about an older version of chipper being checked out.
 *
 * In general when possible, modules are imported lazily in their task
 * declaration to save on overall load time of this file. The pattern is to require all modules needed at the top of the
 * grunt task registration. If a module is used in multiple tasks, it is best to lazily require in each
 * task.
 */

///////////////////////////
// NOTE: to improve performance, the vast majority of modules are lazily imported in task registrations. Even duplicating
// require statements improves the load time of this file noticeably. For details, see https://github.com/phetsims/chipper/issues/1107
const assertIsValidRepoName = require('../common/assertIsValidRepoName');
const assert = require('assert');
const _ = require('lodash');
require('./checkNodeVersion');
///////////////////////////

module.exports = function (grunt) {
  if (grunt.option('debug')) {
    const winston = require('winston');
    winston.default.transports.console.level = 'debug';
  }

  // If true, will skip most prompts, but will fail out on things that should not be done in an automated manner.
  const noninteractive = !!grunt.option('noninteractive');

  /**
   * Wraps a promise's completion with grunt's asynchronous handling, with added helpful failure messages (including stack traces, regardless of whether --stack was provided).
   * @public
   *
   * @param {Promise} promise
   */
  async function wrap(promise) {
    const done = grunt.task.current.async();
    try {
      await promise;
    } catch (e) {
      if (e.stack) {
        grunt.fail.fatal(`Perennial task failed:\n${e.stack}\nFull Error details:\n${e}`);
      } else if (typeof e === 'string') {
        grunt.fail.fatal(`Perennial task failed: ${e}`);
      } else {
        grunt.fail.fatal(`Perennial task failed with unknown error: ${e}`);
      }
    }
    done();
  }

  /**
   * Wraps an async function for a grunt task. Will run the async function when the task should be executed. Will properly handle grunt's async handling, and provides improved
   * error reporting.
   * @public
   *
   * @param {async function} asyncTaskFunction
   */
  function wrapTask(asyncTaskFunction) {
    return () => {
      wrap(asyncTaskFunction());
    };
  }
  grunt.registerTask('checkout-shas', 'Check out shas for a project, as specified in dependencies.json\n' + '--repo : repository name where package.json should be read from\n' + '--skipNpmUpdate : If provided, will prevent the usual npm update\n' + '--buildServer : If provided, it will read dependencies from the build-server temporary location (and will skip npm update)', wrapTask(async () => {
    assert(grunt.option('repo'), 'Requires specifying a repository with --repo={{REPOSITORY}}');
    const checkoutDependencies = require('../common/checkoutDependencies');
    const buildServer = !!grunt.option('buildServer');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const dependencies = grunt.file.readJSON(buildServer ? '../perennial/js/build-server/tmp/dependencies.json' : `../${repo}/dependencies.json`);
    const includeNpmUpdate = !grunt.option('skipNpmUpdate') && !buildServer;
    await checkoutDependencies(repo, dependencies, includeNpmUpdate);
  }));
  grunt.registerTask('checkout-target', 'Check out a specific branch/SHA for a simulation and all of its declared dependencies\n' + '--repo : repository name where package.json should be read from\n' + '--target : the branch/SHA to check out\n' + '--skipNpmUpdate : If provided, will prevent the usual npm update', wrapTask(async () => {
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('target'), 'Requires specifying a branch/SHA with --target={{BRANCH}}');
    assertIsValidRepoName(repo);
    const checkoutTarget = require('../common/checkoutTarget');
    await checkoutTarget(repo, grunt.option('target'), !grunt.option('skipNpmUpdate'));
  }));
  grunt.registerTask('checkout-release', 'Check out the latest deployed production release branch for a simulation and all of its declared dependencies\n' + '--repo : repository name where package.json should be read from\n' + '--skipNpmUpdate : If provided, will prevent the usual npm update', wrapTask(async () => {
    const checkoutRelease = require('../common/checkoutRelease');
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assertIsValidRepoName(repo);
    await checkoutRelease(repo, !grunt.option('skipNpmUpdate'));
  }));
  grunt.registerTask('checkout-timestamp', 'Check out a specific timestamp for a simulation and all of its declared dependencies\n' + '--repo : repository name where package.json should be read from\n' + '--timestamp : the timestamp to check things out for, e.g. --timestamp="Jan 08 2018"\n' + '--skipNpmUpdate : If provided, will prevent the usual npm update', wrapTask(async () => {
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('timestamp'), 'Requires specifying a timestamp with --timestamp={{BRANCH}}');
    assertIsValidRepoName(repo);
    const checkoutTimestamp = require('../common/checkoutTimestamp');
    await checkoutTimestamp(repo, grunt.option('timestamp'), !grunt.option('skipNpmUpdate'));
  }));
  grunt.registerTask('checkout-master', 'Check out master branch for all dependencies, as specified in dependencies.json\n' + '--repo : repository name where package.json should be read from\n' + '--skipNpmUpdate : If provided, will prevent the usual npm update', wrapTask(async () => {
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    const checkoutMaster = require('../common/checkoutMaster');
    assertIsValidRepoName(repo);
    await checkoutMaster(repo, !grunt.option('skipNpmUpdate'));
  }));
  grunt.registerTask('checkout-master-all', 'Check out master branch for all repos in git root', wrapTask(async () => {
    const checkoutMasterAll = require('./checkoutMasterAll');
    checkoutMasterAll();
  }));
  grunt.registerTask('sha-check', 'Checks which simulations\' latest release version includes the given common-code SHA in its git tree.\n' + '--repo : repository to check for the SHA\n' + '--sha : git SHA', wrapTask(async () => {
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const shaCheck = require('./shaCheck');
    await shaCheck(repo, grunt.option('sha'));
  }));
  grunt.registerTask('print-phet-io-links', 'Print the current list of all phet-io sims\' links', wrapTask(async () => {
    const getPhetioLinks = require('../common/getPhetioLinks');
    const phetioLinks = await getPhetioLinks();
    console.log('Latest Links:');
    console.log(`\n${phetioLinks.join('\n')}`);
  }));
  grunt.registerTask('update-gh-pages', 'Updates the gh-pages branches for various repos, including building of dot/kite/scenery', wrapTask(async () => {
    const updateGithubPages = require('../common/updateGithubPages');
    await updateGithubPages();
  }));
  grunt.registerTask('sim-list', 'Prints out a list of live production HTML sims to stderr (can be filtered from other stdout output)\n' + '--versions : Outputs the sim version after its name.', wrapTask(async () => {
    const simMetadata = require('../common/simMetadata');
    const winston = require('winston');
    winston.default.transports.console.level = 'error';
    const data = await simMetadata({
      type: 'html'
    });
    console.error(data.projects.map(project => {
      const name = project.name.slice(project.name.indexOf('/') + 1);
      let result = name;
      if (grunt.option('versions')) {
        result += ` ${project.version.major}.${project.version.minor}.${project.version.dev}`;
      }
      return result;
    }).join('\n'));
  }));
  grunt.registerTask('release-branch-list', 'Prints out a list of all release branches that would need maintenance patches\n' + '--repo : Only show branches for a specific repository\n' + '--order=<ORDER> : alphabetical|date', wrapTask(async () => {
    const Maintenance = require('../common/Maintenance');
    const winston = require('winston');
    winston.default.transports.console.level = 'error';
    const repo = grunt.option('repo');
    const order = grunt.option('order') || 'alphabetical';
    if (repo) {
      assertIsValidRepoName(repo);
    }
    assert(order === 'alphabetical' || order === 'date');
    const branches = await Maintenance.getMaintenanceBranches(filterRepo => !repo || filterRepo === repo, true, true);
    let structures = [];
    for (const branch of branches) {
      structures.push({
        branch: branch,
        timestamp: await branch.getDivergingTimestamp()
      });
    }
    if (order === 'date') {
      structures = _.sortBy(structures, struct => struct.timestamp);
    }
    console.log('\nRelease branches:\n{repo} {branch} {brand[,brand]+} {date}\n');
    for (const struct of structures) {
      console.log(`${struct.branch.toString()} ${new Date(struct.timestamp).toISOString().split('T')[0]}`);
    }
  }));
  grunt.registerTask('npm-update', 'Runs npm update/prune for chipper, perennial-alias and the given repository\n' + '--repo : The repository to update', wrapTask(async () => {
    const npmUpdate = require('../common/npmUpdate');
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assertIsValidRepoName(repo);
    await npmUpdate(repo).then(() => npmUpdate('chipper')).then(() => npmUpdate('perennial-alias'));
  }));
  grunt.registerTask('create-release', 'Creates a new release branch for a given simulation\n' + '--repo : The repository to add the release branch to\n' + '--branch : The branch name, which should be {{MAJOR}}.{{MINOR}}, e.g. 1.0\n' + '--brands : The supported brands for the release, comma separated.\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const createRelease = require('./createRelease');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const branch = grunt.option('branch');
    const message = grunt.option('message');
    const brands = grunt.option('brands');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(brands, 'Requires specifying brands with --brands={{BRANDS}} (comma separated)');
    assert(branch, 'Requires specifying a branch with --branch={{BRANCH}}');
    assert(branch.split('.').length === 2, 'Branch should be {{MAJOR}}.{{MINOR}}');
    await createRelease(repo, branch, brands.split(','), message);
  }));
  grunt.registerTask('create-one-off', 'Creates a new release branch for a given simulation\n' + '--repo : The repository to add the release branch to\n' + '--branch : The branch/one-off name, which should be anything without dashes or periods\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const createOneOff = require('./createOneOff');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const branch = grunt.option('branch');
    const message = grunt.option('message');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(branch, 'Requires specifying a branch with --branch={{BRANCH}}');
    assert(!branch.includes('-') && !branch.includes('.'), 'Branch should not contain dashes or periods');
    await createOneOff(repo, branch, message);
  }));
  grunt.registerTask('cherry-pick', 'Runs cherry-pick on a list of SHAs until one works. Reports success or failure\n' + '--repo : The repository to cherry-pick on\n' + '--shas : Comma-separated list of SHAs to try', wrapTask(async () => {
    const cherryPick = require('./cherryPick');
    const repo = grunt.option('repo');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('shas'), 'Requires specifying a comma-separated list of SHAs with --shas={{SHAS}}');
    assertIsValidRepoName(repo);
    const shas = grunt.option('shas').split(',');
    await cherryPick(repo, shas);
  }));
  grunt.registerTask('lint', 'Lints this repository only', wrapTask(async () => {
    const execute = require('../common/execute');
    const gruntCommand = require('../common/gruntCommand');
    const index = process.argv.indexOf('lint');
    assert && assert(index >= 0, 'lint command does not appear');
    const tail = process.argv.slice(index + 1);
    if (!grunt.option('repos')) {
      tail.push('--repos=perennial');
    }

    // Forward to chipper, supporting all of the options
    grunt.log.writeln((await execute(gruntCommand, ['lint', ...tail], '../chipper', {
      errors: 'resolve'
    })).stdout);
  }));
  grunt.registerTask('dev', 'Deploys a dev version of the simulation\n' + '--repo : The name of the repository to deploy\n' + '--brands : A comma-separated list of brand names to deploy\n' + '--noninteractive : If specified, prompts will be skipped. Some prompts that should not be automated will fail out\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const dev = require('./dev');
    assert(grunt.option('repo'), 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('brands'), 'Requires specifying brands (comma-separated) with --brands={{BRANDS}}');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    await dev(repo, grunt.option('brands').split(','), noninteractive, 'master', grunt.option('message'));
  }));
  grunt.registerTask('deploy-images', 'Rebuilds all images\n' + '--simulation : Optional. If present, only the given simulation will receive images from master. If absent, all sims' + 'will receive images from master.', wrapTask(async () => {
    console.log(grunt.option('simulation'));
    const simulation = grunt.option('simulation') || null;
    const deployImages = require('./deployImages');
    await deployImages({
      simulation: simulation
    });
  }));
  grunt.registerTask('one-off', 'Deploys a one-off version of the simulation (using the current or specified branch)\n' + '--repo : The name of the repository to deploy\n' + '--branch : The name of the one-off branch (the name of the one-off)\n' + '--brands : A comma-separated list of brand names to deploy\n' + '--noninteractive : If specified, prompts will be skipped. Some prompts that should not be automated will fail out\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const getBranch = require('../common/getBranch');
    const dev = require('./dev');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const brands = grunt.option('brands');
    assert(repo, 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(brands, 'Requires specifying brands (comma-separated) with --brands={{BRANDS}}');
    let branch = grunt.option('branch');
    if (!branch) {
      branch = await getBranch(repo);
      console.log(`--branch not provided, using ${branch} detected from ${repo}`);
    }
    assert(branch !== 'master', 'One-off deploys for master are unsupported.');
    await dev(repo, brands.split(','), noninteractive, branch, grunt.option('message'));
  }));
  grunt.registerTask('rc', 'Deploys an rc version of the simulation\n' + '--repo : The name of the repository to deploy\n' + '--branch : The release branch name (e.g. "1.7") that should be used for deployment\n' + '--brands : A comma-separated list of brand names to deploy\n' + '--noninteractive : If specified, prompts will be skipped. Some prompts that should not be automated will fail out\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    assert(grunt.option('repo'), 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('branch'), 'Requires specifying a branch with --branch={{BRANCH}}');
    assert(grunt.option('brands'), 'Requires specifying brands (comma-separated) with --brands={{BRANDS}}');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const rc = require('./rc');
    await rc(repo, grunt.option('branch'), grunt.option('brands').split(','), noninteractive, grunt.option('message'));
  }));
  grunt.registerTask('production', 'Marks a simulation as published, and deploys a production version of the simulation\n' + '--repo : The name of the repository to deploy\n' + '--branch : The release branch name (e.g. "1.7") that should be used for deployment\n' + '--brands : A comma-separated list of brand names to deploy\n' + '--noninteractive : If specified, prompts will be skipped. Some prompts that should not be automated will fail out\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const production = require('./production');
    const markSimAsPublished = require('../common/markSimAsPublished');
    assert(grunt.option('repo'), 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('branch'), 'Requires specifying a branch with --branch={{BRANCH}}');
    assert(grunt.option('brands'), 'Requires specifying brands (comma-separated) with --brands={{BRANDS}}');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    await markSimAsPublished(repo);
    await production(repo, grunt.option('branch'), grunt.option('brands').split(','), noninteractive, grunt.option('message'));
  }));
  grunt.registerTask('prototype', 'Deploys a production (prototype) version of the simulation\n' + '--repo : The name of the repository to deploy\n' + '--branch : The release branch name (e.g. "1.7") that should be used for deployment\n' + '--brands : A comma-separated list of brand names to deploy\n' + '--noninteractive : If specified, prompts will be skipped. Some prompts that should not be automated will fail out\n' + '--message : An optional message that will be appended on version-change commits.', wrapTask(async () => {
    const production = require('./production');
    assert(grunt.option('repo'), 'Requires specifying a repository with --repo={{REPOSITORY}}');
    assert(grunt.option('branch'), 'Requires specifying a branch with --branch={{BRANCH}}');
    assert(grunt.option('brands'), 'Requires specifying brands (comma-separated) with --brands={{BRANDS}}');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    await production(repo, grunt.option('branch'), grunt.option('brands').split(','), noninteractive, grunt.option('message'));
  }));
  grunt.registerTask('deploy-decaf', 'Deploys a decaf version of the simulation\n' + '--project : The name of the project to deploy', wrapTask(async () => {
    const deployDecaf = require('./decaf/deployDecaf');
    assert(grunt.option('project'), 'Requires specifying a repository with --project={{PROJECT}}');
    assert(grunt.option('dev') || grunt.option('production'), 'Requires at least one of --dev or --production');
    await deployDecaf(grunt.option('project'), !!grunt.option('dev'), !!grunt.option('production'));
  }));
  grunt.registerTask('build-decaf', 'Builds a decaf version of the simulation\n' + '--project : The name of the project to deploy', wrapTask(async () => {
    const buildDecaf = require('./decaf/buildDecaf');
    assert(grunt.option('project'), 'Requires specifying a repository with --project={{PROJECT}}');
    await buildDecaf(grunt.option('project'), grunt.option('preloadResources'));
  }));
  grunt.registerTask('create-sim', 'Creates a sim based on the simula-rasa template.\n' + '--repo="string" : the repository name\n' + '--author="string" : the author name\n' + '--title="string" : (optional) the simulation title\n' + '--clean=true : (optional) deletes the repository directory if it exists', wrapTask(async () => {
    const createSim = require('./createSim');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const author = grunt.option('author');
    const title = grunt.option('title');
    const clean = grunt.option('clean');
    assert(repo, 'Requires specifying a repository name with --repo={{REPO}}');
    assert(grunt.option('author'), 'Requires specifying a author with --author={{AUTHOR}}');
    await createSim(repo, author, {
      title: title,
      clean: clean
    });
  }));
  grunt.registerTask('lint-everything', 'lint all js files for all repos', wrapTask(async () => {
    const getDataFile = require('../common/getDataFile');

    // --disable-eslint-cache disables the cache, useful for developing rules
    const cache = !grunt.option('disable-eslint-cache');
    const activeRepos = getDataFile('active-repos');
    const fix = grunt.option('fix');
    const format = grunt.option('format');
    const chipAway = grunt.option('chip-away');
    const disableWithComment = grunt.option('disable-with-comment');
    const showProgressBar = !grunt.option('hide-progress-bar');

    // Don't always require this, as we may have an older chipper checked out.  Also make sure it is the promise-based lint.
    const lint = require('../../../chipper/js/grunt/lint');
    if (lint.chipperAPIVersion === 'promisesPerRepo1') {
      const lintReturnValue = await lint(activeRepos, {
        cache: cache,
        fix: fix,
        format: format,
        chipAway: chipAway,
        disableWithComment: disableWithComment,
        showProgressBar: showProgressBar
      });

      // Output results on errors.
      if (!lintReturnValue.ok) {
        grunt.fail.fatal('Lint failed');
      }
    }
  }));
  grunt.registerTask('generate-data', 'Generates the lists under perennial/data/, and if there were changes, will commit and push.', wrapTask(async () => {
    const generateData = require('./generateData');
    await generateData(grunt);
  }));
  grunt.registerTask('clone-missing-repos', 'Clones missing repos', wrapTask(async () => {
    const cloneMissingRepos = require('../common/cloneMissingRepos');
    await cloneMissingRepos();
  }));
  grunt.registerTask('maintenance', 'Starts a maintenance REPL', wrapTask(async () => {
    const Maintenance = require('../common/Maintenance');
    await Maintenance.startREPL();
  }));
  grunt.registerTask('maintenance-check-branch-status', 'Reports out on release branch statuses', wrapTask(async () => {
    const Maintenance = require('../common/Maintenance');
    const winston = require('winston');
    winston.default.transports.console.level = 'error';
    await Maintenance.checkBranchStatus();
  }));
  grunt.registerTask('maintenance-list', 'Lists out the current maintenance process state', wrapTask(async () => {
    const Maintenance = require('../common/Maintenance');
    await Maintenance.list();
  }));
  grunt.registerTask('maintenance-create-patch', 'Adds a patch to the maintenance process', wrapTask(async () => {
    const Maintenance = require('../common/Maintenance');
    const repo = grunt.option('repo');
    assertIsValidRepoName(repo);
    const message = grunt.option('message');
    assert(repo, 'Requires specifying a repo that will need to be patched with --repo={{REPO}}');
    assert(grunt.option('message'), 'Requires specifying a message (included with commits) with --message={{MESSAGE}}');
    await Maintenance.createPatch(repo, message);
  }));
  grunt.registerTask('reopen-issues-from-todos', 'If there is a TODO in the project pointing to a closed issue, reopen it.', wrapTask(async () => {
    const reopenIssuesFromTODOs = require('./reopenIssuesFromTODOs');
    await reopenIssuesFromTODOs();
  }));
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhc3NlcnRJc1ZhbGlkUmVwb05hbWUiLCJyZXF1aXJlIiwiYXNzZXJ0IiwiXyIsIm1vZHVsZSIsImV4cG9ydHMiLCJncnVudCIsIm9wdGlvbiIsIndpbnN0b24iLCJkZWZhdWx0IiwidHJhbnNwb3J0cyIsImNvbnNvbGUiLCJsZXZlbCIsIm5vbmludGVyYWN0aXZlIiwid3JhcCIsInByb21pc2UiLCJkb25lIiwidGFzayIsImN1cnJlbnQiLCJhc3luYyIsImUiLCJzdGFjayIsImZhaWwiLCJmYXRhbCIsIndyYXBUYXNrIiwiYXN5bmNUYXNrRnVuY3Rpb24iLCJyZWdpc3RlclRhc2siLCJjaGVja291dERlcGVuZGVuY2llcyIsImJ1aWxkU2VydmVyIiwicmVwbyIsImRlcGVuZGVuY2llcyIsImZpbGUiLCJyZWFkSlNPTiIsImluY2x1ZGVOcG1VcGRhdGUiLCJjaGVja291dFRhcmdldCIsImNoZWNrb3V0UmVsZWFzZSIsImNoZWNrb3V0VGltZXN0YW1wIiwiY2hlY2tvdXRNYXN0ZXIiLCJjaGVja291dE1hc3RlckFsbCIsInNoYUNoZWNrIiwiZ2V0UGhldGlvTGlua3MiLCJwaGV0aW9MaW5rcyIsImxvZyIsImpvaW4iLCJ1cGRhdGVHaXRodWJQYWdlcyIsInNpbU1ldGFkYXRhIiwiZGF0YSIsInR5cGUiLCJlcnJvciIsInByb2plY3RzIiwibWFwIiwicHJvamVjdCIsIm5hbWUiLCJzbGljZSIsImluZGV4T2YiLCJyZXN1bHQiLCJ2ZXJzaW9uIiwibWFqb3IiLCJtaW5vciIsImRldiIsIk1haW50ZW5hbmNlIiwib3JkZXIiLCJicmFuY2hlcyIsImdldE1haW50ZW5hbmNlQnJhbmNoZXMiLCJmaWx0ZXJSZXBvIiwic3RydWN0dXJlcyIsImJyYW5jaCIsInB1c2giLCJ0aW1lc3RhbXAiLCJnZXREaXZlcmdpbmdUaW1lc3RhbXAiLCJzb3J0QnkiLCJzdHJ1Y3QiLCJ0b1N0cmluZyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwibnBtVXBkYXRlIiwidGhlbiIsImNyZWF0ZVJlbGVhc2UiLCJtZXNzYWdlIiwiYnJhbmRzIiwibGVuZ3RoIiwiY3JlYXRlT25lT2ZmIiwiaW5jbHVkZXMiLCJjaGVycnlQaWNrIiwic2hhcyIsImV4ZWN1dGUiLCJncnVudENvbW1hbmQiLCJpbmRleCIsInByb2Nlc3MiLCJhcmd2IiwidGFpbCIsIndyaXRlbG4iLCJlcnJvcnMiLCJzdGRvdXQiLCJzaW11bGF0aW9uIiwiZGVwbG95SW1hZ2VzIiwiZ2V0QnJhbmNoIiwicmMiLCJwcm9kdWN0aW9uIiwibWFya1NpbUFzUHVibGlzaGVkIiwiZGVwbG95RGVjYWYiLCJidWlsZERlY2FmIiwiY3JlYXRlU2ltIiwiYXV0aG9yIiwidGl0bGUiLCJjbGVhbiIsImdldERhdGFGaWxlIiwiY2FjaGUiLCJhY3RpdmVSZXBvcyIsImZpeCIsImZvcm1hdCIsImNoaXBBd2F5IiwiZGlzYWJsZVdpdGhDb21tZW50Iiwic2hvd1Byb2dyZXNzQmFyIiwibGludCIsImNoaXBwZXJBUElWZXJzaW9uIiwibGludFJldHVyblZhbHVlIiwib2siLCJnZW5lcmF0ZURhdGEiLCJjbG9uZU1pc3NpbmdSZXBvcyIsInN0YXJ0UkVQTCIsImNoZWNrQnJhbmNoU3RhdHVzIiwibGlzdCIsImNyZWF0ZVBhdGNoIiwicmVvcGVuSXNzdWVzRnJvbVRPRE9zIl0sInNvdXJjZXMiOlsiR3J1bnRmaWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDAyLTIwMTUsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEdydW50IGNvbmZpZ3VyYXRpb24gZmlsZSBmb3IgdGFza3MgdGhhdCBoYXZlIG5vIGRlcGVuZGVuY2llcyBvbiBvdGhlciByZXBvcy5cclxuICogSW4gcGFydGljdWxhciwgZ3J1bnQgY2hlY2tvdXQtc2hhcyBhbmQgZ3J1bnQgY2hlY2tvdXQtbWFzdGVyIGNhbiBiZSBydW4gZnJvbSBoZXJlXHJcbiAqIHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgYW4gb2xkZXIgdmVyc2lvbiBvZiBjaGlwcGVyIGJlaW5nIGNoZWNrZWQgb3V0LlxyXG4gKlxyXG4gKiBJbiBnZW5lcmFsIHdoZW4gcG9zc2libGUsIG1vZHVsZXMgYXJlIGltcG9ydGVkIGxhemlseSBpbiB0aGVpciB0YXNrXHJcbiAqIGRlY2xhcmF0aW9uIHRvIHNhdmUgb24gb3ZlcmFsbCBsb2FkIHRpbWUgb2YgdGhpcyBmaWxlLiBUaGUgcGF0dGVybiBpcyB0byByZXF1aXJlIGFsbCBtb2R1bGVzIG5lZWRlZCBhdCB0aGUgdG9wIG9mIHRoZVxyXG4gKiBncnVudCB0YXNrIHJlZ2lzdHJhdGlvbi4gSWYgYSBtb2R1bGUgaXMgdXNlZCBpbiBtdWx0aXBsZSB0YXNrcywgaXQgaXMgYmVzdCB0byBsYXppbHkgcmVxdWlyZSBpbiBlYWNoXHJcbiAqIHRhc2suXHJcbiAqL1xyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIE5PVEU6IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIHRoZSB2YXN0IG1ham9yaXR5IG9mIG1vZHVsZXMgYXJlIGxhemlseSBpbXBvcnRlZCBpbiB0YXNrIHJlZ2lzdHJhdGlvbnMuIEV2ZW4gZHVwbGljYXRpbmdcclxuLy8gcmVxdWlyZSBzdGF0ZW1lbnRzIGltcHJvdmVzIHRoZSBsb2FkIHRpbWUgb2YgdGhpcyBmaWxlIG5vdGljZWFibHkuIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NoaXBwZXIvaXNzdWVzLzExMDdcclxuY29uc3QgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lID0gcmVxdWlyZSggJy4uL2NvbW1vbi9hc3NlcnRJc1ZhbGlkUmVwb05hbWUnICk7XHJcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoICdhc3NlcnQnICk7XHJcbmNvbnN0IF8gPSByZXF1aXJlKCAnbG9kYXNoJyApO1xyXG5yZXF1aXJlKCAnLi9jaGVja05vZGVWZXJzaW9uJyApO1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIGdydW50ICkge1xyXG5cclxuICBpZiAoIGdydW50Lm9wdGlvbiggJ2RlYnVnJyApICkge1xyXG4gICAgY29uc3Qgd2luc3RvbiA9IHJlcXVpcmUoICd3aW5zdG9uJyApO1xyXG5cclxuICAgIHdpbnN0b24uZGVmYXVsdC50cmFuc3BvcnRzLmNvbnNvbGUubGV2ZWwgPSAnZGVidWcnO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgdHJ1ZSwgd2lsbCBza2lwIG1vc3QgcHJvbXB0cywgYnV0IHdpbGwgZmFpbCBvdXQgb24gdGhpbmdzIHRoYXQgc2hvdWxkIG5vdCBiZSBkb25lIGluIGFuIGF1dG9tYXRlZCBtYW5uZXIuXHJcbiAgY29uc3Qgbm9uaW50ZXJhY3RpdmUgPSAhIWdydW50Lm9wdGlvbiggJ25vbmludGVyYWN0aXZlJyApO1xyXG5cclxuICAvKipcclxuICAgKiBXcmFwcyBhIHByb21pc2UncyBjb21wbGV0aW9uIHdpdGggZ3J1bnQncyBhc3luY2hyb25vdXMgaGFuZGxpbmcsIHdpdGggYWRkZWQgaGVscGZ1bCBmYWlsdXJlIG1lc3NhZ2VzIChpbmNsdWRpbmcgc3RhY2sgdHJhY2VzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgLS1zdGFjayB3YXMgcHJvdmlkZWQpLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZVxyXG4gICAqL1xyXG4gIGFzeW5jIGZ1bmN0aW9uIHdyYXAoIHByb21pc2UgKSB7XHJcbiAgICBjb25zdCBkb25lID0gZ3J1bnQudGFzay5jdXJyZW50LmFzeW5jKCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgcHJvbWlzZTtcclxuICAgIH1cclxuICAgIGNhdGNoKCBlICkge1xyXG4gICAgICBpZiAoIGUuc3RhY2sgKSB7XHJcbiAgICAgICAgZ3J1bnQuZmFpbC5mYXRhbCggYFBlcmVubmlhbCB0YXNrIGZhaWxlZDpcXG4ke2Uuc3RhY2t9XFxuRnVsbCBFcnJvciBkZXRhaWxzOlxcbiR7ZX1gICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoIHR5cGVvZiBlID09PSAnc3RyaW5nJyApIHtcclxuICAgICAgICBncnVudC5mYWlsLmZhdGFsKCBgUGVyZW5uaWFsIHRhc2sgZmFpbGVkOiAke2V9YCApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGdydW50LmZhaWwuZmF0YWwoIGBQZXJlbm5pYWwgdGFzayBmYWlsZWQgd2l0aCB1bmtub3duIGVycm9yOiAke2V9YCApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZG9uZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV3JhcHMgYW4gYXN5bmMgZnVuY3Rpb24gZm9yIGEgZ3J1bnQgdGFzay4gV2lsbCBydW4gdGhlIGFzeW5jIGZ1bmN0aW9uIHdoZW4gdGhlIHRhc2sgc2hvdWxkIGJlIGV4ZWN1dGVkLiBXaWxsIHByb3Blcmx5IGhhbmRsZSBncnVudCdzIGFzeW5jIGhhbmRsaW5nLCBhbmQgcHJvdmlkZXMgaW1wcm92ZWRcclxuICAgKiBlcnJvciByZXBvcnRpbmcuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHthc3luYyBmdW5jdGlvbn0gYXN5bmNUYXNrRnVuY3Rpb25cclxuICAgKi9cclxuICBmdW5jdGlvbiB3cmFwVGFzayggYXN5bmNUYXNrRnVuY3Rpb24gKSB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3cmFwKCBhc3luY1Rhc2tGdW5jdGlvbigpICk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnY2hlY2tvdXQtc2hhcycsXHJcbiAgICAnQ2hlY2sgb3V0IHNoYXMgZm9yIGEgcHJvamVjdCwgYXMgc3BlY2lmaWVkIGluIGRlcGVuZGVuY2llcy5qc29uXFxuJyArXHJcbiAgICAnLS1yZXBvIDogcmVwb3NpdG9yeSBuYW1lIHdoZXJlIHBhY2thZ2UuanNvbiBzaG91bGQgYmUgcmVhZCBmcm9tXFxuJyArXHJcbiAgICAnLS1za2lwTnBtVXBkYXRlIDogSWYgcHJvdmlkZWQsIHdpbGwgcHJldmVudCB0aGUgdXN1YWwgbnBtIHVwZGF0ZVxcbicgK1xyXG4gICAgJy0tYnVpbGRTZXJ2ZXIgOiBJZiBwcm92aWRlZCwgaXQgd2lsbCByZWFkIGRlcGVuZGVuY2llcyBmcm9tIHRoZSBidWlsZC1zZXJ2ZXIgdGVtcG9yYXJ5IGxvY2F0aW9uIChhbmQgd2lsbCBza2lwIG5wbSB1cGRhdGUpJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAncmVwbycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvc2l0b3J5IHdpdGggLS1yZXBvPXt7UkVQT1NJVE9SWX19JyApO1xyXG5cclxuICAgICAgY29uc3QgY2hlY2tvdXREZXBlbmRlbmNpZXMgPSByZXF1aXJlKCAnLi4vY29tbW9uL2NoZWNrb3V0RGVwZW5kZW5jaWVzJyApO1xyXG5cclxuICAgICAgY29uc3QgYnVpbGRTZXJ2ZXIgPSAhIWdydW50Lm9wdGlvbiggJ2J1aWxkU2VydmVyJyApO1xyXG5cclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gZ3J1bnQuZmlsZS5yZWFkSlNPTiggYnVpbGRTZXJ2ZXIgPyAnLi4vcGVyZW5uaWFsL2pzL2J1aWxkLXNlcnZlci90bXAvZGVwZW5kZW5jaWVzLmpzb24nIDogYC4uLyR7cmVwb30vZGVwZW5kZW5jaWVzLmpzb25gICk7XHJcbiAgICAgIGNvbnN0IGluY2x1ZGVOcG1VcGRhdGUgPSAhZ3J1bnQub3B0aW9uKCAnc2tpcE5wbVVwZGF0ZScgKSAmJiAhYnVpbGRTZXJ2ZXI7XHJcblxyXG4gICAgICBhd2FpdCBjaGVja291dERlcGVuZGVuY2llcyggcmVwbywgZGVwZW5kZW5jaWVzLCBpbmNsdWRlTnBtVXBkYXRlICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnY2hlY2tvdXQtdGFyZ2V0JyxcclxuICAgICdDaGVjayBvdXQgYSBzcGVjaWZpYyBicmFuY2gvU0hBIGZvciBhIHNpbXVsYXRpb24gYW5kIGFsbCBvZiBpdHMgZGVjbGFyZWQgZGVwZW5kZW5jaWVzXFxuJyArXHJcbiAgICAnLS1yZXBvIDogcmVwb3NpdG9yeSBuYW1lIHdoZXJlIHBhY2thZ2UuanNvbiBzaG91bGQgYmUgcmVhZCBmcm9tXFxuJyArXHJcbiAgICAnLS10YXJnZXQgOiB0aGUgYnJhbmNoL1NIQSB0byBjaGVjayBvdXRcXG4nICtcclxuICAgICctLXNraXBOcG1VcGRhdGUgOiBJZiBwcm92aWRlZCwgd2lsbCBwcmV2ZW50IHRoZSB1c3VhbCBucG0gdXBkYXRlJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlcG8gPSBncnVudC5vcHRpb24oICdyZXBvJyApO1xyXG5cclxuICAgICAgYXNzZXJ0KCByZXBvLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHJlcG9zaXRvcnkgd2l0aCAtLXJlcG89e3tSRVBPU0lUT1JZfX0nICk7XHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAndGFyZ2V0JyApLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIGJyYW5jaC9TSEEgd2l0aCAtLXRhcmdldD17e0JSQU5DSH19JyApO1xyXG5cclxuICAgICAgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lKCByZXBvICk7XHJcblxyXG4gICAgICBjb25zdCBjaGVja291dFRhcmdldCA9IHJlcXVpcmUoICcuLi9jb21tb24vY2hlY2tvdXRUYXJnZXQnICk7XHJcblxyXG4gICAgICBhd2FpdCBjaGVja291dFRhcmdldCggcmVwbywgZ3J1bnQub3B0aW9uKCAndGFyZ2V0JyApLCAhZ3J1bnQub3B0aW9uKCAnc2tpcE5wbVVwZGF0ZScgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2NoZWNrb3V0LXJlbGVhc2UnLFxyXG4gICAgJ0NoZWNrIG91dCB0aGUgbGF0ZXN0IGRlcGxveWVkIHByb2R1Y3Rpb24gcmVsZWFzZSBicmFuY2ggZm9yIGEgc2ltdWxhdGlvbiBhbmQgYWxsIG9mIGl0cyBkZWNsYXJlZCBkZXBlbmRlbmNpZXNcXG4nICtcclxuICAgICctLXJlcG8gOiByZXBvc2l0b3J5IG5hbWUgd2hlcmUgcGFja2FnZS5qc29uIHNob3VsZCBiZSByZWFkIGZyb21cXG4nICtcclxuICAgICctLXNraXBOcG1VcGRhdGUgOiBJZiBwcm92aWRlZCwgd2lsbCBwcmV2ZW50IHRoZSB1c3VhbCBucG0gdXBkYXRlJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNoZWNrb3V0UmVsZWFzZSA9IHJlcXVpcmUoICcuLi9jb21tb24vY2hlY2tvdXRSZWxlYXNlJyApO1xyXG5cclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcblxyXG4gICAgICBhc3NlcnQoIHJlcG8sICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcmVwbz17e1JFUE9TSVRPUll9fScgKTtcclxuICAgICAgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lKCByZXBvICk7XHJcblxyXG4gICAgICBhd2FpdCBjaGVja291dFJlbGVhc2UoIHJlcG8sICFncnVudC5vcHRpb24oICdza2lwTnBtVXBkYXRlJyApICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnY2hlY2tvdXQtdGltZXN0YW1wJyxcclxuICAgICdDaGVjayBvdXQgYSBzcGVjaWZpYyB0aW1lc3RhbXAgZm9yIGEgc2ltdWxhdGlvbiBhbmQgYWxsIG9mIGl0cyBkZWNsYXJlZCBkZXBlbmRlbmNpZXNcXG4nICtcclxuICAgICctLXJlcG8gOiByZXBvc2l0b3J5IG5hbWUgd2hlcmUgcGFja2FnZS5qc29uIHNob3VsZCBiZSByZWFkIGZyb21cXG4nICtcclxuICAgICctLXRpbWVzdGFtcCA6IHRoZSB0aW1lc3RhbXAgdG8gY2hlY2sgdGhpbmdzIG91dCBmb3IsIGUuZy4gLS10aW1lc3RhbXA9XCJKYW4gMDggMjAxOFwiXFxuJyArXHJcbiAgICAnLS1za2lwTnBtVXBkYXRlIDogSWYgcHJvdmlkZWQsIHdpbGwgcHJldmVudCB0aGUgdXN1YWwgbnBtIHVwZGF0ZScsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCByZXBvID0gZ3J1bnQub3B0aW9uKCAncmVwbycgKTtcclxuXHJcbiAgICAgIGFzc2VydCggcmVwbywgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvc2l0b3J5IHdpdGggLS1yZXBvPXt7UkVQT1NJVE9SWX19JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ3RpbWVzdGFtcCcgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSB0aW1lc3RhbXAgd2l0aCAtLXRpbWVzdGFtcD17e0JSQU5DSH19JyApO1xyXG5cclxuICAgICAgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lKCByZXBvICk7XHJcblxyXG4gICAgICBjb25zdCBjaGVja291dFRpbWVzdGFtcCA9IHJlcXVpcmUoICcuLi9jb21tb24vY2hlY2tvdXRUaW1lc3RhbXAnICk7XHJcblxyXG4gICAgICBhd2FpdCBjaGVja291dFRpbWVzdGFtcCggcmVwbywgZ3J1bnQub3B0aW9uKCAndGltZXN0YW1wJyApLCAhZ3J1bnQub3B0aW9uKCAnc2tpcE5wbVVwZGF0ZScgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2NoZWNrb3V0LW1hc3RlcicsXHJcbiAgICAnQ2hlY2sgb3V0IG1hc3RlciBicmFuY2ggZm9yIGFsbCBkZXBlbmRlbmNpZXMsIGFzIHNwZWNpZmllZCBpbiBkZXBlbmRlbmNpZXMuanNvblxcbicgK1xyXG4gICAgJy0tcmVwbyA6IHJlcG9zaXRvcnkgbmFtZSB3aGVyZSBwYWNrYWdlLmpzb24gc2hvdWxkIGJlIHJlYWQgZnJvbVxcbicgK1xyXG4gICAgJy0tc2tpcE5wbVVwZGF0ZSA6IElmIHByb3ZpZGVkLCB3aWxsIHByZXZlbnQgdGhlIHVzdWFsIG5wbSB1cGRhdGUnLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcblxyXG4gICAgICBhc3NlcnQoIHJlcG8sICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcmVwbz17e1JFUE9TSVRPUll9fScgKTtcclxuXHJcbiAgICAgIGNvbnN0IGNoZWNrb3V0TWFzdGVyID0gcmVxdWlyZSggJy4uL2NvbW1vbi9jaGVja291dE1hc3RlcicgKTtcclxuXHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgYXdhaXQgY2hlY2tvdXRNYXN0ZXIoIHJlcG8sICFncnVudC5vcHRpb24oICdza2lwTnBtVXBkYXRlJyApICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnY2hlY2tvdXQtbWFzdGVyLWFsbCcsXHJcbiAgICAnQ2hlY2sgb3V0IG1hc3RlciBicmFuY2ggZm9yIGFsbCByZXBvcyBpbiBnaXQgcm9vdCcsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBjaGVja291dE1hc3RlckFsbCA9IHJlcXVpcmUoICcuL2NoZWNrb3V0TWFzdGVyQWxsJyApO1xyXG5cclxuICAgICAgY2hlY2tvdXRNYXN0ZXJBbGwoKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdzaGEtY2hlY2snLFxyXG4gICAgJ0NoZWNrcyB3aGljaCBzaW11bGF0aW9uc1xcJyBsYXRlc3QgcmVsZWFzZSB2ZXJzaW9uIGluY2x1ZGVzIHRoZSBnaXZlbiBjb21tb24tY29kZSBTSEEgaW4gaXRzIGdpdCB0cmVlLlxcbicgK1xyXG4gICAgJy0tcmVwbyA6IHJlcG9zaXRvcnkgdG8gY2hlY2sgZm9yIHRoZSBTSEFcXG4nICtcclxuICAgICctLXNoYSA6IGdpdCBTSEEnLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgY29uc3Qgc2hhQ2hlY2sgPSByZXF1aXJlKCAnLi9zaGFDaGVjaycgKTtcclxuXHJcbiAgICAgIGF3YWl0IHNoYUNoZWNrKCByZXBvLCBncnVudC5vcHRpb24oICdzaGEnICkgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdwcmludC1waGV0LWlvLWxpbmtzJyxcclxuICAgICdQcmludCB0aGUgY3VycmVudCBsaXN0IG9mIGFsbCBwaGV0LWlvIHNpbXNcXCcgbGlua3MnLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgZ2V0UGhldGlvTGlua3MgPSByZXF1aXJlKCAnLi4vY29tbW9uL2dldFBoZXRpb0xpbmtzJyApO1xyXG4gICAgICBjb25zdCBwaGV0aW9MaW5rcyA9IGF3YWl0IGdldFBoZXRpb0xpbmtzKCk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyggJ0xhdGVzdCBMaW5rczonICk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCBgXFxuJHtwaGV0aW9MaW5rcy5qb2luKCAnXFxuJyApfWAgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICd1cGRhdGUtZ2gtcGFnZXMnLFxyXG4gICAgJ1VwZGF0ZXMgdGhlIGdoLXBhZ2VzIGJyYW5jaGVzIGZvciB2YXJpb3VzIHJlcG9zLCBpbmNsdWRpbmcgYnVpbGRpbmcgb2YgZG90L2tpdGUvc2NlbmVyeScsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB1cGRhdGVHaXRodWJQYWdlcyA9IHJlcXVpcmUoICcuLi9jb21tb24vdXBkYXRlR2l0aHViUGFnZXMnICk7XHJcblxyXG4gICAgICBhd2FpdCB1cGRhdGVHaXRodWJQYWdlcygpO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ3NpbS1saXN0JyxcclxuICAgICdQcmludHMgb3V0IGEgbGlzdCBvZiBsaXZlIHByb2R1Y3Rpb24gSFRNTCBzaW1zIHRvIHN0ZGVyciAoY2FuIGJlIGZpbHRlcmVkIGZyb20gb3RoZXIgc3Rkb3V0IG91dHB1dClcXG4nICtcclxuICAgICctLXZlcnNpb25zIDogT3V0cHV0cyB0aGUgc2ltIHZlcnNpb24gYWZ0ZXIgaXRzIG5hbWUuJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHNpbU1ldGFkYXRhID0gcmVxdWlyZSggJy4uL2NvbW1vbi9zaW1NZXRhZGF0YScgKTtcclxuICAgICAgY29uc3Qgd2luc3RvbiA9IHJlcXVpcmUoICd3aW5zdG9uJyApO1xyXG5cclxuICAgICAgd2luc3Rvbi5kZWZhdWx0LnRyYW5zcG9ydHMuY29uc29sZS5sZXZlbCA9ICdlcnJvcic7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzaW1NZXRhZGF0YSgge1xyXG4gICAgICAgIHR5cGU6ICdodG1sJ1xyXG4gICAgICB9ICk7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoIGRhdGEucHJvamVjdHMubWFwKCBwcm9qZWN0ID0+IHtcclxuICAgICAgICBjb25zdCBuYW1lID0gcHJvamVjdC5uYW1lLnNsaWNlKCBwcm9qZWN0Lm5hbWUuaW5kZXhPZiggJy8nICkgKyAxICk7XHJcblxyXG4gICAgICAgIGxldCByZXN1bHQgPSBuYW1lO1xyXG4gICAgICAgIGlmICggZ3J1bnQub3B0aW9uKCAndmVyc2lvbnMnICkgKSB7XHJcbiAgICAgICAgICByZXN1bHQgKz0gYCAke3Byb2plY3QudmVyc2lvbi5tYWpvcn0uJHtwcm9qZWN0LnZlcnNpb24ubWlub3J9LiR7cHJvamVjdC52ZXJzaW9uLmRldn1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9ICkuam9pbiggJ1xcbicgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ3JlbGVhc2UtYnJhbmNoLWxpc3QnLFxyXG4gICAgJ1ByaW50cyBvdXQgYSBsaXN0IG9mIGFsbCByZWxlYXNlIGJyYW5jaGVzIHRoYXQgd291bGQgbmVlZCBtYWludGVuYW5jZSBwYXRjaGVzXFxuJyArXHJcbiAgICAnLS1yZXBvIDogT25seSBzaG93IGJyYW5jaGVzIGZvciBhIHNwZWNpZmljIHJlcG9zaXRvcnlcXG4nICtcclxuICAgICctLW9yZGVyPTxPUkRFUj4gOiBhbHBoYWJldGljYWx8ZGF0ZScsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBNYWludGVuYW5jZSA9IHJlcXVpcmUoICcuLi9jb21tb24vTWFpbnRlbmFuY2UnICk7XHJcbiAgICAgIGNvbnN0IHdpbnN0b24gPSByZXF1aXJlKCAnd2luc3RvbicgKTtcclxuXHJcbiAgICAgIHdpbnN0b24uZGVmYXVsdC50cmFuc3BvcnRzLmNvbnNvbGUubGV2ZWwgPSAnZXJyb3InO1xyXG5cclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGNvbnN0IG9yZGVyID0gZ3J1bnQub3B0aW9uKCAnb3JkZXInICkgfHwgJ2FscGhhYmV0aWNhbCc7XHJcblxyXG4gICAgICBpZiAoIHJlcG8gKSB7XHJcbiAgICAgICAgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lKCByZXBvICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFzc2VydCggb3JkZXIgPT09ICdhbHBoYWJldGljYWwnIHx8IG9yZGVyID09PSAnZGF0ZScgKTtcclxuXHJcbiAgICAgIGNvbnN0IGJyYW5jaGVzID0gYXdhaXQgTWFpbnRlbmFuY2UuZ2V0TWFpbnRlbmFuY2VCcmFuY2hlcyggZmlsdGVyUmVwbyA9PiAhcmVwbyB8fCBmaWx0ZXJSZXBvID09PSByZXBvLCB0cnVlLCB0cnVlICk7XHJcblxyXG4gICAgICBsZXQgc3RydWN0dXJlcyA9IFtdO1xyXG4gICAgICBmb3IgKCBjb25zdCBicmFuY2ggb2YgYnJhbmNoZXMgKSB7XHJcbiAgICAgICAgc3RydWN0dXJlcy5wdXNoKCB7XHJcbiAgICAgICAgICBicmFuY2g6IGJyYW5jaCxcclxuICAgICAgICAgIHRpbWVzdGFtcDogYXdhaXQgYnJhbmNoLmdldERpdmVyZ2luZ1RpbWVzdGFtcCgpXHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIG9yZGVyID09PSAnZGF0ZScgKSB7XHJcbiAgICAgICAgc3RydWN0dXJlcyA9IF8uc29ydEJ5KCBzdHJ1Y3R1cmVzLCBzdHJ1Y3QgPT4gc3RydWN0LnRpbWVzdGFtcCApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyggJ1xcblJlbGVhc2UgYnJhbmNoZXM6XFxue3JlcG99IHticmFuY2h9IHticmFuZFssYnJhbmRdK30ge2RhdGV9XFxuJyApO1xyXG4gICAgICBmb3IgKCBjb25zdCBzdHJ1Y3Qgb2Ygc3RydWN0dXJlcyApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyggYCR7c3RydWN0LmJyYW5jaC50b1N0cmluZygpfSAke25ldyBEYXRlKCBzdHJ1Y3QudGltZXN0YW1wICkudG9JU09TdHJpbmcoKS5zcGxpdCggJ1QnIClbIDAgXX1gICk7XHJcbiAgICAgIH1cclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICducG0tdXBkYXRlJyxcclxuICAgICdSdW5zIG5wbSB1cGRhdGUvcHJ1bmUgZm9yIGNoaXBwZXIsIHBlcmVubmlhbC1hbGlhcyBhbmQgdGhlIGdpdmVuIHJlcG9zaXRvcnlcXG4nICtcclxuICAgICctLXJlcG8gOiBUaGUgcmVwb3NpdG9yeSB0byB1cGRhdGUnLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbnBtVXBkYXRlID0gcmVxdWlyZSggJy4uL2NvbW1vbi9ucG1VcGRhdGUnICk7XHJcblxyXG4gICAgICBjb25zdCByZXBvID0gZ3J1bnQub3B0aW9uKCAncmVwbycgKTtcclxuICAgICAgYXNzZXJ0KCByZXBvLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHJlcG9zaXRvcnkgd2l0aCAtLXJlcG89e3tSRVBPU0lUT1JZfX0nICk7XHJcblxyXG4gICAgICBhc3NlcnRJc1ZhbGlkUmVwb05hbWUoIHJlcG8gKTtcclxuXHJcbiAgICAgIGF3YWl0IG5wbVVwZGF0ZSggcmVwbyApLnRoZW4oICgpID0+IG5wbVVwZGF0ZSggJ2NoaXBwZXInICkgKS50aGVuKCAoKSA9PiBucG1VcGRhdGUoICdwZXJlbm5pYWwtYWxpYXMnICkgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdjcmVhdGUtcmVsZWFzZScsXHJcbiAgICAnQ3JlYXRlcyBhIG5ldyByZWxlYXNlIGJyYW5jaCBmb3IgYSBnaXZlbiBzaW11bGF0aW9uXFxuJyArXHJcbiAgICAnLS1yZXBvIDogVGhlIHJlcG9zaXRvcnkgdG8gYWRkIHRoZSByZWxlYXNlIGJyYW5jaCB0b1xcbicgK1xyXG4gICAgJy0tYnJhbmNoIDogVGhlIGJyYW5jaCBuYW1lLCB3aGljaCBzaG91bGQgYmUge3tNQUpPUn19Lnt7TUlOT1J9fSwgZS5nLiAxLjBcXG4nICtcclxuICAgICctLWJyYW5kcyA6IFRoZSBzdXBwb3J0ZWQgYnJhbmRzIGZvciB0aGUgcmVsZWFzZSwgY29tbWEgc2VwYXJhdGVkLlxcbicgK1xyXG4gICAgJy0tbWVzc2FnZSA6IEFuIG9wdGlvbmFsIG1lc3NhZ2UgdGhhdCB3aWxsIGJlIGFwcGVuZGVkIG9uIHZlcnNpb24tY2hhbmdlIGNvbW1pdHMuJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNyZWF0ZVJlbGVhc2UgPSByZXF1aXJlKCAnLi9jcmVhdGVSZWxlYXNlJyApO1xyXG5cclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgY29uc3QgYnJhbmNoID0gZ3J1bnQub3B0aW9uKCAnYnJhbmNoJyApO1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gZ3J1bnQub3B0aW9uKCAnbWVzc2FnZScgKTtcclxuICAgICAgY29uc3QgYnJhbmRzID0gZ3J1bnQub3B0aW9uKCAnYnJhbmRzJyApO1xyXG5cclxuICAgICAgYXNzZXJ0KCByZXBvLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHJlcG9zaXRvcnkgd2l0aCAtLXJlcG89e3tSRVBPU0lUT1JZfX0nICk7XHJcbiAgICAgIGFzc2VydCggYnJhbmRzLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBicmFuZHMgd2l0aCAtLWJyYW5kcz17e0JSQU5EU319IChjb21tYSBzZXBhcmF0ZWQpJyApO1xyXG4gICAgICBhc3NlcnQoIGJyYW5jaCwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSBicmFuY2ggd2l0aCAtLWJyYW5jaD17e0JSQU5DSH19JyApO1xyXG4gICAgICBhc3NlcnQoIGJyYW5jaC5zcGxpdCggJy4nICkubGVuZ3RoID09PSAyLCAnQnJhbmNoIHNob3VsZCBiZSB7e01BSk9SfX0ue3tNSU5PUn19JyApO1xyXG5cclxuICAgICAgYXdhaXQgY3JlYXRlUmVsZWFzZSggcmVwbywgYnJhbmNoLCBicmFuZHMuc3BsaXQoICcsJyApLCBtZXNzYWdlICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnY3JlYXRlLW9uZS1vZmYnLFxyXG4gICAgJ0NyZWF0ZXMgYSBuZXcgcmVsZWFzZSBicmFuY2ggZm9yIGEgZ2l2ZW4gc2ltdWxhdGlvblxcbicgK1xyXG4gICAgJy0tcmVwbyA6IFRoZSByZXBvc2l0b3J5IHRvIGFkZCB0aGUgcmVsZWFzZSBicmFuY2ggdG9cXG4nICtcclxuICAgICctLWJyYW5jaCA6IFRoZSBicmFuY2gvb25lLW9mZiBuYW1lLCB3aGljaCBzaG91bGQgYmUgYW55dGhpbmcgd2l0aG91dCBkYXNoZXMgb3IgcGVyaW9kc1xcbicgK1xyXG4gICAgJy0tbWVzc2FnZSA6IEFuIG9wdGlvbmFsIG1lc3NhZ2UgdGhhdCB3aWxsIGJlIGFwcGVuZGVkIG9uIHZlcnNpb24tY2hhbmdlIGNvbW1pdHMuJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNyZWF0ZU9uZU9mZiA9IHJlcXVpcmUoICcuL2NyZWF0ZU9uZU9mZicgKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcG8gPSBncnVudC5vcHRpb24oICdyZXBvJyApO1xyXG4gICAgICBhc3NlcnRJc1ZhbGlkUmVwb05hbWUoIHJlcG8gKTtcclxuXHJcbiAgICAgIGNvbnN0IGJyYW5jaCA9IGdydW50Lm9wdGlvbiggJ2JyYW5jaCcgKTtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IGdydW50Lm9wdGlvbiggJ21lc3NhZ2UnICk7XHJcbiAgICAgIGFzc2VydCggcmVwbywgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvc2l0b3J5IHdpdGggLS1yZXBvPXt7UkVQT1NJVE9SWX19JyApO1xyXG4gICAgICBhc3NlcnQoIGJyYW5jaCwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSBicmFuY2ggd2l0aCAtLWJyYW5jaD17e0JSQU5DSH19JyApO1xyXG4gICAgICBhc3NlcnQoICFicmFuY2guaW5jbHVkZXMoICctJyApICYmICFicmFuY2guaW5jbHVkZXMoICcuJyApLCAnQnJhbmNoIHNob3VsZCBub3QgY29udGFpbiBkYXNoZXMgb3IgcGVyaW9kcycgKTtcclxuXHJcbiAgICAgIGF3YWl0IGNyZWF0ZU9uZU9mZiggcmVwbywgYnJhbmNoLCBtZXNzYWdlICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnY2hlcnJ5LXBpY2snLFxyXG4gICAgJ1J1bnMgY2hlcnJ5LXBpY2sgb24gYSBsaXN0IG9mIFNIQXMgdW50aWwgb25lIHdvcmtzLiBSZXBvcnRzIHN1Y2Nlc3Mgb3IgZmFpbHVyZVxcbicgK1xyXG4gICAgJy0tcmVwbyA6IFRoZSByZXBvc2l0b3J5IHRvIGNoZXJyeS1waWNrIG9uXFxuJyArXHJcbiAgICAnLS1zaGFzIDogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgU0hBcyB0byB0cnknLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgY2hlcnJ5UGljayA9IHJlcXVpcmUoICcuL2NoZXJyeVBpY2snICk7XHJcblxyXG4gICAgICBjb25zdCByZXBvID0gZ3J1bnQub3B0aW9uKCAncmVwbycgKTtcclxuXHJcbiAgICAgIGFzc2VydCggcmVwbywgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvc2l0b3J5IHdpdGggLS1yZXBvPXt7UkVQT1NJVE9SWX19JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ3NoYXMnICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgU0hBcyB3aXRoIC0tc2hhcz17e1NIQVN9fScgKTtcclxuXHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgY29uc3Qgc2hhcyA9IGdydW50Lm9wdGlvbiggJ3NoYXMnICkuc3BsaXQoICcsJyApO1xyXG5cclxuICAgICAgYXdhaXQgY2hlcnJ5UGljayggcmVwbywgc2hhcyApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2xpbnQnLCAnTGludHMgdGhpcyByZXBvc2l0b3J5IG9ubHknLCB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgZXhlY3V0ZSA9IHJlcXVpcmUoICcuLi9jb21tb24vZXhlY3V0ZScgKTtcclxuICAgIGNvbnN0IGdydW50Q29tbWFuZCA9IHJlcXVpcmUoICcuLi9jb21tb24vZ3J1bnRDb21tYW5kJyApO1xyXG5cclxuICAgIGNvbnN0IGluZGV4ID0gcHJvY2Vzcy5hcmd2LmluZGV4T2YoICdsaW50JyApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggaW5kZXggPj0gMCwgJ2xpbnQgY29tbWFuZCBkb2VzIG5vdCBhcHBlYXInICk7XHJcbiAgICBjb25zdCB0YWlsID0gcHJvY2Vzcy5hcmd2LnNsaWNlKCBpbmRleCArIDEgKTtcclxuXHJcbiAgICBpZiAoICFncnVudC5vcHRpb24oICdyZXBvcycgKSApIHtcclxuICAgICAgdGFpbC5wdXNoKCAnLS1yZXBvcz1wZXJlbm5pYWwnICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9yd2FyZCB0byBjaGlwcGVyLCBzdXBwb3J0aW5nIGFsbCBvZiB0aGUgb3B0aW9uc1xyXG4gICAgZ3J1bnQubG9nLndyaXRlbG4oICggYXdhaXQgZXhlY3V0ZSggZ3J1bnRDb21tYW5kLCBbICdsaW50JywgLi4udGFpbCBdLCAnLi4vY2hpcHBlcicsIHsgZXJyb3JzOiAncmVzb2x2ZScgfSApICkuc3Rkb3V0ICk7XHJcbiAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2RldicsXHJcbiAgICAnRGVwbG95cyBhIGRldiB2ZXJzaW9uIG9mIHRoZSBzaW11bGF0aW9uXFxuJyArXHJcbiAgICAnLS1yZXBvIDogVGhlIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnkgdG8gZGVwbG95XFxuJyArXHJcbiAgICAnLS1icmFuZHMgOiBBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGJyYW5kIG5hbWVzIHRvIGRlcGxveVxcbicgK1xyXG4gICAgJy0tbm9uaW50ZXJhY3RpdmUgOiBJZiBzcGVjaWZpZWQsIHByb21wdHMgd2lsbCBiZSBza2lwcGVkLiBTb21lIHByb21wdHMgdGhhdCBzaG91bGQgbm90IGJlIGF1dG9tYXRlZCB3aWxsIGZhaWwgb3V0XFxuJyArXHJcbiAgICAnLS1tZXNzYWdlIDogQW4gb3B0aW9uYWwgbWVzc2FnZSB0aGF0IHdpbGwgYmUgYXBwZW5kZWQgb24gdmVyc2lvbi1jaGFuZ2UgY29tbWl0cy4nLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgZGV2ID0gcmVxdWlyZSggJy4vZGV2JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ3JlcG8nICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcmVwbz17e1JFUE9TSVRPUll9fScgKTtcclxuICAgICAgYXNzZXJ0KCBncnVudC5vcHRpb24oICdicmFuZHMnICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGJyYW5kcyAoY29tbWEtc2VwYXJhdGVkKSB3aXRoIC0tYnJhbmRzPXt7QlJBTkRTfX0nICk7XHJcblxyXG4gICAgICBjb25zdCByZXBvID0gZ3J1bnQub3B0aW9uKCAncmVwbycgKTtcclxuICAgICAgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lKCByZXBvICk7XHJcblxyXG4gICAgICBhd2FpdCBkZXYoIHJlcG8sIGdydW50Lm9wdGlvbiggJ2JyYW5kcycgKS5zcGxpdCggJywnICksIG5vbmludGVyYWN0aXZlLCAnbWFzdGVyJywgZ3J1bnQub3B0aW9uKCAnbWVzc2FnZScgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2RlcGxveS1pbWFnZXMnLFxyXG4gICAgJ1JlYnVpbGRzIGFsbCBpbWFnZXNcXG4nICtcclxuICAgICctLXNpbXVsYXRpb24gOiBPcHRpb25hbC4gSWYgcHJlc2VudCwgb25seSB0aGUgZ2l2ZW4gc2ltdWxhdGlvbiB3aWxsIHJlY2VpdmUgaW1hZ2VzIGZyb20gbWFzdGVyLiBJZiBhYnNlbnQsIGFsbCBzaW1zJyArXHJcbiAgICAnd2lsbCByZWNlaXZlIGltYWdlcyBmcm9tIG1hc3Rlci4nLFxyXG5cclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCBncnVudC5vcHRpb24oICdzaW11bGF0aW9uJyApICk7XHJcbiAgICAgIGNvbnN0IHNpbXVsYXRpb24gPSBncnVudC5vcHRpb24oICdzaW11bGF0aW9uJyApIHx8IG51bGw7XHJcbiAgICAgIGNvbnN0IGRlcGxveUltYWdlcyA9IHJlcXVpcmUoICcuL2RlcGxveUltYWdlcycgKTtcclxuICAgICAgYXdhaXQgZGVwbG95SW1hZ2VzKCB7IHNpbXVsYXRpb246IHNpbXVsYXRpb24gfSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ29uZS1vZmYnLFxyXG4gICAgJ0RlcGxveXMgYSBvbmUtb2ZmIHZlcnNpb24gb2YgdGhlIHNpbXVsYXRpb24gKHVzaW5nIHRoZSBjdXJyZW50IG9yIHNwZWNpZmllZCBicmFuY2gpXFxuJyArXHJcbiAgICAnLS1yZXBvIDogVGhlIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnkgdG8gZGVwbG95XFxuJyArXHJcbiAgICAnLS1icmFuY2ggOiBUaGUgbmFtZSBvZiB0aGUgb25lLW9mZiBicmFuY2ggKHRoZSBuYW1lIG9mIHRoZSBvbmUtb2ZmKVxcbicgK1xyXG4gICAgJy0tYnJhbmRzIDogQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBicmFuZCBuYW1lcyB0byBkZXBsb3lcXG4nICtcclxuICAgICctLW5vbmludGVyYWN0aXZlIDogSWYgc3BlY2lmaWVkLCBwcm9tcHRzIHdpbGwgYmUgc2tpcHBlZC4gU29tZSBwcm9tcHRzIHRoYXQgc2hvdWxkIG5vdCBiZSBhdXRvbWF0ZWQgd2lsbCBmYWlsIG91dFxcbicgK1xyXG4gICAgJy0tbWVzc2FnZSA6IEFuIG9wdGlvbmFsIG1lc3NhZ2UgdGhhdCB3aWxsIGJlIGFwcGVuZGVkIG9uIHZlcnNpb24tY2hhbmdlIGNvbW1pdHMuJyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcblxyXG4gICAgICBjb25zdCBnZXRCcmFuY2ggPSByZXF1aXJlKCAnLi4vY29tbW9uL2dldEJyYW5jaCcgKTtcclxuICAgICAgY29uc3QgZGV2ID0gcmVxdWlyZSggJy4vZGV2JyApO1xyXG5cclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgY29uc3QgYnJhbmRzID0gZ3J1bnQub3B0aW9uKCAnYnJhbmRzJyApO1xyXG5cclxuICAgICAgYXNzZXJ0KCByZXBvLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHJlcG9zaXRvcnkgd2l0aCAtLXJlcG89e3tSRVBPU0lUT1JZfX0nICk7XHJcbiAgICAgIGFzc2VydCggYnJhbmRzLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBicmFuZHMgKGNvbW1hLXNlcGFyYXRlZCkgd2l0aCAtLWJyYW5kcz17e0JSQU5EU319JyApO1xyXG5cclxuICAgICAgbGV0IGJyYW5jaCA9IGdydW50Lm9wdGlvbiggJ2JyYW5jaCcgKTtcclxuICAgICAgaWYgKCAhYnJhbmNoICkge1xyXG4gICAgICAgIGJyYW5jaCA9IGF3YWl0IGdldEJyYW5jaCggcmVwbyApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCBgLS1icmFuY2ggbm90IHByb3ZpZGVkLCB1c2luZyAke2JyYW5jaH0gZGV0ZWN0ZWQgZnJvbSAke3JlcG99YCApO1xyXG4gICAgICB9XHJcbiAgICAgIGFzc2VydCggYnJhbmNoICE9PSAnbWFzdGVyJywgJ09uZS1vZmYgZGVwbG95cyBmb3IgbWFzdGVyIGFyZSB1bnN1cHBvcnRlZC4nICk7XHJcblxyXG4gICAgICBhd2FpdCBkZXYoIHJlcG8sIGJyYW5kcy5zcGxpdCggJywnICksIG5vbmludGVyYWN0aXZlLCBicmFuY2gsIGdydW50Lm9wdGlvbiggJ21lc3NhZ2UnICkgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdyYycsXHJcbiAgICAnRGVwbG95cyBhbiByYyB2ZXJzaW9uIG9mIHRoZSBzaW11bGF0aW9uXFxuJyArXHJcbiAgICAnLS1yZXBvIDogVGhlIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnkgdG8gZGVwbG95XFxuJyArXHJcbiAgICAnLS1icmFuY2ggOiBUaGUgcmVsZWFzZSBicmFuY2ggbmFtZSAoZS5nLiBcIjEuN1wiKSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBkZXBsb3ltZW50XFxuJyArXHJcbiAgICAnLS1icmFuZHMgOiBBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGJyYW5kIG5hbWVzIHRvIGRlcGxveVxcbicgK1xyXG4gICAgJy0tbm9uaW50ZXJhY3RpdmUgOiBJZiBzcGVjaWZpZWQsIHByb21wdHMgd2lsbCBiZSBza2lwcGVkLiBTb21lIHByb21wdHMgdGhhdCBzaG91bGQgbm90IGJlIGF1dG9tYXRlZCB3aWxsIGZhaWwgb3V0XFxuJyArXHJcbiAgICAnLS1tZXNzYWdlIDogQW4gb3B0aW9uYWwgbWVzc2FnZSB0aGF0IHdpbGwgYmUgYXBwZW5kZWQgb24gdmVyc2lvbi1jaGFuZ2UgY29tbWl0cy4nLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgYXNzZXJ0KCBncnVudC5vcHRpb24oICdyZXBvJyApLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHJlcG9zaXRvcnkgd2l0aCAtLXJlcG89e3tSRVBPU0lUT1JZfX0nICk7XHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAnYnJhbmNoJyApLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIGJyYW5jaCB3aXRoIC0tYnJhbmNoPXt7QlJBTkNIfX0nICk7XHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAnYnJhbmRzJyApLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBicmFuZHMgKGNvbW1hLXNlcGFyYXRlZCkgd2l0aCAtLWJyYW5kcz17e0JSQU5EU319JyApO1xyXG5cclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgY29uc3QgcmMgPSByZXF1aXJlKCAnLi9yYycgKTtcclxuXHJcbiAgICAgIGF3YWl0IHJjKCByZXBvLCBncnVudC5vcHRpb24oICdicmFuY2gnICksIGdydW50Lm9wdGlvbiggJ2JyYW5kcycgKS5zcGxpdCggJywnICksIG5vbmludGVyYWN0aXZlLCBncnVudC5vcHRpb24oICdtZXNzYWdlJyApICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAncHJvZHVjdGlvbicsXHJcbiAgICAnTWFya3MgYSBzaW11bGF0aW9uIGFzIHB1Ymxpc2hlZCwgYW5kIGRlcGxveXMgYSBwcm9kdWN0aW9uIHZlcnNpb24gb2YgdGhlIHNpbXVsYXRpb25cXG4nICtcclxuICAgICctLXJlcG8gOiBUaGUgbmFtZSBvZiB0aGUgcmVwb3NpdG9yeSB0byBkZXBsb3lcXG4nICtcclxuICAgICctLWJyYW5jaCA6IFRoZSByZWxlYXNlIGJyYW5jaCBuYW1lIChlLmcuIFwiMS43XCIpIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGRlcGxveW1lbnRcXG4nICtcclxuICAgICctLWJyYW5kcyA6IEEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYnJhbmQgbmFtZXMgdG8gZGVwbG95XFxuJyArXHJcbiAgICAnLS1ub25pbnRlcmFjdGl2ZSA6IElmIHNwZWNpZmllZCwgcHJvbXB0cyB3aWxsIGJlIHNraXBwZWQuIFNvbWUgcHJvbXB0cyB0aGF0IHNob3VsZCBub3QgYmUgYXV0b21hdGVkIHdpbGwgZmFpbCBvdXRcXG4nICtcclxuICAgICctLW1lc3NhZ2UgOiBBbiBvcHRpb25hbCBtZXNzYWdlIHRoYXQgd2lsbCBiZSBhcHBlbmRlZCBvbiB2ZXJzaW9uLWNoYW5nZSBjb21taXRzLicsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBwcm9kdWN0aW9uID0gcmVxdWlyZSggJy4vcHJvZHVjdGlvbicgKTtcclxuICAgICAgY29uc3QgbWFya1NpbUFzUHVibGlzaGVkID0gcmVxdWlyZSggJy4uL2NvbW1vbi9tYXJrU2ltQXNQdWJsaXNoZWQnICk7XHJcblxyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ3JlcG8nICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcmVwbz17e1JFUE9TSVRPUll9fScgKTtcclxuICAgICAgYXNzZXJ0KCBncnVudC5vcHRpb24oICdicmFuY2gnICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgYnJhbmNoIHdpdGggLS1icmFuY2g9e3tCUkFOQ0h9fScgKTtcclxuICAgICAgYXNzZXJ0KCBncnVudC5vcHRpb24oICdicmFuZHMnICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGJyYW5kcyAoY29tbWEtc2VwYXJhdGVkKSB3aXRoIC0tYnJhbmRzPXt7QlJBTkRTfX0nICk7XHJcblxyXG4gICAgICBjb25zdCByZXBvID0gZ3J1bnQub3B0aW9uKCAncmVwbycgKTtcclxuICAgICAgYXNzZXJ0SXNWYWxpZFJlcG9OYW1lKCByZXBvICk7XHJcblxyXG4gICAgICBhd2FpdCBtYXJrU2ltQXNQdWJsaXNoZWQoIHJlcG8gKTtcclxuXHJcbiAgICAgIGF3YWl0IHByb2R1Y3Rpb24oIHJlcG8sIGdydW50Lm9wdGlvbiggJ2JyYW5jaCcgKSwgZ3J1bnQub3B0aW9uKCAnYnJhbmRzJyApLnNwbGl0KCAnLCcgKSwgbm9uaW50ZXJhY3RpdmUsIGdydW50Lm9wdGlvbiggJ21lc3NhZ2UnICkgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdwcm90b3R5cGUnLFxyXG4gICAgJ0RlcGxveXMgYSBwcm9kdWN0aW9uIChwcm90b3R5cGUpIHZlcnNpb24gb2YgdGhlIHNpbXVsYXRpb25cXG4nICtcclxuICAgICctLXJlcG8gOiBUaGUgbmFtZSBvZiB0aGUgcmVwb3NpdG9yeSB0byBkZXBsb3lcXG4nICtcclxuICAgICctLWJyYW5jaCA6IFRoZSByZWxlYXNlIGJyYW5jaCBuYW1lIChlLmcuIFwiMS43XCIpIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGRlcGxveW1lbnRcXG4nICtcclxuICAgICctLWJyYW5kcyA6IEEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYnJhbmQgbmFtZXMgdG8gZGVwbG95XFxuJyArXHJcbiAgICAnLS1ub25pbnRlcmFjdGl2ZSA6IElmIHNwZWNpZmllZCwgcHJvbXB0cyB3aWxsIGJlIHNraXBwZWQuIFNvbWUgcHJvbXB0cyB0aGF0IHNob3VsZCBub3QgYmUgYXV0b21hdGVkIHdpbGwgZmFpbCBvdXRcXG4nICtcclxuICAgICctLW1lc3NhZ2UgOiBBbiBvcHRpb25hbCBtZXNzYWdlIHRoYXQgd2lsbCBiZSBhcHBlbmRlZCBvbiB2ZXJzaW9uLWNoYW5nZSBjb21taXRzLicsXHJcbiAgICB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBwcm9kdWN0aW9uID0gcmVxdWlyZSggJy4vcHJvZHVjdGlvbicgKTtcclxuXHJcbiAgICAgIGFzc2VydCggZ3J1bnQub3B0aW9uKCAncmVwbycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvc2l0b3J5IHdpdGggLS1yZXBvPXt7UkVQT1NJVE9SWX19JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ2JyYW5jaCcgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSBicmFuY2ggd2l0aCAtLWJyYW5jaD17e0JSQU5DSH19JyApO1xyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ2JyYW5kcycgKSwgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYnJhbmRzIChjb21tYS1zZXBhcmF0ZWQpIHdpdGggLS1icmFuZHM9e3tCUkFORFN9fScgKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcG8gPSBncnVudC5vcHRpb24oICdyZXBvJyApO1xyXG4gICAgICBhc3NlcnRJc1ZhbGlkUmVwb05hbWUoIHJlcG8gKTtcclxuXHJcbiAgICAgIGF3YWl0IHByb2R1Y3Rpb24oIHJlcG8sIGdydW50Lm9wdGlvbiggJ2JyYW5jaCcgKSwgZ3J1bnQub3B0aW9uKCAnYnJhbmRzJyApLnNwbGl0KCAnLCcgKSwgbm9uaW50ZXJhY3RpdmUsIGdydW50Lm9wdGlvbiggJ21lc3NhZ2UnICkgKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdkZXBsb3ktZGVjYWYnLFxyXG4gICAgJ0RlcGxveXMgYSBkZWNhZiB2ZXJzaW9uIG9mIHRoZSBzaW11bGF0aW9uXFxuJyArXHJcbiAgICAnLS1wcm9qZWN0IDogVGhlIG5hbWUgb2YgdGhlIHByb2plY3QgdG8gZGVwbG95JyxcclxuICAgIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRlcGxveURlY2FmID0gcmVxdWlyZSggJy4vZGVjYWYvZGVwbG95RGVjYWYnICk7XHJcblxyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ3Byb2plY3QnICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcHJvamVjdD17e1BST0pFQ1R9fScgKTtcclxuICAgICAgYXNzZXJ0KCBncnVudC5vcHRpb24oICdkZXYnICkgfHwgZ3J1bnQub3B0aW9uKCAncHJvZHVjdGlvbicgKSwgJ1JlcXVpcmVzIGF0IGxlYXN0IG9uZSBvZiAtLWRldiBvciAtLXByb2R1Y3Rpb24nICk7XHJcbiAgICAgIGF3YWl0IGRlcGxveURlY2FmKCBncnVudC5vcHRpb24oICdwcm9qZWN0JyApLCAhIWdydW50Lm9wdGlvbiggJ2RldicgKSwgISFncnVudC5vcHRpb24oICdwcm9kdWN0aW9uJyApICk7XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnYnVpbGQtZGVjYWYnLFxyXG4gICAgJ0J1aWxkcyBhIGRlY2FmIHZlcnNpb24gb2YgdGhlIHNpbXVsYXRpb25cXG4nICtcclxuICAgICctLXByb2plY3QgOiBUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCB0byBkZXBsb3knLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgYnVpbGREZWNhZiA9IHJlcXVpcmUoICcuL2RlY2FmL2J1aWxkRGVjYWYnICk7XHJcblxyXG4gICAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ3Byb2plY3QnICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgcmVwb3NpdG9yeSB3aXRoIC0tcHJvamVjdD17e1BST0pFQ1R9fScgKTtcclxuICAgICAgYXdhaXQgYnVpbGREZWNhZiggZ3J1bnQub3B0aW9uKCAncHJvamVjdCcgKSwgZ3J1bnQub3B0aW9uKCAncHJlbG9hZFJlc291cmNlcycgKSApO1xyXG4gICAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ2NyZWF0ZS1zaW0nLFxyXG4gICAgJ0NyZWF0ZXMgYSBzaW0gYmFzZWQgb24gdGhlIHNpbXVsYS1yYXNhIHRlbXBsYXRlLlxcbicgK1xyXG4gICAgJy0tcmVwbz1cInN0cmluZ1wiIDogdGhlIHJlcG9zaXRvcnkgbmFtZVxcbicgK1xyXG4gICAgJy0tYXV0aG9yPVwic3RyaW5nXCIgOiB0aGUgYXV0aG9yIG5hbWVcXG4nICtcclxuICAgICctLXRpdGxlPVwic3RyaW5nXCIgOiAob3B0aW9uYWwpIHRoZSBzaW11bGF0aW9uIHRpdGxlXFxuJyArXHJcbiAgICAnLS1jbGVhbj10cnVlIDogKG9wdGlvbmFsKSBkZWxldGVzIHRoZSByZXBvc2l0b3J5IGRpcmVjdG9yeSBpZiBpdCBleGlzdHMnLFxyXG4gICAgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgY3JlYXRlU2ltID0gcmVxdWlyZSggJy4vY3JlYXRlU2ltJyApO1xyXG5cclxuICAgICAgY29uc3QgcmVwbyA9IGdydW50Lm9wdGlvbiggJ3JlcG8nICk7XHJcbiAgICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgICAgY29uc3QgYXV0aG9yID0gZ3J1bnQub3B0aW9uKCAnYXV0aG9yJyApO1xyXG4gICAgICBjb25zdCB0aXRsZSA9IGdydW50Lm9wdGlvbiggJ3RpdGxlJyApO1xyXG4gICAgICBjb25zdCBjbGVhbiA9IGdydW50Lm9wdGlvbiggJ2NsZWFuJyApO1xyXG5cclxuICAgICAgYXNzZXJ0KCByZXBvLCAnUmVxdWlyZXMgc3BlY2lmeWluZyBhIHJlcG9zaXRvcnkgbmFtZSB3aXRoIC0tcmVwbz17e1JFUE99fScgKTtcclxuICAgICAgYXNzZXJ0KCBncnVudC5vcHRpb24oICdhdXRob3InICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgYXV0aG9yIHdpdGggLS1hdXRob3I9e3tBVVRIT1J9fScgKTtcclxuXHJcbiAgICAgIGF3YWl0IGNyZWF0ZVNpbSggcmVwbywgYXV0aG9yLCB7IHRpdGxlOiB0aXRsZSwgY2xlYW46IGNsZWFuIH0gKTtcclxuICAgIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdsaW50LWV2ZXJ5dGhpbmcnLCAnbGludCBhbGwganMgZmlsZXMgZm9yIGFsbCByZXBvcycsIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBnZXREYXRhRmlsZSA9IHJlcXVpcmUoICcuLi9jb21tb24vZ2V0RGF0YUZpbGUnICk7XHJcblxyXG4gICAgLy8gLS1kaXNhYmxlLWVzbGludC1jYWNoZSBkaXNhYmxlcyB0aGUgY2FjaGUsIHVzZWZ1bCBmb3IgZGV2ZWxvcGluZyBydWxlc1xyXG4gICAgY29uc3QgY2FjaGUgPSAhZ3J1bnQub3B0aW9uKCAnZGlzYWJsZS1lc2xpbnQtY2FjaGUnICk7XHJcbiAgICBjb25zdCBhY3RpdmVSZXBvcyA9IGdldERhdGFGaWxlKCAnYWN0aXZlLXJlcG9zJyApO1xyXG4gICAgY29uc3QgZml4ID0gZ3J1bnQub3B0aW9uKCAnZml4JyApO1xyXG4gICAgY29uc3QgZm9ybWF0ID0gZ3J1bnQub3B0aW9uKCAnZm9ybWF0JyApO1xyXG4gICAgY29uc3QgY2hpcEF3YXkgPSBncnVudC5vcHRpb24oICdjaGlwLWF3YXknICk7XHJcbiAgICBjb25zdCBkaXNhYmxlV2l0aENvbW1lbnQgPSBncnVudC5vcHRpb24oICdkaXNhYmxlLXdpdGgtY29tbWVudCcgKTtcclxuICAgIGNvbnN0IHNob3dQcm9ncmVzc0JhciA9ICFncnVudC5vcHRpb24oICdoaWRlLXByb2dyZXNzLWJhcicgKTtcclxuXHJcbiAgICAvLyBEb24ndCBhbHdheXMgcmVxdWlyZSB0aGlzLCBhcyB3ZSBtYXkgaGF2ZSBhbiBvbGRlciBjaGlwcGVyIGNoZWNrZWQgb3V0LiAgQWxzbyBtYWtlIHN1cmUgaXQgaXMgdGhlIHByb21pc2UtYmFzZWQgbGludC5cclxuICAgIGNvbnN0IGxpbnQgPSByZXF1aXJlKCAnLi4vLi4vLi4vY2hpcHBlci9qcy9ncnVudC9saW50JyApO1xyXG4gICAgaWYgKCBsaW50LmNoaXBwZXJBUElWZXJzaW9uID09PSAncHJvbWlzZXNQZXJSZXBvMScgKSB7XHJcbiAgICAgIGNvbnN0IGxpbnRSZXR1cm5WYWx1ZSA9IGF3YWl0IGxpbnQoIGFjdGl2ZVJlcG9zLCB7XHJcbiAgICAgICAgY2FjaGU6IGNhY2hlLFxyXG4gICAgICAgIGZpeDogZml4LFxyXG4gICAgICAgIGZvcm1hdDogZm9ybWF0LFxyXG4gICAgICAgIGNoaXBBd2F5OiBjaGlwQXdheSxcclxuICAgICAgICBkaXNhYmxlV2l0aENvbW1lbnQ6IGRpc2FibGVXaXRoQ29tbWVudCxcclxuICAgICAgICBzaG93UHJvZ3Jlc3NCYXI6IHNob3dQcm9ncmVzc0JhclxyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICAvLyBPdXRwdXQgcmVzdWx0cyBvbiBlcnJvcnMuXHJcbiAgICAgIGlmICggIWxpbnRSZXR1cm5WYWx1ZS5vayApIHtcclxuICAgICAgICBncnVudC5mYWlsLmZhdGFsKCAnTGludCBmYWlsZWQnICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnZ2VuZXJhdGUtZGF0YScsICdHZW5lcmF0ZXMgdGhlIGxpc3RzIHVuZGVyIHBlcmVubmlhbC9kYXRhLywgYW5kIGlmIHRoZXJlIHdlcmUgY2hhbmdlcywgd2lsbCBjb21taXQgYW5kIHB1c2guJywgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IGdlbmVyYXRlRGF0YSA9IHJlcXVpcmUoICcuL2dlbmVyYXRlRGF0YScgKTtcclxuICAgIGF3YWl0IGdlbmVyYXRlRGF0YSggZ3J1bnQgKTtcclxuICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnY2xvbmUtbWlzc2luZy1yZXBvcycsICdDbG9uZXMgbWlzc2luZyByZXBvcycsIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBjbG9uZU1pc3NpbmdSZXBvcyA9IHJlcXVpcmUoICcuLi9jb21tb24vY2xvbmVNaXNzaW5nUmVwb3MnICk7XHJcblxyXG4gICAgYXdhaXQgY2xvbmVNaXNzaW5nUmVwb3MoKTtcclxuICB9ICkgKTtcclxuXHJcbiAgZ3J1bnQucmVnaXN0ZXJUYXNrKCAnbWFpbnRlbmFuY2UnLCAnU3RhcnRzIGEgbWFpbnRlbmFuY2UgUkVQTCcsIHdyYXBUYXNrKCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBNYWludGVuYW5jZSA9IHJlcXVpcmUoICcuLi9jb21tb24vTWFpbnRlbmFuY2UnICk7XHJcblxyXG4gICAgYXdhaXQgTWFpbnRlbmFuY2Uuc3RhcnRSRVBMKCk7XHJcbiAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ21haW50ZW5hbmNlLWNoZWNrLWJyYW5jaC1zdGF0dXMnLCAnUmVwb3J0cyBvdXQgb24gcmVsZWFzZSBicmFuY2ggc3RhdHVzZXMnLCB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgTWFpbnRlbmFuY2UgPSByZXF1aXJlKCAnLi4vY29tbW9uL01haW50ZW5hbmNlJyApO1xyXG4gICAgY29uc3Qgd2luc3RvbiA9IHJlcXVpcmUoICd3aW5zdG9uJyApO1xyXG5cclxuICAgIHdpbnN0b24uZGVmYXVsdC50cmFuc3BvcnRzLmNvbnNvbGUubGV2ZWwgPSAnZXJyb3InO1xyXG5cclxuICAgIGF3YWl0IE1haW50ZW5hbmNlLmNoZWNrQnJhbmNoU3RhdHVzKCk7XHJcbiAgfSApICk7XHJcblxyXG4gIGdydW50LnJlZ2lzdGVyVGFzayggJ21haW50ZW5hbmNlLWxpc3QnLCAnTGlzdHMgb3V0IHRoZSBjdXJyZW50IG1haW50ZW5hbmNlIHByb2Nlc3Mgc3RhdGUnLCB3cmFwVGFzayggYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgTWFpbnRlbmFuY2UgPSByZXF1aXJlKCAnLi4vY29tbW9uL01haW50ZW5hbmNlJyApO1xyXG4gICAgYXdhaXQgTWFpbnRlbmFuY2UubGlzdCgpO1xyXG4gIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdtYWludGVuYW5jZS1jcmVhdGUtcGF0Y2gnLCAnQWRkcyBhIHBhdGNoIHRvIHRoZSBtYWludGVuYW5jZSBwcm9jZXNzJywgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IE1haW50ZW5hbmNlID0gcmVxdWlyZSggJy4uL2NvbW1vbi9NYWludGVuYW5jZScgKTtcclxuXHJcbiAgICBjb25zdCByZXBvID0gZ3J1bnQub3B0aW9uKCAncmVwbycgKTtcclxuICAgIGFzc2VydElzVmFsaWRSZXBvTmFtZSggcmVwbyApO1xyXG5cclxuICAgIGNvbnN0IG1lc3NhZ2UgPSBncnVudC5vcHRpb24oICdtZXNzYWdlJyApO1xyXG5cclxuICAgIGFzc2VydCggcmVwbywgJ1JlcXVpcmVzIHNwZWNpZnlpbmcgYSByZXBvIHRoYXQgd2lsbCBuZWVkIHRvIGJlIHBhdGNoZWQgd2l0aCAtLXJlcG89e3tSRVBPfX0nICk7XHJcbiAgICBhc3NlcnQoIGdydW50Lm9wdGlvbiggJ21lc3NhZ2UnICksICdSZXF1aXJlcyBzcGVjaWZ5aW5nIGEgbWVzc2FnZSAoaW5jbHVkZWQgd2l0aCBjb21taXRzKSB3aXRoIC0tbWVzc2FnZT17e01FU1NBR0V9fScgKTtcclxuXHJcbiAgICBhd2FpdCBNYWludGVuYW5jZS5jcmVhdGVQYXRjaCggcmVwbywgbWVzc2FnZSApO1xyXG4gIH0gKSApO1xyXG5cclxuICBncnVudC5yZWdpc3RlclRhc2soICdyZW9wZW4taXNzdWVzLWZyb20tdG9kb3MnLCAnSWYgdGhlcmUgaXMgYSBUT0RPIGluIHRoZSBwcm9qZWN0IHBvaW50aW5nIHRvIGEgY2xvc2VkIGlzc3VlLCByZW9wZW4gaXQuJywgd3JhcFRhc2soIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHJlb3Blbklzc3Vlc0Zyb21UT0RPcyA9IHJlcXVpcmUoICcuL3Jlb3Blbklzc3Vlc0Zyb21UT0RPcycgKTtcclxuICAgIGF3YWl0IHJlb3Blbklzc3Vlc0Zyb21UT0RPcygpO1xyXG4gIH0gKSApO1xyXG59O1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLHFCQUFxQixHQUFHQyxPQUFPLENBQUUsaUNBQWtDLENBQUM7QUFDMUUsTUFBTUMsTUFBTSxHQUFHRCxPQUFPLENBQUUsUUFBUyxDQUFDO0FBQ2xDLE1BQU1FLENBQUMsR0FBR0YsT0FBTyxDQUFFLFFBQVMsQ0FBQztBQUM3QkEsT0FBTyxDQUFFLG9CQUFxQixDQUFDO0FBQy9COztBQUVBRyxNQUFNLENBQUNDLE9BQU8sR0FBRyxVQUFVQyxLQUFLLEVBQUc7RUFFakMsSUFBS0EsS0FBSyxDQUFDQyxNQUFNLENBQUUsT0FBUSxDQUFDLEVBQUc7SUFDN0IsTUFBTUMsT0FBTyxHQUFHUCxPQUFPLENBQUUsU0FBVSxDQUFDO0lBRXBDTyxPQUFPLENBQUNDLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDQyxPQUFPLENBQUNDLEtBQUssR0FBRyxPQUFPO0VBQ3BEOztFQUVBO0VBQ0EsTUFBTUMsY0FBYyxHQUFHLENBQUMsQ0FBQ1AsS0FBSyxDQUFDQyxNQUFNLENBQUUsZ0JBQWlCLENBQUM7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