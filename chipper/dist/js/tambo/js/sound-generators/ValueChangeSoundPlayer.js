// Copyright 2022-2023, University of Colorado Boulder

/**
 * ValueChangeSoundPlayer plays sounds based on changes to a numerical value.  It was initially created for supporting
 * sound generation in PhET's Slider class and variations thereof, but it may have other applications.
 *
 * This class does not extend SoundGenerator and is not itself added to the sound manager.  It is instead a player of
 * a set of sounds, each of which should be registered with the sound manager elsewhere.
 *
 * Because the sounds should only be produced when users directly change a value, and not in side-effect-ish situations
 * (such as a reset), this class does not monitor a Property.  Instead, it provides methods that can be used to evaluate
 * changes in a value and potentially play sounds (or not, if the change doesn't warrant sound generation), and it is
 * the client's responsibility to know the situations in which these methods should be called.  Often these methods will
 * be called in drag handlers and other code that handles user input.
 *
 * @author John Blanco (PhET Interactive Simulations)
 */

import Range from '../../../dot/js/Range.js';
import Utils from '../../../dot/js/Utils.js';
import optionize from '../../../phet-core/js/optionize.js';
import generalBoundaryBoop_mp3 from '../../sounds/generalBoundaryBoop_mp3.js';
import generalSoftClick_mp3 from '../../sounds/generalSoftClick_mp3.js';
import phetAudioContext from '../phetAudioContext.js';
import generalBoundaryBoopSoundPlayer from '../shared-sound-players/generalBoundaryBoopSoundPlayer.js';
import generalSoftClickSoundPlayer from '../shared-sound-players/generalSoftClickSoundPlayer.js';
import nullSoundPlayer from '../shared-sound-players/nullSoundPlayer.js';
import tambo from '../tambo.js';
import SoundClip from './SoundClip.js';
import SoundClipPlayer from './SoundClipPlayer.js';

// constants
const DEFAULT_NUMBER_OF_MIDDLE_THRESHOLDS = 5; // fairly arbitrary
const DEFAULT_MIN_SOUND_PLAYER = new SoundClipPlayer(generalBoundaryBoop_mp3, {
  soundClipOptions: {
    initialOutputLevel: 0.2,
    initialPlaybackRate: 1 / Math.pow(2, 1 / 6) // a major second lower
  },

  soundManagerOptions: {
    categoryName: 'user-interface'
  }
});
const DEFAULT_MIDDLE_MOVING_DOWN_SOUND_PLAYER = new SoundClipPlayer(generalSoftClick_mp3, {
  soundClipOptions: {
    initialOutputLevel: 0.2,
    initialPlaybackRate: 1 / Math.pow(2, 1 / 6) // a major second lower
  },

  soundManagerOptions: {
    categoryName: 'user-interface'
  }
});

// Define a default constraint function.  See the docs for the associated option for more info.  The interval value used
// here was empirically determined.
const DEFAULT_VALUE_CONSTRAINT = value => Utils.roundToInterval(value, 0.000000001);

// A "no-op" function for mapping pitch values.  Always returns one, which signifies no change to the playback rate.
const NO_PLAYBACK_RATE_CHANGE = () => 1;

// A function for a stubbed sound player, see usage.
const STUB_SOUND_PLAYER_FUNCTION = () => {
  assert && assert(false, 'Code error: This is a stubbed function and should never be invoked.');
};
class ValueChangeSoundPlayer {
  // The distance between the threshold values at which sounds will be played.

  // range of values that this should expect to handle

  // sound player for movement in the middle of the range (i.e. not at min or max) and moving up

  // sound player for movement in the middle of the range (i.e. not at min or max) and moving down

  // playback rate mapper for middle sounds and upward value changes

  // playback rate mapper for middle sounds and downward value changes

  // Sound players for the min and max values.  If nothing is provided a default will be used.  If the flag
  // USE_MIDDLE_SOUND is provided, the sound player for the middle range will be used.
  // min time between playing one middle sound and the next
  // function to constrain the values used for thresholds and comparisons
  // time of most recently played middle sound, used to moderate the rate at which these sounds are played
  /**
   * @param valueRange - the range of values expected and over which sounds will be played
   * @param [providedOptions]
   */
  constructor(valueRange, providedOptions) {
    const options = optionize()({
      middleMovingUpSoundPlayer: generalSoftClickSoundPlayer,
      middleMovingDownSoundPlayer: DEFAULT_MIDDLE_MOVING_DOWN_SOUND_PLAYER,
      middleMovingUpPlaybackRateMapper: NO_PLAYBACK_RATE_CHANGE,
      middleMovingDownPlaybackRateMapper: NO_PLAYBACK_RATE_CHANGE,
      numberOfMiddleThresholds: null,
      interThresholdDelta: null,
      constrainValue: DEFAULT_VALUE_CONSTRAINT,
      minSoundPlayer: DEFAULT_MIN_SOUND_PLAYER,
      maxSoundPlayer: generalBoundaryBoopSoundPlayer,
      minimumInterMiddleSoundTime: 0.035 // empirically determined
    }, providedOptions);

    // option validity checks
    assert && assert(options.minimumInterMiddleSoundTime >= 0 && options.minimumInterMiddleSoundTime < 1, `unreasonable value for minimumInterMiddleSoundTime: ${options.minimumInterMiddleSoundTime}`);
    assert && assert(options.numberOfMiddleThresholds === null || options.interThresholdDelta === null, 'cannot specify both the number of middle thresholds and the inter-threshold delta');
    assert && assert(options.numberOfMiddleThresholds === null || Number.isInteger(options.numberOfMiddleThresholds), 'numberOfMiddleThresholds must be an integer if specified');

    // If a playback rate mapper is provided for a middle threshold sound, the provided sound player must support
    // setting a different playback rate.  It should NOT be a SoundClipPlayer, since those are designed to be shared, so
    // the playback rate should never be changed.  The following assertions are intended to verify that these options
    // are set in a compatible way.
    assert && assert(options.middleMovingUpPlaybackRateMapper === NO_PLAYBACK_RATE_CHANGE || options.middleMovingUpSoundPlayer instanceof SoundClip, 'a sound player that supports playback rate changes is required when a playback rate mapper is used');
    assert && assert(options.middleMovingDownPlaybackRateMapper === NO_PLAYBACK_RATE_CHANGE || options.middleMovingDownSoundPlayer instanceof SoundClip, 'a sound player that supports playback rate changes is required when a playback rate mapper is used');

    // Set default number of middle thresholds if necessary.
    if (options.numberOfMiddleThresholds === null && options.interThresholdDelta === null) {
      options.numberOfMiddleThresholds = DEFAULT_NUMBER_OF_MIDDLE_THRESHOLDS;
    }
    if (options.numberOfMiddleThresholds !== null) {
      this.interThresholdDistance = valueRange.getLength() / (options.numberOfMiddleThresholds + 1);
    } else if (options.interThresholdDelta !== null) {
      this.interThresholdDistance = options.interThresholdDelta;
    } else {
      assert && assert(false, 'should never get here, it is a logic error if we do');
      this.interThresholdDistance = valueRange.getLength() / 2; // avoid uninitialized compile-time error
    }

    this.valueRange = valueRange;
    this.middleMovingUpSoundPlayer = options.middleMovingUpSoundPlayer;
    this.middleMovingDownSoundPlayer = options.middleMovingDownSoundPlayer;
    this.middleMovingUpPlaybackRateMapper = options.middleMovingUpPlaybackRateMapper;
    this.middleMovingDownPlaybackRateMapper = options.middleMovingDownPlaybackRateMapper;
    this.minSoundPlayer = options.minSoundPlayer;
    this.maxSoundPlayer = options.maxSoundPlayer;
    this.minimumInterMiddleSoundTime = options.minimumInterMiddleSoundTime;
    this.timeOfMostRecentMiddleSound = 0;
    this.constrainValue = options.constrainValue;
  }

  /**
   * Check if the new value has reached or crossed a threshold and, if so, play the appropriate sound.  If no threshold
   * has been reached or crossed and the new value is not at the min or max, no sound will be played.
   */
  playSoundIfThresholdReached(newValue, oldValue) {
    if (newValue !== oldValue) {
      const constrainedNewValue = this.constrainValue(newValue);
      const constrainedOldValue = this.constrainValue(oldValue);
      const oldValueSurroundingThresholds = this.getSurroundingThresholds(constrainedOldValue);
      const newValueSurroundingThresholds = this.getSurroundingThresholds(constrainedNewValue);
      const thresholdCrossed = oldValueSurroundingThresholds.length === 1 && newValueSurroundingThresholds.length === 1 && Math.abs(oldValueSurroundingThresholds[0] - newValueSurroundingThresholds[0]) > this.interThresholdDistance || oldValueSurroundingThresholds.length === 1 && newValueSurroundingThresholds.length === 2 && oldValueSurroundingThresholds[0] !== newValueSurroundingThresholds[0] && oldValueSurroundingThresholds[0] !== newValueSurroundingThresholds[1] || oldValueSurroundingThresholds.length === 2 && newValueSurroundingThresholds.length === 1 && newValueSurroundingThresholds[0] !== oldValueSurroundingThresholds[0] && newValueSurroundingThresholds[0] !== oldValueSurroundingThresholds[1] || oldValueSurroundingThresholds.length === 2 && newValueSurroundingThresholds.length === 2 && newValueSurroundingThresholds[0] !== oldValueSurroundingThresholds[0];
      const thresholdReached = newValueSurroundingThresholds.length === 1 && (oldValueSurroundingThresholds.length === 2 || oldValueSurroundingThresholds[0] !== newValueSurroundingThresholds[0]);
      if (thresholdCrossed || thresholdReached || constrainedNewValue === this.valueRange.min || constrainedNewValue === this.valueRange.max) {
        this.playSoundForValueChange(newValue, oldValue);
      }
    }
  }

  /**
   * Play the appropriate sound for the change in value indicated by the provided new and old values.  This will almost
   * always play a sound, but there are some exceptions.  See the code and comments for details.
   */
  playSoundForValueChange(newValue, oldValue) {
    const constrainedNewValue = this.constrainValue(newValue);
    const constrainedOldValue = this.constrainValue(oldValue);
    if (constrainedNewValue !== constrainedOldValue || oldValue !== newValue && (newValue === this.valueRange.min || newValue === this.valueRange.max)) {
      if (newValue === this.valueRange.min && this.minSoundPlayer !== ValueChangeSoundPlayer.USE_MIDDLE_SOUND) {
        this.minSoundPlayer.play();
      } else if (newValue === this.valueRange.max && this.maxSoundPlayer !== ValueChangeSoundPlayer.USE_MIDDLE_SOUND) {
        this.maxSoundPlayer.play();
      } else {
        // Play a middle-range sound, but only if enough time has passed since the last one was played.
        const now = phetAudioContext.currentTime;
        if (now - this.timeOfMostRecentMiddleSound > this.minimumInterMiddleSoundTime) {
          let playbackRateMapper;
          let soundPlayer;
          if (constrainedNewValue > constrainedOldValue) {
            playbackRateMapper = this.middleMovingUpPlaybackRateMapper;
            soundPlayer = this.middleMovingUpSoundPlayer;
          } else {
            playbackRateMapper = this.middleMovingUpPlaybackRateMapper;
            soundPlayer = this.middleMovingDownSoundPlayer;
          }
          if (playbackRateMapper !== NO_PLAYBACK_RATE_CHANGE) {
            // Adjust the playback rate based on the provided new value.  It should be safe to cast this here because of
            // the assertion checks that occur during construction.
            soundPlayer.setPlaybackRate(playbackRateMapper(newValue));
          }
          soundPlayer.play();
          this.timeOfMostRecentMiddleSound = now;
        }
      }
    }
  }

  /**
   * Get an array that contains the next lowest and next highest thresholds for the provided value.  If the provided
   * value is exactly equal to a threshold, only the single threshold value is returned in the array.
   */
  getSurroundingThresholds(value) {
    // A note to future maintainers: JavaScript's floating point implementation was causing all manner of problems with
    // this method.  For instance, when the inter-threshold distance was 0.1 and the provided value was 0.3, JS says
    // that 0.3/0.1 is 2.9999999999999996, so it was tricky to tell that the value was at a threshold and not below it.
    // Therefore, the code below does rounding to intervals that were empirically determined to correct for the floating
    // point problems.  This worked in all test cases, but may not stand the test of time if some unusual slider
    // configurations are needed.  One idea might be to make the rounding interval for this calculation an option to the
    // class, but that felt like overkill at the time of this writing.
    const roundingInterval = 1E-7;
    const segment = Math.floor(Utils.roundToInterval((value - this.valueRange.min) / this.interThresholdDistance, roundingInterval));
    const lowerThreshold = Utils.roundToInterval(segment * this.interThresholdDistance + this.valueRange.min, roundingInterval);
    const thresholdArray = [lowerThreshold];
    if (lowerThreshold !== value) {
      // The provided value wasn't exactly at a threshold.  Since the preceding calculation provided the lower
      // threshold, add the upper one now.
      const upperThreshold = Math.min(Utils.roundToInterval(lowerThreshold + this.interThresholdDistance, roundingInterval), this.valueRange.max);

      // This may seem like an odd test, so here's the story: There are some rare but possible cases where the
      // calculation above doesn't actually yield a higher value due to floating point errors.  When testing in Dec
      // 2022, this was only seen on the Wave Packet Center slider in Fourier Making Waves.  So, only add the upper
      // threshold if it's actually higher than the lower one.  If the upper threshold isn't added, this essentially
      // says that the lower threshold was an exact match for one of the crossing thresholds, which is approximately
      // true and has worked fine in all test cases thus far.
      if (upperThreshold > lowerThreshold) {
        thresholdArray.push(upperThreshold);
      }
    }
    return thresholdArray;
  }

  /**
   * A static instance that makes no sound.  This is generally used as an option value to turn off sound generation.
   */
  static NO_SOUND = new ValueChangeSoundPlayer(new Range(0, 1), {
    middleMovingUpSoundPlayer: nullSoundPlayer,
    minSoundPlayer: nullSoundPlayer,
    maxSoundPlayer: nullSoundPlayer
  });

  /**
   * A static TSoundPlayer instance that is intended to be used as a flag for the min and max sound players to
   * indicate that the middle sound player should be used.
   */
  static USE_MIDDLE_SOUND = {
    play: STUB_SOUND_PLAYER_FUNCTION,
    stop: STUB_SOUND_PLAYER_FUNCTION
  };
}
tambo.register('ValueChangeSoundPlayer', ValueChangeSoundPlayer);
export default ValueChangeSoundPlayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSYW5nZSIsIlV0aWxzIiwib3B0aW9uaXplIiwiZ2VuZXJhbEJvdW5kYXJ5Qm9vcF9tcDMiLCJnZW5lcmFsU29mdENsaWNrX21wMyIsInBoZXRBdWRpb0NvbnRleHQiLCJnZW5lcmFsQm91bmRhcnlCb29wU291bmRQbGF5ZXIiLCJnZW5lcmFsU29mdENsaWNrU291bmRQbGF5ZXIiLCJudWxsU291bmRQbGF5ZXIiLCJ0YW1ibyIsIlNvdW5kQ2xpcCIsIlNvdW5kQ2xpcFBsYXllciIsIkRFRkFVTFRfTlVNQkVSX09GX01JRERMRV9USFJFU0hPTERTIiwiREVGQVVMVF9NSU5fU09VTkRfUExBWUVSIiwic291bmRDbGlwT3B0aW9ucyIsImluaXRpYWxPdXRwdXRMZXZlbCIsImluaXRpYWxQbGF5YmFja1JhdGUiLCJNYXRoIiwicG93Iiwic291bmRNYW5hZ2VyT3B0aW9ucyIsImNhdGVnb3J5TmFtZSIsIkRFRkFVTFRfTUlERExFX01PVklOR19ET1dOX1NPVU5EX1BMQVlFUiIsIkRFRkFVTFRfVkFMVUVfQ09OU1RSQUlOVCIsInZhbHVlIiwicm91bmRUb0ludGVydmFsIiwiTk9fUExBWUJBQ0tfUkFURV9DSEFOR0UiLCJTVFVCX1NPVU5EX1BMQVlFUl9GVU5DVElPTiIsImFzc2VydCIsIlZhbHVlQ2hhbmdlU291bmRQbGF5ZXIiLCJjb25zdHJ1Y3RvciIsInZhbHVlUmFuZ2UiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwibWlkZGxlTW92aW5nVXBTb3VuZFBsYXllciIsIm1pZGRsZU1vdmluZ0Rvd25Tb3VuZFBsYXllciIsIm1pZGRsZU1vdmluZ1VwUGxheWJhY2tSYXRlTWFwcGVyIiwibWlkZGxlTW92aW5nRG93blBsYXliYWNrUmF0ZU1hcHBlciIsIm51bWJlck9mTWlkZGxlVGhyZXNob2xkcyIsImludGVyVGhyZXNob2xkRGVsdGEiLCJjb25zdHJhaW5WYWx1ZSIsIm1pblNvdW5kUGxheWVyIiwibWF4U291bmRQbGF5ZXIiLCJtaW5pbXVtSW50ZXJNaWRkbGVTb3VuZFRpbWUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJpbnRlclRocmVzaG9sZERpc3RhbmNlIiwiZ2V0TGVuZ3RoIiwidGltZU9mTW9zdFJlY2VudE1pZGRsZVNvdW5kIiwicGxheVNvdW5kSWZUaHJlc2hvbGRSZWFjaGVkIiwibmV3VmFsdWUiLCJvbGRWYWx1ZSIsImNvbnN0cmFpbmVkTmV3VmFsdWUiLCJjb25zdHJhaW5lZE9sZFZhbHVlIiwib2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMiLCJnZXRTdXJyb3VuZGluZ1RocmVzaG9sZHMiLCJuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcyIsInRocmVzaG9sZENyb3NzZWQiLCJsZW5ndGgiLCJhYnMiLCJ0aHJlc2hvbGRSZWFjaGVkIiwibWluIiwibWF4IiwicGxheVNvdW5kRm9yVmFsdWVDaGFuZ2UiLCJVU0VfTUlERExFX1NPVU5EIiwicGxheSIsIm5vdyIsImN1cnJlbnRUaW1lIiwicGxheWJhY2tSYXRlTWFwcGVyIiwic291bmRQbGF5ZXIiLCJzZXRQbGF5YmFja1JhdGUiLCJyb3VuZGluZ0ludGVydmFsIiwic2VnbWVudCIsImZsb29yIiwibG93ZXJUaHJlc2hvbGQiLCJ0aHJlc2hvbGRBcnJheSIsInVwcGVyVGhyZXNob2xkIiwicHVzaCIsIk5PX1NPVU5EIiwic3RvcCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiVmFsdWVDaGFuZ2VTb3VuZFBsYXllci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMi0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyIHBsYXlzIHNvdW5kcyBiYXNlZCBvbiBjaGFuZ2VzIHRvIGEgbnVtZXJpY2FsIHZhbHVlLiAgSXQgd2FzIGluaXRpYWxseSBjcmVhdGVkIGZvciBzdXBwb3J0aW5nXHJcbiAqIHNvdW5kIGdlbmVyYXRpb24gaW4gUGhFVCdzIFNsaWRlciBjbGFzcyBhbmQgdmFyaWF0aW9ucyB0aGVyZW9mLCBidXQgaXQgbWF5IGhhdmUgb3RoZXIgYXBwbGljYXRpb25zLlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIGRvZXMgbm90IGV4dGVuZCBTb3VuZEdlbmVyYXRvciBhbmQgaXMgbm90IGl0c2VsZiBhZGRlZCB0byB0aGUgc291bmQgbWFuYWdlci4gIEl0IGlzIGluc3RlYWQgYSBwbGF5ZXIgb2ZcclxuICogYSBzZXQgb2Ygc291bmRzLCBlYWNoIG9mIHdoaWNoIHNob3VsZCBiZSByZWdpc3RlcmVkIHdpdGggdGhlIHNvdW5kIG1hbmFnZXIgZWxzZXdoZXJlLlxyXG4gKlxyXG4gKiBCZWNhdXNlIHRoZSBzb3VuZHMgc2hvdWxkIG9ubHkgYmUgcHJvZHVjZWQgd2hlbiB1c2VycyBkaXJlY3RseSBjaGFuZ2UgYSB2YWx1ZSwgYW5kIG5vdCBpbiBzaWRlLWVmZmVjdC1pc2ggc2l0dWF0aW9uc1xyXG4gKiAoc3VjaCBhcyBhIHJlc2V0KSwgdGhpcyBjbGFzcyBkb2VzIG5vdCBtb25pdG9yIGEgUHJvcGVydHkuICBJbnN0ZWFkLCBpdCBwcm92aWRlcyBtZXRob2RzIHRoYXQgY2FuIGJlIHVzZWQgdG8gZXZhbHVhdGVcclxuICogY2hhbmdlcyBpbiBhIHZhbHVlIGFuZCBwb3RlbnRpYWxseSBwbGF5IHNvdW5kcyAob3Igbm90LCBpZiB0aGUgY2hhbmdlIGRvZXNuJ3Qgd2FycmFudCBzb3VuZCBnZW5lcmF0aW9uKSwgYW5kIGl0IGlzXHJcbiAqIHRoZSBjbGllbnQncyByZXNwb25zaWJpbGl0eSB0byBrbm93IHRoZSBzaXR1YXRpb25zIGluIHdoaWNoIHRoZXNlIG1ldGhvZHMgc2hvdWxkIGJlIGNhbGxlZC4gIE9mdGVuIHRoZXNlIG1ldGhvZHMgd2lsbFxyXG4gKiBiZSBjYWxsZWQgaW4gZHJhZyBoYW5kbGVycyBhbmQgb3RoZXIgY29kZSB0aGF0IGhhbmRsZXMgdXNlciBpbnB1dC5cclxuICpcclxuICogQGF1dGhvciBKb2huIEJsYW5jbyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi4vLi4vLi4vZG90L2pzL1JhbmdlLmpzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBnZW5lcmFsQm91bmRhcnlCb29wX21wMyBmcm9tICcuLi8uLi9zb3VuZHMvZ2VuZXJhbEJvdW5kYXJ5Qm9vcF9tcDMuanMnO1xyXG5pbXBvcnQgZ2VuZXJhbFNvZnRDbGlja19tcDMgZnJvbSAnLi4vLi4vc291bmRzL2dlbmVyYWxTb2Z0Q2xpY2tfbXAzLmpzJztcclxuaW1wb3J0IFRTb3VuZFBsYXllciBmcm9tICcuLi9UU291bmRQbGF5ZXIuanMnO1xyXG5pbXBvcnQgcGhldEF1ZGlvQ29udGV4dCBmcm9tICcuLi9waGV0QXVkaW9Db250ZXh0LmpzJztcclxuaW1wb3J0IGdlbmVyYWxCb3VuZGFyeUJvb3BTb3VuZFBsYXllciBmcm9tICcuLi9zaGFyZWQtc291bmQtcGxheWVycy9nZW5lcmFsQm91bmRhcnlCb29wU291bmRQbGF5ZXIuanMnO1xyXG5pbXBvcnQgZ2VuZXJhbFNvZnRDbGlja1NvdW5kUGxheWVyIGZyb20gJy4uL3NoYXJlZC1zb3VuZC1wbGF5ZXJzL2dlbmVyYWxTb2Z0Q2xpY2tTb3VuZFBsYXllci5qcyc7XHJcbmltcG9ydCBudWxsU291bmRQbGF5ZXIgZnJvbSAnLi4vc2hhcmVkLXNvdW5kLXBsYXllcnMvbnVsbFNvdW5kUGxheWVyLmpzJztcclxuaW1wb3J0IHRhbWJvIGZyb20gJy4uL3RhbWJvLmpzJztcclxuaW1wb3J0IFNvdW5kQ2xpcCBmcm9tICcuL1NvdW5kQ2xpcC5qcyc7XHJcbmltcG9ydCBTb3VuZENsaXBQbGF5ZXIgZnJvbSAnLi9Tb3VuZENsaXBQbGF5ZXIuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IERFRkFVTFRfTlVNQkVSX09GX01JRERMRV9USFJFU0hPTERTID0gNTsgLy8gZmFpcmx5IGFyYml0cmFyeVxyXG5jb25zdCBERUZBVUxUX01JTl9TT1VORF9QTEFZRVIgPSBuZXcgU291bmRDbGlwUGxheWVyKCBnZW5lcmFsQm91bmRhcnlCb29wX21wMywge1xyXG4gIHNvdW5kQ2xpcE9wdGlvbnM6IHtcclxuICAgIGluaXRpYWxPdXRwdXRMZXZlbDogMC4yLFxyXG4gICAgaW5pdGlhbFBsYXliYWNrUmF0ZTogMSAvIE1hdGgucG93KCAyLCAxIC8gNiApIC8vIGEgbWFqb3Igc2Vjb25kIGxvd2VyXHJcbiAgfSxcclxuICBzb3VuZE1hbmFnZXJPcHRpb25zOiB7IGNhdGVnb3J5TmFtZTogJ3VzZXItaW50ZXJmYWNlJyB9XHJcbn0gKTtcclxuY29uc3QgREVGQVVMVF9NSURETEVfTU9WSU5HX0RPV05fU09VTkRfUExBWUVSID0gbmV3IFNvdW5kQ2xpcFBsYXllciggZ2VuZXJhbFNvZnRDbGlja19tcDMsIHtcclxuICBzb3VuZENsaXBPcHRpb25zOiB7XHJcbiAgICBpbml0aWFsT3V0cHV0TGV2ZWw6IDAuMixcclxuICAgIGluaXRpYWxQbGF5YmFja1JhdGU6IDEgLyBNYXRoLnBvdyggMiwgMSAvIDYgKSAvLyBhIG1ham9yIHNlY29uZCBsb3dlclxyXG4gIH0sXHJcbiAgc291bmRNYW5hZ2VyT3B0aW9uczogeyBjYXRlZ29yeU5hbWU6ICd1c2VyLWludGVyZmFjZScgfVxyXG59ICk7XHJcblxyXG4vLyBEZWZpbmUgYSBkZWZhdWx0IGNvbnN0cmFpbnQgZnVuY3Rpb24uICBTZWUgdGhlIGRvY3MgZm9yIHRoZSBhc3NvY2lhdGVkIG9wdGlvbiBmb3IgbW9yZSBpbmZvLiAgVGhlIGludGVydmFsIHZhbHVlIHVzZWRcclxuLy8gaGVyZSB3YXMgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZC5cclxuY29uc3QgREVGQVVMVF9WQUxVRV9DT05TVFJBSU5UID0gKCB2YWx1ZTogbnVtYmVyICkgPT4gVXRpbHMucm91bmRUb0ludGVydmFsKCB2YWx1ZSwgMC4wMDAwMDAwMDEgKTtcclxuXHJcbi8vIEEgXCJuby1vcFwiIGZ1bmN0aW9uIGZvciBtYXBwaW5nIHBpdGNoIHZhbHVlcy4gIEFsd2F5cyByZXR1cm5zIG9uZSwgd2hpY2ggc2lnbmlmaWVzIG5vIGNoYW5nZSB0byB0aGUgcGxheWJhY2sgcmF0ZS5cclxuY29uc3QgTk9fUExBWUJBQ0tfUkFURV9DSEFOR0UgPSAoKSA9PiAxO1xyXG5cclxuLy8gQSBmdW5jdGlvbiBmb3IgYSBzdHViYmVkIHNvdW5kIHBsYXllciwgc2VlIHVzYWdlLlxyXG5jb25zdCBTVFVCX1NPVU5EX1BMQVlFUl9GVU5DVElPTiA9ICgpOiB2b2lkID0+IHtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ0NvZGUgZXJyb3I6IFRoaXMgaXMgYSBzdHViYmVkIGZ1bmN0aW9uIGFuZCBzaG91bGQgbmV2ZXIgYmUgaW52b2tlZC4nICk7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyT3B0aW9ucyA9IHtcclxuXHJcbiAgLy8gVGhlIHNvdW5kIHBsYXllciBmb3IgbW92ZW1lbnQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgcmFuZ2UgaW4gdGhlIHVwIGRpcmVjdGlvbi5cclxuICBtaWRkbGVNb3ZpbmdVcFNvdW5kUGxheWVyPzogVFNvdW5kUGxheWVyIHwgU291bmRDbGlwO1xyXG5cclxuICAvLyBUaGUgc291bmQgcGxheWVyIGZvciBtb3ZlbWVudCBpbiB0aGUgbWlkZGxlIG9mIHRoZSByYW5nZSBpbiB0aGUgZG93biBkaXJlY3Rpb24uXHJcbiAgbWlkZGxlTW92aW5nRG93blNvdW5kUGxheWVyPzogVFNvdW5kUGxheWVyIHwgU291bmRDbGlwO1xyXG5cclxuICAvLyBGdW5jdGlvbnMgdGhhdCwgaWYgcHJvdmlkZWQsIHdpbGwgYWx0ZXIgdGhlIHBsYXliYWNrIHJhdGVzIG9mIHRoZSBtaWRkbGUgc291bmRzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICBtaWRkbGVNb3ZpbmdVcFBsYXliYWNrUmF0ZU1hcHBlcj86ICggdmFsdWU6IG51bWJlciApID0+IG51bWJlcjtcclxuICBtaWRkbGVNb3ZpbmdEb3duUGxheWJhY2tSYXRlTWFwcGVyPzogKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyO1xyXG5cclxuICAvLyBUaGUgbnVtYmVyIG9mIHRocmVzaG9sZHMgdGhhdCwgd2hlbiByZWFjaGVkIG9yIGNyb3NzZWQsIHdpbGwgY2F1c2UgYSBzb3VuZCB0byBiZSBwbGF5ZWQgd2hlbiBjaGVja2luZyB2YWx1ZSBjaGFuZ2VzXHJcbiAgLy8gYWdhaW5zdCB0aHJlc2hvbGRzLiAgSW4gb3RoZXIgd29yZHMsIHRoaXMgaXMgdGhlIG51bWJlciBvZiB0aHJlc2hvbGRzIHRoYXQgZXhpc3QgYmV0d2VlbiB0aGUgbWluIGFuZCBtYXggdmFsdWVzLlxyXG4gIC8vIFRoaXMgYXNzdW1lcyBzeW1tZXRyaWMgc3BhY2luZyBvZiB0aGUgdGhyZXNob2xkcywgYW5kIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggZXhwbGljaXRseSBzZXR0aW5nIG9mIHRoZSAnZGVsdGEnXHJcbiAgLy8gdmFsdWUuXHJcbiAgbnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzPzogbnVtYmVyIHwgbnVsbDtcclxuXHJcbiAgLy8gVGhlIGRlbHRhIHZhbHVlIGJldHdlZW4gdGhyZXNob2xkcyB0aGF0IGFyZSB1c2VkIHRvIGRldGVybWluZSB3aGVuIHNvdW5kcyBhcmUgcGxheWVkLiAgVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSB3YXlcclxuICAvLyB0byBzcGVjaWZ5IHRoZSB0aHJlc2hvbGRzIGFuZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gbnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzIGNhbid0LCB3aGljaCBpcyBnZW5lcmFsbHkgd2hlbiBhXHJcbiAgLy8gdmVyeSBzcGVjaWZpYyBkZWx0YSBpcyByZXF1aXJlZCBhbmQgaGF2aW5nIHBlcmZlY3RseSBldmVuIHRocmVzaG9sZHMgaXNuJ3QgY29tcGxldGVseSBkZXNpcmFibGUuICBOb3RlIHRoYXQgdGhpc1xyXG4gIC8vIGFwcHJvYWNoIHdpbGwgb2Z0ZW4gbGVhZCB0byBhIHNpdHVhdGlvbiB3aGVyZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGFzdCB0aHJlc2hvbGQgYW5kIHRoZSBlbmQgb2YgdGhlIHJhbmdlXHJcbiAgLy8gaXNuJ3QgdGhlIHNhbWUgYXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gYWxsIHRoZSBvdGhlciB0aHJlc2hvbGRzLiAgVGhpcyB3YXMgaW5pdGlhbGx5IGFkZGVkIHRvIHN1cHBvcnRcclxuICAvLyBOdW1iZXJDb250cm9sLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvNjk3LiAgVGhpcyBpcyBpbmNvbXBhdGlibGUgd2l0aCBzcGVjaWZ5aW5nXHJcbiAgLy8gbnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzLlxyXG4gIGludGVyVGhyZXNob2xkRGVsdGE/OiBudW1iZXIgfCBudWxsO1xyXG5cclxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY29uc3RyYWluIHRoZSB2YWx1ZXMgdXNlZCBmb3IgdGhyZXNob2xkcyBhbmQgdmFsdWUgY29tcGFyaXNvbnMuICBXaXRob3V0IHRoaXMsIHRoZXJlIGNhblxyXG4gIC8vIHNvbWV0aW1lcyBiZSBjYXNlcyB3aGVyZSBzbGlnaHQgdmFsdWUgZGlmZmVyZW5jZXMsIHN1Y2ggYXMgdGhvc2UgY2F1c2VkIGJ5IGZsb2F0aW5nIHBvaW50IGluYWNjdXJhY2llcywgY2FuIGNhdXNlXHJcbiAgLy8gc291bmRzIG5vdCB0byBiZSBnZW5lcmF0ZWQgd2hlbiB0aGV5IHNob3VsZC4gIFVzZSBfLmlkZW50aXR5IGZvciBhIFwibm8tb3BcIiBpZiBubyBjb25zdHJhaW50IGlzIG5lZWRlZC4gIFRoaXMgaXNcclxuICAvLyB1c2VkIGZvciBtdWx0aXBsZSB2YWx1ZXMsIGJ1dCBpcyBjYWxsZWQgXCJjb25zdHJhaW5WYWx1ZVwiIHJhdGhlciB0aGFuIFwiY29uc3RyYWluVmFsdWVzXCIgdG8gbWF0Y2ggdGhlIHByZS1leGlzdGluZ1xyXG4gIC8vIG9wdGlvbiBuYW1lIGluIHRoZSBTbGlkZXIgY2xhc3MuICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvNjk3I2lzc3VlY29tbWVudC0xMDY2ODUwMTgxLlxyXG4gIGNvbnN0cmFpblZhbHVlPzogKCBuOiBudW1iZXIgKSA9PiBudW1iZXI7XHJcblxyXG4gIC8vIFRoZSBzb3VuZCBwbGF5ZXIgdGhhdCBpcyB1c2VkIHRvIGluZGljYXRlIHRoZSBtaW5pbXVtIHZhbHVlLlxyXG4gIG1pblNvdW5kUGxheWVyPzogVFNvdW5kUGxheWVyO1xyXG5cclxuICAvLyBUaGUgc291bmQgcGxheWVyIHRoYXQgaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgbWF4aW11bSB2YWx1ZS5cclxuICBtYXhTb3VuZFBsYXllcj86IFRTb3VuZFBsYXllcjtcclxuXHJcbiAgLy8gVGhlIG1pbmltdW0gYW1vdW50IG9mIHRpbWUgdGhhdCBtdXN0IHBhc3MgYWZ0ZXIgYSBtaWRkbGUgc291bmQgaXMgcGxheWVkIGJlZm9yZSBhbm90aGVyIGNhbiBiZSBwbGF5ZWQuICBUaGlzIGlzXHJcbiAgLy8gaGVscGZ1bCB3aGVuIGEgbG90IG9mIHZhbHVlIGNoYW5nZXMgY2FuIG9jY3VyIHJhcGlkbHkgYW5kIHRodXMgY3JlYXRlIGFuIG92ZXJ3aGVsbWluZyBhbW91bnQgb2Ygc291bmQuXHJcbiAgbWluaW11bUludGVyTWlkZGxlU291bmRUaW1lPzogbnVtYmVyO1xyXG59O1xyXG5cclxuY2xhc3MgVmFsdWVDaGFuZ2VTb3VuZFBsYXllciB7XHJcblxyXG4gIC8vIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0aHJlc2hvbGQgdmFsdWVzIGF0IHdoaWNoIHNvdW5kcyB3aWxsIGJlIHBsYXllZC5cclxuICBwcml2YXRlIHJlYWRvbmx5IGludGVyVGhyZXNob2xkRGlzdGFuY2U6IG51bWJlcjtcclxuXHJcbiAgLy8gcmFuZ2Ugb2YgdmFsdWVzIHRoYXQgdGhpcyBzaG91bGQgZXhwZWN0IHRvIGhhbmRsZVxyXG4gIHByaXZhdGUgcmVhZG9ubHkgdmFsdWVSYW5nZTogUmFuZ2U7XHJcblxyXG4gIC8vIHNvdW5kIHBsYXllciBmb3IgbW92ZW1lbnQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgcmFuZ2UgKGkuZS4gbm90IGF0IG1pbiBvciBtYXgpIGFuZCBtb3ZpbmcgdXBcclxuICBwcml2YXRlIHJlYWRvbmx5IG1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXI6IFRTb3VuZFBsYXllciB8IFNvdW5kQ2xpcDtcclxuXHJcbiAgLy8gc291bmQgcGxheWVyIGZvciBtb3ZlbWVudCBpbiB0aGUgbWlkZGxlIG9mIHRoZSByYW5nZSAoaS5lLiBub3QgYXQgbWluIG9yIG1heCkgYW5kIG1vdmluZyBkb3duXHJcbiAgcHJpdmF0ZSByZWFkb25seSBtaWRkbGVNb3ZpbmdEb3duU291bmRQbGF5ZXI6IFRTb3VuZFBsYXllciB8IFNvdW5kQ2xpcDtcclxuXHJcbiAgLy8gcGxheWJhY2sgcmF0ZSBtYXBwZXIgZm9yIG1pZGRsZSBzb3VuZHMgYW5kIHVwd2FyZCB2YWx1ZSBjaGFuZ2VzXHJcbiAgcHJpdmF0ZSByZWFkb25seSBtaWRkbGVNb3ZpbmdVcFBsYXliYWNrUmF0ZU1hcHBlcjogKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyO1xyXG5cclxuICAvLyBwbGF5YmFjayByYXRlIG1hcHBlciBmb3IgbWlkZGxlIHNvdW5kcyBhbmQgZG93bndhcmQgdmFsdWUgY2hhbmdlc1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgbWlkZGxlTW92aW5nRG93blBsYXliYWNrUmF0ZU1hcHBlcjogKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyO1xyXG5cclxuICAvLyBTb3VuZCBwbGF5ZXJzIGZvciB0aGUgbWluIGFuZCBtYXggdmFsdWVzLiAgSWYgbm90aGluZyBpcyBwcm92aWRlZCBhIGRlZmF1bHQgd2lsbCBiZSB1c2VkLiAgSWYgdGhlIGZsYWdcclxuICAvLyBVU0VfTUlERExFX1NPVU5EIGlzIHByb3ZpZGVkLCB0aGUgc291bmQgcGxheWVyIGZvciB0aGUgbWlkZGxlIHJhbmdlIHdpbGwgYmUgdXNlZC5cclxuICBwcml2YXRlIHJlYWRvbmx5IG1pblNvdW5kUGxheWVyOiBUU291bmRQbGF5ZXI7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhTb3VuZFBsYXllcjogVFNvdW5kUGxheWVyO1xyXG5cclxuICAvLyBtaW4gdGltZSBiZXR3ZWVuIHBsYXlpbmcgb25lIG1pZGRsZSBzb3VuZCBhbmQgdGhlIG5leHRcclxuICBwcml2YXRlIHJlYWRvbmx5IG1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZTogbnVtYmVyO1xyXG5cclxuICAvLyBmdW5jdGlvbiB0byBjb25zdHJhaW4gdGhlIHZhbHVlcyB1c2VkIGZvciB0aHJlc2hvbGRzIGFuZCBjb21wYXJpc29uc1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgY29uc3RyYWluVmFsdWU6ICggbjogbnVtYmVyICkgPT4gbnVtYmVyO1xyXG5cclxuICAvLyB0aW1lIG9mIG1vc3QgcmVjZW50bHkgcGxheWVkIG1pZGRsZSBzb3VuZCwgdXNlZCB0byBtb2RlcmF0ZSB0aGUgcmF0ZSBhdCB3aGljaCB0aGVzZSBzb3VuZHMgYXJlIHBsYXllZFxyXG4gIHByaXZhdGUgdGltZU9mTW9zdFJlY2VudE1pZGRsZVNvdW5kOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB2YWx1ZVJhbmdlIC0gdGhlIHJhbmdlIG9mIHZhbHVlcyBleHBlY3RlZCBhbmQgb3ZlciB3aGljaCBzb3VuZHMgd2lsbCBiZSBwbGF5ZWRcclxuICAgKiBAcGFyYW0gW3Byb3ZpZGVkT3B0aW9uc11cclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIHZhbHVlUmFuZ2U6IFJhbmdlLCBwcm92aWRlZE9wdGlvbnM/OiBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPFZhbHVlQ2hhbmdlU291bmRQbGF5ZXJPcHRpb25zPigpKCB7XHJcbiAgICAgIG1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXI6IGdlbmVyYWxTb2Z0Q2xpY2tTb3VuZFBsYXllcixcclxuICAgICAgbWlkZGxlTW92aW5nRG93blNvdW5kUGxheWVyOiBERUZBVUxUX01JRERMRV9NT1ZJTkdfRE9XTl9TT1VORF9QTEFZRVIsXHJcbiAgICAgIG1pZGRsZU1vdmluZ1VwUGxheWJhY2tSYXRlTWFwcGVyOiBOT19QTEFZQkFDS19SQVRFX0NIQU5HRSxcclxuICAgICAgbWlkZGxlTW92aW5nRG93blBsYXliYWNrUmF0ZU1hcHBlcjogTk9fUExBWUJBQ0tfUkFURV9DSEFOR0UsXHJcbiAgICAgIG51bWJlck9mTWlkZGxlVGhyZXNob2xkczogbnVsbCxcclxuICAgICAgaW50ZXJUaHJlc2hvbGREZWx0YTogbnVsbCxcclxuICAgICAgY29uc3RyYWluVmFsdWU6IERFRkFVTFRfVkFMVUVfQ09OU1RSQUlOVCxcclxuICAgICAgbWluU291bmRQbGF5ZXI6IERFRkFVTFRfTUlOX1NPVU5EX1BMQVlFUixcclxuICAgICAgbWF4U291bmRQbGF5ZXI6IGdlbmVyYWxCb3VuZGFyeUJvb3BTb3VuZFBsYXllcixcclxuICAgICAgbWluaW11bUludGVyTWlkZGxlU291bmRUaW1lOiAwLjAzNSAvLyBlbXBpcmljYWxseSBkZXRlcm1pbmVkXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBvcHRpb24gdmFsaWRpdHkgY2hlY2tzXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KFxyXG4gICAgb3B0aW9ucy5taW5pbXVtSW50ZXJNaWRkbGVTb3VuZFRpbWUgPj0gMCAmJiBvcHRpb25zLm1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZSA8IDEsXHJcbiAgICAgIGB1bnJlYXNvbmFibGUgdmFsdWUgZm9yIG1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZTogJHtvcHRpb25zLm1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZX1gXHJcbiAgICApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydChcclxuICAgICAgb3B0aW9ucy5udW1iZXJPZk1pZGRsZVRocmVzaG9sZHMgPT09IG51bGwgfHwgb3B0aW9ucy5pbnRlclRocmVzaG9sZERlbHRhID09PSBudWxsLFxyXG4gICAgICAnY2Fubm90IHNwZWNpZnkgYm90aCB0aGUgbnVtYmVyIG9mIG1pZGRsZSB0aHJlc2hvbGRzIGFuZCB0aGUgaW50ZXItdGhyZXNob2xkIGRlbHRhJ1xyXG4gICAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoXHJcbiAgICAgIG9wdGlvbnMubnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzID09PSBudWxsIHx8IE51bWJlci5pc0ludGVnZXIoIG9wdGlvbnMubnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzICksXHJcbiAgICAgICdudW1iZXJPZk1pZGRsZVRocmVzaG9sZHMgbXVzdCBiZSBhbiBpbnRlZ2VyIGlmIHNwZWNpZmllZCdcclxuICAgICk7XHJcblxyXG4gICAgLy8gSWYgYSBwbGF5YmFjayByYXRlIG1hcHBlciBpcyBwcm92aWRlZCBmb3IgYSBtaWRkbGUgdGhyZXNob2xkIHNvdW5kLCB0aGUgcHJvdmlkZWQgc291bmQgcGxheWVyIG11c3Qgc3VwcG9ydFxyXG4gICAgLy8gc2V0dGluZyBhIGRpZmZlcmVudCBwbGF5YmFjayByYXRlLiAgSXQgc2hvdWxkIE5PVCBiZSBhIFNvdW5kQ2xpcFBsYXllciwgc2luY2UgdGhvc2UgYXJlIGRlc2lnbmVkIHRvIGJlIHNoYXJlZCwgc29cclxuICAgIC8vIHRoZSBwbGF5YmFjayByYXRlIHNob3VsZCBuZXZlciBiZSBjaGFuZ2VkLiAgVGhlIGZvbGxvd2luZyBhc3NlcnRpb25zIGFyZSBpbnRlbmRlZCB0byB2ZXJpZnkgdGhhdCB0aGVzZSBvcHRpb25zXHJcbiAgICAvLyBhcmUgc2V0IGluIGEgY29tcGF0aWJsZSB3YXkuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KFxyXG4gICAgICBvcHRpb25zLm1pZGRsZU1vdmluZ1VwUGxheWJhY2tSYXRlTWFwcGVyID09PSBOT19QTEFZQkFDS19SQVRFX0NIQU5HRSB8fFxyXG4gICAgICBvcHRpb25zLm1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXIgaW5zdGFuY2VvZiBTb3VuZENsaXAsXHJcbiAgICAgICdhIHNvdW5kIHBsYXllciB0aGF0IHN1cHBvcnRzIHBsYXliYWNrIHJhdGUgY2hhbmdlcyBpcyByZXF1aXJlZCB3aGVuIGEgcGxheWJhY2sgcmF0ZSBtYXBwZXIgaXMgdXNlZCdcclxuICAgICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KFxyXG4gICAgICBvcHRpb25zLm1pZGRsZU1vdmluZ0Rvd25QbGF5YmFja1JhdGVNYXBwZXIgPT09IE5PX1BMQVlCQUNLX1JBVEVfQ0hBTkdFIHx8XHJcbiAgICAgIG9wdGlvbnMubWlkZGxlTW92aW5nRG93blNvdW5kUGxheWVyIGluc3RhbmNlb2YgU291bmRDbGlwLFxyXG4gICAgICAnYSBzb3VuZCBwbGF5ZXIgdGhhdCBzdXBwb3J0cyBwbGF5YmFjayByYXRlIGNoYW5nZXMgaXMgcmVxdWlyZWQgd2hlbiBhIHBsYXliYWNrIHJhdGUgbWFwcGVyIGlzIHVzZWQnXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFNldCBkZWZhdWx0IG51bWJlciBvZiBtaWRkbGUgdGhyZXNob2xkcyBpZiBuZWNlc3NhcnkuXHJcbiAgICBpZiAoIG9wdGlvbnMubnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzID09PSBudWxsICYmIG9wdGlvbnMuaW50ZXJUaHJlc2hvbGREZWx0YSA9PT0gbnVsbCApIHtcclxuICAgICAgb3B0aW9ucy5udW1iZXJPZk1pZGRsZVRocmVzaG9sZHMgPSBERUZBVUxUX05VTUJFUl9PRl9NSURETEVfVEhSRVNIT0xEUztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIG9wdGlvbnMubnVtYmVyT2ZNaWRkbGVUaHJlc2hvbGRzICE9PSBudWxsICkge1xyXG4gICAgICB0aGlzLmludGVyVGhyZXNob2xkRGlzdGFuY2UgPSB2YWx1ZVJhbmdlLmdldExlbmd0aCgpIC8gKCBvcHRpb25zLm51bWJlck9mTWlkZGxlVGhyZXNob2xkcyArIDEgKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCBvcHRpb25zLmludGVyVGhyZXNob2xkRGVsdGEgIT09IG51bGwgKSB7XHJcbiAgICAgIHRoaXMuaW50ZXJUaHJlc2hvbGREaXN0YW5jZSA9IG9wdGlvbnMuaW50ZXJUaHJlc2hvbGREZWx0YTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ3Nob3VsZCBuZXZlciBnZXQgaGVyZSwgaXQgaXMgYSBsb2dpYyBlcnJvciBpZiB3ZSBkbycgKTtcclxuICAgICAgdGhpcy5pbnRlclRocmVzaG9sZERpc3RhbmNlID0gdmFsdWVSYW5nZS5nZXRMZW5ndGgoKSAvIDI7IC8vIGF2b2lkIHVuaW5pdGlhbGl6ZWQgY29tcGlsZS10aW1lIGVycm9yXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy52YWx1ZVJhbmdlID0gdmFsdWVSYW5nZTtcclxuICAgIHRoaXMubWlkZGxlTW92aW5nVXBTb3VuZFBsYXllciA9IG9wdGlvbnMubWlkZGxlTW92aW5nVXBTb3VuZFBsYXllcjtcclxuICAgIHRoaXMubWlkZGxlTW92aW5nRG93blNvdW5kUGxheWVyID0gb3B0aW9ucy5taWRkbGVNb3ZpbmdEb3duU291bmRQbGF5ZXI7XHJcbiAgICB0aGlzLm1pZGRsZU1vdmluZ1VwUGxheWJhY2tSYXRlTWFwcGVyID0gb3B0aW9ucy5taWRkbGVNb3ZpbmdVcFBsYXliYWNrUmF0ZU1hcHBlcjtcclxuICAgIHRoaXMubWlkZGxlTW92aW5nRG93blBsYXliYWNrUmF0ZU1hcHBlciA9IG9wdGlvbnMubWlkZGxlTW92aW5nRG93blBsYXliYWNrUmF0ZU1hcHBlcjtcclxuICAgIHRoaXMubWluU291bmRQbGF5ZXIgPSBvcHRpb25zLm1pblNvdW5kUGxheWVyO1xyXG4gICAgdGhpcy5tYXhTb3VuZFBsYXllciA9IG9wdGlvbnMubWF4U291bmRQbGF5ZXI7XHJcbiAgICB0aGlzLm1pbmltdW1JbnRlck1pZGRsZVNvdW5kVGltZSA9IG9wdGlvbnMubWluaW11bUludGVyTWlkZGxlU291bmRUaW1lO1xyXG4gICAgdGhpcy50aW1lT2ZNb3N0UmVjZW50TWlkZGxlU291bmQgPSAwO1xyXG4gICAgdGhpcy5jb25zdHJhaW5WYWx1ZSA9IG9wdGlvbnMuY29uc3RyYWluVmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgbmV3IHZhbHVlIGhhcyByZWFjaGVkIG9yIGNyb3NzZWQgYSB0aHJlc2hvbGQgYW5kLCBpZiBzbywgcGxheSB0aGUgYXBwcm9wcmlhdGUgc291bmQuICBJZiBubyB0aHJlc2hvbGRcclxuICAgKiBoYXMgYmVlbiByZWFjaGVkIG9yIGNyb3NzZWQgYW5kIHRoZSBuZXcgdmFsdWUgaXMgbm90IGF0IHRoZSBtaW4gb3IgbWF4LCBubyBzb3VuZCB3aWxsIGJlIHBsYXllZC5cclxuICAgKi9cclxuICBwdWJsaWMgcGxheVNvdW5kSWZUaHJlc2hvbGRSZWFjaGVkKCBuZXdWYWx1ZTogbnVtYmVyLCBvbGRWYWx1ZTogbnVtYmVyICk6IHZvaWQge1xyXG5cclxuICAgIGlmICggbmV3VmFsdWUgIT09IG9sZFZhbHVlICkge1xyXG5cclxuICAgICAgY29uc3QgY29uc3RyYWluZWROZXdWYWx1ZSA9IHRoaXMuY29uc3RyYWluVmFsdWUoIG5ld1ZhbHVlICk7XHJcbiAgICAgIGNvbnN0IGNvbnN0cmFpbmVkT2xkVmFsdWUgPSB0aGlzLmNvbnN0cmFpblZhbHVlKCBvbGRWYWx1ZSApO1xyXG5cclxuICAgICAgY29uc3Qgb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMgPSB0aGlzLmdldFN1cnJvdW5kaW5nVGhyZXNob2xkcyggY29uc3RyYWluZWRPbGRWYWx1ZSApO1xyXG4gICAgICBjb25zdCBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcyA9IHRoaXMuZ2V0U3Vycm91bmRpbmdUaHJlc2hvbGRzKCBjb25zdHJhaW5lZE5ld1ZhbHVlICk7XHJcblxyXG4gICAgICBjb25zdCB0aHJlc2hvbGRDcm9zc2VkID0gKCBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKCBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMCBdIC0gbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSApID4gdGhpcy5pbnRlclRocmVzaG9sZERpc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDIgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAhPT0gbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMCBdICE9PSBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMSBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzLmxlbmd0aCA9PT0gMiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAhPT0gb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMCBdICE9PSBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkc1sgMSBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzLmxlbmd0aCA9PT0gMiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDIgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAhPT0gb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgY29uc3QgdGhyZXNob2xkUmVhY2hlZCA9IG5ld1ZhbHVlU3Vycm91bmRpbmdUaHJlc2hvbGRzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBvbGRWYWx1ZVN1cnJvdW5kaW5nVGhyZXNob2xkcy5sZW5ndGggPT09IDIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSAhPT0gbmV3VmFsdWVTdXJyb3VuZGluZ1RocmVzaG9sZHNbIDAgXSApO1xyXG5cclxuICAgICAgaWYgKCB0aHJlc2hvbGRDcm9zc2VkIHx8XHJcbiAgICAgICAgICAgdGhyZXNob2xkUmVhY2hlZCB8fFxyXG4gICAgICAgICAgIGNvbnN0cmFpbmVkTmV3VmFsdWUgPT09IHRoaXMudmFsdWVSYW5nZS5taW4gfHxcclxuICAgICAgICAgICBjb25zdHJhaW5lZE5ld1ZhbHVlID09PSB0aGlzLnZhbHVlUmFuZ2UubWF4XHJcbiAgICAgICkge1xyXG4gICAgICAgIHRoaXMucGxheVNvdW5kRm9yVmFsdWVDaGFuZ2UoIG5ld1ZhbHVlLCBvbGRWYWx1ZSApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQbGF5IHRoZSBhcHByb3ByaWF0ZSBzb3VuZCBmb3IgdGhlIGNoYW5nZSBpbiB2YWx1ZSBpbmRpY2F0ZWQgYnkgdGhlIHByb3ZpZGVkIG5ldyBhbmQgb2xkIHZhbHVlcy4gIFRoaXMgd2lsbCBhbG1vc3RcclxuICAgKiBhbHdheXMgcGxheSBhIHNvdW5kLCBidXQgdGhlcmUgYXJlIHNvbWUgZXhjZXB0aW9ucy4gIFNlZSB0aGUgY29kZSBhbmQgY29tbWVudHMgZm9yIGRldGFpbHMuXHJcbiAgICovXHJcbiAgcHVibGljIHBsYXlTb3VuZEZvclZhbHVlQ2hhbmdlKCBuZXdWYWx1ZTogbnVtYmVyLCBvbGRWYWx1ZTogbnVtYmVyICk6IHZvaWQge1xyXG4gICAgY29uc3QgY29uc3RyYWluZWROZXdWYWx1ZSA9IHRoaXMuY29uc3RyYWluVmFsdWUoIG5ld1ZhbHVlICk7XHJcbiAgICBjb25zdCBjb25zdHJhaW5lZE9sZFZhbHVlID0gdGhpcy5jb25zdHJhaW5WYWx1ZSggb2xkVmFsdWUgKTtcclxuICAgIGlmICggY29uc3RyYWluZWROZXdWYWx1ZSAhPT0gY29uc3RyYWluZWRPbGRWYWx1ZSB8fFxyXG4gICAgICAgICAoIG9sZFZhbHVlICE9PSBuZXdWYWx1ZSAmJiAoIG5ld1ZhbHVlID09PSB0aGlzLnZhbHVlUmFuZ2UubWluIHx8IG5ld1ZhbHVlID09PSB0aGlzLnZhbHVlUmFuZ2UubWF4ICkgKSApIHtcclxuXHJcbiAgICAgIGlmICggbmV3VmFsdWUgPT09IHRoaXMudmFsdWVSYW5nZS5taW4gJiYgdGhpcy5taW5Tb3VuZFBsYXllciAhPT0gVmFsdWVDaGFuZ2VTb3VuZFBsYXllci5VU0VfTUlERExFX1NPVU5EICkge1xyXG4gICAgICAgIHRoaXMubWluU291bmRQbGF5ZXIucGxheSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCBuZXdWYWx1ZSA9PT0gdGhpcy52YWx1ZVJhbmdlLm1heCAmJiB0aGlzLm1heFNvdW5kUGxheWVyICE9PSBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyLlVTRV9NSURETEVfU09VTkQgKSB7XHJcbiAgICAgICAgdGhpcy5tYXhTb3VuZFBsYXllci5wbGF5KCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFBsYXkgYSBtaWRkbGUtcmFuZ2Ugc291bmQsIGJ1dCBvbmx5IGlmIGVub3VnaCB0aW1lIGhhcyBwYXNzZWQgc2luY2UgdGhlIGxhc3Qgb25lIHdhcyBwbGF5ZWQuXHJcbiAgICAgICAgY29uc3Qgbm93ID0gcGhldEF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcclxuICAgICAgICBpZiAoIG5vdyAtIHRoaXMudGltZU9mTW9zdFJlY2VudE1pZGRsZVNvdW5kID4gdGhpcy5taW5pbXVtSW50ZXJNaWRkbGVTb3VuZFRpbWUgKSB7XHJcbiAgICAgICAgICBsZXQgcGxheWJhY2tSYXRlTWFwcGVyO1xyXG4gICAgICAgICAgbGV0IHNvdW5kUGxheWVyO1xyXG4gICAgICAgICAgaWYgKCBjb25zdHJhaW5lZE5ld1ZhbHVlID4gY29uc3RyYWluZWRPbGRWYWx1ZSApIHtcclxuICAgICAgICAgICAgcGxheWJhY2tSYXRlTWFwcGVyID0gdGhpcy5taWRkbGVNb3ZpbmdVcFBsYXliYWNrUmF0ZU1hcHBlcjtcclxuICAgICAgICAgICAgc291bmRQbGF5ZXIgPSB0aGlzLm1pZGRsZU1vdmluZ1VwU291bmRQbGF5ZXI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGxheWJhY2tSYXRlTWFwcGVyID0gdGhpcy5taWRkbGVNb3ZpbmdVcFBsYXliYWNrUmF0ZU1hcHBlcjtcclxuICAgICAgICAgICAgc291bmRQbGF5ZXIgPSB0aGlzLm1pZGRsZU1vdmluZ0Rvd25Tb3VuZFBsYXllcjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIHBsYXliYWNrUmF0ZU1hcHBlciAhPT0gTk9fUExBWUJBQ0tfUkFURV9DSEFOR0UgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGp1c3QgdGhlIHBsYXliYWNrIHJhdGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG5ldyB2YWx1ZS4gIEl0IHNob3VsZCBiZSBzYWZlIHRvIGNhc3QgdGhpcyBoZXJlIGJlY2F1c2Ugb2ZcclxuICAgICAgICAgICAgLy8gdGhlIGFzc2VydGlvbiBjaGVja3MgdGhhdCBvY2N1ciBkdXJpbmcgY29uc3RydWN0aW9uLlxyXG4gICAgICAgICAgICAoIHNvdW5kUGxheWVyIGFzIFNvdW5kQ2xpcCApLnNldFBsYXliYWNrUmF0ZSggcGxheWJhY2tSYXRlTWFwcGVyKCBuZXdWYWx1ZSApICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzb3VuZFBsYXllci5wbGF5KCk7XHJcbiAgICAgICAgICB0aGlzLnRpbWVPZk1vc3RSZWNlbnRNaWRkbGVTb3VuZCA9IG5vdztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBuZXh0IGxvd2VzdCBhbmQgbmV4dCBoaWdoZXN0IHRocmVzaG9sZHMgZm9yIHRoZSBwcm92aWRlZCB2YWx1ZS4gIElmIHRoZSBwcm92aWRlZFxyXG4gICAqIHZhbHVlIGlzIGV4YWN0bHkgZXF1YWwgdG8gYSB0aHJlc2hvbGQsIG9ubHkgdGhlIHNpbmdsZSB0aHJlc2hvbGQgdmFsdWUgaXMgcmV0dXJuZWQgaW4gdGhlIGFycmF5LlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0U3Vycm91bmRpbmdUaHJlc2hvbGRzKCB2YWx1ZTogbnVtYmVyICk6IG51bWJlcltdIHtcclxuXHJcbiAgICAvLyBBIG5vdGUgdG8gZnV0dXJlIG1haW50YWluZXJzOiBKYXZhU2NyaXB0J3MgZmxvYXRpbmcgcG9pbnQgaW1wbGVtZW50YXRpb24gd2FzIGNhdXNpbmcgYWxsIG1hbm5lciBvZiBwcm9ibGVtcyB3aXRoXHJcbiAgICAvLyB0aGlzIG1ldGhvZC4gIEZvciBpbnN0YW5jZSwgd2hlbiB0aGUgaW50ZXItdGhyZXNob2xkIGRpc3RhbmNlIHdhcyAwLjEgYW5kIHRoZSBwcm92aWRlZCB2YWx1ZSB3YXMgMC4zLCBKUyBzYXlzXHJcbiAgICAvLyB0aGF0IDAuMy8wLjEgaXMgMi45OTk5OTk5OTk5OTk5OTk2LCBzbyBpdCB3YXMgdHJpY2t5IHRvIHRlbGwgdGhhdCB0aGUgdmFsdWUgd2FzIGF0IGEgdGhyZXNob2xkIGFuZCBub3QgYmVsb3cgaXQuXHJcbiAgICAvLyBUaGVyZWZvcmUsIHRoZSBjb2RlIGJlbG93IGRvZXMgcm91bmRpbmcgdG8gaW50ZXJ2YWxzIHRoYXQgd2VyZSBlbXBpcmljYWxseSBkZXRlcm1pbmVkIHRvIGNvcnJlY3QgZm9yIHRoZSBmbG9hdGluZ1xyXG4gICAgLy8gcG9pbnQgcHJvYmxlbXMuICBUaGlzIHdvcmtlZCBpbiBhbGwgdGVzdCBjYXNlcywgYnV0IG1heSBub3Qgc3RhbmQgdGhlIHRlc3Qgb2YgdGltZSBpZiBzb21lIHVudXN1YWwgc2xpZGVyXHJcbiAgICAvLyBjb25maWd1cmF0aW9ucyBhcmUgbmVlZGVkLiAgT25lIGlkZWEgbWlnaHQgYmUgdG8gbWFrZSB0aGUgcm91bmRpbmcgaW50ZXJ2YWwgZm9yIHRoaXMgY2FsY3VsYXRpb24gYW4gb3B0aW9uIHRvIHRoZVxyXG4gICAgLy8gY2xhc3MsIGJ1dCB0aGF0IGZlbHQgbGlrZSBvdmVya2lsbCBhdCB0aGUgdGltZSBvZiB0aGlzIHdyaXRpbmcuXHJcbiAgICBjb25zdCByb3VuZGluZ0ludGVydmFsID0gMUUtNztcclxuXHJcbiAgICBjb25zdCBzZWdtZW50ID0gTWF0aC5mbG9vcihcclxuICAgICAgVXRpbHMucm91bmRUb0ludGVydmFsKCAoIHZhbHVlIC0gdGhpcy52YWx1ZVJhbmdlLm1pbiApIC8gdGhpcy5pbnRlclRocmVzaG9sZERpc3RhbmNlLCByb3VuZGluZ0ludGVydmFsIClcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgbG93ZXJUaHJlc2hvbGQgPSBVdGlscy5yb3VuZFRvSW50ZXJ2YWwoXHJcbiAgICAgIHNlZ21lbnQgKiB0aGlzLmludGVyVGhyZXNob2xkRGlzdGFuY2UgKyB0aGlzLnZhbHVlUmFuZ2UubWluLFxyXG4gICAgICByb3VuZGluZ0ludGVydmFsXHJcbiAgICApO1xyXG4gICAgY29uc3QgdGhyZXNob2xkQXJyYXkgPSBbIGxvd2VyVGhyZXNob2xkIF07XHJcbiAgICBpZiAoIGxvd2VyVGhyZXNob2xkICE9PSB2YWx1ZSApIHtcclxuXHJcbiAgICAgIC8vIFRoZSBwcm92aWRlZCB2YWx1ZSB3YXNuJ3QgZXhhY3RseSBhdCBhIHRocmVzaG9sZC4gIFNpbmNlIHRoZSBwcmVjZWRpbmcgY2FsY3VsYXRpb24gcHJvdmlkZWQgdGhlIGxvd2VyXHJcbiAgICAgIC8vIHRocmVzaG9sZCwgYWRkIHRoZSB1cHBlciBvbmUgbm93LlxyXG4gICAgICBjb25zdCB1cHBlclRocmVzaG9sZCA9IE1hdGgubWluKFxyXG4gICAgICAgIFV0aWxzLnJvdW5kVG9JbnRlcnZhbCggbG93ZXJUaHJlc2hvbGQgKyB0aGlzLmludGVyVGhyZXNob2xkRGlzdGFuY2UsIHJvdW5kaW5nSW50ZXJ2YWwgKSxcclxuICAgICAgICB0aGlzLnZhbHVlUmFuZ2UubWF4XHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBUaGlzIG1heSBzZWVtIGxpa2UgYW4gb2RkIHRlc3QsIHNvIGhlcmUncyB0aGUgc3Rvcnk6IFRoZXJlIGFyZSBzb21lIHJhcmUgYnV0IHBvc3NpYmxlIGNhc2VzIHdoZXJlIHRoZVxyXG4gICAgICAvLyBjYWxjdWxhdGlvbiBhYm92ZSBkb2Vzbid0IGFjdHVhbGx5IHlpZWxkIGEgaGlnaGVyIHZhbHVlIGR1ZSB0byBmbG9hdGluZyBwb2ludCBlcnJvcnMuICBXaGVuIHRlc3RpbmcgaW4gRGVjXHJcbiAgICAgIC8vIDIwMjIsIHRoaXMgd2FzIG9ubHkgc2VlbiBvbiB0aGUgV2F2ZSBQYWNrZXQgQ2VudGVyIHNsaWRlciBpbiBGb3VyaWVyIE1ha2luZyBXYXZlcy4gIFNvLCBvbmx5IGFkZCB0aGUgdXBwZXJcclxuICAgICAgLy8gdGhyZXNob2xkIGlmIGl0J3MgYWN0dWFsbHkgaGlnaGVyIHRoYW4gdGhlIGxvd2VyIG9uZS4gIElmIHRoZSB1cHBlciB0aHJlc2hvbGQgaXNuJ3QgYWRkZWQsIHRoaXMgZXNzZW50aWFsbHlcclxuICAgICAgLy8gc2F5cyB0aGF0IHRoZSBsb3dlciB0aHJlc2hvbGQgd2FzIGFuIGV4YWN0IG1hdGNoIGZvciBvbmUgb2YgdGhlIGNyb3NzaW5nIHRocmVzaG9sZHMsIHdoaWNoIGlzIGFwcHJveGltYXRlbHlcclxuICAgICAgLy8gdHJ1ZSBhbmQgaGFzIHdvcmtlZCBmaW5lIGluIGFsbCB0ZXN0IGNhc2VzIHRodXMgZmFyLlxyXG4gICAgICBpZiAoIHVwcGVyVGhyZXNob2xkID4gbG93ZXJUaHJlc2hvbGQgKSB7XHJcbiAgICAgICAgdGhyZXNob2xkQXJyYXkucHVzaCggdXBwZXJUaHJlc2hvbGQgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRocmVzaG9sZEFycmF5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBzdGF0aWMgaW5zdGFuY2UgdGhhdCBtYWtlcyBubyBzb3VuZC4gIFRoaXMgaXMgZ2VuZXJhbGx5IHVzZWQgYXMgYW4gb3B0aW9uIHZhbHVlIHRvIHR1cm4gb2ZmIHNvdW5kIGdlbmVyYXRpb24uXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBOT19TT1VORCA9IG5ldyBWYWx1ZUNoYW5nZVNvdW5kUGxheWVyKCBuZXcgUmFuZ2UoIDAsIDEgKSwge1xyXG4gICAgbWlkZGxlTW92aW5nVXBTb3VuZFBsYXllcjogbnVsbFNvdW5kUGxheWVyLFxyXG4gICAgbWluU291bmRQbGF5ZXI6IG51bGxTb3VuZFBsYXllcixcclxuICAgIG1heFNvdW5kUGxheWVyOiBudWxsU291bmRQbGF5ZXJcclxuICB9ICk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc3RhdGljIFRTb3VuZFBsYXllciBpbnN0YW5jZSB0aGF0IGlzIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgYSBmbGFnIGZvciB0aGUgbWluIGFuZCBtYXggc291bmQgcGxheWVycyB0b1xyXG4gICAqIGluZGljYXRlIHRoYXQgdGhlIG1pZGRsZSBzb3VuZCBwbGF5ZXIgc2hvdWxkIGJlIHVzZWQuXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBVU0VfTUlERExFX1NPVU5EOiBUU291bmRQbGF5ZXIgPSB7XHJcbiAgICBwbGF5OiBTVFVCX1NPVU5EX1BMQVlFUl9GVU5DVElPTixcclxuICAgIHN0b3A6IFNUVUJfU09VTkRfUExBWUVSX0ZVTkNUSU9OXHJcbiAgfTtcclxufVxyXG5cclxudGFtYm8ucmVnaXN0ZXIoICdWYWx1ZUNoYW5nZVNvdW5kUGxheWVyJywgVmFsdWVDaGFuZ2VTb3VuZFBsYXllciApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVmFsdWVDaGFuZ2VTb3VuZFBsYXllcjsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxLQUFLLE1BQU0sMEJBQTBCO0FBQzVDLE9BQU9DLEtBQUssTUFBTSwwQkFBMEI7QUFDNUMsT0FBT0MsU0FBUyxNQUFNLG9DQUFvQztBQUMxRCxPQUFPQyx1QkFBdUIsTUFBTSx5Q0FBeUM7QUFDN0UsT0FBT0Msb0JBQW9CLE1BQU0sc0NBQXNDO0FBRXZFLE9BQU9DLGdCQUFnQixNQUFNLHdCQUF3QjtBQUNyRCxPQUFPQyw4QkFBOEIsTUFBTSwyREFBMkQ7QUFDdEcsT0FBT0MsMkJBQTJCLE1BQU0sd0RBQXdEO0FBQ2hHLE9BQU9DLGVBQWUsTUFBTSw0Q0FBNEM7QUFDeEUsT0FBT0MsS0FBSyxNQUFNLGFBQWE7QUFDL0IsT0FBT0MsU0FBUyxNQUFNLGdCQUFnQjtBQUN0QyxPQUFPQyxlQUFlLE1BQU0sc0JBQXNCOztBQUVsRDtBQUNBLE1BQU1DLG1DQUFtQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQy9DLE1BQU1DLHdCQUF3QixHQUFHLElBQUlGLGVBQWUsQ0FBRVIsdUJBQXVCLEVBQUU7RUFDN0VXLGdCQUFnQixFQUFFO0lBQ2hCQyxrQkFBa0IsRUFBRSxHQUFHO0lBQ3ZCQyxtQkFBbUIsRUFBRSxDQUFDLEdBQUdDLElBQUksQ0FBQ0MsR0FBRyxDQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBRSxDQUFDLENBQUM7RUFDaEQsQ0FBQzs7RUFDREMsbUJBQW1CLEVBQUU7SUFBRUMsWUFBWSxFQUFFO0VBQWlCO0FBQ3hELENBQUUsQ0FBQztBQUNILE1BQU1DLHVDQUF1QyxHQUFHLElBQUlWLGVBQWUsQ0FBRVAsb0JBQW9CLEVBQUU7RUFDekZVLGdCQUFnQixFQUFFO0lBQ2hCQyxrQkFBa0IsRUFBRSxHQUFHO0lBQ3ZCQyxtQkFBbUIsRUFBRSxDQUFDLEdBQUdDLElBQUksQ0FBQ0MsR0FBRyxDQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBRSxDQUFDLENBQUM7RUFDaEQsQ0FBQzs7RUFDREMsbUJBQW1CLEVBQUU7SUFBRUMsWUFBWSxFQUFFO0VBQWlCO0FBQ3hELENBQUUsQ0FBQzs7QUFFSDtBQUNBO0FBQ0EsTUFBTUUsd0JBQXdCLEdBQUtDLEtBQWEsSUFBTXRCLEtBQUssQ0FBQ3VCLGVBQWUsQ0FBRUQsS0FBSyxFQUFFLFdBQVksQ0FBQzs7QUFFakc7QUFDQSxNQUFNRSx1QkFBdUIsR0FBR0EsQ0FBQSxLQUFNLENBQUM7O0FBRXZDO0FBQ0EsTUFBTUMsMEJBQTBCLEdBQUdBLENBQUEsS0FBWTtFQUM3Q0MsTUFBTSxJQUFJQSxNQUFNLENBQUUsS0FBSyxFQUFFLHFFQUFzRSxDQUFDO0FBQ2xHLENBQUM7QUErQ0QsTUFBTUMsc0JBQXNCLENBQUM7RUFFM0I7O0VBR0E7O0VBR0E7O0VBR0E7O0VBR0E7O0VBR0E7O0VBR0E7RUFDQTtFQUlBO0VBR0E7RUFHQTtFQUdBO0FBQ0Y7QUFDQTtBQUNBO0VBQ1NDLFdBQVdBLENBQUVDLFVBQWlCLEVBQUVDLGVBQStDLEVBQUc7SUFFdkYsTUFBTUMsT0FBTyxHQUFHOUIsU0FBUyxDQUFnQyxDQUFDLENBQUU7TUFDMUQrQix5QkFBeUIsRUFBRTFCLDJCQUEyQjtNQUN0RDJCLDJCQUEyQixFQUFFYix1Q0FBdUM7TUFDcEVjLGdDQUFnQyxFQUFFVix1QkFBdUI7TUFDekRXLGtDQUFrQyxFQUFFWCx1QkFBdUI7TUFDM0RZLHdCQUF3QixFQUFFLElBQUk7TUFDOUJDLG1CQUFtQixFQUFFLElBQUk7TUFDekJDLGNBQWMsRUFBRWpCLHdCQUF3QjtNQUN4Q2tCLGNBQWMsRUFBRTNCLHdCQUF3QjtNQUN4QzRCLGNBQWMsRUFBRW5DLDhCQUE4QjtNQUM5Q29DLDJCQUEyQixFQUFFLEtBQUssQ0FBQztJQUNyQyxDQUFDLEVBQUVYLGVBQWdCLENBQUM7O0lBRXBCO0lBQ0FKLE1BQU0sSUFBSUEsTUFBTSxDQUNoQkssT0FBTyxDQUFDVSwyQkFBMkIsSUFBSSxDQUFDLElBQUlWLE9BQU8sQ0FBQ1UsMkJBQTJCLEdBQUcsQ0FBQyxFQUNoRix1REFBc0RWLE9BQU8sQ0FBQ1UsMkJBQTRCLEVBQzdGLENBQUM7SUFDRGYsTUFBTSxJQUFJQSxNQUFNLENBQ2RLLE9BQU8sQ0FBQ0ssd0JBQXdCLEtBQUssSUFBSSxJQUFJTCxPQUFPLENBQUNNLG1CQUFtQixLQUFLLElBQUksRUFDakYsbUZBQ0YsQ0FBQztJQUNEWCxNQUFNLElBQUlBLE1BQU0sQ0FDZEssT0FBTyxDQUFDSyx3QkFBd0IsS0FBSyxJQUFJLElBQUlNLE1BQU0sQ0FBQ0MsU0FBUyxDQUFFWixPQUFPLENBQUNLLHdCQUF5QixDQUFDLEVBQ2pHLDBEQUNGLENBQUM7O0lBRUQ7SUFDQTtJQUNBO0lBQ0E7SUFDQVYsTUFBTSxJQUFJQSxNQUFNLENBQ2RLLE9BQU8sQ0FBQ0csZ0NBQWdDLEtBQUtWLHVCQUF1QixJQUNwRU8sT0FBTyxDQUFDQyx5QkFBeUIsWUFBWXZCLFNBQVMsRUFDdEQsb0dBQ0YsQ0FBQztJQUNEaUIsTUFBTSxJQUFJQSxNQUFNLENBQ2RLLE9BQU8sQ0FBQ0ksa0NBQWtDLEtBQUtYLHVCQUF1QixJQUN0RU8sT0FBTyxDQUFDRSwyQkFBMkIsWUFBWXhCLFNBQVMsRUFDeEQsb0dBQ0YsQ0FBQzs7SUFFRDtJQUNBLElBQUtzQixPQUFPLENBQUNLLHdCQUF3QixLQUFLLElBQUksSUFBSUwsT0FBTyxDQUFDTSxtQkFBbUIsS0FBSyxJQUFJLEVBQUc7TUFDdkZOLE9BQU8sQ0FBQ0ssd0JBQXdCLEdBQUd6QixtQ0FBbUM7SUFDeEU7SUFFQSxJQUFLb0IsT0FBTyxDQUFDSyx3QkFBd0IsS0FBSyxJQUFJLEVBQUc7TUFDL0MsSUFBSSxDQUFDUSxzQkFBc0IsR0FBR2YsVUFBVSxDQUFDZ0IsU0FBUyxDQUFDLENBQUMsSUFBS2QsT0FBTyxDQUFDSyx3QkFBd0IsR0FBRyxDQUFDLENBQUU7SUFDakcsQ0FBQyxNQUNJLElBQUtMLE9BQU8sQ0FBQ00sbUJBQW1CLEtBQUssSUFBSSxFQUFHO01BQy9DLElBQUksQ0FBQ08sc0JBQXNCLEdBQUdiLE9BQU8sQ0FBQ00sbUJBQW1CO0lBQzNELENBQUMsTUFDSTtNQUNIWCxNQUFNLElBQUlBLE1BQU0sQ0FBRSxLQUFLLEVBQUUscURBQXNELENBQUM7TUFDaEYsSUFBSSxDQUFDa0Isc0JBQXNCLEdBQUdmLFVBQVUsQ0FBQ2dCLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDNUQ7O0lBRUEsSUFBSSxDQUFDaEIsVUFBVSxHQUFHQSxVQUFVO0lBQzVCLElBQUksQ0FBQ0cseUJBQXlCLEdBQUdELE9BQU8sQ0FBQ0MseUJBQXlCO0lBQ2xFLElBQUksQ0FBQ0MsMkJBQTJCLEdBQUdGLE9BQU8sQ0FBQ0UsMkJBQTJCO0lBQ3RFLElBQUksQ0FBQ0MsZ0NBQWdDLEdBQUdILE9BQU8sQ0FBQ0csZ0NBQWdDO0lBQ2hGLElBQUksQ0FBQ0Msa0NBQWtDLEdBQUdKLE9BQU8sQ0FBQ0ksa0NBQWtDO0lBQ3BGLElBQUksQ0FBQ0ksY0FBYyxHQUFHUixPQUFPLENBQUNRLGNBQWM7SUFDNUMsSUFBSSxDQUFDQyxjQUFjLEdBQUdULE9BQU8sQ0FBQ1MsY0FBYztJQUM1QyxJQUFJLENBQUNDLDJCQUEyQixHQUFHVixPQUFPLENBQUNVLDJCQUEyQjtJQUN0RSxJQUFJLENBQUNLLDJCQUEyQixHQUFHLENBQUM7SUFDcEMsSUFBSSxDQUFDUixjQUFjLEdBQUdQLE9BQU8sQ0FBQ08sY0FBYztFQUM5Qzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNTUywyQkFBMkJBLENBQUVDLFFBQWdCLEVBQUVDLFFBQWdCLEVBQVM7SUFFN0UsSUFBS0QsUUFBUSxLQUFLQyxRQUFRLEVBQUc7TUFFM0IsTUFBTUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDWixjQUFjLENBQUVVLFFBQVMsQ0FBQztNQUMzRCxNQUFNRyxtQkFBbUIsR0FBRyxJQUFJLENBQUNiLGNBQWMsQ0FBRVcsUUFBUyxDQUFDO01BRTNELE1BQU1HLDZCQUE2QixHQUFHLElBQUksQ0FBQ0Msd0JBQXdCLENBQUVGLG1CQUFvQixDQUFDO01BQzFGLE1BQU1HLDZCQUE2QixHQUFHLElBQUksQ0FBQ0Qsd0JBQXdCLENBQUVILG1CQUFvQixDQUFDO01BRTFGLE1BQU1LLGdCQUFnQixHQUFLSCw2QkFBNkIsQ0FBQ0ksTUFBTSxLQUFLLENBQUMsSUFDMUNGLDZCQUE2QixDQUFDRSxNQUFNLEtBQUssQ0FBQyxJQUMxQ3hDLElBQUksQ0FBQ3lDLEdBQUcsQ0FBRUwsNkJBQTZCLENBQUUsQ0FBQyxDQUFFLEdBQUdFLDZCQUE2QixDQUFFLENBQUMsQ0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDVixzQkFBc0IsSUFFakhRLDZCQUE2QixDQUFDSSxNQUFNLEtBQUssQ0FBQyxJQUMxQ0YsNkJBQTZCLENBQUNFLE1BQU0sS0FBSyxDQUFDLElBQzFDSiw2QkFBNkIsQ0FBRSxDQUFDLENBQUUsS0FBS0UsNkJBQTZCLENBQUUsQ0FBQyxDQUFFLElBQ3pFRiw2QkFBNkIsQ0FBRSxDQUFDLENBQUUsS0FBS0UsNkJBQTZCLENBQUUsQ0FBQyxDQUN4RSxJQUVDRiw2QkFBNkIsQ0FBQ0ksTUFBTSxLQUFLLENBQUMsSUFDMUNGLDZCQUE2QixDQUFDRSxNQUFNLEtBQUssQ0FBQyxJQUMxQ0YsNkJBQTZCLENBQUUsQ0FBQyxDQUFFLEtBQUtGLDZCQUE2QixDQUFFLENBQUMsQ0FBRSxJQUN6RUUsNkJBQTZCLENBQUUsQ0FBQyxDQUFFLEtBQUtGLDZCQUE2QixDQUFFLENBQUMsQ0FDeEUsSUFFQ0EsNkJBQTZCLENBQUNJLE1BQU0sS0FBSyxDQUFDLElBQzFDRiw2QkFBNkIsQ0FBQ0UsTUFBTSxLQUFLLENBQUMsSUFDMUNGLDZCQUE2QixDQUFFLENBQUMsQ0FBRSxLQUFLRiw2QkFBNkIsQ0FBRSxDQUFDLENBQ3hFO01BQzFCLE1BQU1NLGdCQUFnQixHQUFHSiw2QkFBNkIsQ0FBQ0UsTUFBTSxLQUFLLENBQUMsS0FDeENKLDZCQUE2QixDQUFDSSxNQUFNLEtBQUssQ0FBQyxJQUMxQ0osNkJBQTZCLENBQUUsQ0FBQyxDQUFFLEtBQUtFLDZCQUE2QixDQUFFLENBQUMsQ0FBRSxDQUFFO01BRXRHLElBQUtDLGdCQUFnQixJQUNoQkcsZ0JBQWdCLElBQ2hCUixtQkFBbUIsS0FBSyxJQUFJLENBQUNyQixVQUFVLENBQUM4QixHQUFHLElBQzNDVCxtQkFBbUIsS0FBSyxJQUFJLENBQUNyQixVQUFVLENBQUMrQixHQUFHLEVBQzlDO1FBQ0EsSUFBSSxDQUFDQyx1QkFBdUIsQ0FBRWIsUUFBUSxFQUFFQyxRQUFTLENBQUM7TUFDcEQ7SUFDRjtFQUNGOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ1NZLHVCQUF1QkEsQ0FBRWIsUUFBZ0IsRUFBRUMsUUFBZ0IsRUFBUztJQUN6RSxNQUFNQyxtQkFBbUIsR0FBRyxJQUFJLENBQUNaLGNBQWMsQ0FBRVUsUUFBUyxDQUFDO0lBQzNELE1BQU1HLG1CQUFtQixHQUFHLElBQUksQ0FBQ2IsY0FBYyxDQUFFVyxRQUFTLENBQUM7SUFDM0QsSUFBS0MsbUJBQW1CLEtBQUtDLG1CQUFtQixJQUN6Q0YsUUFBUSxLQUFLRCxRQUFRLEtBQU1BLFFBQVEsS0FBSyxJQUFJLENBQUNuQixVQUFVLENBQUM4QixHQUFHLElBQUlYLFFBQVEsS0FBSyxJQUFJLENBQUNuQixVQUFVLENBQUMrQixHQUFHLENBQUksRUFBRztNQUUzRyxJQUFLWixRQUFRLEtBQUssSUFBSSxDQUFDbkIsVUFBVSxDQUFDOEIsR0FBRyxJQUFJLElBQUksQ0FBQ3BCLGNBQWMsS0FBS1osc0JBQXNCLENBQUNtQyxnQkFBZ0IsRUFBRztRQUN6RyxJQUFJLENBQUN2QixjQUFjLENBQUN3QixJQUFJLENBQUMsQ0FBQztNQUM1QixDQUFDLE1BQ0ksSUFBS2YsUUFBUSxLQUFLLElBQUksQ0FBQ25CLFVBQVUsQ0FBQytCLEdBQUcsSUFBSSxJQUFJLENBQUNwQixjQUFjLEtBQUtiLHNCQUFzQixDQUFDbUMsZ0JBQWdCLEVBQUc7UUFDOUcsSUFBSSxDQUFDdEIsY0FBYyxDQUFDdUIsSUFBSSxDQUFDLENBQUM7TUFDNUIsQ0FBQyxNQUNJO1FBRUg7UUFDQSxNQUFNQyxHQUFHLEdBQUc1RCxnQkFBZ0IsQ0FBQzZELFdBQVc7UUFDeEMsSUFBS0QsR0FBRyxHQUFHLElBQUksQ0FBQ2xCLDJCQUEyQixHQUFHLElBQUksQ0FBQ0wsMkJBQTJCLEVBQUc7VUFDL0UsSUFBSXlCLGtCQUFrQjtVQUN0QixJQUFJQyxXQUFXO1VBQ2YsSUFBS2pCLG1CQUFtQixHQUFHQyxtQkFBbUIsRUFBRztZQUMvQ2Usa0JBQWtCLEdBQUcsSUFBSSxDQUFDaEMsZ0NBQWdDO1lBQzFEaUMsV0FBVyxHQUFHLElBQUksQ0FBQ25DLHlCQUF5QjtVQUM5QyxDQUFDLE1BQ0k7WUFDSGtDLGtCQUFrQixHQUFHLElBQUksQ0FBQ2hDLGdDQUFnQztZQUMxRGlDLFdBQVcsR0FBRyxJQUFJLENBQUNsQywyQkFBMkI7VUFDaEQ7VUFFQSxJQUFLaUMsa0JBQWtCLEtBQUsxQyx1QkFBdUIsRUFBRztZQUVwRDtZQUNBO1lBQ0UyQyxXQUFXLENBQWdCQyxlQUFlLENBQUVGLGtCQUFrQixDQUFFbEIsUUFBUyxDQUFFLENBQUM7VUFDaEY7VUFDQW1CLFdBQVcsQ0FBQ0osSUFBSSxDQUFDLENBQUM7VUFDbEIsSUFBSSxDQUFDakIsMkJBQTJCLEdBQUdrQixHQUFHO1FBQ3hDO01BQ0Y7SUFDRjtFQUNGOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ1VYLHdCQUF3QkEsQ0FBRS9CLEtBQWEsRUFBYTtJQUUxRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0rQyxnQkFBZ0IsR0FBRyxJQUFJO0lBRTdCLE1BQU1DLE9BQU8sR0FBR3RELElBQUksQ0FBQ3VELEtBQUssQ0FDeEJ2RSxLQUFLLENBQUN1QixlQUFlLENBQUUsQ0FBRUQsS0FBSyxHQUFHLElBQUksQ0FBQ08sVUFBVSxDQUFDOEIsR0FBRyxJQUFLLElBQUksQ0FBQ2Ysc0JBQXNCLEVBQUV5QixnQkFBaUIsQ0FDekcsQ0FBQztJQUVELE1BQU1HLGNBQWMsR0FBR3hFLEtBQUssQ0FBQ3VCLGVBQWUsQ0FDMUMrQyxPQUFPLEdBQUcsSUFBSSxDQUFDMUIsc0JBQXNCLEdBQUcsSUFBSSxDQUFDZixVQUFVLENBQUM4QixHQUFHLEVBQzNEVSxnQkFDRixDQUFDO0lBQ0QsTUFBTUksY0FBYyxHQUFHLENBQUVELGNBQWMsQ0FBRTtJQUN6QyxJQUFLQSxjQUFjLEtBQUtsRCxLQUFLLEVBQUc7TUFFOUI7TUFDQTtNQUNBLE1BQU1vRCxjQUFjLEdBQUcxRCxJQUFJLENBQUMyQyxHQUFHLENBQzdCM0QsS0FBSyxDQUFDdUIsZUFBZSxDQUFFaUQsY0FBYyxHQUFHLElBQUksQ0FBQzVCLHNCQUFzQixFQUFFeUIsZ0JBQWlCLENBQUMsRUFDdkYsSUFBSSxDQUFDeEMsVUFBVSxDQUFDK0IsR0FDbEIsQ0FBQzs7TUFFRDtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQSxJQUFLYyxjQUFjLEdBQUdGLGNBQWMsRUFBRztRQUNyQ0MsY0FBYyxDQUFDRSxJQUFJLENBQUVELGNBQWUsQ0FBQztNQUN2QztJQUNGO0lBQ0EsT0FBT0QsY0FBYztFQUN2Qjs7RUFFQTtBQUNGO0FBQ0E7RUFDRSxPQUF1QkcsUUFBUSxHQUFHLElBQUlqRCxzQkFBc0IsQ0FBRSxJQUFJNUIsS0FBSyxDQUFFLENBQUMsRUFBRSxDQUFFLENBQUMsRUFBRTtJQUMvRWlDLHlCQUF5QixFQUFFekIsZUFBZTtJQUMxQ2dDLGNBQWMsRUFBRWhDLGVBQWU7SUFDL0JpQyxjQUFjLEVBQUVqQztFQUNsQixDQUFFLENBQUM7O0VBRUg7QUFDRjtBQUNBO0FBQ0E7RUFDRSxPQUF1QnVELGdCQUFnQixHQUFpQjtJQUN0REMsSUFBSSxFQUFFdEMsMEJBQTBCO0lBQ2hDb0QsSUFBSSxFQUFFcEQ7RUFDUixDQUFDO0FBQ0g7QUFFQWpCLEtBQUssQ0FBQ3NFLFFBQVEsQ0FBRSx3QkFBd0IsRUFBRW5ELHNCQUF1QixDQUFDO0FBRWxFLGVBQWVBLHNCQUFzQiJ9