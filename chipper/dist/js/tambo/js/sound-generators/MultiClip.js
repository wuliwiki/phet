// Copyright 2019-2022, University of Colorado Boulder

/**
 * MultiClip is a sound generator that plays one-shot sounds from a set of pre-recorded files that are provided upon
 * construction. This is often used as a base class for a sound generator when a finite set of sounds clips need to be
 * played in response to different values of a model parameter.
 *
 * Individual gain controls are not provided for the different sound clips in this class, there is just a single gain
 * node for the sound generator as a whole.  The intent here is that this saves resources by not creating unneeded gain
 * nodes.  If such fine-grained control is needed, a similar type could be created using multiple instances of the
 * SoundClip class.
 *
 * This class only supports clips that are played as one shots, i.e. it does not include support for looping.
 *
 * @author John Blanco (PhET Interactive Simulations)
 */

import audioContextStateChangeMonitor from '../audioContextStateChangeMonitor.js';
import tambo from '../tambo.js';
import SoundGenerator from './SoundGenerator.js';
import optionize from '../../../phet-core/js/optionize.js';
// constants
const STOP_DELAY_TIME = 0.1; // empirically determined to avoid clicks when stopping sounds
const MAX_PLAY_DEFER_TIME = 0.2; // seconds, max time to defer a play request while waiting for audio context state change

class MultiClip extends SoundGenerator {
  // buffer sources that are currently playing, used if they need to be stopped early

  // map that associates values with audio buffers

  // a gain node that is used to prevent clicks when stopping the sounds

  // playback rate used for all clips

  // a listener for implementing deferred play requests, see usage for details

  // time at which a deferred play request occurred, in milliseconds since epoch

  /**
   * @param valueToWrappedAudioBufferMap - a map of values to Web Audio AudioBuffer objects that is used to associate
   * each item in a set of values with a sound. The object defines a method that can then be used to play the sound
   * associated with the value.
   * @param [providedOptions]
   */
  constructor(valueToWrappedAudioBufferMap, providedOptions) {
    const options = optionize()({
      initialPlaybackRate: 1
    }, providedOptions);
    super(options);
    this.activeBufferSources = [];
    this.valueToWrappedAudioBufferMap = valueToWrappedAudioBufferMap;

    // initialize the local gain node
    this.localGainNode = this.audioContext.createGain();
    this.localGainNode.connect(this.soundSourceDestination);

    // listen to the Property that indicates whether we are fully enabled and stop sounds if and when it goes false
    this.fullyEnabledProperty.lazyLink(fullyEnabled => {
      if (!fullyEnabled) {
        this.stopAll();
      }
    });
    this.playbackRate = options.initialPlaybackRate === undefined ? 1 : options.initialPlaybackRate;
    this.audioContextStateChangeListener = null;
    this.timeOfDeferredPlayRequest = Number.NEGATIVE_INFINITY;
  }

  /**
   * play the sound associated with the provided value
   */
  playAssociatedSound(value, delay = 0) {
    // get the audio buffer for this value
    const wrappedAudioBuffer = this.valueToWrappedAudioBufferMap.get(value);

    // verify that we have a sound for the provided value
    assert && assert(wrappedAudioBuffer !== undefined, 'no sound found for provided value');
    if (this.audioContext.state === 'running') {
      // play the sound (if enabled and fully decoded)
      if (this.fullyEnabled && wrappedAudioBuffer.audioBufferProperty.value) {
        const now = this.audioContext.currentTime;

        // make sure the local gain is set to unity value
        this.localGainNode.gain.cancelScheduledValues(now);
        this.localGainNode.gain.setValueAtTime(1, now);

        // create an audio buffer source node and connect it to the previously data in the audio buffer
        const bufferSource = this.audioContext.createBufferSource();
        bufferSource.buffer = wrappedAudioBuffer.audioBufferProperty.value;
        bufferSource.playbackRate.setValueAtTime(this.playbackRate, this.audioContext.currentTime);

        // connect this source node to the output
        bufferSource.connect(this.localGainNode);

        // add this to the list of active sources so that it can be stopped if necessary
        this.activeBufferSources.push(bufferSource);

        // add a handler for when the sound finishes playing
        bufferSource.onended = () => {
          // remove the source from the list of active sources
          const indexOfSource = this.activeBufferSources.indexOf(bufferSource);
          if (indexOfSource > -1) {
            this.activeBufferSources.splice(indexOfSource, 1);
          }
        };

        // start the playback of the sound
        bufferSource.start(now + delay);
      }
    } else {
      // This method was called while the sound context was not yet running.  This can happen if the method is called
      // due to the first interaction from the user, and also during fuzz testing.

      // Remove previous listener if present.
      if (this.audioContextStateChangeListener) {
        audioContextStateChangeMonitor.removeStateChangeListener(this.audioContext, this.audioContextStateChangeListener);
      }

      // Create and add a listener to play the specified sound when the audio context changes to the 'running' state.
      this.timeOfDeferredPlayRequest = Date.now();
      this.audioContextStateChangeListener = () => {
        // Only play the sound if it hasn't been too long, otherwise it may be irrelevant.
        if ((Date.now() - this.timeOfDeferredPlayRequest) / 1000 < MAX_PLAY_DEFER_TIME) {
          // Play the sound, but delayed a little bit so that the gain nodes can be fully turned up in time.
          this.playAssociatedSound(value, 0.1);
        }
        audioContextStateChangeMonitor.removeStateChangeListener(this.audioContext, this.audioContextStateChangeListener);
        this.audioContextStateChangeListener = null;
      };
      audioContextStateChangeMonitor.addStateChangeListener(this.audioContext, this.audioContextStateChangeListener);
    }
  }

  /**
   * Change the speed that the sound playback occurs. Note, this does not affect playing sounds, but will only affect
   * subsequent plays of sounds.
   * @param playbackRate - desired playback speed, 1 = normal speed
   */
  setPlaybackRate(playbackRate) {
    this.playbackRate = playbackRate;
  }

  /**
   * Stop playing any sounds that are currently in progress.
   */
  stopAll() {
    // Simply calling stop() on the buffer source frequently causes an audible click, so we use a gain node and turn
    // down the gain, effectively doing a fade out, before stopping playback.
    const stopTime = this.audioContext.currentTime + STOP_DELAY_TIME;
    this.localGainNode.gain.linearRampToValueAtTime(0, stopTime);
    this.activeBufferSources.forEach(source => {
      source.stop(stopTime);
    });

    // The WebAudio spec is a bit unclear about whether stopping a sound will trigger an onended event.  In testing
    // on Chrome in September 2018, I (jbphet) found that onended was NOT being fired when stop() was called, so the
    // code below is needed to clear the array of all active buffer sources.
    this.activeBufferSources.length = 0;
  }
}
tambo.register('MultiClip', MultiClip);
export default MultiClip;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhdWRpb0NvbnRleHRTdGF0ZUNoYW5nZU1vbml0b3IiLCJ0YW1ibyIsIlNvdW5kR2VuZXJhdG9yIiwib3B0aW9uaXplIiwiU1RPUF9ERUxBWV9USU1FIiwiTUFYX1BMQVlfREVGRVJfVElNRSIsIk11bHRpQ2xpcCIsImNvbnN0cnVjdG9yIiwidmFsdWVUb1dyYXBwZWRBdWRpb0J1ZmZlck1hcCIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJpbml0aWFsUGxheWJhY2tSYXRlIiwiYWN0aXZlQnVmZmVyU291cmNlcyIsImxvY2FsR2Fpbk5vZGUiLCJhdWRpb0NvbnRleHQiLCJjcmVhdGVHYWluIiwiY29ubmVjdCIsInNvdW5kU291cmNlRGVzdGluYXRpb24iLCJmdWxseUVuYWJsZWRQcm9wZXJ0eSIsImxhenlMaW5rIiwiZnVsbHlFbmFibGVkIiwic3RvcEFsbCIsInBsYXliYWNrUmF0ZSIsInVuZGVmaW5lZCIsImF1ZGlvQ29udGV4dFN0YXRlQ2hhbmdlTGlzdGVuZXIiLCJ0aW1lT2ZEZWZlcnJlZFBsYXlSZXF1ZXN0IiwiTnVtYmVyIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJwbGF5QXNzb2NpYXRlZFNvdW5kIiwidmFsdWUiLCJkZWxheSIsIndyYXBwZWRBdWRpb0J1ZmZlciIsImdldCIsImFzc2VydCIsInN0YXRlIiwiYXVkaW9CdWZmZXJQcm9wZXJ0eSIsIm5vdyIsImN1cnJlbnRUaW1lIiwiZ2FpbiIsImNhbmNlbFNjaGVkdWxlZFZhbHVlcyIsInNldFZhbHVlQXRUaW1lIiwiYnVmZmVyU291cmNlIiwiY3JlYXRlQnVmZmVyU291cmNlIiwiYnVmZmVyIiwicHVzaCIsIm9uZW5kZWQiLCJpbmRleE9mU291cmNlIiwiaW5kZXhPZiIsInNwbGljZSIsInN0YXJ0IiwicmVtb3ZlU3RhdGVDaGFuZ2VMaXN0ZW5lciIsIkRhdGUiLCJhZGRTdGF0ZUNoYW5nZUxpc3RlbmVyIiwic2V0UGxheWJhY2tSYXRlIiwic3RvcFRpbWUiLCJsaW5lYXJSYW1wVG9WYWx1ZUF0VGltZSIsImZvckVhY2giLCJzb3VyY2UiLCJzdG9wIiwibGVuZ3RoIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJNdWx0aUNsaXAudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogTXVsdGlDbGlwIGlzIGEgc291bmQgZ2VuZXJhdG9yIHRoYXQgcGxheXMgb25lLXNob3Qgc291bmRzIGZyb20gYSBzZXQgb2YgcHJlLXJlY29yZGVkIGZpbGVzIHRoYXQgYXJlIHByb3ZpZGVkIHVwb25cclxuICogY29uc3RydWN0aW9uLiBUaGlzIGlzIG9mdGVuIHVzZWQgYXMgYSBiYXNlIGNsYXNzIGZvciBhIHNvdW5kIGdlbmVyYXRvciB3aGVuIGEgZmluaXRlIHNldCBvZiBzb3VuZHMgY2xpcHMgbmVlZCB0byBiZVxyXG4gKiBwbGF5ZWQgaW4gcmVzcG9uc2UgdG8gZGlmZmVyZW50IHZhbHVlcyBvZiBhIG1vZGVsIHBhcmFtZXRlci5cclxuICpcclxuICogSW5kaXZpZHVhbCBnYWluIGNvbnRyb2xzIGFyZSBub3QgcHJvdmlkZWQgZm9yIHRoZSBkaWZmZXJlbnQgc291bmQgY2xpcHMgaW4gdGhpcyBjbGFzcywgdGhlcmUgaXMganVzdCBhIHNpbmdsZSBnYWluXHJcbiAqIG5vZGUgZm9yIHRoZSBzb3VuZCBnZW5lcmF0b3IgYXMgYSB3aG9sZS4gIFRoZSBpbnRlbnQgaGVyZSBpcyB0aGF0IHRoaXMgc2F2ZXMgcmVzb3VyY2VzIGJ5IG5vdCBjcmVhdGluZyB1bm5lZWRlZCBnYWluXHJcbiAqIG5vZGVzLiAgSWYgc3VjaCBmaW5lLWdyYWluZWQgY29udHJvbCBpcyBuZWVkZWQsIGEgc2ltaWxhciB0eXBlIGNvdWxkIGJlIGNyZWF0ZWQgdXNpbmcgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHRoZVxyXG4gKiBTb3VuZENsaXAgY2xhc3MuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3Mgb25seSBzdXBwb3J0cyBjbGlwcyB0aGF0IGFyZSBwbGF5ZWQgYXMgb25lIHNob3RzLCBpLmUuIGl0IGRvZXMgbm90IGluY2x1ZGUgc3VwcG9ydCBmb3IgbG9vcGluZy5cclxuICpcclxuICogQGF1dGhvciBKb2huIEJsYW5jbyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VNb25pdG9yIGZyb20gJy4uL2F1ZGlvQ29udGV4dFN0YXRlQ2hhbmdlTW9uaXRvci5qcyc7XHJcbmltcG9ydCB0YW1ibyBmcm9tICcuLi90YW1iby5qcyc7XHJcbmltcG9ydCBTb3VuZEdlbmVyYXRvciwgeyBTb3VuZEdlbmVyYXRvck9wdGlvbnMgfSBmcm9tICcuL1NvdW5kR2VuZXJhdG9yLmpzJztcclxuaW1wb3J0IFdyYXBwZWRBdWRpb0J1ZmZlciBmcm9tICcuLi9XcmFwcGVkQXVkaW9CdWZmZXIuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuICBpbml0aWFsUGxheWJhY2tSYXRlPzogbnVtYmVyO1xyXG59O1xyXG5leHBvcnQgdHlwZSBNdWx0aUNsaXBPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBTb3VuZEdlbmVyYXRvck9wdGlvbnM7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgU1RPUF9ERUxBWV9USU1FID0gMC4xOyAvLyBlbXBpcmljYWxseSBkZXRlcm1pbmVkIHRvIGF2b2lkIGNsaWNrcyB3aGVuIHN0b3BwaW5nIHNvdW5kc1xyXG5jb25zdCBNQVhfUExBWV9ERUZFUl9USU1FID0gMC4yOyAvLyBzZWNvbmRzLCBtYXggdGltZSB0byBkZWZlciBhIHBsYXkgcmVxdWVzdCB3aGlsZSB3YWl0aW5nIGZvciBhdWRpbyBjb250ZXh0IHN0YXRlIGNoYW5nZVxyXG5cclxuY2xhc3MgTXVsdGlDbGlwPFQ+IGV4dGVuZHMgU291bmRHZW5lcmF0b3Ige1xyXG5cclxuICAvLyBidWZmZXIgc291cmNlcyB0aGF0IGFyZSBjdXJyZW50bHkgcGxheWluZywgdXNlZCBpZiB0aGV5IG5lZWQgdG8gYmUgc3RvcHBlZCBlYXJseVxyXG4gIHByaXZhdGUgcmVhZG9ubHkgYWN0aXZlQnVmZmVyU291cmNlczogQXVkaW9CdWZmZXJTb3VyY2VOb2RlW107XHJcblxyXG4gIC8vIG1hcCB0aGF0IGFzc29jaWF0ZXMgdmFsdWVzIHdpdGggYXVkaW8gYnVmZmVyc1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgdmFsdWVUb1dyYXBwZWRBdWRpb0J1ZmZlck1hcDogTWFwPFQsIFdyYXBwZWRBdWRpb0J1ZmZlcj47XHJcblxyXG4gIC8vIGEgZ2FpbiBub2RlIHRoYXQgaXMgdXNlZCB0byBwcmV2ZW50IGNsaWNrcyB3aGVuIHN0b3BwaW5nIHRoZSBzb3VuZHNcclxuICBwcml2YXRlIHJlYWRvbmx5IGxvY2FsR2Fpbk5vZGU6IEdhaW5Ob2RlO1xyXG5cclxuICAvLyBwbGF5YmFjayByYXRlIHVzZWQgZm9yIGFsbCBjbGlwc1xyXG4gIHByaXZhdGUgcGxheWJhY2tSYXRlOiBudW1iZXI7XHJcblxyXG4gIC8vIGEgbGlzdGVuZXIgZm9yIGltcGxlbWVudGluZyBkZWZlcnJlZCBwbGF5IHJlcXVlc3RzLCBzZWUgdXNhZ2UgZm9yIGRldGFpbHNcclxuICBwcml2YXRlIGF1ZGlvQ29udGV4dFN0YXRlQ2hhbmdlTGlzdGVuZXI6IG51bGwgfCAoICggc3RhdGU6IHN0cmluZyApID0+IHZvaWQgKTtcclxuXHJcbiAgLy8gdGltZSBhdCB3aGljaCBhIGRlZmVycmVkIHBsYXkgcmVxdWVzdCBvY2N1cnJlZCwgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoXHJcbiAgcHJpdmF0ZSB0aW1lT2ZEZWZlcnJlZFBsYXlSZXF1ZXN0OiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB2YWx1ZVRvV3JhcHBlZEF1ZGlvQnVmZmVyTWFwIC0gYSBtYXAgb2YgdmFsdWVzIHRvIFdlYiBBdWRpbyBBdWRpb0J1ZmZlciBvYmplY3RzIHRoYXQgaXMgdXNlZCB0byBhc3NvY2lhdGVcclxuICAgKiBlYWNoIGl0ZW0gaW4gYSBzZXQgb2YgdmFsdWVzIHdpdGggYSBzb3VuZC4gVGhlIG9iamVjdCBkZWZpbmVzIGEgbWV0aG9kIHRoYXQgY2FuIHRoZW4gYmUgdXNlZCB0byBwbGF5IHRoZSBzb3VuZFxyXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmFsdWUuXHJcbiAgICogQHBhcmFtIFtwcm92aWRlZE9wdGlvbnNdXHJcbiAgICovXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCB2YWx1ZVRvV3JhcHBlZEF1ZGlvQnVmZmVyTWFwOiBNYXA8VCwgV3JhcHBlZEF1ZGlvQnVmZmVyPiwgcHJvdmlkZWRPcHRpb25zPzogTXVsdGlDbGlwT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPE11bHRpQ2xpcE9wdGlvbnMsIFNlbGZPcHRpb25zLCBNdWx0aUNsaXBPcHRpb25zPigpKCB7XHJcbiAgICAgIGluaXRpYWxQbGF5YmFja1JhdGU6IDFcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy5hY3RpdmVCdWZmZXJTb3VyY2VzID0gW107XHJcbiAgICB0aGlzLnZhbHVlVG9XcmFwcGVkQXVkaW9CdWZmZXJNYXAgPSB2YWx1ZVRvV3JhcHBlZEF1ZGlvQnVmZmVyTWFwO1xyXG5cclxuICAgIC8vIGluaXRpYWxpemUgdGhlIGxvY2FsIGdhaW4gbm9kZVxyXG4gICAgdGhpcy5sb2NhbEdhaW5Ob2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgdGhpcy5sb2NhbEdhaW5Ob2RlLmNvbm5lY3QoIHRoaXMuc291bmRTb3VyY2VEZXN0aW5hdGlvbiApO1xyXG5cclxuICAgIC8vIGxpc3RlbiB0byB0aGUgUHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZSBhcmUgZnVsbHkgZW5hYmxlZCBhbmQgc3RvcCBzb3VuZHMgaWYgYW5kIHdoZW4gaXQgZ29lcyBmYWxzZVxyXG4gICAgdGhpcy5mdWxseUVuYWJsZWRQcm9wZXJ0eS5sYXp5TGluayggZnVsbHlFbmFibGVkID0+IHtcclxuICAgICAgaWYgKCAhZnVsbHlFbmFibGVkICkge1xyXG4gICAgICAgIHRoaXMuc3RvcEFsbCgpO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy5wbGF5YmFja1JhdGUgPSAoIG9wdGlvbnMuaW5pdGlhbFBsYXliYWNrUmF0ZSA9PT0gdW5kZWZpbmVkICkgPyAxIDogb3B0aW9ucy5pbml0aWFsUGxheWJhY2tSYXRlO1xyXG4gICAgdGhpcy5hdWRpb0NvbnRleHRTdGF0ZUNoYW5nZUxpc3RlbmVyID0gbnVsbDtcclxuICAgIHRoaXMudGltZU9mRGVmZXJyZWRQbGF5UmVxdWVzdCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHBsYXkgdGhlIHNvdW5kIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWVcclxuICAgKi9cclxuICBwdWJsaWMgcGxheUFzc29jaWF0ZWRTb3VuZCggdmFsdWU6IFQsIGRlbGF5ID0gMCApOiB2b2lkIHtcclxuXHJcbiAgICAvLyBnZXQgdGhlIGF1ZGlvIGJ1ZmZlciBmb3IgdGhpcyB2YWx1ZVxyXG4gICAgY29uc3Qgd3JhcHBlZEF1ZGlvQnVmZmVyID0gdGhpcy52YWx1ZVRvV3JhcHBlZEF1ZGlvQnVmZmVyTWFwLmdldCggdmFsdWUgKTtcclxuXHJcbiAgICAvLyB2ZXJpZnkgdGhhdCB3ZSBoYXZlIGEgc291bmQgZm9yIHRoZSBwcm92aWRlZCB2YWx1ZVxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggd3JhcHBlZEF1ZGlvQnVmZmVyICE9PSB1bmRlZmluZWQsICdubyBzb3VuZCBmb3VuZCBmb3IgcHJvdmlkZWQgdmFsdWUnICk7XHJcblxyXG4gICAgaWYgKCB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3J1bm5pbmcnICkge1xyXG5cclxuICAgICAgLy8gcGxheSB0aGUgc291bmQgKGlmIGVuYWJsZWQgYW5kIGZ1bGx5IGRlY29kZWQpXHJcbiAgICAgIGlmICggdGhpcy5mdWxseUVuYWJsZWQgJiYgd3JhcHBlZEF1ZGlvQnVmZmVyIS5hdWRpb0J1ZmZlclByb3BlcnR5LnZhbHVlICkge1xyXG5cclxuICAgICAgICBjb25zdCBub3cgPSB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcclxuXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBsb2NhbCBnYWluIGlzIHNldCB0byB1bml0eSB2YWx1ZVxyXG4gICAgICAgIHRoaXMubG9jYWxHYWluTm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyggbm93ICk7XHJcbiAgICAgICAgdGhpcy5sb2NhbEdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoIDEsIG5vdyApO1xyXG5cclxuICAgICAgICAvLyBjcmVhdGUgYW4gYXVkaW8gYnVmZmVyIHNvdXJjZSBub2RlIGFuZCBjb25uZWN0IGl0IHRvIHRoZSBwcmV2aW91c2x5IGRhdGEgaW4gdGhlIGF1ZGlvIGJ1ZmZlclxyXG4gICAgICAgIGNvbnN0IGJ1ZmZlclNvdXJjZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG4gICAgICAgIGJ1ZmZlclNvdXJjZS5idWZmZXIgPSB3cmFwcGVkQXVkaW9CdWZmZXIhLmF1ZGlvQnVmZmVyUHJvcGVydHkudmFsdWU7XHJcbiAgICAgICAgYnVmZmVyU291cmNlLnBsYXliYWNrUmF0ZS5zZXRWYWx1ZUF0VGltZSggdGhpcy5wbGF5YmFja1JhdGUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICk7XHJcblxyXG4gICAgICAgIC8vIGNvbm5lY3QgdGhpcyBzb3VyY2Ugbm9kZSB0byB0aGUgb3V0cHV0XHJcbiAgICAgICAgYnVmZmVyU291cmNlLmNvbm5lY3QoIHRoaXMubG9jYWxHYWluTm9kZSApO1xyXG5cclxuICAgICAgICAvLyBhZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBhY3RpdmUgc291cmNlcyBzbyB0aGF0IGl0IGNhbiBiZSBzdG9wcGVkIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIHRoaXMuYWN0aXZlQnVmZmVyU291cmNlcy5wdXNoKCBidWZmZXJTb3VyY2UgKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGEgaGFuZGxlciBmb3Igd2hlbiB0aGUgc291bmQgZmluaXNoZXMgcGxheWluZ1xyXG4gICAgICAgIGJ1ZmZlclNvdXJjZS5vbmVuZGVkID0gKCkgPT4ge1xyXG5cclxuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc291cmNlIGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIHNvdXJjZXNcclxuICAgICAgICAgIGNvbnN0IGluZGV4T2ZTb3VyY2UgPSB0aGlzLmFjdGl2ZUJ1ZmZlclNvdXJjZXMuaW5kZXhPZiggYnVmZmVyU291cmNlICk7XHJcbiAgICAgICAgICBpZiAoIGluZGV4T2ZTb3VyY2UgPiAtMSApIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVCdWZmZXJTb3VyY2VzLnNwbGljZSggaW5kZXhPZlNvdXJjZSwgMSApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIHN0YXJ0IHRoZSBwbGF5YmFjayBvZiB0aGUgc291bmRcclxuICAgICAgICBidWZmZXJTb3VyY2Uuc3RhcnQoIG5vdyArIGRlbGF5ICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgLy8gVGhpcyBtZXRob2Qgd2FzIGNhbGxlZCB3aGlsZSB0aGUgc291bmQgY29udGV4dCB3YXMgbm90IHlldCBydW5uaW5nLiAgVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkXHJcbiAgICAgIC8vIGR1ZSB0byB0aGUgZmlyc3QgaW50ZXJhY3Rpb24gZnJvbSB0aGUgdXNlciwgYW5kIGFsc28gZHVyaW5nIGZ1enogdGVzdGluZy5cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBsaXN0ZW5lciBpZiBwcmVzZW50LlxyXG4gICAgICBpZiAoIHRoaXMuYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VMaXN0ZW5lciApIHtcclxuICAgICAgICBhdWRpb0NvbnRleHRTdGF0ZUNoYW5nZU1vbml0b3IucmVtb3ZlU3RhdGVDaGFuZ2VMaXN0ZW5lciggdGhpcy5hdWRpb0NvbnRleHQsIHRoaXMuYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VMaXN0ZW5lciApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDcmVhdGUgYW5kIGFkZCBhIGxpc3RlbmVyIHRvIHBsYXkgdGhlIHNwZWNpZmllZCBzb3VuZCB3aGVuIHRoZSBhdWRpbyBjb250ZXh0IGNoYW5nZXMgdG8gdGhlICdydW5uaW5nJyBzdGF0ZS5cclxuICAgICAgdGhpcy50aW1lT2ZEZWZlcnJlZFBsYXlSZXF1ZXN0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgdGhpcy5hdWRpb0NvbnRleHRTdGF0ZUNoYW5nZUxpc3RlbmVyID0gKCkgPT4ge1xyXG5cclxuICAgICAgICAvLyBPbmx5IHBsYXkgdGhlIHNvdW5kIGlmIGl0IGhhc24ndCBiZWVuIHRvbyBsb25nLCBvdGhlcndpc2UgaXQgbWF5IGJlIGlycmVsZXZhbnQuXHJcbiAgICAgICAgaWYgKCAoIERhdGUubm93KCkgLSB0aGlzLnRpbWVPZkRlZmVycmVkUGxheVJlcXVlc3QgKSAvIDEwMDAgPCBNQVhfUExBWV9ERUZFUl9USU1FICkge1xyXG5cclxuICAgICAgICAgIC8vIFBsYXkgdGhlIHNvdW5kLCBidXQgZGVsYXllZCBhIGxpdHRsZSBiaXQgc28gdGhhdCB0aGUgZ2FpbiBub2RlcyBjYW4gYmUgZnVsbHkgdHVybmVkIHVwIGluIHRpbWUuXHJcbiAgICAgICAgICB0aGlzLnBsYXlBc3NvY2lhdGVkU291bmQoIHZhbHVlLCAwLjEgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VNb25pdG9yLnJlbW92ZVN0YXRlQ2hhbmdlTGlzdGVuZXIoXHJcbiAgICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCxcclxuICAgICAgICAgIHRoaXMuYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VMaXN0ZW5lciFcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgIH07XHJcbiAgICAgIGF1ZGlvQ29udGV4dFN0YXRlQ2hhbmdlTW9uaXRvci5hZGRTdGF0ZUNoYW5nZUxpc3RlbmVyKFxyXG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LFxyXG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0U3RhdGVDaGFuZ2VMaXN0ZW5lclxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hhbmdlIHRoZSBzcGVlZCB0aGF0IHRoZSBzb3VuZCBwbGF5YmFjayBvY2N1cnMuIE5vdGUsIHRoaXMgZG9lcyBub3QgYWZmZWN0IHBsYXlpbmcgc291bmRzLCBidXQgd2lsbCBvbmx5IGFmZmVjdFxyXG4gICAqIHN1YnNlcXVlbnQgcGxheXMgb2Ygc291bmRzLlxyXG4gICAqIEBwYXJhbSBwbGF5YmFja1JhdGUgLSBkZXNpcmVkIHBsYXliYWNrIHNwZWVkLCAxID0gbm9ybWFsIHNwZWVkXHJcbiAgICovXHJcbiAgcHVibGljIHNldFBsYXliYWNrUmF0ZSggcGxheWJhY2tSYXRlOiBudW1iZXIgKTogdm9pZCB7XHJcbiAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgcGxheWluZyBhbnkgc291bmRzIHRoYXQgYXJlIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cclxuICAgKi9cclxuICBwdWJsaWMgc3RvcEFsbCgpOiB2b2lkIHtcclxuXHJcbiAgICAvLyBTaW1wbHkgY2FsbGluZyBzdG9wKCkgb24gdGhlIGJ1ZmZlciBzb3VyY2UgZnJlcXVlbnRseSBjYXVzZXMgYW4gYXVkaWJsZSBjbGljaywgc28gd2UgdXNlIGEgZ2FpbiBub2RlIGFuZCB0dXJuXHJcbiAgICAvLyBkb3duIHRoZSBnYWluLCBlZmZlY3RpdmVseSBkb2luZyBhIGZhZGUgb3V0LCBiZWZvcmUgc3RvcHBpbmcgcGxheWJhY2suXHJcbiAgICBjb25zdCBzdG9wVGltZSA9IHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgU1RPUF9ERUxBWV9USU1FO1xyXG4gICAgdGhpcy5sb2NhbEdhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIDAsIHN0b3BUaW1lICk7XHJcbiAgICB0aGlzLmFjdGl2ZUJ1ZmZlclNvdXJjZXMuZm9yRWFjaCggc291cmNlID0+IHsgc291cmNlLnN0b3AoIHN0b3BUaW1lICk7IH0gKTtcclxuXHJcbiAgICAvLyBUaGUgV2ViQXVkaW8gc3BlYyBpcyBhIGJpdCB1bmNsZWFyIGFib3V0IHdoZXRoZXIgc3RvcHBpbmcgYSBzb3VuZCB3aWxsIHRyaWdnZXIgYW4gb25lbmRlZCBldmVudC4gIEluIHRlc3RpbmdcclxuICAgIC8vIG9uIENocm9tZSBpbiBTZXB0ZW1iZXIgMjAxOCwgSSAoamJwaGV0KSBmb3VuZCB0aGF0IG9uZW5kZWQgd2FzIE5PVCBiZWluZyBmaXJlZCB3aGVuIHN0b3AoKSB3YXMgY2FsbGVkLCBzbyB0aGVcclxuICAgIC8vIGNvZGUgYmVsb3cgaXMgbmVlZGVkIHRvIGNsZWFyIHRoZSBhcnJheSBvZiBhbGwgYWN0aXZlIGJ1ZmZlciBzb3VyY2VzLlxyXG4gICAgdGhpcy5hY3RpdmVCdWZmZXJTb3VyY2VzLmxlbmd0aCA9IDA7XHJcbiAgfVxyXG59XHJcblxyXG50YW1iby5yZWdpc3RlciggJ011bHRpQ2xpcCcsIE11bHRpQ2xpcCApO1xyXG5leHBvcnQgZGVmYXVsdCBNdWx0aUNsaXA7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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