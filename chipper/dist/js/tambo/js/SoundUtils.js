// Copyright 2018-2022, University of Colorado Boulder

/**
 * a singleton object with functions for analyzing and manipulating sound data
 */

import tambo from './tambo.js';

// a type that contains information about where the audible sounds begin and end within an audio buffer

// This threshold is used for analyzing individual decoded sound samples in order to find where the actual sound
// values start and end.  Its value was determined through experimentation on a single loop (charges-in-body) at a
// number of different encodings.  It may need to be refined over time as we add new sounds.  Or it may work perfectly
// forever (one can only hope).  See https://github.com/phetsims/tambo/issues/35.
const AUDIO_DATA_THRESHOLD = 0.05;

/**
 * sound utility object definition
 */
const SoundUtils = {
  /**
   * Detect the start and end points of a sound within and AudioBuffer based on the points where the samples exceed a
   * predetermined threshold.
   */
  detectSoundBounds: audioBuffer => {
    const soundDataLength = audioBuffer.length;
    const soundStartIndexes = [];
    const soundEndIndexes = [];

    // analyze each channel of the sound data
    for (let channelNumber = 0; channelNumber < audioBuffer.numberOfChannels; channelNumber++) {
      // initialize some variables that will be used to analyze the data
      const soundData = audioBuffer.getChannelData(channelNumber);

      // find where the sound first exceeds the threshold
      soundStartIndexes[channelNumber] = findSoundStartIndex(soundData, soundDataLength, AUDIO_DATA_THRESHOLD);

      // find the last point at which the sound exceeds the threshold, then go a little past
      soundEndIndexes[channelNumber] = findSoundEndIndex(soundData, soundDataLength, AUDIO_DATA_THRESHOLD);
    }

    // return an object with values for where the loop should start and end
    const sampleRate = audioBuffer.sampleRate;
    return {
      soundStart: _.min(soundStartIndexes) / sampleRate,
      soundEnd: _.max(soundEndIndexes) / sampleRate
    };
  }
};

/**
 * Find the index in the provided audio buffer where the sound begins, i.e. find the end of any leading silence.
 * @param soundData - sound data to be analyzed
 * @param length - length of the sound data
 * @param threshold - detection level for initial sound, should be between 0 and 1
 * @returns index where sound can be considered to start
 */
const findSoundStartIndex = (soundData, length, threshold) => {
  // find the first occurrence of the threshold that is trending in the up direction
  let startThresholdIndex = 0;
  let dataIndex;
  let found = false;
  for (dataIndex = 0; dataIndex < length - 1 && !found; dataIndex++) {
    if (soundData[dataIndex] > threshold && soundData[dataIndex + 1] > soundData[dataIndex]) {
      startThresholdIndex = dataIndex;
      found = true;
    }
  }

  // work backwards from the first threshold found to find the first zero or zero crossing
  let soundStartIndex = 0;
  found = false;
  for (dataIndex = startThresholdIndex; dataIndex > 0 && !found; dataIndex--) {
    const value = soundData[dataIndex];
    if (value <= 0) {
      soundStartIndex = value === 0 ? dataIndex : dataIndex + 1;
      found = true;
    }
  }

  // detect and log the peaks in the pre-start data, useful for determining what the threshold value should be
  let maxPreStartPeak = 0;
  let minPreStartPeak = 0;
  for (dataIndex = 0; dataIndex < soundStartIndex; dataIndex++) {
    maxPreStartPeak = Math.max(maxPreStartPeak, soundData[dataIndex]);
    minPreStartPeak = Math.min(minPreStartPeak, soundData[dataIndex]);
  }
  return soundStartIndex;
};

/**
 * Find the index in the provided sound data where the sound can be considered to end, meaning that there is only
 * silence or very little sound energy thereafter.
 * @param soundData - the sample values for the sound
 * @param length - length of the sound data
 * @param threshold - detection level for the presence of sound, should be between 0 and 1
 */
const findSoundEndIndex = (soundData, length, threshold) => {
  // work backwards from the end of the data to find the first negative occurance of the threshold
  let endThresholdIndex = length - 1;
  let found = false;
  let dataIndex;
  for (dataIndex = length - 1; dataIndex > 0 && !found; dataIndex--) {
    if (soundData[dataIndex] <= -threshold && soundData[dataIndex - 1] < soundData[dataIndex]) {
      endThresholdIndex = dataIndex;
      found = true;
    }
  }

  // work forward from the end threshold to find a zero or zero crossing that can work as the end of the loop
  let soundEndIndex = endThresholdIndex;
  found = false;
  for (dataIndex = endThresholdIndex; dataIndex < length - 1 && !found; dataIndex++) {
    if (soundData[dataIndex + 1] >= 0) {
      soundEndIndex = dataIndex;
      found = true;
    }
  }

  // detect and log the peaks in the post-end data, useful for determining what the threshold value should be
  let maxPostEndPeak = 0;
  let minPostEndPeak = 0;
  for (dataIndex = soundEndIndex; dataIndex < length; dataIndex++) {
    maxPostEndPeak = Math.max(maxPostEndPeak, soundData[dataIndex]);
    minPostEndPeak = Math.min(minPostEndPeak, soundData[dataIndex]);
  }
  return soundEndIndex;
};
tambo.register('SoundUtils', SoundUtils);
export default SoundUtils;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ0YW1ibyIsIkFVRElPX0RBVEFfVEhSRVNIT0xEIiwiU291bmRVdGlscyIsImRldGVjdFNvdW5kQm91bmRzIiwiYXVkaW9CdWZmZXIiLCJzb3VuZERhdGFMZW5ndGgiLCJsZW5ndGgiLCJzb3VuZFN0YXJ0SW5kZXhlcyIsInNvdW5kRW5kSW5kZXhlcyIsImNoYW5uZWxOdW1iZXIiLCJudW1iZXJPZkNoYW5uZWxzIiwic291bmREYXRhIiwiZ2V0Q2hhbm5lbERhdGEiLCJmaW5kU291bmRTdGFydEluZGV4IiwiZmluZFNvdW5kRW5kSW5kZXgiLCJzYW1wbGVSYXRlIiwic291bmRTdGFydCIsIl8iLCJtaW4iLCJzb3VuZEVuZCIsIm1heCIsInRocmVzaG9sZCIsInN0YXJ0VGhyZXNob2xkSW5kZXgiLCJkYXRhSW5kZXgiLCJmb3VuZCIsInNvdW5kU3RhcnRJbmRleCIsInZhbHVlIiwibWF4UHJlU3RhcnRQZWFrIiwibWluUHJlU3RhcnRQZWFrIiwiTWF0aCIsImVuZFRocmVzaG9sZEluZGV4Iiwic291bmRFbmRJbmRleCIsIm1heFBvc3RFbmRQZWFrIiwibWluUG9zdEVuZFBlYWsiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlNvdW5kVXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTgtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogYSBzaW5nbGV0b24gb2JqZWN0IHdpdGggZnVuY3Rpb25zIGZvciBhbmFseXppbmcgYW5kIG1hbmlwdWxhdGluZyBzb3VuZCBkYXRhXHJcbiAqL1xyXG5cclxuaW1wb3J0IHRhbWJvIGZyb20gJy4vdGFtYm8uanMnO1xyXG5cclxuLy8gYSB0eXBlIHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgd2hlcmUgdGhlIGF1ZGlibGUgc291bmRzIGJlZ2luIGFuZCBlbmQgd2l0aGluIGFuIGF1ZGlvIGJ1ZmZlclxyXG50eXBlIFNvdW5kQm91bmRzID0ge1xyXG4gIHNvdW5kU3RhcnQ6IG51bWJlcjtcclxuICBzb3VuZEVuZDogbnVtYmVyIHwgbnVsbDtcclxufTtcclxuXHJcbi8vIFRoaXMgdGhyZXNob2xkIGlzIHVzZWQgZm9yIGFuYWx5emluZyBpbmRpdmlkdWFsIGRlY29kZWQgc291bmQgc2FtcGxlcyBpbiBvcmRlciB0byBmaW5kIHdoZXJlIHRoZSBhY3R1YWwgc291bmRcclxuLy8gdmFsdWVzIHN0YXJ0IGFuZCBlbmQuICBJdHMgdmFsdWUgd2FzIGRldGVybWluZWQgdGhyb3VnaCBleHBlcmltZW50YXRpb24gb24gYSBzaW5nbGUgbG9vcCAoY2hhcmdlcy1pbi1ib2R5KSBhdCBhXHJcbi8vIG51bWJlciBvZiBkaWZmZXJlbnQgZW5jb2RpbmdzLiAgSXQgbWF5IG5lZWQgdG8gYmUgcmVmaW5lZCBvdmVyIHRpbWUgYXMgd2UgYWRkIG5ldyBzb3VuZHMuICBPciBpdCBtYXkgd29yayBwZXJmZWN0bHlcclxuLy8gZm9yZXZlciAob25lIGNhbiBvbmx5IGhvcGUpLiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy90YW1iby9pc3N1ZXMvMzUuXHJcbmNvbnN0IEFVRElPX0RBVEFfVEhSRVNIT0xEID0gMC4wNTtcclxuXHJcbi8qKlxyXG4gKiBzb3VuZCB1dGlsaXR5IG9iamVjdCBkZWZpbml0aW9uXHJcbiAqL1xyXG5jb25zdCBTb3VuZFV0aWxzID0ge1xyXG5cclxuICAvKipcclxuICAgKiBEZXRlY3QgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIG9mIGEgc291bmQgd2l0aGluIGFuZCBBdWRpb0J1ZmZlciBiYXNlZCBvbiB0aGUgcG9pbnRzIHdoZXJlIHRoZSBzYW1wbGVzIGV4Y2VlZCBhXHJcbiAgICogcHJlZGV0ZXJtaW5lZCB0aHJlc2hvbGQuXHJcbiAgICovXHJcbiAgZGV0ZWN0U291bmRCb3VuZHM6ICggYXVkaW9CdWZmZXI6IEF1ZGlvQnVmZmVyICk6IFNvdW5kQm91bmRzID0+IHtcclxuXHJcbiAgICBjb25zdCBzb3VuZERhdGFMZW5ndGggPSBhdWRpb0J1ZmZlci5sZW5ndGg7XHJcbiAgICBjb25zdCBzb3VuZFN0YXJ0SW5kZXhlcyA9IFtdO1xyXG4gICAgY29uc3Qgc291bmRFbmRJbmRleGVzID0gW107XHJcblxyXG4gICAgLy8gYW5hbHl6ZSBlYWNoIGNoYW5uZWwgb2YgdGhlIHNvdW5kIGRhdGFcclxuICAgIGZvciAoIGxldCBjaGFubmVsTnVtYmVyID0gMDsgY2hhbm5lbE51bWJlciA8IGF1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7IGNoYW5uZWxOdW1iZXIrKyApIHtcclxuXHJcbiAgICAgIC8vIGluaXRpYWxpemUgc29tZSB2YXJpYWJsZXMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYW5hbHl6ZSB0aGUgZGF0YVxyXG4gICAgICBjb25zdCBzb3VuZERhdGEgPSBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YSggY2hhbm5lbE51bWJlciApO1xyXG5cclxuICAgICAgLy8gZmluZCB3aGVyZSB0aGUgc291bmQgZmlyc3QgZXhjZWVkcyB0aGUgdGhyZXNob2xkXHJcbiAgICAgIHNvdW5kU3RhcnRJbmRleGVzWyBjaGFubmVsTnVtYmVyIF0gPSBmaW5kU291bmRTdGFydEluZGV4KFxyXG4gICAgICAgIHNvdW5kRGF0YSxcclxuICAgICAgICBzb3VuZERhdGFMZW5ndGgsXHJcbiAgICAgICAgQVVESU9fREFUQV9USFJFU0hPTERcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIGZpbmQgdGhlIGxhc3QgcG9pbnQgYXQgd2hpY2ggdGhlIHNvdW5kIGV4Y2VlZHMgdGhlIHRocmVzaG9sZCwgdGhlbiBnbyBhIGxpdHRsZSBwYXN0XHJcbiAgICAgIHNvdW5kRW5kSW5kZXhlc1sgY2hhbm5lbE51bWJlciBdID0gZmluZFNvdW5kRW5kSW5kZXgoIHNvdW5kRGF0YSwgc291bmREYXRhTGVuZ3RoLCBBVURJT19EQVRBX1RIUkVTSE9MRCApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJldHVybiBhbiBvYmplY3Qgd2l0aCB2YWx1ZXMgZm9yIHdoZXJlIHRoZSBsb29wIHNob3VsZCBzdGFydCBhbmQgZW5kXHJcbiAgICBjb25zdCBzYW1wbGVSYXRlID0gYXVkaW9CdWZmZXIuc2FtcGxlUmF0ZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNvdW5kU3RhcnQ6IF8ubWluKCBzb3VuZFN0YXJ0SW5kZXhlcyApISAvIHNhbXBsZVJhdGUsXHJcbiAgICAgIHNvdW5kRW5kOiBfLm1heCggc291bmRFbmRJbmRleGVzICkhIC8gc2FtcGxlUmF0ZVxyXG4gICAgfTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRmluZCB0aGUgaW5kZXggaW4gdGhlIHByb3ZpZGVkIGF1ZGlvIGJ1ZmZlciB3aGVyZSB0aGUgc291bmQgYmVnaW5zLCBpLmUuIGZpbmQgdGhlIGVuZCBvZiBhbnkgbGVhZGluZyBzaWxlbmNlLlxyXG4gKiBAcGFyYW0gc291bmREYXRhIC0gc291bmQgZGF0YSB0byBiZSBhbmFseXplZFxyXG4gKiBAcGFyYW0gbGVuZ3RoIC0gbGVuZ3RoIG9mIHRoZSBzb3VuZCBkYXRhXHJcbiAqIEBwYXJhbSB0aHJlc2hvbGQgLSBkZXRlY3Rpb24gbGV2ZWwgZm9yIGluaXRpYWwgc291bmQsIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDFcclxuICogQHJldHVybnMgaW5kZXggd2hlcmUgc291bmQgY2FuIGJlIGNvbnNpZGVyZWQgdG8gc3RhcnRcclxuICovXHJcbmNvbnN0IGZpbmRTb3VuZFN0YXJ0SW5kZXggPSAoIHNvdW5kRGF0YTogRmxvYXQzMkFycmF5LCBsZW5ndGg6IG51bWJlciwgdGhyZXNob2xkOiBudW1iZXIgKTogbnVtYmVyID0+IHtcclxuXHJcbiAgLy8gZmluZCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgdGhyZXNob2xkIHRoYXQgaXMgdHJlbmRpbmcgaW4gdGhlIHVwIGRpcmVjdGlvblxyXG4gIGxldCBzdGFydFRocmVzaG9sZEluZGV4ID0gMDtcclxuICBsZXQgZGF0YUluZGV4O1xyXG4gIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gIGZvciAoIGRhdGFJbmRleCA9IDA7IGRhdGFJbmRleCA8IGxlbmd0aCAtIDEgJiYgIWZvdW5kOyBkYXRhSW5kZXgrKyApIHtcclxuICAgIGlmICggc291bmREYXRhWyBkYXRhSW5kZXggXSA+IHRocmVzaG9sZCAmJiBzb3VuZERhdGFbIGRhdGFJbmRleCArIDEgXSA+IHNvdW5kRGF0YVsgZGF0YUluZGV4IF0gKSB7XHJcbiAgICAgIHN0YXJ0VGhyZXNob2xkSW5kZXggPSBkYXRhSW5kZXg7XHJcbiAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHdvcmsgYmFja3dhcmRzIGZyb20gdGhlIGZpcnN0IHRocmVzaG9sZCBmb3VuZCB0byBmaW5kIHRoZSBmaXJzdCB6ZXJvIG9yIHplcm8gY3Jvc3NpbmdcclxuICBsZXQgc291bmRTdGFydEluZGV4ID0gMDtcclxuICBmb3VuZCA9IGZhbHNlO1xyXG4gIGZvciAoIGRhdGFJbmRleCA9IHN0YXJ0VGhyZXNob2xkSW5kZXg7IGRhdGFJbmRleCA+IDAgJiYgIWZvdW5kOyBkYXRhSW5kZXgtLSApIHtcclxuICAgIGNvbnN0IHZhbHVlID0gc291bmREYXRhWyBkYXRhSW5kZXggXTtcclxuICAgIGlmICggdmFsdWUgPD0gMCApIHtcclxuICAgICAgc291bmRTdGFydEluZGV4ID0gdmFsdWUgPT09IDAgPyBkYXRhSW5kZXggOiBkYXRhSW5kZXggKyAxO1xyXG4gICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBkZXRlY3QgYW5kIGxvZyB0aGUgcGVha3MgaW4gdGhlIHByZS1zdGFydCBkYXRhLCB1c2VmdWwgZm9yIGRldGVybWluaW5nIHdoYXQgdGhlIHRocmVzaG9sZCB2YWx1ZSBzaG91bGQgYmVcclxuICBsZXQgbWF4UHJlU3RhcnRQZWFrID0gMDtcclxuICBsZXQgbWluUHJlU3RhcnRQZWFrID0gMDtcclxuICBmb3IgKCBkYXRhSW5kZXggPSAwOyBkYXRhSW5kZXggPCBzb3VuZFN0YXJ0SW5kZXg7IGRhdGFJbmRleCsrICkge1xyXG4gICAgbWF4UHJlU3RhcnRQZWFrID0gTWF0aC5tYXgoIG1heFByZVN0YXJ0UGVhaywgc291bmREYXRhWyBkYXRhSW5kZXggXSApO1xyXG4gICAgbWluUHJlU3RhcnRQZWFrID0gTWF0aC5taW4oIG1pblByZVN0YXJ0UGVhaywgc291bmREYXRhWyBkYXRhSW5kZXggXSApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNvdW5kU3RhcnRJbmRleDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaW5kIHRoZSBpbmRleCBpbiB0aGUgcHJvdmlkZWQgc291bmQgZGF0YSB3aGVyZSB0aGUgc291bmQgY2FuIGJlIGNvbnNpZGVyZWQgdG8gZW5kLCBtZWFuaW5nIHRoYXQgdGhlcmUgaXMgb25seVxyXG4gKiBzaWxlbmNlIG9yIHZlcnkgbGl0dGxlIHNvdW5kIGVuZXJneSB0aGVyZWFmdGVyLlxyXG4gKiBAcGFyYW0gc291bmREYXRhIC0gdGhlIHNhbXBsZSB2YWx1ZXMgZm9yIHRoZSBzb3VuZFxyXG4gKiBAcGFyYW0gbGVuZ3RoIC0gbGVuZ3RoIG9mIHRoZSBzb3VuZCBkYXRhXHJcbiAqIEBwYXJhbSB0aHJlc2hvbGQgLSBkZXRlY3Rpb24gbGV2ZWwgZm9yIHRoZSBwcmVzZW5jZSBvZiBzb3VuZCwgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgMVxyXG4gKi9cclxuY29uc3QgZmluZFNvdW5kRW5kSW5kZXggPSAoIHNvdW5kRGF0YTogRmxvYXQzMkFycmF5LCBsZW5ndGg6IG51bWJlciwgdGhyZXNob2xkOiBudW1iZXIgKTogbnVtYmVyID0+IHtcclxuXHJcbiAgLy8gd29yayBiYWNrd2FyZHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBkYXRhIHRvIGZpbmQgdGhlIGZpcnN0IG5lZ2F0aXZlIG9jY3VyYW5jZSBvZiB0aGUgdGhyZXNob2xkXHJcbiAgbGV0IGVuZFRocmVzaG9sZEluZGV4ID0gbGVuZ3RoIC0gMTtcclxuICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICBsZXQgZGF0YUluZGV4O1xyXG4gIGZvciAoIGRhdGFJbmRleCA9IGxlbmd0aCAtIDE7IGRhdGFJbmRleCA+IDAgJiYgIWZvdW5kOyBkYXRhSW5kZXgtLSApIHtcclxuICAgIGlmICggc291bmREYXRhWyBkYXRhSW5kZXggXSA8PSAtdGhyZXNob2xkICYmIHNvdW5kRGF0YVsgZGF0YUluZGV4IC0gMSBdIDwgc291bmREYXRhWyBkYXRhSW5kZXggXSApIHtcclxuICAgICAgZW5kVGhyZXNob2xkSW5kZXggPSBkYXRhSW5kZXg7XHJcbiAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHdvcmsgZm9yd2FyZCBmcm9tIHRoZSBlbmQgdGhyZXNob2xkIHRvIGZpbmQgYSB6ZXJvIG9yIHplcm8gY3Jvc3NpbmcgdGhhdCBjYW4gd29yayBhcyB0aGUgZW5kIG9mIHRoZSBsb29wXHJcbiAgbGV0IHNvdW5kRW5kSW5kZXggPSBlbmRUaHJlc2hvbGRJbmRleDtcclxuICBmb3VuZCA9IGZhbHNlO1xyXG4gIGZvciAoIGRhdGFJbmRleCA9IGVuZFRocmVzaG9sZEluZGV4OyBkYXRhSW5kZXggPCBsZW5ndGggLSAxICYmICFmb3VuZDsgZGF0YUluZGV4KysgKSB7XHJcbiAgICBpZiAoIHNvdW5kRGF0YVsgZGF0YUluZGV4ICsgMSBdID49IDAgKSB7XHJcbiAgICAgIHNvdW5kRW5kSW5kZXggPSBkYXRhSW5kZXg7XHJcbiAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGRldGVjdCBhbmQgbG9nIHRoZSBwZWFrcyBpbiB0aGUgcG9zdC1lbmQgZGF0YSwgdXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGF0IHRoZSB0aHJlc2hvbGQgdmFsdWUgc2hvdWxkIGJlXHJcbiAgbGV0IG1heFBvc3RFbmRQZWFrID0gMDtcclxuICBsZXQgbWluUG9zdEVuZFBlYWsgPSAwO1xyXG4gIGZvciAoIGRhdGFJbmRleCA9IHNvdW5kRW5kSW5kZXg7IGRhdGFJbmRleCA8IGxlbmd0aDsgZGF0YUluZGV4KysgKSB7XHJcbiAgICBtYXhQb3N0RW5kUGVhayA9IE1hdGgubWF4KCBtYXhQb3N0RW5kUGVhaywgc291bmREYXRhWyBkYXRhSW5kZXggXSApO1xyXG4gICAgbWluUG9zdEVuZFBlYWsgPSBNYXRoLm1pbiggbWluUG9zdEVuZFBlYWssIHNvdW5kRGF0YVsgZGF0YUluZGV4IF0gKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzb3VuZEVuZEluZGV4O1xyXG59O1xyXG5cclxudGFtYm8ucmVnaXN0ZXIoICdTb3VuZFV0aWxzJywgU291bmRVdGlscyApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU291bmRVdGlsczsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxLQUFLLE1BQU0sWUFBWTs7QUFFOUI7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxvQkFBb0IsR0FBRyxJQUFJOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxNQUFNQyxVQUFVLEdBQUc7RUFFakI7QUFDRjtBQUNBO0FBQ0E7RUFDRUMsaUJBQWlCLEVBQUlDLFdBQXdCLElBQW1CO0lBRTlELE1BQU1DLGVBQWUsR0FBR0QsV0FBVyxDQUFDRSxNQUFNO0lBQzFDLE1BQU1DLGlCQUFpQixHQUFHLEVBQUU7SUFDNUIsTUFBTUMsZUFBZSxHQUFHLEVBQUU7O0lBRTFCO0lBQ0EsS0FBTSxJQUFJQyxhQUFhLEdBQUcsQ0FBQyxFQUFFQSxhQUFhLEdBQUdMLFdBQVcsQ0FBQ00sZ0JBQWdCLEVBQUVELGFBQWEsRUFBRSxFQUFHO01BRTNGO01BQ0EsTUFBTUUsU0FBUyxHQUFHUCxXQUFXLENBQUNRLGNBQWMsQ0FBRUgsYUFBYyxDQUFDOztNQUU3RDtNQUNBRixpQkFBaUIsQ0FBRUUsYUFBYSxDQUFFLEdBQUdJLG1CQUFtQixDQUN0REYsU0FBUyxFQUNUTixlQUFlLEVBQ2ZKLG9CQUNGLENBQUM7O01BRUQ7TUFDQU8sZUFBZSxDQUFFQyxhQUFhLENBQUUsR0FBR0ssaUJBQWlCLENB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