// Copyright 2017-2023, University of Colorado Boulder

/**
 * Drag handler for shopping items.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import { DragListener } from '../../../../scenery/js/imports.js';
import unitRates from '../../unitRates.js';
export default class ShoppingItemDragListener extends DragListener {
  /**
   * @param {ShoppingItemNode} itemNode
   * @param {item} item
   * @param {Shelf} shelf
   * @param {Scale} scale
   * @param {Node} frontItemLayer
   * @param {Node} backItemLayer
   * @param {Node} dragLayer
   */
  constructor(itemNode, item, shelf, scale, frontItemLayer, backItemLayer, dragLayer) {
    // {Vector2} where the drag started relative to the item's position, in parent view coordinates
    let startDragOffset;
    super({
      // allow touch swipes across an item to pick it up
      allowTouchSnag: true,
      /**
       * Called when a drag sequence starts.
       * @param {SceneryEvent} event
       */
      start: event => {
        // move Node to the drag layer, so that it pops to the front
        item.dragging = true;
        itemNode.getParent() && itemNode.getParent().removeChild(itemNode);
        dragLayer.addChild(itemNode);

        // remove item from shelf or scale
        if (shelf.containsItem(item)) {
          shelf.removeItem(item);
        } else if (scale.containsItem(item)) {
          scale.removeItem(item);
        } else {
          // item was grabbed while animating
        }

        // compute the offset between the pointer and the item's position
        startDragOffset = itemNode.globalToParentPoint(event.pointer.point).minus(item.positionProperty.value);
      },
      /**
       * Called when the pointer moves during a drag sequence.
       * @param {SceneryEvent} event
       */
      drag: event => {
        // move the item immediately while dragging
        item.moveTo(itemNode.globalToParentPoint(event.pointer.point).minus(startDragOffset));
      },
      /**
       * Called when a drag sequence ends.
       */
      end: () => {
        item.dragging = false;

        // if the item is released above the scale, item falls to scale, otherwise to shelf.
        const shoppingContainer = item.positionProperty.value.y < scale.yAboveScale ? scale : shelf;

        // get the closest row and unoccupied cell, returns {itemRow: RowOfMovables, cellIndex: number}
        const rowAndCell = getClosestRowAndUnoccupiedCell(shoppingContainer, item.positionProperty.value);
        animateItemToContainer(shoppingContainer, item, itemNode, rowAndCell.itemRow, rowAndCell.cellIndex, frontItemLayer, backItemLayer);
      }
    });
  }
}

/**
 * Gets the row and unoccupied cell that are closest to the specified position.
 * @param {ShoppingContainer} shoppingContainer
 * @param {Vector2} position
 * @returns {{itemRow: RowOfMovables, cellIndex: number}}
 */
function getClosestRowAndUnoccupiedCell(shoppingContainer, position) {
  // to improve readability
  const backItemRow = shoppingContainer.backItemRow;
  const frontItemRow = shoppingContainer.frontItemRow;

  // find closest cell in each row
  const backCellIndex = backItemRow.getClosestUnoccupiedCell(position);
  const frontCellIndex = frontItemRow.getClosestUnoccupiedCell(position);
  assert && assert(!(backCellIndex === -1 && frontCellIndex === -1), 'container is full');
  let itemRow = null;
  let cellIndex = -1;
  if (backCellIndex === -1) {
    // back row is full, use front row
    itemRow = frontItemRow;
    cellIndex = frontCellIndex;
  } else if (frontCellIndex === -1) {
    // front row is full, use back row
    itemRow = backItemRow;
    cellIndex = backCellIndex;
  } else {
    // front and back rows both have unoccupied cells, choose the closest one
    const backCellDistance = position.distance(backItemRow.getCellPosition(backCellIndex));
    const frontCellDistance = position.distance(frontItemRow.getCellPosition(frontCellIndex));
    if (backCellDistance <= frontCellDistance) {
      itemRow = backItemRow;
      cellIndex = backCellIndex;
    } else {
      itemRow = frontItemRow;
      cellIndex = frontCellIndex;
    }
  }
  return {
    itemRow: itemRow,
    // {RowOfMovables} the front or back row of items
    cellIndex: cellIndex // {number} a cell in itemRow
  };
}

/**
 * Animates an item to a specified row and cell in a container.
 * The animation will change course immediately if the specified cell becomes occupied.
 * @param {ShoppingContainer} shoppingContainer
 * @param {ShoppingItem} item
 * @param {Node} itemNode
 * @param {RowOfMovables} itemRow
 * @param {number} cellIndex
 * @param {Node} frontItemLayer
 * @param {Node} backItemLayer
 * @private
 */
function animateItemToContainer(shoppingContainer, item, itemNode, itemRow, cellIndex, frontItemLayer, backItemLayer) {
  // If the item's Node has been disposed (which means the item no longer exists), then ignore all of this.
  // See https://github.com/phetsims/unit-rates/issues/214
  if (itemNode.isDisposed) {
    return;
  }

  // This function changes course to the next closest unoccupied cell.
  const changeCourse = () => {
    unitRates.log && unitRates.log(`cell ${cellIndex} is occupied, trying another cell`);

    // get the closest row and unoccupied cell, returns {itemRow: RowOfMovables, cellIndex: number}
    const rowAndCell = getClosestRowAndUnoccupiedCell(shoppingContainer, item.positionProperty.value);
    animateItemToContainer(shoppingContainer, item, itemNode, rowAndCell.itemRow, rowAndCell.cellIndex, frontItemLayer, backItemLayer);
  };

  // This function is called on each animation step.
  // If the target cell becomes occupied, change course immediately.
  const animationStepCallback = () => {
    if (!itemRow.isEmptyCell(cellIndex)) {
      changeCourse();
    }
  };

  // This function is called when animation completes.
  // If the target cell is still empty, add the item. Otherwise animate to an unoccupied cell.
  const animationCompletedCallback = () => {
    // If the item's Node has been disposed (which means the item no longer exists), then ignore this.
    // See https://github.com/phetsims/unit-rates/issues/214
    if (itemNode.isDisposed) {
      return;
    }
    if (itemRow.isEmptyCell(cellIndex)) {
      // the cell is still unoccupied when we reached it, put the item in that cell
      itemRow.put(item, cellIndex);

      // move Node to front or back item layer
      itemNode.getParent() && itemNode.getParent().removeChild(itemNode);
      if (itemRow === shoppingContainer.backItemRow) {
        backItemLayer.addChild(itemNode);
      } else {
        frontItemLayer.addChild(itemNode);
      }
    } else {
      // the cell is occupied, try another cell
      changeCourse();
    }
  };
  const destination = itemRow.getCellPosition(cellIndex); // {Vector2}

  // begin the animation
  item.animateTo(destination, {
    animationStepCallback: animationStepCallback,
    animationCompletedCallback: animationCompletedCallback
  });
}
unitRates.register('ShoppingItemDragListener', ShoppingItemDragListener);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEcmFnTGlzdGVuZXIiLCJ1bml0UmF0ZXMiLCJTaG9wcGluZ0l0ZW1EcmFnTGlzdGVuZXIiLCJjb25zdHJ1Y3RvciIsIml0ZW1Ob2RlIiwiaXRlbSIsInNoZWxmIiwic2NhbGUiLCJmcm9udEl0ZW1MYXllciIsImJhY2tJdGVtTGF5ZXIiLCJkcmFnTGF5ZXIiLCJzdGFydERyYWdPZmZzZXQiLCJhbGxvd1RvdWNoU25hZyIsInN0YXJ0IiwiZXZlbnQiLCJkcmFnZ2luZyIsImdldFBhcmVudCIsInJlbW92ZUNoaWxkIiwiYWRkQ2hpbGQiLCJjb250YWluc0l0ZW0iLCJyZW1vdmVJdGVtIiwiZ2xvYmFsVG9QYXJlbnRQb2ludCIsInBvaW50ZXIiLCJwb2ludCIsIm1pbnVzIiwicG9zaXRpb25Qcm9wZXJ0eSIsInZhbHVlIiwiZHJhZyIsIm1vdmVUbyIsImVuZCIsInNob3BwaW5nQ29udGFpbmVyIiwieSIsInlBYm92ZVNjYWxlIiwicm93QW5kQ2VsbCIsImdldENsb3Nlc3RSb3dBbmRVbm9jY3VwaWVkQ2VsbCIsImFuaW1hdGVJdGVtVG9Db250YWluZXIiLCJpdGVtUm93IiwiY2VsbEluZGV4IiwicG9zaXRpb24iLCJiYWNrSXRlbVJvdyIsImZyb250SXRlbVJvdyIsImJhY2tDZWxsSW5kZXgiLCJnZXRDbG9zZXN0VW5vY2N1cGllZENlbGwiLCJmcm9udENlbGxJbmRleCIsImFzc2VydCIsImJhY2tDZWxsRGlzdGFuY2UiLCJkaXN0YW5jZSIsImdldENlbGxQb3NpdGlvbiIsImZyb250Q2VsbERpc3RhbmNlIiwiaXNEaXNwb3NlZCIsImNoYW5nZUNvdXJzZSIsImxvZyIsImFuaW1hdGlvblN0ZXBDYWxsYmFjayIsImlzRW1wdHlDZWxsIiwiYW5pbWF0aW9uQ29tcGxldGVkQ2FsbGJhY2siLCJwdXQiLCJkZXN0aW5hdGlvbiIsImFuaW1hdGVUbyIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiU2hvcHBpbmdJdGVtRHJhZ0xpc3RlbmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE3LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIERyYWcgaGFuZGxlciBmb3Igc2hvcHBpbmcgaXRlbXMuXHJcbiAqXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgRHJhZ0xpc3RlbmVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IHVuaXRSYXRlcyBmcm9tICcuLi8uLi91bml0UmF0ZXMuanMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hvcHBpbmdJdGVtRHJhZ0xpc3RlbmVyIGV4dGVuZHMgRHJhZ0xpc3RlbmVyIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTaG9wcGluZ0l0ZW1Ob2RlfSBpdGVtTm9kZVxyXG4gICAqIEBwYXJhbSB7aXRlbX0gaXRlbVxyXG4gICAqIEBwYXJhbSB7U2hlbGZ9IHNoZWxmXHJcbiAgICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcclxuICAgKiBAcGFyYW0ge05vZGV9IGZyb250SXRlbUxheWVyXHJcbiAgICogQHBhcmFtIHtOb2RlfSBiYWNrSXRlbUxheWVyXHJcbiAgICogQHBhcmFtIHtOb2RlfSBkcmFnTGF5ZXJcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggaXRlbU5vZGUsIGl0ZW0sIHNoZWxmLCBzY2FsZSwgZnJvbnRJdGVtTGF5ZXIsIGJhY2tJdGVtTGF5ZXIsIGRyYWdMYXllciApIHtcclxuXHJcbiAgICAvLyB7VmVjdG9yMn0gd2hlcmUgdGhlIGRyYWcgc3RhcnRlZCByZWxhdGl2ZSB0byB0aGUgaXRlbSdzIHBvc2l0aW9uLCBpbiBwYXJlbnQgdmlldyBjb29yZGluYXRlc1xyXG4gICAgbGV0IHN0YXJ0RHJhZ09mZnNldDtcclxuXHJcbiAgICBzdXBlcigge1xyXG5cclxuICAgICAgLy8gYWxsb3cgdG91Y2ggc3dpcGVzIGFjcm9zcyBhbiBpdGVtIHRvIHBpY2sgaXQgdXBcclxuICAgICAgYWxsb3dUb3VjaFNuYWc6IHRydWUsXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQ2FsbGVkIHdoZW4gYSBkcmFnIHNlcXVlbmNlIHN0YXJ0cy5cclxuICAgICAgICogQHBhcmFtIHtTY2VuZXJ5RXZlbnR9IGV2ZW50XHJcbiAgICAgICAqL1xyXG4gICAgICBzdGFydDogZXZlbnQgPT4ge1xyXG5cclxuICAgICAgICAvLyBtb3ZlIE5vZGUgdG8gdGhlIGRyYWcgbGF5ZXIsIHNvIHRoYXQgaXQgcG9wcyB0byB0aGUgZnJvbnRcclxuICAgICAgICBpdGVtLmRyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICBpdGVtTm9kZS5nZXRQYXJlbnQoKSAmJiBpdGVtTm9kZS5nZXRQYXJlbnQoKS5yZW1vdmVDaGlsZCggaXRlbU5vZGUgKTtcclxuICAgICAgICBkcmFnTGF5ZXIuYWRkQ2hpbGQoIGl0ZW1Ob2RlICk7XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBpdGVtIGZyb20gc2hlbGYgb3Igc2NhbGVcclxuICAgICAgICBpZiAoIHNoZWxmLmNvbnRhaW5zSXRlbSggaXRlbSApICkge1xyXG4gICAgICAgICAgc2hlbGYucmVtb3ZlSXRlbSggaXRlbSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICggc2NhbGUuY29udGFpbnNJdGVtKCBpdGVtICkgKSB7XHJcbiAgICAgICAgICBzY2FsZS5yZW1vdmVJdGVtKCBpdGVtICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgLy8gaXRlbSB3YXMgZ3JhYmJlZCB3aGlsZSBhbmltYXRpbmdcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBwb2ludGVyIGFuZCB0aGUgaXRlbSdzIHBvc2l0aW9uXHJcbiAgICAgICAgc3RhcnREcmFnT2Zmc2V0ID0gaXRlbU5vZGUuZ2xvYmFsVG9QYXJlbnRQb2ludCggZXZlbnQucG9pbnRlci5wb2ludCApLm1pbnVzKCBpdGVtLnBvc2l0aW9uUHJvcGVydHkudmFsdWUgKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcG9pbnRlciBtb3ZlcyBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxyXG4gICAgICAgKiBAcGFyYW0ge1NjZW5lcnlFdmVudH0gZXZlbnRcclxuICAgICAgICovXHJcbiAgICAgIGRyYWc6IGV2ZW50ID0+IHtcclxuXHJcbiAgICAgICAgLy8gbW92ZSB0aGUgaXRlbSBpbW1lZGlhdGVseSB3aGlsZSBkcmFnZ2luZ1xyXG4gICAgICAgIGl0ZW0ubW92ZVRvKCBpdGVtTm9kZS5nbG9iYWxUb1BhcmVudFBvaW50KCBldmVudC5wb2ludGVyLnBvaW50ICkubWludXMoIHN0YXJ0RHJhZ09mZnNldCApICk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQ2FsbGVkIHdoZW4gYSBkcmFnIHNlcXVlbmNlIGVuZHMuXHJcbiAgICAgICAqL1xyXG4gICAgICBlbmQ6ICgpID0+IHtcclxuXHJcbiAgICAgICAgaXRlbS5kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBpZiB0aGUgaXRlbSBpcyByZWxlYXNlZCBhYm92ZSB0aGUgc2NhbGUsIGl0ZW0gZmFsbHMgdG8gc2NhbGUsIG90aGVyd2lzZSB0byBzaGVsZi5cclxuICAgICAgICBjb25zdCBzaG9wcGluZ0NvbnRhaW5lciA9ICggaXRlbS5wb3NpdGlvblByb3BlcnR5LnZhbHVlLnkgPCBzY2FsZS55QWJvdmVTY2FsZSApID8gc2NhbGUgOiBzaGVsZjtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHRoZSBjbG9zZXN0IHJvdyBhbmQgdW5vY2N1cGllZCBjZWxsLCByZXR1cm5zIHtpdGVtUm93OiBSb3dPZk1vdmFibGVzLCBjZWxsSW5kZXg6IG51bWJlcn1cclxuICAgICAgICBjb25zdCByb3dBbmRDZWxsID0gZ2V0Q2xvc2VzdFJvd0FuZFVub2NjdXBpZWRDZWxsKCBzaG9wcGluZ0NvbnRhaW5lciwgaXRlbS5wb3NpdGlvblByb3BlcnR5LnZhbHVlICk7XHJcblxyXG4gICAgICAgIGFuaW1hdGVJdGVtVG9Db250YWluZXIoIHNob3BwaW5nQ29udGFpbmVyLCBpdGVtLCBpdGVtTm9kZSwgcm93QW5kQ2VsbC5pdGVtUm93LCByb3dBbmRDZWxsLmNlbGxJbmRleCxcclxuICAgICAgICAgIGZyb250SXRlbUxheWVyLCBiYWNrSXRlbUxheWVyICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSByb3cgYW5kIHVub2NjdXBpZWQgY2VsbCB0aGF0IGFyZSBjbG9zZXN0IHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXHJcbiAqIEBwYXJhbSB7U2hvcHBpbmdDb250YWluZXJ9IHNob3BwaW5nQ29udGFpbmVyXHJcbiAqIEBwYXJhbSB7VmVjdG9yMn0gcG9zaXRpb25cclxuICogQHJldHVybnMge3tpdGVtUm93OiBSb3dPZk1vdmFibGVzLCBjZWxsSW5kZXg6IG51bWJlcn19XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDbG9zZXN0Um93QW5kVW5vY2N1cGllZENlbGwoIHNob3BwaW5nQ29udGFpbmVyLCBwb3NpdGlvbiApIHtcclxuXHJcbiAgLy8gdG8gaW1wcm92ZSByZWFkYWJpbGl0eVxyXG4gIGNvbnN0IGJhY2tJdGVtUm93ID0gc2hvcHBpbmdDb250YWluZXIuYmFja0l0ZW1Sb3c7XHJcbiAgY29uc3QgZnJvbnRJdGVtUm93ID0gc2hvcHBpbmdDb250YWluZXIuZnJvbnRJdGVtUm93O1xyXG5cclxuICAvLyBmaW5kIGNsb3Nlc3QgY2VsbCBpbiBlYWNoIHJvd1xyXG4gIGNvbnN0IGJhY2tDZWxsSW5kZXggPSBiYWNrSXRlbVJvdy5nZXRDbG9zZXN0VW5vY2N1cGllZENlbGwoIHBvc2l0aW9uICk7XHJcbiAgY29uc3QgZnJvbnRDZWxsSW5kZXggPSBmcm9udEl0ZW1Sb3cuZ2V0Q2xvc2VzdFVub2NjdXBpZWRDZWxsKCBwb3NpdGlvbiApO1xyXG4gIGFzc2VydCAmJiBhc3NlcnQoICEoIGJhY2tDZWxsSW5kZXggPT09IC0xICYmIGZyb250Q2VsbEluZGV4ID09PSAtMSApLCAnY29udGFpbmVyIGlzIGZ1bGwnICk7XHJcblxyXG4gIGxldCBpdGVtUm93ID0gbnVsbDtcclxuICBsZXQgY2VsbEluZGV4ID0gLTE7XHJcblxyXG4gIGlmICggYmFja0NlbGxJbmRleCA9PT0gLTEgKSB7XHJcblxyXG4gICAgLy8gYmFjayByb3cgaXMgZnVsbCwgdXNlIGZyb250IHJvd1xyXG4gICAgaXRlbVJvdyA9IGZyb250SXRlbVJvdztcclxuICAgIGNlbGxJbmRleCA9IGZyb250Q2VsbEluZGV4O1xyXG4gIH1cclxuICBlbHNlIGlmICggZnJvbnRDZWxsSW5kZXggPT09IC0xICkge1xyXG5cclxuICAgIC8vIGZyb250IHJvdyBpcyBmdWxsLCB1c2UgYmFjayByb3dcclxuICAgIGl0ZW1Sb3cgPSBiYWNrSXRlbVJvdztcclxuICAgIGNlbGxJbmRleCA9IGJhY2tDZWxsSW5kZXg7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG5cclxuICAgIC8vIGZyb250IGFuZCBiYWNrIHJvd3MgYm90aCBoYXZlIHVub2NjdXBpZWQgY2VsbHMsIGNob29zZSB0aGUgY2xvc2VzdCBvbmVcclxuICAgIGNvbnN0IGJhY2tDZWxsRGlzdGFuY2UgPSBwb3NpdGlvbi5kaXN0YW5jZSggYmFja0l0ZW1Sb3cuZ2V0Q2VsbFBvc2l0aW9uKCBiYWNrQ2VsbEluZGV4ICkgKTtcclxuICAgIGNvbnN0IGZyb250Q2VsbERpc3RhbmNlID0gcG9zaXRpb24uZGlzdGFuY2UoIGZyb250SXRlbVJvdy5nZXRDZWxsUG9zaXRpb24oIGZyb250Q2VsbEluZGV4ICkgKTtcclxuICAgIGlmICggYmFja0NlbGxEaXN0YW5jZSA8PSBmcm9udENlbGxEaXN0YW5jZSApIHtcclxuICAgICAgaXRlbVJvdyA9IGJhY2tJdGVtUm93O1xyXG4gICAgICBjZWxsSW5kZXggPSBiYWNrQ2VsbEluZGV4O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGl0ZW1Sb3cgPSBmcm9udEl0ZW1Sb3c7XHJcbiAgICAgIGNlbGxJbmRleCA9IGZyb250Q2VsbEluZGV4O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGl0ZW1Sb3c6IGl0ZW1Sb3csIC8vIHtSb3dPZk1vdmFibGVzfSB0aGUgZnJvbnQgb3IgYmFjayByb3cgb2YgaXRlbXNcclxuICAgIGNlbGxJbmRleDogY2VsbEluZGV4IC8vIHtudW1iZXJ9IGEgY2VsbCBpbiBpdGVtUm93XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuaW1hdGVzIGFuIGl0ZW0gdG8gYSBzcGVjaWZpZWQgcm93IGFuZCBjZWxsIGluIGEgY29udGFpbmVyLlxyXG4gKiBUaGUgYW5pbWF0aW9uIHdpbGwgY2hhbmdlIGNvdXJzZSBpbW1lZGlhdGVseSBpZiB0aGUgc3BlY2lmaWVkIGNlbGwgYmVjb21lcyBvY2N1cGllZC5cclxuICogQHBhcmFtIHtTaG9wcGluZ0NvbnRhaW5lcn0gc2hvcHBpbmdDb250YWluZXJcclxuICogQHBhcmFtIHtTaG9wcGluZ0l0ZW19IGl0ZW1cclxuICogQHBhcmFtIHtOb2RlfSBpdGVtTm9kZVxyXG4gKiBAcGFyYW0ge1Jvd09mTW92YWJsZXN9IGl0ZW1Sb3dcclxuICogQHBhcmFtIHtudW1iZXJ9IGNlbGxJbmRleFxyXG4gKiBAcGFyYW0ge05vZGV9IGZyb250SXRlbUxheWVyXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYmFja0l0ZW1MYXllclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gYW5pbWF0ZUl0ZW1Ub0NvbnRhaW5lciggc2hvcHBpbmdDb250YWluZXIsIGl0ZW0sIGl0ZW1Ob2RlLCBpdGVtUm93LCBjZWxsSW5kZXgsIGZyb250SXRlbUxheWVyLCBiYWNrSXRlbUxheWVyICkge1xyXG5cclxuICAvLyBJZiB0aGUgaXRlbSdzIE5vZGUgaGFzIGJlZW4gZGlzcG9zZWQgKHdoaWNoIG1lYW5zIHRoZSBpdGVtIG5vIGxvbmdlciBleGlzdHMpLCB0aGVuIGlnbm9yZSBhbGwgb2YgdGhpcy5cclxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3VuaXQtcmF0ZXMvaXNzdWVzLzIxNFxyXG4gIGlmICggaXRlbU5vZGUuaXNEaXNwb3NlZCApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIFRoaXMgZnVuY3Rpb24gY2hhbmdlcyBjb3Vyc2UgdG8gdGhlIG5leHQgY2xvc2VzdCB1bm9jY3VwaWVkIGNlbGwuXHJcbiAgY29uc3QgY2hhbmdlQ291cnNlID0gKCkgPT4ge1xyXG4gICAgdW5pdFJhdGVzLmxvZyAmJiB1bml0UmF0ZXMubG9nKCBgY2VsbCAke2NlbGxJbmRleH0gaXMgb2NjdXBpZWQsIHRyeWluZyBhbm90aGVyIGNlbGxgICk7XHJcblxyXG4gICAgLy8gZ2V0IHRoZSBjbG9zZXN0IHJvdyBhbmQgdW5vY2N1cGllZCBjZWxsLCByZXR1cm5zIHtpdGVtUm93OiBSb3dPZk1vdmFibGVzLCBjZWxsSW5kZXg6IG51bWJlcn1cclxuICAgIGNvbnN0IHJvd0FuZENlbGwgPSBnZXRDbG9zZXN0Um93QW5kVW5vY2N1cGllZENlbGwoIHNob3BwaW5nQ29udGFpbmVyLCBpdGVtLnBvc2l0aW9uUHJvcGVydHkudmFsdWUgKTtcclxuXHJcbiAgICBhbmltYXRlSXRlbVRvQ29udGFpbmVyKCBzaG9wcGluZ0NvbnRhaW5lciwgaXRlbSwgaXRlbU5vZGUsIHJvd0FuZENlbGwuaXRlbVJvdywgcm93QW5kQ2VsbC5jZWxsSW5kZXgsXHJcbiAgICAgIGZyb250SXRlbUxheWVyLCBiYWNrSXRlbUxheWVyICk7XHJcbiAgfTtcclxuXHJcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCBhbmltYXRpb24gc3RlcC5cclxuICAvLyBJZiB0aGUgdGFyZ2V0IGNlbGwgYmVjb21lcyBvY2N1cGllZCwgY2hhbmdlIGNvdXJzZSBpbW1lZGlhdGVseS5cclxuICBjb25zdCBhbmltYXRpb25TdGVwQ2FsbGJhY2sgPSAoKSA9PiB7XHJcbiAgICBpZiAoICFpdGVtUm93LmlzRW1wdHlDZWxsKCBjZWxsSW5kZXggKSApIHtcclxuICAgICAgY2hhbmdlQ291cnNlKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhbmltYXRpb24gY29tcGxldGVzLlxyXG4gIC8vIElmIHRoZSB0YXJnZXQgY2VsbCBpcyBzdGlsbCBlbXB0eSwgYWRkIHRoZSBpdGVtLiBPdGhlcndpc2UgYW5pbWF0ZSB0byBhbiB1bm9jY3VwaWVkIGNlbGwuXHJcbiAgY29uc3QgYW5pbWF0aW9uQ29tcGxldGVkQ2FsbGJhY2sgPSAoKSA9PiB7XHJcblxyXG4gICAgLy8gSWYgdGhlIGl0ZW0ncyBOb2RlIGhhcyBiZWVuIGRpc3Bvc2VkICh3aGljaCBtZWFucyB0aGUgaXRlbSBubyBsb25nZXIgZXhpc3RzKSwgdGhlbiBpZ25vcmUgdGhpcy5cclxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdW5pdC1yYXRlcy9pc3N1ZXMvMjE0XHJcbiAgICBpZiAoIGl0ZW1Ob2RlLmlzRGlzcG9zZWQgKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIGl0ZW1Sb3cuaXNFbXB0eUNlbGwoIGNlbGxJbmRleCApICkge1xyXG5cclxuICAgICAgLy8gdGhlIGNlbGwgaXMgc3RpbGwgdW5vY2N1cGllZCB3aGVuIHdlIHJlYWNoZWQgaXQsIHB1dCB0aGUgaXRlbSBpbiB0aGF0IGNlbGxcclxuICAgICAgaXRlbVJvdy5wdXQoIGl0ZW0sIGNlbGxJbmRleCApO1xyXG5cclxuICAgICAgLy8gbW92ZSBOb2RlIHRvIGZyb250IG9yIGJhY2sgaXRlbSBsYXllclxyXG4gICAgICBpdGVtTm9kZS5nZXRQYXJlbnQoKSAmJiBpdGVtTm9kZS5nZXRQYXJlbnQoKS5yZW1vdmVDaGlsZCggaXRlbU5vZGUgKTtcclxuICAgICAgaWYgKCBpdGVtUm93ID09PSBzaG9wcGluZ0NvbnRhaW5lci5iYWNrSXRlbVJvdyApIHtcclxuICAgICAgICBiYWNrSXRlbUxheWVyLmFkZENoaWxkKCBpdGVtTm9kZSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGZyb250SXRlbUxheWVyLmFkZENoaWxkKCBpdGVtTm9kZSApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuXHJcbiAgICAgIC8vIHRoZSBjZWxsIGlzIG9jY3VwaWVkLCB0cnkgYW5vdGhlciBjZWxsXHJcbiAgICAgIGNoYW5nZUNvdXJzZSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gaXRlbVJvdy5nZXRDZWxsUG9zaXRpb24oIGNlbGxJbmRleCApOyAvLyB7VmVjdG9yMn1cclxuXHJcbiAgLy8gYmVnaW4gdGhlIGFuaW1hdGlvblxyXG4gIGl0ZW0uYW5pbWF0ZVRvKCBkZXN0aW5hdGlvbiwge1xyXG4gICAgYW5pbWF0aW9uU3RlcENhbGxiYWNrOiBhbmltYXRpb25TdGVwQ2FsbGJhY2ssXHJcbiAgICBhbmltYXRpb25Db21wbGV0ZWRDYWxsYmFjazogYW5pbWF0aW9uQ29tcGxldGVkQ2FsbGJhY2tcclxuICB9ICk7XHJcbn1cclxuXHJcbnVuaXRSYXRlcy5yZWdpc3RlciggJ1Nob3BwaW5nSXRlbURyYWdMaXN0ZW5lcicsIFNob3BwaW5nSXRlbURyYWdMaXN0ZW5lciApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTQSxZQUFZLFFBQVEsbUNBQW1DO0FBQ2hFLE9BQU9DLFNBQVMsTUFBTSxvQkFBb0I7QUFFMUMsZUFBZSxNQUFNQyx3QkFBd0IsU0FBU0YsWUFBWSxDQUFDO0VBRWpFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFRyxX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