// Copyright 2002-2022, University of Colorado Boulder

/**
 * Renders a triangular lattice of pegs for a Galton board.
 * Implemented using CanvasNode as a performance optimization on iPad.
 *
 * @author Martin Veillette (Berea College)
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import merge from '../../../../phet-core/js/merge.js';
import { CanvasNode, Circle, Path, RadialGradient } from '../../../../scenery/js/imports.js';
import plinkoProbability from '../../plinkoProbability.js';
import GaltonBoard from '../model/GaltonBoard.js';
import PlinkoProbabilityConstants from '../PlinkoProbabilityConstants.js';
class PegsNode extends CanvasNode {
  /**
   * @param {GaltonBoard} galtonBoard
   * @param {Property.<number>} numberOfRowsProperty - an integer
   * @param {Property.<number>} probabilityProperty - a number ranging from 0 to 1
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Object} [options]
   */
  constructor(galtonBoard, numberOfRowsProperty, probabilityProperty, modelViewTransform, options) {
    options = merge({
      rotatePegs: true,
      // pegs have a flat surface whose orientation changes with probability
      pegRadius: 50 // radius of peg when the number of rows is 1
    }, options);
    super(options);

    // NOTE: the pegs are scales inversely proportional to the numberOfBins
    // that is inversely proportional to the number of rows +1

    // for the purposes of drawing the pegs, draw the largest possible peg (i.e. with the minimum number Of rows) in
    // Node and use canvasNode to scale it down, ensuring always a high quality image.
    const largestPegRadius = options.pegRadius * (2 / (PlinkoProbabilityConstants.ROWS_RANGE.min + 1));

    // @private
    this.options = options;
    this.galtonBoard = galtonBoard;
    this.numberOfRowsProperty = numberOfRowsProperty;
    this.probabilityProperty = probabilityProperty;
    this.modelViewTransform = modelViewTransform;
    let pegShape;
    if (options.rotatePegs) {
      // flat surface pointing up
      pegShape = new Shape().arc(0, 0, largestPegRadius, -0.75 * Math.PI, -0.25 * Math.PI, true);
    } else {
      pegShape = new Shape().circle(0, 0, largestPegRadius);
    }
    const pegNode = new Path(pegShape, {
      fill: PlinkoProbabilityConstants.PEG_COLOR
    });
    const shadowNode = new Circle(1.4 * largestPegRadius, {
      fill: new RadialGradient(largestPegRadius * 0.3, largestPegRadius * 0.5, 0, largestPegRadius * 0.1, -largestPegRadius * 0.6, largestPegRadius * 1.4).addColorStop(0, 'rgba(0,0,0,1)').addColorStop(0.1809, 'rgba(3,3,3, 0.8191)').addColorStop(0.3135, 'rgba(12,12,12, 0.6865)').addColorStop(0.4307, 'rgba(28,28,28, 0.5693)').addColorStop(0.539, 'rgba(48,48,48, 0.461)').addColorStop(0.6412, 'rgba(80,80,80, 0.3588)').addColorStop(0.7388, 'rgba(116,116,116, 0.2612)').addColorStop(0.8328, 'rgba(158,158,158, 0.1672)').addColorStop(0.9217, 'rgba(206,206,206, 0.0783)').addColorStop(1, 'rgba(255,255,255, 0.00)')
    });

    // Renders the peg to a canvas.
    pegNode.toCanvas((canvas, x, y, width, height) => {
      this.pegCanvase = canvas; // @private
      this.invalidatePaint(); // calls paintCanvas
    });

    // Create an image of the peg shadow. This happens asynchronously.
    shadowNode.toImage(image => {
      this.shadowImage = image; // @private
      this.invalidatePaint(); // calls paintCanvas
    });

    // Rotate the pegs when probability changes, but only if they have a flat surface.
    // No need to unlink since this instance is present for the lifetime of the simulation.
    if (options.rotatePegs) {
      probabilityProperty.lazyLink(() => {
        this.invalidatePaint();
      });
    }

    // Update the number of pegs.
    // No need to unlink since this instance is present for the lifetime of the simulation.
    numberOfRowsProperty.lazyLink(() => {
      this.invalidatePaint();
    });

    // calls paintCanvas
    this.invalidatePaint();
  }

  /**
   * @param {CanvasRenderingContext2D} context
   * @override
   * @private
   */
  paintCanvas(context) {
    // images are created asynchronously by toImage, so they may not be available yet
    if (!this.pegCanvase || !this.shadowImage) {
      return;
    }

    // compute values that remain constant in for loop

    // scale peg radius to be inversely proportional to the number of bins
    const pegScale = (PlinkoProbabilityConstants.ROWS_RANGE.min + 1) / (this.numberOfRowsProperty.get() + 1);
    const pegWidth = pegScale * this.pegCanvase.width;
    const pegHeight = pegScale * this.pegCanvase.height;
    const shadowWidth = pegScale * this.shadowImage.width;
    const shadowHeight = pegScale * this.shadowImage.height;

    // probability 0.5 has the flat part of the peg facing up
    const pegAngle = -(Math.PI / 4) + this.probabilityProperty.get() * Math.PI / 2;

    // shadow offset, a bit below and to the right, determined empirically
    const pegSpacing = GaltonBoard.getPegSpacing(this.numberOfRowsProperty.get());
    const shadowOffset = this.modelViewTransform.modelToViewDelta(new Vector2(pegSpacing * 0.08, -pegSpacing * 0.24));

    // galtonBoard.pegs contains all the model pegs (even pegs that that are currently invisible)
    this.galtonBoard.pegs.forEach(peg => {
      if (peg.isVisible) {
        const pegPosition = this.modelViewTransform.modelToViewPosition(peg.position);
        const shadowPosition = pegPosition.plus(shadowOffset);

        // shadow
        context.drawImage(this.shadowImage, shadowPosition.x - shadowWidth / 2, shadowPosition.y - shadowHeight / 2, shadowWidth, shadowHeight);

        // rotated peg
        context.save();
        context.translate(pegPosition.x, pegPosition.y);
        context.rotate(pegAngle);
        context.drawImage(this.pegCanvase, -pegWidth / 2, -pegHeight / 2, pegWidth, pegHeight);
        context.restore();
      }
    });
  }
}
plinkoProbability.register('PegsNode', PegsNode);
export default PegsNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiU2hhcGUiLCJtZXJnZSIsIkNhbnZhc05vZGUiLCJDaXJjbGUiLCJQYXRoIiwiUmFkaWFsR3JhZGllbnQiLCJwbGlua29Qcm9iYWJpbGl0eSIsIkdhbHRvbkJvYXJkIiwiUGxpbmtvUHJvYmFiaWxpdHlDb25zdGFudHMiLCJQZWdzTm9kZSIsImNvbnN0cnVjdG9yIiwiZ2FsdG9uQm9hcmQiLCJudW1iZXJPZlJvd3NQcm9wZXJ0eSIsInByb2JhYmlsaXR5UHJvcGVydHkiLCJtb2RlbFZpZXdUcmFuc2Zvcm0iLCJvcHRpb25zIiwicm90YXRlUGVncyIsInBlZ1JhZGl1cyIsImxhcmdlc3RQZWdSYWRpdXMiLCJST1dTX1JBTkdFIiwibWluIiwicGVnU2hhcGUiLCJhcmMiLCJNYXRoIiwiUEkiLCJjaXJjbGUiLCJwZWdOb2RlIiwiZmlsbCIsIlBFR19DT0xPUiIsInNoYWRvd05vZGUiLCJhZGRDb2xvclN0b3AiLCJ0b0NhbnZhcyIsImNhbnZhcyIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJwZWdDYW52YXNlIiwiaW52YWxpZGF0ZVBhaW50IiwidG9JbWFnZSIsImltYWdlIiwic2hhZG93SW1hZ2UiLCJsYXp5TGluayIsInBhaW50Q2FudmFzIiwiY29udGV4dCIsInBlZ1NjYWxlIiwiZ2V0IiwicGVnV2lkdGgiLCJwZWdIZWlnaHQiLCJzaGFkb3dXaWR0aCIsInNoYWRvd0hlaWdodCIsInBlZ0FuZ2xlIiwicGVnU3BhY2luZyIsImdldFBlZ1NwYWNpbmciLCJzaGFkb3dPZmZzZXQiLCJtb2RlbFRvVmlld0RlbHRhIiwicGVncyIsImZvckVhY2giLCJwZWciLCJpc1Zpc2libGUiLCJwZWdQb3NpdGlvbiIsIm1vZGVsVG9WaWV3UG9zaXRpb24iLCJwb3NpdGlvbiIsInNoYWRvd1Bvc2l0aW9uIiwicGx1cyIsImRyYXdJbWFnZSIsInNhdmUiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJyZXN0b3JlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJQZWdzTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAwMi0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIGEgdHJpYW5ndWxhciBsYXR0aWNlIG9mIHBlZ3MgZm9yIGEgR2FsdG9uIGJvYXJkLlxyXG4gKiBJbXBsZW1lbnRlZCB1c2luZyBDYW52YXNOb2RlIGFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIG9uIGlQYWQuXHJcbiAqXHJcbiAqIEBhdXRob3IgTWFydGluIFZlaWxsZXR0ZSAoQmVyZWEgQ29sbGVnZSlcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCB7IENhbnZhc05vZGUsIENpcmNsZSwgUGF0aCwgUmFkaWFsR3JhZGllbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgcGxpbmtvUHJvYmFiaWxpdHkgZnJvbSAnLi4vLi4vcGxpbmtvUHJvYmFiaWxpdHkuanMnO1xyXG5pbXBvcnQgR2FsdG9uQm9hcmQgZnJvbSAnLi4vbW9kZWwvR2FsdG9uQm9hcmQuanMnO1xyXG5pbXBvcnQgUGxpbmtvUHJvYmFiaWxpdHlDb25zdGFudHMgZnJvbSAnLi4vUGxpbmtvUHJvYmFiaWxpdHlDb25zdGFudHMuanMnO1xyXG5cclxuY2xhc3MgUGVnc05vZGUgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge0dhbHRvbkJvYXJkfSBnYWx0b25Cb2FyZFxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHkuPG51bWJlcj59IG51bWJlck9mUm93c1Byb3BlcnR5IC0gYW4gaW50ZWdlclxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHkuPG51bWJlcj59IHByb2JhYmlsaXR5UHJvcGVydHkgLSBhIG51bWJlciByYW5naW5nIGZyb20gMCB0byAxXHJcbiAgICogQHBhcmFtIHtNb2RlbFZpZXdUcmFuc2Zvcm0yfSBtb2RlbFZpZXdUcmFuc2Zvcm1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGdhbHRvbkJvYXJkLCBudW1iZXJPZlJvd3NQcm9wZXJ0eSwgcHJvYmFiaWxpdHlQcm9wZXJ0eSwgbW9kZWxWaWV3VHJhbnNmb3JtLCBvcHRpb25zICkge1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG4gICAgICByb3RhdGVQZWdzOiB0cnVlLCAvLyBwZWdzIGhhdmUgYSBmbGF0IHN1cmZhY2Ugd2hvc2Ugb3JpZW50YXRpb24gY2hhbmdlcyB3aXRoIHByb2JhYmlsaXR5XHJcbiAgICAgIHBlZ1JhZGl1czogNTAgLy8gcmFkaXVzIG9mIHBlZyB3aGVuIHRoZSBudW1iZXIgb2Ygcm93cyBpcyAxXHJcbiAgICB9LCBvcHRpb25zICk7XHJcblxyXG4gICAgc3VwZXIoIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBOT1RFOiB0aGUgcGVncyBhcmUgc2NhbGVzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlck9mQmluc1xyXG4gICAgLy8gdGhhdCBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2Ygcm93cyArMVxyXG5cclxuICAgIC8vIGZvciB0aGUgcHVycG9zZXMgb2YgZHJhd2luZyB0aGUgcGVncywgZHJhdyB0aGUgbGFyZ2VzdCBwb3NzaWJsZSBwZWcgKGkuZS4gd2l0aCB0aGUgbWluaW11bSBudW1iZXIgT2Ygcm93cykgaW5cclxuICAgIC8vIE5vZGUgYW5kIHVzZSBjYW52YXNOb2RlIHRvIHNjYWxlIGl0IGRvd24sIGVuc3VyaW5nIGFsd2F5cyBhIGhpZ2ggcXVhbGl0eSBpbWFnZS5cclxuICAgIGNvbnN0IGxhcmdlc3RQZWdSYWRpdXMgPSBvcHRpb25zLnBlZ1JhZGl1cyAqICggMiAvICggUGxpbmtvUHJvYmFiaWxpdHlDb25zdGFudHMuUk9XU19SQU5HRS5taW4gKyAxICkgKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIHRoaXMuZ2FsdG9uQm9hcmQgPSBnYWx0b25Cb2FyZDtcclxuICAgIHRoaXMubnVtYmVyT2ZSb3dzUHJvcGVydHkgPSBudW1iZXJPZlJvd3NQcm9wZXJ0eTtcclxuICAgIHRoaXMucHJvYmFiaWxpdHlQcm9wZXJ0eSA9IHByb2JhYmlsaXR5UHJvcGVydHk7XHJcbiAgICB0aGlzLm1vZGVsVmlld1RyYW5zZm9ybSA9IG1vZGVsVmlld1RyYW5zZm9ybTtcclxuXHJcbiAgICBsZXQgcGVnU2hhcGU7XHJcbiAgICBpZiAoIG9wdGlvbnMucm90YXRlUGVncyApIHtcclxuXHJcbiAgICAgIC8vIGZsYXQgc3VyZmFjZSBwb2ludGluZyB1cFxyXG4gICAgICBwZWdTaGFwZSA9IG5ldyBTaGFwZSgpLmFyYyggMCwgMCwgbGFyZ2VzdFBlZ1JhZGl1cywgLTAuNzUgKiBNYXRoLlBJLCAtMC4yNSAqIE1hdGguUEksIHRydWUgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBwZWdTaGFwZSA9IG5ldyBTaGFwZSgpLmNpcmNsZSggMCwgMCwgbGFyZ2VzdFBlZ1JhZGl1cyApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBlZ05vZGUgPSBuZXcgUGF0aCggcGVnU2hhcGUsIHsgZmlsbDogUGxpbmtvUHJvYmFiaWxpdHlDb25zdGFudHMuUEVHX0NPTE9SIH0gKTtcclxuXHJcbiAgICBjb25zdCBzaGFkb3dOb2RlID0gbmV3IENpcmNsZSggMS40ICogbGFyZ2VzdFBlZ1JhZGl1cywge1xyXG4gICAgICBmaWxsOiBuZXcgUmFkaWFsR3JhZGllbnQoXHJcbiAgICAgICAgbGFyZ2VzdFBlZ1JhZGl1cyAqIDAuMyxcclxuICAgICAgICBsYXJnZXN0UGVnUmFkaXVzICogMC41LFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgbGFyZ2VzdFBlZ1JhZGl1cyAqIDAuMSxcclxuICAgICAgICAtbGFyZ2VzdFBlZ1JhZGl1cyAqIDAuNixcclxuICAgICAgICBsYXJnZXN0UGVnUmFkaXVzICogMS40XHJcbiAgICAgIClcclxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAwLCAncmdiYSgwLDAsMCwxKScgKVxyXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDAuMTgwOSwgJ3JnYmEoMywzLDMsIDAuODE5MSknIClcclxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAwLjMxMzUsICdyZ2JhKDEyLDEyLDEyLCAwLjY4NjUpJyApXHJcbiAgICAgICAgLmFkZENvbG9yU3RvcCggMC40MzA3LCAncmdiYSgyOCwyOCwyOCwgMC41NjkzKScgKVxyXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDAuNTM5LCAncmdiYSg0OCw0OCw0OCwgMC40NjEpJyApXHJcbiAgICAgICAgLmFkZENvbG9yU3RvcCggMC42NDEyLCAncmdiYSg4MCw4MCw4MCwgMC4zNTg4KScgKVxyXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDAuNzM4OCwgJ3JnYmEoMTE2LDExNiwxMTYsIDAuMjYxMiknIClcclxuICAgICAgICAuYWRkQ29sb3JTdG9wKCAwLjgzMjgsICdyZ2JhKDE1OCwxNTgsMTU4LCAwLjE2NzIpJyApXHJcbiAgICAgICAgLmFkZENvbG9yU3RvcCggMC45MjE3LCAncmdiYSgyMDYsMjA2LDIwNiwgMC4wNzgzKScgKVxyXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDEsICdyZ2JhKDI1NSwyNTUsMjU1LCAwLjAwKScgKVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFJlbmRlcnMgdGhlIHBlZyB0byBhIGNhbnZhcy5cclxuICAgIHBlZ05vZGUudG9DYW52YXMoICggY2FudmFzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkgPT4ge1xyXG4gICAgICB0aGlzLnBlZ0NhbnZhc2UgPSBjYW52YXM7IC8vIEBwcml2YXRlXHJcbiAgICAgIHRoaXMuaW52YWxpZGF0ZVBhaW50KCk7IC8vIGNhbGxzIHBhaW50Q2FudmFzXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGFuIGltYWdlIG9mIHRoZSBwZWcgc2hhZG93LiBUaGlzIGhhcHBlbnMgYXN5bmNocm9ub3VzbHkuXHJcbiAgICBzaGFkb3dOb2RlLnRvSW1hZ2UoIGltYWdlID0+IHtcclxuICAgICAgdGhpcy5zaGFkb3dJbWFnZSA9IGltYWdlOyAvLyBAcHJpdmF0ZVxyXG4gICAgICB0aGlzLmludmFsaWRhdGVQYWludCgpOyAvLyBjYWxscyBwYWludENhbnZhc1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFJvdGF0ZSB0aGUgcGVncyB3aGVuIHByb2JhYmlsaXR5IGNoYW5nZXMsIGJ1dCBvbmx5IGlmIHRoZXkgaGF2ZSBhIGZsYXQgc3VyZmFjZS5cclxuICAgIC8vIE5vIG5lZWQgdG8gdW5saW5rIHNpbmNlIHRoaXMgaW5zdGFuY2UgaXMgcHJlc2VudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW11bGF0aW9uLlxyXG4gICAgaWYgKCBvcHRpb25zLnJvdGF0ZVBlZ3MgKSB7XHJcbiAgICAgIHByb2JhYmlsaXR5UHJvcGVydHkubGF6eUxpbmsoICgpID0+IHtcclxuICAgICAgICB0aGlzLmludmFsaWRhdGVQYWludCgpO1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBudW1iZXIgb2YgcGVncy5cclxuICAgIC8vIE5vIG5lZWQgdG8gdW5saW5rIHNpbmNlIHRoaXMgaW5zdGFuY2UgaXMgcHJlc2VudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW11bGF0aW9uLlxyXG4gICAgbnVtYmVyT2ZSb3dzUHJvcGVydHkubGF6eUxpbmsoICgpID0+IHtcclxuICAgICAgdGhpcy5pbnZhbGlkYXRlUGFpbnQoKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBjYWxscyBwYWludENhbnZhc1xyXG4gICAgdGhpcy5pbnZhbGlkYXRlUGFpbnQoKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgcGFpbnRDYW52YXMoIGNvbnRleHQgKSB7XHJcblxyXG4gICAgLy8gaW1hZ2VzIGFyZSBjcmVhdGVkIGFzeW5jaHJvbm91c2x5IGJ5IHRvSW1hZ2UsIHNvIHRoZXkgbWF5IG5vdCBiZSBhdmFpbGFibGUgeWV0XHJcbiAgICBpZiAoICF0aGlzLnBlZ0NhbnZhc2UgfHwgIXRoaXMuc2hhZG93SW1hZ2UgKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb21wdXRlIHZhbHVlcyB0aGF0IHJlbWFpbiBjb25zdGFudCBpbiBmb3IgbG9vcFxyXG5cclxuICAgIC8vIHNjYWxlIHBlZyByYWRpdXMgdG8gYmUgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIGJpbnNcclxuICAgIGNvbnN0IHBlZ1NjYWxlID0gKCBQbGlua29Qcm9iYWJpbGl0eUNvbnN0YW50cy5ST1dTX1JBTkdFLm1pbiArIDEgKSAvXHJcbiAgICAgICAgICAgICAgICAgICAgICggdGhpcy5udW1iZXJPZlJvd3NQcm9wZXJ0eS5nZXQoKSArIDEgKTtcclxuXHJcbiAgICBjb25zdCBwZWdXaWR0aCA9IHBlZ1NjYWxlICogdGhpcy5wZWdDYW52YXNlLndpZHRoO1xyXG4gICAgY29uc3QgcGVnSGVpZ2h0ID0gcGVnU2NhbGUgKiB0aGlzLnBlZ0NhbnZhc2UuaGVpZ2h0O1xyXG4gICAgY29uc3Qgc2hhZG93V2lkdGggPSBwZWdTY2FsZSAqIHRoaXMuc2hhZG93SW1hZ2Uud2lkdGg7XHJcbiAgICBjb25zdCBzaGFkb3dIZWlnaHQgPSBwZWdTY2FsZSAqIHRoaXMuc2hhZG93SW1hZ2UuaGVpZ2h0O1xyXG5cclxuICAgIC8vIHByb2JhYmlsaXR5IDAuNSBoYXMgdGhlIGZsYXQgcGFydCBvZiB0aGUgcGVnIGZhY2luZyB1cFxyXG4gICAgY29uc3QgcGVnQW5nbGUgPSAtKCBNYXRoLlBJIC8gNCApICsgKCB0aGlzLnByb2JhYmlsaXR5UHJvcGVydHkuZ2V0KCkgKiBNYXRoLlBJIC8gMiApO1xyXG5cclxuICAgIC8vIHNoYWRvdyBvZmZzZXQsIGEgYml0IGJlbG93IGFuZCB0byB0aGUgcmlnaHQsIGRldGVybWluZWQgZW1waXJpY2FsbHlcclxuICAgIGNvbnN0IHBlZ1NwYWNpbmcgPSBHYWx0b25Cb2FyZC5nZXRQZWdTcGFjaW5nKCB0aGlzLm51bWJlck9mUm93c1Byb3BlcnR5LmdldCgpICk7XHJcbiAgICBjb25zdCBzaGFkb3dPZmZzZXQgPSB0aGlzLm1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhKCBuZXcgVmVjdG9yMiggcGVnU3BhY2luZyAqIDAuMDgsIC1wZWdTcGFjaW5nICogMC4yNCApICk7XHJcblxyXG4gICAgLy8gZ2FsdG9uQm9hcmQucGVncyBjb250YWlucyBhbGwgdGhlIG1vZGVsIHBlZ3MgKGV2ZW4gcGVncyB0aGF0IHRoYXQgYXJlIGN1cnJlbnRseSBpbnZpc2libGUpXHJcbiAgICB0aGlzLmdhbHRvbkJvYXJkLnBlZ3MuZm9yRWFjaCggcGVnID0+IHtcclxuICAgICAgaWYgKCBwZWcuaXNWaXNpYmxlICkge1xyXG5cclxuICAgICAgICBjb25zdCBwZWdQb3NpdGlvbiA9IHRoaXMubW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3UG9zaXRpb24oIHBlZy5wb3NpdGlvbiApO1xyXG4gICAgICAgIGNvbnN0IHNoYWRvd1Bvc2l0aW9uID0gcGVnUG9zaXRpb24ucGx1cyggc2hhZG93T2Zmc2V0ICk7XHJcblxyXG4gICAgICAgIC8vIHNoYWRvd1xyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCB0aGlzLnNoYWRvd0ltYWdlLFxyXG4gICAgICAgICAgc2hhZG93UG9zaXRpb24ueCAtIHNoYWRvd1dpZHRoIC8gMiwgc2hhZG93UG9zaXRpb24ueSAtIHNoYWRvd0hlaWdodCAvIDIsXHJcbiAgICAgICAgICBzaGFkb3dXaWR0aCwgc2hhZG93SGVpZ2h0ICk7XHJcblxyXG4gICAgICAgIC8vIHJvdGF0ZWQgcGVnXHJcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoIHBlZ1Bvc2l0aW9uLngsIHBlZ1Bvc2l0aW9uLnkgKTtcclxuICAgICAgICBjb250ZXh0LnJvdGF0ZSggcGVnQW5nbGUgKTtcclxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSggdGhpcy5wZWdDYW52YXNlLCAtcGVnV2lkdGggLyAyLCAtcGVnSGVpZ2h0IC8gMiwgcGVnV2lkdGgsIHBlZ0hlaWdodCApO1xyXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcbiAgfVxyXG59XHJcblxyXG5wbGlua29Qcm9iYWJpbGl0eS5yZWdpc3RlciggJ1BlZ3NOb2RlJywgUGVnc05vZGUgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBlZ3NOb2RlOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxTQUFTQyxLQUFLLFFBQVEsZ0NBQWdDO0FBQ3RELE9BQU9DLEtBQUssTUFBTSxtQ0FBbUM7QUFDckQsU0FBU0MsVUFBVSxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsY0FBYyxRQUFRLG1DQUFtQztBQUM1RixPQUFPQyxpQkFBaUIsTUFBTSw0QkFBNEI7QUFDMUQsT0FBT0MsV0FBVyxNQUFNLHlCQUF5QjtBQUNqRCxPQUFPQywwQkFBMEIsTUFBTSxrQ0FBa0M7QUFFekUsTUFBTUMsUUFB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