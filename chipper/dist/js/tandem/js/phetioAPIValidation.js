// Copyright 2019-2022, University of Colorado Boulder

/**
 * This singleton is responsible for ensuring that the PhET-iO API is correct through the lifetime of the simulation.
 * The PhET-iO API is defined through multiple preloaded files. The "elements baseline" API holds an exact match of
 * what PhetioObject instances/metadata the sim should create on startup, where the "elements overrides" file is a
 * sparse list that can overwrite metadata without changing the code. See `grunt generate-phet-io-api` for
 * more information. The complete list of checks was decided on in https://github.com/phetsims/phet-io/issues/1453
 * (and later trimmed down) and is as follows:
 *
 * 1. After startup, only dynamic instances prescribed by the baseline API can be registered.
 * 2. Any static, registered PhetioObject can never be deregistered.
 * 3. Any schema entries in the overrides file must exist in the baseline API
 * 4. Any schema entries in the overrides file must be different from its baseline counterpart
 * 5. Dynamic element metadata should match the archetype in the API.
 *
 * Terminology:
 * schema: specified through preloads. The full schema is the baseline plus the overrides, but those parts can be
 *         referred to separately.
 * registered: the process of instrumenting a PhetioObject and it "becoming" a PhET-iO Element on the wrapper side.
 * static PhetioObject: A registered PhetioObject that exists for the lifetime of the sim. It should not be removed
 *                      (even intermittently) and must be created during startup so that it is immediately interoperable.
 * dynamic PhetioObject: A registered PhetioObject that can be created and/or destroyed at any point. Only dynamic
 *                       PhetioObjects can be created after startup.
 *
 * See https://github.com/phetsims/phet-io/issues/1443#issuecomment-484306552 for an explanation of how to maintain the
 * PhET-iO API for a simulation.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Chris Klusendorf (PhET Interactive Simulations)
 */

import Tandem, { DYNAMIC_ARCHETYPE_NAME } from './Tandem.js';
import tandemNamespace from './tandemNamespace.js';
import { LinkedElement } from './PhetioObject.js';
// constants
// The API-tracked and validated metadata keys
const KEYS_TO_CHECK = ['phetioDynamicElement', 'phetioEventType', 'phetioIsArchetype', 'phetioPlayback', 'phetioReadOnly', 'phetioState', 'phetioTypeName'];

// Feel free to add any other JSONifyable keys to this to make the error more clear! All mismatches are printed
// at once for clarity, see PhetioEngine.
class PhetioAPIValidation {
  apiMismatches = [];

  // keep track of when the sim has started.
  simHasStarted = false;

  // settable by qunitStart.js. Validation is only enabled when all screens are present.
  enabled = !!assert && Tandem.VALIDATION;

  // this must be all phet-io types so that the
  // following would fail: add a phetioType, then remove it, then add a different one under the same typeName.
  // A Note about memory: Every IOType that is loaded as a module is already loaded on the namespace. Therefore
  // this map doesn't add any memory by storing these. The exception to this is parametric IOTypes. It should be
  // double checked that anything being passed into a parametric type is memory safe. As of this writing, only IOTypes
  // are passed to parametric IOTypes, so this pattern remains memory leak free. Furthermore, this list is only
  // populated when `this.enabled`.
  everyPhetioType = {};

  /**
   * Callback when the simulation is ready to go, and all static PhetioObjects have been created.
   */
  onSimStarted() {
    if (this.enabled && phet.joist.sim.allScreensCreated) {
      this.validateOverridesFile();
      this.validatePreferencesModel();
    }
    if (phet.preloads.phetio.queryParameters.phetioPrintAPIProblems && this.apiMismatches) {
      console.log('PhET-iO api problems detected: ', this.apiMismatches);
    }

    // After the overrides validation to support ?phetioPrintAPIProblems on errors with overrides.
    this.simHasStarted = true;
  }

  /**
   * All core elements in the preferencesModel should be phetioReadOnly: false so they can be set over the API
   * or from within studio, but phetioState: false so they are not captured with save states.
   */
  validatePreferencesModel() {
    Object.keys(phet.phetio.phetioEngine.phetioObjectMap).filter(key => key.includes('.preferencesModel.')).forEach(preferencesKey => {
      let phetioObject = phet.phetio.phetioEngine.phetioObjectMap[preferencesKey];
      while (phetioObject instanceof LinkedElement) {
        phetioObject = phetioObject.element;
      }
      assert && assert(!phetioObject.phetioReadOnly, 'preferences model and its descendants should be phetioReadOnly: false, key=' + preferencesKey);

      // Audio manager, color profile property and localeProperty are supposed to be stateful. All other preferences
      // should be phetioState: false so they are not captured in the state
      assert && assert(phetioObject.phetioState === (phetioObject.phetioID.endsWith('.colorProfileProperty') || phetioObject.phetioID.endsWith('.audioEnabledProperty') || phetioObject.phetioID.endsWith('.localeProperty') ||
      // Sim preferences should also be stateful
      preferencesKey.includes('.simulationModel.')), 'most preferences should be phetioState: false, key=' + preferencesKey);
    });
  }

  /**
   * Checks if a removed phetioObject is part of a Group
   */
  onPhetioObjectRemoved(phetioObject) {
    if (!this.enabled) {
      return;
    }
    const phetioID = phetioObject.tandem.phetioID;

    // if it isn't dynamic, then it shouldn't be removed during the lifetime of the sim.
    if (!phetioObject.phetioDynamicElement) {
      this.assertAPIError({
        phetioID: phetioID,
        ruleInViolation: '2. Any static, registered PhetioObject can never be deregistered.'
      });
    }
  }

  /**
   * Should be called from phetioEngine when a PhetioObject is added to the PhET-iO
   */
  onPhetioObjectAdded(phetioObject) {
    if (!this.enabled) {
      return;
    }
    const newPhetioType = phetioObject.phetioType;
    const oldPhetioType = this.everyPhetioType[newPhetioType.typeName];
    if (!oldPhetioType) {
      // This may not be necessary, but may be helpful so that we don't overwrite if rule 10 is in violation
      this.everyPhetioType[newPhetioType.typeName] = newPhetioType;
    }
    if (this.simHasStarted) {
      // Here we need to kick this validation to the next frame to support construction in any order. Parent first, or
      // child first. Use namespace to avoid because timer is a PhetioObject.
      phet.axon.animationFrameTimer.runOnNextTick(() => {
        // The only instances that it's OK to create after startup are "dynamic instances" which are marked as such.
        if (!phetioObject.phetioDynamicElement) {
          this.assertAPIError({
            phetioID: phetioObject.tandem.phetioID,
            ruleInViolation: '1. After startup, only dynamic instances prescribed by the baseline file can be registered.'
          });
        } else {
          // Compare the dynamic element to the archetype if creating them this runtime. Don't check this if it has
          // already been disposed.
          if (phet.preloads.phetio.createArchetypes && !phetioObject.isDisposed) {
            const archetypeID = phetioObject.tandem.getArchetypalPhetioID();
            const archetypeMetadata = phet.phetio.phetioEngine.getPhetioObject(archetypeID).getMetadata();

            // Compare to the simulation-defined archetype
            this.checkDynamicInstanceAgainstArchetype(phetioObject, archetypeMetadata, 'simulation archetype');
          }
        }
      });
    }
  }
  validateOverridesFile() {
    // import phetioEngine causes a cycle and cannot be used, hence we must use the namespace
    const entireBaseline = phet.phetio.phetioEngine.getPhetioElementsBaseline();
    for (const phetioID in window.phet.preloads.phetio.phetioElementsOverrides) {
      const isArchetype = phetioID.includes(DYNAMIC_ARCHETYPE_NAME);
      if (!phet.preloads.phetio.createArchetypes && !entireBaseline.hasOwnProperty(phetioID)) {
        assert && assert(isArchetype, `phetioID missing from the baseline that was not an archetype: ${phetioID}`);
      } else {
        if (!entireBaseline.hasOwnProperty(phetioID)) {
          this.assertAPIError({
            phetioID: phetioID,
            ruleInViolation: '3. Any schema entries in the overrides file must exist in the baseline file.',
            message: 'phetioID expected in the baseline file but does not exist'
          });
        } else {
          const override = window.phet.preloads.phetio.phetioElementsOverrides[phetioID];
          const baseline = entireBaseline[phetioID];
          if (Object.keys(override).length === 0) {
            this.assertAPIError({
              phetioID: phetioID,
              ruleInViolation: '4. Any schema entries in the overrides file must be different from its baseline counterpart.',
              message: 'no metadata keys found for this override.'
            });
          }
          for (const metadataKey in override) {
            if (!baseline.hasOwnProperty(metadataKey)) {
              this.assertAPIError({
                phetioID: phetioID,
                ruleInViolation: '8. Any schema entries in the overrides file must be different from its baseline counterpart.',
                message: `phetioID metadata key not found in the baseline: ${metadataKey}`
              });
            }
            if (override[metadataKey] === baseline[metadataKey]) {
              this.assertAPIError({
                phetioID: phetioID,
                ruleInViolation: '8. Any schema entries in the overrides file must be different from its baseline counterpart.',
                message: 'phetioID metadata override value is the same as the corresponding metadata value in the baseline.'
              });
            }
          }
        }
      }
    }
  }

  /**
   * Assert out the failed API validation rule.
   */
  assertAPIError(apiErrorObject) {
    const mismatchMessage = apiErrorObject.phetioID ? `${apiErrorObject.phetioID}:  ${apiErrorObject.ruleInViolation}` : `${apiErrorObject.ruleInViolation}`;
    this.apiMismatches.push(apiErrorObject);

    // If ?phetioPrintAPIProblems is present, then ignore assertions until the sim has started up.
    if (this.simHasStarted || !phet.preloads.phetio.queryParameters.phetioPrintAPIProblems) {
      assert && assert(false, `PhET-iO API error:\n${mismatchMessage}`);
    }
  }

  /**
   * Compare a dynamic phetioObject's metadata to the expected metadata
   */
  checkDynamicInstanceAgainstArchetype(phetioObject, archetypeMetadata, source) {
    const actualMetadata = phetioObject.getMetadata();
    KEYS_TO_CHECK.forEach(key => {
      // These attributes are different for archetype vs actual
      if (key !== 'phetioDynamicElement' && key !== 'phetioArchetypePhetioID' && key !== 'phetioIsArchetype') {
        // @ts-expect-error - not sure how to be typesafe in the API files
        if (archetypeMetadata[key] !== actualMetadata[key] && phetioObject.tandem) {
          this.assertAPIError({
            phetioID: phetioObject.tandem.phetioID,
            ruleInViolation: '5. Dynamic element metadata should match the archetype in the API.',
            source: source,
            message: `mismatched metadata: ${key}`
          });
        }
      }
    });
  }
}
const phetioAPIValidation = new PhetioAPIValidation();
tandemNamespace.register('phetioAPIValidation', phetioAPIValidation);
export default phetioAPIValidation;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUYW5kZW0iLCJEWU5BTUlDX0FSQ0hFVFlQRV9OQU1FIiwidGFuZGVtTmFtZXNwYWNlIiwiTGlua2VkRWxlbWVudCIsIktFWVNfVE9fQ0hFQ0siLCJQaGV0aW9BUElWYWxpZGF0aW9uIiwiYXBpTWlzbWF0Y2hlcyIsInNpbUhhc1N0YXJ0ZWQiLCJlbmFibGVkIiwiYXNzZXJ0IiwiVkFMSURBVElPTiIsImV2ZXJ5UGhldGlvVHlwZSIsIm9uU2ltU3RhcnRlZCIsInBoZXQiLCJqb2lzdCIsInNpbSIsImFsbFNjcmVlbnNDcmVhdGVkIiwidmFsaWRhdGVPdmVycmlkZXNGaWxlIiwidmFsaWRhdGVQcmVmZXJlbmNlc01vZGVsIiwicHJlbG9hZHMiLCJwaGV0aW8iLCJxdWVyeVBhcmFtZXRlcnMiLCJwaGV0aW9QcmludEFQSVByb2JsZW1zIiwiY29uc29sZSIsImxvZyIsIk9iamVjdCIsImtleXMiLCJwaGV0aW9FbmdpbmUiLCJwaGV0aW9PYmplY3RNYXAiLCJmaWx0ZXIiLCJrZXkiLCJpbmNsdWRlcyIsImZvckVhY2giLCJwcmVmZXJlbmNlc0tleSIsInBoZXRpb09iamVjdCIsImVsZW1lbnQiLCJwaGV0aW9SZWFkT25seSIsInBoZXRpb1N0YXRlIiwicGhldGlvSUQiLCJlbmRzV2l0aCIsIm9uUGhldGlvT2JqZWN0UmVtb3ZlZCIsInRhbmRlbSIsInBoZXRpb0R5bmFtaWNFbGVtZW50IiwiYXNzZXJ0QVBJRXJyb3IiLCJydWxlSW5WaW9sYXRpb24iLCJvblBoZXRpb09iamVjdEFkZGVkIiwibmV3UGhldGlvVHlwZSIsInBoZXRpb1R5cGUiLCJvbGRQaGV0aW9UeXBlIiwidHlwZU5hbWUiLCJheG9uIiwiYW5pbWF0aW9uRnJhbWVUaW1lciIsInJ1bk9uTmV4dFRpY2siLCJjcmVhdGVBcmNoZXR5cGVzIiwiaXNEaXNwb3NlZCIsImFyY2hldHlwZUlEIiwiZ2V0QXJjaGV0eXBhbFBoZXRpb0lEIiwiYXJjaGV0eXBlTWV0YWRhdGEiLCJnZXRQaGV0aW9PYmplY3QiLCJnZXRNZXRhZGF0YSIsImNoZWNrRHluYW1pY0luc3RhbmNlQWdhaW5zdEFyY2hldHlwZSIsImVudGlyZUJhc2VsaW5lIiwiZ2V0UGhldGlvRWxlbWVudHNCYXNlbGluZSIsIndpbmRvdyIsInBoZXRpb0VsZW1lbnRzT3ZlcnJpZGVzIiwiaXNBcmNoZXR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lc3NhZ2UiLCJvdmVycmlkZSIsImJhc2VsaW5lIiwibGVuZ3RoIiwibWV0YWRhdGFLZXkiLCJhcGlFcnJvck9iamVjdCIsIm1pc21hdGNoTWVzc2FnZSIsInB1c2giLCJzb3VyY2UiLCJhY3R1YWxNZXRhZGF0YSIsInBoZXRpb0FQSVZhbGlkYXRpb24iLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbInBoZXRpb0FQSVZhbGlkYXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVGhpcyBzaW5nbGV0b24gaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHRoYXQgdGhlIFBoRVQtaU8gQVBJIGlzIGNvcnJlY3QgdGhyb3VnaCB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbXVsYXRpb24uXHJcbiAqIFRoZSBQaEVULWlPIEFQSSBpcyBkZWZpbmVkIHRocm91Z2ggbXVsdGlwbGUgcHJlbG9hZGVkIGZpbGVzLiBUaGUgXCJlbGVtZW50cyBiYXNlbGluZVwiIEFQSSBob2xkcyBhbiBleGFjdCBtYXRjaCBvZlxyXG4gKiB3aGF0IFBoZXRpb09iamVjdCBpbnN0YW5jZXMvbWV0YWRhdGEgdGhlIHNpbSBzaG91bGQgY3JlYXRlIG9uIHN0YXJ0dXAsIHdoZXJlIHRoZSBcImVsZW1lbnRzIG92ZXJyaWRlc1wiIGZpbGUgaXMgYVxyXG4gKiBzcGFyc2UgbGlzdCB0aGF0IGNhbiBvdmVyd3JpdGUgbWV0YWRhdGEgd2l0aG91dCBjaGFuZ2luZyB0aGUgY29kZS4gU2VlIGBncnVudCBnZW5lcmF0ZS1waGV0LWlvLWFwaWAgZm9yXHJcbiAqIG1vcmUgaW5mb3JtYXRpb24uIFRoZSBjb21wbGV0ZSBsaXN0IG9mIGNoZWNrcyB3YXMgZGVjaWRlZCBvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pby9pc3N1ZXMvMTQ1M1xyXG4gKiAoYW5kIGxhdGVyIHRyaW1tZWQgZG93bikgYW5kIGlzIGFzIGZvbGxvd3M6XHJcbiAqXHJcbiAqIDEuIEFmdGVyIHN0YXJ0dXAsIG9ubHkgZHluYW1pYyBpbnN0YW5jZXMgcHJlc2NyaWJlZCBieSB0aGUgYmFzZWxpbmUgQVBJIGNhbiBiZSByZWdpc3RlcmVkLlxyXG4gKiAyLiBBbnkgc3RhdGljLCByZWdpc3RlcmVkIFBoZXRpb09iamVjdCBjYW4gbmV2ZXIgYmUgZGVyZWdpc3RlcmVkLlxyXG4gKiAzLiBBbnkgc2NoZW1hIGVudHJpZXMgaW4gdGhlIG92ZXJyaWRlcyBmaWxlIG11c3QgZXhpc3QgaW4gdGhlIGJhc2VsaW5lIEFQSVxyXG4gKiA0LiBBbnkgc2NoZW1hIGVudHJpZXMgaW4gdGhlIG92ZXJyaWRlcyBmaWxlIG11c3QgYmUgZGlmZmVyZW50IGZyb20gaXRzIGJhc2VsaW5lIGNvdW50ZXJwYXJ0XHJcbiAqIDUuIER5bmFtaWMgZWxlbWVudCBtZXRhZGF0YSBzaG91bGQgbWF0Y2ggdGhlIGFyY2hldHlwZSBpbiB0aGUgQVBJLlxyXG4gKlxyXG4gKiBUZXJtaW5vbG9neTpcclxuICogc2NoZW1hOiBzcGVjaWZpZWQgdGhyb3VnaCBwcmVsb2Fkcy4gVGhlIGZ1bGwgc2NoZW1hIGlzIHRoZSBiYXNlbGluZSBwbHVzIHRoZSBvdmVycmlkZXMsIGJ1dCB0aG9zZSBwYXJ0cyBjYW4gYmVcclxuICogICAgICAgICByZWZlcnJlZCB0byBzZXBhcmF0ZWx5LlxyXG4gKiByZWdpc3RlcmVkOiB0aGUgcHJvY2VzcyBvZiBpbnN0cnVtZW50aW5nIGEgUGhldGlvT2JqZWN0IGFuZCBpdCBcImJlY29taW5nXCIgYSBQaEVULWlPIEVsZW1lbnQgb24gdGhlIHdyYXBwZXIgc2lkZS5cclxuICogc3RhdGljIFBoZXRpb09iamVjdDogQSByZWdpc3RlcmVkIFBoZXRpb09iamVjdCB0aGF0IGV4aXN0cyBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0uIEl0IHNob3VsZCBub3QgYmUgcmVtb3ZlZFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAoZXZlbiBpbnRlcm1pdHRlbnRseSkgYW5kIG11c3QgYmUgY3JlYXRlZCBkdXJpbmcgc3RhcnR1cCBzbyB0aGF0IGl0IGlzIGltbWVkaWF0ZWx5IGludGVyb3BlcmFibGUuXHJcbiAqIGR5bmFtaWMgUGhldGlvT2JqZWN0OiBBIHJlZ2lzdGVyZWQgUGhldGlvT2JqZWN0IHRoYXQgY2FuIGJlIGNyZWF0ZWQgYW5kL29yIGRlc3Ryb3llZCBhdCBhbnkgcG9pbnQuIE9ubHkgZHluYW1pY1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgUGhldGlvT2JqZWN0cyBjYW4gYmUgY3JlYXRlZCBhZnRlciBzdGFydHVwLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vaXNzdWVzLzE0NDMjaXNzdWVjb21tZW50LTQ4NDMwNjU1MiBmb3IgYW4gZXhwbGFuYXRpb24gb2YgaG93IHRvIG1haW50YWluIHRoZVxyXG4gKiBQaEVULWlPIEFQSSBmb3IgYSBzaW11bGF0aW9uLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKiBAYXV0aG9yIE1pY2hhZWwgS2F1em1hbm4gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqIEBhdXRob3IgQ2hyaXMgS2x1c2VuZG9yZiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgVGFuZGVtLCB7IERZTkFNSUNfQVJDSEVUWVBFX05BTUUgfSBmcm9tICcuL1RhbmRlbS5qcyc7XHJcbmltcG9ydCB0YW5kZW1OYW1lc3BhY2UgZnJvbSAnLi90YW5kZW1OYW1lc3BhY2UuanMnO1xyXG5pbXBvcnQgSU9UeXBlIGZyb20gJy4vdHlwZXMvSU9UeXBlLmpzJztcclxuaW1wb3J0IFBoZXRpb09iamVjdCwgeyBMaW5rZWRFbGVtZW50IH0gZnJvbSAnLi9QaGV0aW9PYmplY3QuanMnO1xyXG5pbXBvcnQgeyBQaGV0aW9PYmplY3RNZXRhZGF0YSB9IGZyb20gJy4vVGFuZGVtQ29uc3RhbnRzLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG4vLyBUaGUgQVBJLXRyYWNrZWQgYW5kIHZhbGlkYXRlZCBtZXRhZGF0YSBrZXlzXHJcbmNvbnN0IEtFWVNfVE9fQ0hFQ0sgPSBbXHJcbiAgJ3BoZXRpb0R5bmFtaWNFbGVtZW50JyxcclxuICAncGhldGlvRXZlbnRUeXBlJyxcclxuICAncGhldGlvSXNBcmNoZXR5cGUnLFxyXG4gICdwaGV0aW9QbGF5YmFjaycsXHJcbiAgJ3BoZXRpb1JlYWRPbmx5JyxcclxuICAncGhldGlvU3RhdGUnLFxyXG4gICdwaGV0aW9UeXBlTmFtZSdcclxuXTtcclxuXHJcbi8vIEZlZWwgZnJlZSB0byBhZGQgYW55IG90aGVyIEpTT05pZnlhYmxlIGtleXMgdG8gdGhpcyB0byBtYWtlIHRoZSBlcnJvciBtb3JlIGNsZWFyISBBbGwgbWlzbWF0Y2hlcyBhcmUgcHJpbnRlZFxyXG4vLyBhdCBvbmNlIGZvciBjbGFyaXR5LCBzZWUgUGhldGlvRW5naW5lLlxyXG50eXBlIEFQSU1pc21hdGNoID0ge1xyXG4gIHBoZXRpb0lEOiBzdHJpbmc7XHJcbiAgcnVsZUluVmlvbGF0aW9uOiBzdHJpbmc7IC8vIG9uZSBvZiB0aGUgbnVtYmVyZWQgbGlzdCBpbiB0aGUgaGVhZGVyIGRvYy5cclxuICBtZXNzYWdlPzogc3RyaW5nOyAvLyBzcGVjaWZpYyBwcm9ibGVtXHJcbiAgc291cmNlPzogc3RyaW5nO1xyXG59O1xyXG5cclxuY2xhc3MgUGhldGlvQVBJVmFsaWRhdGlvbiB7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBhcGlNaXNtYXRjaGVzOiBBUElNaXNtYXRjaFtdID0gW107XHJcblxyXG4gIC8vIGtlZXAgdHJhY2sgb2Ygd2hlbiB0aGUgc2ltIGhhcyBzdGFydGVkLlxyXG4gIHByaXZhdGUgc2ltSGFzU3RhcnRlZCA9IGZhbHNlO1xyXG5cclxuICAvLyBzZXR0YWJsZSBieSBxdW5pdFN0YXJ0LmpzLiBWYWxpZGF0aW9uIGlzIG9ubHkgZW5hYmxlZCB3aGVuIGFsbCBzY3JlZW5zIGFyZSBwcmVzZW50LlxyXG4gIHB1YmxpYyBlbmFibGVkOiBib29sZWFuID0gISFhc3NlcnQgJiYgVGFuZGVtLlZBTElEQVRJT047XHJcblxyXG5cclxuICAvLyB0aGlzIG11c3QgYmUgYWxsIHBoZXQtaW8gdHlwZXMgc28gdGhhdCB0aGVcclxuICAvLyBmb2xsb3dpbmcgd291bGQgZmFpbDogYWRkIGEgcGhldGlvVHlwZSwgdGhlbiByZW1vdmUgaXQsIHRoZW4gYWRkIGEgZGlmZmVyZW50IG9uZSB1bmRlciB0aGUgc2FtZSB0eXBlTmFtZS5cclxuICAvLyBBIE5vdGUgYWJvdXQgbWVtb3J5OiBFdmVyeSBJT1R5cGUgdGhhdCBpcyBsb2FkZWQgYXMgYSBtb2R1bGUgaXMgYWxyZWFkeSBsb2FkZWQgb24gdGhlIG5hbWVzcGFjZS4gVGhlcmVmb3JlXHJcbiAgLy8gdGhpcyBtYXAgZG9lc24ndCBhZGQgYW55IG1lbW9yeSBieSBzdG9yaW5nIHRoZXNlLiBUaGUgZXhjZXB0aW9uIHRvIHRoaXMgaXMgcGFyYW1ldHJpYyBJT1R5cGVzLiBJdCBzaG91bGQgYmVcclxuICAvLyBkb3VibGUgY2hlY2tlZCB0aGF0IGFueXRoaW5nIGJlaW5nIHBhc3NlZCBpbnRvIGEgcGFyYW1ldHJpYyB0eXBlIGlzIG1lbW9yeSBzYWZlLiBBcyBvZiB0aGlzIHdyaXRpbmcsIG9ubHkgSU9UeXBlc1xyXG4gIC8vIGFyZSBwYXNzZWQgdG8gcGFyYW1ldHJpYyBJT1R5cGVzLCBzbyB0aGlzIHBhdHRlcm4gcmVtYWlucyBtZW1vcnkgbGVhayBmcmVlLiBGdXJ0aGVybW9yZSwgdGhpcyBsaXN0IGlzIG9ubHlcclxuICAvLyBwb3B1bGF0ZWQgd2hlbiBgdGhpcy5lbmFibGVkYC5cclxuICBwcml2YXRlIGV2ZXJ5UGhldGlvVHlwZTogUmVjb3JkPHN0cmluZywgSU9UeXBlPiA9IHt9O1xyXG5cclxuICAvKipcclxuICAgKiBDYWxsYmFjayB3aGVuIHRoZSBzaW11bGF0aW9uIGlzIHJlYWR5IHRvIGdvLCBhbmQgYWxsIHN0YXRpYyBQaGV0aW9PYmplY3RzIGhhdmUgYmVlbiBjcmVhdGVkLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvblNpbVN0YXJ0ZWQoKTogdm9pZCB7XHJcbiAgICBpZiAoIHRoaXMuZW5hYmxlZCAmJiBwaGV0LmpvaXN0LnNpbS5hbGxTY3JlZW5zQ3JlYXRlZCApIHtcclxuICAgICAgdGhpcy52YWxpZGF0ZU92ZXJyaWRlc0ZpbGUoKTtcclxuICAgICAgdGhpcy52YWxpZGF0ZVByZWZlcmVuY2VzTW9kZWwoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIHBoZXQucHJlbG9hZHMucGhldGlvLnF1ZXJ5UGFyYW1ldGVycy5waGV0aW9QcmludEFQSVByb2JsZW1zICYmIHRoaXMuYXBpTWlzbWF0Y2hlcyApIHtcclxuICAgICAgY29uc29sZS5sb2coICdQaEVULWlPIGFwaSBwcm9ibGVtcyBkZXRlY3RlZDogJywgdGhpcy5hcGlNaXNtYXRjaGVzICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWZ0ZXIgdGhlIG92ZXJyaWRlcyB2YWxpZGF0aW9uIHRvIHN1cHBvcnQgP3BoZXRpb1ByaW50QVBJUHJvYmxlbXMgb24gZXJyb3JzIHdpdGggb3ZlcnJpZGVzLlxyXG4gICAgdGhpcy5zaW1IYXNTdGFydGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsbCBjb3JlIGVsZW1lbnRzIGluIHRoZSBwcmVmZXJlbmNlc01vZGVsIHNob3VsZCBiZSBwaGV0aW9SZWFkT25seTogZmFsc2Ugc28gdGhleSBjYW4gYmUgc2V0IG92ZXIgdGhlIEFQSVxyXG4gICAqIG9yIGZyb20gd2l0aGluIHN0dWRpbywgYnV0IHBoZXRpb1N0YXRlOiBmYWxzZSBzbyB0aGV5IGFyZSBub3QgY2FwdHVyZWQgd2l0aCBzYXZlIHN0YXRlcy5cclxuICAgKi9cclxuICBwdWJsaWMgdmFsaWRhdGVQcmVmZXJlbmNlc01vZGVsKCk6IHZvaWQge1xyXG4gICAgT2JqZWN0LmtleXMoIHBoZXQucGhldGlvLnBoZXRpb0VuZ2luZS5waGV0aW9PYmplY3RNYXAgKS5maWx0ZXIoIGtleSA9PiBrZXkuaW5jbHVkZXMoICcucHJlZmVyZW5jZXNNb2RlbC4nICkgKVxyXG4gICAgICAuZm9yRWFjaCggcHJlZmVyZW5jZXNLZXkgPT4ge1xyXG5cclxuICAgICAgICBsZXQgcGhldGlvT2JqZWN0ID0gcGhldC5waGV0aW8ucGhldGlvRW5naW5lLnBoZXRpb09iamVjdE1hcFsgcHJlZmVyZW5jZXNLZXkgXTtcclxuXHJcbiAgICAgICAgd2hpbGUgKCBwaGV0aW9PYmplY3QgaW5zdGFuY2VvZiBMaW5rZWRFbGVtZW50ICkge1xyXG4gICAgICAgICAgcGhldGlvT2JqZWN0ID0gcGhldGlvT2JqZWN0LmVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoICFwaGV0aW9PYmplY3QucGhldGlvUmVhZE9ubHksICdwcmVmZXJlbmNlcyBtb2RlbCBhbmQgaXRzIGRlc2NlbmRhbnRzIHNob3VsZCBiZSBwaGV0aW9SZWFkT25seTogZmFsc2UsIGtleT0nICsgcHJlZmVyZW5jZXNLZXkgKTtcclxuXHJcbiAgICAgICAgLy8gQXVkaW8gbWFuYWdlciwgY29sb3IgcHJvZmlsZSBwcm9wZXJ0eSBhbmQgbG9jYWxlUHJvcGVydHkgYXJlIHN1cHBvc2VkIHRvIGJlIHN0YXRlZnVsLiBBbGwgb3RoZXIgcHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBzaG91bGQgYmUgcGhldGlvU3RhdGU6IGZhbHNlIHNvIHRoZXkgYXJlIG5vdCBjYXB0dXJlZCBpbiB0aGUgc3RhdGVcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwaGV0aW9PYmplY3QucGhldGlvU3RhdGUgPT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBwaGV0aW9PYmplY3QucGhldGlvSUQuZW5kc1dpdGgoICcuY29sb3JQcm9maWxlUHJvcGVydHknICkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBoZXRpb09iamVjdC5waGV0aW9JRC5lbmRzV2l0aCggJy5hdWRpb0VuYWJsZWRQcm9wZXJ0eScgKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGhldGlvT2JqZWN0LnBoZXRpb0lELmVuZHNXaXRoKCAnLmxvY2FsZVByb3BlcnR5JyApIHx8XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2ltIHByZWZlcmVuY2VzIHNob3VsZCBhbHNvIGJlIHN0YXRlZnVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlc0tleS5pbmNsdWRlcyggJy5zaW11bGF0aW9uTW9kZWwuJyApICksXHJcbiAgICAgICAgICAnbW9zdCBwcmVmZXJlbmNlcyBzaG91bGQgYmUgcGhldGlvU3RhdGU6IGZhbHNlLCBrZXk9JyArIHByZWZlcmVuY2VzS2V5ICk7XHJcbiAgICAgIH0gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBhIHJlbW92ZWQgcGhldGlvT2JqZWN0IGlzIHBhcnQgb2YgYSBHcm91cFxyXG4gICAqL1xyXG4gIHB1YmxpYyBvblBoZXRpb09iamVjdFJlbW92ZWQoIHBoZXRpb09iamVjdDogUGhldGlvT2JqZWN0ICk6IHZvaWQge1xyXG4gICAgaWYgKCAhdGhpcy5lbmFibGVkICkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGhldGlvSUQgPSBwaGV0aW9PYmplY3QudGFuZGVtLnBoZXRpb0lEO1xyXG5cclxuICAgIC8vIGlmIGl0IGlzbid0IGR5bmFtaWMsIHRoZW4gaXQgc2hvdWxkbid0IGJlIHJlbW92ZWQgZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGUgc2ltLlxyXG4gICAgaWYgKCAhcGhldGlvT2JqZWN0LnBoZXRpb0R5bmFtaWNFbGVtZW50ICkge1xyXG4gICAgICB0aGlzLmFzc2VydEFQSUVycm9yKCB7XHJcbiAgICAgICAgcGhldGlvSUQ6IHBoZXRpb0lELFxyXG4gICAgICAgIHJ1bGVJblZpb2xhdGlvbjogJzIuIEFueSBzdGF0aWMsIHJlZ2lzdGVyZWQgUGhldGlvT2JqZWN0IGNhbiBuZXZlciBiZSBkZXJlZ2lzdGVyZWQuJ1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTaG91bGQgYmUgY2FsbGVkIGZyb20gcGhldGlvRW5naW5lIHdoZW4gYSBQaGV0aW9PYmplY3QgaXMgYWRkZWQgdG8gdGhlIFBoRVQtaU9cclxuICAgKi9cclxuICBwdWJsaWMgb25QaGV0aW9PYmplY3RBZGRlZCggcGhldGlvT2JqZWN0OiBQaGV0aW9PYmplY3QgKTogdm9pZCB7XHJcbiAgICBpZiAoICF0aGlzLmVuYWJsZWQgKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdQaGV0aW9UeXBlID0gcGhldGlvT2JqZWN0LnBoZXRpb1R5cGU7XHJcbiAgICBjb25zdCBvbGRQaGV0aW9UeXBlID0gdGhpcy5ldmVyeVBoZXRpb1R5cGVbIG5ld1BoZXRpb1R5cGUudHlwZU5hbWUgXTtcclxuXHJcbiAgICBpZiAoICFvbGRQaGV0aW9UeXBlICkgeyAvLyBUaGlzIG1heSBub3QgYmUgbmVjZXNzYXJ5LCBidXQgbWF5IGJlIGhlbHBmdWwgc28gdGhhdCB3ZSBkb24ndCBvdmVyd3JpdGUgaWYgcnVsZSAxMCBpcyBpbiB2aW9sYXRpb25cclxuICAgICAgdGhpcy5ldmVyeVBoZXRpb1R5cGVbIG5ld1BoZXRpb1R5cGUudHlwZU5hbWUgXSA9IG5ld1BoZXRpb1R5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCB0aGlzLnNpbUhhc1N0YXJ0ZWQgKSB7XHJcblxyXG4gICAgICAvLyBIZXJlIHdlIG5lZWQgdG8ga2ljayB0aGlzIHZhbGlkYXRpb24gdG8gdGhlIG5leHQgZnJhbWUgdG8gc3VwcG9ydCBjb25zdHJ1Y3Rpb24gaW4gYW55IG9yZGVyLiBQYXJlbnQgZmlyc3QsIG9yXHJcbiAgICAgIC8vIGNoaWxkIGZpcnN0LiBVc2UgbmFtZXNwYWNlIHRvIGF2b2lkIGJlY2F1c2UgdGltZXIgaXMgYSBQaGV0aW9PYmplY3QuXHJcbiAgICAgIHBoZXQuYXhvbi5hbmltYXRpb25GcmFtZVRpbWVyLnJ1bk9uTmV4dFRpY2soICgpID0+IHtcclxuXHJcbiAgICAgICAgLy8gVGhlIG9ubHkgaW5zdGFuY2VzIHRoYXQgaXQncyBPSyB0byBjcmVhdGUgYWZ0ZXIgc3RhcnR1cCBhcmUgXCJkeW5hbWljIGluc3RhbmNlc1wiIHdoaWNoIGFyZSBtYXJrZWQgYXMgc3VjaC5cclxuICAgICAgICBpZiAoICFwaGV0aW9PYmplY3QucGhldGlvRHluYW1pY0VsZW1lbnQgKSB7XHJcbiAgICAgICAgICB0aGlzLmFzc2VydEFQSUVycm9yKCB7XHJcbiAgICAgICAgICAgIHBoZXRpb0lEOiBwaGV0aW9PYmplY3QudGFuZGVtLnBoZXRpb0lELFxyXG4gICAgICAgICAgICBydWxlSW5WaW9sYXRpb246ICcxLiBBZnRlciBzdGFydHVwLCBvbmx5IGR5bmFtaWMgaW5zdGFuY2VzIHByZXNjcmliZWQgYnkgdGhlIGJhc2VsaW5lIGZpbGUgY2FuIGJlIHJlZ2lzdGVyZWQuJ1xyXG4gICAgICAgICAgfSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBDb21wYXJlIHRoZSBkeW5hbWljIGVsZW1lbnQgdG8gdGhlIGFyY2hldHlwZSBpZiBjcmVhdGluZyB0aGVtIHRoaXMgcnVudGltZS4gRG9uJ3QgY2hlY2sgdGhpcyBpZiBpdCBoYXNcclxuICAgICAgICAgIC8vIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cclxuICAgICAgICAgIGlmICggcGhldC5wcmVsb2Fkcy5waGV0aW8uY3JlYXRlQXJjaGV0eXBlcyAmJiAhcGhldGlvT2JqZWN0LmlzRGlzcG9zZWQgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyY2hldHlwZUlEID0gcGhldGlvT2JqZWN0LnRhbmRlbS5nZXRBcmNoZXR5cGFsUGhldGlvSUQoKTtcclxuICAgICAgICAgICAgY29uc3QgYXJjaGV0eXBlTWV0YWRhdGEgPSBwaGV0LnBoZXRpby5waGV0aW9FbmdpbmUuZ2V0UGhldGlvT2JqZWN0KCBhcmNoZXR5cGVJRCApLmdldE1ldGFkYXRhKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIHRvIHRoZSBzaW11bGF0aW9uLWRlZmluZWQgYXJjaGV0eXBlXHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tEeW5hbWljSW5zdGFuY2VBZ2FpbnN0QXJjaGV0eXBlKCBwaGV0aW9PYmplY3QsIGFyY2hldHlwZU1ldGFkYXRhLCAnc2ltdWxhdGlvbiBhcmNoZXR5cGUnICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHZhbGlkYXRlT3ZlcnJpZGVzRmlsZSgpOiB2b2lkIHtcclxuXHJcbiAgICAvLyBpbXBvcnQgcGhldGlvRW5naW5lIGNhdXNlcyBhIGN5Y2xlIGFuZCBjYW5ub3QgYmUgdXNlZCwgaGVuY2Ugd2UgbXVzdCB1c2UgdGhlIG5hbWVzcGFjZVxyXG4gICAgY29uc3QgZW50aXJlQmFzZWxpbmUgPSBwaGV0LnBoZXRpby5waGV0aW9FbmdpbmUuZ2V0UGhldGlvRWxlbWVudHNCYXNlbGluZSgpO1xyXG5cclxuICAgIGZvciAoIGNvbnN0IHBoZXRpb0lEIGluIHdpbmRvdy5waGV0LnByZWxvYWRzLnBoZXRpby5waGV0aW9FbGVtZW50c092ZXJyaWRlcyApIHtcclxuICAgICAgY29uc3QgaXNBcmNoZXR5cGUgPSBwaGV0aW9JRC5pbmNsdWRlcyggRFlOQU1JQ19BUkNIRVRZUEVfTkFNRSApO1xyXG4gICAgICBpZiAoICFwaGV0LnByZWxvYWRzLnBoZXRpby5jcmVhdGVBcmNoZXR5cGVzICYmICFlbnRpcmVCYXNlbGluZS5oYXNPd25Qcm9wZXJ0eSggcGhldGlvSUQgKSApIHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBpc0FyY2hldHlwZSwgYHBoZXRpb0lEIG1pc3NpbmcgZnJvbSB0aGUgYmFzZWxpbmUgdGhhdCB3YXMgbm90IGFuIGFyY2hldHlwZTogJHtwaGV0aW9JRH1gICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCAhZW50aXJlQmFzZWxpbmUuaGFzT3duUHJvcGVydHkoIHBoZXRpb0lEICkgKSB7XHJcbiAgICAgICAgICB0aGlzLmFzc2VydEFQSUVycm9yKCB7XHJcbiAgICAgICAgICAgIHBoZXRpb0lEOiBwaGV0aW9JRCxcclxuICAgICAgICAgICAgcnVsZUluVmlvbGF0aW9uOiAnMy4gQW55IHNjaGVtYSBlbnRyaWVzIGluIHRoZSBvdmVycmlkZXMgZmlsZSBtdXN0IGV4aXN0IGluIHRoZSBiYXNlbGluZSBmaWxlLicsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdwaGV0aW9JRCBleHBlY3RlZCBpbiB0aGUgYmFzZWxpbmUgZmlsZSBidXQgZG9lcyBub3QgZXhpc3QnXHJcbiAgICAgICAgICB9ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgIGNvbnN0IG92ZXJyaWRlID0gd2luZG93LnBoZXQucHJlbG9hZHMucGhldGlvLnBoZXRpb0VsZW1lbnRzT3ZlcnJpZGVzWyBwaGV0aW9JRCBdO1xyXG4gICAgICAgICAgY29uc3QgYmFzZWxpbmUgPSBlbnRpcmVCYXNlbGluZVsgcGhldGlvSUQgXTtcclxuXHJcbiAgICAgICAgICBpZiAoIE9iamVjdC5rZXlzKCBvdmVycmlkZSApLmxlbmd0aCA9PT0gMCApIHtcclxuICAgICAgICAgICAgdGhpcy5hc3NlcnRBUElFcnJvcigge1xyXG4gICAgICAgICAgICAgIHBoZXRpb0lEOiBwaGV0aW9JRCxcclxuICAgICAgICAgICAgICBydWxlSW5WaW9sYXRpb246ICc0LiBBbnkgc2NoZW1hIGVudHJpZXMgaW4gdGhlIG92ZXJyaWRlcyBmaWxlIG11c3QgYmUgZGlmZmVyZW50IGZyb20gaXRzIGJhc2VsaW5lIGNvdW50ZXJwYXJ0LicsXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ25vIG1ldGFkYXRhIGtleXMgZm91bmQgZm9yIHRoaXMgb3ZlcnJpZGUuJ1xyXG4gICAgICAgICAgICB9ICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yICggY29uc3QgbWV0YWRhdGFLZXkgaW4gb3ZlcnJpZGUgKSB7XHJcbiAgICAgICAgICAgIGlmICggIWJhc2VsaW5lLmhhc093blByb3BlcnR5KCBtZXRhZGF0YUtleSApICkge1xyXG4gICAgICAgICAgICAgIHRoaXMuYXNzZXJ0QVBJRXJyb3IoIHtcclxuICAgICAgICAgICAgICAgIHBoZXRpb0lEOiBwaGV0aW9JRCxcclxuICAgICAgICAgICAgICAgIHJ1bGVJblZpb2xhdGlvbjogJzguIEFueSBzY2hlbWEgZW50cmllcyBpbiB0aGUgb3ZlcnJpZGVzIGZpbGUgbXVzdCBiZSBkaWZmZXJlbnQgZnJvbSBpdHMgYmFzZWxpbmUgY291bnRlcnBhcnQuJyxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBwaGV0aW9JRCBtZXRhZGF0YSBrZXkgbm90IGZvdW5kIGluIHRoZSBiYXNlbGluZTogJHttZXRhZGF0YUtleX1gXHJcbiAgICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIG92ZXJyaWRlWyBtZXRhZGF0YUtleSBdID09PSBiYXNlbGluZVsgbWV0YWRhdGFLZXkgXSApIHtcclxuICAgICAgICAgICAgICB0aGlzLmFzc2VydEFQSUVycm9yKCB7XHJcbiAgICAgICAgICAgICAgICBwaGV0aW9JRDogcGhldGlvSUQsXHJcbiAgICAgICAgICAgICAgICBydWxlSW5WaW9sYXRpb246ICc4LiBBbnkgc2NoZW1hIGVudHJpZXMgaW4gdGhlIG92ZXJyaWRlcyBmaWxlIG11c3QgYmUgZGlmZmVyZW50IGZyb20gaXRzIGJhc2VsaW5lIGNvdW50ZXJwYXJ0LicsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAncGhldGlvSUQgbWV0YWRhdGEgb3ZlcnJpZGUgdmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhlIGNvcnJlc3BvbmRpbmcgbWV0YWRhdGEgdmFsdWUgaW4gdGhlIGJhc2VsaW5lLidcclxuICAgICAgICAgICAgICB9ICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFzc2VydCBvdXQgdGhlIGZhaWxlZCBBUEkgdmFsaWRhdGlvbiBydWxlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXNzZXJ0QVBJRXJyb3IoIGFwaUVycm9yT2JqZWN0OiBBUElNaXNtYXRjaCApOiB2b2lkIHtcclxuXHJcbiAgICBjb25zdCBtaXNtYXRjaE1lc3NhZ2UgPSBhcGlFcnJvck9iamVjdC5waGV0aW9JRCA/IGAke2FwaUVycm9yT2JqZWN0LnBoZXRpb0lEfTogICR7YXBpRXJyb3JPYmplY3QucnVsZUluVmlvbGF0aW9ufWAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7YXBpRXJyb3JPYmplY3QucnVsZUluVmlvbGF0aW9ufWA7XHJcblxyXG4gICAgdGhpcy5hcGlNaXNtYXRjaGVzLnB1c2goIGFwaUVycm9yT2JqZWN0ICk7XHJcblxyXG4gICAgLy8gSWYgP3BoZXRpb1ByaW50QVBJUHJvYmxlbXMgaXMgcHJlc2VudCwgdGhlbiBpZ25vcmUgYXNzZXJ0aW9ucyB1bnRpbCB0aGUgc2ltIGhhcyBzdGFydGVkIHVwLlxyXG4gICAgaWYgKCB0aGlzLnNpbUhhc1N0YXJ0ZWQgfHwgIXBoZXQucHJlbG9hZHMucGhldGlvLnF1ZXJ5UGFyYW1ldGVycy5waGV0aW9QcmludEFQSVByb2JsZW1zICkge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgYFBoRVQtaU8gQVBJIGVycm9yOlxcbiR7bWlzbWF0Y2hNZXNzYWdlfWAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb21wYXJlIGEgZHluYW1pYyBwaGV0aW9PYmplY3QncyBtZXRhZGF0YSB0byB0aGUgZXhwZWN0ZWQgbWV0YWRhdGFcclxuICAgKi9cclxuICBwcml2YXRlIGNoZWNrRHluYW1pY0luc3RhbmNlQWdhaW5zdEFyY2hldHlwZSggcGhldGlvT2JqZWN0OiBQaGV0aW9PYmplY3QsIGFyY2hldHlwZU1ldGFkYXRhOiBQaGV0aW9PYmplY3RNZXRhZGF0YSwgc291cmNlOiBzdHJpbmcgKTogdm9pZCB7XHJcbiAgICBjb25zdCBhY3R1YWxNZXRhZGF0YSA9IHBoZXRpb09iamVjdC5nZXRNZXRhZGF0YSgpO1xyXG4gICAgS0VZU19UT19DSEVDSy5mb3JFYWNoKCBrZXkgPT4ge1xyXG5cclxuICAgICAgLy8gVGhlc2UgYXR0cmlidXRlcyBhcmUgZGlmZmVyZW50IGZvciBhcmNoZXR5cGUgdnMgYWN0dWFsXHJcbiAgICAgIGlmICgga2V5ICE9PSAncGhldGlvRHluYW1pY0VsZW1lbnQnICYmIGtleSAhPT0gJ3BoZXRpb0FyY2hldHlwZVBoZXRpb0lEJyAmJiBrZXkgIT09ICdwaGV0aW9Jc0FyY2hldHlwZScgKSB7XHJcblxyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBub3Qgc3VyZSBob3cgdG8gYmUgdHlwZXNhZmUgaW4gdGhlIEFQSSBmaWxlc1xyXG4gICAgICAgIGlmICggYXJjaGV0eXBlTWV0YWRhdGFbIGtleSBdICE9PSBhY3R1YWxNZXRhZGF0YVsga2V5IF0gJiYgcGhldGlvT2JqZWN0LnRhbmRlbSApIHtcclxuICAgICAgICAgIHRoaXMuYXNzZXJ0QVBJRXJyb3IoIHtcclxuICAgICAgICAgICAgcGhldGlvSUQ6IHBoZXRpb09iamVjdC50YW5kZW0ucGhldGlvSUQsXHJcbiAgICAgICAgICAgIHJ1bGVJblZpb2xhdGlvbjogJzUuIER5bmFtaWMgZWxlbWVudCBtZXRhZGF0YSBzaG91bGQgbWF0Y2ggdGhlIGFyY2hldHlwZSBpbiB0aGUgQVBJLicsXHJcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBgbWlzbWF0Y2hlZCBtZXRhZGF0YTogJHtrZXl9YFxyXG4gICAgICAgICAgfSApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSApO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbmNvbnN0IHBoZXRpb0FQSVZhbGlkYXRpb24gPSBuZXcgUGhldGlvQVBJVmFsaWRhdGlvbigpO1xyXG50YW5kZW1OYW1lc3BhY2UucmVnaXN0ZXIoICdwaGV0aW9BUElWYWxpZGF0aW9uJywgcGhldGlvQVBJVmFsaWRhdGlvbiApO1xyXG5leHBvcnQgZGVmYXVsdCBwaGV0aW9BUElWYWxpZGF0aW9uOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLE1BQU0sSUFBSUMsc0JBQXNCLFFBQVEsYUFBYTtBQUM1RCxPQUFPQyxlQUFlLE1BQU0sc0JBQXNCO0FBRWxELFNBQXVCQyxhQUFhLFFBQVEsbUJBQW1CO0FBRy9EO0FBQ0E7QUFDQSxNQUFNQyxhQUFhLEdBQUcsQ0FDcEIsc0JBQXNCLEVBQ3RCLGlCQUFpQixFQUNqQixtQkFBbUIsRUFDbkIsZ0JBQWdCLEVBQ2hCLGdCQUFnQixFQUNoQixhQUFhLEVBQ2IsZ0JBQWdCLENBQ2pCOztBQUVEO0FBQ0E7QUFRQSxNQUFNQyxtQkFBbUIsQ0FBQztFQUNQQyxhQUFh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