// Copyright 2020-2023, University of Colorado Boulder

/**
 * IO Types form a synthetic type system used to describe PhET-iO Elements. A PhET-iO Element is an instrumented PhetioObject
 * that is interoperable from the "wrapper" frame (outside the sim frame). An IO Type includes documentation, methods,
 * names, serialization, etc.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import validate from '../../../axon/js/validate.js';
import Validation from '../../../axon/js/Validation.js';
import optionize from '../../../phet-core/js/optionize.js';
import PhetioConstants from '../PhetioConstants.js';
import TandemConstants from '../TandemConstants.js';
import tandemNamespace from '../tandemNamespace.js';
import StateSchema from './StateSchema.js';
// constants
const VALIDATE_OPTIONS_FALSE = {
  validateValidator: false
};

/**
 * Estimate the core type name from a given IO Type name.
 */
const getCoreTypeName = ioTypeName => {
  const index = ioTypeName.indexOf(PhetioConstants.IO_TYPE_SUFFIX);
  assert && assert(index >= 0, 'IO should be in the type name');
  return ioTypeName.substring(0, index);
};
// TODO: not any, but do we have to serialize type parameters? https://github.com/phetsims/tandem/issues/263
export default class IOType {
  // eslint-disable-line @typescript-eslint/no-explicit-any

  // TODO: instead of unknown this is the second parameter type for PhetioDynamicElementContainer. How? https://github.com/phetsims/tandem/issues/261

  /**
   * @param typeName - The name that this IOType will have in the public PhET-iO API. In general, this should
   *    only be word characters, ending in "IO". Parametric types are a special subset of IOTypes that include their
   *    parameters in their typeName. If an IOType's parameters are other IO Type(s), then they should be included within
   *    angle brackets, like "PropertyIO<BooleanIO>". Some other types use a more custom format for displaying their
   *    parameter types, in this case the parameter section of the type name (immediately following "IO") should begin
   *    with an open paren, "(". Thus the schema for a typeName could be defined (using regex) as `[A-Z]\w*IO([(<].*){0,1}`.
   *    Parameterized types should also include a `parameterTypes` field on the IOType.
   * @param providedOptions
   */
  constructor(typeName, providedOptions) {
    this.typeName = typeName;
    // For reference in the options
    const supertype = providedOptions.supertype || IOType.ObjectIO;
    const toStateObjectSupplied = !!providedOptions.toStateObject;
    const applyStateSupplied = !!providedOptions.applyState;
    const stateSchemaSupplied = !!providedOptions.stateSchema;
    const options = optionize()({
      supertype: IOType.ObjectIO,
      methods: {},
      events: [],
      metadataDefaults: {},
      //  Most likely this will remain PhET-iO internal, and shouldn't need to be used when creating IOTypes outside of tandem/.
      dataDefaults: {},
      methodOrder: [],
      parameterTypes: [],
      documentation: `IO Type for ${getCoreTypeName(typeName)}`,
      isFunctionType: false,
      /**** STATE ****/

      toStateObject: supertype && supertype.toStateObject,
      fromStateObject: supertype && supertype.fromStateObject,
      stateObjectToCreateElementArguments: supertype && supertype.stateObjectToCreateElementArguments,
      applyState: supertype && supertype.applyState,
      stateSchema: null,
      defaultDeserializationMethod: 'fromStateObject',
      addChildElement: supertype && supertype.addChildElement
    }, providedOptions);
    if (assert && supertype) {
      Object.keys(options.metadataDefaults).forEach(metadataDefaultKey => {
        assert && supertype.getAllMetadataDefaults().hasOwnProperty(metadataDefaultKey) && assert(supertype.getAllMetadataDefaults()[metadataDefaultKey] !== options.metadataDefaults[metadataDefaultKey], `${metadataDefaultKey} should not have the same default value as the ancestor metadata default.`);
      });
    }
    this.supertype = supertype;
    this.documentation = options.documentation;
    this.methods = options.methods;
    this.events = options.events;
    this.metadataDefaults = options.metadataDefaults; // just for this level, see getAllMetadataDefaults()
    this.dataDefaults = options.dataDefaults; // just for this level, see getAllDataDefaults()
    this.methodOrder = options.methodOrder;
    this.parameterTypes = options.parameterTypes;

    // Validation
    this.validator = _.pick(options, Validation.VALIDATOR_KEYS);
    this.validator.validationMessage = this.validator.validationMessage || `Validation failed IOType Validator: ${this.typeName}`;
    this.defaultDeserializationMethod = options.defaultDeserializationMethod;
    if (options.stateSchema === null || options.stateSchema instanceof StateSchema) {
      // @ts-expect-error https://github.com/phetsims/tandem/issues/263
      this.stateSchema = options.stateSchema;
    } else {
      const compositeSchema = typeof options.stateSchema === 'function' ? options.stateSchema(this) : options.stateSchema;
      this.stateSchema = new StateSchema({
        compositeSchema: compositeSchema
      });
    }

    // Assert that toStateObject method is provided for value StateSchemas. Do this with the following logic:
    // 1. It is acceptable to not provide a stateSchema (for IOTypes that aren't stateful)
    // 2. You must either provide a toStateObject, or have a composite StateSchema. Composite state schemas support default serialization methods.
    assert && assert(!this.stateSchema || toStateObjectSupplied || this.stateSchema.isComposite(), 'toStateObject method must be provided for value StateSchemas');
    this.toStateObject = coreObject => {
      validate(coreObject, this.validator, VALIDATE_OPTIONS_FALSE);
      let toStateObject;

      // Only do this non-standard toStateObject function if there is a stateSchema but no toStateObject provided
      if (!toStateObjectSupplied && stateSchemaSupplied && this.stateSchema && this.stateSchema.isComposite()) {
        toStateObject = this.stateSchema.defaultToStateObject(coreObject);
      } else {
        toStateObject = options.toStateObject(coreObject);
      }

      // Validate, but only if this IOType instance has more to validate than the supertype
      if (toStateObjectSupplied || stateSchemaSupplied) {
        // Only validate the stateObject if it is phetioState:true.
        // This is an n*m algorithm because for each time toStateObject is called and needs validation, this.validateStateObject
        // looks all the way up the IOType hierarchy. This is not efficient, but gains us the ability to make sure that
        // the stateObject doesn't have any superfluous, unexpected keys. The "m" portion is based on how many sub-properties
        // in a state call `toStateObject`, and the "n" portion is based on how many IOTypes in the hierarchy define a
        // toStateObject or stateSchema. In the future we could potentially improve performance by having validateStateObject
        // only check against the schema at this level, but then extra keys in the stateObject would not be caught. From work done in https://github.com/phetsims/phet-io/issues/1774
        assert && this.validateStateObject(toStateObject);
      }
      return toStateObject;
    };
    this.fromStateObject = options.fromStateObject;
    this.stateObjectToCreateElementArguments = options.stateObjectToCreateElementArguments;
    this.applyState = (coreObject, stateObject) => {
      validate(coreObject, this.validator, VALIDATE_OPTIONS_FALSE);

      // Validate, but only if this IOType instance has more to validate than the supertype
      if (applyStateSupplied || stateSchemaSupplied) {
        // Validate that the provided stateObject is of the expected schema
        // NOTE: Cannot use this.validateStateObject because options adopts supertype.applyState, which is bounds to the
        // parent IO Type. This prevents correct validation because the supertype doesn't know about the subtype schemas.
        // @ts-expect-error we cannot type check against PhetioObject from this file
        assert && coreObject.phetioType.validateStateObject(stateObject);
      }

      // Only do this non-standard applyState function from stateSchema if there is a stateSchema but no applyState provided
      if (!applyStateSupplied && stateSchemaSupplied && this.stateSchema && this.stateSchema.isComposite()) {
        this.stateSchema.defaultApplyState(coreObject, stateObject);
      } else {
        options.applyState(coreObject, stateObject);
      }
    };
    this.isFunctionType = options.isFunctionType;
    this.addChildElement = options.addChildElement;
    if (assert) {
      assert && assert(supertype || this.typeName === 'ObjectIO', 'supertype is required');
      assert && assert(!this.typeName.includes('.'), 'Dots should not appear in type names');
      assert && assert(this.typeName.split(/[<(]/)[0].endsWith(PhetioConstants.IO_TYPE_SUFFIX), `IO Type name must end with ${PhetioConstants.IO_TYPE_SUFFIX}`);
      assert && assert(this.hasOwnProperty('typeName'), 'this.typeName is required');

      // assert that each public method adheres to the expected schema
      this.methods && Object.values(this.methods).forEach(methodObject => {
        if (typeof methodObject === 'object') {
          assert && methodObject.invocableForReadOnlyElements && assert(typeof methodObject.invocableForReadOnlyElements === 'boolean', `invocableForReadOnlyElements must be of type boolean: ${methodObject.invocableForReadOnlyElements}`);
        }
      });
      assert && assert(this.documentation.length > 0, 'documentation must be provided');
      this.methods && this.hasOwnProperty('methodOrder') && this.methodOrder.forEach(methodName => {
        assert && assert(this.methods[methodName], `methodName not in public methods: ${methodName}`);
      });
      if (supertype) {
        const typeHierarchy = supertype.getTypeHierarchy();
        assert && this.events && this.events.forEach(event => {
          // Make sure events are not listed again
          assert && assert(!_.some(typeHierarchy, t => t.events.includes(event)), `IOType should not declare event that parent also has: ${event}`);
        });
      } else {
        // The root IOType must supply all 4 state methods.
        assert && assert(typeof options.toStateObject === 'function', 'toStateObject must be defined');
        assert && assert(typeof options.fromStateObject === 'function', 'fromStateObject must be defined');
        assert && assert(typeof options.stateObjectToCreateElementArguments === 'function', 'stateObjectToCreateElementArguments must be defined');
        assert && assert(typeof options.applyState === 'function', 'applyState must be defined');
      }
    }
  }

  /**
   * Gets an array of IOTypes of the self type and all the supertype ancestors.
   */
  getTypeHierarchy() {
    const array = [];

    // @ts-expect-error Still working out this stuff, https://github.com/phetsims/tandem/issues/263
    let ioType = this; // eslint-disable-line consistent-this, @typescript-eslint/no-this-alias
    while (ioType) {
      array.push(ioType);
      ioType = ioType.supertype;
    }
    return array;
  }

  /**
   * Returns true if this IOType is a subtype of the passed-in type (or if they are the same).
   */
  extends(type) {
    // memory-based implementation OK since this method is only used in assertions
    return this.getTypeHierarchy().includes(type);
  }

  /**
   * Return all the metadata defaults (for the entire IO Type hierarchy)
   */
  getAllMetadataDefaults() {
    return _.merge({}, this.supertype ? this.supertype.getAllMetadataDefaults() : {}, this.metadataDefaults);
  }

  /**
   * Return all the data defaults (for the entire IO Type hierarchy)
   */
  getAllDataDefaults() {
    return _.merge({}, this.supertype ? this.supertype.getAllDataDefaults() : {}, this.dataDefaults);
  }

  /**
   * @param stateObject - the stateObject to validate against
   * @param toAssert=false - whether to assert when invalid
   * @param schemaKeysPresentInStateObject=[]
   * @returns if the stateObject is valid or not.
   */
  isStateObjectValid(stateObject, toAssert = false, schemaKeysPresentInStateObject = []) {
    // Set to false when invalid
    let valid = true;

    // make sure the stateObject has everything the schema requires and nothing more
    if (this.stateSchema) {
      const validSoFar = this.stateSchema.checkStateObjectValid(stateObject, toAssert, schemaKeysPresentInStateObject);

      // null as a marker to keep checking up the hierarchy, otherwise we reached our based case because the stateSchema was a value, not a composite
      if (validSoFar !== null) {
        return validSoFar;
      }
    }
    if (this.supertype) {
      return valid && this.supertype.isStateObjectValid(stateObject, toAssert, schemaKeysPresentInStateObject);
    }

    // When we reach the root, make sure there isn't anything in the stateObject that isn't described by a schema
    if (!this.supertype && stateObject && typeof stateObject !== 'string' && !Array.isArray(stateObject)) {
      // Visit the state
      Object.keys(stateObject).forEach(key => {
        const keyValid = schemaKeysPresentInStateObject.includes(key);
        if (!keyValid) {
          valid = false;
        }
        assert && toAssert && assert(keyValid, `stateObject provided a key that is not in the schema: ${key}`);
      });
      return valid;
    }
    return true;
  }

  /**
   * Assert if the provided stateObject is not valid to this IOType's stateSchema
   */
  validateStateObject(stateObject) {
    this.isStateObjectValid(stateObject, true);
  }
  toString() {
    return this.typeName;
  }
}

// default state value
const DEFAULT_STATE = null;
IOType.ObjectIO = new IOType(TandemConstants.OBJECT_IO_TYPE_NAME, {
  isValidValue: () => true,
  supertype: null,
  documentation: 'The root of the IO Type hierarchy',
  toStateObject: coreObject => {
    if (phet && phet.tandem && phet.tandem.Tandem.VALIDATION) {
      assert && assert(coreObject.tandem, 'coreObject must be PhET-iO object');
      assert && assert(!coreObject.phetioState, `fell back to root serialization state for ${coreObject.tandem.phetioID}. Potential solutions:
         * mark the type as phetioState: false
         * create a custom toStateObject method in your IO Type
         * perhaps you have everything right, but forgot to pass in the IOType via phetioType in the constructor`);
    }
    return DEFAULT_STATE;
  },
  fromStateObject: () => {
    throw new Error('ObjectIO.fromStateObject should not be called');
  },
  stateObjectToCreateElementArguments: () => [],
  applyState: _.noop,
  metadataDefaults: TandemConstants.PHET_IO_OBJECT_METADATA_DEFAULTS,
  dataDefaults: {
    initialState: DEFAULT_STATE
  },
  stateSchema: null
});
tandemNamespace.register('IOType', IOType);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ2YWxpZGF0ZSIsIlZhbGlkYXRpb24iLCJvcHRpb25pemUiLCJQaGV0aW9Db25zdGFudHMiLCJUYW5kZW1Db25zdGFudHMiLCJ0YW5kZW1OYW1lc3BhY2UiLCJTdGF0ZVNjaGVtYSIsIlZBTElEQVRFX09QVElPTlNfRkFMU0UiLCJ2YWxpZGF0ZVZhbGlkYXRvciIsImdldENvcmVUeXBlTmFtZSIsImlvVHlwZU5hbWUiLCJpbmRleCIsImluZGV4T2YiLCJJT19UWVBFX1NVRkZJWCIsImFzc2VydCIsInN1YnN0cmluZyIsIklPVHlwZSIsImNvbnN0cnVjdG9yIiwidHlwZU5hbWUiLCJwcm92aWRlZE9wdGlvbnMiLCJzdXBlcnR5cGUiLCJPYmplY3RJTyIsInRvU3RhdGVPYmplY3RTdXBwbGllZCIsInRvU3RhdGVPYmplY3QiLCJhcHBseVN0YXRlU3VwcGxpZWQiLCJhcHBseVN0YXRlIiwic3RhdGVTY2hlbWFTdXBwbGllZCIsInN0YXRlU2NoZW1hIiwib3B0aW9ucyIsIm1ldGhvZHMiLCJldmVudHMiLCJtZXRhZGF0YURlZmF1bHRzIiwiZGF0YURlZmF1bHRzIiwibWV0aG9kT3JkZXIiLCJwYXJhbWV0ZXJUeXBlcyIsImRvY3VtZW50YXRpb24iLCJpc0Z1bmN0aW9uVHlwZSIsImZyb21TdGF0ZU9iamVjdCIsInN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzIiwiZGVmYXVsdERlc2VyaWFsaXphdGlvbk1ldGhvZCIsImFkZENoaWxkRWxlbWVudCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwibWV0YWRhdGFEZWZhdWx0S2V5IiwiZ2V0QWxsTWV0YWRhdGFEZWZhdWx0cyIsImhhc093blByb3BlcnR5IiwidmFsaWRhdG9yIiwiXyIsInBpY2siLCJWQUxJREFUT1JfS0VZUyIsInZhbGlkYXRpb25NZXNzYWdlIiwiY29tcG9zaXRlU2NoZW1hIiwiaXNDb21wb3NpdGUiLCJjb3JlT2JqZWN0IiwiZGVmYXVsdFRvU3RhdGVPYmplY3QiLCJ2YWxpZGF0ZVN0YXRlT2JqZWN0Iiwic3RhdGVPYmplY3QiLCJwaGV0aW9UeXBlIiwiZGVmYXVsdEFwcGx5U3RhdGUiLCJpbmNsdWRlcyIsInNwbGl0IiwiZW5kc1dpdGgiLCJ2YWx1ZXMiLCJtZXRob2RPYmplY3QiLCJpbnZvY2FibGVGb3JSZWFkT25seUVsZW1lbnRzIiwibGVuZ3RoIiwibWV0aG9kTmFtZSIsInR5cGVIaWVyYXJjaHkiLCJnZXRUeXBlSGllcmFyY2h5IiwiZXZlbnQiLCJzb21lIiwidCIsImFycmF5IiwiaW9UeXBlIiwicHVzaCIsImV4dGVuZHMiLCJ0eXBlIiwibWVyZ2UiLCJnZXRBbGxEYXRhRGVmYXVsdHMiLCJpc1N0YXRlT2JqZWN0VmFsaWQiLCJ0b0Fzc2VydCIsInNjaGVtYUtleXNQcmVzZW50SW5TdGF0ZU9iamVjdCIsInZhbGlkIiwidmFsaWRTb0ZhciIsImNoZWNrU3RhdGVPYmplY3RWYWxpZCIsIkFycmF5IiwiaXNBcnJheSIsImtleSIsImtleVZhbGlkIiwidG9TdHJpbmciLCJERUZBVUxUX1NUQVRFIiwiT0JKRUNUX0lPX1RZUEVfTkFNRSIsImlzVmFsaWRWYWx1ZSIsInBoZXQiLCJ0YW5kZW0iLCJUYW5kZW0iLCJWQUxJREFUSU9OIiwicGhldGlvU3RhdGUiLCJwaGV0aW9JRCIsIkVycm9yIiwibm9vcCIsIlBIRVRfSU9fT0JKRUNUX01FVEFEQVRBX0RFRkFVTFRTIiwiaW5pdGlhbFN0YXRlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJJT1R5cGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogSU8gVHlwZXMgZm9ybSBhIHN5bnRoZXRpYyB0eXBlIHN5c3RlbSB1c2VkIHRvIGRlc2NyaWJlIFBoRVQtaU8gRWxlbWVudHMuIEEgUGhFVC1pTyBFbGVtZW50IGlzIGFuIGluc3RydW1lbnRlZCBQaGV0aW9PYmplY3RcclxuICogdGhhdCBpcyBpbnRlcm9wZXJhYmxlIGZyb20gdGhlIFwid3JhcHBlclwiIGZyYW1lIChvdXRzaWRlIHRoZSBzaW0gZnJhbWUpLiBBbiBJTyBUeXBlIGluY2x1ZGVzIGRvY3VtZW50YXRpb24sIG1ldGhvZHMsXHJcbiAqIG5hbWVzLCBzZXJpYWxpemF0aW9uLCBldGMuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIFJlaWQgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4uLy4uLy4uL2F4b24vanMvdmFsaWRhdGUuanMnO1xyXG5pbXBvcnQgVmFsaWRhdGlvbiwgeyBWYWxpZGF0b3IgfSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1ZhbGlkYXRpb24uanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgUGhldGlvQ29uc3RhbnRzIGZyb20gJy4uL1BoZXRpb0NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBUYW5kZW1Db25zdGFudHMsIHsgSU9UeXBlTmFtZSwgUGhldGlvT2JqZWN0TWV0YWRhdGEgfSBmcm9tICcuLi9UYW5kZW1Db25zdGFudHMuanMnO1xyXG5pbXBvcnQgdGFuZGVtTmFtZXNwYWNlIGZyb20gJy4uL3RhbmRlbU5hbWVzcGFjZS5qcyc7XHJcbmltcG9ydCBTdGF0ZVNjaGVtYSwgeyBDb21wb3NpdGVTY2hlbWEsIENvbXBvc2l0ZVN0YXRlT2JqZWN0VHlwZSB9IGZyb20gJy4vU3RhdGVTY2hlbWEuanMnO1xyXG5pbXBvcnQgdHlwZSBQaGV0aW9PYmplY3QgZnJvbSAnLi4vUGhldGlvT2JqZWN0LmpzJztcclxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9JbnRlbnRpb25hbEFueS5qcyc7XHJcbmltcG9ydCBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lciBmcm9tICcuLi9QaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lci5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgVkFMSURBVEVfT1BUSU9OU19GQUxTRSA9IHsgdmFsaWRhdGVWYWxpZGF0b3I6IGZhbHNlIH07XHJcblxyXG4vKipcclxuICogRXN0aW1hdGUgdGhlIGNvcmUgdHlwZSBuYW1lIGZyb20gYSBnaXZlbiBJTyBUeXBlIG5hbWUuXHJcbiAqL1xyXG5jb25zdCBnZXRDb3JlVHlwZU5hbWUgPSAoIGlvVHlwZU5hbWU6IElPVHlwZU5hbWUgKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBpbmRleCA9IGlvVHlwZU5hbWUuaW5kZXhPZiggUGhldGlvQ29uc3RhbnRzLklPX1RZUEVfU1VGRklYICk7XHJcbiAgYXNzZXJ0ICYmIGFzc2VydCggaW5kZXggPj0gMCwgJ0lPIHNob3VsZCBiZSBpbiB0aGUgdHlwZSBuYW1lJyApO1xyXG4gIHJldHVybiBpb1R5cGVOYW1lLnN1YnN0cmluZyggMCwgaW5kZXggKTtcclxufTtcclxuXHJcbnR5cGUgQWRkQ2hpbGRFbGVtZW50ID0gKCBncm91cDogUGhldGlvRHluYW1pY0VsZW1lbnRDb250YWluZXI8UGhldGlvT2JqZWN0PiwgY29tcG9uZW50TmFtZTogc3RyaW5nLCBzdGF0ZU9iamVjdDogdW5rbm93biApID0+IFBoZXRpb09iamVjdDtcclxuXHJcbmV4cG9ydCB0eXBlIElPVHlwZU1ldGhvZCA9IHtcclxuICByZXR1cm5UeXBlOiBJT1R5cGU7XHJcbiAgcGFyYW1ldGVyVHlwZXM6IElPVHlwZVtdO1xyXG5cclxuICAvL3RoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkLiBUaGlzIGZ1bmN0aW9uJ3MgcGFyYW1ldGVycyB3aWxsIGJlIGJhc2VkIG9uIGBwYXJhbWV0ZXJUeXBlc2AsXHJcbiAgLy8gYW5kIHNob3VsZCByZXR1cm4gdGhlIHR5cGUgc3BlY2lmaWVkIGJ5IGByZXR1cm5UeXBlYFxyXG4gIGltcGxlbWVudGF0aW9uOiAoIC4uLmFyZ3M6IEludGVudGlvbmFsQW55W10gKSA9PiB1bmtub3duO1xyXG4gIGRvY3VtZW50YXRpb246IHN0cmluZztcclxuXHJcbiAgLy8gYnkgZGVmYXVsdCwgYWxsIG1ldGhvZHMgYXJlIGludm9jYWJsZSBmb3IgYWxsIGVsZW1lbnRzLiBIb3dldmVyLCBmb3Igc29tZSByZWFkLW9ubHkgZWxlbWVudHMsIGNlcnRhaW4gbWV0aG9kc1xyXG4gIC8vIHNob3VsZCBub3QgYmUgaW52b2NhYmxlLiBJbiB0aGF0IGNhc2UsIHRoZXkgYXJlIG1hcmtlZCBhcyBpbnZvY2FibGVGb3JSZWFkT25seUVsZW1lbnRzOiBmYWxzZS5cclxuICBpbnZvY2FibGVGb3JSZWFkT25seUVsZW1lbnRzPzogYm9vbGVhbjtcclxufTtcclxuXHJcbnR5cGUgRGVzZXJpYWxpemF0aW9uVHlwZSA9ICdmcm9tU3RhdGVPYmplY3QnIHwgJ2FwcGx5U3RhdGUnO1xyXG5cclxudHlwZSBTdGF0ZVNjaGVtYU9wdGlvbjxULCBTdGF0ZVR5cGU+ID0gKFxyXG4gICggaW9UeXBlOiBJT1R5cGU8VCwgU3RhdGVUeXBlPiApID0+IENvbXBvc2l0ZVNjaGVtYSApIHxcclxuICBTdGF0ZVNjaGVtYTxULCBTdGF0ZVR5cGU+IHxcclxuICBDb21wb3NpdGVTY2hlbWEgfFxyXG4gIG51bGw7XHJcblxyXG50eXBlIFNlbGZPcHRpb25zPFQsIFN0YXRlVHlwZT4gPSB7XHJcblxyXG4gIC8vIElPIFR5cGVzIGZvcm0gYW4gb2JqZWN0IHRyZWUgbGlrZSBhIHR5cGUgaGllcmFyY2h5LiBJZiB0aGUgc3VwZXJ0eXBlIGlzIHNwZWNpZmllZCwgYXR0cmlidXRlcyBzdWNoIGFzXHJcbiAgLy8gdG9TdGF0ZU9iamVjdCwgZnJvbVN0YXRlT2JqZWN0LCBzdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cywgYXBwbHlTdGF0ZSwgYWRkQ2hpbGRFbGVtZW50XHJcbiAgLy8gd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgc3VwZXJ0eXBlICh1bmxlc3Mgb3ZlcnJpZGRlbikuICBJdCBpcyBhbHNvIHVzZWQgaW4gZmVhdHVyZXMgc3VjaCBhcyBzY2hlbWEgdmFsaWRhdGlvbixcclxuICAvLyBkYXRhL21ldGFkYXRhIGRlZmF1bHQgY2FsY3VsYXRpb25zLlxyXG4gIHN1cGVydHlwZT86IElPVHlwZSB8IG51bGw7XHJcblxyXG4gIC8vIFRoZSBsaXN0IG9mIGV2ZW50cyB0aGF0IGNhbiBiZSBlbWl0dGVkIGF0IHRoaXMgbGV2ZWwgKGRvZXMgbm90IGluY2x1ZGUgZXZlbnRzIGZyb20gc3VwZXJ0eXBlcykuXHJcbiAgZXZlbnRzPzogc3RyaW5nW107XHJcblxyXG4gIC8vIEtleS92YWx1ZSBwYWlycyBpbmRpY2F0aW5nIHRoZSBkZWZhdWx0cyBmb3IgdGhlIElPIFR5cGUgZGF0YSwganVzdCBmb3IgdGhpcyBsZXZlbCAoZG8gbm90IHNwZWNpZnkgcGFyZW50IGRlZmF1bHRzKVxyXG4gIGRhdGFEZWZhdWx0cz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cclxuICAvLyBLZXkvdmFsdWUgcGFpcnMgaW5kaWNhdGluZyB0aGUgZGVmYXVsdHMgZm9yIHRoZSBJTyBUeXBlIG1ldGFkYXRhLlxyXG4gIC8vIElmIGFueXRoaW5nIGlzIHByb3ZpZGVkIGhlcmUsIHRoZW4gY29ycmVzcG9uZGluZyBQaGV0aW9PYmplY3RzIHRoYXQgdXNlIHRoaXMgSU9UeXBlIHNob3VsZCBvdmVycmlkZVxyXG4gIC8vIFBoZXRpb09iamVjdC5nZXRNZXRhZGF0YSgpIHRvIGFkZCB3aGF0IGtleXMgdGhleSBuZWVkIGZvciB0aGVpciBzcGVjaWZpYyB0eXBlLiAgQ2Fubm90IHNwZWNpZnkgcmVkdW5kYW50IHZhbHVlc1xyXG4gIC8vICh0aGF0IGFuIGFuY2VzdG9yIGFscmVhZHkgc3BlY2lmaWVkKS5cclxuICBtZXRhZGF0YURlZmF1bHRzPzogUGFydGlhbDxQaGV0aW9PYmplY3RNZXRhZGF0YT47XHJcblxyXG4gIC8vIFRleHQgdGhhdCBkZXNjcmliZXMgdGhlIElPIFR5cGUsIHByZXNlbnRlZCB0byB0aGUgUGhFVC1pTyBDbGllbnQgaW4gU3R1ZGlvLCBzdXBwb3J0cyBIVE1MIG1hcmt1cC5cclxuICBkb2N1bWVudGF0aW9uPzogc3RyaW5nO1xyXG5cclxuICAvLyBUaGUgcHVibGljIG1ldGhvZHMgYXZhaWxhYmxlIGZvciB0aGlzIElPIFR5cGUuIEVhY2ggbWV0aG9kIGlzIG5vdCBqdXN0IGEgZnVuY3Rpb24sXHJcbiAgLy8gYnV0IGEgY29sbGVjdGlvbiBvZiBtZXRhZGF0YSBhYm91dCB0aGUgbWV0aG9kIHRvIGJlIGFibGUgdG8gc2VyaWFsaXplIHBhcmFtZXRlcnMgYW5kIHJldHVybiB0eXBlcyBhbmQgcHJvdmlkZVxyXG4gIC8vIGJldHRlciBkb2N1bWVudGF0aW9uLlxyXG4gIG1ldGhvZHM/OiBSZWNvcmQ8c3RyaW5nLCBJT1R5cGVNZXRob2Q+O1xyXG5cclxuICAvLyBJTyBUeXBlcyBjYW4gc3BlY2lmeSB0aGUgb3JkZXIgdGhhdCBtZXRob2RzIGFwcGVhciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBieSBwdXR0aW5nIHRoZWlyIG5hbWVzIGluIHRoaXNcclxuICAvLyBsaXN0LiBUaGlzIGxpc3QgaXMgb25seSBmb3IgdGhlIG1ldGhvZHMgZGVmaW5lZCBhdCB0aGlzIGxldmVsIGluIHRoZSB0eXBlIGhpZXJhcmNoeS4gQWZ0ZXIgdGhlIG1ldGhvZE9yZGVyXHJcbiAgLy8gc3BlY2lmaWVkLCB0aGUgbWV0aG9kcyBmb2xsb3cgaW4gdGhlIG9yZGVyIGRlY2xhcmVkIGluIHRoZSBpbXBsZW1lbnRhdGlvbiAod2hpY2ggaXNuJ3QgbmVjZXNzYXJpbHkgc3RhYmxlKS5cclxuICBtZXRob2RPcmRlcj86IHN0cmluZ1tdO1xyXG5cclxuICAvLyBGb3IgcGFyYW1ldHJpYyB0eXBlcywgdGhleSBtdXN0IGluZGljYXRlIHRoZSB0eXBlcyBvZiB0aGUgcGFyYW1ldGVycyBoZXJlLiBFbXB0eSBhcnJheSBpZiBub24tcGFyYW1ldHJpYy5cclxuICBwYXJhbWV0ZXJUeXBlcz86IElPVHlwZVtdO1xyXG5cclxuICAvLyBGb3IgaW50ZXJuYWwgcGhldC1pbyB1c2Ugb25seS4gRnVuY3Rpb25zIGNhbm5vdCBiZSBzZW50IGZyb20gb25lIGlmcmFtZSB0byBhbm90aGVyLCBzbyBtdXN0IGJlIHdyYXBwZWQuIFNlZVxyXG4gIC8vIHBoZXRpb0NvbW1hbmRQcm9jZXNzb3Iud3JhcEZ1bmN0aW9uXHJcbiAgaXNGdW5jdGlvblR5cGU/OiBib29sZWFuO1xyXG5cclxuICAvLyAqKioqKioqKiBTVEFURSAqKioqKioqKiAvL1xyXG5cclxuICAvLyBUaGUgc3BlY2lmaWNhdGlvbiBmb3IgaG93IHRoZSBQaEVULWlPIHN0YXRlIHdpbGwgbG9vayBmb3IgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS4gbnVsbCBzcGVjaWZpZXMgdGhhdCB0aGUgb2JqZWN0XHJcbiAgLy8gaXMgbm90IHNlcmlhbGl6ZWQuIEEgY29tcG9zaXRlIFN0YXRlU2NoZW1hIGNhbiBzdXBwbHkgYSB0b1N0YXRlT2JqZWN0IGFuZCBhcHBseVN0YXRlIHNlcmlhbGl6YXRpb24gc3RyYXRlZ3kuIFRoaXNcclxuICAvLyBkZWZhdWx0IHNlcmlhbGl6YXRpb24gc3RyYXRlZ3kgb25seSBhcHBsaWVzIHRvIHRoaXMgbGV2ZWwsIGFuZCBkb2VzIG5vdCByZWN1cnNlIHRvIHBhcmVudHMuIElmIHlvdSBuZWVkIHRvIGFkZFxyXG4gIC8vIHNlcmlhbGl6YXRpb24gZnJvbSBwYXJlbnQgbGV2ZWxzLCB0aGlzIGNhbiBiZSBkb25lIGJ5IG1hbnVhbGx5IGltcGxlbWVudGluZyBhIGN1c3RvbSB0b1N0YXRlT2JqZWN0LiBCeSBkZWZhdWx0LCBpdFxyXG4gIC8vIHdpbGwgYXNzdW1lIHRoYXQgZWFjaCBjb21wb3NpdGUgY2hpbGQgb2YgdGhpcyBzdGF0ZVNjaGVtYSBkZXNlcmlhbGl6ZXMgdmlhIFwiZnJvbVN0YXRlT2JqZWN0XCIsIGlmIGluc3RlYWQgaXQgdXNlc1xyXG4gIC8vIGFwcGx5U3RhdGUsIHBsZWFzZSBzcGVjaWZ5IHRoYXQgcGVyIElPVHlwZSB3aXRoIGRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2QuXHJcbiAgLy8gRm9yIHBoZXRpb1N0YXRlOiB0cnVlIG9iamVjdHMsIHRoaXMgc2hvdWxkIGJlIHJlcXVpcmVkLCBidXQgbWF5IGJlIHNwZWNpZmllZCBpbiB0aGUgcGFyZW50IElPVHlwZSwgbGlrZSBpbiBEZXJpdmVkUHJvcGVydHlJT1xyXG4gIHN0YXRlU2NoZW1hPzogU3RhdGVTY2hlbWFPcHRpb248VCwgU3RhdGVUeXBlPjtcclxuXHJcbiAgLy8gU2VyaWFsaXplIHRoZSBjb3JlIG9iamVjdC4gTW9zdCBvZnRlbiB0aGlzIGxvb2tzIGxpa2UgYW4gb2JqZWN0IGxpdGVyYWwgdGhhdCBob2xkcyBkYXRhIGFib3V0IHRoZSBQaGV0aW9PYmplY3RcclxuICAvLyBpbnN0YW5jZS4gVGhpcyBpcyBsaWtlbHkgc3VwZXJmbHVvdXMgdG8ganVzdCBwcm92aWRpbmcgYSBzdGF0ZVNjaGVtYSBvZiBjb21wb3NpdGUga2V5L0lPVHlwZSB2YWx1ZXMsIHdoaWNoIHdpbGxcclxuICAvLyBjcmVhdGUgYSBkZWZhdWx0IHRvU3RhdGVPYmplY3QgYmFzZWQgb24gdGhlIHNjaGVtYS5cclxuICB0b1N0YXRlT2JqZWN0PzogKCB0OiBUICkgPT4gU3RhdGVUeXBlO1xyXG5cclxuICAvLyAqKioqKioqKiBERVNFUklBTElaQVRJT04gKioqKioqKiogLy9cclxuXHJcbiAgLy8gRm9yIERhdGEgVHlwZSBEZXNlcmlhbGl6YXRpb24uIERlY29kZXMgdGhlIG9iamVjdCBmcm9tIGEgc3RhdGUgKHNlZSB0b1N0YXRlT2JqZWN0KSBpbnRvIGFuIGluc3RhbmNlIG9mIHRoZSBjb3JlIHR5cGUuXHJcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9waGV0LWlvL2Jsb2IvbWFzdGVyL2RvYy9waGV0LWlvLWluc3RydW1lbnRhdGlvbi10ZWNobmljYWwtZ3VpZGUubWQjdGhyZWUtdHlwZXMtb2YtZGVzZXJpYWxpemF0aW9uXHJcbiAgZnJvbVN0YXRlT2JqZWN0PzogKCBzOiBTdGF0ZVR5cGUgKSA9PiBUO1xyXG5cclxuICAvLyBGb3IgRHluYW1pYyBFbGVtZW50IERlc2VyaWFsaXphdGlvbjogY29udmVydHMgdGhlIHN0YXRlIG9iamVjdCB0byBhcmd1bWVudHNcclxuICAvLyBmb3IgYSBgY3JlYXRlYCBmdW5jdGlvbiBpbiBQaGV0aW9Hcm91cCBvciBvdGhlciBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lciBjcmVhdGlvbiBmdW5jdGlvbi4gTm90ZSB0aGF0XHJcbiAgLy8gb3RoZXIgbm9uLXNlcmlhbGl6ZWQgYXJncyAobm90IGRlYWx0IHdpdGggaGVyZSkgbWF5IGJlIHN1cHBsaWVkIGFzIGNsb3N1cmUgdmFyaWFibGVzLiBUaGlzIGZ1bmN0aW9uIG9ubHkgbmVlZHNcclxuICAvLyB0byBiZSBpbXBsZW1lbnRlZCBvbiBJTyBUeXBlcyB3aG9zZSBjb3JlIHR5cGUgaXMgcGhldGlvRHluYW1pY0VsZW1lbnQ6IHRydWUsIHN1Y2ggYXMgUGhldGlvRHluYW1pY0VsZW1lbnRDb250YWluZXJcclxuICAvLyBlbGVtZW50cy5cclxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vYmxvYi9tYXN0ZXIvZG9jL3BoZXQtaW8taW5zdHJ1bWVudGF0aW9uLXRlY2huaWNhbC1ndWlkZS5tZCN0aHJlZS10eXBlcy1vZi1kZXNlcmlhbGl6YXRpb25cclxuICBzdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cz86ICggczogU3RhdGVUeXBlICkgPT4gdW5rbm93bltdO1xyXG5cclxuICAvLyBGb3IgUmVmZXJlbmNlIFR5cGUgRGVzZXJpYWxpemF0aW9uOiAgQXBwbGllcyB0aGUgc3RhdGUgKHNlZSB0b1N0YXRlT2JqZWN0KVxyXG4gIC8vIHZhbHVlIHRvIHRoZSBpbnN0YW5jZS4gV2hlbiBzZXR0aW5nIFBoRVQtaU8gc3RhdGUsIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb24gYW4gaW5zdHJ1bWVudGVkIGluc3RhbmNlIHRvIHNldCB0aGVcclxuICAvLyBzdGF0ZU9iamVjdCdzIHZhbHVlIHRvIGl0LiBTdGF0ZVNjaGVtYSBtYWtlcyB0aGlzIG1ldGhvZCBvZnRlbiBzdXBlcmZsdW91cy4gQSBjb21wb3NpdGUgc3RhdGVTY2hlbWEgY2FuIGJlIHVzZWRcclxuICAvLyB0byBhdXRvbWF0aWNhbGx5IGZvcm11bGF0ZSB0aGUgYXBwbHlTdGF0ZSBmdW5jdGlvbi4gSWYgdXNpbmcgc3RhdGVTY2hlbWEgZm9yIHRoZSBhcHBseVN0YXRlIG1ldGhvZCwgbWFrZSBzdXJlIHRoYXRcclxuICAvLyBlYWNoIGNvbXBvc2UgSU9UeXBlIGhhcyB0aGUgY29ycmVjdCBkZWZhdWx0RGVzZXJpYWxpemF0aW9uTWV0aG9kLiBNb3N0IG9mIHRoZSB0aW1lLCBjb21wb3NpdGUgSU9UeXBlcyB1c2UgZnJvbVN0YXRlT2JqZWN0XHJcbiAgLy8gdG8gZGVzZXJpYWxpemUgZWFjaCBzdWItY29tcG9uZW50LCBidXQgaW4gc29tZSBjaXJjdW1zdGFuY2VzLCB5b3Ugd2lsbCB3YW50IHlvdXIgY2hpbGQgdG8gZGVzZXJpYWxpemUgYnkgYWxzbyB1c2luZyBhcHBseVN0YXRlLlxyXG4gIC8vIFNlZSBvcHRpb25zLmRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2QgdG8gY29uZmlndXJlIHRoaXMgY2FzZS5cclxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vYmxvYi9tYXN0ZXIvZG9jL3BoZXQtaW8taW5zdHJ1bWVudGF0aW9uLXRlY2huaWNhbC1ndWlkZS5tZCN0aHJlZS10eXBlcy1vZi1kZXNlcmlhbGl6YXRpb25cclxuICBhcHBseVN0YXRlPzogKCB0OiBULCBzdGF0ZTogU3RhdGVUeXBlICkgPT4gdm9pZDtcclxuXHJcbiAgLy8gRm9yIHVzZSB3aGVuIHRoaXMgSU9UeXBlIGlzIHBhcnQgb2YgYSBjb21wb3NpdGUgc3RhdGVTY2hlbWEgaW4gYW5vdGhlciBJT1R5cGUuICBXaGVuXHJcbiAgLy8gdXNpbmcgc2VyaWFsaXphdGlvbiBtZXRob2RzIGJ5IHN1cHBseWluZyBvbmx5IHN0YXRlU2NoZW1hLCB0aGVuIGRlc2VyaWFsaXphdGlvblxyXG4gIC8vIGNhbiB0YWtlIGEgdmFyaWV0eSBvZiBmb3JtcywgYW5kIHRoaXMgd2lsbCB2YXJ5IGJhc2VkIG9uIHRoZSBJT1R5cGUuIEluIG1vc3QgY2FzZXMgZGVzZXJpYWxpemF0aW9uIG9mIGEgY29tcG9uZW50XHJcbiAgLy8gaXMgZG9uZSB2aWEgZnJvbVN0YXRlT2JqZWN0LiBJZiBub3QsIHNwZWNpZnkgdGhpcyBvcHRpb24gc28gdGhhdCB0aGUgc3RhdGVTY2hlbWEgd2lsbCBiZSBhYmxlIHRvIGtub3cgdG8gY2FsbFxyXG4gIC8vIHRoZSBhcHByb3ByaWF0ZSBkZXNlcmlhbGl6YXRpb24gbWV0aG9kIHdoZW4gZGVzZXJpYWxpemluZyBzb21ldGhpbmcgb2YgdGhpcyBJT1R5cGUuXHJcbiAgZGVmYXVsdERlc2VyaWFsaXphdGlvbk1ldGhvZD86IERlc2VyaWFsaXphdGlvblR5cGU7XHJcblxyXG4gIC8vIEZvciBkeW5hbWljIGVsZW1lbnQgY29udGFpbmVycywgc2VlIGV4YW1wbGVzIGluIElPVHlwZXMgZm9yIFBoZXRpb0R5bmFtaWNFbGVtZW50Q29udGFpbmVyIGNsYXNzZXNcclxuICBhZGRDaGlsZEVsZW1lbnQ/OiBBZGRDaGlsZEVsZW1lbnQ7XHJcbn07XHJcblxyXG50eXBlIElPVHlwZU9wdGlvbnM8VCwgU3RhdGVUeXBlPiA9IFNlbGZPcHRpb25zPFQsIFN0YXRlVHlwZT4gJiBWYWxpZGF0b3I8VD47XHJcblxyXG4vLyBUT0RPOiBub3QgYW55LCBidXQgZG8gd2UgaGF2ZSB0byBzZXJpYWxpemUgdHlwZSBwYXJhbWV0ZXJzPyBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdGFuZGVtL2lzc3Vlcy8yNjNcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9UeXBlPFQgPSBhbnksIFN0YXRlVHlwZSA9IGFueT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICBwdWJsaWMgcmVhZG9ubHkgc3VwZXJ0eXBlPzogSU9UeXBlO1xyXG4gIHB1YmxpYyByZWFkb25seSBkb2N1bWVudGF0aW9uPzogc3RyaW5nO1xyXG4gIHB1YmxpYyByZWFkb25seSBtZXRob2RzPzogUmVjb3JkPHN0cmluZywgSU9UeXBlTWV0aG9kPjtcclxuXHJcbiAgcHVibGljIHJlYWRvbmx5IGV2ZW50czogc3RyaW5nW107XHJcbiAgcHVibGljIHJlYWRvbmx5IG1ldGFkYXRhRGVmYXVsdHM/OiBQYXJ0aWFsPFBoZXRpb09iamVjdE1ldGFkYXRhPjtcclxuXHJcbiAgcHVibGljIHJlYWRvbmx5IGRhdGFEZWZhdWx0cz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG4gIHB1YmxpYyByZWFkb25seSBtZXRob2RPcmRlcj86IHN0cmluZ1tdO1xyXG4gIHB1YmxpYyByZWFkb25seSBwYXJhbWV0ZXJUeXBlcz86IElPVHlwZVtdO1xyXG5cclxuICBwdWJsaWMgcmVhZG9ubHkgdG9TdGF0ZU9iamVjdDogKCB0OiBUICkgPT4gU3RhdGVUeXBlO1xyXG4gIHB1YmxpYyByZWFkb25seSBmcm9tU3RhdGVPYmplY3Q6ICggc3RhdGU6IFN0YXRlVHlwZSApID0+IFQ7XHJcbiAgcHVibGljIHJlYWRvbmx5IHN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzOiAoIHM6IFN0YXRlVHlwZSApID0+IHVua25vd25bXTsgLy8gVE9ETzogaW5zdGVhZCBvZiB1bmtub3duIHRoaXMgaXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdHlwZSBmb3IgUGhldGlvRHluYW1pY0VsZW1lbnRDb250YWluZXIuIEhvdz8gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3RhbmRlbS9pc3N1ZXMvMjYxXHJcbiAgcHVibGljIHJlYWRvbmx5IGFwcGx5U3RhdGU6ICggb2JqZWN0OiBULCBzdGF0ZTogU3RhdGVUeXBlICkgPT4gdm9pZDtcclxuICBwdWJsaWMgcmVhZG9ubHkgYWRkQ2hpbGRFbGVtZW50OiBBZGRDaGlsZEVsZW1lbnQ7XHJcbiAgcHVibGljIHJlYWRvbmx5IHZhbGlkYXRvcjogVmFsaWRhdG9yPFQ+O1xyXG4gIHB1YmxpYyByZWFkb25seSBkZWZhdWx0RGVzZXJpYWxpemF0aW9uTWV0aG9kOiBEZXNlcmlhbGl6YXRpb25UeXBlO1xyXG4gIHB1YmxpYyByZWFkb25seSBzdGF0ZVNjaGVtYTogU3RhdGVTY2hlbWE8VCwgU3RhdGVUeXBlPjtcclxuICBwdWJsaWMgcmVhZG9ubHkgaXNGdW5jdGlvblR5cGU6IGJvb2xlYW47XHJcblxyXG4gIHB1YmxpYyBzdGF0aWMgT2JqZWN0SU86IElPVHlwZTtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHR5cGVOYW1lIC0gVGhlIG5hbWUgdGhhdCB0aGlzIElPVHlwZSB3aWxsIGhhdmUgaW4gdGhlIHB1YmxpYyBQaEVULWlPIEFQSS4gSW4gZ2VuZXJhbCwgdGhpcyBzaG91bGRcclxuICAgKiAgICBvbmx5IGJlIHdvcmQgY2hhcmFjdGVycywgZW5kaW5nIGluIFwiSU9cIi4gUGFyYW1ldHJpYyB0eXBlcyBhcmUgYSBzcGVjaWFsIHN1YnNldCBvZiBJT1R5cGVzIHRoYXQgaW5jbHVkZSB0aGVpclxyXG4gICAqICAgIHBhcmFtZXRlcnMgaW4gdGhlaXIgdHlwZU5hbWUuIElmIGFuIElPVHlwZSdzIHBhcmFtZXRlcnMgYXJlIG90aGVyIElPIFR5cGUocyksIHRoZW4gdGhleSBzaG91bGQgYmUgaW5jbHVkZWQgd2l0aGluXHJcbiAgICogICAgYW5nbGUgYnJhY2tldHMsIGxpa2UgXCJQcm9wZXJ0eUlPPEJvb2xlYW5JTz5cIi4gU29tZSBvdGhlciB0eXBlcyB1c2UgYSBtb3JlIGN1c3RvbSBmb3JtYXQgZm9yIGRpc3BsYXlpbmcgdGhlaXJcclxuICAgKiAgICBwYXJhbWV0ZXIgdHlwZXMsIGluIHRoaXMgY2FzZSB0aGUgcGFyYW1ldGVyIHNlY3Rpb24gb2YgdGhlIHR5cGUgbmFtZSAoaW1tZWRpYXRlbHkgZm9sbG93aW5nIFwiSU9cIikgc2hvdWxkIGJlZ2luXHJcbiAgICogICAgd2l0aCBhbiBvcGVuIHBhcmVuLCBcIihcIi4gVGh1cyB0aGUgc2NoZW1hIGZvciBhIHR5cGVOYW1lIGNvdWxkIGJlIGRlZmluZWQgKHVzaW5nIHJlZ2V4KSBhcyBgW0EtWl1cXHcqSU8oWyg8XS4qKXswLDF9YC5cclxuICAgKiAgICBQYXJhbWV0ZXJpemVkIHR5cGVzIHNob3VsZCBhbHNvIGluY2x1ZGUgYSBgcGFyYW1ldGVyVHlwZXNgIGZpZWxkIG9uIHRoZSBJT1R5cGUuXHJcbiAgICogQHBhcmFtIHByb3ZpZGVkT3B0aW9uc1xyXG4gICAqL1xyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcHVibGljIHJlYWRvbmx5IHR5cGVOYW1lOiBJT1R5cGVOYW1lLCBwcm92aWRlZE9wdGlvbnM6IElPVHlwZU9wdGlvbnM8VCwgU3RhdGVUeXBlPiApIHtcclxuXHJcbiAgICAvLyBGb3IgcmVmZXJlbmNlIGluIHRoZSBvcHRpb25zXHJcbiAgICBjb25zdCBzdXBlcnR5cGUgPSBwcm92aWRlZE9wdGlvbnMuc3VwZXJ0eXBlIHx8IElPVHlwZS5PYmplY3RJTztcclxuICAgIGNvbnN0IHRvU3RhdGVPYmplY3RTdXBwbGllZCA9ICEhKCBwcm92aWRlZE9wdGlvbnMudG9TdGF0ZU9iamVjdCApO1xyXG4gICAgY29uc3QgYXBwbHlTdGF0ZVN1cHBsaWVkID0gISEoIHByb3ZpZGVkT3B0aW9ucy5hcHBseVN0YXRlICk7XHJcbiAgICBjb25zdCBzdGF0ZVNjaGVtYVN1cHBsaWVkID0gISEoIHByb3ZpZGVkT3B0aW9ucy5zdGF0ZVNjaGVtYSApO1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8SU9UeXBlT3B0aW9uczxULCBTdGF0ZVR5cGU+LCBTZWxmT3B0aW9uczxULCBTdGF0ZVR5cGU+PigpKCB7XHJcblxyXG4gICAgICBzdXBlcnR5cGU6IElPVHlwZS5PYmplY3RJTyxcclxuICAgICAgbWV0aG9kczoge30sXHJcbiAgICAgIGV2ZW50czogW10sXHJcbiAgICAgIG1ldGFkYXRhRGVmYXVsdHM6IHt9LFxyXG5cclxuICAgICAgLy8gIE1vc3QgbGlrZWx5IHRoaXMgd2lsbCByZW1haW4gUGhFVC1pTyBpbnRlcm5hbCwgYW5kIHNob3VsZG4ndCBuZWVkIHRvIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBJT1R5cGVzIG91dHNpZGUgb2YgdGFuZGVtLy5cclxuICAgICAgZGF0YURlZmF1bHRzOiB7fSxcclxuICAgICAgbWV0aG9kT3JkZXI6IFtdLFxyXG4gICAgICBwYXJhbWV0ZXJUeXBlczogW10sXHJcbiAgICAgIGRvY3VtZW50YXRpb246IGBJTyBUeXBlIGZvciAke2dldENvcmVUeXBlTmFtZSggdHlwZU5hbWUgKX1gLFxyXG4gICAgICBpc0Z1bmN0aW9uVHlwZTogZmFsc2UsXHJcblxyXG4gICAgICAvKioqKiBTVEFURSAqKioqL1xyXG5cclxuICAgICAgdG9TdGF0ZU9iamVjdDogc3VwZXJ0eXBlICYmIHN1cGVydHlwZS50b1N0YXRlT2JqZWN0LFxyXG4gICAgICBmcm9tU3RhdGVPYmplY3Q6IHN1cGVydHlwZSAmJiBzdXBlcnR5cGUuZnJvbVN0YXRlT2JqZWN0LFxyXG4gICAgICBzdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50czogc3VwZXJ0eXBlICYmIHN1cGVydHlwZS5zdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cyxcclxuICAgICAgYXBwbHlTdGF0ZTogc3VwZXJ0eXBlICYmIHN1cGVydHlwZS5hcHBseVN0YXRlLFxyXG5cclxuICAgICAgc3RhdGVTY2hlbWE6IG51bGwsXHJcbiAgICAgIGRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2Q6ICdmcm9tU3RhdGVPYmplY3QnLFxyXG4gICAgICBhZGRDaGlsZEVsZW1lbnQ6IHN1cGVydHlwZSAmJiBzdXBlcnR5cGUuYWRkQ2hpbGRFbGVtZW50XHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICBpZiAoIGFzc2VydCAmJiBzdXBlcnR5cGUgKSB7XHJcbiAgICAgICggT2JqZWN0LmtleXMoIG9wdGlvbnMubWV0YWRhdGFEZWZhdWx0cyApIGFzICgga2V5b2YgUGhldGlvT2JqZWN0TWV0YWRhdGEgKVtdICkuZm9yRWFjaCggbWV0YWRhdGFEZWZhdWx0S2V5ID0+IHtcclxuICAgICAgICBhc3NlcnQgJiYgc3VwZXJ0eXBlLmdldEFsbE1ldGFkYXRhRGVmYXVsdHMoKS5oYXNPd25Qcm9wZXJ0eSggbWV0YWRhdGFEZWZhdWx0S2V5ICkgJiZcclxuICAgICAgICBhc3NlcnQoIHN1cGVydHlwZS5nZXRBbGxNZXRhZGF0YURlZmF1bHRzKClbIG1ldGFkYXRhRGVmYXVsdEtleSBdICE9PSBvcHRpb25zLm1ldGFkYXRhRGVmYXVsdHNbIG1ldGFkYXRhRGVmYXVsdEtleSBdLFxyXG4gICAgICAgICAgYCR7bWV0YWRhdGFEZWZhdWx0S2V5fSBzaG91bGQgbm90IGhhdmUgdGhlIHNhbWUgZGVmYXVsdCB2YWx1ZSBhcyB0aGUgYW5jZXN0b3IgbWV0YWRhdGEgZGVmYXVsdC5gICk7XHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuICAgIHRoaXMuc3VwZXJ0eXBlID0gc3VwZXJ0eXBlO1xyXG4gICAgdGhpcy5kb2N1bWVudGF0aW9uID0gb3B0aW9ucy5kb2N1bWVudGF0aW9uO1xyXG4gICAgdGhpcy5tZXRob2RzID0gb3B0aW9ucy5tZXRob2RzO1xyXG4gICAgdGhpcy5ldmVudHMgPSBvcHRpb25zLmV2ZW50cztcclxuICAgIHRoaXMubWV0YWRhdGFEZWZhdWx0cyA9IG9wdGlvbnMubWV0YWRhdGFEZWZhdWx0czsgLy8ganVzdCBmb3IgdGhpcyBsZXZlbCwgc2VlIGdldEFsbE1ldGFkYXRhRGVmYXVsdHMoKVxyXG4gICAgdGhpcy5kYXRhRGVmYXVsdHMgPSBvcHRpb25zLmRhdGFEZWZhdWx0czsgLy8ganVzdCBmb3IgdGhpcyBsZXZlbCwgc2VlIGdldEFsbERhdGFEZWZhdWx0cygpXHJcbiAgICB0aGlzLm1ldGhvZE9yZGVyID0gb3B0aW9ucy5tZXRob2RPcmRlcjtcclxuICAgIHRoaXMucGFyYW1ldGVyVHlwZXMgPSBvcHRpb25zLnBhcmFtZXRlclR5cGVzO1xyXG5cclxuICAgIC8vIFZhbGlkYXRpb25cclxuICAgIHRoaXMudmFsaWRhdG9yID0gXy5waWNrKCBvcHRpb25zLCBWYWxpZGF0aW9uLlZBTElEQVRPUl9LRVlTICk7XHJcbiAgICB0aGlzLnZhbGlkYXRvci52YWxpZGF0aW9uTWVzc2FnZSA9IHRoaXMudmFsaWRhdG9yLnZhbGlkYXRpb25NZXNzYWdlIHx8IGBWYWxpZGF0aW9uIGZhaWxlZCBJT1R5cGUgVmFsaWRhdG9yOiAke3RoaXMudHlwZU5hbWV9YDtcclxuXHJcbiAgICB0aGlzLmRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2QgPSBvcHRpb25zLmRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2Q7XHJcblxyXG4gICAgaWYgKCBvcHRpb25zLnN0YXRlU2NoZW1hID09PSBudWxsIHx8IG9wdGlvbnMuc3RhdGVTY2hlbWEgaW5zdGFuY2VvZiBTdGF0ZVNjaGVtYSApIHtcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdGFuZGVtL2lzc3Vlcy8yNjNcclxuICAgICAgdGhpcy5zdGF0ZVNjaGVtYSA9IG9wdGlvbnMuc3RhdGVTY2hlbWE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgY29uc3QgY29tcG9zaXRlU2NoZW1hID0gdHlwZW9mIG9wdGlvbnMuc3RhdGVTY2hlbWEgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnN0YXRlU2NoZW1hKCB0aGlzICkgOiBvcHRpb25zLnN0YXRlU2NoZW1hO1xyXG5cclxuICAgICAgdGhpcy5zdGF0ZVNjaGVtYSA9IG5ldyBTdGF0ZVNjaGVtYTxULCBTdGF0ZVR5cGU+KCB7IGNvbXBvc2l0ZVNjaGVtYTogY29tcG9zaXRlU2NoZW1hIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBc3NlcnQgdGhhdCB0b1N0YXRlT2JqZWN0IG1ldGhvZCBpcyBwcm92aWRlZCBmb3IgdmFsdWUgU3RhdGVTY2hlbWFzLiBEbyB0aGlzIHdpdGggdGhlIGZvbGxvd2luZyBsb2dpYzpcclxuICAgIC8vIDEuIEl0IGlzIGFjY2VwdGFibGUgdG8gbm90IHByb3ZpZGUgYSBzdGF0ZVNjaGVtYSAoZm9yIElPVHlwZXMgdGhhdCBhcmVuJ3Qgc3RhdGVmdWwpXHJcbiAgICAvLyAyLiBZb3UgbXVzdCBlaXRoZXIgcHJvdmlkZSBhIHRvU3RhdGVPYmplY3QsIG9yIGhhdmUgYSBjb21wb3NpdGUgU3RhdGVTY2hlbWEuIENvbXBvc2l0ZSBzdGF0ZSBzY2hlbWFzIHN1cHBvcnQgZGVmYXVsdCBzZXJpYWxpemF0aW9uIG1ldGhvZHMuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhdGhpcy5zdGF0ZVNjaGVtYSB8fCAoIHRvU3RhdGVPYmplY3RTdXBwbGllZCB8fCB0aGlzLnN0YXRlU2NoZW1hLmlzQ29tcG9zaXRlKCkgKSxcclxuICAgICAgJ3RvU3RhdGVPYmplY3QgbWV0aG9kIG11c3QgYmUgcHJvdmlkZWQgZm9yIHZhbHVlIFN0YXRlU2NoZW1hcycgKTtcclxuXHJcbiAgICB0aGlzLnRvU3RhdGVPYmplY3QgPSAoIGNvcmVPYmplY3Q6IFQgKSA9PiB7XHJcbiAgICAgIHZhbGlkYXRlKCBjb3JlT2JqZWN0LCB0aGlzLnZhbGlkYXRvciwgVkFMSURBVEVfT1BUSU9OU19GQUxTRSApO1xyXG5cclxuICAgICAgbGV0IHRvU3RhdGVPYmplY3Q7XHJcblxyXG4gICAgICAvLyBPbmx5IGRvIHRoaXMgbm9uLXN0YW5kYXJkIHRvU3RhdGVPYmplY3QgZnVuY3Rpb24gaWYgdGhlcmUgaXMgYSBzdGF0ZVNjaGVtYSBidXQgbm8gdG9TdGF0ZU9iamVjdCBwcm92aWRlZFxyXG4gICAgICBpZiAoICF0b1N0YXRlT2JqZWN0U3VwcGxpZWQgJiYgc3RhdGVTY2hlbWFTdXBwbGllZCAmJiB0aGlzLnN0YXRlU2NoZW1hICYmIHRoaXMuc3RhdGVTY2hlbWEuaXNDb21wb3NpdGUoKSApIHtcclxuICAgICAgICB0b1N0YXRlT2JqZWN0ID0gdGhpcy5zdGF0ZVNjaGVtYS5kZWZhdWx0VG9TdGF0ZU9iamVjdCggY29yZU9iamVjdCApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRvU3RhdGVPYmplY3QgPSBvcHRpb25zLnRvU3RhdGVPYmplY3QoIGNvcmVPYmplY3QgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVmFsaWRhdGUsIGJ1dCBvbmx5IGlmIHRoaXMgSU9UeXBlIGluc3RhbmNlIGhhcyBtb3JlIHRvIHZhbGlkYXRlIHRoYW4gdGhlIHN1cGVydHlwZVxyXG4gICAgICBpZiAoIHRvU3RhdGVPYmplY3RTdXBwbGllZCB8fCBzdGF0ZVNjaGVtYVN1cHBsaWVkICkge1xyXG5cclxuICAgICAgICAvLyBPbmx5IHZhbGlkYXRlIHRoZSBzdGF0ZU9iamVjdCBpZiBpdCBpcyBwaGV0aW9TdGF0ZTp0cnVlLlxyXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gbiptIGFsZ29yaXRobSBiZWNhdXNlIGZvciBlYWNoIHRpbWUgdG9TdGF0ZU9iamVjdCBpcyBjYWxsZWQgYW5kIG5lZWRzIHZhbGlkYXRpb24sIHRoaXMudmFsaWRhdGVTdGF0ZU9iamVjdFxyXG4gICAgICAgIC8vIGxvb2tzIGFsbCB0aGUgd2F5IHVwIHRoZSBJT1R5cGUgaGllcmFyY2h5LiBUaGlzIGlzIG5vdCBlZmZpY2llbnQsIGJ1dCBnYWlucyB1cyB0aGUgYWJpbGl0eSB0byBtYWtlIHN1cmUgdGhhdFxyXG4gICAgICAgIC8vIHRoZSBzdGF0ZU9iamVjdCBkb2Vzbid0IGhhdmUgYW55IHN1cGVyZmx1b3VzLCB1bmV4cGVjdGVkIGtleXMuIFRoZSBcIm1cIiBwb3J0aW9uIGlzIGJhc2VkIG9uIGhvdyBtYW55IHN1Yi1wcm9wZXJ0aWVzXHJcbiAgICAgICAgLy8gaW4gYSBzdGF0ZSBjYWxsIGB0b1N0YXRlT2JqZWN0YCwgYW5kIHRoZSBcIm5cIiBwb3J0aW9uIGlzIGJhc2VkIG9uIGhvdyBtYW55IElPVHlwZXMgaW4gdGhlIGhpZXJhcmNoeSBkZWZpbmUgYVxyXG4gICAgICAgIC8vIHRvU3RhdGVPYmplY3Qgb3Igc3RhdGVTY2hlbWEuIEluIHRoZSBmdXR1cmUgd2UgY291bGQgcG90ZW50aWFsbHkgaW1wcm92ZSBwZXJmb3JtYW5jZSBieSBoYXZpbmcgdmFsaWRhdGVTdGF0ZU9iamVjdFxyXG4gICAgICAgIC8vIG9ubHkgY2hlY2sgYWdhaW5zdCB0aGUgc2NoZW1hIGF0IHRoaXMgbGV2ZWwsIGJ1dCB0aGVuIGV4dHJhIGtleXMgaW4gdGhlIHN0YXRlT2JqZWN0IHdvdWxkIG5vdCBiZSBjYXVnaHQuIEZyb20gd29yayBkb25lIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9waGV0LWlvL2lzc3Vlcy8xNzc0XHJcbiAgICAgICAgYXNzZXJ0ICYmIHRoaXMudmFsaWRhdGVTdGF0ZU9iamVjdCggdG9TdGF0ZU9iamVjdCApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0b1N0YXRlT2JqZWN0O1xyXG4gICAgfTtcclxuICAgIHRoaXMuZnJvbVN0YXRlT2JqZWN0ID0gb3B0aW9ucy5mcm9tU3RhdGVPYmplY3Q7XHJcbiAgICB0aGlzLnN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzID0gb3B0aW9ucy5zdGF0ZU9iamVjdFRvQ3JlYXRlRWxlbWVudEFyZ3VtZW50cztcclxuXHJcbiAgICB0aGlzLmFwcGx5U3RhdGUgPSAoIGNvcmVPYmplY3Q6IFQsIHN0YXRlT2JqZWN0OiBTdGF0ZVR5cGUgKSA9PiB7XHJcbiAgICAgIHZhbGlkYXRlKCBjb3JlT2JqZWN0LCB0aGlzLnZhbGlkYXRvciwgVkFMSURBVEVfT1BUSU9OU19GQUxTRSApO1xyXG5cclxuICAgICAgLy8gVmFsaWRhdGUsIGJ1dCBvbmx5IGlmIHRoaXMgSU9UeXBlIGluc3RhbmNlIGhhcyBtb3JlIHRvIHZhbGlkYXRlIHRoYW4gdGhlIHN1cGVydHlwZVxyXG4gICAgICBpZiAoIGFwcGx5U3RhdGVTdXBwbGllZCB8fCBzdGF0ZVNjaGVtYVN1cHBsaWVkICkge1xyXG5cclxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm92aWRlZCBzdGF0ZU9iamVjdCBpcyBvZiB0aGUgZXhwZWN0ZWQgc2NoZW1hXHJcbiAgICAgICAgLy8gTk9URTogQ2Fubm90IHVzZSB0aGlzLnZhbGlkYXRlU3RhdGVPYmplY3QgYmVjYXVzZSBvcHRpb25zIGFkb3B0cyBzdXBlcnR5cGUuYXBwbHlTdGF0ZSwgd2hpY2ggaXMgYm91bmRzIHRvIHRoZVxyXG4gICAgICAgIC8vIHBhcmVudCBJTyBUeXBlLiBUaGlzIHByZXZlbnRzIGNvcnJlY3QgdmFsaWRhdGlvbiBiZWNhdXNlIHRoZSBzdXBlcnR5cGUgZG9lc24ndCBrbm93IGFib3V0IHRoZSBzdWJ0eXBlIHNjaGVtYXMuXHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB3ZSBjYW5ub3QgdHlwZSBjaGVjayBhZ2FpbnN0IFBoZXRpb09iamVjdCBmcm9tIHRoaXMgZmlsZVxyXG4gICAgICAgIGFzc2VydCAmJiBjb3JlT2JqZWN0LnBoZXRpb1R5cGUudmFsaWRhdGVTdGF0ZU9iamVjdCggc3RhdGVPYmplY3QgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT25seSBkbyB0aGlzIG5vbi1zdGFuZGFyZCBhcHBseVN0YXRlIGZ1bmN0aW9uIGZyb20gc3RhdGVTY2hlbWEgaWYgdGhlcmUgaXMgYSBzdGF0ZVNjaGVtYSBidXQgbm8gYXBwbHlTdGF0ZSBwcm92aWRlZFxyXG4gICAgICBpZiAoICFhcHBseVN0YXRlU3VwcGxpZWQgJiYgc3RhdGVTY2hlbWFTdXBwbGllZCAmJiB0aGlzLnN0YXRlU2NoZW1hICYmIHRoaXMuc3RhdGVTY2hlbWEuaXNDb21wb3NpdGUoKSApIHtcclxuICAgICAgICB0aGlzLnN0YXRlU2NoZW1hLmRlZmF1bHRBcHBseVN0YXRlKCBjb3JlT2JqZWN0LCBzdGF0ZU9iamVjdCBhcyBDb21wb3NpdGVTdGF0ZU9iamVjdFR5cGUgKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBvcHRpb25zLmFwcGx5U3RhdGUoIGNvcmVPYmplY3QsIHN0YXRlT2JqZWN0ICk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pc0Z1bmN0aW9uVHlwZSA9IG9wdGlvbnMuaXNGdW5jdGlvblR5cGU7XHJcbiAgICB0aGlzLmFkZENoaWxkRWxlbWVudCA9IG9wdGlvbnMuYWRkQ2hpbGRFbGVtZW50O1xyXG5cclxuICAgIGlmICggYXNzZXJ0ICkge1xyXG5cclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggc3VwZXJ0eXBlIHx8IHRoaXMudHlwZU5hbWUgPT09ICdPYmplY3RJTycsICdzdXBlcnR5cGUgaXMgcmVxdWlyZWQnICk7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoICF0aGlzLnR5cGVOYW1lLmluY2x1ZGVzKCAnLicgKSwgJ0RvdHMgc2hvdWxkIG5vdCBhcHBlYXIgaW4gdHlwZSBuYW1lcycgKTtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy50eXBlTmFtZS5zcGxpdCggL1s8KF0vIClbIDAgXS5lbmRzV2l0aCggUGhldGlvQ29uc3RhbnRzLklPX1RZUEVfU1VGRklYICksIGBJTyBUeXBlIG5hbWUgbXVzdCBlbmQgd2l0aCAke1BoZXRpb0NvbnN0YW50cy5JT19UWVBFX1NVRkZJWH1gICk7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaGFzT3duUHJvcGVydHkoICd0eXBlTmFtZScgKSwgJ3RoaXMudHlwZU5hbWUgaXMgcmVxdWlyZWQnICk7XHJcblxyXG4gICAgICAvLyBhc3NlcnQgdGhhdCBlYWNoIHB1YmxpYyBtZXRob2QgYWRoZXJlcyB0byB0aGUgZXhwZWN0ZWQgc2NoZW1hXHJcbiAgICAgIHRoaXMubWV0aG9kcyAmJiBPYmplY3QudmFsdWVzKCB0aGlzLm1ldGhvZHMgKS5mb3JFYWNoKCAoIG1ldGhvZE9iamVjdDogSU9UeXBlTWV0aG9kICkgPT4ge1xyXG4gICAgICAgIGlmICggdHlwZW9mIG1ldGhvZE9iamVjdCA9PT0gJ29iamVjdCcgKSB7XHJcbiAgICAgICAgICBhc3NlcnQgJiYgbWV0aG9kT2JqZWN0Lmludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHMgJiYgYXNzZXJ0KCB0eXBlb2YgbWV0aG9kT2JqZWN0Lmludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHMgPT09ICdib29sZWFuJyxcclxuICAgICAgICAgICAgYGludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHMgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW46ICR7bWV0aG9kT2JqZWN0Lmludm9jYWJsZUZvclJlYWRPbmx5RWxlbWVudHN9YCApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSApO1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmRvY3VtZW50YXRpb24ubGVuZ3RoID4gMCwgJ2RvY3VtZW50YXRpb24gbXVzdCBiZSBwcm92aWRlZCcgKTtcclxuXHJcbiAgICAgIHRoaXMubWV0aG9kcyAmJiB0aGlzLmhhc093blByb3BlcnR5KCAnbWV0aG9kT3JkZXInICkgJiYgdGhpcy5tZXRob2RPcmRlci5mb3JFYWNoKCBtZXRob2ROYW1lID0+IHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLm1ldGhvZHMhWyBtZXRob2ROYW1lIF0sIGBtZXRob2ROYW1lIG5vdCBpbiBwdWJsaWMgbWV0aG9kczogJHttZXRob2ROYW1lfWAgKTtcclxuICAgICAgfSApO1xyXG5cclxuICAgICAgaWYgKCBzdXBlcnR5cGUgKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZUhpZXJhcmNoeSA9IHN1cGVydHlwZS5nZXRUeXBlSGllcmFyY2h5KCk7XHJcbiAgICAgICAgYXNzZXJ0ICYmIHRoaXMuZXZlbnRzICYmIHRoaXMuZXZlbnRzLmZvckVhY2goIGV2ZW50ID0+IHtcclxuXHJcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgZXZlbnRzIGFyZSBub3QgbGlzdGVkIGFnYWluXHJcbiAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhXy5zb21lKCB0eXBlSGllcmFyY2h5LCB0ID0+IHQuZXZlbnRzLmluY2x1ZGVzKCBldmVudCApICksIGBJT1R5cGUgc2hvdWxkIG5vdCBkZWNsYXJlIGV2ZW50IHRoYXQgcGFyZW50IGFsc28gaGFzOiAke2V2ZW50fWAgKTtcclxuICAgICAgICB9ICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb290IElPVHlwZSBtdXN0IHN1cHBseSBhbGwgNCBzdGF0ZSBtZXRob2RzLlxyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBvcHRpb25zLnRvU3RhdGVPYmplY3QgPT09ICdmdW5jdGlvbicsICd0b1N0YXRlT2JqZWN0IG11c3QgYmUgZGVmaW5lZCcgKTtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0eXBlb2Ygb3B0aW9ucy5mcm9tU3RhdGVPYmplY3QgPT09ICdmdW5jdGlvbicsICdmcm9tU3RhdGVPYmplY3QgbXVzdCBiZSBkZWZpbmVkJyApO1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBvcHRpb25zLnN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzID09PSAnZnVuY3Rpb24nLCAnc3RhdGVPYmplY3RUb0NyZWF0ZUVsZW1lbnRBcmd1bWVudHMgbXVzdCBiZSBkZWZpbmVkJyApO1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBvcHRpb25zLmFwcGx5U3RhdGUgPT09ICdmdW5jdGlvbicsICdhcHBseVN0YXRlIG11c3QgYmUgZGVmaW5lZCcgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbiBhcnJheSBvZiBJT1R5cGVzIG9mIHRoZSBzZWxmIHR5cGUgYW5kIGFsbCB0aGUgc3VwZXJ0eXBlIGFuY2VzdG9ycy5cclxuICAgKi9cclxuICBwcml2YXRlIGdldFR5cGVIaWVyYXJjaHkoKTogSU9UeXBlPHVua25vd24sIHVua25vd24+W10ge1xyXG4gICAgY29uc3QgYXJyYXkgPSBbXTtcclxuXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFN0aWxsIHdvcmtpbmcgb3V0IHRoaXMgc3R1ZmYsIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy90YW5kZW0vaXNzdWVzLzI2M1xyXG4gICAgbGV0IGlvVHlwZTogSU9UeXBlPHVua25vd24sIHVua25vd24+ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXHJcbiAgICB3aGlsZSAoIGlvVHlwZSApIHtcclxuICAgICAgYXJyYXkucHVzaCggaW9UeXBlICk7XHJcbiAgICAgIGlvVHlwZSA9IGlvVHlwZS5zdXBlcnR5cGUhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgSU9UeXBlIGlzIGEgc3VidHlwZSBvZiB0aGUgcGFzc2VkLWluIHR5cGUgKG9yIGlmIHRoZXkgYXJlIHRoZSBzYW1lKS5cclxuICAgKi9cclxuICBwdWJsaWMgZXh0ZW5kcyggdHlwZTogSU9UeXBlPHVua25vd24sIHVua25vd24+ICk6IGJvb2xlYW4ge1xyXG5cclxuICAgIC8vIG1lbW9yeS1iYXNlZCBpbXBsZW1lbnRhdGlvbiBPSyBzaW5jZSB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgaW4gYXNzZXJ0aW9uc1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZUhpZXJhcmNoeSgpLmluY2x1ZGVzKCB0eXBlICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYWxsIHRoZSBtZXRhZGF0YSBkZWZhdWx0cyAoZm9yIHRoZSBlbnRpcmUgSU8gVHlwZSBoaWVyYXJjaHkpXHJcbiAgICovXHJcbiAgcHVibGljIGdldEFsbE1ldGFkYXRhRGVmYXVsdHMoKTogUGFydGlhbDxQaGV0aW9PYmplY3RNZXRhZGF0YT4ge1xyXG4gICAgcmV0dXJuIF8ubWVyZ2UoIHt9LCB0aGlzLnN1cGVydHlwZSA/IHRoaXMuc3VwZXJ0eXBlLmdldEFsbE1ldGFkYXRhRGVmYXVsdHMoKSA6IHt9LCB0aGlzLm1ldGFkYXRhRGVmYXVsdHMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbGwgdGhlIGRhdGEgZGVmYXVsdHMgKGZvciB0aGUgZW50aXJlIElPIFR5cGUgaGllcmFyY2h5KVxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRBbGxEYXRhRGVmYXVsdHMoKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xyXG4gICAgcmV0dXJuIF8ubWVyZ2UoIHt9LCB0aGlzLnN1cGVydHlwZSA/IHRoaXMuc3VwZXJ0eXBlLmdldEFsbERhdGFEZWZhdWx0cygpIDoge30sIHRoaXMuZGF0YURlZmF1bHRzICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gc3RhdGVPYmplY3QgLSB0aGUgc3RhdGVPYmplY3QgdG8gdmFsaWRhdGUgYWdhaW5zdFxyXG4gICAqIEBwYXJhbSB0b0Fzc2VydD1mYWxzZSAtIHdoZXRoZXIgdG8gYXNzZXJ0IHdoZW4gaW52YWxpZFxyXG4gICAqIEBwYXJhbSBzY2hlbWFLZXlzUHJlc2VudEluU3RhdGVPYmplY3Q9W11cclxuICAgKiBAcmV0dXJucyBpZiB0aGUgc3RhdGVPYmplY3QgaXMgdmFsaWQgb3Igbm90LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBpc1N0YXRlT2JqZWN0VmFsaWQoIHN0YXRlT2JqZWN0OiBTdGF0ZVR5cGUsIHRvQXNzZXJ0ID0gZmFsc2UsIHNjaGVtYUtleXNQcmVzZW50SW5TdGF0ZU9iamVjdDogc3RyaW5nW10gPSBbXSApOiBib29sZWFuIHtcclxuXHJcbiAgICAvLyBTZXQgdG8gZmFsc2Ugd2hlbiBpbnZhbGlkXHJcbiAgICBsZXQgdmFsaWQgPSB0cnVlO1xyXG5cclxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgc3RhdGVPYmplY3QgaGFzIGV2ZXJ5dGhpbmcgdGhlIHNjaGVtYSByZXF1aXJlcyBhbmQgbm90aGluZyBtb3JlXHJcbiAgICBpZiAoIHRoaXMuc3RhdGVTY2hlbWEgKSB7XHJcbiAgICAgIGNvbnN0IHZhbGlkU29GYXIgPSB0aGlzLnN0YXRlU2NoZW1hLmNoZWNrU3RhdGVPYmplY3RWYWxpZCggc3RhdGVPYmplY3QsIHRvQXNzZXJ0LCBzY2hlbWFLZXlzUHJlc2VudEluU3RhdGVPYmplY3QgKTtcclxuXHJcbiAgICAgIC8vIG51bGwgYXMgYSBtYXJrZXIgdG8ga2VlcCBjaGVja2luZyB1cCB0aGUgaGllcmFyY2h5LCBvdGhlcndpc2Ugd2UgcmVhY2hlZCBvdXIgYmFzZWQgY2FzZSBiZWNhdXNlIHRoZSBzdGF0ZVNjaGVtYSB3YXMgYSB2YWx1ZSwgbm90IGEgY29tcG9zaXRlXHJcbiAgICAgIGlmICggdmFsaWRTb0ZhciAhPT0gbnVsbCApIHtcclxuICAgICAgICByZXR1cm4gdmFsaWRTb0ZhcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICggdGhpcy5zdXBlcnR5cGUgKSB7XHJcbiAgICAgIHJldHVybiB2YWxpZCAmJiB0aGlzLnN1cGVydHlwZS5pc1N0YXRlT2JqZWN0VmFsaWQoIHN0YXRlT2JqZWN0LCB0b0Fzc2VydCwgc2NoZW1hS2V5c1ByZXNlbnRJblN0YXRlT2JqZWN0ICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgcm9vdCwgbWFrZSBzdXJlIHRoZXJlIGlzbid0IGFueXRoaW5nIGluIHRoZSBzdGF0ZU9iamVjdCB0aGF0IGlzbid0IGRlc2NyaWJlZCBieSBhIHNjaGVtYVxyXG4gICAgaWYgKCAhdGhpcy5zdXBlcnR5cGUgJiYgc3RhdGVPYmplY3QgJiYgdHlwZW9mIHN0YXRlT2JqZWN0ICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheSggc3RhdGVPYmplY3QgKSApIHtcclxuXHJcbiAgICAgIC8vIFZpc2l0IHRoZSBzdGF0ZVxyXG4gICAgICBPYmplY3Qua2V5cyggc3RhdGVPYmplY3QgKS5mb3JFYWNoKCBrZXkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGtleVZhbGlkID0gc2NoZW1hS2V5c1ByZXNlbnRJblN0YXRlT2JqZWN0LmluY2x1ZGVzKCBrZXkgKTtcclxuICAgICAgICBpZiAoICFrZXlWYWxpZCApIHtcclxuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydCAmJiB0b0Fzc2VydCAmJiBhc3NlcnQoIGtleVZhbGlkLCBgc3RhdGVPYmplY3QgcHJvdmlkZWQgYSBrZXkgdGhhdCBpcyBub3QgaW4gdGhlIHNjaGVtYTogJHtrZXl9YCApO1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICByZXR1cm4gdmFsaWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFzc2VydCBpZiB0aGUgcHJvdmlkZWQgc3RhdGVPYmplY3QgaXMgbm90IHZhbGlkIHRvIHRoaXMgSU9UeXBlJ3Mgc3RhdGVTY2hlbWFcclxuICAgKi9cclxuICBwdWJsaWMgdmFsaWRhdGVTdGF0ZU9iamVjdCggc3RhdGVPYmplY3Q6IFN0YXRlVHlwZSApOiB2b2lkIHtcclxuICAgIHRoaXMuaXNTdGF0ZU9iamVjdFZhbGlkKCBzdGF0ZU9iamVjdCwgdHJ1ZSApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHRvU3RyaW5nKCk6IElPVHlwZU5hbWUge1xyXG4gICAgcmV0dXJuIHRoaXMudHlwZU5hbWU7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBkZWZhdWx0IHN0YXRlIHZhbHVlXHJcbmNvbnN0IERFRkFVTFRfU1RBVEUgPSBudWxsO1xyXG5cclxuSU9UeXBlLk9iamVjdElPID0gbmV3IElPVHlwZTxQaGV0aW9PYmplY3QsIG51bGw+KCBUYW5kZW1Db25zdGFudHMuT0JKRUNUX0lPX1RZUEVfTkFNRSwge1xyXG4gIGlzVmFsaWRWYWx1ZTogKCkgPT4gdHJ1ZSxcclxuICBzdXBlcnR5cGU6IG51bGwsXHJcbiAgZG9jdW1lbnRhdGlvbjogJ1RoZSByb290IG9mIHRoZSBJTyBUeXBlIGhpZXJhcmNoeScsXHJcbiAgdG9TdGF0ZU9iamVjdDogKCBjb3JlT2JqZWN0OiBQaGV0aW9PYmplY3QgKSA9PiB7XHJcblxyXG4gICAgaWYgKCBwaGV0ICYmIHBoZXQudGFuZGVtICYmIHBoZXQudGFuZGVtLlRhbmRlbS5WQUxJREFUSU9OICkge1xyXG5cclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggY29yZU9iamVjdC50YW5kZW0sICdjb3JlT2JqZWN0IG11c3QgYmUgUGhFVC1pTyBvYmplY3QnICk7XHJcblxyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhY29yZU9iamVjdC5waGV0aW9TdGF0ZSxcclxuICAgICAgICBgZmVsbCBiYWNrIHRvIHJvb3Qgc2VyaWFsaXphdGlvbiBzdGF0ZSBmb3IgJHtjb3JlT2JqZWN0LnRhbmRlbS5waGV0aW9JRH0uIFBvdGVudGlhbCBzb2x1dGlvbnM6XHJcbiAgICAgICAgICogbWFyayB0aGUgdHlwZSBhcyBwaGV0aW9TdGF0ZTogZmFsc2VcclxuICAgICAgICAgKiBjcmVhdGUgYSBjdXN0b20gdG9TdGF0ZU9iamVjdCBtZXRob2QgaW4geW91ciBJTyBUeXBlXHJcbiAgICAgICAgICogcGVyaGFwcyB5b3UgaGF2ZSBldmVyeXRoaW5nIHJpZ2h0LCBidXQgZm9yZ290IHRvIHBhc3MgaW4gdGhlIElPVHlwZSB2aWEgcGhldGlvVHlwZSBpbiB0aGUgY29uc3RydWN0b3JgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gREVGQVVMVF9TVEFURTtcclxuICB9LFxyXG4gIGZyb21TdGF0ZU9iamVjdDogKCkgPT4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCAnT2JqZWN0SU8uZnJvbVN0YXRlT2JqZWN0IHNob3VsZCBub3QgYmUgY2FsbGVkJyApO1xyXG4gIH0sXHJcbiAgc3RhdGVPYmplY3RUb0NyZWF0ZUVsZW1lbnRBcmd1bWVudHM6ICgpID0+IFtdLFxyXG4gIGFwcGx5U3RhdGU6IF8ubm9vcCxcclxuICBtZXRhZGF0YURlZmF1bHRzOiBUYW5kZW1Db25zdGFudHMuUEhFVF9JT19PQkpFQ1RfTUVUQURBVEFfREVGQVVMVFMsXHJcbiAgZGF0YURlZmF1bHRzOiB7XHJcbiAgICBpbml0aWFsU3RhdGU6IERFRkFVTFRfU1RBVEVcclxuICB9LFxyXG4gIHN0YXRlU2NoZW1hOiBudWxsXHJcbn0gKTtcclxuXHJcbnRhbmRlbU5hbWVzcGFjZS5yZWdpc3RlciggJ0lPVHlwZScsIElPVHlwZSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsUUFBUSxNQUFNLDhCQUE4QjtBQUNuRCxPQUFPQyxVQUFVLE1BQXFCLGdDQUFnQztBQUN0RSxPQUFPQyxTQUFTLE1BQU0sb0NBQW9DO0FBQzFELE9BQU9DLGVBQWUsTUFBTSx1QkFBdUI7QUFDbkQsT0FBT0MsZUFBZSxNQUE0Qyx1QkFBdUI7QUFDekYsT0FBT0MsZUFBZSxNQUFNLHVCQUF1QjtBQUNuRCxPQUFPQyxXQUFXLE1BQXFELGtCQUFrQjtBQUt6RjtBQUNBLE1BQU1DLHNCQUFzQixHQUFHO0VBQUVDLGlCQUFpQixFQUFFO0FBQU0sQ0FBQzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsZUFBZSxHQUFLQyxVQUFzQixJQUFjO0VBQzVELE1BQU1DLEtBQUssR0FBR0QsVUFBVSxDQUFDRSxPQUFPLENBQUVULGVBQWUsQ0FBQ1UsY0FBZSxDQUFDO0VBQ2xFQyxNQUFNLElBQUlBLE1BQU0sQ0FBRUgsS0FBSyxJQUFJLENBQUMsRUFBRSwrQkFBZ0MsQ0FBQztFQUMvRCxPQUFPRCxVQUFVLENBQUNLLFNBQVMsQ0FBRSxDQUFDLEVBQUVKLEtBQU0sQ0FBQztBQUN6QyxDQUFDO0FBdUhEO0FBQ0EsZUFBZSxNQUFNSyxNQUFNLENBQTJCO0VBQUU7O0VBYzhCOztFQVVwRjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNTQyxXQUFXQSxDQUFrQkMsUUFBb0IsRUFBRUMs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