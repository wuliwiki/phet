// Copyright 2021-2023, University of Colorado Boulder

/**
 * Class responsible for storing information about the schema of PhET-iO state. See IOType stateSchema option for usage
 * and more information.
 *
 * There are two types of StateSchema, the first serves as a "value", when the state of an IOType is just a value.
 * The second is a "composite", where the state of an IOType is made from sub-components, each of which have an IOType.
 * Check which type of StateSchema your instance is with StateSchema.isComposite().
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */

import Validation from '../../../axon/js/Validation.js';
import assertMutuallyExclusiveOptions from '../../../phet-core/js/assertMutuallyExclusiveOptions.js';
import optionize from '../../../phet-core/js/optionize.js';
import tandemNamespace from '../tandemNamespace.js';
import IOType from './IOType.js';

// As provided in the PhET-iO API json

// The schema of the stateObject value

export default class StateSchema {
  // "composite" state schemas are treated differently that value state schemas

  constructor(providedOptions) {
    // Either create with compositeSchema, or specify a that this state is just a value
    assert && assertMutuallyExclusiveOptions(providedOptions, ['compositeSchema'], ['displayString', 'validator']);
    const options = optionize()({
      displayString: '',
      validator: null,
      // an object literal of keys that correspond to an IOType
      compositeSchema: null
    }, providedOptions);
    this.displayString = options.displayString;
    this.validator = options.validator;
    this.compositeSchema = options.compositeSchema;
  }
  defaultApplyState(coreObject, stateObject) {
    assert && assert(this.isComposite(), 'defaultApplyState from stateSchema only applies to composite stateSchemas');
    for (const stateKey in this.compositeSchema) {
      if (this.compositeSchema.hasOwnProperty(stateKey)) {
        assert && assert(stateObject.hasOwnProperty(stateKey), `stateObject does not have expected schema key: ${stateKey}`);

        // The IOType for the key in the composite.
        const schemaIOType = this.compositeSchema[stateKey];
        const coreObjectAccessor = stateKey.startsWith('_') ? stateKey.substring(1) : stateKey;

        // Using fromStateObject to deserialize sub-component
        if (schemaIOType.defaultDeserializationMethod === 'fromStateObject') {
          // @ts-expect-error, I don't know how to tell typescript that we are accessing an expected key on the PhetioObject subtype. Likely there is no way with making things generic.
          coreObject[coreObjectAccessor] = this.compositeSchema[stateKey].fromStateObject(stateObject[stateKey]);
        } else {
          assert && assert(schemaIOType.defaultDeserializationMethod === 'applyState', 'unexpected deserialization method');

          // Using applyState to deserialize sub-component
          // @ts-expect-error, I don't know how to tell typescript that we are accessing an expected key on the PhetioObject subtype. Likely there is no way with making things generic.
          this.compositeSchema[stateKey].applyState(coreObject[coreObjectAccessor], stateObject[stateKey]);
        }
      }
    }
  }
  defaultToStateObject(coreObject) {
    assert && assert(this.isComposite(), 'defaultToStateObject from stateSchema only applies to composite stateSchemas');
    const stateObject = {};
    for (const stateKey in this.compositeSchema) {
      if (this.compositeSchema.hasOwnProperty(stateKey)) {
        // Trim the '_' if any
        const coreObjectAccessor = stateKey.startsWith('_') ? stateKey.substring(1) : stateKey;

        // @ts-expect-error I guess we need to support schemas outside of composite here, or tell how to avoid that, https://github.com/phetsims/tandem/issues/261
        assert && assert(coreObject.hasOwnProperty(coreObjectAccessor), `cannot get state because coreObject does not have expected schema key: ${coreObjectAccessor}`);

        // @ts-expect-error https://github.com/phetsims/tandem/issues/261
        stateObject[stateKey] = this.compositeSchema[stateKey].toStateObject(coreObject[coreObjectAccessor]);
      }
    }
    return stateObject;
  }

  /**
   * True if the StateSchema is a composite schema.
   */
  isComposite() {
    return !!this.compositeSchema;
  }

  /**
   * Check if a given stateObject is as valid as can be determined by this StateSchema. Will return null if valid, but
   * needs more checking up and down the hierarchy.
   *
   * @param stateObject - the stateObject to validate against
   * @param toAssert - whether to assert when invalid
   * @param schemaKeysPresentInStateObject - to be populated with any keys this StateSchema is responsible for.
   * @returns boolean if validity can be checked, null if valid, but next in the hierarchy is needed
   */
  checkStateObjectValid(stateObject, toAssert, schemaKeysPresentInStateObject) {
    if (this.isComposite()) {
      const compositeStateObject = stateObject;
      const schema = this.compositeSchema;
      let valid = null;
      if (!compositeStateObject) {
        assert && toAssert && assert(false, 'There was no stateObject, but there was a state schema saying there should be', schema);
        valid = false;
        return valid;
      }
      Object.keys(schema).forEach(key => {
        if (!compositeStateObject.hasOwnProperty(key)) {
          assert && toAssert && assert(false, `${key} in state schema but not in the state object`);
          valid = false;
        } else {
          if (!schema[key].isStateObjectValid(compositeStateObject[key], false)) {
            assert && toAssert && assert(false, `stateObject is not valid for ${key}`);
            valid = false;
          }
        }
        schemaKeysPresentInStateObject.push(key);
      });
      return valid;
    } else {
      assert && assert(this.validator, 'validator must be present if not composite');
      const valueStateObject = stateObject;
      assert && toAssert && assert(Validation.getValidationError(valueStateObject, this.validator) === null);
      return Validation.isValueValid(valueStateObject, this.validator);
    }
  }

  /**
   * Get a list of all IOTypes associated with this StateSchema
   */
  getRelatedTypes() {
    const relatedTypes = [];
    if (this.compositeSchema) {
      Object.keys(this.compositeSchema).forEach(stateSchemaKey => {
        this.compositeSchema[stateSchemaKey] instanceof IOType && relatedTypes.push(this.compositeSchema[stateSchemaKey]);
      });
    }
    return relatedTypes;
  }

  /**
   * Returns a unique identified for this stateSchema, or an object of the stateSchemas for each sub-component in the composite
   * (phet-io internal)
   */
  getStateSchemaAPI() {
    if (this.isComposite()) {
      return _.mapValues(this.compositeSchema, value => value.typeName);
    } else {
      return this.displayString;
    }
  }

  /**
   * Factory function for StateKSchema instances that represent a single value of state. This is opposed to a composite
   * schema of sub-components.
   */
  static asValue(displayString, validator) {
    assert && assert(validator, 'validator required');
    return new StateSchema({
      validator: validator,
      displayString: displayString
    });
  }
}
tandemNamespace.register('StateSchema', StateSchema);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWYWxpZGF0aW9uIiwiYXNzZXJ0TXV0dWFsbHlFeGNsdXNpdmVPcHRpb25zIiwib3B0aW9uaXplIiwidGFuZGVtTmFtZXNwYWNlIiwiSU9UeXBlIiwiU3RhdGVTY2hlbWEiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVkT3B0aW9ucyIsImFzc2VydCIsIm9wdGlvbnMiLCJkaXNwbGF5U3RyaW5nIiwidmFsaWRhdG9yIiwiY29tcG9zaXRlU2NoZW1hIiwiZGVmYXVsdEFwcGx5U3RhdGUiLCJjb3JlT2JqZWN0Iiwic3RhdGVPYmplY3QiLCJpc0NvbXBvc2l0ZSIsInN0YXRlS2V5IiwiaGFzT3duUHJvcGVydHkiLCJzY2hlbWFJT1R5cGUiLCJjb3JlT2JqZWN0QWNjZXNzb3IiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwiZGVmYXVsdERlc2VyaWFsaXphdGlvbk1ldGhvZCIsImZyb21TdGF0ZU9iamVjdCIsImFwcGx5U3RhdGUiLCJkZWZhdWx0VG9TdGF0ZU9iamVjdCIsInRvU3RhdGVPYmplY3QiLCJjaGVja1N0YXRlT2JqZWN0VmFsaWQiLCJ0b0Fzc2VydCIsInNjaGVtYUtleXNQcmVzZW50SW5TdGF0ZU9iamVjdCIsImNvbXBvc2l0ZVN0YXRlT2JqZWN0Iiwic2NoZW1hIiwidmFsaWQiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImlzU3RhdGVPYmplY3RWYWxpZCIsInB1c2giLCJ2YWx1ZVN0YXRlT2JqZWN0IiwiZ2V0VmFsaWRhdGlvbkVycm9yIiwiaXNWYWx1ZVZhbGlkIiwiZ2V0UmVsYXRlZFR5cGVzIiwicmVsYXRlZFR5cGVzIiwic3RhdGVTY2hlbWFLZXkiLCJnZXRTdGF0ZVNjaGVtYUFQSSIsIl8iLCJtYXBWYWx1ZXMiLCJ2YWx1ZSIsInR5cGVOYW1lIiwiYXNWYWx1ZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiU3RhdGVTY2hlbWEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIHN0b3JpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNjaGVtYSBvZiBQaEVULWlPIHN0YXRlLiBTZWUgSU9UeXBlIHN0YXRlU2NoZW1hIG9wdGlvbiBmb3IgdXNhZ2VcclxuICogYW5kIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgU3RhdGVTY2hlbWEsIHRoZSBmaXJzdCBzZXJ2ZXMgYXMgYSBcInZhbHVlXCIsIHdoZW4gdGhlIHN0YXRlIG9mIGFuIElPVHlwZSBpcyBqdXN0IGEgdmFsdWUuXHJcbiAqIFRoZSBzZWNvbmQgaXMgYSBcImNvbXBvc2l0ZVwiLCB3aGVyZSB0aGUgc3RhdGUgb2YgYW4gSU9UeXBlIGlzIG1hZGUgZnJvbSBzdWItY29tcG9uZW50cywgZWFjaCBvZiB3aGljaCBoYXZlIGFuIElPVHlwZS5cclxuICogQ2hlY2sgd2hpY2ggdHlwZSBvZiBTdGF0ZVNjaGVtYSB5b3VyIGluc3RhbmNlIGlzIHdpdGggU3RhdGVTY2hlbWEuaXNDb21wb3NpdGUoKS5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBNaWNoYWVsIEthdXptYW5uIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBWYWxpZGF0aW9uLCB7IFZhbGlkYXRvciB9IGZyb20gJy4uLy4uLy4uL2F4b24vanMvVmFsaWRhdGlvbi5qcyc7XHJcbmltcG9ydCBhc3NlcnRNdXR1YWxseUV4Y2x1c2l2ZU9wdGlvbnMgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL2Fzc2VydE11dHVhbGx5RXhjbHVzaXZlT3B0aW9ucy5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCB0YW5kZW1OYW1lc3BhY2UgZnJvbSAnLi4vdGFuZGVtTmFtZXNwYWNlLmpzJztcclxuaW1wb3J0IElPVHlwZSBmcm9tICcuL0lPVHlwZS5qcyc7XHJcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xyXG5pbXBvcnQgeyBJT1R5cGVOYW1lIH0gZnJvbSAnLi4vVGFuZGVtQ29uc3RhbnRzLmpzJztcclxuXHJcbmV4cG9ydCB0eXBlIENvbXBvc2l0ZVNjaGVtYSA9IFJlY29yZDxzdHJpbmcsIElPVHlwZT47XHJcblxyXG4vLyBBcyBwcm92aWRlZCBpbiB0aGUgUGhFVC1pTyBBUEkganNvblxyXG50eXBlIENvbXBvc2l0ZVNjaGVtYUFQSSA9IFJlY29yZDxzdHJpbmcsIElPVHlwZU5hbWU+O1xyXG5cclxuLy8gVGhlIHNjaGVtYSBvZiB0aGUgc3RhdGVPYmplY3QgdmFsdWVcclxuZXhwb3J0IHR5cGUgQ29tcG9zaXRlU3RhdGVPYmplY3RUeXBlID0gUmVjb3JkPHN0cmluZywgSW50ZW50aW9uYWxBbnk+O1xyXG5cclxudHlwZSBTdGF0ZVNjaGVtYU9wdGlvbnMgPSB7XHJcbiAgZGlzcGxheVN0cmluZz86IHN0cmluZztcclxuICB2YWxpZGF0b3I/OiBWYWxpZGF0b3I8SW50ZW50aW9uYWxBbnk+IHwgbnVsbDtcclxuICBjb21wb3NpdGVTY2hlbWE/OiBudWxsIHwgQ29tcG9zaXRlU2NoZW1hO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVTY2hlbWE8VCwgU3RhdGVUeXBlPiB7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBkaXNwbGF5U3RyaW5nOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSByZWFkb25seSB2YWxpZGF0b3I6IFZhbGlkYXRvcjxTdGF0ZVR5cGU+IHwgbnVsbDtcclxuXHJcbiAgLy8gXCJjb21wb3NpdGVcIiBzdGF0ZSBzY2hlbWFzIGFyZSB0cmVhdGVkIGRpZmZlcmVudGx5IHRoYXQgdmFsdWUgc3RhdGUgc2NoZW1hc1xyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb3NpdGVTY2hlbWE6IG51bGwgfCBDb21wb3NpdGVTY2hlbWE7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcHJvdmlkZWRPcHRpb25zPzogU3RhdGVTY2hlbWFPcHRpb25zICkge1xyXG5cclxuICAgIC8vIEVpdGhlciBjcmVhdGUgd2l0aCBjb21wb3NpdGVTY2hlbWEsIG9yIHNwZWNpZnkgYSB0aGF0IHRoaXMgc3RhdGUgaXMganVzdCBhIHZhbHVlXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0TXV0dWFsbHlFeGNsdXNpdmVPcHRpb25zKCBwcm92aWRlZE9wdGlvbnMsIFsgJ2NvbXBvc2l0ZVNjaGVtYScgXSwgWyAnZGlzcGxheVN0cmluZycsICd2YWxpZGF0b3InIF0gKTtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPFN0YXRlU2NoZW1hT3B0aW9ucz4oKSgge1xyXG4gICAgICBkaXNwbGF5U3RyaW5nOiAnJyxcclxuICAgICAgdmFsaWRhdG9yOiBudWxsLFxyXG5cclxuICAgICAgLy8gYW4gb2JqZWN0IGxpdGVyYWwgb2Yga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gYW4gSU9UeXBlXHJcbiAgICAgIGNvbXBvc2l0ZVNjaGVtYTogbnVsbFxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy5kaXNwbGF5U3RyaW5nID0gb3B0aW9ucy5kaXNwbGF5U3RyaW5nO1xyXG4gICAgdGhpcy52YWxpZGF0b3IgPSBvcHRpb25zLnZhbGlkYXRvcjtcclxuXHJcbiAgICB0aGlzLmNvbXBvc2l0ZVNjaGVtYSA9IG9wdGlvbnMuY29tcG9zaXRlU2NoZW1hO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGRlZmF1bHRBcHBseVN0YXRlKCBjb3JlT2JqZWN0OiBULCBzdGF0ZU9iamVjdDogQ29tcG9zaXRlU3RhdGVPYmplY3RUeXBlICk6IHZvaWQge1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaXNDb21wb3NpdGUoKSwgJ2RlZmF1bHRBcHBseVN0YXRlIGZyb20gc3RhdGVTY2hlbWEgb25seSBhcHBsaWVzIHRvIGNvbXBvc2l0ZSBzdGF0ZVNjaGVtYXMnICk7XHJcbiAgICBmb3IgKCBjb25zdCBzdGF0ZUtleSBpbiB0aGlzLmNvbXBvc2l0ZVNjaGVtYSApIHtcclxuICAgICAgaWYgKCB0aGlzLmNvbXBvc2l0ZVNjaGVtYS5oYXNPd25Qcm9wZXJ0eSggc3RhdGVLZXkgKSApIHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBzdGF0ZU9iamVjdC5oYXNPd25Qcm9wZXJ0eSggc3RhdGVLZXkgKSwgYHN0YXRlT2JqZWN0IGRvZXMgbm90IGhhdmUgZXhwZWN0ZWQgc2NoZW1hIGtleTogJHtzdGF0ZUtleX1gICk7XHJcblxyXG4gICAgICAgIC8vIFRoZSBJT1R5cGUgZm9yIHRoZSBrZXkgaW4gdGhlIGNvbXBvc2l0ZS5cclxuICAgICAgICBjb25zdCBzY2hlbWFJT1R5cGUgPSB0aGlzLmNvbXBvc2l0ZVNjaGVtYVsgc3RhdGVLZXkgXTtcclxuXHJcbiAgICAgICAgY29uc3QgY29yZU9iamVjdEFjY2Vzc29yID0gc3RhdGVLZXkuc3RhcnRzV2l0aCggJ18nICkgPyBzdGF0ZUtleS5zdWJzdHJpbmcoIDEgKSA6IHN0YXRlS2V5O1xyXG5cclxuICAgICAgICAvLyBVc2luZyBmcm9tU3RhdGVPYmplY3QgdG8gZGVzZXJpYWxpemUgc3ViLWNvbXBvbmVudFxyXG4gICAgICAgIGlmICggc2NoZW1hSU9UeXBlLmRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2QgPT09ICdmcm9tU3RhdGVPYmplY3QnICkge1xyXG5cclxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IsIEkgZG9uJ3Qga25vdyBob3cgdG8gdGVsbCB0eXBlc2NyaXB0IHRoYXQgd2UgYXJlIGFjY2Vzc2luZyBhbiBleHBlY3RlZCBrZXkgb24gdGhlIFBoZXRpb09iamVjdCBzdWJ0eXBlLiBMaWtlbHkgdGhlcmUgaXMgbm8gd2F5IHdpdGggbWFraW5nIHRoaW5ncyBnZW5lcmljLlxyXG4gICAgICAgICAgY29yZU9iamVjdFsgY29yZU9iamVjdEFjY2Vzc29yIF0gPSB0aGlzLmNvbXBvc2l0ZVNjaGVtYVsgc3RhdGVLZXkgXS5mcm9tU3RhdGVPYmplY3QoIHN0YXRlT2JqZWN0WyBzdGF0ZUtleSBdICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggc2NoZW1hSU9UeXBlLmRlZmF1bHREZXNlcmlhbGl6YXRpb25NZXRob2QgPT09ICdhcHBseVN0YXRlJywgJ3VuZXhwZWN0ZWQgZGVzZXJpYWxpemF0aW9uIG1ldGhvZCcgKTtcclxuXHJcbiAgICAgICAgICAvLyBVc2luZyBhcHBseVN0YXRlIHRvIGRlc2VyaWFsaXplIHN1Yi1jb21wb25lbnRcclxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IsIEkgZG9uJ3Qga25vdyBob3cgdG8gdGVsbCB0eXBlc2NyaXB0IHRoYXQgd2UgYXJlIGFjY2Vzc2luZyBhbiBleHBlY3RlZCBrZXkgb24gdGhlIFBoZXRpb09iamVjdCBzdWJ0eXBlLiBMaWtlbHkgdGhlcmUgaXMgbm8gd2F5IHdpdGggbWFraW5nIHRoaW5ncyBnZW5lcmljLlxyXG4gICAgICAgICAgdGhpcy5jb21wb3NpdGVTY2hlbWFbIHN0YXRlS2V5IF0uYXBwbHlTdGF0ZSggY29yZU9iamVjdFsgY29yZU9iamVjdEFjY2Vzc29yIF0sIHN0YXRlT2JqZWN0WyBzdGF0ZUtleSBdICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZGVmYXVsdFRvU3RhdGVPYmplY3QoIGNvcmVPYmplY3Q6IFQgKTogU3RhdGVUeXBlIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaXNDb21wb3NpdGUoKSwgJ2RlZmF1bHRUb1N0YXRlT2JqZWN0IGZyb20gc3RhdGVTY2hlbWEgb25seSBhcHBsaWVzIHRvIGNvbXBvc2l0ZSBzdGF0ZVNjaGVtYXMnICk7XHJcblxyXG4gICAgY29uc3Qgc3RhdGVPYmplY3QgPSB7fTtcclxuICAgIGZvciAoIGNvbnN0IHN0YXRlS2V5IGluIHRoaXMuY29tcG9zaXRlU2NoZW1hICkge1xyXG4gICAgICBpZiAoIHRoaXMuY29tcG9zaXRlU2NoZW1hLmhhc093blByb3BlcnR5KCBzdGF0ZUtleSApICkge1xyXG5cclxuICAgICAgICAvLyBUcmltIHRoZSAnXycgaWYgYW55XHJcbiAgICAgICAgY29uc3QgY29yZU9iamVjdEFjY2Vzc29yID0gc3RhdGVLZXkuc3RhcnRzV2l0aCggJ18nICkgPyBzdGF0ZUtleS5zdWJzdHJpbmcoIDEgKSA6IHN0YXRlS2V5O1xyXG5cclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEkgZ3Vlc3Mgd2UgbmVlZCB0byBzdXBwb3J0IHNjaGVtYXMgb3V0c2lkZSBvZiBjb21wb3NpdGUgaGVyZSwgb3IgdGVsbCBob3cgdG8gYXZvaWQgdGhhdCwgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3RhbmRlbS9pc3N1ZXMvMjYxXHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggY29yZU9iamVjdC5oYXNPd25Qcm9wZXJ0eSggY29yZU9iamVjdEFjY2Vzc29yICksXHJcbiAgICAgICAgICBgY2Fubm90IGdldCBzdGF0ZSBiZWNhdXNlIGNvcmVPYmplY3QgZG9lcyBub3QgaGF2ZSBleHBlY3RlZCBzY2hlbWEga2V5OiAke2NvcmVPYmplY3RBY2Nlc3Nvcn1gICk7XHJcblxyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3RhbmRlbS9pc3N1ZXMvMjYxXHJcbiAgICAgICAgc3RhdGVPYmplY3RbIHN0YXRlS2V5IF0gPSB0aGlzLmNvbXBvc2l0ZVNjaGVtYVsgc3RhdGVLZXkgXS50b1N0YXRlT2JqZWN0KCBjb3JlT2JqZWN0WyBjb3JlT2JqZWN0QWNjZXNzb3IgXSApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhdGVPYmplY3QgYXMgU3RhdGVUeXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJ1ZSBpZiB0aGUgU3RhdGVTY2hlbWEgaXMgYSBjb21wb3NpdGUgc2NoZW1hLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBpc0NvbXBvc2l0ZSgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAhIXRoaXMuY29tcG9zaXRlU2NoZW1hO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBnaXZlbiBzdGF0ZU9iamVjdCBpcyBhcyB2YWxpZCBhcyBjYW4gYmUgZGV0ZXJtaW5lZCBieSB0aGlzIFN0YXRlU2NoZW1hLiBXaWxsIHJldHVybiBudWxsIGlmIHZhbGlkLCBidXRcclxuICAgKiBuZWVkcyBtb3JlIGNoZWNraW5nIHVwIGFuZCBkb3duIHRoZSBoaWVyYXJjaHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RhdGVPYmplY3QgLSB0aGUgc3RhdGVPYmplY3QgdG8gdmFsaWRhdGUgYWdhaW5zdFxyXG4gICAqIEBwYXJhbSB0b0Fzc2VydCAtIHdoZXRoZXIgdG8gYXNzZXJ0IHdoZW4gaW52YWxpZFxyXG4gICAqIEBwYXJhbSBzY2hlbWFLZXlzUHJlc2VudEluU3RhdGVPYmplY3QgLSB0byBiZSBwb3B1bGF0ZWQgd2l0aCBhbnkga2V5cyB0aGlzIFN0YXRlU2NoZW1hIGlzIHJlc3BvbnNpYmxlIGZvci5cclxuICAgKiBAcmV0dXJucyBib29sZWFuIGlmIHZhbGlkaXR5IGNhbiBiZSBjaGVja2VkLCBudWxsIGlmIHZhbGlkLCBidXQgbmV4dCBpbiB0aGUgaGllcmFyY2h5IGlzIG5lZWRlZFxyXG4gICAqL1xyXG4gIHB1YmxpYyBjaGVja1N0YXRlT2JqZWN0VmFsaWQoIHN0YXRlT2JqZWN0OiBTdGF0ZVR5cGUsIHRvQXNzZXJ0OiBib29sZWFuLCBzY2hlbWFLZXlzUHJlc2VudEluU3RhdGVPYmplY3Q6IHN0cmluZ1tdICk6IGJvb2xlYW4gfCBudWxsIHtcclxuICAgIGlmICggdGhpcy5pc0NvbXBvc2l0ZSgpICkge1xyXG4gICAgICBjb25zdCBjb21wb3NpdGVTdGF0ZU9iamVjdCA9IHN0YXRlT2JqZWN0IGFzIENvbXBvc2l0ZVN0YXRlT2JqZWN0VHlwZTtcclxuICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5jb21wb3NpdGVTY2hlbWEhO1xyXG5cclxuICAgICAgbGV0IHZhbGlkID0gbnVsbDtcclxuICAgICAgaWYgKCAhY29tcG9zaXRlU3RhdGVPYmplY3QgKSB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIHRvQXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsICdUaGVyZSB3YXMgbm8gc3RhdGVPYmplY3QsIGJ1dCB0aGVyZSB3YXMgYSBzdGF0ZSBzY2hlbWEgc2F5aW5nIHRoZXJlIHNob3VsZCBiZScsIHNjaGVtYSApO1xyXG4gICAgICAgIHZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xyXG4gICAgICB9XHJcbiAgICAgIE9iamVjdC5rZXlzKCBzY2hlbWEgKS5mb3JFYWNoKCBrZXkgPT4ge1xyXG4gICAgICAgIGlmICggIWNvbXBvc2l0ZVN0YXRlT2JqZWN0Lmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcclxuICAgICAgICAgIGFzc2VydCAmJiB0b0Fzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCBgJHtrZXl9IGluIHN0YXRlIHNjaGVtYSBidXQgbm90IGluIHRoZSBzdGF0ZSBvYmplY3RgICk7XHJcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmICggIXNjaGVtYVsga2V5IF0uaXNTdGF0ZU9iamVjdFZhbGlkKCBjb21wb3NpdGVTdGF0ZU9iamVjdFsga2V5IF0sIGZhbHNlICkgKSB7XHJcbiAgICAgICAgICAgIGFzc2VydCAmJiB0b0Fzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCBgc3RhdGVPYmplY3QgaXMgbm90IHZhbGlkIGZvciAke2tleX1gICk7XHJcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjaGVtYUtleXNQcmVzZW50SW5TdGF0ZU9iamVjdC5wdXNoKCBrZXkgKTtcclxuICAgICAgfSApO1xyXG4gICAgICByZXR1cm4gdmFsaWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy52YWxpZGF0b3IsICd2YWxpZGF0b3IgbXVzdCBiZSBwcmVzZW50IGlmIG5vdCBjb21wb3NpdGUnICk7XHJcbiAgICAgIGNvbnN0IHZhbHVlU3RhdGVPYmplY3QgPSBzdGF0ZU9iamVjdDtcclxuICAgICAgYXNzZXJ0ICYmIHRvQXNzZXJ0ICYmIGFzc2VydCggVmFsaWRhdGlvbi5nZXRWYWxpZGF0aW9uRXJyb3IoIHZhbHVlU3RhdGVPYmplY3QsIHRoaXMudmFsaWRhdG9yISApID09PSBudWxsICk7XHJcblxyXG4gICAgICByZXR1cm4gVmFsaWRhdGlvbi5pc1ZhbHVlVmFsaWQoIHZhbHVlU3RhdGVPYmplY3QsIHRoaXMudmFsaWRhdG9yISApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBhbGwgSU9UeXBlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBTdGF0ZVNjaGVtYVxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRSZWxhdGVkVHlwZXMoKTogSU9UeXBlW10ge1xyXG4gICAgY29uc3QgcmVsYXRlZFR5cGVzOiBJT1R5cGVbXSA9IFtdO1xyXG5cclxuICAgIGlmICggdGhpcy5jb21wb3NpdGVTY2hlbWEgKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKCB0aGlzLmNvbXBvc2l0ZVNjaGVtYSApLmZvckVhY2goIHN0YXRlU2NoZW1hS2V5ID0+IHtcclxuICAgICAgICB0aGlzLmNvbXBvc2l0ZVNjaGVtYSFbIHN0YXRlU2NoZW1hS2V5IF0gaW5zdGFuY2VvZiBJT1R5cGUgJiYgcmVsYXRlZFR5cGVzLnB1c2goIHRoaXMuY29tcG9zaXRlU2NoZW1hIVsgc3RhdGVTY2hlbWFLZXkgXSApO1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVsYXRlZFR5cGVzO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSB1bmlxdWUgaWRlbnRpZmllZCBmb3IgdGhpcyBzdGF0ZVNjaGVtYSwgb3IgYW4gb2JqZWN0IG9mIHRoZSBzdGF0ZVNjaGVtYXMgZm9yIGVhY2ggc3ViLWNvbXBvbmVudCBpbiB0aGUgY29tcG9zaXRlXHJcbiAgICogKHBoZXQtaW8gaW50ZXJuYWwpXHJcbiAgICovXHJcbiAgcHVibGljIGdldFN0YXRlU2NoZW1hQVBJKCk6IHN0cmluZyB8IENvbXBvc2l0ZVNjaGVtYUFQSSB7XHJcbiAgICBpZiAoIHRoaXMuaXNDb21wb3NpdGUoKSApIHtcclxuICAgICAgcmV0dXJuIF8ubWFwVmFsdWVzKCB0aGlzLmNvbXBvc2l0ZVNjaGVtYSwgdmFsdWUgPT4gdmFsdWUudHlwZU5hbWUgKSE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheVN0cmluZztcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBTdGF0ZUtTY2hlbWEgaW5zdGFuY2VzIHRoYXQgcmVwcmVzZW50IGEgc2luZ2xlIHZhbHVlIG9mIHN0YXRlLiBUaGlzIGlzIG9wcG9zZWQgdG8gYSBjb21wb3NpdGVcclxuICAgKiBzY2hlbWEgb2Ygc3ViLWNvbXBvbmVudHMuXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBhc1ZhbHVlPFQsIFN0YXRlVHlwZT4oIGRpc3BsYXlTdHJpbmc6IHN0cmluZywgdmFsaWRhdG9yOiBWYWxpZGF0b3I8SW50ZW50aW9uYWxBbnk+ICk6IFN0YXRlU2NoZW1hPFQsIFN0YXRlVHlwZT4ge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdmFsaWRhdG9yLCAndmFsaWRhdG9yIHJlcXVpcmVkJyApO1xyXG4gICAgcmV0dXJuIG5ldyBTdGF0ZVNjaGVtYTxULCBTdGF0ZVR5cGU+KCB7XHJcbiAgICAgIHZhbGlkYXRvcjogdmFsaWRhdG9yLFxyXG4gICAgICBkaXNwbGF5U3RyaW5nOiBkaXNwbGF5U3RyaW5nXHJcbiAgICB9ICk7XHJcbiAgfVxyXG59XHJcblxyXG50YW5kZW1OYW1lc3BhY2UucmVnaXN0ZXIoICdTdGF0ZVNjaGVtYScsIFN0YXRlU2NoZW1hICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFVBQVUsTUFBcUIsZ0NBQWdDO0FBQ3RFLE9BQU9DLDhCQUE4QixNQUFNLHlEQUF5RDtBQUNwRyxPQUFPQyxTQUFTLE1BQU0sb0NBQW9DO0FBQzFELE9BQU9DLGVBQWUsTUFBTSx1QkFBdUI7QUFDbkQsT0FBT0MsTUFBTSxNQUFNLGFBQWE7O0FBTWhDOztBQUdBOztBQVNBLGVBQWUsTUFBTUMsV0FBVyxDQUFlO0VBSTdDOztFQUdPQyxXQUFXQSxDQUFFQyxlQUFvQyxFQUFHO0lBRXpEO0lBQ0FDLE1BQU0sSUFBSVAsOEJBQThCLENBQUVNLGVBQWUsRUFBRSxDQUFFLGlCQUFpQixDQUFFLEVBQUUsQ0FBRSxlQUFlLEVBQUUsV0FBVyxDQUFHLENBQUM7SUFFcEgsTUFBTUUsT0FBTyxHQUFHUCxTQUFTLENBQXFCLENBQUMsQ0FBRTtNQUMvQ1EsYUFBYSxFQUFFLEVBQUU7TUFDakJDLFNBQVMsRUFBRSxJQUFJO01BRWY7TUFDQUMsZUFBZSxFQUFFO0lBQ25CLENBQUMsRUFBRUwsZUFBZ0IsQ0FBQztJQUVwQixJQUFJLENBQUNHLGFBQWEsR0FBR0QsT0FBTyxDQUFDQyxhQUFhO0lBQzFDLElBQUksQ0FBQ0MsU0FBUyxHQUFHRixPQUFPLENBQUNFLFNBQVM7SUFFbEMsSUFBSSxDQUFDQyxlQUFlLEdBQUdILE9BQU8sQ0FBQ0csZUFBZTtF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