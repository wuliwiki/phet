// Copyright 2018-2022, University of Colorado Boulder

/**
 * IO Type for JS's built-in function type.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */

import tandemNamespace from '../tandemNamespace.js';
import IOType from './IOType.js';

// cache each parameterized IOType so that it is only created once
const cache = new Map();

/**
 * Parametric IO Type constructor--given return type and parameter types, this function returns a type wrapped IO Type for
 * that "class" of functions. "Class" here refers to the supported parameter and return IO Types.
 * This caching implementation should be kept in sync with the other parametric IO Type caching implementations.
 * @param returnType - IO Type of the return type of the function that can support cross-frame serialization
 * @param functionParameterTypes - IO Types for the individual arguments of the function.
 */
const FunctionIO = (returnType, functionParameterTypes) => {
  for (let i = 0; i < functionParameterTypes.length; i++) {
    assert && assert(functionParameterTypes[i], 'parameter type was not truthy');
  }
  assert && assert(returnType, 'return type was not truthy');

  // REVIEW https://github.com/phetsims/tandem/issues/169 Why is this different than the typeName later in this file?
  const cacheKey = `${returnType.typeName}.${functionParameterTypes.map(type => type.typeName).join(',')}`;
  if (!cache.has(cacheKey)) {
    // gather a list of argument names for the documentation string
    let argsString = functionParameterTypes.map(parameterType => parameterType.typeName).join(', ');
    if (argsString === '') {
      argsString = 'none';
    }
    const parameterTypesString = functionParameterTypes.map(parameterType => parameterType.typeName).join(',');
    cache.set(cacheKey, new IOType(`FunctionIO(${parameterTypesString})=>${returnType.typeName}`, {
      valueType: 'function',
      isFunctionType: true,
      // These are the parameters to this FunctionIO, not to the function it wraps. That is why it includes the return type.
      // NOTE: the order is very important, for instance phetioCommandProcessor relies on the parameters being before
      // the return type.  If we decide this is too brittle, perhaps we should subclass IOType to FunctionIOType, and it
      // can track its functionParameterTypes separately from the returnType.
      parameterTypes: functionParameterTypes.concat([returnType]),
      documentation: `${'Wrapper for the built-in JS function type.<br>' + '<strong>Arguments:</strong> '}${argsString}<br>` + `<strong>Return Type:</strong> ${returnType.typeName}`
    }));
  }
  return cache.get(cacheKey);
};
tandemNamespace.register('FunctionIO', FunctionIO);
export default FunctionIO;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ0YW5kZW1OYW1lc3BhY2UiLCJJT1R5cGUiLCJjYWNoZSIsIk1hcCIsIkZ1bmN0aW9uSU8iLCJyZXR1cm5UeXBlIiwiZnVuY3Rpb25QYXJhbWV0ZXJUeXBlcyIsImkiLCJsZW5ndGgiLCJhc3NlcnQiLCJjYWNoZUtleSIsInR5cGVOYW1lIiwibWFwIiwidHlwZSIsImpvaW4iLCJoYXMiLCJhcmdzU3RyaW5nIiwicGFyYW1ldGVyVHlwZSIsInBhcmFtZXRlclR5cGVzU3RyaW5nIiwic2V0IiwidmFsdWVUeXBlIiwiaXNGdW5jdGlvblR5cGUiLCJwYXJhbWV0ZXJUeXBlcyIsImNvbmNhdCIsImRvY3VtZW50YXRpb24iLCJnZXQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkZ1bmN0aW9uSU8udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTgtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogSU8gVHlwZSBmb3IgSlMncyBidWlsdC1pbiBmdW5jdGlvbiB0eXBlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKiBAYXV0aG9yIEFuZHJldyBBZGFyZSAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgdGFuZGVtTmFtZXNwYWNlIGZyb20gJy4uL3RhbmRlbU5hbWVzcGFjZS5qcyc7XHJcbmltcG9ydCBJT1R5cGUgZnJvbSAnLi9JT1R5cGUuanMnO1xyXG5cclxuXHJcbi8vIGNhY2hlIGVhY2ggcGFyYW1ldGVyaXplZCBJT1R5cGUgc28gdGhhdCBpdCBpcyBvbmx5IGNyZWF0ZWQgb25jZVxyXG5jb25zdCBjYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBJT1R5cGU+KCk7XHJcblxyXG4vKipcclxuICogUGFyYW1ldHJpYyBJTyBUeXBlIGNvbnN0cnVjdG9yLS1naXZlbiByZXR1cm4gdHlwZSBhbmQgcGFyYW1ldGVyIHR5cGVzLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0eXBlIHdyYXBwZWQgSU8gVHlwZSBmb3JcclxuICogdGhhdCBcImNsYXNzXCIgb2YgZnVuY3Rpb25zLiBcIkNsYXNzXCIgaGVyZSByZWZlcnMgdG8gdGhlIHN1cHBvcnRlZCBwYXJhbWV0ZXIgYW5kIHJldHVybiBJTyBUeXBlcy5cclxuICogVGhpcyBjYWNoaW5nIGltcGxlbWVudGF0aW9uIHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgb3RoZXIgcGFyYW1ldHJpYyBJTyBUeXBlIGNhY2hpbmcgaW1wbGVtZW50YXRpb25zLlxyXG4gKiBAcGFyYW0gcmV0dXJuVHlwZSAtIElPIFR5cGUgb2YgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGNhbiBzdXBwb3J0IGNyb3NzLWZyYW1lIHNlcmlhbGl6YXRpb25cclxuICogQHBhcmFtIGZ1bmN0aW9uUGFyYW1ldGVyVHlwZXMgLSBJTyBUeXBlcyBmb3IgdGhlIGluZGl2aWR1YWwgYXJndW1lbnRzIG9mIHRoZSBmdW5jdGlvbi5cclxuICovXHJcbmNvbnN0IEZ1bmN0aW9uSU8gPSAoIHJldHVyblR5cGU6IElPVHlwZSwgZnVuY3Rpb25QYXJhbWV0ZXJUeXBlczogSU9UeXBlW10gKTogSU9UeXBlID0+IHtcclxuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBmdW5jdGlvblBhcmFtZXRlclR5cGVzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZnVuY3Rpb25QYXJhbWV0ZXJUeXBlc1sgaSBdLCAncGFyYW1ldGVyIHR5cGUgd2FzIG5vdCB0cnV0aHknICk7XHJcbiAgfVxyXG4gIGFzc2VydCAmJiBhc3NlcnQoIHJldHVyblR5cGUsICdyZXR1cm4gdHlwZSB3YXMgbm90IHRydXRoeScgKTtcclxuXHJcbiAgLy8gUkVWSUVXIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy90YW5kZW0vaXNzdWVzLzE2OSBXaHkgaXMgdGhpcyBkaWZmZXJlbnQgdGhhbiB0aGUgdHlwZU5hbWUgbGF0ZXIgaW4gdGhpcyBmaWxlP1xyXG4gIGNvbnN0IGNhY2hlS2V5ID0gYCR7cmV0dXJuVHlwZS50eXBlTmFtZX0uJHtmdW5jdGlvblBhcmFtZXRlclR5cGVzLm1hcCggdHlwZSA9PiB0eXBlLnR5cGVOYW1lICkuam9pbiggJywnICl9YDtcclxuXHJcbiAgaWYgKCAhY2FjaGUuaGFzKCBjYWNoZUtleSApICkge1xyXG5cclxuICAgIC8vIGdhdGhlciBhIGxpc3Qgb2YgYXJndW1lbnQgbmFtZXMgZm9yIHRoZSBkb2N1bWVudGF0aW9uIHN0cmluZ1xyXG4gICAgbGV0IGFyZ3NTdHJpbmcgPSBmdW5jdGlvblBhcmFtZXRlclR5cGVzLm1hcCggcGFyYW1ldGVyVHlwZSA9PiBwYXJhbWV0ZXJUeXBlLnR5cGVOYW1lICkuam9pbiggJywgJyApO1xyXG4gICAgaWYgKCBhcmdzU3RyaW5nID09PSAnJyApIHtcclxuICAgICAgYXJnc1N0cmluZyA9ICdub25lJztcclxuICAgIH1cclxuICAgIGNvbnN0IHBhcmFtZXRlclR5cGVzU3RyaW5nID0gZnVuY3Rpb25QYXJhbWV0ZXJUeXBlcy5tYXAoIHBhcmFtZXRlclR5cGUgPT4gcGFyYW1ldGVyVHlwZS50eXBlTmFtZSApLmpvaW4oICcsJyApO1xyXG5cclxuICAgIGNhY2hlLnNldCggY2FjaGVLZXksIG5ldyBJT1R5cGUoIGBGdW5jdGlvbklPKCR7cGFyYW1ldGVyVHlwZXNTdHJpbmd9KT0+JHtyZXR1cm5UeXBlLnR5cGVOYW1lfWAsIHtcclxuICAgICAgdmFsdWVUeXBlOiAnZnVuY3Rpb24nLFxyXG5cclxuICAgICAgaXNGdW5jdGlvblR5cGU6IHRydWUsXHJcblxyXG4gICAgICAvLyBUaGVzZSBhcmUgdGhlIHBhcmFtZXRlcnMgdG8gdGhpcyBGdW5jdGlvbklPLCBub3QgdG8gdGhlIGZ1bmN0aW9uIGl0IHdyYXBzLiBUaGF0IGlzIHdoeSBpdCBpbmNsdWRlcyB0aGUgcmV0dXJuIHR5cGUuXHJcbiAgICAgIC8vIE5PVEU6IHRoZSBvcmRlciBpcyB2ZXJ5IGltcG9ydGFudCwgZm9yIGluc3RhbmNlIHBoZXRpb0NvbW1hbmRQcm9jZXNzb3IgcmVsaWVzIG9uIHRoZSBwYXJhbWV0ZXJzIGJlaW5nIGJlZm9yZVxyXG4gICAgICAvLyB0aGUgcmV0dXJuIHR5cGUuICBJZiB3ZSBkZWNpZGUgdGhpcyBpcyB0b28gYnJpdHRsZSwgcGVyaGFwcyB3ZSBzaG91bGQgc3ViY2xhc3MgSU9UeXBlIHRvIEZ1bmN0aW9uSU9UeXBlLCBhbmQgaXRcclxuICAgICAgLy8gY2FuIHRyYWNrIGl0cyBmdW5jdGlvblBhcmFtZXRlclR5cGVzIHNlcGFyYXRlbHkgZnJvbSB0aGUgcmV0dXJuVHlwZS5cclxuICAgICAgcGFyYW1ldGVyVHlwZXM6IGZ1bmN0aW9uUGFyYW1ldGVyVHlwZXMuY29uY2F0KCBbIHJldHVyblR5cGUgXSApLFxyXG4gICAgICBkb2N1bWVudGF0aW9uOiBgJHsnV3JhcHBlciBmb3IgdGhlIGJ1aWx0LWluIEpTIGZ1bmN0aW9uIHR5cGUuPGJyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAnPHN0cm9uZz5Bcmd1bWVudHM6PC9zdHJvbmc+ICd9JHthcmdzU3RyaW5nfTxicj5gICtcclxuICAgICAgICAgICAgICAgICAgICAgYDxzdHJvbmc+UmV0dXJuIFR5cGU6PC9zdHJvbmc+ICR7cmV0dXJuVHlwZS50eXBlTmFtZX1gXHJcbiAgICB9ICkgKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjYWNoZS5nZXQoIGNhY2hlS2V5ICkhO1xyXG59O1xyXG5cclxudGFuZGVtTmFtZXNwYWNlLnJlZ2lzdGVyKCAnRnVuY3Rpb25JTycsIEZ1bmN0aW9uSU8gKTtcclxuZXhwb3J0IGRlZmF1bHQgRnVuY3Rpb25JTzsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxlQUFlLE1BQU0sdUJBQXVCO0FBQ25ELE9BQU9DLE1BQU0sTUFBTSxhQUFhOztBQUdoQztBQUNBLE1BQU1DLEtBQUssR0FBRyxJQUFJQyxHQUFHLENBQWlCLENBQUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsVUFBVSxHQUFHQSxDQUFFQyxVQUFrQixFQUFFQyxzQkFBZ0MsS0FBYztFQUNyRixLQUFNLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0Qsc0JBQXNCLENBQUNFLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUc7SUFDeERFLE1BQU0sSUFBSUEsTUFBTSxDQUFFSCxzQkFBc0IsQ0FBRUMsQ0FBQyxDQUFFLEVBQUUsK0JBQWdDLENBQUM7RUFDbEY7RUFDQUUsTUFBTSxJQUFJQSxNQUFNLENBQUVKLFVBQVUsRUFBRSw0QkFBNkIsQ0FBQzs7RUFFNUQ7RUFDQSxNQUFNSyxRQUFRLEdBQUksR0FBRUwsVUFBVSxDQUFDTSxRQUFTLElBQUdMLHNCQUFzQixDQUFDTSxHQUFHLENBQUVDLElBQUksSUFBSUEsSUFBSSxDQUFDRixRQUFTLENBQUMsQ0FBQ0csSUFBSSxDQUFFLEdBQUksQ0FBRSxFQUFDO0VBRTVHLElBQUssQ0FBQ1osS0FBSyxDQUFDYSxHQUFHLENBQUVMLFFBQVMsQ0FBQyxFQUFHO0lBRTVCO0lBQ0EsSUFBSU0sVUFBVSxHQUFHVixzQkFBc0IsQ0FBQ00sR0FBRyxDQUFFSyxhQUFhLElBQUlBLGFBQWEsQ0FBQ04sUUFBUyxDQUFDLENBQUNHLElBQUksQ0FBRSxJQUFLLENBQUM7SUFDbkcsSUFBS0UsVUFBVSxLQUFLLEVBQUUsRUFBRztNQUN2QkEsVUFBVSxHQUFHLE1BQU07SUFDckI7SUFDQSxNQUFNRSxvQkFBb0IsR0FBR1osc0JBQXNCLENBQUNNLEdBQUcsQ0FBRUssYUFBYSxJQUFJQSxhQUFhLENBQUNOLFFBQVMsQ0FBQyxDQUFDRyxJQUFJLENBQUUsR0FBSSxDQUFDO0lBRTlHWixLQUFLLENBQUNpQixHQUFHLENBQUVULFFBQVEsRUFBRSxJQUFJVCxNQUFNLENBQUcsY0FBYWlCLG9CQUFxQixNQUFLYixVQUFVLENBQUNNLFFBQVMsRUFBQyxFQUFFO01BQzlGUyxTQUFTLEVBQUUsVUFBVTtNQUVyQkMsY0FBYyxFQUFFLElBQUk7TUFFcEI7TUFDQTtNQUNBO01BQ0E7TUFDQUMsY0FBYyxFQUFFaEIsc0JBQXNCLENBQUNpQixNQUFNLENBQUUsQ0FBRWxCLFVBQVUsQ0FBRyxDQUFDO01BQy9EbUIsYUFBYSxFQUFHLEdBQUUsZ0RBQWdELEdBQ25ELDhCQUErQixHQUFFUixVQUFXLE1BQUssR0FDaEQsaUNBQWdDWCxVQUFVLENBQUNNLFFBQVM7SUFDdEUsQ0FBRSxDQUFFLENBQUM7RUFDUDtFQUVBLE9BQU9ULEtBQUssQ0FBQ3VCLEdBQUcsQ0FBRWYsUUFBUyxDQUFDO0FBQzlCLENBQUM7QUFFRFYsZUFBZSxDQUFDMEIsUUFBUSxDQUFFLFlBQVksRUFBRXRCLFVBQVcsQ0FBQztBQUNwRCxlQUFlQSxVQUFVIn0=