// Copyright 2018-2022, University of Colorado Boulder

/**
 * Container for the circular representation
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import Vector2 from '../../../../../dot/js/Vector2.js';
import { Shape } from '../../../../../kite/js/imports.js';
import { Circle, Path } from '../../../../../scenery/js/imports.js';
import FractionsCommonConstants from '../../../common/FractionsCommonConstants.js';
import FractionsCommonColors from '../../../common/view/FractionsCommonColors.js';
import fractionsCommon from '../../../fractionsCommon.js';
import CellContainerNode from '../CellContainerNode.js';
import CircularNode from './CircularNode.js';
class CircularContainerNode extends CellContainerNode {
  /**
   * @param {Container} container
   * @param {Object} [options]
   */
  constructor(container, options) {
    super(container, options);

    // @public
    this.circleRadius = CircularNode.RADIUS;

    // Extend by 0.5 so that our cell fills don't overlap our border
    this.addChild(new Circle(this.circleRadius + 0.5, {
      lineWidth: FractionsCommonConstants.INTRO_CONTAINER_LINE_WIDTH,
      fill: FractionsCommonColors.introContainerBackgroundProperty,
      stroke: this.strokeProperty
    }));

    // Use current bounds as permanent bounds
    this.localBounds = this.localBounds; // eslint-disable-line no-self-assign

    // @private {Path} creates the path for the dividing lines between cells
    this.cellDividersPath = new Path(null, {
      stroke: this.strokeProperty
    });
    this.addChild(this.cellDividersPath);
    this.rebuild();
    this.mutate(options);
  }

  /**
   * Rebuilds the full container (required when the number of cells changes).
   * @protected
   * @override
   */
  rebuild() {
    super.rebuild();
    const cellDividersShape = new Shape();
    const denominator = this.container.cells.length;

    // disregard segment for denominator equal to 1
    const cellDividersLength = denominator > 1 ? this.circleRadius : 0;

    // creates an angle between the cells of a circle node that corresponds to the denominator value
    const cellDividersAngle = 2 * Math.PI / denominator;
    for (let i = 0; i < denominator; i++) {
      const cell = this.container.cells.get(i);
      const cellNode = new CircularNode(denominator, i, {
        colorOverride: this.colorOverride
      });
      cellNode.translation = cellNode.getContainerOffset();
      this.addCellNode(cell, cellNode);

      // positions and draws the polar coordinate of the dividing line between cells
      const edgePosition = Vector2.createPolar(cellDividersLength, i * cellDividersAngle);
      if (cellDividersLength) {
        // Workaround for https://github.com/phetsims/scenery/issues/750
        cellDividersShape.moveToPoint(edgePosition).lineToPoint(edgePosition.normalized().timesScalar(0.01));
      }
    }
    this.cellDividersPath.setShape(cellDividersShape);
  }
}
fractionsCommon.register('CircularContainerNode', CircularContainerNode);
export default CircularContainerNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiU2hhcGUiLCJDaXJjbGUiLCJQYXRoIiwiRnJhY3Rpb25zQ29tbW9uQ29uc3RhbnRzIiwiRnJhY3Rpb25zQ29tbW9uQ29sb3JzIiwiZnJhY3Rpb25zQ29tbW9uIiwiQ2VsbENvbnRhaW5lck5vZGUiLCJDaXJjdWxhck5vZGUiLCJDaXJjdWxhckNvbnRhaW5lck5vZGUiLCJjb25zdHJ1Y3RvciIsImNvbnRhaW5lciIsIm9wdGlvbnMiLCJjaXJjbGVSYWRpdXMiLCJSQURJVVMiLCJhZGRDaGlsZCIsImxpbmVXaWR0aCIsIklOVFJPX0NPTlRBSU5FUl9MSU5FX1dJRFRIIiwiZmlsbCIsImludHJvQ29udGFpbmVyQmFja2dyb3VuZFByb3BlcnR5Iiwic3Ryb2tlIiwic3Ryb2tlUHJvcGVydHkiLCJsb2NhbEJvdW5kcyIsImNlbGxEaXZpZGVyc1BhdGgiLCJyZWJ1aWxkIiwibXV0YXRlIiwiY2VsbERpdmlkZXJzU2hhcGUiLCJkZW5vbWluYXRvciIsImNlbGxzIiwibGVuZ3RoIiwiY2VsbERpdmlkZXJzTGVuZ3RoIiwiY2VsbERpdmlkZXJzQW5nbGUiLCJNYXRoIiwiUEkiLCJpIiwiY2VsbCIsImdldCIsImNlbGxOb2RlIiwiY29sb3JPdmVycmlkZSIsInRyYW5zbGF0aW9uIiwiZ2V0Q29udGFpbmVyT2Zmc2V0IiwiYWRkQ2VsbE5vZGUiLCJlZGdlUG9zaXRpb24iLCJjcmVhdGVQb2xhciIsIm1vdmVUb1BvaW50IiwibGluZVRvUG9pbnQiLCJub3JtYWxpemVkIiwidGltZXNTY2FsYXIiLCJzZXRTaGFwZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQ2lyY3VsYXJDb250YWluZXJOb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIENvbnRhaW5lciBmb3IgdGhlIGNpcmN1bGFyIHJlcHJlc2VudGF0aW9uXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cclxuICovXHJcblxyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IHsgQ2lyY2xlLCBQYXRoIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IEZyYWN0aW9uc0NvbW1vbkNvbnN0YW50cyBmcm9tICcuLi8uLi8uLi9jb21tb24vRnJhY3Rpb25zQ29tbW9uQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IEZyYWN0aW9uc0NvbW1vbkNvbG9ycyBmcm9tICcuLi8uLi8uLi9jb21tb24vdmlldy9GcmFjdGlvbnNDb21tb25Db2xvcnMuanMnO1xyXG5pbXBvcnQgZnJhY3Rpb25zQ29tbW9uIGZyb20gJy4uLy4uLy4uL2ZyYWN0aW9uc0NvbW1vbi5qcyc7XHJcbmltcG9ydCBDZWxsQ29udGFpbmVyTm9kZSBmcm9tICcuLi9DZWxsQ29udGFpbmVyTm9kZS5qcyc7XHJcbmltcG9ydCBDaXJjdWxhck5vZGUgZnJvbSAnLi9DaXJjdWxhck5vZGUuanMnO1xyXG5cclxuY2xhc3MgQ2lyY3VsYXJDb250YWluZXJOb2RlIGV4dGVuZHMgQ2VsbENvbnRhaW5lck5vZGUge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Q29udGFpbmVyfSBjb250YWluZXJcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGNvbnRhaW5lciwgb3B0aW9ucyApIHtcclxuICAgIHN1cGVyKCBjb250YWluZXIsIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBAcHVibGljXHJcbiAgICB0aGlzLmNpcmNsZVJhZGl1cyA9IENpcmN1bGFyTm9kZS5SQURJVVM7XHJcblxyXG4gICAgLy8gRXh0ZW5kIGJ5IDAuNSBzbyB0aGF0IG91ciBjZWxsIGZpbGxzIGRvbid0IG92ZXJsYXAgb3VyIGJvcmRlclxyXG4gICAgdGhpcy5hZGRDaGlsZCggbmV3IENpcmNsZSggdGhpcy5jaXJjbGVSYWRpdXMgKyAwLjUsIHtcclxuICAgICAgbGluZVdpZHRoOiBGcmFjdGlvbnNDb21tb25Db25zdGFudHMuSU5UUk9fQ09OVEFJTkVSX0xJTkVfV0lEVEgsXHJcbiAgICAgIGZpbGw6IEZyYWN0aW9uc0NvbW1vbkNvbG9ycy5pbnRyb0NvbnRhaW5lckJhY2tncm91bmRQcm9wZXJ0eSxcclxuICAgICAgc3Ryb2tlOiB0aGlzLnN0cm9rZVByb3BlcnR5XHJcbiAgICB9ICkgKTtcclxuXHJcbiAgICAvLyBVc2UgY3VycmVudCBib3VuZHMgYXMgcGVybWFuZW50IGJvdW5kc1xyXG4gICAgdGhpcy5sb2NhbEJvdW5kcyA9IHRoaXMubG9jYWxCb3VuZHM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1hc3NpZ25cclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7UGF0aH0gY3JlYXRlcyB0aGUgcGF0aCBmb3IgdGhlIGRpdmlkaW5nIGxpbmVzIGJldHdlZW4gY2VsbHNcclxuICAgIHRoaXMuY2VsbERpdmlkZXJzUGF0aCA9IG5ldyBQYXRoKCBudWxsLCB7IHN0cm9rZTogdGhpcy5zdHJva2VQcm9wZXJ0eSB9ICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCB0aGlzLmNlbGxEaXZpZGVyc1BhdGggKTtcclxuXHJcbiAgICB0aGlzLnJlYnVpbGQoKTtcclxuICAgIHRoaXMubXV0YXRlKCBvcHRpb25zICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWJ1aWxkcyB0aGUgZnVsbCBjb250YWluZXIgKHJlcXVpcmVkIHdoZW4gdGhlIG51bWJlciBvZiBjZWxscyBjaGFuZ2VzKS5cclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXHJcbiAgcmVidWlsZCgpIHtcclxuICAgIHN1cGVyLnJlYnVpbGQoKTtcclxuXHJcbiAgICBjb25zdCBjZWxsRGl2aWRlcnNTaGFwZSA9IG5ldyBTaGFwZSgpO1xyXG5cclxuICAgIGNvbnN0IGRlbm9taW5hdG9yID0gdGhpcy5jb250YWluZXIuY2VsbHMubGVuZ3RoO1xyXG5cclxuICAgIC8vIGRpc3JlZ2FyZCBzZWdtZW50IGZvciBkZW5vbWluYXRvciBlcXVhbCB0byAxXHJcbiAgICBjb25zdCBjZWxsRGl2aWRlcnNMZW5ndGggPSAoIGRlbm9taW5hdG9yID4gMSApID8gdGhpcy5jaXJjbGVSYWRpdXMgOiAwO1xyXG5cclxuICAgIC8vIGNyZWF0ZXMgYW4gYW5nbGUgYmV0d2VlbiB0aGUgY2VsbHMgb2YgYSBjaXJjbGUgbm9kZSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBkZW5vbWluYXRvciB2YWx1ZVxyXG4gICAgY29uc3QgY2VsbERpdmlkZXJzQW5nbGUgPSAyICogTWF0aC5QSSAvIGRlbm9taW5hdG9yO1xyXG5cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGRlbm9taW5hdG9yOyBpKysgKSB7XHJcbiAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmNvbnRhaW5lci5jZWxscy5nZXQoIGkgKTtcclxuXHJcbiAgICAgIGNvbnN0IGNlbGxOb2RlID0gbmV3IENpcmN1bGFyTm9kZSggZGVub21pbmF0b3IsIGksIHtcclxuICAgICAgICBjb2xvck92ZXJyaWRlOiB0aGlzLmNvbG9yT3ZlcnJpZGVcclxuICAgICAgfSApO1xyXG4gICAgICBjZWxsTm9kZS50cmFuc2xhdGlvbiA9IGNlbGxOb2RlLmdldENvbnRhaW5lck9mZnNldCgpO1xyXG5cclxuICAgICAgdGhpcy5hZGRDZWxsTm9kZSggY2VsbCwgY2VsbE5vZGUgKTtcclxuXHJcbiAgICAgIC8vIHBvc2l0aW9ucyBhbmQgZHJhd3MgdGhlIHBvbGFyIGNvb3JkaW5hdGUgb2YgdGhlIGRpdmlkaW5nIGxpbmUgYmV0d2VlbiBjZWxsc1xyXG4gICAgICBjb25zdCBlZGdlUG9zaXRpb24gPSBWZWN0b3IyLmNyZWF0ZVBvbGFyKCBjZWxsRGl2aWRlcnNMZW5ndGgsIGkgKiBjZWxsRGl2aWRlcnNBbmdsZSApO1xyXG4gICAgICBpZiAoIGNlbGxEaXZpZGVyc0xlbmd0aCApIHtcclxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc2NlbmVyeS9pc3N1ZXMvNzUwXHJcbiAgICAgICAgY2VsbERpdmlkZXJzU2hhcGUubW92ZVRvUG9pbnQoIGVkZ2VQb3NpdGlvbiApLmxpbmVUb1BvaW50KCBlZGdlUG9zaXRpb24ubm9ybWFsaXplZCgpLnRpbWVzU2NhbGFyKCAwLjAxICkgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5jZWxsRGl2aWRlcnNQYXRoLnNldFNoYXBlKCBjZWxsRGl2aWRlcnNTaGFwZSApO1xyXG4gIH1cclxufVxyXG5cclxuZnJhY3Rpb25zQ29tbW9uLnJlZ2lzdGVyKCAnQ2lyY3VsYXJDb250YWluZXJOb2RlJywgQ2lyY3VsYXJDb250YWluZXJOb2RlICk7XHJcbmV4cG9ydCBkZWZhdWx0IENpcmN1bGFyQ29udGFpbmVyTm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFNLGtDQUFrQztBQUN0RCxTQUFTQyxLQUFLLFFBQVEsbUNBQW1DO0FBQ3pELFNBQVNDLE1BQU0sRUFBRUMsSUFBSSxRQUFRLHNDQUFzQztBQUNuRSxPQUFPQyx3QkFBd0IsTUFBTSw2Q0FBNkM7QUFDbEYsT0FBT0MscUJBQXFCLE1BQU0sK0NBQStDO0FBQ2pGLE9BQU9DLGVBQWUsTUFBTSw2QkFBNkI7QUFDekQsT0FBT0MsaUJBQWlCLE1BQU0seUJBQXlCO0FBQ3ZELE9BQU9DLFlBQVksTUFBTSxtQkFBbUI7QUFFNUMsTUFBTUMscUJBQXFCLFNBQVNGLGlCQUFpQixDQUFDO0VBQ3BEO0FBQ0Y7QUFDQTtBQUNBO0VBQ0VHLFdBQVdBLENBQUVDLFNBQVMs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