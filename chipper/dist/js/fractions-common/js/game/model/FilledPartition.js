// Copyright 2018-2021, University of Colorado Boulder

/**
 * Represents a ShapePartition with each shape marked as filled or unfilled (all with a particular color).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import dotRandom from '../../../../dot/js/dotRandom.js';
import Fraction from '../../../../phetcommon/js/model/Fraction.js';
import fractionsCommon from '../../fractionsCommon.js';
import FillType from './FillType.js';
import ShapePartition from './ShapePartition.js';
class FilledPartition {
  /**
   * @param {ShapePartition} shapePartition
   * @param {Array.<boolean>} fills
   * @param {ColorDef} color
   */
  constructor(shapePartition, fills, color) {
    assert && assert(shapePartition instanceof ShapePartition);
    assert && assert(Array.isArray(fills));
    assert && assert(fills.length === shapePartition.length);
    assert && fills.forEach(fill => assert(typeof fill === 'boolean'));

    // @public {ShapePartition}
    this.shapePartition = shapePartition;

    // @public {Array.<boolean>} - Index corresponds to the shapes in shapePartition
    this.fills = fills;

    // @public {ColorDef}
    this.color = color;

    // @public {Fraction} - The computed fraction for the value of this filled partition
    this.fraction = new Fraction(fills.filter(_.identity).length, fills.length).reduce();
  }

  /**
   * Returns a list of filled partitions, filled in the specified manner.
   * @public
   *
   * @param {ShapePartition} shapePartition
   * @param {Fraction} fraction
   * @param {ColorDef} color
   * @param {FillType} fillType
   * @returns {Array.<FilledPartition>}
   */
  static fill(shapePartition, fraction, color, fillType) {
    assert && assert(_.includes(FillType.VALUES, fillType));
    if (fillType === FillType.RANDOM) {
      return FilledPartition.randomFill(shapePartition, fraction, color);
    } else if (fillType === FillType.SEQUENTIAL) {
      return FilledPartition.sequentialFill(shapePartition, fraction, color);
    } else {
      let result = [];
      while (!fraction.isLessThan(Fraction.ONE)) {
        result = result.concat(FilledPartition.sequentialFill(shapePartition, Fraction.ONE, color));
        fraction = fraction.minus(Fraction.ONE);
      }
      return dotRandom.shuffle([...result, ...FilledPartition.randomFill(shapePartition, fraction, color)]);
    }
  }

  /**
   * Returns a list of filled partitions, filled sequentially from the start.
   * @public
   *
   * @param {ShapePartition} shapePartition
   * @param {Fraction} fraction
   * @param {ColorDef} color
   * @returns {Array.<FilledPartition>}
   */
  static sequentialFill(shapePartition, fraction, color) {
    const result = [];
    while (Fraction.ZERO.isLessThan(fraction)) {
      result.push(new FilledPartition(shapePartition, shapePartition.shapes.map((_, index) => {
        return index < fraction.numerator * (shapePartition.length / fraction.denominator);
      }), color));
      fraction = fraction.minus(Fraction.ONE);
    }
    return result;
  }

  /**
   * Returns a list of filled partitions, filled randomly.
   * @public
   *
   * @param {ShapePartition} shapePartition
   * @param {Fraction} fraction
   * @param {ColorDef} color
   * @returns {Array.<FilledPartition>}
   */
  static randomFill(shapePartition, fraction, color) {
    const numSlicesPerPartition = shapePartition.length;
    const numFilledSlices = fraction.numerator * (numSlicesPerPartition / fraction.denominator);
    const numPartitions = Math.ceil(fraction.value);
    const numTotalSlices = numPartitions * numSlicesPerPartition;
    const fills = dotRandom.shuffle([..._.times(numFilledSlices, () => true), ..._.times(numTotalSlices - numFilledSlices, () => false)]);
    return _.range(0, numPartitions).map(i => {
      return new FilledPartition(shapePartition, fills.slice(i * numSlicesPerPartition, (i + 1) * numSlicesPerPartition), color);
    });
  }
}
fractionsCommon.register('FilledPartition', FilledPartition);
export default FilledPartition;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3RSYW5kb20iLCJGcmFjdGlvbiIsImZyYWN0aW9uc0NvbW1vbiIsIkZpbGxUeXBlIiwiU2hhcGVQYXJ0aXRpb24iLCJGaWxsZWRQYXJ0aXRpb24iLCJjb25zdHJ1Y3RvciIsInNoYXBlUGFydGl0aW9uIiwiZmlsbHMiLCJjb2xvciIsImFzc2VydCIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImZvckVhY2giLCJmaWxsIiwiZnJhY3Rpb24iLCJmaWx0ZXIiLCJfIiwiaWRlbnRpdHkiLCJyZWR1Y2UiLCJmaWxsVHlwZSIsImluY2x1ZGVzIiwiVkFMVUVTIiwiUkFORE9NIiwicmFuZG9tRmlsbCIsIlNFUVVFTlRJQUwiLCJzZXF1ZW50aWFsRmlsbCIsInJlc3VsdCIsImlzTGVzc1RoYW4iLCJPTkUiLCJjb25jYXQiLCJtaW51cyIsInNodWZmbGUiLCJaRVJPIiwicHVzaCIsInNoYXBlcyIsIm1hcCIsImluZGV4IiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJudW1TbGljZXNQZXJQYXJ0aXRpb24iLCJudW1GaWxsZWRTbGljZXMiLCJudW1QYXJ0aXRpb25zIiwiTWF0aCIsImNlaWwiLCJ2YWx1ZSIsIm51bVRvdGFsU2xpY2VzIiwidGltZXMiLCJyYW5nZSIsImkiLCJzbGljZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRmlsbGVkUGFydGl0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4LTIwMjEsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBTaGFwZVBhcnRpdGlvbiB3aXRoIGVhY2ggc2hhcGUgbWFya2VkIGFzIGZpbGxlZCBvciB1bmZpbGxlZCAoYWxsIHdpdGggYSBwYXJ0aWN1bGFyIGNvbG9yKS5cclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBkb3RSYW5kb20gZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL2RvdFJhbmRvbS5qcyc7XHJcbmltcG9ydCBGcmFjdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9waGV0Y29tbW9uL2pzL21vZGVsL0ZyYWN0aW9uLmpzJztcclxuaW1wb3J0IGZyYWN0aW9uc0NvbW1vbiBmcm9tICcuLi8uLi9mcmFjdGlvbnNDb21tb24uanMnO1xyXG5pbXBvcnQgRmlsbFR5cGUgZnJvbSAnLi9GaWxsVHlwZS5qcyc7XHJcbmltcG9ydCBTaGFwZVBhcnRpdGlvbiBmcm9tICcuL1NoYXBlUGFydGl0aW9uLmpzJztcclxuXHJcbmNsYXNzIEZpbGxlZFBhcnRpdGlvbiB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTaGFwZVBhcnRpdGlvbn0gc2hhcGVQYXJ0aXRpb25cclxuICAgKiBAcGFyYW0ge0FycmF5Ljxib29sZWFuPn0gZmlsbHNcclxuICAgKiBAcGFyYW0ge0NvbG9yRGVmfSBjb2xvclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBzaGFwZVBhcnRpdGlvbiwgZmlsbHMsIGNvbG9yICkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggc2hhcGVQYXJ0aXRpb24gaW5zdGFuY2VvZiBTaGFwZVBhcnRpdGlvbiApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggQXJyYXkuaXNBcnJheSggZmlsbHMgKSApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZmlsbHMubGVuZ3RoID09PSBzaGFwZVBhcnRpdGlvbi5sZW5ndGggKTtcclxuICAgIGFzc2VydCAmJiBmaWxscy5mb3JFYWNoKCBmaWxsID0+IGFzc2VydCggdHlwZW9mIGZpbGwgPT09ICdib29sZWFuJyApICk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyB7U2hhcGVQYXJ0aXRpb259XHJcbiAgICB0aGlzLnNoYXBlUGFydGl0aW9uID0gc2hhcGVQYXJ0aXRpb247XHJcblxyXG4gICAgLy8gQHB1YmxpYyB7QXJyYXkuPGJvb2xlYW4+fSAtIEluZGV4IGNvcnJlc3BvbmRzIHRvIHRoZSBzaGFwZXMgaW4gc2hhcGVQYXJ0aXRpb25cclxuICAgIHRoaXMuZmlsbHMgPSBmaWxscztcclxuXHJcbiAgICAvLyBAcHVibGljIHtDb2xvckRlZn1cclxuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuXHJcbiAgICAvLyBAcHVibGljIHtGcmFjdGlvbn0gLSBUaGUgY29tcHV0ZWQgZnJhY3Rpb24gZm9yIHRoZSB2YWx1ZSBvZiB0aGlzIGZpbGxlZCBwYXJ0aXRpb25cclxuICAgIHRoaXMuZnJhY3Rpb24gPSBuZXcgRnJhY3Rpb24oIGZpbGxzLmZpbHRlciggXy5pZGVudGl0eSApLmxlbmd0aCwgZmlsbHMubGVuZ3RoICkucmVkdWNlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxsZWQgcGFydGl0aW9ucywgZmlsbGVkIGluIHRoZSBzcGVjaWZpZWQgbWFubmVyLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2hhcGVQYXJ0aXRpb259IHNoYXBlUGFydGl0aW9uXHJcbiAgICogQHBhcmFtIHtGcmFjdGlvbn0gZnJhY3Rpb25cclxuICAgKiBAcGFyYW0ge0NvbG9yRGVmfSBjb2xvclxyXG4gICAqIEBwYXJhbSB7RmlsbFR5cGV9IGZpbGxUeXBlXHJcbiAgICogQHJldHVybnMge0FycmF5LjxGaWxsZWRQYXJ0aXRpb24+fVxyXG4gICAqL1xyXG4gIHN0YXRpYyBmaWxsKCBzaGFwZVBhcnRpdGlvbiwgZnJhY3Rpb24sIGNvbG9yLCBmaWxsVHlwZSApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIF8uaW5jbHVkZXMoIEZpbGxUeXBlLlZBTFVFUywgZmlsbFR5cGUgKSApO1xyXG5cclxuICAgIGlmICggZmlsbFR5cGUgPT09IEZpbGxUeXBlLlJBTkRPTSApIHtcclxuICAgICAgcmV0dXJuIEZpbGxlZFBhcnRpdGlvbi5yYW5kb21GaWxsKCBzaGFwZVBhcnRpdGlvbiwgZnJhY3Rpb24sIGNvbG9yICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggZmlsbFR5cGUgPT09IEZpbGxUeXBlLlNFUVVFTlRJQUwgKSB7XHJcbiAgICAgIHJldHVybiBGaWxsZWRQYXJ0aXRpb24uc2VxdWVudGlhbEZpbGwoIHNoYXBlUGFydGl0aW9uLCBmcmFjdGlvbiwgY29sb3IgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgIHdoaWxlICggIWZyYWN0aW9uLmlzTGVzc1RoYW4oIEZyYWN0aW9uLk9ORSApICkge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoIEZpbGxlZFBhcnRpdGlvbi5zZXF1ZW50aWFsRmlsbCggc2hhcGVQYXJ0aXRpb24sIEZyYWN0aW9uLk9ORSwgY29sb3IgKSApO1xyXG4gICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ubWludXMoIEZyYWN0aW9uLk9ORSApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBkb3RSYW5kb20uc2h1ZmZsZSggW1xyXG4gICAgICAgIC4uLnJlc3VsdCxcclxuICAgICAgICAuLi5GaWxsZWRQYXJ0aXRpb24ucmFuZG9tRmlsbCggc2hhcGVQYXJ0aXRpb24sIGZyYWN0aW9uLCBjb2xvciApXHJcbiAgICAgIF0gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIGZpbGxlZCBwYXJ0aXRpb25zLCBmaWxsZWQgc2VxdWVudGlhbGx5IGZyb20gdGhlIHN0YXJ0LlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2hhcGVQYXJ0aXRpb259IHNoYXBlUGFydGl0aW9uXHJcbiAgICogQHBhcmFtIHtGcmFjdGlvbn0gZnJhY3Rpb25cclxuICAgKiBAcGFyYW0ge0NvbG9yRGVmfSBjb2xvclxyXG4gICAqIEByZXR1cm5zIHtBcnJheS48RmlsbGVkUGFydGl0aW9uPn1cclxuICAgKi9cclxuICBzdGF0aWMgc2VxdWVudGlhbEZpbGwoIHNoYXBlUGFydGl0aW9uLCBmcmFjdGlvbiwgY29sb3IgKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuXHJcbiAgICB3aGlsZSAoIEZyYWN0aW9uLlpFUk8uaXNMZXNzVGhhbiggZnJhY3Rpb24gKSApIHtcclxuICAgICAgcmVzdWx0LnB1c2goIG5ldyBGaWxsZWRQYXJ0aXRpb24oIHNoYXBlUGFydGl0aW9uLCBzaGFwZVBhcnRpdGlvbi5zaGFwZXMubWFwKCAoIF8sIGluZGV4ICkgPT4ge1xyXG4gICAgICAgIHJldHVybiBpbmRleCA8IGZyYWN0aW9uLm51bWVyYXRvciAqICggc2hhcGVQYXJ0aXRpb24ubGVuZ3RoIC8gZnJhY3Rpb24uZGVub21pbmF0b3IgKTtcclxuICAgICAgfSApLCBjb2xvciApICk7XHJcbiAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ubWludXMoIEZyYWN0aW9uLk9ORSApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmaWxsZWQgcGFydGl0aW9ucywgZmlsbGVkIHJhbmRvbWx5LlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2hhcGVQYXJ0aXRpb259IHNoYXBlUGFydGl0aW9uXHJcbiAgICogQHBhcmFtIHtGcmFjdGlvbn0gZnJhY3Rpb25cclxuICAgKiBAcGFyYW0ge0NvbG9yRGVmfSBjb2xvclxyXG4gICAqIEByZXR1cm5zIHtBcnJheS48RmlsbGVkUGFydGl0aW9uPn1cclxuICAgKi9cclxuICBzdGF0aWMgcmFuZG9tRmlsbCggc2hhcGVQYXJ0aXRpb24sIGZyYWN0aW9uLCBjb2xvciApIHtcclxuICAgIGNvbnN0IG51bVNsaWNlc1BlclBhcnRpdGlvbiA9IHNoYXBlUGFydGl0aW9uLmxlbmd0aDtcclxuICAgIGNvbnN0IG51bUZpbGxlZFNsaWNlcyA9IGZyYWN0aW9uLm51bWVyYXRvciAqICggbnVtU2xpY2VzUGVyUGFydGl0aW9uIC8gZnJhY3Rpb24uZGVub21pbmF0b3IgKTtcclxuICAgIGNvbnN0IG51bVBhcnRpdGlvbnMgPSBNYXRoLmNlaWwoIGZyYWN0aW9uLnZhbHVlICk7XHJcbiAgICBjb25zdCBudW1Ub3RhbFNsaWNlcyA9IG51bVBhcnRpdGlvbnMgKiBudW1TbGljZXNQZXJQYXJ0aXRpb247XHJcbiAgICBjb25zdCBmaWxscyA9IGRvdFJhbmRvbS5zaHVmZmxlKCBbXHJcbiAgICAgIC4uLl8udGltZXMoIG51bUZpbGxlZFNsaWNlcywgKCkgPT4gdHJ1ZSApLFxyXG4gICAgICAuLi5fLnRpbWVzKCBudW1Ub3RhbFNsaWNlcyAtIG51bUZpbGxlZFNsaWNlcywgKCkgPT4gZmFsc2UgKVxyXG4gICAgXSApO1xyXG4gICAgcmV0dXJuIF8ucmFuZ2UoIDAsIG51bVBhcnRpdGlvbnMgKS5tYXAoIGkgPT4ge1xyXG4gICAgICByZXR1cm4gbmV3IEZpbGxlZFBhcnRpdGlvbiggc2hhcGVQYXJ0aXRpb24sIGZpbGxzLnNsaWNlKCBpICogbnVtU2xpY2VzUGVyUGFydGl0aW9uLCAoIGkgKyAxICkgKiBudW1TbGljZXNQZXJQYXJ0aXRpb24gKSwgY29sb3IgKTtcclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcbmZyYWN0aW9uc0NvbW1vbi5yZWdpc3RlciggJ0ZpbGxlZFBhcnRpdGlvbicsIEZpbGxlZFBhcnRpdGlvbiApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRmlsbGVkUGFydGl0aW9uOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxTQUFTLE1BQU0saUNBQWlDO0FBQ3ZELE9BQU9DLFFBQVEsTUFBTSw2Q0FBNkM7QUFDbEUsT0FBT0MsZUFBZSxNQUFNLDBCQUEwQjtBQUN0RCxPQUFPQyxRQUFRLE1BQU0sZUFBZTtBQUNwQyxPQUFPQyxjQUFjLE1BQU0scUJBQXFCO0FBRWhELE1BQU1DLGVBQWUsQ0FBQztFQUNwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VB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