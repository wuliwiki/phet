// Copyright 2018-2021, University of Colorado Boulder

/**
 * Sound generator used to produce a sound like that of a foot being dragged on a carpet.
 *
 * @author John Blanco
 */

import dotRandom from '../../../../dot/js/dotRandom.js';
import Utils from '../../../../dot/js/Utils.js';
import merge from '../../../../phet-core/js/merge.js';
import NoiseGenerator from '../../../../tambo/js/sound-generators/NoiseGenerator.js';
import johnTravoltage from '../../johnTravoltage.js';

// constants
const MAX_DRAG_SOUND_VOLUME = 2; // can be greater than 1 because filtering tends to reduce output a lot
const VELOCITY_REDUCTION_RATE = 50; // amount per second, empirically determined for best sound
const STILLNESS_TIME = 0.064; // in seconds, if there are no angle updates for this long, the leg is considered still
const NOISE_CENTER_FREQUENCY = 1300; // Hz
const DIRECTION_FREQUENCY_DELTA = NOISE_CENTER_FREQUENCY / 8; // max difference for forward vs backward motion of foot
const MAX_LEG_ANGULAR_VELOCITY = 3 * Math.PI; // in radians/sec, see explanatory note where this is used
const MIN_SOUND_GAP = 0.05; // in seconds
const NOISE_START_TIME_CONSTANT = 0.01;
const NOISE_STOP_TIME_CONSTANT = 0.02;
const NOISE_LEVEL_CHANGE_TIME_CONSTANT = 0.1;
const NOISE_OFF_TIME = 0.05; // in seconds

class FootDragSoundGenerator extends NoiseGenerator {
  /**
   * @constructor
   * {Property.<number>} legAngleProperty - angle of leg in radians
   * {Number} minContactAngle - min angle at which foot motion starts to make sound, in radians
   * {Number} maxContactAngle - max angle at which foot motion makes sound, in radians
   * {Object} [options]
   */
  constructor(legAngleProperty, minContactAngle, maxContactAngle, options) {
    options = merge({
      noiseType: 'brown',
      centerFrequency: NOISE_CENTER_FREQUENCY,
      qFactor: 2,
      initialOutputLevel: 0
    }, options);
    super(options);

    // @private - state variables for keeping track of what the foot is doing
    this.legAngleUpdateTime = null;
    this.legAngularVelocity = 0;
    this.soundStartCountdown = 0;
    this.motionState = 'still'; // valid values are 'still', 'forward', and 'backward'
    let legAngle = null;

    // monitor the leg angle and adjust the noise output accordingly
    legAngleProperty.link(newLegAngle => {
      const now = this.audioContext.currentTime;

      // determine whether the foot is on the carpet
      const footOnCarpet = newLegAngle > minContactAngle && newLegAngle < maxContactAngle;

      // update the angular velocity of the leg and determine the motion state
      let newMotionState = 'still';
      if (newLegAngle === legAngleProperty.initialValue && !this.fullyEnabledProperty.value) {
        // this case indicates that a reset caused the leg motion, so set the leg velocity to zero
        this.legAngularVelocity = 0;
      } else if (this.legAngleUpdateTime !== null) {
        // set the angular velocity of the leg, but keep it limited to the max allowed value
        this.legAngularVelocity = Utils.clamp((newLegAngle - legAngle) / (now - this.legAngleUpdateTime), -MAX_LEG_ANGULAR_VELOCITY, MAX_LEG_ANGULAR_VELOCITY);

        // update the motion state
        newMotionState = this.legAngularVelocity > 0 ? 'backward' : 'forward';
      }

      // update the state of sound generation (on or off)
      if (footOnCarpet && newMotionState !== 'still') {
        if (newMotionState !== this.motionState && this.motionState !== 'still') {
          // the leg switched directions without stopping in between, so set a countdown that will create a sound gap
          this.setOutputLevel(0, NOISE_STOP_TIME_CONSTANT);
          this.soundStartCountdown = MIN_SOUND_GAP;
        } else {
          // figure

          // the foot is dragging on the carpet, make sure sound is playing
          if (!this.isPlaying) {
            this.start();
            this.setOutputLevel(mapVelocityToOutputLevel(this.legAngularVelocity), NOISE_START_TIME_CONSTANT);
          } else {
            this.setOutputLevel(mapVelocityToOutputLevel(this.legAngularVelocity), NOISE_LEVEL_CHANGE_TIME_CONSTANT);
          }

          // set the frequency of the drag sound
          this.setBandpassFilterCenterFrequency(mapVelocityToFilterFrequency(this.legAngularVelocity, newMotionState));
        }
      } else {
        if (this.isPlaying) {
          this.stop(now + NOISE_OFF_TIME);
        }
      }

      // set the filter value that controls whether the forward or backward dragging sound is heard
      if (this.motionState !== newMotionState) {
        // set the frequency based on the direction
        let frequencyDelta = newMotionState === 'forward' ? DIRECTION_FREQUENCY_DELTA : -DIRECTION_FREQUENCY_DELTA;

        // add some randomization to the frequency delta so that back-and-forth motion sounds less repetitive
        frequencyDelta = frequencyDelta * (1 - dotRandom.nextDouble() / 2);

        // set the filter value that controls whether the forward or backward dragging sound is heard
        this.setBandpassFilterCenterFrequency(NOISE_CENTER_FREQUENCY + frequencyDelta, 0.01);
      }

      // update state variable for the timer to use and for next time through this method
      legAngle = newLegAngle;
      this.legAngleUpdateTime = now;
      this.motionState = newMotionState;
    });
  }

  /**
   * step function that mostly detects when the leg stops moving and helps create the silence intervals when the foot
   * drag changes direction
   * @param {number} dt - amount of time step, in seconds
   * @public
   */
  step(dt) {
    // check if the countdown used to keep sounds from running together is going
    if (this.soundStartCountdown > 0) {
      this.soundStartCountdown = Math.max(this.soundStartCountdown - dt, 0);
      if (this.soundStartCountdown === 0 && this.motionState !== 'still') {
        this.setOutputLevel(mapVelocityToOutputLevel(this.legAngularVelocity), NOISE_START_TIME_CONSTANT);
      }
    } else if (this.audioContext.currentTime - this.legAngleUpdateTime > STILLNESS_TIME && Math.abs(this.legAngularVelocity) > 0) {
      // The leg angle hasn't changed for a bit, so start to reduce the angular velocity, but don't do it all at once
      // since that isn't realistic and tends to cause gaps in the sound.
      const angularVelocityChange = (this.legAngularVelocity > 0 ? -1 : 1) * Math.min(dt * VELOCITY_REDUCTION_RATE, Math.abs(this.legAngularVelocity));
      this.legAngularVelocity = this.legAngularVelocity + angularVelocityChange;
      if (this.legAngularVelocity === 0) {
        this.motionState = 'still';
        this.stop(this.audioContext.currentTime + NOISE_OFF_TIME);
        this.setOutputLevel(0, NOISE_STOP_TIME_CONSTANT);
      } else {
        this.setOutputLevel(mapVelocityToOutputLevel(this.legAngularVelocity), NOISE_START_TIME_CONSTANT);
      }
    }
  }
}

// helper function to convert the angular velocity of the leg to an output level for the noise generator
function mapVelocityToOutputLevel(angularVelocityOfLeg) {
  const multiplier = Math.min(Math.pow(Math.abs(angularVelocityOfLeg) / MAX_LEG_ANGULAR_VELOCITY, 0.7), 1);
  return MAX_DRAG_SOUND_VOLUME * multiplier;
}

// helper function to convert the angular velocity of the leg to a center frequency values for the noise filter
function mapVelocityToFilterFrequency(angularVelocityOfLeg, direction) {
  let minFrequency;
  if (direction === 'forward') {
    minFrequency = NOISE_CENTER_FREQUENCY - DIRECTION_FREQUENCY_DELTA;
  } else {
    minFrequency = NOISE_CENTER_FREQUENCY + DIRECTION_FREQUENCY_DELTA;
  }
  const multiplier = Math.abs(angularVelocityOfLeg) / MAX_LEG_ANGULAR_VELOCITY;
  return minFrequency + 500 * multiplier;
}
johnTravoltage.register('FootDragSoundGenerator', FootDragSoundGenerator);
export default FootDragSoundGenerator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3RSYW5kb20iLCJVdGlscyIsIm1lcmdlIiwiTm9pc2VHZW5lcmF0b3IiLCJqb2huVHJhdm9sdGFnZSIsIk1BWF9EUkFHX1NPVU5EX1ZPTFVNRSIsIlZFTE9DSVRZX1JFRFVDVElPTl9SQVRFIiwiU1RJTExORVNTX1RJTUUiLCJOT0lTRV9DRU5URVJfRlJFUVVFTkNZIiwiRElSRUNUSU9OX0ZSRVFVRU5DWV9ERUxUQSIsIk1BWF9MRUdfQU5HVUxBUl9WRUxPQ0lUWSIsIk1hdGgiLCJQSSIsIk1JTl9TT1VORF9HQVAiLCJOT0lTRV9TVEFSVF9USU1FX0NPTlNUQU5UIiwiTk9JU0VfU1RPUF9USU1FX0NPTlNUQU5UIiwiTk9JU0VfTEVWRUxfQ0hBTkdFX1RJTUVfQ09OU1RBTlQiLCJOT0lTRV9PRkZfVElNRSIsIkZvb3REcmFnU291bmRHZW5lcmF0b3IiLCJjb25zdHJ1Y3RvciIsImxlZ0FuZ2xlUHJvcGVydHkiLCJtaW5Db250YWN0QW5nbGUiLCJtYXhDb250YWN0QW5nbGUiLCJvcHRpb25zIiwibm9pc2VUeXBlIiwiY2VudGVyRnJlcXVlbmN5IiwicUZhY3RvciIsImluaXRpYWxPdXRwdXRMZXZlbCIsImxlZ0FuZ2xlVXBkYXRlVGltZSIsImxlZ0FuZ3VsYXJWZWxvY2l0eSIsInNvdW5kU3RhcnRDb3VudGRvd24iLCJtb3Rpb25TdGF0ZSIsImxlZ0FuZ2xlIiwibGluayIsIm5ld0xlZ0FuZ2xlIiwibm93IiwiYXVkaW9Db250ZXh0IiwiY3VycmVudFRpbWUiLCJmb290T25DYXJwZXQiLCJuZXdNb3Rpb25TdGF0ZSIsImluaXRpYWxWYWx1ZSIsImZ1bGx5RW5hYmxlZFByb3BlcnR5IiwidmFsdWUiLCJjbGFtcCIsInNldE91dHB1dExldmVsIiwiaXNQbGF5aW5nIiwic3RhcnQiLCJtYXBWZWxvY2l0eVRvT3V0cHV0TGV2ZWwiLCJzZXRCYW5kcGFzc0ZpbHRlckNlbnRlckZyZXF1ZW5jeSIsIm1hcFZlbG9jaXR5VG9GaWx0ZXJGcmVxdWVuY3kiLCJzdG9wIiwiZnJlcXVlbmN5RGVsdGEiLCJuZXh0RG91YmxlIiwic3RlcCIsImR0IiwibWF4IiwiYWJzIiwiYW5ndWxhclZlbG9jaXR5Q2hhbmdlIiwibWluIiwiYW5ndWxhclZlbG9jaXR5T2ZMZWciLCJtdWx0aXBsaWVyIiwicG93IiwiZGlyZWN0aW9uIiwibWluRnJlcXVlbmN5IiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJGb290RHJhZ1NvdW5kR2VuZXJhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4LTIwMjEsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFNvdW5kIGdlbmVyYXRvciB1c2VkIHRvIHByb2R1Y2UgYSBzb3VuZCBsaWtlIHRoYXQgb2YgYSBmb290IGJlaW5nIGRyYWdnZWQgb24gYSBjYXJwZXQuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICovXHJcblxyXG5pbXBvcnQgZG90UmFuZG9tIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9kb3RSYW5kb20uanMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCBOb2lzZUdlbmVyYXRvciBmcm9tICcuLi8uLi8uLi8uLi90YW1iby9qcy9zb3VuZC1nZW5lcmF0b3JzL05vaXNlR2VuZXJhdG9yLmpzJztcclxuaW1wb3J0IGpvaG5UcmF2b2x0YWdlIGZyb20gJy4uLy4uL2pvaG5UcmF2b2x0YWdlLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBNQVhfRFJBR19TT1VORF9WT0xVTUUgPSAyOyAvLyBjYW4gYmUgZ3JlYXRlciB0aGFuIDEgYmVjYXVzZSBmaWx0ZXJpbmcgdGVuZHMgdG8gcmVkdWNlIG91dHB1dCBhIGxvdFxyXG5jb25zdCBWRUxPQ0lUWV9SRURVQ1RJT05fUkFURSA9IDUwOyAvLyBhbW91bnQgcGVyIHNlY29uZCwgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZCBmb3IgYmVzdCBzb3VuZFxyXG5jb25zdCBTVElMTE5FU1NfVElNRSA9IDAuMDY0OyAvLyBpbiBzZWNvbmRzLCBpZiB0aGVyZSBhcmUgbm8gYW5nbGUgdXBkYXRlcyBmb3IgdGhpcyBsb25nLCB0aGUgbGVnIGlzIGNvbnNpZGVyZWQgc3RpbGxcclxuY29uc3QgTk9JU0VfQ0VOVEVSX0ZSRVFVRU5DWSA9IDEzMDA7IC8vIEh6XHJcbmNvbnN0IERJUkVDVElPTl9GUkVRVUVOQ1lfREVMVEEgPSBOT0lTRV9DRU5URVJfRlJFUVVFTkNZIC8gODsgLy8gbWF4IGRpZmZlcmVuY2UgZm9yIGZvcndhcmQgdnMgYmFja3dhcmQgbW90aW9uIG9mIGZvb3RcclxuY29uc3QgTUFYX0xFR19BTkdVTEFSX1ZFTE9DSVRZID0gMyAqIE1hdGguUEk7IC8vIGluIHJhZGlhbnMvc2VjLCBzZWUgZXhwbGFuYXRvcnkgbm90ZSB3aGVyZSB0aGlzIGlzIHVzZWRcclxuY29uc3QgTUlOX1NPVU5EX0dBUCA9IDAuMDU7IC8vIGluIHNlY29uZHNcclxuY29uc3QgTk9JU0VfU1RBUlRfVElNRV9DT05TVEFOVCA9IDAuMDE7XHJcbmNvbnN0IE5PSVNFX1NUT1BfVElNRV9DT05TVEFOVCA9IDAuMDI7XHJcbmNvbnN0IE5PSVNFX0xFVkVMX0NIQU5HRV9USU1FX0NPTlNUQU5UID0gMC4xO1xyXG5jb25zdCBOT0lTRV9PRkZfVElNRSA9IDAuMDU7IC8vIGluIHNlY29uZHNcclxuXHJcbmNsYXNzIEZvb3REcmFnU291bmRHZW5lcmF0b3IgZXh0ZW5kcyBOb2lzZUdlbmVyYXRvciB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIHtQcm9wZXJ0eS48bnVtYmVyPn0gbGVnQW5nbGVQcm9wZXJ0eSAtIGFuZ2xlIG9mIGxlZyBpbiByYWRpYW5zXHJcbiAgICoge051bWJlcn0gbWluQ29udGFjdEFuZ2xlIC0gbWluIGFuZ2xlIGF0IHdoaWNoIGZvb3QgbW90aW9uIHN0YXJ0cyB0byBtYWtlIHNvdW5kLCBpbiByYWRpYW5zXHJcbiAgICoge051bWJlcn0gbWF4Q29udGFjdEFuZ2xlIC0gbWF4IGFuZ2xlIGF0IHdoaWNoIGZvb3QgbW90aW9uIG1ha2VzIHNvdW5kLCBpbiByYWRpYW5zXHJcbiAgICoge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGxlZ0FuZ2xlUHJvcGVydHksIG1pbkNvbnRhY3RBbmdsZSwgbWF4Q29udGFjdEFuZ2xlLCBvcHRpb25zICkge1xyXG4gICAgb3B0aW9ucyA9IG1lcmdlKCB7XHJcbiAgICAgICAgbm9pc2VUeXBlOiAnYnJvd24nLFxyXG4gICAgICAgIGNlbnRlckZyZXF1ZW5jeTogTk9JU0VfQ0VOVEVSX0ZSRVFVRU5DWSxcclxuICAgICAgICBxRmFjdG9yOiAyLFxyXG4gICAgICAgIGluaXRpYWxPdXRwdXRMZXZlbDogMFxyXG4gICAgICB9LFxyXG4gICAgICBvcHRpb25zXHJcbiAgICApO1xyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gQHByaXZhdGUgLSBzdGF0ZSB2YXJpYWJsZXMgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCB0aGUgZm9vdCBpcyBkb2luZ1xyXG4gICAgdGhpcy5sZWdBbmdsZVVwZGF0ZVRpbWUgPSBudWxsO1xyXG4gICAgdGhpcy5sZWdBbmd1bGFyVmVsb2NpdHkgPSAwO1xyXG4gICAgdGhpcy5zb3VuZFN0YXJ0Q291bnRkb3duID0gMDtcclxuICAgIHRoaXMubW90aW9uU3RhdGUgPSAnc3RpbGwnOyAvLyB2YWxpZCB2YWx1ZXMgYXJlICdzdGlsbCcsICdmb3J3YXJkJywgYW5kICdiYWNrd2FyZCdcclxuICAgIGxldCBsZWdBbmdsZSA9IG51bGw7XHJcblxyXG4gICAgLy8gbW9uaXRvciB0aGUgbGVnIGFuZ2xlIGFuZCBhZGp1c3QgdGhlIG5vaXNlIG91dHB1dCBhY2NvcmRpbmdseVxyXG4gICAgbGVnQW5nbGVQcm9wZXJ0eS5saW5rKCBuZXdMZWdBbmdsZSA9PiB7XHJcbiAgICAgIGNvbnN0IG5vdyA9IHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xyXG5cclxuICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGZvb3QgaXMgb24gdGhlIGNhcnBldFxyXG4gICAgICBjb25zdCBmb290T25DYXJwZXQgPSBuZXdMZWdBbmdsZSA+IG1pbkNvbnRhY3RBbmdsZSAmJiBuZXdMZWdBbmdsZSA8IG1heENvbnRhY3RBbmdsZTtcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSB0aGUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgbGVnIGFuZCBkZXRlcm1pbmUgdGhlIG1vdGlvbiBzdGF0ZVxyXG4gICAgICBsZXQgbmV3TW90aW9uU3RhdGUgPSAnc3RpbGwnO1xyXG4gICAgICBpZiAoIG5ld0xlZ0FuZ2xlID09PSBsZWdBbmdsZVByb3BlcnR5LmluaXRpYWxWYWx1ZSAmJiAhdGhpcy5mdWxseUVuYWJsZWRQcm9wZXJ0eS52YWx1ZSApIHtcclxuXHJcbiAgICAgICAgLy8gdGhpcyBjYXNlIGluZGljYXRlcyB0aGF0IGEgcmVzZXQgY2F1c2VkIHRoZSBsZWcgbW90aW9uLCBzbyBzZXQgdGhlIGxlZyB2ZWxvY2l0eSB0byB6ZXJvXHJcbiAgICAgICAgdGhpcy5sZWdBbmd1bGFyVmVsb2NpdHkgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCB0aGlzLmxlZ0FuZ2xlVXBkYXRlVGltZSAhPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgLy8gc2V0IHRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSBsZWcsIGJ1dCBrZWVwIGl0IGxpbWl0ZWQgdG8gdGhlIG1heCBhbGxvd2VkIHZhbHVlXHJcbiAgICAgICAgdGhpcy5sZWdBbmd1bGFyVmVsb2NpdHkgPSBVdGlscy5jbGFtcChcclxuICAgICAgICAgICggbmV3TGVnQW5nbGUgLSBsZWdBbmdsZSApIC8gKCBub3cgLSB0aGlzLmxlZ0FuZ2xlVXBkYXRlVGltZSApLFxyXG4gICAgICAgICAgLU1BWF9MRUdfQU5HVUxBUl9WRUxPQ0lUWSxcclxuICAgICAgICAgIE1BWF9MRUdfQU5HVUxBUl9WRUxPQ0lUWVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgbW90aW9uIHN0YXRlXHJcbiAgICAgICAgbmV3TW90aW9uU3RhdGUgPSB0aGlzLmxlZ0FuZ3VsYXJWZWxvY2l0eSA+IDAgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHNvdW5kIGdlbmVyYXRpb24gKG9uIG9yIG9mZilcclxuICAgICAgaWYgKCBmb290T25DYXJwZXQgJiYgbmV3TW90aW9uU3RhdGUgIT09ICdzdGlsbCcgKSB7XHJcblxyXG4gICAgICAgIGlmICggbmV3TW90aW9uU3RhdGUgIT09IHRoaXMubW90aW9uU3RhdGUgJiYgdGhpcy5tb3Rpb25TdGF0ZSAhPT0gJ3N0aWxsJyApIHtcclxuXHJcbiAgICAgICAgICAvLyB0aGUgbGVnIHN3aXRjaGVkIGRpcmVjdGlvbnMgd2l0aG91dCBzdG9wcGluZyBpbiBiZXR3ZWVuLCBzbyBzZXQgYSBjb3VudGRvd24gdGhhdCB3aWxsIGNyZWF0ZSBhIHNvdW5kIGdhcFxyXG4gICAgICAgICAgdGhpcy5zZXRPdXRwdXRMZXZlbCggMCwgTk9JU0VfU1RPUF9USU1FX0NPTlNUQU5UICk7XHJcbiAgICAgICAgICB0aGlzLnNvdW5kU3RhcnRDb3VudGRvd24gPSBNSU5fU09VTkRfR0FQO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBmaWd1cmVcclxuXHJcbiAgICAgICAgICAvLyB0aGUgZm9vdCBpcyBkcmFnZ2luZyBvbiB0aGUgY2FycGV0LCBtYWtlIHN1cmUgc291bmQgaXMgcGxheWluZ1xyXG4gICAgICAgICAgaWYgKCAhdGhpcy5pc1BsYXlpbmcgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXRMZXZlbCggbWFwVmVsb2NpdHlUb091dHB1dExldmVsKCB0aGlzLmxlZ0FuZ3VsYXJWZWxvY2l0eSApLCBOT0lTRV9TVEFSVF9USU1FX0NPTlNUQU5UICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXRMZXZlbCggbWFwVmVsb2NpdHlUb091dHB1dExldmVsKCB0aGlzLmxlZ0FuZ3VsYXJWZWxvY2l0eSApLCBOT0lTRV9MRVZFTF9DSEFOR0VfVElNRV9DT05TVEFOVCApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHNldCB0aGUgZnJlcXVlbmN5IG9mIHRoZSBkcmFnIHNvdW5kXHJcbiAgICAgICAgICB0aGlzLnNldEJhbmRwYXNzRmlsdGVyQ2VudGVyRnJlcXVlbmN5KCBtYXBWZWxvY2l0eVRvRmlsdGVyRnJlcXVlbmN5KCB0aGlzLmxlZ0FuZ3VsYXJWZWxvY2l0eSwgbmV3TW90aW9uU3RhdGUgKSApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBpZiAoIHRoaXMuaXNQbGF5aW5nICkge1xyXG4gICAgICAgICAgdGhpcy5zdG9wKCBub3cgKyBOT0lTRV9PRkZfVElNRSApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc2V0IHRoZSBmaWx0ZXIgdmFsdWUgdGhhdCBjb250cm9scyB3aGV0aGVyIHRoZSBmb3J3YXJkIG9yIGJhY2t3YXJkIGRyYWdnaW5nIHNvdW5kIGlzIGhlYXJkXHJcbiAgICAgIGlmICggdGhpcy5tb3Rpb25TdGF0ZSAhPT0gbmV3TW90aW9uU3RhdGUgKSB7XHJcblxyXG4gICAgICAgIC8vIHNldCB0aGUgZnJlcXVlbmN5IGJhc2VkIG9uIHRoZSBkaXJlY3Rpb25cclxuICAgICAgICBsZXQgZnJlcXVlbmN5RGVsdGEgPSBuZXdNb3Rpb25TdGF0ZSA9PT0gJ2ZvcndhcmQnID8gRElSRUNUSU9OX0ZSRVFVRU5DWV9ERUxUQSA6IC1ESVJFQ1RJT05fRlJFUVVFTkNZX0RFTFRBO1xyXG5cclxuICAgICAgICAvLyBhZGQgc29tZSByYW5kb21pemF0aW9uIHRvIHRoZSBmcmVxdWVuY3kgZGVsdGEgc28gdGhhdCBiYWNrLWFuZC1mb3J0aCBtb3Rpb24gc291bmRzIGxlc3MgcmVwZXRpdGl2ZVxyXG4gICAgICAgIGZyZXF1ZW5jeURlbHRhID0gZnJlcXVlbmN5RGVsdGEgKiAoIDEgLSBkb3RSYW5kb20ubmV4dERvdWJsZSgpIC8gMiApO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIGZpbHRlciB2YWx1ZSB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgdGhlIGZvcndhcmQgb3IgYmFja3dhcmQgZHJhZ2dpbmcgc291bmQgaXMgaGVhcmRcclxuICAgICAgICB0aGlzLnNldEJhbmRwYXNzRmlsdGVyQ2VudGVyRnJlcXVlbmN5KCBOT0lTRV9DRU5URVJfRlJFUVVFTkNZICsgZnJlcXVlbmN5RGVsdGEsIDAuMDEgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdXBkYXRlIHN0YXRlIHZhcmlhYmxlIGZvciB0aGUgdGltZXIgdG8gdXNlIGFuZCBmb3IgbmV4dCB0aW1lIHRocm91Z2ggdGhpcyBtZXRob2RcclxuICAgICAgbGVnQW5nbGUgPSBuZXdMZWdBbmdsZTtcclxuICAgICAgdGhpcy5sZWdBbmdsZVVwZGF0ZVRpbWUgPSBub3c7XHJcbiAgICAgIHRoaXMubW90aW9uU3RhdGUgPSBuZXdNb3Rpb25TdGF0ZTtcclxuICAgIH0gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHN0ZXAgZnVuY3Rpb24gdGhhdCBtb3N0bHkgZGV0ZWN0cyB3aGVuIHRoZSBsZWcgc3RvcHMgbW92aW5nIGFuZCBoZWxwcyBjcmVhdGUgdGhlIHNpbGVuY2UgaW50ZXJ2YWxzIHdoZW4gdGhlIGZvb3RcclxuICAgKiBkcmFnIGNoYW5nZXMgZGlyZWN0aW9uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR0IC0gYW1vdW50IG9mIHRpbWUgc3RlcCwgaW4gc2Vjb25kc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzdGVwKCBkdCApIHtcclxuXHJcbiAgICAvLyBjaGVjayBpZiB0aGUgY291bnRkb3duIHVzZWQgdG8ga2VlcCBzb3VuZHMgZnJvbSBydW5uaW5nIHRvZ2V0aGVyIGlzIGdvaW5nXHJcbiAgICBpZiAoIHRoaXMuc291bmRTdGFydENvdW50ZG93biA+IDAgKSB7XHJcbiAgICAgIHRoaXMuc291bmRTdGFydENvdW50ZG93biA9IE1hdGgubWF4KCB0aGlzLnNvdW5kU3RhcnRDb3VudGRvd24gLSBkdCwgMCApO1xyXG4gICAgICBpZiAoIHRoaXMuc291bmRTdGFydENvdW50ZG93biA9PT0gMCAmJiB0aGlzLm1vdGlvblN0YXRlICE9PSAnc3RpbGwnICkge1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TGV2ZWwoIG1hcFZlbG9jaXR5VG9PdXRwdXRMZXZlbCggdGhpcy5sZWdBbmd1bGFyVmVsb2NpdHkgKSwgTk9JU0VfU1RBUlRfVElNRV9DT05TVEFOVCApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgLSB0aGlzLmxlZ0FuZ2xlVXBkYXRlVGltZSA+IFNUSUxMTkVTU19USU1FICYmXHJcbiAgICAgICAgICAgICAgTWF0aC5hYnMoIHRoaXMubGVnQW5ndWxhclZlbG9jaXR5ICkgPiAwICkge1xyXG5cclxuICAgICAgLy8gVGhlIGxlZyBhbmdsZSBoYXNuJ3QgY2hhbmdlZCBmb3IgYSBiaXQsIHNvIHN0YXJ0IHRvIHJlZHVjZSB0aGUgYW5ndWxhciB2ZWxvY2l0eSwgYnV0IGRvbid0IGRvIGl0IGFsbCBhdCBvbmNlXHJcbiAgICAgIC8vIHNpbmNlIHRoYXQgaXNuJ3QgcmVhbGlzdGljIGFuZCB0ZW5kcyB0byBjYXVzZSBnYXBzIGluIHRoZSBzb3VuZC5cclxuICAgICAgY29uc3QgYW5ndWxhclZlbG9jaXR5Q2hhbmdlID0gKCB0aGlzLmxlZ0FuZ3VsYXJWZWxvY2l0eSA+IDAgPyAtMSA6IDEgKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKCBkdCAqIFZFTE9DSVRZX1JFRFVDVElPTl9SQVRFLCBNYXRoLmFicyggdGhpcy5sZWdBbmd1bGFyVmVsb2NpdHkgKSApO1xyXG4gICAgICB0aGlzLmxlZ0FuZ3VsYXJWZWxvY2l0eSA9IHRoaXMubGVnQW5ndWxhclZlbG9jaXR5ICsgYW5ndWxhclZlbG9jaXR5Q2hhbmdlO1xyXG4gICAgICBpZiAoIHRoaXMubGVnQW5ndWxhclZlbG9jaXR5ID09PSAwICkge1xyXG4gICAgICAgIHRoaXMubW90aW9uU3RhdGUgPSAnc3RpbGwnO1xyXG4gICAgICAgIHRoaXMuc3RvcCggdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyBOT0lTRV9PRkZfVElNRSApO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TGV2ZWwoIDAsIE5PSVNFX1NUT1BfVElNRV9DT05TVEFOVCApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TGV2ZWwoIG1hcFZlbG9jaXR5VG9PdXRwdXRMZXZlbCggdGhpcy5sZWdBbmd1bGFyVmVsb2NpdHkgKSwgTk9JU0VfU1RBUlRfVElNRV9DT05TVEFOVCApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGxlZyB0byBhbiBvdXRwdXQgbGV2ZWwgZm9yIHRoZSBub2lzZSBnZW5lcmF0b3JcclxuZnVuY3Rpb24gbWFwVmVsb2NpdHlUb091dHB1dExldmVsKCBhbmd1bGFyVmVsb2NpdHlPZkxlZyApIHtcclxuICBjb25zdCBtdWx0aXBsaWVyID0gTWF0aC5taW4oIE1hdGgucG93KCBNYXRoLmFicyggYW5ndWxhclZlbG9jaXR5T2ZMZWcgKSAvIE1BWF9MRUdfQU5HVUxBUl9WRUxPQ0lUWSwgMC43ICksIDEgKTtcclxuICByZXR1cm4gTUFYX0RSQUdfU09VTkRfVk9MVU1FICogbXVsdGlwbGllcjtcclxufVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGxlZyB0byBhIGNlbnRlciBmcmVxdWVuY3kgdmFsdWVzIGZvciB0aGUgbm9pc2UgZmlsdGVyXHJcbmZ1bmN0aW9uIG1hcFZlbG9jaXR5VG9GaWx0ZXJGcmVxdWVuY3koIGFuZ3VsYXJWZWxvY2l0eU9mTGVnLCBkaXJlY3Rpb24gKSB7XHJcbiAgbGV0IG1pbkZyZXF1ZW5jeTtcclxuICBpZiAoIGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnICkge1xyXG4gICAgbWluRnJlcXVlbmN5ID0gTk9JU0VfQ0VOVEVSX0ZSRVFVRU5DWSAtIERJUkVDVElPTl9GUkVRVUVOQ1lfREVMVEE7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgbWluRnJlcXVlbmN5ID0gTk9JU0VfQ0VOVEVSX0ZSRVFVRU5DWSArIERJUkVDVElPTl9GUkVRVUVOQ1lfREVMVEE7XHJcbiAgfVxyXG4gIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLmFicyggYW5ndWxhclZlbG9jaXR5T2ZMZWcgKSAvIE1BWF9MRUdfQU5HVUxBUl9WRUxPQ0lUWTtcclxuICByZXR1cm4gbWluRnJlcXVlbmN5ICsgNTAwICogbXVsdGlwbGllcjtcclxufVxyXG5cclxuam9oblRyYXZvbHRhZ2UucmVnaXN0ZXIoICdGb290RHJhZ1NvdW5kR2VuZXJhdG9yJywgRm9vdERyYWdTb3VuZEdlbmVyYXRvciApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRm9vdERyYWdTb3VuZEdlbmVyYXRvcjsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsU0FBUyxNQUFNLGlDQUFpQztBQUN2RCxPQUFPQyxLQUFLLE1BQU0sNkJBQTZCO0FB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