// Copyright 2016-2023, University of Colorado Boulder

/**
 * Abstract base class for WireNode and FixedCircuitElementNode
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import { Node } from '../../../scenery/js/imports.js';
import CCKCConstants from '../CCKCConstants.js';
import circuitConstructionKitCommon from '../circuitConstructionKitCommon.js';
import optionize from '../../../phet-core/js/optionize.js';
export default class CircuitElementNode extends Node {
  /**
   * @param circuitElement - the CircuitElement to be rendered
   * @param circuit - the circuit which the element can be removed from or null for icons
   * @param [providedOptions]
   */
  constructor(circuitElement, circuit, providedOptions) {
    providedOptions = optionize()({
      useHitTestForSensors: false // if true, use the scenery mouse region hit test for fine-grained region. Otherwise, use bounds test.
    }, providedOptions);

    // When not an icon, enable keyboard navigation
    if (circuit) {
      providedOptions = optionize()({
        tagName: 'div',
        // HTML tag name for representative element in the document, see ParallelDOM.js
        focusable: true,
        focusHighlight: 'invisible',
        // highlights are drawn by the simulation, invisible is deprecated don't use in future
        phetioDynamicElement: true,
        phetioState: false,
        phetioVisiblePropertyInstrumented: false,
        phetioInputEnabledPropertyInstrumented: true,
        useHitTestForSensors: false
      }, providedOptions);
    }
    super(providedOptions);
    this.useHitTestForSensors = !!providedOptions.useHitTestForSensors;

    // the circuit which the element can be removed from or null for icons
    this.circuit = circuit;
    this.circuitElement = circuitElement;

    // Make it easy to get back to circuitElements
    this.addLinkedElement(circuitElement, {
      tandem: providedOptions.tandem.createTandem('circuitElement')
    });
    this.updateOpacityOnInteractiveChange();

    /**
     * When the object is created and dragged from the toolbox, the start drag method is forwarded through to start the
     * dragging.
     * @param event - scenery event
     */
    const startDragListener = event => this.dragListener.down(event);
    circuitElement.startDragEmitter.addListener(startDragListener);

    // Flag to indicate when updating view is necessary, in order to avoid duplicate work when both vertices move
    this.dirty = true;
    this.disposeEmitter.addListener(() => circuitElement.startDragEmitter.removeListener(startDragListener));
  }

  /**
   * Mark dirty to batch changes, so that update can be done once in view step, if necessary
   */
  markAsDirty() {
    this.dirty = true;
  }

  /**
   * When interactivity changes, update the opacity.  Overridden.
   */
  updateOpacityOnInteractiveChange() {
    // TODO (black-box-study): Replace this with grayscale if we keep it
    // TODO (black-box-study): @jonathonolson said: I've wished for a scenery-level grayscale/etc. filter. Let me know when you get close to doing this.
    const interactivityChanged = interactive => {
      this.opacity = interactive ? 1 : 0.5;
    };
    this.circuitElement.interactiveProperty.link(interactivityChanged);
    this.disposeEmitter.addListener(() => this.circuitElement.interactiveProperty.unlink(interactivityChanged));
  }

  /**
   * Returns true if the node hits the sensor at the given point.
   */
  containsSensorPoint(globalPoint) {
    const localPoint = this.globalToParentPoint(globalPoint);

    // make sure bounds are correct if cut or joined in this animation frame
    this.step();
    if (this.useHitTestForSensors) {
      // Check against the mouse region
      return !!this.hitTest(localPoint, true, false);
    } else {
      // default implementation is a scenery geometry containment test
      return this.containsPoint(localPoint);
    }
  }

  /**
   * called during the view step
   */
  step() {
    if (this.dirty) {
      this.updateRender();
      this.dirty = false;
    }
  }
  /**
   * Handles when the node is dropped, called by subclass input listener.
   * @param node - the node the input listener is attached to
   * @param vertices - the vertices that are dragged
   * @param screenView - the main screen view, null for icon
   * @param circuitNode
   * @param initialPoint
   * @param latestPoint
   * @param dragged
   */
  endDrag(node, vertices, screenView, circuitNode, initialPoint, latestPoint, dragged) {
    const circuitElement = this.circuitElement;
    if (circuitElement.interactiveProperty.get()) {
      // If over the toolbox, then drop into it
      if (screenView.canNodeDropInToolbox(this)) {
        this.circuit.disposeCircuitElement(circuitElement);
      } else {
        // End drag for each of the vertices
        vertices.forEach(vertex => {
          if (screenView.model.circuit.vertexGroup.includes(vertex)) {
            circuitNode.endDrag(vertex, dragged);
          }
        });

        // Only show the editor when tapped, not on every drag.  Also, event could be undefined if this end() was
        // triggered by dispose()
        this.selectCircuitElementNodeWhenNear(circuitNode, initialPoint, latestPoint);
      }
    }
  }

  /**
   * On tap events, select the CircuitElement (if it is close enough to the tap)
   */
  selectCircuitElementNodeWhenNear(circuitNode, startPoint, latestPoint) {
    if (!this.circuitElement.isDisposed && latestPoint && latestPoint.distance(startPoint) < CCKCConstants.TAP_THRESHOLD) {
      circuitNode.circuit.selectionProperty.value = this.circuitElement;

      // focus the element for keyboard interaction
      // in the state wrapper, the destination frame tries to apply this delete first, which steals it from the upstream frame
      const ignoreFocus = phet.preloads.phetio && phet.preloads.phetio.queryParameters.frameTitle === 'destination';
      if (!ignoreFocus) {
        this.focus();
      }
    }
  }
}
circuitConstructionKitCommon.register('CircuitElementNode', CircuitElementNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJOb2RlIiwiQ0NLQ0NvbnN0YW50cyIsImNpcmN1aXRDb25zdHJ1Y3Rpb25LaXRDb21tb24iLCJvcHRpb25pemUiLCJDaXJjdWl0RWxlbWVudE5vZGUiLCJjb25zdHJ1Y3RvciIsImNpcmN1aXRFbGVtZW50IiwiY2lyY3VpdCIsInByb3ZpZGVkT3B0aW9ucyIsInVzZUhpdFRlc3RGb3JTZW5zb3JzIiwidGFnTmFtZSIsImZvY3VzYWJsZSIsImZvY3VzSGlnaGxpZ2h0IiwicGhldGlvRHluYW1pY0VsZW1lbnQiLCJwaGV0aW9TdGF0ZSIsInBoZXRpb1Zpc2libGVQcm9wZXJ0eUluc3RydW1lbnRlZCIsInBoZXRpb0lucHV0RW5hYmxlZFByb3BlcnR5SW5zdHJ1bWVudGVkIiwiYWRkTGlua2VkRWxlbWVudCIsInRhbmRlbSIsImNyZWF0ZVRhbmRlbSIsInVwZGF0ZU9wYWNpdHlPbkludGVyYWN0aXZlQ2hhbmdlIiwic3RhcnREcmFnTGlzdGVuZXIiLCJldmVudCIsImRyYWdMaXN0ZW5lciIsImRvd24iLCJzdGFydERyYWdFbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJkaXJ0eSIsImRpc3Bvc2VFbWl0dGVyIiwicmVtb3ZlTGlzdGVuZXIiLCJtYXJrQXNEaXJ0eSIsImludGVyYWN0aXZpdHlDaGFuZ2VkIiwiaW50ZXJhY3RpdmUiLCJvcGFjaXR5IiwiaW50ZXJhY3RpdmVQcm9wZXJ0eSIsImxpbmsiLCJ1bmxpbmsiLCJjb250YWluc1NlbnNvclBvaW50IiwiZ2xvYmFsUG9pbnQiLCJsb2NhbFBvaW50IiwiZ2xvYmFsVG9QYXJlbnRQb2ludCIsInN0ZXAiLCJoaXRUZXN0IiwiY29udGFpbnNQb2ludCIsInVwZGF0ZVJlbmRlciIsImVuZERyYWciLCJub2RlIiwidmVydGljZXMiLCJzY3JlZW5WaWV3IiwiY2lyY3VpdE5vZGUiLCJpbml0aWFsUG9pbnQiLCJsYXRlc3RQb2ludCIsImRyYWdnZWQiLCJnZXQiLCJjYW5Ob2RlRHJvcEluVG9vbGJveCIsImRpc3Bvc2VDaXJjdWl0RWxlbWVudCIsImZvckVhY2giLCJ2ZXJ0ZXgiLCJtb2RlbCIsInZlcnRleEdyb3VwIiwiaW5jbHVkZXMiLCJzZWxlY3RDaXJjdWl0RWxlbWVudE5vZGVXaGVuTmVhciIsInN0YXJ0UG9pbnQiLCJpc0Rpc3Bvc2VkIiwiZGlzdGFuY2UiLCJUQVBfVEhSRVNIT0xEIiwic2VsZWN0aW9uUHJvcGVydHkiLCJ2YWx1ZSIsImlnbm9yZUZvY3VzIiwicGhldCIsInByZWxvYWRzIiwicGhldGlvIiwicXVlcnlQYXJhbWV0ZXJzIiwiZnJhbWVUaXRsZSIsImZvY3VzIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJDaXJjdWl0RWxlbWVudE5vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTYtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgV2lyZU5vZGUgYW5kIEZpeGVkQ2lyY3VpdEVsZW1lbnROb2RlXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIFJlaWQgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBOb2RlLCBOb2RlT3B0aW9ucywgUHJlc3NMaXN0ZW5lckV2ZW50IH0gZnJvbSAnLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IENDS0NDb25zdGFudHMgZnJvbSAnLi4vQ0NLQ0NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBjaXJjdWl0Q29uc3RydWN0aW9uS2l0Q29tbW9uIGZyb20gJy4uL2NpcmN1aXRDb25zdHJ1Y3Rpb25LaXRDb21tb24uanMnO1xyXG5pbXBvcnQgQ2lyY3VpdCBmcm9tICcuLi9tb2RlbC9DaXJjdWl0LmpzJztcclxuaW1wb3J0IENpcmN1aXRFbGVtZW50IGZyb20gJy4uL21vZGVsL0NpcmN1aXRFbGVtZW50LmpzJztcclxuaW1wb3J0IENDS0NTY3JlZW5WaWV3IGZyb20gJy4vQ0NLQ1NjcmVlblZpZXcuanMnO1xyXG5pbXBvcnQgQ2lyY3VpdE5vZGUgZnJvbSAnLi9DaXJjdWl0Tm9kZS5qcyc7XHJcbmltcG9ydCBWZXJ0ZXggZnJvbSAnLi4vbW9kZWwvVmVydGV4LmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IENpcmN1aXROb2RlRHJhZ0xpc3RlbmVyIGZyb20gJy4vQ2lyY3VpdE5vZGVEcmFnTGlzdGVuZXIuanMnO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuICB1c2VIaXRUZXN0Rm9yU2Vuc29ycz86IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBDaXJjdWl0RWxlbWVudE5vZGVPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBOb2RlT3B0aW9ucztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIENpcmN1aXRFbGVtZW50Tm9kZSBleHRlbmRzIE5vZGUge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgdXNlSGl0VGVzdEZvclNlbnNvcnM6IGJvb2xlYW47XHJcbiAgcHJpdmF0ZSByZWFkb25seSBjaXJjdWl0OiBDaXJjdWl0IHwgbnVsbDtcclxuICBwdWJsaWMgcmVhZG9ubHkgY2lyY3VpdEVsZW1lbnQ6IENpcmN1aXRFbGVtZW50O1xyXG4gIHByaXZhdGUgZGlydHk6IGJvb2xlYW47XHJcbiAgcHVibGljIHJlYWRvbmx5IGFic3RyYWN0IGRyYWdMaXN0ZW5lcjogQ2lyY3VpdE5vZGVEcmFnTGlzdGVuZXIgfCBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gY2lyY3VpdEVsZW1lbnQgLSB0aGUgQ2lyY3VpdEVsZW1lbnQgdG8gYmUgcmVuZGVyZWRcclxuICAgKiBAcGFyYW0gY2lyY3VpdCAtIHRoZSBjaXJjdWl0IHdoaWNoIHRoZSBlbGVtZW50IGNhbiBiZSByZW1vdmVkIGZyb20gb3IgbnVsbCBmb3IgaWNvbnNcclxuICAgKiBAcGFyYW0gW3Byb3ZpZGVkT3B0aW9uc11cclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIGNpcmN1aXRFbGVtZW50OiBDaXJjdWl0RWxlbWVudCwgY2lyY3VpdDogQ2lyY3VpdCB8IG51bGwsIHByb3ZpZGVkT3B0aW9ucz86IENpcmN1aXRFbGVtZW50Tm9kZU9wdGlvbnMgKSB7XHJcblxyXG4gICAgcHJvdmlkZWRPcHRpb25zID0gb3B0aW9uaXplPENpcmN1aXRFbGVtZW50Tm9kZU9wdGlvbnMsIFNlbGZPcHRpb25zLCBOb2RlT3B0aW9ucz4oKSgge1xyXG4gICAgICB1c2VIaXRUZXN0Rm9yU2Vuc29yczogZmFsc2UgLy8gaWYgdHJ1ZSwgdXNlIHRoZSBzY2VuZXJ5IG1vdXNlIHJlZ2lvbiBoaXQgdGVzdCBmb3IgZmluZS1ncmFpbmVkIHJlZ2lvbi4gT3RoZXJ3aXNlLCB1c2UgYm91bmRzIHRlc3QuXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBXaGVuIG5vdCBhbiBpY29uLCBlbmFibGUga2V5Ym9hcmQgbmF2aWdhdGlvblxyXG4gICAgaWYgKCBjaXJjdWl0ICkge1xyXG4gICAgICBwcm92aWRlZE9wdGlvbnMgPSBvcHRpb25pemU8Q2lyY3VpdEVsZW1lbnROb2RlT3B0aW9ucywgU2VsZk9wdGlvbnMsIE5vZGVPcHRpb25zPigpKCB7XHJcbiAgICAgICAgdGFnTmFtZTogJ2RpdicsIC8vIEhUTUwgdGFnIG5hbWUgZm9yIHJlcHJlc2VudGF0aXZlIGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50LCBzZWUgUGFyYWxsZWxET00uanNcclxuICAgICAgICBmb2N1c2FibGU6IHRydWUsXHJcbiAgICAgICAgZm9jdXNIaWdobGlnaHQ6ICdpbnZpc2libGUnLCAvLyBoaWdobGlnaHRzIGFyZSBkcmF3biBieSB0aGUgc2ltdWxhdGlvbiwgaW52aXNpYmxlIGlzIGRlcHJlY2F0ZWQgZG9uJ3QgdXNlIGluIGZ1dHVyZVxyXG4gICAgICAgIHBoZXRpb0R5bmFtaWNFbGVtZW50OiB0cnVlLFxyXG4gICAgICAgIHBoZXRpb1N0YXRlOiBmYWxzZSxcclxuICAgICAgICBwaGV0aW9WaXNpYmxlUHJvcGVydHlJbnN0cnVtZW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIHBoZXRpb0lucHV0RW5hYmxlZFByb3BlcnR5SW5zdHJ1bWVudGVkOiB0cnVlLFxyXG4gICAgICAgIHVzZUhpdFRlc3RGb3JTZW5zb3JzOiBmYWxzZVxyXG4gICAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuICAgIH1cclxuXHJcbiAgICBzdXBlciggcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy51c2VIaXRUZXN0Rm9yU2Vuc29ycyA9ICEhcHJvdmlkZWRPcHRpb25zLnVzZUhpdFRlc3RGb3JTZW5zb3JzO1xyXG5cclxuICAgIC8vIHRoZSBjaXJjdWl0IHdoaWNoIHRoZSBlbGVtZW50IGNhbiBiZSByZW1vdmVkIGZyb20gb3IgbnVsbCBmb3IgaWNvbnNcclxuICAgIHRoaXMuY2lyY3VpdCA9IGNpcmN1aXQ7XHJcbiAgICB0aGlzLmNpcmN1aXRFbGVtZW50ID0gY2lyY3VpdEVsZW1lbnQ7XHJcblxyXG4gICAgLy8gTWFrZSBpdCBlYXN5IHRvIGdldCBiYWNrIHRvIGNpcmN1aXRFbGVtZW50c1xyXG4gICAgdGhpcy5hZGRMaW5rZWRFbGVtZW50KCBjaXJjdWl0RWxlbWVudCwge1xyXG4gICAgICB0YW5kZW06IHByb3ZpZGVkT3B0aW9ucy50YW5kZW0hLmNyZWF0ZVRhbmRlbSggJ2NpcmN1aXRFbGVtZW50JyApXHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVPcGFjaXR5T25JbnRlcmFjdGl2ZUNoYW5nZSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB0aGUgb2JqZWN0IGlzIGNyZWF0ZWQgYW5kIGRyYWdnZWQgZnJvbSB0aGUgdG9vbGJveCwgdGhlIHN0YXJ0IGRyYWcgbWV0aG9kIGlzIGZvcndhcmRlZCB0aHJvdWdoIHRvIHN0YXJ0IHRoZVxyXG4gICAgICogZHJhZ2dpbmcuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBzY2VuZXJ5IGV2ZW50XHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHN0YXJ0RHJhZ0xpc3RlbmVyID0gKCBldmVudDogUHJlc3NMaXN0ZW5lckV2ZW50ICkgPT4gdGhpcy5kcmFnTGlzdGVuZXIhLmRvd24oIGV2ZW50ICk7XHJcblxyXG4gICAgY2lyY3VpdEVsZW1lbnQuc3RhcnREcmFnRW1pdHRlci5hZGRMaXN0ZW5lciggc3RhcnREcmFnTGlzdGVuZXIgKTtcclxuXHJcbiAgICAvLyBGbGFnIHRvIGluZGljYXRlIHdoZW4gdXBkYXRpbmcgdmlldyBpcyBuZWNlc3NhcnksIGluIG9yZGVyIHRvIGF2b2lkIGR1cGxpY2F0ZSB3b3JrIHdoZW4gYm90aCB2ZXJ0aWNlcyBtb3ZlXHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIHRoaXMuZGlzcG9zZUVtaXR0ZXIuYWRkTGlzdGVuZXIoICgpID0+IGNpcmN1aXRFbGVtZW50LnN0YXJ0RHJhZ0VtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIHN0YXJ0RHJhZ0xpc3RlbmVyICkgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcmsgZGlydHkgdG8gYmF0Y2ggY2hhbmdlcywgc28gdGhhdCB1cGRhdGUgY2FuIGJlIGRvbmUgb25jZSBpbiB2aWV3IHN0ZXAsIGlmIG5lY2Vzc2FyeVxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBtYXJrQXNEaXJ0eSgpOiB2b2lkIHtcclxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiBpbnRlcmFjdGl2aXR5IGNoYW5nZXMsIHVwZGF0ZSB0aGUgb3BhY2l0eS4gIE92ZXJyaWRkZW4uXHJcbiAgICovXHJcbiAgcHVibGljIHVwZGF0ZU9wYWNpdHlPbkludGVyYWN0aXZlQ2hhbmdlKCk6IHZvaWQge1xyXG5cclxuICAgIC8vIFRPRE8gKGJsYWNrLWJveC1zdHVkeSk6IFJlcGxhY2UgdGhpcyB3aXRoIGdyYXlzY2FsZSBpZiB3ZSBrZWVwIGl0XHJcbiAgICAvLyBUT0RPIChibGFjay1ib3gtc3R1ZHkpOiBAam9uYXRob25vbHNvbiBzYWlkOiBJJ3ZlIHdpc2hlZCBmb3IgYSBzY2VuZXJ5LWxldmVsIGdyYXlzY2FsZS9ldGMuIGZpbHRlci4gTGV0IG1lIGtub3cgd2hlbiB5b3UgZ2V0IGNsb3NlIHRvIGRvaW5nIHRoaXMuXHJcbiAgICBjb25zdCBpbnRlcmFjdGl2aXR5Q2hhbmdlZCA9ICggaW50ZXJhY3RpdmU6IGJvb2xlYW4gKSA9PiB7XHJcbiAgICAgIHRoaXMub3BhY2l0eSA9IGludGVyYWN0aXZlID8gMSA6IDAuNTtcclxuICAgIH07XHJcbiAgICB0aGlzLmNpcmN1aXRFbGVtZW50LmludGVyYWN0aXZlUHJvcGVydHkubGluayggaW50ZXJhY3Rpdml0eUNoYW5nZWQgKTtcclxuXHJcbiAgICB0aGlzLmRpc3Bvc2VFbWl0dGVyLmFkZExpc3RlbmVyKCAoKSA9PiB0aGlzLmNpcmN1aXRFbGVtZW50LmludGVyYWN0aXZlUHJvcGVydHkudW5saW5rKCBpbnRlcmFjdGl2aXR5Q2hhbmdlZCApICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaGl0cyB0aGUgc2Vuc29yIGF0IHRoZSBnaXZlbiBwb2ludC5cclxuICAgKi9cclxuICBwdWJsaWMgY29udGFpbnNTZW5zb3JQb2ludCggZ2xvYmFsUG9pbnQ6IFZlY3RvcjIgKTogYm9vbGVhbiB7XHJcblxyXG4gICAgY29uc3QgbG9jYWxQb2ludCA9IHRoaXMuZ2xvYmFsVG9QYXJlbnRQb2ludCggZ2xvYmFsUG9pbnQgKTtcclxuXHJcbiAgICAvLyBtYWtlIHN1cmUgYm91bmRzIGFyZSBjb3JyZWN0IGlmIGN1dCBvciBqb2luZWQgaW4gdGhpcyBhbmltYXRpb24gZnJhbWVcclxuICAgIHRoaXMuc3RlcCgpO1xyXG5cclxuICAgIGlmICggdGhpcy51c2VIaXRUZXN0Rm9yU2Vuc29ycyApIHtcclxuXHJcbiAgICAgIC8vIENoZWNrIGFnYWluc3QgdGhlIG1vdXNlIHJlZ2lvblxyXG4gICAgICByZXR1cm4gISF0aGlzLmhpdFRlc3QoIGxvY2FsUG9pbnQsIHRydWUsIGZhbHNlICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuXHJcbiAgICAgIC8vIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgYSBzY2VuZXJ5IGdlb21ldHJ5IGNvbnRhaW5tZW50IHRlc3RcclxuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnNQb2ludCggbG9jYWxQb2ludCApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY2FsbGVkIGR1cmluZyB0aGUgdmlldyBzdGVwXHJcbiAgICovXHJcbiAgcHVibGljIHN0ZXAoKTogdm9pZCB7XHJcbiAgICBpZiAoIHRoaXMuZGlydHkgKSB7XHJcblxyXG4gICAgICB0aGlzLnVwZGF0ZVJlbmRlcigpO1xyXG4gICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYWJzdHJhY3QgdXBkYXRlUmVuZGVyKCk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgd2hlbiB0aGUgbm9kZSBpcyBkcm9wcGVkLCBjYWxsZWQgYnkgc3ViY2xhc3MgaW5wdXQgbGlzdGVuZXIuXHJcbiAgICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0aGUgaW5wdXQgbGlzdGVuZXIgaXMgYXR0YWNoZWQgdG9cclxuICAgKiBAcGFyYW0gdmVydGljZXMgLSB0aGUgdmVydGljZXMgdGhhdCBhcmUgZHJhZ2dlZFxyXG4gICAqIEBwYXJhbSBzY3JlZW5WaWV3IC0gdGhlIG1haW4gc2NyZWVuIHZpZXcsIG51bGwgZm9yIGljb25cclxuICAgKiBAcGFyYW0gY2lyY3VpdE5vZGVcclxuICAgKiBAcGFyYW0gaW5pdGlhbFBvaW50XHJcbiAgICogQHBhcmFtIGxhdGVzdFBvaW50XHJcbiAgICogQHBhcmFtIGRyYWdnZWRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZW5kRHJhZyggbm9kZTogTm9kZSwgdmVydGljZXM6IFZlcnRleFtdLCBzY3JlZW5WaWV3OiBDQ0tDU2NyZWVuVmlldywgY2lyY3VpdE5vZGU6IENpcmN1aXROb2RlLCBpbml0aWFsUG9pbnQ6IFZlY3RvcjIsIGxhdGVzdFBvaW50OiBWZWN0b3IyLCBkcmFnZ2VkOiBib29sZWFuICk6IHZvaWQge1xyXG4gICAgY29uc3QgY2lyY3VpdEVsZW1lbnQgPSB0aGlzLmNpcmN1aXRFbGVtZW50O1xyXG5cclxuICAgIGlmICggY2lyY3VpdEVsZW1lbnQuaW50ZXJhY3RpdmVQcm9wZXJ0eS5nZXQoKSApIHtcclxuXHJcbiAgICAgIC8vIElmIG92ZXIgdGhlIHRvb2xib3gsIHRoZW4gZHJvcCBpbnRvIGl0XHJcbiAgICAgIGlmICggc2NyZWVuVmlldy5jYW5Ob2RlRHJvcEluVG9vbGJveCggdGhpcyApICkge1xyXG4gICAgICAgIHRoaXMuY2lyY3VpdCEuZGlzcG9zZUNpcmN1aXRFbGVtZW50KCBjaXJjdWl0RWxlbWVudCApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFbmQgZHJhZyBmb3IgZWFjaCBvZiB0aGUgdmVydGljZXNcclxuICAgICAgICB2ZXJ0aWNlcy5mb3JFYWNoKCB2ZXJ0ZXggPT4ge1xyXG4gICAgICAgICAgaWYgKCBzY3JlZW5WaWV3Lm1vZGVsLmNpcmN1aXQudmVydGV4R3JvdXAuaW5jbHVkZXMoIHZlcnRleCApICkge1xyXG4gICAgICAgICAgICBjaXJjdWl0Tm9kZS5lbmREcmFnKCB2ZXJ0ZXgsIGRyYWdnZWQgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgIC8vIE9ubHkgc2hvdyB0aGUgZWRpdG9yIHdoZW4gdGFwcGVkLCBub3Qgb24gZXZlcnkgZHJhZy4gIEFsc28sIGV2ZW50IGNvdWxkIGJlIHVuZGVmaW5lZCBpZiB0aGlzIGVuZCgpIHdhc1xyXG4gICAgICAgIC8vIHRyaWdnZXJlZCBieSBkaXNwb3NlKClcclxuICAgICAgICB0aGlzLnNlbGVjdENpcmN1aXRFbGVtZW50Tm9kZVdoZW5OZWFyKCBjaXJjdWl0Tm9kZSwgaW5pdGlhbFBvaW50LCBsYXRlc3RQb2ludCApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPbiB0YXAgZXZlbnRzLCBzZWxlY3QgdGhlIENpcmN1aXRFbGVtZW50IChpZiBpdCBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIHRhcClcclxuICAgKi9cclxuICBwcml2YXRlIHNlbGVjdENpcmN1aXRFbGVtZW50Tm9kZVdoZW5OZWFyKCBjaXJjdWl0Tm9kZTogQ2lyY3VpdE5vZGUsIHN0YXJ0UG9pbnQ6IFZlY3RvcjIsIGxhdGVzdFBvaW50OiBWZWN0b3IyIHwgbnVsbCApOiB2b2lkIHtcclxuXHJcbiAgICBpZiAoICF0aGlzLmNpcmN1aXRFbGVtZW50LmlzRGlzcG9zZWQgJiYgbGF0ZXN0UG9pbnQgJiYgbGF0ZXN0UG9pbnQuZGlzdGFuY2UoIHN0YXJ0UG9pbnQgKSA8IENDS0NDb25zdGFudHMuVEFQX1RIUkVTSE9MRCApIHtcclxuXHJcbiAgICAgIGNpcmN1aXROb2RlLmNpcmN1aXQuc2VsZWN0aW9uUHJvcGVydHkudmFsdWUgPSB0aGlzLmNpcmN1aXRFbGVtZW50O1xyXG5cclxuICAgICAgLy8gZm9jdXMgdGhlIGVsZW1lbnQgZm9yIGtleWJvYXJkIGludGVyYWN0aW9uXHJcbiAgICAgIC8vIGluIHRoZSBzdGF0ZSB3cmFwcGVyLCB0aGUgZGVzdGluYXRpb24gZnJhbWUgdHJpZXMgdG8gYXBwbHkgdGhpcyBkZWxldGUgZmlyc3QsIHdoaWNoIHN0ZWFscyBpdCBmcm9tIHRoZSB1cHN0cmVhbSBmcmFtZVxyXG4gICAgICBjb25zdCBpZ25vcmVGb2N1cyA9IHBoZXQucHJlbG9hZHMucGhldGlvICYmIHBoZXQucHJlbG9hZHMucGhldGlvLnF1ZXJ5UGFyYW1ldGVycy5mcmFtZVRpdGxlID09PSAnZGVzdGluYXRpb24nO1xyXG4gICAgICBpZiAoICFpZ25vcmVGb2N1cyApIHtcclxuICAgICAgICB0aGlzLmZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmNpcmN1aXRDb25zdHJ1Y3Rpb25LaXRDb21tb24ucmVnaXN0ZXIoICdDaXJjdWl0RWxlbWVudE5vZGUnLCBDaXJjdWl0RWxlbWVudE5vZGUgKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0EsU0FBU0EsSUFBSSxRQUF5QyxnQ0FBZ0M7QUFDdEYsT0FBT0MsYUFBYSxNQUFNLHFCQUFxQjtBQUMvQyxPQUFPQyw0QkFBNEIsTUFBTSxvQ0FBb0M7QUFNN0UsT0FBT0MsU0FBUyxNQUFNLG9DQUFvQztBQVMxRCxlQUFlLE1BQWVDLGtCQUFrQixTQUFTSixJQUFJLENBQUM7RUFPNUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNTSyxXQUFXQSxDQUFFQyxjQUE4QixFQUFFQyxPQUF1QixFQUFFQyxlQUEyQyxFQUFHO0lBRXpIQSxlQUFlLEdBQUdMLFNBQVMsQ0FBc0QsQ0FBQyxDQUFFO01BQ2xGTSxvQkFBb0IsRUFBRSxLQUFLLENBQUM7SUFDOUIsQ0FBQyxFQUFFRCxlQUFnQixDQUFDOztJQUVwQjtJQUNBLElBQUtELE9BQU8sRUFBRztNQUNiQyxlQUFlLEdBQUdMLFNBQVMsQ0FBc0QsQ0FBQyxDQUFFO1FBQ2xGTyxPQUFPLEVBQUUsS0FBSztRQUFFO1FBQ2hCQyxTQUFTLEVBQUUsSUFBSTtRQUNmQyxjQUFjLEVBQUUsV0FBVztRQUFFO1FBQzdCQyxvQkFBb0IsRUFBRSxJQUFJO1FBQzFCQyxXQUFXLEVBQUUsS0FBSztRQUNsQkMsaUNBQWlDLEVBQUUsS0FBSztRQUN4Q0Msc0NBQXNDLEVBQUUsSUFBSTtRQUM1Q1Asb0JBQW9CLEVBQUU7TUFDeEIsQ0FBQyxFQUFFRCxlQUFnQixDQUFDO0lBQ3RCO0lBRUEsS0FBSyxDQUFFQSxlQUFnQixDQUFDO0lB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