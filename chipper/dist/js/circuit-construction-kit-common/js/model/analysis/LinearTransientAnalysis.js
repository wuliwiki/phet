// Copyright 2019-2023, University of Colorado Boulder

/**
 * Takes a Circuit, creates a corresponding LTACircuit, solves the LTACircuit and applies the results back
 * to the original Circuit.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import circuitConstructionKitCommon from '../../circuitConstructionKitCommon.js';
import Capacitor from '../Capacitor.js';
import LTACircuit from './LTACircuit.js';
import Fuse from '../Fuse.js';
import Inductor from '../Inductor.js';
import LightBulb from '../LightBulb.js';
import Resistor from '../Resistor.js';
import SeriesAmmeter from '../SeriesAmmeter.js';
import Switch from '../Switch.js';
import TimestepSubdivisions from './TimestepSubdivisions.js';
import VoltageSource from '../VoltageSource.js';
import Wire from '../Wire.js';
import CCKCConstants from '../../CCKCConstants.js';
import LTAResistiveBattery from './LTAResistiveBattery.js';
import LTAInductor from './LTAInductor.js';
import CCKCUtils from '../../CCKCUtils.js';
import LTACapacitor from './LTACapacitor.js';
import MNAResistor from './mna/MNAResistor.js';

// constants
const TIMESTEP_SUBDIVISIONS = new TimestepSubdivisions();
let id = 0;
export default class LinearTransientAnalysis {
  /**
   * Solves the system with Modified Nodal Analysis, and apply the results back to the Circuit.
   */
  static solveModifiedNodalAnalysis(circuit, dt) {
    const ltaBatteries = [];
    const ltaResistors = [];
    const ltaCapacitors = [];
    const ltaInductors = [];

    // Identify CircuitElements that are not in a loop with a voltage source. They will have their currents zeroed out.
    const nonParticipants = [];
    const participants = [];
    const resistorMap = new Map(); // Should be something like Resistor | Fuse | Wire | LightBulb | SeriesAmmeter | Switch
    const voltageSourceMap = new Map();
    const capacitorMap = new Map();
    const inductorMap = new Map();
    let hasRealBulbs = false;
    for (let i = 0; i < circuit.circuitElements.length; i++) {
      const circuitElement = circuit.circuitElements[i];
      const inLoop = circuit.isInLoop(circuitElement);
      if (inLoop) {
        participants.push(circuitElement);
        if (circuitElement instanceof VoltageSource) {
          const ltaVoltageSource = new LTAResistiveBattery(id++, circuitElement.startVertexProperty.value.index + '', circuitElement.endVertexProperty.value.index + '', circuitElement.voltageProperty.value, circuitElement.internalResistanceProperty.value);
          voltageSourceMap.set(ltaVoltageSource, circuitElement);
          ltaBatteries.push(ltaVoltageSource);
        } else if (circuitElement instanceof Resistor || circuitElement instanceof Fuse || circuitElement instanceof Wire || circuitElement instanceof LightBulb || circuitElement instanceof SeriesAmmeter ||
        // Since no closed circuit there; see below where current is zeroed out
        circuitElement instanceof Switch && circuitElement.isClosedProperty.value) {
          // For real bulbs, we run an initial circuit solution to determine their operating characteristics.
          // These operating characteristics are then used in a second solution to prevent a hysteresis.

          // If a resistor goes to 0 resistance, then we cannot compute the current through as I=V/R.  Therefore,
          // simulate a small amount of resistance.
          const resistance = circuitElement instanceof LightBulb && circuitElement.isReal ? LightBulb.REAL_BULB_COLD_RESISTANCE : circuitElement.resistanceProperty.value || CCKCConstants.MINIMUM_RESISTANCE;
          if (circuitElement instanceof LightBulb && circuitElement.isReal) {
            hasRealBulbs = true;
          }
          const resistorAdapter = new MNAResistor(circuitElement.startVertexProperty.value.index + '', circuitElement.endVertexProperty.value.index + '', resistance);
          resistorMap.set(resistorAdapter, circuitElement);
          ltaResistors.push(resistorAdapter);
        } else if (circuitElement instanceof Switch && !circuitElement.isClosedProperty.value) {

          // no element for an open switch
        } else if (circuitElement instanceof Capacitor) {
          const ltaCapacitor = new LTACapacitor(id++, circuitElement.startVertexProperty.value.index + '', circuitElement.endVertexProperty.value.index + '', circuitElement.mnaVoltageDrop, circuitElement.mnaCurrent, circuitElement.capacitanceProperty.value);
          ltaCapacitors.push(ltaCapacitor);
          capacitorMap.set(ltaCapacitor, circuitElement);
        } else if (circuitElement instanceof Inductor) {
          const ltaInductor = new LTAInductor(id++, circuitElement.startVertexProperty.value.index + '', circuitElement.endVertexProperty.value.index + '', circuitElement.mnaVoltageDrop, circuitElement.mnaCurrent, circuitElement.inductanceProperty.value);
          inductorMap.set(ltaInductor, circuitElement);
          ltaInductors.push(ltaInductor);
        } else {
          assert && assert(false, `Type not found: ${circuitElement.constructor.name}`);
        }
      } else {
        nonParticipants.push(circuitElement);
      }
    }

    // Solve the system
    let ltaCircuit = new LTACircuit(ltaResistors, ltaBatteries, ltaCapacitors, ltaInductors);
    let circuitResult = ltaCircuit.solveWithSubdivisions(TIMESTEP_SUBDIVISIONS, dt);

    // the resistance of real bulbs is a function of their voltage
    if (hasRealBulbs) {
      // to estimate the resistance of a real bulb, we start by setting its resistance to REAL_BULB_COLD_RESISTANCE
      // then we solve the circuit to find the voltage across it, and update its resistance according to the log equation below
      // we repeat this process 10 times to get closer to the bulb's actual voltage and resistance
      // in testing, we found that 10 iterations brings the real bulb to within an acceptable range of the accurate resistance
      for (let i = 0; i < 10; i++) {
        for (let j = 0; j < ltaResistors.length; j++) {
          const resistorAdapter = ltaResistors[j];
          const circuitElement = resistorMap.get(resistorAdapter);
          if (circuitElement instanceof LightBulb && circuitElement.isReal) {
            const logWithBase = (value, base) => Math.log(value) / Math.log(base);
            const dV = circuitResult.getFinalState().ltaSolution.getVoltage(resistorAdapter.nodeId0, resistorAdapter.nodeId1);
            const V = Math.abs(dV);
            const base = 2;

            // I = ln(V)
            // V=IR
            // V=ln(V)R
            // R = V/ln(V)

            // Adjust so it looks good in comparison to a standard bulb
            const coefficient = 3;

            // shift by base so at V=0 the log is 1
            resistorAdapter.resistance = LightBulb.REAL_BULB_COLD_RESISTANCE + coefficient * V / logWithBase(V + base, base);
            circuitElement.resistanceProperty.value = resistorAdapter.resistance;
          }
        }

        // If the circuit contains real bulbs, we need to solve the circuit again after calculating their resistance
        // to prevent a hysteresis. This ensures that the resistance of the bulbs is consistent with their voltage.
        ltaCircuit = new LTACircuit(ltaResistors, ltaBatteries, ltaCapacitors, ltaInductors);
        circuitResult = ltaCircuit.solveWithSubdivisions(TIMESTEP_SUBDIVISIONS, dt);
      }
    }

    // Apply the solutions from the analysis back to the actual Circuit
    ltaBatteries.forEach(batteryAdapter => {
      const circuitElement = voltageSourceMap.get(batteryAdapter);
      circuitElement.currentProperty.value = circuitResult.getTimeAverageCurrentForCoreModel(batteryAdapter);
    });
    ltaResistors.forEach(resistorAdapter => {
      const circuitElement = resistorMap.get(resistorAdapter);
      circuitElement.currentProperty.value = circuitResult.getTimeAverageCurrent(resistorAdapter);
    });
    ltaCapacitors.forEach(ltaCapacitor => {
      const capacitor = capacitorMap.get(ltaCapacitor);
      capacitor.currentProperty.value = circuitResult.getTimeAverageCurrentForCoreModel(ltaCapacitor);
      capacitor.mnaCurrent = CCKCUtils.clampMagnitude(circuitResult.getInstantaneousCurrentForCoreModel(ltaCapacitor));
      capacitor.mnaVoltageDrop = CCKCUtils.clampMagnitude(circuitResult.getInstantaneousVoltageForCoreModel(ltaCapacitor));
      assert && assert(Math.abs(capacitor.mnaCurrent) < 1E100, 'mnaCurrent out of range');
      assert && assert(Math.abs(capacitor.mnaVoltageDrop) < 1E100, 'mnaVoltageDrop out of range');
    });
    ltaInductors.forEach(ltaInductor => {
      const inductor = inductorMap.get(ltaInductor);
      inductor.currentProperty.value = circuitResult.getTimeAverageCurrentForCoreModel(ltaInductor);
      inductor.mnaCurrent = CCKCUtils.clampMagnitude(circuitResult.getInstantaneousCurrentForCoreModel(ltaInductor));
      inductor.mnaVoltageDrop = CCKCUtils.clampMagnitude(circuitResult.getInstantaneousVoltageForCoreModel(ltaInductor));
      assert && assert(Math.abs(inductor.mnaCurrent) < 1E100, 'mnaCurrent out of range');
      assert && assert(Math.abs(inductor.mnaVoltageDrop) < 1E100, 'mnaVoltageDrop out of range');
    });

    // zero out currents on open branches
    nonParticipants.forEach(circuitElement => {
      circuitElement.currentProperty.value = 0;

      // Clear disconnected isReal light bulbs
      if (circuitElement instanceof LightBulb && circuitElement.isReal) {
        circuitElement.resistanceProperty.value = LightBulb.REAL_BULB_COLD_RESISTANCE;
      }
    });
    const solvedVertices = [];
    const unsolvedVertices = [];

    // Apply the node voltages to the vertices
    circuit.vertexGroup.forEach(vertex => {
      const voltage = circuitResult.getFinalState().ltaSolution.getNodeVoltage(vertex.index + '');
      if (typeof voltage === 'number') {
        vertex.voltageProperty.value = -voltage;
        solvedVertices.push(vertex);
      } else {
        unsolvedVertices.push(vertex);
      }
    });

    // compute voltages for open branches
    // for each connected component, start at a known voltage and depth first search the graph.
    const visitVoltage = (startVertex, circuitElement, endVertex) => {
      // If we already know the voltage from the matrix solution, skip it.
      if (!solvedVertices.includes(endVertex)) {
        const sign = startVertex === circuitElement.startVertexProperty.value ? 1 : -1;

        // compute end voltage from start voltage
        if (circuitElement instanceof Resistor || circuitElement instanceof Wire || circuitElement instanceof LightBulb || circuitElement instanceof Switch && circuitElement.isClosedProperty.value || circuitElement instanceof Fuse || circuitElement instanceof SeriesAmmeter) {
          // In the general case, we would need V=IR to compute the voltage drop, but we know the current across the
          // non-participants is 0, so the voltage drop across them is also zero
          endVertex.voltageProperty.value = startVertex.voltageProperty.value;
          solvedVertices.push(endVertex);
        } else if (circuitElement instanceof VoltageSource) {
          endVertex.voltageProperty.value = startVertex.voltageProperty.value + sign * circuitElement.voltageProperty.value;
          solvedVertices.push(endVertex);
        } else if (circuitElement instanceof Capacitor || circuitElement instanceof Inductor) {
          endVertex.voltageProperty.value = startVertex.voltageProperty.value - sign * circuitElement.mnaVoltageDrop;
          solvedVertices.push(endVertex);
        } else if (circuitElement instanceof Switch && !circuitElement.isClosedProperty.value) {
          // for an open switch, the node voltages are independent
        } else {
          assert && assert(false, 'unknown circuit element type: ' + circuitElement.constructor.name);
        }
      }
    };
    const visited = [];
    const dfs = (vertex, visit) => {
      visited.push(vertex);
      circuit.circuitElements.forEach(circuitElement => {
        if (circuitElement.containsVertex(vertex)) {
          const opposite = circuitElement.getOppositeVertex(vertex);
          if (!visited.includes(opposite) && !(circuitElement instanceof Switch && !circuitElement.isClosedProperty.value)) {
            visit(vertex, circuitElement, opposite);
            dfs(opposite, visit);
          }
        }
      });
    };

    // Start visiting from the solved vertices, since they have the ground truth.  Have to visit each to make sure
    // we traveled to all disconnected components
    const allVertices = [...solvedVertices, ...unsolvedVertices];
    allVertices.forEach(vertex => {
      if (!visited.includes(vertex)) {
        dfs(vertex, visitVoltage);
      }
    });

    // Depth first search across the circuit to ensure current conserved at each vertex
    // circuit.checkCurrentConservation( 'before' );
    const locked = [...nonParticipants];
    const visitCurrent = vertex => circuit.conserveCurrent(vertex, locked);
    visited.length = 0;
    allVertices.forEach(vertex => dfs(vertex, visitCurrent));
    // circuit.checkCurrentConservation( 'after' );

    unsolvedVertices.forEach(v => {
      assert && assert(visited.includes(v), 'unsolved vertex ' + v.tandem.phetioID + ' should be visited.');
    });
  }
}
circuitConstructionKitCommon.register('LinearTransientAnalysis', LinearTransientAnalysis);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjaXJjdWl0Q29uc3RydWN0aW9uS2l0Q29tbW9uIiwiQ2FwYWNpdG9yIiwiTFRBQ2lyY3VpdCIsIkZ1c2UiLCJJbmR1Y3RvciIsIkxpZ2h0QnVsYiIsIlJlc2lzdG9yIiwiU2VyaWVzQW1tZXRlciIsIlN3aXRjaCIsIlRpbWVzdGVwU3ViZGl2aXNpb25zIiwiVm9sdGFnZVNvdXJjZSIsIldpcmUiLCJDQ0tDQ29uc3RhbnRzIiwiTFRBUmVzaXN0aXZlQmF0dGVyeSIsIkxUQUluZHVjdG9yIiwiQ0NLQ1V0aWxzIiwiTFRBQ2FwYWNpdG9yIiwiTU5BUmVzaXN0b3IiLCJUSU1FU1RFUF9TVUJESVZJU0lPTlMiLCJpZCIsIkxpbmVhclRyYW5zaWVudEFuYWx5c2lzIiwic29sdmVNb2RpZmllZE5vZGFsQW5hbHlzaXMiLCJjaXJjdWl0IiwiZHQiLCJsdGFCYXR0ZXJpZXMiLCJsdGFSZXNpc3RvcnMiLCJsdGFDYXBhY2l0b3JzIiwibHRhSW5kdWN0b3JzIiwibm9uUGFydGljaXBhbnRzIiwicGFydGljaXBhbnRzIiwicmVzaXN0b3JNYXAiLCJNYXAiLCJ2b2x0YWdlU291cmNlTWFwIiwiY2FwYWNpdG9yTWFwIiwiaW5kdWN0b3JNYXAiLCJoYXNSZWFsQnVsYnMiLCJpIiwiY2lyY3VpdEVsZW1lbnRzIiwibGVuZ3RoIiwiY2lyY3VpdEVsZW1lbnQiLCJpbkxvb3AiLCJpc0luTG9vcCIsInB1c2giLCJsdGFWb2x0YWdlU291cmNlIiwic3RhcnRWZXJ0ZXhQcm9wZXJ0eSIsInZhbHVlIiwiaW5kZXgiLCJlbmRWZXJ0ZXhQcm9wZXJ0eSIsInZvbHRhZ2VQcm9wZXJ0eSIsImludGVybmFsUmVzaXN0YW5jZVByb3BlcnR5Iiwic2V0IiwiaXNDbG9zZWRQcm9wZXJ0eSIsInJlc2lzdGFuY2UiLCJpc1JlYWwiLCJSRUFMX0JVTEJfQ09MRF9SRVNJU1RBTkNFIiwicmVzaXN0YW5jZVByb3BlcnR5IiwiTUlOSU1VTV9SRVNJU1RBTkNFIiwicmVzaXN0b3JBZGFwdGVyIiwibHRhQ2FwYWNpdG9yIiwibW5hVm9sdGFnZURyb3AiLCJtbmFDdXJyZW50IiwiY2FwYWNpdGFuY2VQcm9wZXJ0eSIsImx0YUluZHVjdG9yIiwiaW5kdWN0YW5jZVByb3BlcnR5IiwiYXNzZXJ0IiwiY29uc3RydWN0b3IiLCJuYW1lIiwibHRhQ2lyY3VpdCIsImNpcmN1aXRSZXN1bHQiLCJzb2x2ZVdpdGhTdWJkaXZpc2lvbnMiLCJqIiwiZ2V0IiwibG9nV2l0aEJhc2UiLCJiYXNlIiwiTWF0aCIsImxvZyIsImRWIiwiZ2V0RmluYWxTdGF0ZSIsImx0YVNvbHV0aW9uIiwiZ2V0Vm9sdGFnZSIsIm5vZGVJZDAiLCJub2RlSWQxIiwiViIsImFicyIsImNvZWZmaWNpZW50IiwiZm9yRWFjaCIsImJhdHRlcnlBZGFwdGVyIiwiY3VycmVudFByb3BlcnR5IiwiZ2V0VGltZUF2ZXJhZ2VDdXJyZW50Rm9yQ29yZU1vZGVsIiwiZ2V0VGltZUF2ZXJhZ2VDdXJyZW50IiwiY2FwYWNpdG9yIiwiY2xhbXBNYWduaXR1ZGUiLCJnZXRJbnN0YW50YW5lb3VzQ3VycmVudEZvckNvcmVNb2RlbCIsImdldEluc3RhbnRhbmVvdXNWb2x0YWdlRm9yQ29yZU1vZGVsIiwiaW5kdWN0b3IiLCJzb2x2ZWRWZXJ0aWNlcyIsInVuc29sdmVkVmVydGljZXMiLCJ2ZXJ0ZXhHcm91cCIsInZlcnRleCIsInZvbHRhZ2UiLCJnZXROb2RlVm9sdGFnZSIsInZpc2l0Vm9sdGFnZSIsInN0YXJ0VmVydGV4IiwiZW5kVmVydGV4IiwiaW5jbHVkZXMiLCJzaWduIiwidmlzaXRlZCIsImRmcyIsInZpc2l0IiwiY29udGFpbnNWZXJ0ZXgiLCJvcHBvc2l0ZSIsImdldE9wcG9zaXRlVmVydGV4IiwiYWxsVmVydGljZXMiLCJsb2NrZWQiLCJ2aXNpdEN1cnJlbnQiLCJjb25zZXJ2ZUN1cnJlbnQiLCJ2IiwidGFuZGVtIiwicGhldGlvSUQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkxpbmVhclRyYW5zaWVudEFuYWx5c2lzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE5LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFRha2VzIGEgQ2lyY3VpdCwgY3JlYXRlcyBhIGNvcnJlc3BvbmRpbmcgTFRBQ2lyY3VpdCwgc29sdmVzIHRoZSBMVEFDaXJjdWl0IGFuZCBhcHBsaWVzIHRoZSByZXN1bHRzIGJhY2tcclxuICogdG8gdGhlIG9yaWdpbmFsIENpcmN1aXQuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIFJlaWQgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IGNpcmN1aXRDb25zdHJ1Y3Rpb25LaXRDb21tb24gZnJvbSAnLi4vLi4vY2lyY3VpdENvbnN0cnVjdGlvbktpdENvbW1vbi5qcyc7XHJcbmltcG9ydCBDYXBhY2l0b3IgZnJvbSAnLi4vQ2FwYWNpdG9yLmpzJztcclxuaW1wb3J0IExUQUNpcmN1aXQgZnJvbSAnLi9MVEFDaXJjdWl0LmpzJztcclxuaW1wb3J0IEZ1c2UgZnJvbSAnLi4vRnVzZS5qcyc7XHJcbmltcG9ydCBJbmR1Y3RvciBmcm9tICcuLi9JbmR1Y3Rvci5qcyc7XHJcbmltcG9ydCBMaWdodEJ1bGIgZnJvbSAnLi4vTGlnaHRCdWxiLmpzJztcclxuaW1wb3J0IFJlc2lzdG9yIGZyb20gJy4uL1Jlc2lzdG9yLmpzJztcclxuaW1wb3J0IFNlcmllc0FtbWV0ZXIgZnJvbSAnLi4vU2VyaWVzQW1tZXRlci5qcyc7XHJcbmltcG9ydCBTd2l0Y2ggZnJvbSAnLi4vU3dpdGNoLmpzJztcclxuaW1wb3J0IFRpbWVzdGVwU3ViZGl2aXNpb25zIGZyb20gJy4vVGltZXN0ZXBTdWJkaXZpc2lvbnMuanMnO1xyXG5pbXBvcnQgVm9sdGFnZVNvdXJjZSBmcm9tICcuLi9Wb2x0YWdlU291cmNlLmpzJztcclxuaW1wb3J0IFdpcmUgZnJvbSAnLi4vV2lyZS5qcyc7XHJcbmltcG9ydCBDaXJjdWl0IGZyb20gJy4uL0NpcmN1aXQuanMnO1xyXG5pbXBvcnQgTFRBU3RhdGUgZnJvbSAnLi9MVEFTdGF0ZS5qcyc7XHJcbmltcG9ydCBWZXJ0ZXggZnJvbSAnLi4vVmVydGV4LmpzJztcclxuaW1wb3J0IENpcmN1aXRFbGVtZW50IGZyb20gJy4uL0NpcmN1aXRFbGVtZW50LmpzJztcclxuaW1wb3J0IENDS0NDb25zdGFudHMgZnJvbSAnLi4vLi4vQ0NLQ0NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBMVEFSZXNpc3RpdmVCYXR0ZXJ5IGZyb20gJy4vTFRBUmVzaXN0aXZlQmF0dGVyeS5qcyc7XHJcbmltcG9ydCBMVEFJbmR1Y3RvciBmcm9tICcuL0xUQUluZHVjdG9yLmpzJztcclxuaW1wb3J0IENDS0NVdGlscyBmcm9tICcuLi8uLi9DQ0tDVXRpbHMuanMnO1xyXG5pbXBvcnQgTFRBQ2FwYWNpdG9yIGZyb20gJy4vTFRBQ2FwYWNpdG9yLmpzJztcclxuaW1wb3J0IE1OQVJlc2lzdG9yIGZyb20gJy4vbW5hL01OQVJlc2lzdG9yLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBUSU1FU1RFUF9TVUJESVZJU0lPTlMgPSBuZXcgVGltZXN0ZXBTdWJkaXZpc2lvbnM8TFRBU3RhdGU+KCk7XHJcblxyXG5sZXQgaWQgPSAwO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZWFyVHJhbnNpZW50QW5hbHlzaXMge1xyXG5cclxuICAvKipcclxuICAgKiBTb2x2ZXMgdGhlIHN5c3RlbSB3aXRoIE1vZGlmaWVkIE5vZGFsIEFuYWx5c2lzLCBhbmQgYXBwbHkgdGhlIHJlc3VsdHMgYmFjayB0byB0aGUgQ2lyY3VpdC5cclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIHNvbHZlTW9kaWZpZWROb2RhbEFuYWx5c2lzKCBjaXJjdWl0OiBDaXJjdWl0LCBkdDogbnVtYmVyICk6IHZvaWQge1xyXG5cclxuICAgIGNvbnN0IGx0YUJhdHRlcmllcyA9IFtdO1xyXG4gICAgY29uc3QgbHRhUmVzaXN0b3JzID0gW107XHJcbiAgICBjb25zdCBsdGFDYXBhY2l0b3JzID0gW107XHJcbiAgICBjb25zdCBsdGFJbmR1Y3RvcnMgPSBbXTtcclxuXHJcbiAgICAvLyBJZGVudGlmeSBDaXJjdWl0RWxlbWVudHMgdGhhdCBhcmUgbm90IGluIGEgbG9vcCB3aXRoIGEgdm9sdGFnZSBzb3VyY2UuIFRoZXkgd2lsbCBoYXZlIHRoZWlyIGN1cnJlbnRzIHplcm9lZCBvdXQuXHJcbiAgICBjb25zdCBub25QYXJ0aWNpcGFudHMgPSBbXTtcclxuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IFtdO1xyXG5cclxuICAgIGNvbnN0IHJlc2lzdG9yTWFwID0gbmV3IE1hcDxNTkFSZXNpc3RvciwgQ2lyY3VpdEVsZW1lbnQ+KCk7IC8vIFNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSBSZXNpc3RvciB8IEZ1c2UgfCBXaXJlIHwgTGlnaHRCdWxiIHwgU2VyaWVzQW1tZXRlciB8IFN3aXRjaFxyXG4gICAgY29uc3Qgdm9sdGFnZVNvdXJjZU1hcCA9IG5ldyBNYXA8TFRBUmVzaXN0aXZlQmF0dGVyeSwgVm9sdGFnZVNvdXJjZT4oKTtcclxuICAgIGNvbnN0IGNhcGFjaXRvck1hcCA9IG5ldyBNYXA8TFRBQ2FwYWNpdG9yLCBDYXBhY2l0b3I+KCk7XHJcbiAgICBjb25zdCBpbmR1Y3Rvck1hcCA9IG5ldyBNYXA8TFRBSW5kdWN0b3IsIEluZHVjdG9yPigpO1xyXG5cclxuICAgIGxldCBoYXNSZWFsQnVsYnMgPSBmYWxzZTtcclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGNpcmN1aXQuY2lyY3VpdEVsZW1lbnRzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICBjb25zdCBjaXJjdWl0RWxlbWVudCA9IGNpcmN1aXQuY2lyY3VpdEVsZW1lbnRzWyBpIF07XHJcblxyXG4gICAgICBjb25zdCBpbkxvb3AgPSBjaXJjdWl0LmlzSW5Mb29wKCBjaXJjdWl0RWxlbWVudCApO1xyXG5cclxuICAgICAgaWYgKCBpbkxvb3AgKSB7XHJcbiAgICAgICAgcGFydGljaXBhbnRzLnB1c2goIGNpcmN1aXRFbGVtZW50ICk7XHJcbiAgICAgICAgaWYgKCBjaXJjdWl0RWxlbWVudCBpbnN0YW5jZW9mIFZvbHRhZ2VTb3VyY2UgKSB7XHJcbiAgICAgICAgICBjb25zdCBsdGFWb2x0YWdlU291cmNlID0gbmV3IExUQVJlc2lzdGl2ZUJhdHRlcnkoXHJcbiAgICAgICAgICAgIGlkKyssXHJcbiAgICAgICAgICAgIGNpcmN1aXRFbGVtZW50LnN0YXJ0VmVydGV4UHJvcGVydHkudmFsdWUuaW5kZXggKyAnJyxcclxuICAgICAgICAgICAgY2lyY3VpdEVsZW1lbnQuZW5kVmVydGV4UHJvcGVydHkudmFsdWUuaW5kZXggKyAnJyxcclxuICAgICAgICAgICAgY2lyY3VpdEVsZW1lbnQudm9sdGFnZVByb3BlcnR5LnZhbHVlLFxyXG4gICAgICAgICAgICBjaXJjdWl0RWxlbWVudC5pbnRlcm5hbFJlc2lzdGFuY2VQcm9wZXJ0eS52YWx1ZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHZvbHRhZ2VTb3VyY2VNYXAuc2V0KCBsdGFWb2x0YWdlU291cmNlLCBjaXJjdWl0RWxlbWVudCApO1xyXG4gICAgICAgICAgbHRhQmF0dGVyaWVzLnB1c2goIGx0YVZvbHRhZ2VTb3VyY2UgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIGNpcmN1aXRFbGVtZW50IGluc3RhbmNlb2YgUmVzaXN0b3IgfHxcclxuICAgICAgICAgICAgICAgICAgY2lyY3VpdEVsZW1lbnQgaW5zdGFuY2VvZiBGdXNlIHx8XHJcbiAgICAgICAgICAgICAgICAgIGNpcmN1aXRFbGVtZW50IGluc3RhbmNlb2YgV2lyZSB8fFxyXG4gICAgICAgICAgICAgICAgICBjaXJjdWl0RWxlbWVudCBpbnN0YW5jZW9mIExpZ2h0QnVsYiB8fFxyXG4gICAgICAgICAgICAgICAgICBjaXJjdWl0RWxlbWVudCBpbnN0YW5jZW9mIFNlcmllc0FtbWV0ZXIgfHxcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIG5vIGNsb3NlZCBjaXJjdWl0IHRoZXJlOyBzZWUgYmVsb3cgd2hlcmUgY3VycmVudCBpcyB6ZXJvZWQgb3V0XHJcbiAgICAgICAgICAgICAgICAgICggY2lyY3VpdEVsZW1lbnQgaW5zdGFuY2VvZiBTd2l0Y2ggJiYgY2lyY3VpdEVsZW1lbnQuaXNDbG9zZWRQcm9wZXJ0eS52YWx1ZSApICkge1xyXG5cclxuICAgICAgICAgIC8vIEZvciByZWFsIGJ1bGJzLCB3ZSBydW4gYW4gaW5pdGlhbCBjaXJjdWl0IHNvbHV0aW9uIHRvIGRldGVybWluZSB0aGVpciBvcGVyYXRpbmcgY2hhcmFjdGVyaXN0aWNzLlxyXG4gICAgICAgICAgLy8gVGhlc2Ugb3BlcmF0aW5nIGNoYXJhY3RlcmlzdGljcyBhcmUgdGhlbiB1c2VkIGluIGEgc2Vjb25kIHNvbHV0aW9uIHRvIHByZXZlbnQgYSBoeXN0ZXJlc2lzLlxyXG5cclxuICAgICAgICAgIC8vIElmIGEgcmVzaXN0b3IgZ29lcyB0byAwIHJlc2lzdGFuY2UsIHRoZW4gd2UgY2Fubm90IGNvbXB1dGUgdGhlIGN1cnJlbnQgdGhyb3VnaCBhcyBJPVYvUi4gIFRoZXJlZm9yZSxcclxuICAgICAgICAgIC8vIHNpbXVsYXRlIGEgc21hbGwgYW1vdW50IG9mIHJlc2lzdGFuY2UuXHJcbiAgICAgICAgICBjb25zdCByZXNpc3RhbmNlID0gKCBjaXJjdWl0RWxlbWVudCBpbnN0YW5jZW9mIExpZ2h0QnVsYiAmJiBjaXJjdWl0RWxlbWVudC5pc1JlYWwgKSA/IExpZ2h0QnVsYi5SRUFMX0JVTEJfQ09MRF9SRVNJU1RBTkNFIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGNpcmN1aXRFbGVtZW50LnJlc2lzdGFuY2VQcm9wZXJ0eS52YWx1ZSB8fCBDQ0tDQ29uc3RhbnRzLk1JTklNVU1fUkVTSVNUQU5DRSApO1xyXG5cclxuICAgICAgICAgIGlmICggY2lyY3VpdEVsZW1lbnQgaW5zdGFuY2VvZiBMaWdodEJ1bGIgJiYgY2lyY3VpdEVsZW1lbnQuaXNSZWFsICkge1xyXG4gICAgICAgICAgICBoYXNSZWFsQnVsYnMgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IHJlc2lzdG9yQWRhcHRlciA9IG5ldyBNTkFSZXNpc3RvcihcclxuICAgICAgICAgICAgY2lyY3VpdEVsZW1lbnQuc3RhcnRWZXJ0ZXhQcm9wZXJ0eS52YWx1ZS5pbmRleCArICcnLFxyXG4gICAgICAgICAgICBjaXJjdWl0RWxlbWVudC5lbmRWZXJ0ZXhQcm9wZXJ0eS52YWx1ZS5pbmRleCArICcnLFxyXG4gICAgICAgICAgICByZXNpc3RhbmNlXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgcmVzaXN0b3JNYXAuc2V0KCByZXNpc3RvckFkYXB0ZXIsIGNpcmN1aXRFbGVtZW50ICk7XHJcbiAgICAgICAgICBsdGFSZXNpc3RvcnMucHVzaCggcmVzaXN0b3JBZGFwdGVyICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCBjaXJjdWl0RWxlbWVudCBpbnN0YW5jZW9mIFN3aXRjaCAmJiAhY2lyY3VpdEVsZW1lbnQuaXNDbG9zZWRQcm9wZXJ0eS52YWx1ZSApIHtcclxuXHJcbiAgICAgICAgICAvLyBubyBlbGVtZW50IGZvciBhbiBvcGVuIHN3aXRjaFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICggY2lyY3VpdEVsZW1lbnQgaW5zdGFuY2VvZiBDYXBhY2l0b3IgKSB7XHJcblxyXG4gICAgICAgICAgY29uc3QgbHRhQ2FwYWNpdG9yID0gbmV3IExUQUNhcGFjaXRvcihcclxuICAgICAgICAgICAgaWQrKyxcclxuICAgICAgICAgICAgY2lyY3VpdEVsZW1lbnQuc3RhcnRWZXJ0ZXhQcm9wZXJ0eS52YWx1ZS5pbmRleCArICcnLFxyXG4gICAgICAgICAgICBjaXJjdWl0RWxlbWVudC5lbmRWZXJ0ZXhQcm9wZXJ0eS52YWx1ZS5pbmRleCArICcnLFxyXG4gICAgICAgICAgICBjaXJjdWl0RWxlbWVudC5tbmFWb2x0YWdlRHJvcCxcclxuICAgICAgICAgICAgY2lyY3VpdEVsZW1lbnQubW5hQ3VycmVudCxcclxuICAgICAgICAgICAgY2lyY3VpdEVsZW1lbnQuY2FwYWNpdGFuY2VQcm9wZXJ0eS52YWx1ZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGx0YUNhcGFjaXRvcnMucHVzaCggbHRhQ2FwYWNpdG9yICk7XHJcbiAgICAgICAgICBjYXBhY2l0b3JNYXAuc2V0KCBsdGFDYXBhY2l0b3IsIGNpcmN1aXRFbGVtZW50ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCBjaXJjdWl0RWxlbWVudCBpbnN0YW5jZW9mIEluZHVjdG9yICkge1xyXG5cclxuICAgICAgICAgIGNvbnN0IGx0YUluZHVjdG9yID0gbmV3IExUQUluZHVjdG9yKFxyXG4gICAgICAgICAgICBpZCsrLFxyXG4gICAgICAgICAgICBjaXJjdWl0RWxlbWVudC5zdGFydFZlcnRleFByb3BlcnR5LnZhbHVlLmluZGV4ICsgJycsXHJcbiAgICAgICAgICAgIGNpcmN1aXRFbGVtZW50LmVuZFZlcnRleFByb3BlcnR5LnZhbHVlLmluZGV4ICsgJycsXHJcbiAgICAgICAgICAgIGNpcmN1aXRFbGVtZW50Lm1uYVZvbHRhZ2VEcm9wLFxyXG4gICAgICAgICAgICBjaXJjdWl0RWxlbWVudC5tbmFDdXJyZW50LFxyXG4gICAgICAgICAgICBjaXJjdWl0RWxlbWVudC5pbmR1Y3RhbmNlUHJvcGVydHkudmFsdWVcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBpbmR1Y3Rvck1hcC5zZXQoIGx0YUluZHVjdG9yLCBjaXJjdWl0RWxlbWVudCApO1xyXG4gICAgICAgICAgbHRhSW5kdWN0b3JzLnB1c2goIGx0YUluZHVjdG9yICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsIGBUeXBlIG5vdCBmb3VuZDogJHtjaXJjdWl0RWxlbWVudC5jb25zdHJ1Y3Rvci5uYW1lfWAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbm9uUGFydGljaXBhbnRzLnB1c2goIGNpcmN1aXRFbGVtZW50ICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTb2x2ZSB0aGUgc3lzdGVtXHJcbiAgICBsZXQgbHRhQ2lyY3VpdCA9IG5ldyBMVEFDaXJjdWl0KCBsdGFSZXNpc3RvcnMsIGx0YUJhdHRlcmllcywgbHRhQ2FwYWNpdG9ycywgbHRhSW5kdWN0b3JzICk7XHJcbiAgICBsZXQgY2lyY3VpdFJlc3VsdCA9IGx0YUNpcmN1aXQuc29sdmVXaXRoU3ViZGl2aXNpb25zKCBUSU1FU1RFUF9TVUJESVZJU0lPTlMsIGR0ICk7XHJcblxyXG4gICAgLy8gdGhlIHJlc2lzdGFuY2Ugb2YgcmVhbCBidWxicyBpcyBhIGZ1bmN0aW9uIG9mIHRoZWlyIHZvbHRhZ2VcclxuICAgIGlmICggaGFzUmVhbEJ1bGJzICkge1xyXG5cclxuICAgICAgLy8gdG8gZXN0aW1hdGUgdGhlIHJlc2lzdGFuY2Ugb2YgYSByZWFsIGJ1bGIsIHdlIHN0YXJ0IGJ5IHNldHRpbmcgaXRzIHJlc2lzdGFuY2UgdG8gUkVBTF9CVUxCX0NPTERfUkVTSVNUQU5DRVxyXG4gICAgICAvLyB0aGVuIHdlIHNvbHZlIHRoZSBjaXJjdWl0IHRvIGZpbmQgdGhlIHZvbHRhZ2UgYWNyb3NzIGl0LCBhbmQgdXBkYXRlIGl0cyByZXNpc3RhbmNlIGFjY29yZGluZyB0byB0aGUgbG9nIGVxdWF0aW9uIGJlbG93XHJcbiAgICAgIC8vIHdlIHJlcGVhdCB0aGlzIHByb2Nlc3MgMTAgdGltZXMgdG8gZ2V0IGNsb3NlciB0byB0aGUgYnVsYidzIGFjdHVhbCB2b2x0YWdlIGFuZCByZXNpc3RhbmNlXHJcbiAgICAgIC8vIGluIHRlc3RpbmcsIHdlIGZvdW5kIHRoYXQgMTAgaXRlcmF0aW9ucyBicmluZ3MgdGhlIHJlYWwgYnVsYiB0byB3aXRoaW4gYW4gYWNjZXB0YWJsZSByYW5nZSBvZiB0aGUgYWNjdXJhdGUgcmVzaXN0YW5jZVxyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCAxMDsgaSsrICkge1xyXG4gICAgICAgIGZvciAoIGxldCBqID0gMDsgaiA8IGx0YVJlc2lzdG9ycy5sZW5ndGg7IGorKyApIHtcclxuXHJcbiAgICAgICAgICBjb25zdCByZXNpc3RvckFkYXB0ZXIgPSBsdGFSZXNpc3RvcnNbIGogXTtcclxuICAgICAgICAgIGNvbnN0IGNpcmN1aXRFbGVtZW50ID0gcmVzaXN0b3JNYXAuZ2V0KCByZXNpc3RvckFkYXB0ZXIgKSE7XHJcbiAgICAgICAgICBpZiAoIGNpcmN1aXRFbGVtZW50IGluc3RhbmNlb2YgTGlnaHRCdWxiICYmIGNpcmN1aXRFbGVtZW50LmlzUmVhbCApIHtcclxuICAgICAgICAgICAgY29uc3QgbG9nV2l0aEJhc2UgPSAoIHZhbHVlOiBudW1iZXIsIGJhc2U6IG51bWJlciApID0+IE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5sb2coIGJhc2UgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGRWID0gY2lyY3VpdFJlc3VsdC5nZXRGaW5hbFN0YXRlKCkubHRhU29sdXRpb24hLmdldFZvbHRhZ2UoIHJlc2lzdG9yQWRhcHRlci5ub2RlSWQwLCByZXNpc3RvckFkYXB0ZXIubm9kZUlkMSApO1xyXG4gICAgICAgICAgICBjb25zdCBWID0gTWF0aC5hYnMoIGRWICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBiYXNlID0gMjtcclxuXHJcbiAgICAgICAgICAgIC8vIEkgPSBsbihWKVxyXG4gICAgICAgICAgICAvLyBWPUlSXHJcbiAgICAgICAgICAgIC8vIFY9bG4oVilSXHJcbiAgICAgICAgICAgIC8vIFIgPSBWL2xuKFYpXHJcblxyXG4gICAgICAgICAgICAvLyBBZGp1c3Qgc28gaXQgbG9va3MgZ29vZCBpbiBjb21wYXJpc29uIHRvIGEgc3RhbmRhcmQgYnVsYlxyXG4gICAgICAgICAgICBjb25zdCBjb2VmZmljaWVudCA9IDM7XHJcblxyXG4gICAgICAgICAgICAvLyBzaGlmdCBieSBiYXNlIHNvIGF0IFY9MCB0aGUgbG9nIGlzIDFcclxuICAgICAgICAgICAgcmVzaXN0b3JBZGFwdGVyLnJlc2lzdGFuY2UgPSBMaWdodEJ1bGIuUkVBTF9CVUxCX0NPTERfUkVTSVNUQU5DRSArIGNvZWZmaWNpZW50ICogViAvIGxvZ1dpdGhCYXNlKCBWICsgYmFzZSwgYmFzZSApO1xyXG4gICAgICAgICAgICBjaXJjdWl0RWxlbWVudC5yZXNpc3RhbmNlUHJvcGVydHkudmFsdWUgPSByZXNpc3RvckFkYXB0ZXIucmVzaXN0YW5jZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBjaXJjdWl0IGNvbnRhaW5zIHJlYWwgYnVsYnMsIHdlIG5lZWQgdG8gc29sdmUgdGhlIGNpcmN1aXQgYWdhaW4gYWZ0ZXIgY2FsY3VsYXRpbmcgdGhlaXIgcmVzaXN0YW5jZVxyXG4gICAgICAgIC8vIHRvIHByZXZlbnQgYSBoeXN0ZXJlc2lzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgcmVzaXN0YW5jZSBvZiB0aGUgYnVsYnMgaXMgY29uc2lzdGVudCB3aXRoIHRoZWlyIHZvbHRhZ2UuXHJcbiAgICAgICAgbHRhQ2lyY3VpdCA9IG5ldyBMVEFDaXJjdWl0KCBsdGFSZXNpc3RvcnMsIGx0YUJhdHRlcmllcywgbHRhQ2FwYWNpdG9ycywgbHRhSW5kdWN0b3JzICk7XHJcbiAgICAgICAgY2lyY3VpdFJlc3VsdCA9IGx0YUNpcmN1aXQuc29sdmVXaXRoU3ViZGl2aXNpb25zKCBUSU1FU1RFUF9TVUJESVZJU0lPTlMsIGR0ICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBcHBseSB0aGUgc29sdXRpb25zIGZyb20gdGhlIGFuYWx5c2lzIGJhY2sgdG8gdGhlIGFjdHVhbCBDaXJjdWl0XHJcbiAgICBsdGFCYXR0ZXJpZXMuZm9yRWFjaCggYmF0dGVyeUFkYXB0ZXIgPT4ge1xyXG4gICAgICBjb25zdCBjaXJjdWl0RWxlbWVudCA9IHZvbHRhZ2VTb3VyY2VNYXAuZ2V0KCBiYXR0ZXJ5QWRhcHRlciApITtcclxuICAgICAgY2lyY3VpdEVsZW1lbnQuY3VycmVudFByb3BlcnR5LnZhbHVlID0gY2lyY3VpdFJlc3VsdC5nZXRUaW1lQXZlcmFnZUN1cnJlbnRGb3JDb3JlTW9kZWwoIGJhdHRlcnlBZGFwdGVyICk7XHJcbiAgICB9ICk7XHJcbiAgICBsdGFSZXNpc3RvcnMuZm9yRWFjaCggcmVzaXN0b3JBZGFwdGVyID0+IHtcclxuICAgICAgY29uc3QgY2lyY3VpdEVsZW1lbnQgPSByZXNpc3Rvck1hcC5nZXQoIHJlc2lzdG9yQWRhcHRlciApITtcclxuICAgICAgY2lyY3VpdEVsZW1lbnQuY3VycmVudFByb3BlcnR5LnZhbHVlID0gY2lyY3VpdFJlc3VsdC5nZXRUaW1lQXZlcmFnZUN1cnJlbnQoIHJlc2lzdG9yQWRhcHRlciApO1xyXG4gICAgfSApO1xyXG4gICAgbHRhQ2FwYWNpdG9ycy5mb3JFYWNoKCBsdGFDYXBhY2l0b3IgPT4ge1xyXG4gICAgICBjb25zdCBjYXBhY2l0b3IgPSBjYXBhY2l0b3JNYXAuZ2V0KCBsdGFDYXBhY2l0b3IgKSE7XHJcbiAgICAgIGNhcGFjaXRvci5jdXJyZW50UHJvcGVydHkudmFsdWUgPSBjaXJjdWl0UmVzdWx0LmdldFRpbWVBdmVyYWdlQ3VycmVudEZvckNvcmVNb2RlbCggbHRhQ2FwYWNpdG9yICk7XHJcbiAgICAgIGNhcGFjaXRvci5tbmFDdXJyZW50ID0gQ0NLQ1V0aWxzLmNsYW1wTWFnbml0dWRlKCBjaXJjdWl0UmVzdWx0LmdldEluc3RhbnRhbmVvdXNDdXJyZW50Rm9yQ29yZU1vZGVsKCBsdGFDYXBhY2l0b3IgKSApO1xyXG4gICAgICBjYXBhY2l0b3IubW5hVm9sdGFnZURyb3AgPSBDQ0tDVXRpbHMuY2xhbXBNYWduaXR1ZGUoIGNpcmN1aXRSZXN1bHQuZ2V0SW5zdGFudGFuZW91c1ZvbHRhZ2VGb3JDb3JlTW9kZWwoIGx0YUNhcGFjaXRvciApICk7XHJcblxyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBNYXRoLmFicyggY2FwYWNpdG9yLm1uYUN1cnJlbnQgKSA8IDFFMTAwLCAnbW5hQ3VycmVudCBvdXQgb2YgcmFuZ2UnICk7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIE1hdGguYWJzKCBjYXBhY2l0b3IubW5hVm9sdGFnZURyb3AgKSA8IDFFMTAwLCAnbW5hVm9sdGFnZURyb3Agb3V0IG9mIHJhbmdlJyApO1xyXG4gICAgfSApO1xyXG4gICAgbHRhSW5kdWN0b3JzLmZvckVhY2goIGx0YUluZHVjdG9yID0+IHtcclxuXHJcbiAgICAgIGNvbnN0IGluZHVjdG9yID0gaW5kdWN0b3JNYXAuZ2V0KCBsdGFJbmR1Y3RvciApITtcclxuICAgICAgaW5kdWN0b3IuY3VycmVudFByb3BlcnR5LnZhbHVlID0gY2lyY3VpdFJlc3VsdC5nZXRUaW1lQXZlcmFnZUN1cnJlbnRGb3JDb3JlTW9kZWwoIGx0YUluZHVjdG9yICk7XHJcbiAgICAgIGluZHVjdG9yLm1uYUN1cnJlbnQgPSBDQ0tDVXRpbHMuY2xhbXBNYWduaXR1ZGUoIGNpcmN1aXRSZXN1bHQuZ2V0SW5zdGFudGFuZW91c0N1cnJlbnRGb3JDb3JlTW9kZWwoIGx0YUluZHVjdG9yICkgKTtcclxuICAgICAgaW5kdWN0b3IubW5hVm9sdGFnZURyb3AgPSBDQ0tDVXRpbHMuY2xhbXBNYWduaXR1ZGUoIGNpcmN1aXRSZXN1bHQuZ2V0SW5zdGFudGFuZW91c1ZvbHRhZ2VGb3JDb3JlTW9kZWwoIGx0YUluZHVjdG9yICkgKTtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggTWF0aC5hYnMoIGluZHVjdG9yLm1uYUN1cnJlbnQgKSA8IDFFMTAwLCAnbW5hQ3VycmVudCBvdXQgb2YgcmFuZ2UnICk7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIE1hdGguYWJzKCBpbmR1Y3Rvci5tbmFWb2x0YWdlRHJvcCApIDwgMUUxMDAsICdtbmFWb2x0YWdlRHJvcCBvdXQgb2YgcmFuZ2UnICk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gemVybyBvdXQgY3VycmVudHMgb24gb3BlbiBicmFuY2hlc1xyXG4gICAgbm9uUGFydGljaXBhbnRzLmZvckVhY2goIGNpcmN1aXRFbGVtZW50ID0+IHtcclxuICAgICAgY2lyY3VpdEVsZW1lbnQuY3VycmVudFByb3BlcnR5LnZhbHVlID0gMDtcclxuXHJcbiAgICAgIC8vIENsZWFyIGRpc2Nvbm5lY3RlZCBpc1JlYWwgbGlnaHQgYnVsYnNcclxuICAgICAgaWYgKCBjaXJjdWl0RWxlbWVudCBpbnN0YW5jZW9mIExpZ2h0QnVsYiAmJiBjaXJjdWl0RWxlbWVudC5pc1JlYWwgKSB7XHJcbiAgICAgICAgY2lyY3VpdEVsZW1lbnQucmVzaXN0YW5jZVByb3BlcnR5LnZhbHVlID0gTGlnaHRCdWxiLlJFQUxfQlVMQl9DT0xEX1JFU0lTVEFOQ0U7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICBjb25zdCBzb2x2ZWRWZXJ0aWNlczogVmVydGV4W10gPSBbXTtcclxuICAgIGNvbnN0IHVuc29sdmVkVmVydGljZXM6IFZlcnRleFtdID0gW107XHJcblxyXG4gICAgLy8gQXBwbHkgdGhlIG5vZGUgdm9sdGFnZXMgdG8gdGhlIHZlcnRpY2VzXHJcbiAgICBjaXJjdWl0LnZlcnRleEdyb3VwLmZvckVhY2goIHZlcnRleCA9PiB7XHJcbiAgICAgIGNvbnN0IHZvbHRhZ2UgPSBjaXJjdWl0UmVzdWx0LmdldEZpbmFsU3RhdGUoKS5sdGFTb2x1dGlvbiEuZ2V0Tm9kZVZvbHRhZ2UoIHZlcnRleC5pbmRleCArICcnICk7XHJcblxyXG4gICAgICBpZiAoIHR5cGVvZiB2b2x0YWdlID09PSAnbnVtYmVyJyApIHtcclxuICAgICAgICB2ZXJ0ZXgudm9sdGFnZVByb3BlcnR5LnZhbHVlID0gLXZvbHRhZ2U7XHJcbiAgICAgICAgc29sdmVkVmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdW5zb2x2ZWRWZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIGNvbXB1dGUgdm9sdGFnZXMgZm9yIG9wZW4gYnJhbmNoZXNcclxuICAgIC8vIGZvciBlYWNoIGNvbm5lY3RlZCBjb21wb25lbnQsIHN0YXJ0IGF0IGEga25vd24gdm9sdGFnZSBhbmQgZGVwdGggZmlyc3Qgc2VhcmNoIHRoZSBncmFwaC5cclxuICAgIGNvbnN0IHZpc2l0Vm9sdGFnZSA9ICggc3RhcnRWZXJ0ZXg6IFZlcnRleCwgY2lyY3VpdEVsZW1lbnQ6IENpcmN1aXRFbGVtZW50LCBlbmRWZXJ0ZXg6IFZlcnRleCApID0+IHtcclxuXHJcbiAgICAgIC8vIElmIHdlIGFscmVhZHkga25vdyB0aGUgdm9sdGFnZSBmcm9tIHRoZSBtYXRyaXggc29sdXRpb24sIHNraXAgaXQuXHJcbiAgICAgIGlmICggIXNvbHZlZFZlcnRpY2VzLmluY2x1ZGVzKCBlbmRWZXJ0ZXggKSApIHtcclxuXHJcbiAgICAgICAgY29uc3Qgc2lnbiA9IHN0YXJ0VmVydGV4ID09PSBjaXJjdWl0RWxlbWVudC5zdGFydFZlcnRleFByb3BlcnR5LnZhbHVlID8gMSA6IC0xO1xyXG5cclxuICAgICAgICAvLyBjb21wdXRlIGVuZCB2b2x0YWdlIGZyb20gc3RhcnQgdm9sdGFnZVxyXG4gICAgICAgIGlmICggY2lyY3VpdEVsZW1lbnQgaW5zdGFuY2VvZiBSZXNpc3RvciB8fCBjaXJjdWl0RWxlbWVudCBpbnN0YW5jZW9mIFdpcmUgfHwgY2lyY3VpdEVsZW1lbnQgaW5zdGFuY2VvZiBMaWdodEJ1bGIgfHxcclxuICAgICAgICAgICAgICggY2lyY3VpdEVsZW1lbnQgaW5zdGFuY2VvZiBTd2l0Y2ggJiYgY2lyY3VpdEVsZW1lbnQuaXNDbG9zZWRQcm9wZXJ0eS52YWx1ZSApIHx8IGNpcmN1aXRFbGVtZW50IGluc3RhbmNlb2YgRnVzZSB8fFxyXG4gICAgICAgICAgICAgY2lyY3VpdEVsZW1lbnQgaW5zdGFuY2VvZiBTZXJpZXNBbW1ldGVyXHJcbiAgICAgICAgKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW4gdGhlIGdlbmVyYWwgY2FzZSwgd2Ugd291bGQgbmVlZCBWPUlSIHRvIGNvbXB1dGUgdGhlIHZvbHRhZ2UgZHJvcCwgYnV0IHdlIGtub3cgdGhlIGN1cnJlbnQgYWNyb3NzIHRoZVxyXG4gICAgICAgICAgLy8gbm9uLXBhcnRpY2lwYW50cyBpcyAwLCBzbyB0aGUgdm9sdGFnZSBkcm9wIGFjcm9zcyB0aGVtIGlzIGFsc28gemVyb1xyXG4gICAgICAgICAgZW5kVmVydGV4LnZvbHRhZ2VQcm9wZXJ0eS52YWx1ZSA9IHN0YXJ0VmVydGV4LnZvbHRhZ2VQcm9wZXJ0eS52YWx1ZTtcclxuICAgICAgICAgIHNvbHZlZFZlcnRpY2VzLnB1c2goIGVuZFZlcnRleCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICggY2lyY3VpdEVsZW1lbnQgaW5zdGFuY2VvZiBWb2x0YWdlU291cmNlICkge1xyXG4gICAgICAgICAgZW5kVmVydGV4LnZvbHRhZ2VQcm9wZXJ0eS52YWx1ZSA9IHN0YXJ0VmVydGV4LnZvbHRhZ2VQcm9wZXJ0eS52YWx1ZSArIHNpZ24gKiBjaXJjdWl0RWxlbWVudC52b2x0YWdlUHJvcGVydHkudmFsdWU7XHJcbiAgICAgICAgICBzb2x2ZWRWZXJ0aWNlcy5wdXNoKCBlbmRWZXJ0ZXggKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIGNpcmN1aXRFbGVtZW50IGluc3RhbmNlb2YgQ2FwYWNpdG9yIHx8IGNpcmN1aXRFbGVtZW50IGluc3RhbmNlb2YgSW5kdWN0b3IgKSB7XHJcbiAgICAgICAgICBlbmRWZXJ0ZXgudm9sdGFnZVByb3BlcnR5LnZhbHVlID0gc3RhcnRWZXJ0ZXgudm9sdGFnZVByb3BlcnR5LnZhbHVlIC0gc2lnbiAqIGNpcmN1aXRFbGVtZW50Lm1uYVZvbHRhZ2VEcm9wO1xyXG4gICAgICAgICAgc29sdmVkVmVydGljZXMucHVzaCggZW5kVmVydGV4ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCBjaXJjdWl0RWxlbWVudCBpbnN0YW5jZW9mIFN3aXRjaCAmJiAhY2lyY3VpdEVsZW1lbnQuaXNDbG9zZWRQcm9wZXJ0eS52YWx1ZSApIHtcclxuICAgICAgICAgIC8vIGZvciBhbiBvcGVuIHN3aXRjaCwgdGhlIG5vZGUgdm9sdGFnZXMgYXJlIGluZGVwZW5kZW50XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsICd1bmtub3duIGNpcmN1aXQgZWxlbWVudCB0eXBlOiAnICsgY2lyY3VpdEVsZW1lbnQuY29uc3RydWN0b3IubmFtZSApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB2aXNpdGVkOiBWZXJ0ZXhbXSA9IFtdO1xyXG4gICAgY29uc3QgZGZzID0gKCB2ZXJ0ZXg6IFZlcnRleCwgdmlzaXQ6ICggdjogVmVydGV4LCBjaXJjdWl0RWxlbWVudDogQ2lyY3VpdEVsZW1lbnQsIG9wcG9zaXRlOiBWZXJ0ZXggKSA9PiB2b2lkICkgPT4ge1xyXG4gICAgICB2aXNpdGVkLnB1c2goIHZlcnRleCApO1xyXG4gICAgICBjaXJjdWl0LmNpcmN1aXRFbGVtZW50cy5mb3JFYWNoKCBjaXJjdWl0RWxlbWVudCA9PiB7XHJcbiAgICAgICAgaWYgKCBjaXJjdWl0RWxlbWVudC5jb250YWluc1ZlcnRleCggdmVydGV4ICkgKSB7XHJcbiAgICAgICAgICBjb25zdCBvcHBvc2l0ZSA9IGNpcmN1aXRFbGVtZW50LmdldE9wcG9zaXRlVmVydGV4KCB2ZXJ0ZXggKTtcclxuICAgICAgICAgIGlmICggIXZpc2l0ZWQuaW5jbHVkZXMoIG9wcG9zaXRlICkgJiYgISggY2lyY3VpdEVsZW1lbnQgaW5zdGFuY2VvZiBTd2l0Y2ggJiYgIWNpcmN1aXRFbGVtZW50LmlzQ2xvc2VkUHJvcGVydHkudmFsdWUgKSApIHtcclxuICAgICAgICAgICAgdmlzaXQoIHZlcnRleCwgY2lyY3VpdEVsZW1lbnQsIG9wcG9zaXRlICk7XHJcbiAgICAgICAgICAgIGRmcyggb3Bwb3NpdGUsIHZpc2l0ICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9ICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFN0YXJ0IHZpc2l0aW5nIGZyb20gdGhlIHNvbHZlZCB2ZXJ0aWNlcywgc2luY2UgdGhleSBoYXZlIHRoZSBncm91bmQgdHJ1dGguICBIYXZlIHRvIHZpc2l0IGVhY2ggdG8gbWFrZSBzdXJlXHJcbiAgICAvLyB3ZSB0cmF2ZWxlZCB0byBhbGwgZGlzY29ubmVjdGVkIGNvbXBvbmVudHNcclxuICAgIGNvbnN0IGFsbFZlcnRpY2VzID0gWyAuLi5zb2x2ZWRWZXJ0aWNlcywgLi4udW5zb2x2ZWRWZXJ0aWNlcyBdO1xyXG4gICAgYWxsVmVydGljZXMuZm9yRWFjaCggdmVydGV4ID0+IHtcclxuICAgICAgaWYgKCAhdmlzaXRlZC5pbmNsdWRlcyggdmVydGV4ICkgKSB7XHJcbiAgICAgICAgZGZzKCB2ZXJ0ZXgsIHZpc2l0Vm9sdGFnZSApO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gRGVwdGggZmlyc3Qgc2VhcmNoIGFjcm9zcyB0aGUgY2lyY3VpdCB0byBlbnN1cmUgY3VycmVudCBjb25zZXJ2ZWQgYXQgZWFjaCB2ZXJ0ZXhcclxuICAgIC8vIGNpcmN1aXQuY2hlY2tDdXJyZW50Q29uc2VydmF0aW9uKCAnYmVmb3JlJyApO1xyXG4gICAgY29uc3QgbG9ja2VkID0gWyAuLi5ub25QYXJ0aWNpcGFudHMgXTtcclxuICAgIGNvbnN0IHZpc2l0Q3VycmVudCA9ICggdmVydGV4OiBWZXJ0ZXggKSA9PiBjaXJjdWl0LmNvbnNlcnZlQ3VycmVudCggdmVydGV4LCBsb2NrZWQgKTtcclxuICAgIHZpc2l0ZWQubGVuZ3RoID0gMDtcclxuICAgIGFsbFZlcnRpY2VzLmZvckVhY2goIHZlcnRleCA9PiBkZnMoIHZlcnRleCwgdmlzaXRDdXJyZW50ICkgKTtcclxuICAgIC8vIGNpcmN1aXQuY2hlY2tDdXJyZW50Q29uc2VydmF0aW9uKCAnYWZ0ZXInICk7XHJcblxyXG4gICAgdW5zb2x2ZWRWZXJ0aWNlcy5mb3JFYWNoKCB2ID0+IHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdmlzaXRlZC5pbmNsdWRlcyggdiApLCAndW5zb2x2ZWQgdmVydGV4ICcgKyB2LnRhbmRlbS5waGV0aW9JRCArICcgc2hvdWxkIGJlIHZpc2l0ZWQuJyApO1xyXG4gICAgfSApO1xyXG4gIH1cclxufVxyXG5cclxuY2lyY3VpdENvbnN0cnVjdGlvbktpdENvbW1vbi5yZWdpc3RlciggJ0xpbmVhclRyYW5zaWVudEFuYWx5c2lzJywgTGluZWFyVHJhbnNpZW50QW5hbHlzaXMgKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSw0QkFBNEIsTUFBTSx1Q0FBdUM7QUFDaEYsT0FBT0MsU0FBUyxNQUFNLGlCQUFpQjtBQUN2QyxPQUFPQyxVQUFVLE1BQU0saUJBQWlCO0FBQ3hDLE9BQU9DLElBQUksTUFBTSxZQUFZO0FBQzdCLE9BQU9DLFFBQVEsTUFBTSxnQkFBZ0I7QUFDckMsT0FBT0MsU0FBUyxNQUFNLGlCQUFpQjtBQUN2QyxPQUFPQyxRQUFRLE1BQU0sZ0JBQWdCO0FBQ3JDLE9BQU9DLGFBQWEsTUFBTSxxQkFBcUI7QUFDL0MsT0FBT0MsTUFBTSxNQUFNLGNBQWM7QUFDakMsT0FBT0Msb0JBQW9CLE1BQU0sMkJBQTJCO0FBQzVELE9BQU9DLGFBQWEsTUFBTSxxQkFBcUI7QUFDL0MsT0FBT0MsSUFBSSxNQUFNLFlBQVk7QUFLN0IsT0FBT0MsYUFBYSxNQUFNLHdCQUF3QjtBQUNsRCxPQUFPQyxtQkFBbUIsTUFBTSwwQkFBMEI7QUFDMUQsT0FBT0MsV0FBVyxNQUFNLGtCQUFrQjtBQUMxQyxPQUFPQyxTQUFTLE1BQU0sb0JBQW9CO0FBQzFDLE9BQU9DLFlBQVksTUFBTSxtQkFBbUI7QUFDNUMsT0FBT0MsV0FBVyxNQUFNLHNCQUFzQjs7QUFFOUM7QUFDQSxNQUFNQyxxQkFB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