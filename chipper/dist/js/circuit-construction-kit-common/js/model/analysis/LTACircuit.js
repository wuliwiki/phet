// Copyright 2019-2022, University of Colorado Boulder

/**
 * There are two parts to solving a dynamic circuit:
 * 1. Splitting up dynamic components such as capacitors and inductors into their respective linear companion models.
 * 2. Adjusting the dt so that integration steps are accurate.  This is done through TimestepSubdivisions.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import CCKCQueryParameters from '../../CCKCQueryParameters.js';
import LTAStateSet from './LTAStateSet.js';
import circuitConstructionKitCommon from '../../circuitConstructionKitCommon.js';
import MNACircuit from './mna/MNACircuit.js';
import TimestepSubdivisions from './TimestepSubdivisions.js';
import LTASolution from './LTASolution.js';
import LTAState from './LTAState.js';
import LTAInductor from './LTAInductor.js';
import LTACapacitor from './LTACapacitor.js';
import MNABattery from './mna/MNABattery.js';
import MNAResistor from './mna/MNAResistor.js';
export default class LTACircuit {
  constructor(ltaResistors, ltaBatteries, ltaCapacitors, ltaInductors) {
    this.ltaResistors = ltaResistors;
    this.ltaBatteries = ltaBatteries;
    this.ltaCapacitors = ltaCapacitors;
    this.ltaInductors = ltaInductors;
  }

  /**
   * Solving the companion model is the same as propagating forward in time by dt.
   */
  solvePropagate(dt) {
    const companionBatteries = [];
    const companionResistors = [];
    const companionCurrents = [];
    const currentCompanions = [];

    // Node indices that have been used
    let syntheticNodeIndex = 0;

    // Each resistive battery is a resistor in series with a battery
    this.ltaBatteries.forEach(resistiveBatteryAdapter => {
      const newNode = 'syntheticNode' + syntheticNodeIndex++;
      const idealBattery = new MNABattery(resistiveBatteryAdapter.node0, newNode, resistiveBatteryAdapter.voltage); // final LinearCircuitSolver.Battery
      const idealResistor = new MNAResistor(newNode, resistiveBatteryAdapter.node1, resistiveBatteryAdapter.resistance); // LinearCircuitSolver.Resistor
      companionBatteries.push(idealBattery);
      companionResistors.push(idealResistor);

      // We need to be able to get the current for this component
      currentCompanions.push({
        element: resistiveBatteryAdapter,
        getValueForSolution: solution => solution.getSolvedCurrent(idealBattery)
      });
    });

    // Add companion models for capacitor

    // TRAPEZOIDAL: battery and resistor in series.
    // We use trapezoidal rather than backward Euler because we do not model current sources and it seems to work well.
    // See http://circsimproj.blogspot.com/2009/07/companion-models.html
    // Veq = V + dt*I/2/C;
    // Req = dt/2/C
    this.ltaCapacitors.forEach(ltaCapacitor => {
      assert && assert(dt >= 0, 'dt should be non-negative');
      const newNode1 = 'syntheticNode' + syntheticNodeIndex++;
      const newNode2 = 'syntheticNode' + syntheticNodeIndex++;
      const companionResistance = dt / 2.0 / ltaCapacitor.capacitance;
      const resistanceTerm = CCKCQueryParameters.capacitorResistance;

      // The capacitor is modeled as a battery in series with a resistor.  Hence the voltage drop across the capacitor
      // is equal to the voltage drop across the battery plus the voltage drop across the resistor.
      // V = Vbattery + Vresistor.  We need to solve for the voltage across the battery to use it in the companion
      // model, so we have Vbattery = V-Vresistor.  The magnitude of the voltage drop across the resistor is given by
      // |V|=|IReq| and sign is unchanged since the conventional current flows from high to low voltage.
      const companionVoltage = companionResistance * ltaCapacitor.current - ltaCapacitor.voltage;
      const battery = new MNABattery(ltaCapacitor.node0, newNode1, companionVoltage);
      const resistor = new MNAResistor(newNode1, newNode2, companionResistance);
      const resistor2 = new MNAResistor(newNode2, ltaCapacitor.node1, resistanceTerm);
      companionBatteries.push(battery);
      companionResistors.push(resistor);
      companionResistors.push(resistor2);
      ltaCapacitor.capacitorVoltageNode1 = newNode2;

      // We need to be able to get the current for this component. In series, so the current is the same through both.
      currentCompanions.push({
        element: ltaCapacitor,
        getValueForSolution: solution => solution.getCurrentForResistor(resistor)
      });
    });

    // See also http://circsimproj.blogspot.com/2009/07/companion-models.html, which reports:
    // Req = 2L/dt
    // Veq = -2Li/dt-v
    // See najm page 279 and Pillage page 86
    this.ltaInductors.forEach(ltaInductor => {
      // In series
      const newNode = 'syntheticNode' + syntheticNodeIndex++;
      const newNode2 = 'syntheticNode' + syntheticNodeIndex++;
      const companionResistance = 2 * ltaInductor.inductance / dt;
      const companionVoltage = ltaInductor.voltage + -companionResistance * ltaInductor.current;
      const battery = new MNABattery(ltaInductor.node0, newNode, companionVoltage);
      const resistor = new MNAResistor(newNode, newNode2, companionResistance);
      const addedResistor = new MNAResistor(newNode2, ltaInductor.node1, CCKCQueryParameters.inductorResistance);
      companionBatteries.push(battery);
      companionResistors.push(resistor);
      companionResistors.push(addedResistor);
      ltaInductor.inductorVoltageNode1 = newNode2;

      // we need to be able to get the current for this component
      // in series, so current is same through both companion components
      currentCompanions.push({
        element: ltaInductor,
        getValueForSolution: solution => solution.getCurrentForResistor(resistor)
      });
    });
    const newBatteryList = companionBatteries;
    const newResistorList = [...this.ltaResistors, ...companionResistors];
    const newCurrentList = companionCurrents;
    const mnaCircuit = new MNACircuit(newBatteryList, newResistorList, newCurrentList);
    const mnaSolution = mnaCircuit.solve();
    return new LTASolution(this, mnaSolution, currentCompanions);
  }
  solveWithSubdivisions(timestepSubdivisions, dt) {
    const steppable = {
      update: (a, dt) => a.update(dt),
      distance: (a, b) => euclideanDistance(a.getCharacteristicArray(), b.getCharacteristicArray())
    };

    // Turning the error threshold too low here can fail the inductor tests in MNATestCase
    const x = timestepSubdivisions.stepInTimeWithHistory(new LTAState(this, null), steppable, dt);
    return new LTAStateSet(x);
  }
  solveWithSubdivisions2(dt) {
    return this.solveWithSubdivisions(new TimestepSubdivisions(), dt);
  }
  updateWithSubdivisions(dt) {
    return this.solveWithSubdivisions2(dt).getFinalState().ltaCircuit;
  }
  solveItWithSubdivisions(dt) {
    return this.solveWithSubdivisions2(dt).getFinalState().ltaSolution;
  }
  update(dt) {
    return this.updateCircuit(this.solvePropagate(dt));
  }

  /**
   * Applies the specified solution to the circuit.
   */
  updateCircuit(solution) {
    const updatedCapacitors = this.ltaCapacitors.map(ltaCapacitor => {
      return new LTACapacitor(ltaCapacitor.id, ltaCapacitor.node0, ltaCapacitor.node1, solution.getVoltage(ltaCapacitor.node0, ltaCapacitor.capacitorVoltageNode1), solution.getCurrentForCompanion(ltaCapacitor), ltaCapacitor.capacitance);
    });
    const updatedInductors = this.ltaInductors.map(ltaInductor => {
      return new LTAInductor(ltaInductor.id, ltaInductor.node0, ltaInductor.node1, solution.getVoltage(ltaInductor.node0, ltaInductor.inductorVoltageNode1), solution.getCurrentForCompanion(ltaInductor), ltaInductor.inductance);
    });
    return new LTACircuit(this.ltaResistors, this.ltaBatteries, updatedCapacitors, updatedInductors);
  }
}
const euclideanDistance = (x, y) => {
  assert && assert(x.length === y.length, 'Vector length mismatch');
  let sumSqDiffs = 0;
  for (let i = 0; i < x.length; i++) {
    sumSqDiffs += Math.pow(x[i] - y[i], 2);
  }
  return Math.sqrt(sumSqDiffs);
};
circuitConstructionKitCommon.register('LTACircuit', LTACircuit);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJDQ0tDUXVlcnlQYXJhbWV0ZXJzIiwiTFRBU3RhdGVTZXQiLCJjaXJjdWl0Q29uc3RydWN0aW9uS2l0Q29tbW9uIiwiTU5BQ2lyY3VpdCIsIlRpbWVzdGVwU3ViZGl2aXNpb25zIiwiTFRBU29sdXRpb24iLCJMVEFTdGF0ZSIsIkxUQUluZHVjdG9yIiwiTFRBQ2FwYWNpdG9yIiwiTU5BQmF0dGVyeSIsIk1OQVJlc2lzdG9yIiwiTFRBQ2lyY3VpdCIsImNvbnN0cnVjdG9yIiwibHRhUmVzaXN0b3JzIiwibHRhQmF0dGVyaWVzIiwibHRhQ2FwYWNpdG9ycyIsImx0YUluZHVjdG9ycyIsInNvbHZlUHJvcGFnYXRlIiwiZHQiLCJjb21wYW5pb25CYXR0ZXJpZXMiLCJjb21wYW5pb25SZXNpc3RvcnMiLCJjb21wYW5pb25DdXJyZW50cyIsImN1cnJlbnRDb21wYW5pb25zIiwic3ludGhldGljTm9kZUluZGV4IiwiZm9yRWFjaCIsInJlc2lzdGl2ZUJhdHRlcnlBZGFwdGVyIiwibmV3Tm9kZSIsImlkZWFsQmF0dGVyeSIsIm5vZGUwIiwidm9sdGFnZSIsImlkZWFsUmVzaXN0b3IiLCJub2RlMSIsInJlc2lzdGFuY2UiLCJwdXNoIiwiZWxlbWVudCIsImdldFZhbHVlRm9yU29sdXRpb24iLCJzb2x1dGlvbiIsImdldFNvbHZlZEN1cnJlbnQiLCJsdGFDYXBhY2l0b3IiLCJhc3NlcnQiLCJuZXdOb2RlMSIsIm5ld05vZGUyIiwiY29tcGFuaW9uUmVzaXN0YW5jZSIsImNhcGFjaXRhbmNlIiwicmVzaXN0YW5jZVRlcm0iLCJjYXBhY2l0b3JSZXNpc3RhbmNlIiwiY29tcGFuaW9uVm9sdGFnZSIsImN1cnJlbnQiLCJiYXR0ZXJ5IiwicmVzaXN0b3IiLCJyZXNpc3RvcjIiLCJjYXBhY2l0b3JWb2x0YWdlTm9kZTEiLCJnZXRDdXJyZW50Rm9yUmVzaXN0b3IiLCJsdGFJbmR1Y3RvciIsImluZHVjdGFuY2UiLCJhZGRlZFJlc2lzdG9yIiwiaW5kdWN0b3JSZXNpc3RhbmNlIiwiaW5kdWN0b3JWb2x0YWdlTm9kZTEiLCJuZXdCYXR0ZXJ5TGlzdCIsIm5ld1Jlc2lzdG9yTGlzdCIsIm5ld0N1cnJlbnRMaXN0IiwibW5hQ2lyY3VpdCIsIm1uYVNvbHV0aW9uIiwic29sdmUiLCJzb2x2ZVdpdGhTdWJkaXZpc2lvbnMiLCJ0aW1lc3RlcFN1YmRpdmlzaW9ucyIsInN0ZXBwYWJsZSIsInVwZGF0ZSIsImEiLCJkaXN0YW5jZSIsImIiLCJldWNsaWRlYW5EaXN0YW5jZSIsImdldENoYXJhY3RlcmlzdGljQXJyYXkiLCJ4Iiwic3RlcEluVGltZVdpdGhIaXN0b3J5Iiwic29sdmVXaXRoU3ViZGl2aXNpb25zMiIsInVwZGF0ZVdpdGhTdWJkaXZpc2lvbnMiLCJnZXRGaW5hbFN0YXRlIiwibHRhQ2lyY3VpdCIsInNvbHZlSXRXaXRoU3ViZGl2aXNpb25zIiwibHRhU29sdXRpb24iLCJ1cGRhdGVDaXJjdWl0IiwidXBkYXRlZENhcGFjaXRvcnMiLCJtYXAiLCJpZCIsImdldFZvbHRhZ2UiLCJnZXRDdXJyZW50Rm9yQ29tcGFuaW9uIiwidXBkYXRlZEluZHVjdG9ycyIsInkiLCJsZW5ndGgiLCJzdW1TcURpZmZzIiwiaSIsIk1hdGgiLCJwb3ciLCJzcXJ0IiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJMVEFDaXJjdWl0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE5LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFRoZXJlIGFyZSB0d28gcGFydHMgdG8gc29sdmluZyBhIGR5bmFtaWMgY2lyY3VpdDpcclxuICogMS4gU3BsaXR0aW5nIHVwIGR5bmFtaWMgY29tcG9uZW50cyBzdWNoIGFzIGNhcGFjaXRvcnMgYW5kIGluZHVjdG9ycyBpbnRvIHRoZWlyIHJlc3BlY3RpdmUgbGluZWFyIGNvbXBhbmlvbiBtb2RlbHMuXHJcbiAqIDIuIEFkanVzdGluZyB0aGUgZHQgc28gdGhhdCBpbnRlZ3JhdGlvbiBzdGVwcyBhcmUgYWNjdXJhdGUuICBUaGlzIGlzIGRvbmUgdGhyb3VnaCBUaW1lc3RlcFN1YmRpdmlzaW9ucy5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgQ0NLQ1F1ZXJ5UGFyYW1ldGVycyBmcm9tICcuLi8uLi9DQ0tDUXVlcnlQYXJhbWV0ZXJzLmpzJztcclxuaW1wb3J0IExUQVN0YXRlU2V0IGZyb20gJy4vTFRBU3RhdGVTZXQuanMnO1xyXG5pbXBvcnQgY2lyY3VpdENvbnN0cnVjdGlvbktpdENvbW1vbiBmcm9tICcuLi8uLi9jaXJjdWl0Q29uc3RydWN0aW9uS2l0Q29tbW9uLmpzJztcclxuaW1wb3J0IE1OQUNpcmN1aXQgZnJvbSAnLi9tbmEvTU5BQ2lyY3VpdC5qcyc7XHJcbmltcG9ydCBUaW1lc3RlcFN1YmRpdmlzaW9ucyBmcm9tICcuL1RpbWVzdGVwU3ViZGl2aXNpb25zLmpzJztcclxuaW1wb3J0IExUQVNvbHV0aW9uIGZyb20gJy4vTFRBU29sdXRpb24uanMnO1xyXG5pbXBvcnQgTFRBU3RhdGUgZnJvbSAnLi9MVEFTdGF0ZS5qcyc7XHJcbmltcG9ydCBMVEFJbmR1Y3RvciBmcm9tICcuL0xUQUluZHVjdG9yLmpzJztcclxuaW1wb3J0IExUQUNhcGFjaXRvciBmcm9tICcuL0xUQUNhcGFjaXRvci5qcyc7XHJcbmltcG9ydCBNTkFTb2x1dGlvbiBmcm9tICcuL21uYS9NTkFTb2x1dGlvbi5qcyc7XHJcbmltcG9ydCBMVEFSZXNpc3RpdmVCYXR0ZXJ5IGZyb20gJy4vTFRBUmVzaXN0aXZlQmF0dGVyeS5qcyc7XHJcbmltcG9ydCBNTkFCYXR0ZXJ5IGZyb20gJy4vbW5hL01OQUJhdHRlcnkuanMnO1xyXG5pbXBvcnQgTU5BUmVzaXN0b3IgZnJvbSAnLi9tbmEvTU5BUmVzaXN0b3IuanMnO1xyXG5pbXBvcnQgTU5BQ3VycmVudCBmcm9tICcuL21uYS9NTkFDdXJyZW50LmpzJztcclxuaW1wb3J0IENvcmVNb2RlbCBmcm9tICcuL0NvcmVNb2RlbC5qcyc7XHJcblxyXG50eXBlIERpc3RhbmNlUGFyYW1zID0geyBnZXRDaGFyYWN0ZXJpc3RpY0FycmF5OiAoKSA9PiBudW1iZXJbXSB9O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTFRBQ2lyY3VpdCB7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBsdGFSZXNpc3RvcnM6IE1OQVJlc2lzdG9yW107XHJcbiAgcHJpdmF0ZSByZWFkb25seSBsdGFCYXR0ZXJpZXM6IExUQVJlc2lzdGl2ZUJhdHRlcnlbXTtcclxuICBwdWJsaWMgcmVhZG9ubHkgbHRhQ2FwYWNpdG9yczogTFRBQ2FwYWNpdG9yW107XHJcbiAgcHVibGljIHJlYWRvbmx5IGx0YUluZHVjdG9yczogTFRBSW5kdWN0b3JbXTtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBsdGFSZXNpc3RvcnM6IE1OQVJlc2lzdG9yW10sXHJcbiAgICAgICAgICAgICAgIGx0YUJhdHRlcmllczogTFRBUmVzaXN0aXZlQmF0dGVyeVtdLFxyXG4gICAgICAgICAgICAgICBsdGFDYXBhY2l0b3JzOiBMVEFDYXBhY2l0b3JbXSxcclxuICAgICAgICAgICAgICAgbHRhSW5kdWN0b3JzOiBMVEFJbmR1Y3RvcltdICkge1xyXG5cclxuICAgIHRoaXMubHRhUmVzaXN0b3JzID0gbHRhUmVzaXN0b3JzO1xyXG4gICAgdGhpcy5sdGFCYXR0ZXJpZXMgPSBsdGFCYXR0ZXJpZXM7XHJcbiAgICB0aGlzLmx0YUNhcGFjaXRvcnMgPSBsdGFDYXBhY2l0b3JzO1xyXG4gICAgdGhpcy5sdGFJbmR1Y3RvcnMgPSBsdGFJbmR1Y3RvcnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTb2x2aW5nIHRoZSBjb21wYW5pb24gbW9kZWwgaXMgdGhlIHNhbWUgYXMgcHJvcGFnYXRpbmcgZm9yd2FyZCBpbiB0aW1lIGJ5IGR0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzb2x2ZVByb3BhZ2F0ZSggZHQ6IG51bWJlciApOiBMVEFTb2x1dGlvbiB7XHJcblxyXG4gICAgY29uc3QgY29tcGFuaW9uQmF0dGVyaWVzOiBNTkFCYXR0ZXJ5W10gPSBbXTtcclxuICAgIGNvbnN0IGNvbXBhbmlvblJlc2lzdG9yczogTU5BUmVzaXN0b3JbXSA9IFtdO1xyXG4gICAgY29uc3QgY29tcGFuaW9uQ3VycmVudHM6IE1OQUN1cnJlbnRbXSA9IFtdO1xyXG4gICAgY29uc3QgY3VycmVudENvbXBhbmlvbnM6IHsgZWxlbWVudDogQ29yZU1vZGVsOyBnZXRWYWx1ZUZvclNvbHV0aW9uOiAoIHNvbHV0aW9uOiBNTkFTb2x1dGlvbiApID0+IG51bWJlciB9W10gPSBbXTtcclxuXHJcbiAgICAvLyBOb2RlIGluZGljZXMgdGhhdCBoYXZlIGJlZW4gdXNlZFxyXG4gICAgbGV0IHN5bnRoZXRpY05vZGVJbmRleCA9IDA7XHJcblxyXG4gICAgLy8gRWFjaCByZXNpc3RpdmUgYmF0dGVyeSBpcyBhIHJlc2lzdG9yIGluIHNlcmllcyB3aXRoIGEgYmF0dGVyeVxyXG4gICAgdGhpcy5sdGFCYXR0ZXJpZXMuZm9yRWFjaCggcmVzaXN0aXZlQmF0dGVyeUFkYXB0ZXIgPT4ge1xyXG4gICAgICBjb25zdCBuZXdOb2RlID0gJ3N5bnRoZXRpY05vZGUnICsgKCBzeW50aGV0aWNOb2RlSW5kZXgrKyApO1xyXG5cclxuICAgICAgY29uc3QgaWRlYWxCYXR0ZXJ5ID0gbmV3IE1OQUJhdHRlcnkoIHJlc2lzdGl2ZUJhdHRlcnlBZGFwdGVyLm5vZGUwLCBuZXdOb2RlLCByZXNpc3RpdmVCYXR0ZXJ5QWRhcHRlci52b2x0YWdlICk7IC8vIGZpbmFsIExpbmVhckNpcmN1aXRTb2x2ZXIuQmF0dGVyeVxyXG4gICAgICBjb25zdCBpZGVhbFJlc2lzdG9yID0gbmV3IE1OQVJlc2lzdG9yKCBuZXdOb2RlLCByZXNpc3RpdmVCYXR0ZXJ5QWRhcHRlci5ub2RlMSwgcmVzaXN0aXZlQmF0dGVyeUFkYXB0ZXIucmVzaXN0YW5jZSApOyAvLyBMaW5lYXJDaXJjdWl0U29sdmVyLlJlc2lzdG9yXHJcbiAgICAgIGNvbXBhbmlvbkJhdHRlcmllcy5wdXNoKCBpZGVhbEJhdHRlcnkgKTtcclxuICAgICAgY29tcGFuaW9uUmVzaXN0b3JzLnB1c2goIGlkZWFsUmVzaXN0b3IgKTtcclxuXHJcbiAgICAgIC8vIFdlIG5lZWQgdG8gYmUgYWJsZSB0byBnZXQgdGhlIGN1cnJlbnQgZm9yIHRoaXMgY29tcG9uZW50XHJcbiAgICAgIGN1cnJlbnRDb21wYW5pb25zLnB1c2goIHtcclxuICAgICAgICBlbGVtZW50OiByZXNpc3RpdmVCYXR0ZXJ5QWRhcHRlcixcclxuICAgICAgICBnZXRWYWx1ZUZvclNvbHV0aW9uOiAoIHNvbHV0aW9uOiBNTkFTb2x1dGlvbiApID0+IHNvbHV0aW9uLmdldFNvbHZlZEN1cnJlbnQoIGlkZWFsQmF0dGVyeSApXHJcbiAgICAgIH0gKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBBZGQgY29tcGFuaW9uIG1vZGVscyBmb3IgY2FwYWNpdG9yXHJcblxyXG4gICAgLy8gVFJBUEVaT0lEQUw6IGJhdHRlcnkgYW5kIHJlc2lzdG9yIGluIHNlcmllcy5cclxuICAgIC8vIFdlIHVzZSB0cmFwZXpvaWRhbCByYXRoZXIgdGhhbiBiYWNrd2FyZCBFdWxlciBiZWNhdXNlIHdlIGRvIG5vdCBtb2RlbCBjdXJyZW50IHNvdXJjZXMgYW5kIGl0IHNlZW1zIHRvIHdvcmsgd2VsbC5cclxuICAgIC8vIFNlZSBodHRwOi8vY2lyY3NpbXByb2ouYmxvZ3Nwb3QuY29tLzIwMDkvMDcvY29tcGFuaW9uLW1vZGVscy5odG1sXHJcbiAgICAvLyBWZXEgPSBWICsgZHQqSS8yL0M7XHJcbiAgICAvLyBSZXEgPSBkdC8yL0NcclxuICAgIHRoaXMubHRhQ2FwYWNpdG9ycy5mb3JFYWNoKCBsdGFDYXBhY2l0b3IgPT4ge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBkdCA+PSAwLCAnZHQgc2hvdWxkIGJlIG5vbi1uZWdhdGl2ZScgKTtcclxuXHJcbiAgICAgIGNvbnN0IG5ld05vZGUxID0gJ3N5bnRoZXRpY05vZGUnICsgKCBzeW50aGV0aWNOb2RlSW5kZXgrKyApO1xyXG4gICAgICBjb25zdCBuZXdOb2RlMiA9ICdzeW50aGV0aWNOb2RlJyArICggc3ludGhldGljTm9kZUluZGV4KysgKTtcclxuXHJcbiAgICAgIGNvbnN0IGNvbXBhbmlvblJlc2lzdGFuY2UgPSBkdCAvIDIuMCAvIGx0YUNhcGFjaXRvci5jYXBhY2l0YW5jZTtcclxuICAgICAgY29uc3QgcmVzaXN0YW5jZVRlcm0gPSBDQ0tDUXVlcnlQYXJhbWV0ZXJzLmNhcGFjaXRvclJlc2lzdGFuY2U7XHJcblxyXG4gICAgICAvLyBUaGUgY2FwYWNpdG9yIGlzIG1vZGVsZWQgYXMgYSBiYXR0ZXJ5IGluIHNlcmllcyB3aXRoIGEgcmVzaXN0b3IuICBIZW5jZSB0aGUgdm9sdGFnZSBkcm9wIGFjcm9zcyB0aGUgY2FwYWNpdG9yXHJcbiAgICAgIC8vIGlzIGVxdWFsIHRvIHRoZSB2b2x0YWdlIGRyb3AgYWNyb3NzIHRoZSBiYXR0ZXJ5IHBsdXMgdGhlIHZvbHRhZ2UgZHJvcCBhY3Jvc3MgdGhlIHJlc2lzdG9yLlxyXG4gICAgICAvLyBWID0gVmJhdHRlcnkgKyBWcmVzaXN0b3IuICBXZSBuZWVkIHRvIHNvbHZlIGZvciB0aGUgdm9sdGFnZSBhY3Jvc3MgdGhlIGJhdHRlcnkgdG8gdXNlIGl0IGluIHRoZSBjb21wYW5pb25cclxuICAgICAgLy8gbW9kZWwsIHNvIHdlIGhhdmUgVmJhdHRlcnkgPSBWLVZyZXNpc3Rvci4gIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZvbHRhZ2UgZHJvcCBhY3Jvc3MgdGhlIHJlc2lzdG9yIGlzIGdpdmVuIGJ5XHJcbiAgICAgIC8vIHxWfD18SVJlcXwgYW5kIHNpZ24gaXMgdW5jaGFuZ2VkIHNpbmNlIHRoZSBjb252ZW50aW9uYWwgY3VycmVudCBmbG93cyBmcm9tIGhpZ2ggdG8gbG93IHZvbHRhZ2UuXHJcbiAgICAgIGNvbnN0IGNvbXBhbmlvblZvbHRhZ2UgPSBjb21wYW5pb25SZXNpc3RhbmNlICogbHRhQ2FwYWNpdG9yLmN1cnJlbnQgLSBsdGFDYXBhY2l0b3Iudm9sdGFnZTtcclxuXHJcbiAgICAgIGNvbnN0IGJhdHRlcnkgPSBuZXcgTU5BQmF0dGVyeSggbHRhQ2FwYWNpdG9yLm5vZGUwLCBuZXdOb2RlMSwgY29tcGFuaW9uVm9sdGFnZSApO1xyXG4gICAgICBjb25zdCByZXNpc3RvciA9IG5ldyBNTkFSZXNpc3RvciggbmV3Tm9kZTEsIG5ld05vZGUyLCBjb21wYW5pb25SZXNpc3RhbmNlICk7XHJcbiAgICAgIGNvbnN0IHJlc2lzdG9yMiA9IG5ldyBNTkFSZXNpc3RvciggbmV3Tm9kZTIsIGx0YUNhcGFjaXRvci5ub2RlMSwgcmVzaXN0YW5jZVRlcm0gKTtcclxuXHJcbiAgICAgIGNvbXBhbmlvbkJhdHRlcmllcy5wdXNoKCBiYXR0ZXJ5ICk7XHJcbiAgICAgIGNvbXBhbmlvblJlc2lzdG9ycy5wdXNoKCByZXNpc3RvciApO1xyXG4gICAgICBjb21wYW5pb25SZXNpc3RvcnMucHVzaCggcmVzaXN0b3IyICk7XHJcblxyXG4gICAgICBsdGFDYXBhY2l0b3IuY2FwYWNpdG9yVm9sdGFnZU5vZGUxID0gbmV3Tm9kZTI7XHJcblxyXG4gICAgICAvLyBXZSBuZWVkIHRvIGJlIGFibGUgdG8gZ2V0IHRoZSBjdXJyZW50IGZvciB0aGlzIGNvbXBvbmVudC4gSW4gc2VyaWVzLCBzbyB0aGUgY3VycmVudCBpcyB0aGUgc2FtZSB0aHJvdWdoIGJvdGguXHJcbiAgICAgIGN1cnJlbnRDb21wYW5pb25zLnB1c2goIHtcclxuICAgICAgICBlbGVtZW50OiBsdGFDYXBhY2l0b3IsXHJcbiAgICAgICAgZ2V0VmFsdWVGb3JTb2x1dGlvbjogKCBzb2x1dGlvbjogTU5BU29sdXRpb24gKSA9PiBzb2x1dGlvbi5nZXRDdXJyZW50Rm9yUmVzaXN0b3IoIHJlc2lzdG9yIClcclxuICAgICAgfSApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFNlZSBhbHNvIGh0dHA6Ly9jaXJjc2ltcHJvai5ibG9nc3BvdC5jb20vMjAwOS8wNy9jb21wYW5pb24tbW9kZWxzLmh0bWwsIHdoaWNoIHJlcG9ydHM6XHJcbiAgICAvLyBSZXEgPSAyTC9kdFxyXG4gICAgLy8gVmVxID0gLTJMaS9kdC12XHJcbiAgICAvLyBTZWUgbmFqbSBwYWdlIDI3OSBhbmQgUGlsbGFnZSBwYWdlIDg2XHJcbiAgICB0aGlzLmx0YUluZHVjdG9ycy5mb3JFYWNoKCBsdGFJbmR1Y3RvciA9PiB7XHJcblxyXG4gICAgICAvLyBJbiBzZXJpZXNcclxuICAgICAgY29uc3QgbmV3Tm9kZSA9ICdzeW50aGV0aWNOb2RlJyArICggc3ludGhldGljTm9kZUluZGV4KysgKTtcclxuICAgICAgY29uc3QgbmV3Tm9kZTIgPSAnc3ludGhldGljTm9kZScgKyAoIHN5bnRoZXRpY05vZGVJbmRleCsrICk7XHJcblxyXG4gICAgICBjb25zdCBjb21wYW5pb25SZXNpc3RhbmNlID0gMiAqIGx0YUluZHVjdG9yLmluZHVjdGFuY2UgLyBkdDtcclxuICAgICAgY29uc3QgY29tcGFuaW9uVm9sdGFnZSA9IGx0YUluZHVjdG9yLnZvbHRhZ2UgKyAtY29tcGFuaW9uUmVzaXN0YW5jZSAqIGx0YUluZHVjdG9yLmN1cnJlbnQ7XHJcblxyXG4gICAgICBjb25zdCBiYXR0ZXJ5ID0gbmV3IE1OQUJhdHRlcnkoIGx0YUluZHVjdG9yLm5vZGUwLCBuZXdOb2RlLCBjb21wYW5pb25Wb2x0YWdlICk7XHJcbiAgICAgIGNvbnN0IHJlc2lzdG9yID0gbmV3IE1OQVJlc2lzdG9yKCBuZXdOb2RlLCBuZXdOb2RlMiwgY29tcGFuaW9uUmVzaXN0YW5jZSApO1xyXG4gICAgICBjb25zdCBhZGRlZFJlc2lzdG9yID0gbmV3IE1OQVJlc2lzdG9yKCBuZXdOb2RlMiwgbHRhSW5kdWN0b3Iubm9kZTEsIENDS0NRdWVyeVBhcmFtZXRlcnMuaW5kdWN0b3JSZXNpc3RhbmNlICk7XHJcbiAgICAgIGNvbXBhbmlvbkJhdHRlcmllcy5wdXNoKCBiYXR0ZXJ5ICk7XHJcbiAgICAgIGNvbXBhbmlvblJlc2lzdG9ycy5wdXNoKCByZXNpc3RvciApO1xyXG4gICAgICBjb21wYW5pb25SZXNpc3RvcnMucHVzaCggYWRkZWRSZXNpc3RvciApO1xyXG5cclxuICAgICAgbHRhSW5kdWN0b3IuaW5kdWN0b3JWb2x0YWdlTm9kZTEgPSBuZXdOb2RlMjtcclxuXHJcbiAgICAgIC8vIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBnZXQgdGhlIGN1cnJlbnQgZm9yIHRoaXMgY29tcG9uZW50XHJcbiAgICAgIC8vIGluIHNlcmllcywgc28gY3VycmVudCBpcyBzYW1lIHRocm91Z2ggYm90aCBjb21wYW5pb24gY29tcG9uZW50c1xyXG4gICAgICBjdXJyZW50Q29tcGFuaW9ucy5wdXNoKCB7XHJcbiAgICAgICAgZWxlbWVudDogbHRhSW5kdWN0b3IsXHJcbiAgICAgICAgZ2V0VmFsdWVGb3JTb2x1dGlvbjogKCBzb2x1dGlvbjogTU5BU29sdXRpb24gKSA9PiBzb2x1dGlvbi5nZXRDdXJyZW50Rm9yUmVzaXN0b3IoIHJlc2lzdG9yIClcclxuICAgICAgfSApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIGNvbnN0IG5ld0JhdHRlcnlMaXN0ID0gY29tcGFuaW9uQmF0dGVyaWVzO1xyXG4gICAgY29uc3QgbmV3UmVzaXN0b3JMaXN0ID0gWyAuLi50aGlzLmx0YVJlc2lzdG9ycywgLi4uY29tcGFuaW9uUmVzaXN0b3JzIF07XHJcbiAgICBjb25zdCBuZXdDdXJyZW50TGlzdCA9IGNvbXBhbmlvbkN1cnJlbnRzO1xyXG4gICAgY29uc3QgbW5hQ2lyY3VpdCA9IG5ldyBNTkFDaXJjdWl0KCBuZXdCYXR0ZXJ5TGlzdCwgbmV3UmVzaXN0b3JMaXN0LCBuZXdDdXJyZW50TGlzdCApO1xyXG5cclxuICAgIGNvbnN0IG1uYVNvbHV0aW9uID0gbW5hQ2lyY3VpdC5zb2x2ZSgpO1xyXG4gICAgcmV0dXJuIG5ldyBMVEFTb2x1dGlvbiggdGhpcywgbW5hU29sdXRpb24sIGN1cnJlbnRDb21wYW5pb25zICk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc29sdmVXaXRoU3ViZGl2aXNpb25zKCB0aW1lc3RlcFN1YmRpdmlzaW9uczogVGltZXN0ZXBTdWJkaXZpc2lvbnM8TFRBU3RhdGU+LCBkdDogbnVtYmVyICk6IExUQVN0YXRlU2V0IHtcclxuICAgIGNvbnN0IHN0ZXBwYWJsZSA9IHtcclxuICAgICAgdXBkYXRlOiAoIGE6IHsgdXBkYXRlOiAoIGR0OiBudW1iZXIgKSA9PiBMVEFTdGF0ZSB9LCBkdDogbnVtYmVyICkgPT4gYS51cGRhdGUoIGR0ICksXHJcbiAgICAgIGRpc3RhbmNlOiAoIGE6IERpc3RhbmNlUGFyYW1zLCBiOiBEaXN0YW5jZVBhcmFtcyApID0+IGV1Y2xpZGVhbkRpc3RhbmNlKCBhLmdldENoYXJhY3RlcmlzdGljQXJyYXkoKSwgYi5nZXRDaGFyYWN0ZXJpc3RpY0FycmF5KCkgKVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUdXJuaW5nIHRoZSBlcnJvciB0aHJlc2hvbGQgdG9vIGxvdyBoZXJlIGNhbiBmYWlsIHRoZSBpbmR1Y3RvciB0ZXN0cyBpbiBNTkFUZXN0Q2FzZVxyXG4gICAgY29uc3QgeCA9IHRpbWVzdGVwU3ViZGl2aXNpb25zLnN0ZXBJblRpbWVXaXRoSGlzdG9yeSggbmV3IExUQVN0YXRlKCB0aGlzLCBudWxsICksIHN0ZXBwYWJsZSwgZHQgKTtcclxuICAgIHJldHVybiBuZXcgTFRBU3RhdGVTZXQoIHggKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc29sdmVXaXRoU3ViZGl2aXNpb25zMiggZHQ6IG51bWJlciApOiBMVEFTdGF0ZVNldCB7XHJcbiAgICByZXR1cm4gdGhpcy5zb2x2ZVdpdGhTdWJkaXZpc2lvbnMoIG5ldyBUaW1lc3RlcFN1YmRpdmlzaW9ucygpLCBkdCApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHVwZGF0ZVdpdGhTdWJkaXZpc2lvbnMoIGR0OiBudW1iZXIgKTogTFRBQ2lyY3VpdCB7XHJcbiAgICByZXR1cm4gdGhpcy5zb2x2ZVdpdGhTdWJkaXZpc2lvbnMyKCBkdCApLmdldEZpbmFsU3RhdGUoKS5sdGFDaXJjdWl0O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNvbHZlSXRXaXRoU3ViZGl2aXNpb25zKCBkdDogbnVtYmVyICk6IExUQVNvbHV0aW9uIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy5zb2x2ZVdpdGhTdWJkaXZpc2lvbnMyKCBkdCApLmdldEZpbmFsU3RhdGUoKS5sdGFTb2x1dGlvbjtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlKCBkdDogbnVtYmVyICk6IExUQUNpcmN1aXQge1xyXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlQ2lyY3VpdCggdGhpcy5zb2x2ZVByb3BhZ2F0ZSggZHQgKSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbGllcyB0aGUgc3BlY2lmaWVkIHNvbHV0aW9uIHRvIHRoZSBjaXJjdWl0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyB1cGRhdGVDaXJjdWl0KCBzb2x1dGlvbjogTFRBU29sdXRpb24gKTogTFRBQ2lyY3VpdCB7XHJcbiAgICBjb25zdCB1cGRhdGVkQ2FwYWNpdG9ycyA9IHRoaXMubHRhQ2FwYWNpdG9ycy5tYXAoIGx0YUNhcGFjaXRvciA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgTFRBQ2FwYWNpdG9yKFxyXG4gICAgICAgIGx0YUNhcGFjaXRvci5pZCxcclxuICAgICAgICBsdGFDYXBhY2l0b3Iubm9kZTAsXHJcbiAgICAgICAgbHRhQ2FwYWNpdG9yLm5vZGUxLFxyXG4gICAgICAgIHNvbHV0aW9uLmdldFZvbHRhZ2UoIGx0YUNhcGFjaXRvci5ub2RlMCwgbHRhQ2FwYWNpdG9yLmNhcGFjaXRvclZvbHRhZ2VOb2RlMSEgKSxcclxuICAgICAgICBzb2x1dGlvbi5nZXRDdXJyZW50Rm9yQ29tcGFuaW9uKCBsdGFDYXBhY2l0b3IgKSxcclxuICAgICAgICBsdGFDYXBhY2l0b3IuY2FwYWNpdGFuY2UgKTtcclxuICAgIH0gKTtcclxuICAgIGNvbnN0IHVwZGF0ZWRJbmR1Y3RvcnMgPSB0aGlzLmx0YUluZHVjdG9ycy5tYXAoIGx0YUluZHVjdG9yID0+IHtcclxuICAgICAgcmV0dXJuIG5ldyBMVEFJbmR1Y3RvcihcclxuICAgICAgICBsdGFJbmR1Y3Rvci5pZCxcclxuICAgICAgICBsdGFJbmR1Y3Rvci5ub2RlMCxcclxuICAgICAgICBsdGFJbmR1Y3Rvci5ub2RlMSxcclxuICAgICAgICBzb2x1dGlvbi5nZXRWb2x0YWdlKCBsdGFJbmR1Y3Rvci5ub2RlMCwgbHRhSW5kdWN0b3IuaW5kdWN0b3JWb2x0YWdlTm9kZTEhICksXHJcbiAgICAgICAgc29sdXRpb24uZ2V0Q3VycmVudEZvckNvbXBhbmlvbiggbHRhSW5kdWN0b3IgKSxcclxuICAgICAgICBsdGFJbmR1Y3Rvci5pbmR1Y3RhbmNlXHJcbiAgICAgICk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBMVEFDaXJjdWl0KCB0aGlzLmx0YVJlc2lzdG9ycywgdGhpcy5sdGFCYXR0ZXJpZXMsIHVwZGF0ZWRDYXBhY2l0b3JzLCB1cGRhdGVkSW5kdWN0b3JzICk7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBldWNsaWRlYW5EaXN0YW5jZSA9ICggeDogbnVtYmVyW10sIHk6IG51bWJlcltdICkgPT4ge1xyXG4gIGFzc2VydCAmJiBhc3NlcnQoIHgubGVuZ3RoID09PSB5Lmxlbmd0aCwgJ1ZlY3RvciBsZW5ndGggbWlzbWF0Y2gnICk7XHJcbiAgbGV0IHN1bVNxRGlmZnMgPSAwO1xyXG4gIGZvciAoIGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKysgKSB7XHJcbiAgICBzdW1TcURpZmZzICs9IE1hdGgucG93KCB4WyBpIF0gLSB5WyBpIF0sIDIgKTtcclxuICB9XHJcbiAgcmV0dXJuIE1hdGguc3FydCggc3VtU3FEaWZmcyApO1xyXG59O1xyXG5cclxuY2lyY3VpdENvbnN0cnVjdGlvbktpdENvbW1vbi5yZWdpc3RlciggJ0xUQUNpcmN1aXQnLCBMVEFDaXJjdWl0ICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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