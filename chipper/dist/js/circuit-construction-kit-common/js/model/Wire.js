// Copyright 2015-2022, University of Colorado Boulder

/**
 * A wire whose length can change.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import NumberProperty from '../../../axon/js/NumberProperty.js';
import optionize from '../../../phet-core/js/optionize.js';
import Tandem from '../../../tandem/js/Tandem.js';
import CCKCConstants from '../CCKCConstants.js';
import circuitConstructionKitCommon from '../circuitConstructionKitCommon.js';
import CircuitElement from './CircuitElement.js';
// constants
// Conversion factor between model=view coordinates and meters, in order to use resistivity to compute resistance.
// Chosen so that a battery is around 5cm long.  See CCKCConstants for the default lengths of the elements in view
// coordinates.
const METERS_PER_VIEW_COORDINATE = 0.0005;
export default class Wire extends CircuitElement {
  // if the wire is a small stub attached to the black box

  // the resistance of the Wire in ohms

  // the resistivity of the Wire in ohm-meters

  // when the length changes layoutCharges must be called

  constructor(startVertex, endVertex, resistivityProperty, tandem, providedOptions) {
    assert && assert(typeof resistivityProperty !== 'number', 'property should not be a number');
    assert && assert(!startVertex.isDisposed, 'vertex should not be disposed');
    assert && assert(!endVertex.isDisposed, 'vertex should not be disposed');
    const options = optionize()({
      wireStub: false,
      isMetallic: true,
      // Wires do not have these features, so opt out of PhET-iO instrumentation here
      isEditablePropertyOptions: {
        tandem: Tandem.OPT_OUT
      },
      isValueDisplayablePropertyOptions: {
        tandem: Tandem.OPT_OUT
      },
      labelStringPropertyOptions: {
        tandem: Tandem.OPT_OUT
      }
    }, providedOptions);
    const chargePathLength = startVertex.positionProperty.get().distance(endVertex.positionProperty.get());
    super(startVertex, endVertex, chargePathLength, tandem, options);
    this.wireStub = options.wireStub;
    this.resistanceProperty = new NumberProperty(CCKCConstants.MINIMUM_WIRE_RESISTANCE);
    if (phet.chipper.queryParameters.dev) {
      this.resistanceProperty.link(console.log);
    }
    this.resistivityProperty = resistivityProperty;
    this.lengthProperty = new NumberProperty(0);
    this.updateListener = () => this.update();
    this.vertexMovedEmitter.addListener(this.updateListener);

    // When resistivity changes, update the resistance
    this.resistivityProperty.link(this.updateListener);
    this.update(); // initialize state
  }

  /**
   * Move forward in time
   * @param time - total elapsed time in seconds
   * @param dt - seconds since last step
   * @param circuit
   */
  step(time, dt, circuit) {
    super.step(time, dt, circuit);
    this.update();
  }

  /**
   * Batch changes so that the length doesn't change incrementally when both vertices move one at a time.
   */
  update() {
    const startPosition = this.startPositionProperty.get();
    const endPosition = this.endPositionProperty.get();
    const distanceBetweenVertices = startPosition.distance(endPosition); // same as view coordinates
    const modelLength = distanceBetweenVertices * METERS_PER_VIEW_COORDINATE;
    this.lengthProperty.set(modelLength);

    // R = rho * L / A.  Resistance = resistivity * Length / cross sectional area.
    const resistance = this.resistivityProperty.get() * modelLength / CCKCConstants.WIRE_CROSS_SECTIONAL_AREA;
    const clampedResistance = Math.max(CCKCConstants.MINIMUM_WIRE_RESISTANCE, resistance);
    assert && assert(!isNaN(clampedResistance), 'wire resistance should not be NaN');
    this.resistanceProperty.set(clampedResistance);

    // Update the charge path length, but don't let it go less than a threshold, see https://github.com/phetsims/circuit-construction-kit-common/issues/405
    this.chargePathLength = Math.max(distanceBetweenVertices, 1E-6);
  }

  /**
   * Get the properties so that the circuit can be solved when changed.
   */
  getCircuitProperties() {
    return [this.resistanceProperty];
  }

  /**
   * Releases all resources related to the Wire, called when it will no longer be used.
   */
  dispose() {
    this.vertexMovedEmitter.removeListener(this.updateListener);
    this.resistivityProperty.unlink(this.updateListener);
    super.dispose();
  }
}
circuitConstructionKitCommon.register('Wire', Wire);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJOdW1iZXJQcm9wZXJ0eSIsIm9wdGlvbml6ZSIsIlRhbmRlbSIsIkNDS0NDb25zdGFudHMiLCJjaXJjdWl0Q29uc3RydWN0aW9uS2l0Q29tbW9uIiwiQ2lyY3VpdEVsZW1lbnQiLCJNRVRFUlNfUEVSX1ZJRVdfQ09PUkRJTkFURSIsIldpcmUiLCJjb25zdHJ1Y3RvciIsInN0YXJ0VmVydGV4IiwiZW5kVmVydGV4IiwicmVzaXN0aXZpdHlQcm9wZXJ0eSIsInRhbmRlbSIsInByb3ZpZGVkT3B0aW9ucyIsImFzc2VydCIsImlzRGlzcG9zZWQiLCJvcHRpb25zIiwid2lyZVN0dWIiLCJpc01ldGFsbGljIiwiaXNFZGl0YWJsZVByb3BlcnR5T3B0aW9ucyIsIk9QVF9PVVQiLCJpc1ZhbHVlRGlzcGxheWFibGVQcm9wZXJ0eU9wdGlvbnMiLCJsYWJlbFN0cmluZ1Byb3BlcnR5T3B0aW9ucyIsImNoYXJnZVBhdGhMZW5ndGgiLCJwb3NpdGlvblByb3BlcnR5IiwiZ2V0IiwiZGlzdGFuY2UiLCJyZXNpc3RhbmNlUHJvcGVydHkiLCJNSU5JTVVNX1dJUkVfUkVTSVNUQU5DRSIsInBoZXQiLCJjaGlwcGVyIiwicXVlcnlQYXJhbWV0ZXJzIiwiZGV2IiwibGluayIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGhQcm9wZXJ0eSIsInVwZGF0ZUxpc3RlbmVyIiwidXBkYXRlIiwidmVydGV4TW92ZWRFbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJzdGVwIiwidGltZSIsImR0IiwiY2lyY3VpdCIsInN0YXJ0UG9zaXRpb24iLCJzdGFydFBvc2l0aW9uUHJvcGVydHkiLCJlbmRQb3NpdGlvbiIsImVuZFBvc2l0aW9uUHJvcGVydHkiLCJkaXN0YW5jZUJldHdlZW5WZXJ0aWNlcyIsIm1vZGVsTGVuZ3RoIiwic2V0IiwicmVzaXN0YW5jZSIsIldJUkVfQ1JPU1NfU0VDVElPTkFMX0FSRUEiLCJjbGFtcGVkUmVzaXN0YW5jZSIsIk1hdGgiLCJtYXgiLCJpc05hTiIsImdldENpcmN1aXRQcm9wZXJ0aWVzIiwiZGlzcG9zZSIsInJlbW92ZUxpc3RlbmVyIiwidW5saW5rIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJXaXJlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgd2lyZSB3aG9zZSBsZW5ndGggY2FuIGNoYW5nZS5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgTnVtYmVyUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9OdW1iZXJQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9JbnRlbnRpb25hbEFueS5qcyc7XHJcbmltcG9ydCBUYW5kZW0gZnJvbSAnLi4vLi4vLi4vdGFuZGVtL2pzL1RhbmRlbS5qcyc7XHJcbmltcG9ydCBDQ0tDQ29uc3RhbnRzIGZyb20gJy4uL0NDS0NDb25zdGFudHMuanMnO1xyXG5pbXBvcnQgY2lyY3VpdENvbnN0cnVjdGlvbktpdENvbW1vbiBmcm9tICcuLi9jaXJjdWl0Q29uc3RydWN0aW9uS2l0Q29tbW9uLmpzJztcclxuaW1wb3J0IENpcmN1aXQgZnJvbSAnLi9DaXJjdWl0LmpzJztcclxuaW1wb3J0IENpcmN1aXRFbGVtZW50LCB7IENpcmN1aXRFbGVtZW50T3B0aW9ucyB9IGZyb20gJy4vQ2lyY3VpdEVsZW1lbnQuanMnO1xyXG5pbXBvcnQgVmVydGV4IGZyb20gJy4vVmVydGV4LmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG4vLyBDb252ZXJzaW9uIGZhY3RvciBiZXR3ZWVuIG1vZGVsPXZpZXcgY29vcmRpbmF0ZXMgYW5kIG1ldGVycywgaW4gb3JkZXIgdG8gdXNlIHJlc2lzdGl2aXR5IHRvIGNvbXB1dGUgcmVzaXN0YW5jZS5cclxuLy8gQ2hvc2VuIHNvIHRoYXQgYSBiYXR0ZXJ5IGlzIGFyb3VuZCA1Y20gbG9uZy4gIFNlZSBDQ0tDQ29uc3RhbnRzIGZvciB0aGUgZGVmYXVsdCBsZW5ndGhzIG9mIHRoZSBlbGVtZW50cyBpbiB2aWV3XHJcbi8vIGNvb3JkaW5hdGVzLlxyXG5jb25zdCBNRVRFUlNfUEVSX1ZJRVdfQ09PUkRJTkFURSA9IDAuMDAwNTtcclxuXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSB7XHJcbiAgd2lyZVN0dWI/OiBib29sZWFuO1xyXG59O1xyXG5cclxudHlwZSBXaXJlT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgQ2lyY3VpdEVsZW1lbnRPcHRpb25zO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lyZSBleHRlbmRzIENpcmN1aXRFbGVtZW50IHtcclxuXHJcbiAgLy8gaWYgdGhlIHdpcmUgaXMgYSBzbWFsbCBzdHViIGF0dGFjaGVkIHRvIHRoZSBibGFjayBib3hcclxuICBwcml2YXRlIHJlYWRvbmx5IHdpcmVTdHViOiBib29sZWFuO1xyXG5cclxuICAvLyB0aGUgcmVzaXN0YW5jZSBvZiB0aGUgV2lyZSBpbiBvaG1zXHJcbiAgcHVibGljIHJlYWRvbmx5IHJlc2lzdGFuY2VQcm9wZXJ0eTogTnVtYmVyUHJvcGVydHk7XHJcblxyXG4gIC8vIHRoZSByZXNpc3Rpdml0eSBvZiB0aGUgV2lyZSBpbiBvaG0tbWV0ZXJzXHJcbiAgcHJpdmF0ZSByZWFkb25seSByZXNpc3Rpdml0eVByb3BlcnR5OiBOdW1iZXJQcm9wZXJ0eTtcclxuXHJcbiAgLy8gd2hlbiB0aGUgbGVuZ3RoIGNoYW5nZXMgbGF5b3V0Q2hhcmdlcyBtdXN0IGJlIGNhbGxlZFxyXG4gIHB1YmxpYyBvdmVycmlkZSByZWFkb25seSBsZW5ndGhQcm9wZXJ0eTogTnVtYmVyUHJvcGVydHk7XHJcbiAgcHJpdmF0ZSB1cGRhdGVMaXN0ZW5lcjogKCkgPT4gdm9pZDtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBzdGFydFZlcnRleDogVmVydGV4LCBlbmRWZXJ0ZXg6IFZlcnRleCwgcmVzaXN0aXZpdHlQcm9wZXJ0eTogTnVtYmVyUHJvcGVydHksIHRhbmRlbTogVGFuZGVtLCBwcm92aWRlZE9wdGlvbnM/OiBXaXJlT3B0aW9ucyApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiByZXNpc3Rpdml0eVByb3BlcnR5ICE9PSAnbnVtYmVyJywgJ3Byb3BlcnR5IHNob3VsZCBub3QgYmUgYSBudW1iZXInICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhc3RhcnRWZXJ0ZXguaXNEaXNwb3NlZCwgJ3ZlcnRleCBzaG91bGQgbm90IGJlIGRpc3Bvc2VkJyApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIWVuZFZlcnRleC5pc0Rpc3Bvc2VkLCAndmVydGV4IHNob3VsZCBub3QgYmUgZGlzcG9zZWQnICk7XHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPFdpcmVPcHRpb25zLCBTZWxmT3B0aW9ucywgQ2lyY3VpdEVsZW1lbnRPcHRpb25zPigpKCB7XHJcbiAgICAgIHdpcmVTdHViOiBmYWxzZSxcclxuICAgICAgaXNNZXRhbGxpYzogdHJ1ZSxcclxuXHJcbiAgICAgIC8vIFdpcmVzIGRvIG5vdCBoYXZlIHRoZXNlIGZlYXR1cmVzLCBzbyBvcHQgb3V0IG9mIFBoRVQtaU8gaW5zdHJ1bWVudGF0aW9uIGhlcmVcclxuICAgICAgaXNFZGl0YWJsZVByb3BlcnR5T3B0aW9uczoge1xyXG4gICAgICAgIHRhbmRlbTogVGFuZGVtLk9QVF9PVVRcclxuICAgICAgfSxcclxuICAgICAgaXNWYWx1ZURpc3BsYXlhYmxlUHJvcGVydHlPcHRpb25zOiB7XHJcbiAgICAgICAgdGFuZGVtOiBUYW5kZW0uT1BUX09VVFxyXG4gICAgICB9LFxyXG4gICAgICBsYWJlbFN0cmluZ1Byb3BlcnR5T3B0aW9uczoge1xyXG4gICAgICAgIHRhbmRlbTogVGFuZGVtLk9QVF9PVVRcclxuICAgICAgfVxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcbiAgICBjb25zdCBjaGFyZ2VQYXRoTGVuZ3RoID0gc3RhcnRWZXJ0ZXgucG9zaXRpb25Qcm9wZXJ0eS5nZXQoKS5kaXN0YW5jZSggZW5kVmVydGV4LnBvc2l0aW9uUHJvcGVydHkuZ2V0KCkgKTtcclxuICAgIHN1cGVyKCBzdGFydFZlcnRleCwgZW5kVmVydGV4LCBjaGFyZ2VQYXRoTGVuZ3RoLCB0YW5kZW0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICB0aGlzLndpcmVTdHViID0gb3B0aW9ucy53aXJlU3R1YjtcclxuXHJcbiAgICB0aGlzLnJlc2lzdGFuY2VQcm9wZXJ0eSA9IG5ldyBOdW1iZXJQcm9wZXJ0eSggQ0NLQ0NvbnN0YW50cy5NSU5JTVVNX1dJUkVfUkVTSVNUQU5DRSApO1xyXG5cclxuICAgIGlmICggcGhldC5jaGlwcGVyLnF1ZXJ5UGFyYW1ldGVycy5kZXYgKSB7XHJcbiAgICAgIHRoaXMucmVzaXN0YW5jZVByb3BlcnR5LmxpbmsoIGNvbnNvbGUubG9nICk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZXNpc3Rpdml0eVByb3BlcnR5ID0gcmVzaXN0aXZpdHlQcm9wZXJ0eTtcclxuICAgIHRoaXMubGVuZ3RoUHJvcGVydHkgPSBuZXcgTnVtYmVyUHJvcGVydHkoIDAgKTtcclxuICAgIHRoaXMudXBkYXRlTGlzdGVuZXIgPSAoKSA9PiB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgdGhpcy52ZXJ0ZXhNb3ZlZEVtaXR0ZXIuYWRkTGlzdGVuZXIoIHRoaXMudXBkYXRlTGlzdGVuZXIgKTtcclxuXHJcbiAgICAvLyBXaGVuIHJlc2lzdGl2aXR5IGNoYW5nZXMsIHVwZGF0ZSB0aGUgcmVzaXN0YW5jZVxyXG4gICAgdGhpcy5yZXNpc3Rpdml0eVByb3BlcnR5LmxpbmsoIHRoaXMudXBkYXRlTGlzdGVuZXIgKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpOyAvLyBpbml0aWFsaXplIHN0YXRlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3ZlIGZvcndhcmQgaW4gdGltZVxyXG4gICAqIEBwYXJhbSB0aW1lIC0gdG90YWwgZWxhcHNlZCB0aW1lIGluIHNlY29uZHNcclxuICAgKiBAcGFyYW0gZHQgLSBzZWNvbmRzIHNpbmNlIGxhc3Qgc3RlcFxyXG4gICAqIEBwYXJhbSBjaXJjdWl0XHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIHN0ZXAoIHRpbWU6IG51bWJlciwgZHQ6IG51bWJlciwgY2lyY3VpdDogQ2lyY3VpdCApOiB2b2lkIHtcclxuICAgIHN1cGVyLnN0ZXAoIHRpbWUsIGR0LCBjaXJjdWl0ICk7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmF0Y2ggY2hhbmdlcyBzbyB0aGF0IHRoZSBsZW5ndGggZG9lc24ndCBjaGFuZ2UgaW5jcmVtZW50YWxseSB3aGVuIGJvdGggdmVydGljZXMgbW92ZSBvbmUgYXQgYSB0aW1lLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgdXBkYXRlKCk6IHZvaWQge1xyXG4gICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvblByb3BlcnR5LmdldCgpO1xyXG4gICAgY29uc3QgZW5kUG9zaXRpb24gPSB0aGlzLmVuZFBvc2l0aW9uUHJvcGVydHkuZ2V0KCk7XHJcbiAgICBjb25zdCBkaXN0YW5jZUJldHdlZW5WZXJ0aWNlcyA9IHN0YXJ0UG9zaXRpb24uZGlzdGFuY2UoIGVuZFBvc2l0aW9uICk7IC8vIHNhbWUgYXMgdmlldyBjb29yZGluYXRlc1xyXG4gICAgY29uc3QgbW9kZWxMZW5ndGggPSBkaXN0YW5jZUJldHdlZW5WZXJ0aWNlcyAqIE1FVEVSU19QRVJfVklFV19DT09SRElOQVRFO1xyXG4gICAgdGhpcy5sZW5ndGhQcm9wZXJ0eS5zZXQoIG1vZGVsTGVuZ3RoICk7XHJcblxyXG4gICAgLy8gUiA9IHJobyAqIEwgLyBBLiAgUmVzaXN0YW5jZSA9IHJlc2lzdGl2aXR5ICogTGVuZ3RoIC8gY3Jvc3Mgc2VjdGlvbmFsIGFyZWEuXHJcbiAgICBjb25zdCByZXNpc3RhbmNlID0gdGhpcy5yZXNpc3Rpdml0eVByb3BlcnR5LmdldCgpICogbW9kZWxMZW5ndGggLyBDQ0tDQ29uc3RhbnRzLldJUkVfQ1JPU1NfU0VDVElPTkFMX0FSRUE7XHJcblxyXG4gICAgY29uc3QgY2xhbXBlZFJlc2lzdGFuY2UgPSBNYXRoLm1heCggQ0NLQ0NvbnN0YW50cy5NSU5JTVVNX1dJUkVfUkVTSVNUQU5DRSwgcmVzaXN0YW5jZSApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIWlzTmFOKCBjbGFtcGVkUmVzaXN0YW5jZSApLCAnd2lyZSByZXNpc3RhbmNlIHNob3VsZCBub3QgYmUgTmFOJyApO1xyXG4gICAgdGhpcy5yZXNpc3RhbmNlUHJvcGVydHkuc2V0KCBjbGFtcGVkUmVzaXN0YW5jZSApO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgY2hhcmdlIHBhdGggbGVuZ3RoLCBidXQgZG9uJ3QgbGV0IGl0IGdvIGxlc3MgdGhhbiBhIHRocmVzaG9sZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jaXJjdWl0LWNvbnN0cnVjdGlvbi1raXQtY29tbW9uL2lzc3Vlcy80MDVcclxuICAgIHRoaXMuY2hhcmdlUGF0aExlbmd0aCA9IE1hdGgubWF4KCBkaXN0YW5jZUJldHdlZW5WZXJ0aWNlcywgMUUtNiApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwcm9wZXJ0aWVzIHNvIHRoYXQgdGhlIGNpcmN1aXQgY2FuIGJlIHNvbHZlZCB3aGVuIGNoYW5nZWQuXHJcbiAgICovXHJcbiAgcHVibGljIGdldENpcmN1aXRQcm9wZXJ0aWVzKCk6IFByb3BlcnR5PEludGVudGlvbmFsQW55PltdIHtcclxuICAgIHJldHVybiBbIHRoaXMucmVzaXN0YW5jZVByb3BlcnR5IF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHJlbGF0ZWQgdG8gdGhlIFdpcmUsIGNhbGxlZCB3aGVuIGl0IHdpbGwgbm8gbG9uZ2VyIGJlIHVzZWQuXHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLnZlcnRleE1vdmVkRW1pdHRlci5yZW1vdmVMaXN0ZW5lciggdGhpcy51cGRhdGVMaXN0ZW5lciApO1xyXG4gICAgdGhpcy5yZXNpc3Rpdml0eVByb3BlcnR5LnVubGluayggdGhpcy51cGRhdGVMaXN0ZW5lciApO1xyXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gIH1cclxufVxyXG5cclxuY2lyY3VpdENvbnN0cnVjdGlvbktpdENvbW1vbi5yZWdpc3RlciggJ1dpcmUnLCBXaXJlICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGNBQWMsTUFBTSxvQ0FBb0M7QUFFL0QsT0FBT0MsU0FBUyxNQUFNLG9DQUFvQztBQUUxRCxPQUFPQyxNQUFNLE1BQU0sOEJBQThCO0FBQ2pELE9BQU9DLGFBQWEsTUFBTSxxQkFBcUI7QUFDL0MsT0FBT0MsNEJBQTRCLE1BQU0sb0NBQW9DO0FBRTdFLE9BQU9DLGNBQWMsTUFBaUMscUJBQXFCO0FBRzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsMEJBQTBCLEdBQUcsTUFBTTtBQVF6QyxlQUFlLE1BQU1DLElBQUksU0FBU0YsY0FBYyxDQUFDO0VBRS9DOztFQUdBOztFQUdBOztFQUdBOztFQUlPRyxXQUFXQSxDQUFFQyxXQUFtQixFQUFFQyxTQUFpQixFQUFFQyxtQkFBbUMsRUFBRUMsTUFBYyxFQUFFQyxlQUE2QixFQUFHO0lBQy9JQyxNQUFNLElBQUlBLE1BQU0sQ0FBRSxPQUFPSCxtQkFBbUIsS0FBSyxRQUFRLEVBQUUsaUNBQWtDLENBQUM7SUFDOUZHLE1BQU0sSUFB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