// Copyright 2021-2022, University of Colorado Boulder

/**
 * LightRays is the model of bundles of light rays. It's primary responsibility is to collect the segments of
 * multiple LightRay instances. LightRays are animated over time.
 *
 * @author Martin Veillette
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Emitter from '../../../../axon/js/Emitter.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import geometricOptics from '../../geometricOptics.js';
import LightRay from './LightRay.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2Property from '../../../../dot/js/Vector2Property.js';
import Multilink from '../../../../axon/js/Multilink.js';
// constants related to 'Many' rays representation, see https://github.com/phetsims/geometric-optics/issues/289
const MANY_MIN_RAYS = 20;
const MANY_MIN_RAYS_DISTANCE = 300; // cm, MANY_MIN_RAYS will be shown up to this distance from the optic
const MANY_FAN_ANGLE = Utils.toRadians(120); // degrees to radians
const VECTOR2_PROPERTY = new Vector2Property(Vector2.ZERO); // For helping the type checker with varargs multilink

export default class LightRays {
  // segments for the real rays at a point in time

  // segments for the virtual rays at a point in time

  // tells view that it needs to update, fires after all rays are processed.

  /**
   * @param opticalObjectPositionProperty - position of the optical object
   * @param optic - the optic that this bundle of rays may interact with
   * @param opticalImage - optical image associated with this ray
   * @param raysTypeProperty - representation used for rays
   * @param raysAnimationTimeProperty - elapsed time of light rays animation
   * @param [projectionScreen] - optional projection screen that blocks rays
   */
  constructor(opticalObjectPositionProperty, optic, opticalImage, raysTypeProperty, raysAnimationTimeProperty, projectionScreen) {
    this.realSegments = [];
    this.virtualSegments = [];
    this.raysProcessedEmitter = new Emitter();

    // When the light rays animation begins, hide the optical image. It will be made visible when a ray reaches the
    // image position.  If Rays is set to 'None', make the image visible immediately, since there will be no animation.
    Multilink.multilink([raysTypeProperty, raysAnimationTimeProperty], (raysType, raysAnimationTime) => {
      if (raysType === 'none' || raysAnimationTime === 0) {
        opticalImage.visibleProperty.value = raysTypeProperty.value === 'none';
      }
    });

    // Things that result in a change to the rays.
    // We only care about the types of the first 3 dependencies, because the listener only has 3 parameters.
    const bonusProperty = projectionScreen ? projectionScreen.positionProperty : VECTOR2_PROPERTY;
    const dependencies = [opticalObjectPositionProperty, raysTypeProperty, raysAnimationTimeProperty, optic.positionProperty, optic.diameterProperty, optic.focalLengthProperty, optic.opticSurfaceTypeProperty, bonusProperty];

    // Update all rays, then inform listeners via raysProcessedEmitter.
    Multilink.multilink(dependencies, (opticalObjectPosition, raysType, raysAnimationTime) => {
      // Clear the arrays.
      this.realSegments = [];
      this.virtualSegments = [];

      // the position the opticalImage
      const opticalImagePosition = opticalImage.positionProperty.value;

      // is the Image virtual
      const isVirtual = opticalImage.opticalImageTypeProperty.value === 'virtual';

      // get the initial directions of the rays
      const directions = getRayDirections(raysType, opticalObjectPosition, optic, opticalImagePosition);

      // loop over the direction of each ray
      directions.forEach(direction => {
        // Create a LightRay, which is responsible for creating real and virtual ray segments.
        const lightRay = new LightRay(opticalObjectPosition, direction, raysAnimationTime, optic, opticalImagePosition, isVirtual, raysType, projectionScreen);

        // Set optical image's visibility to true when a ray reaches the optical image or projection screen.
        if (lightRay.hasReachedTarget) {
          opticalImage.visibleProperty.value = true;
        }

        // Add LightRaySegments
        this.realSegments.push(...lightRay.realSegments);
        this.virtualSegments.push(...lightRay.virtualSegments);
      });
      this.raysProcessedEmitter.emit();
    });
  }
  dispose() {
    assert && assert(false, 'dispose is not supported, exists for the lifetime of the sim');
  }
}

/**
 * Gets the initial directions (as unit vectors) of the rays for the different ray types.
 */
function getRayDirections(raysType, opticalObjectPosition, optic, opticalImagePosition) {
  // directions of the light rays emanating from opticalObjectPosition
  const directions = [];

  // vector from object to optic
  const objectOpticVector = optic.positionProperty.value.minus(opticalObjectPosition);
  if (raysType === 'marginal') {
    // 3 rays: through center, top, and bottom of optic.

    // #1: center of the optic
    directions.push(objectOpticVector.normalized());

    // #2: top of the optic
    const topPoint = optic.getTopPoint(opticalObjectPosition, opticalImagePosition);
    const topDirection = topPoint.minus(opticalObjectPosition).normalized();
    directions.push(topDirection);

    // #3: bottom of the optic
    const bottomPoint = optic.getBottomPoint(opticalObjectPosition, opticalImagePosition);
    const bottomDirection = bottomPoint.minus(opticalObjectPosition).normalized();
    directions.push(bottomDirection);
  } else if (raysType === 'principal') {
    // 3 rays: parallel to optical axis, through center of optic, through focal point on left side of optic
    // This representation can result in some confusion, see https://github.com/phetsims/geometric-optics/issues/140.

    // #1: parallel to the optical axis
    directions.push(new Vector2(1, 0));

    // #2: through the center of optic
    directions.push(objectOpticVector.normalized());

    // #3: through the focal point
    const firstFocalVector = objectOpticVector.minusXY(optic.focalLengthProperty.value, 0);
    if (firstFocalVector.x < 0) {
      firstFocalVector.negate(); // should point to the right, to indicate the direction of the light rays
    }

    directions.push(firstFocalVector.normalized());
  } else if (raysType === 'many') {
    // Number of rays depends on how far opticalObjectPosition is from the optic. But we want at least 2 rays to
    // go through the optic. See https://github.com/phetsims/geometric-optics/issues/289.

    // starting angle for fan of rays
    const startingAngle = MANY_FAN_ANGLE / 2;

    // symmetric condition for end angle
    const endAngle = -startingAngle;

    // x distance from the Object to the optic
    const distanceX = Math.abs(optic.positionProperty.value.x - opticalObjectPosition.x);

    // number of rays
    const numberOfRays = MANY_MIN_RAYS * (Math.floor(distanceX / MANY_MIN_RAYS_DISTANCE) + 1);

    // Degrees between adjacent arrays
    const deltaTheta = (endAngle - startingAngle) / (numberOfRays - 1);

    // Create a fan of equidistant rays between startingAngle and endAngle.
    for (let i = 0; i < numberOfRays; i++) {
      const angle = startingAngle + i * deltaTheta;
      directions.push(Vector2.createPolar(1, angle));
    }
  }
  return directions;
}
geometricOptics.register('LightRays', LightRays);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFbWl0dGVyIiwiVmVjdG9yMiIsImdlb21ldHJpY09wdGljcyIsIkxpZ2h0UmF5IiwiVXRpbHMiLCJWZWN0b3IyUHJvcGVydHkiLCJNdWx0aWxpbmsiLCJNQU5ZX01JTl9SQVlTIiwiTUFOWV9NSU5fUkFZU19ESVNUQU5DRSIsIk1BTllfRkFOX0FOR0xFIiwidG9SYWRpYW5zIiwiVkVDVE9SMl9QUk9QRVJUWSIsIlpFUk8iLCJMaWdodFJheXMiLCJjb25zdHJ1Y3RvciIsIm9wdGljYWxPYmplY3RQb3NpdGlvblByb3BlcnR5Iiwib3B0aWMiLCJvcHRpY2FsSW1hZ2UiLCJyYXlzVHlwZVByb3BlcnR5IiwicmF5c0FuaW1hdGlvblRpbWVQcm9wZXJ0eSIsInByb2plY3Rpb25TY3JlZW4iLCJyZWFsU2VnbWVudHMiLCJ2aXJ0dWFsU2VnbWVudHMiLCJyYXlzUHJvY2Vzc2VkRW1pdHRlciIsIm11bHRpbGluayIsInJheXNUeXBlIiwicmF5c0FuaW1hdGlvblRpbWUiLCJ2aXNpYmxlUHJvcGVydHkiLCJ2YWx1ZSIsImJvbnVzUHJvcGVydHkiLCJwb3NpdGlvblByb3BlcnR5IiwiZGVwZW5kZW5jaWVzIiwiZGlhbWV0ZXJQcm9wZXJ0eSIsImZvY2FsTGVuZ3RoUHJvcGVydHkiLCJvcHRpY1N1cmZhY2VUeXBlUHJvcGVydHkiLCJvcHRpY2FsT2JqZWN0UG9zaXRpb24iLCJvcHRpY2FsSW1hZ2VQb3NpdGlvbiIsImlzVmlydHVhbCIsIm9wdGljYWxJbWFnZVR5cGVQcm9wZXJ0eSIsImRpcmVjdGlvbnMiLCJnZXRSYXlEaXJlY3Rpb25zIiwiZm9yRWFjaCIsImRpcmVjdGlvbiIsImxpZ2h0UmF5IiwiaGFzUmVhY2hlZFRhcmdldCIsInB1c2giLCJlbWl0IiwiZGlzcG9zZSIsImFzc2VydCIsIm9iamVjdE9wdGljVmVjdG9yIiwibWludXMiLCJub3JtYWxpemVkIiwidG9wUG9pbnQiLCJnZXRUb3BQb2ludCIsInRvcERpcmVjdGlvbiIsImJvdHRvbVBvaW50IiwiZ2V0Qm90dG9tUG9pbnQiLCJib3R0b21EaXJlY3Rpb24iLCJmaXJzdEZvY2FsVmVjdG9yIiwibWludXNYWSIsIngiLCJuZWdhdGUiLCJzdGFydGluZ0FuZ2xlIiwiZW5kQW5nbGUiLCJkaXN0YW5jZVgiLCJNYXRoIiwiYWJzIiwibnVtYmVyT2ZSYXlzIiwiZmxvb3IiLCJkZWx0YVRoZXRhIiwiaSIsImFuZ2xlIiwiY3JlYXRlUG9sYXIiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkxpZ2h0UmF5cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBMaWdodFJheXMgaXMgdGhlIG1vZGVsIG9mIGJ1bmRsZXMgb2YgbGlnaHQgcmF5cy4gSXQncyBwcmltYXJ5IHJlc3BvbnNpYmlsaXR5IGlzIHRvIGNvbGxlY3QgdGhlIHNlZ21lbnRzIG9mXHJcbiAqIG11bHRpcGxlIExpZ2h0UmF5IGluc3RhbmNlcy4gTGlnaHRSYXlzIGFyZSBhbmltYXRlZCBvdmVyIHRpbWUuXHJcbiAqXHJcbiAqIEBhdXRob3IgTWFydGluIFZlaWxsZXR0ZVxyXG4gKiBAYXV0aG9yIENocmlzIE1hbGxleSAoUGl4ZWxab29tLCBJbmMuKVxyXG4gKi9cclxuXHJcbmltcG9ydCBFbWl0dGVyIGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvRW1pdHRlci5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IGdlb21ldHJpY09wdGljcyBmcm9tICcuLi8uLi9nZW9tZXRyaWNPcHRpY3MuanMnO1xyXG5pbXBvcnQgTGlnaHRSYXksIHsgTGlnaHRSYXlTZWdtZW50IH0gZnJvbSAnLi9MaWdodFJheS5qcyc7XHJcbmltcG9ydCBPcHRpYyBmcm9tICcuL09wdGljLmpzJztcclxuaW1wb3J0IHsgUmF5c1R5cGUgfSBmcm9tICcuL1JheXNUeXBlLmpzJztcclxuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgUHJvamVjdGlvblNjcmVlbiBmcm9tICcuL1Byb2plY3Rpb25TY3JlZW4uanMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IE9wdGljYWxJbWFnZSBmcm9tICcuL09wdGljYWxJbWFnZS5qcyc7XHJcbmltcG9ydCBWZWN0b3IyUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjJQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBNdWx0aWxpbmsgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9NdWx0aWxpbmsuanMnO1xyXG5pbXBvcnQgVEVtaXR0ZXIgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9URW1pdHRlci5qcyc7XHJcblxyXG4vLyBjb25zdGFudHMgcmVsYXRlZCB0byAnTWFueScgcmF5cyByZXByZXNlbnRhdGlvbiwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9nZW9tZXRyaWMtb3B0aWNzL2lzc3Vlcy8yODlcclxuY29uc3QgTUFOWV9NSU5fUkFZUyA9IDIwO1xyXG5jb25zdCBNQU5ZX01JTl9SQVlTX0RJU1RBTkNFID0gMzAwOyAvLyBjbSwgTUFOWV9NSU5fUkFZUyB3aWxsIGJlIHNob3duIHVwIHRvIHRoaXMgZGlzdGFuY2UgZnJvbSB0aGUgb3B0aWNcclxuY29uc3QgTUFOWV9GQU5fQU5HTEUgPSBVdGlscy50b1JhZGlhbnMoIDEyMCApOyAvLyBkZWdyZWVzIHRvIHJhZGlhbnNcclxuY29uc3QgVkVDVE9SMl9QUk9QRVJUWSA9IG5ldyBWZWN0b3IyUHJvcGVydHkoIFZlY3RvcjIuWkVSTyApOyAvLyBGb3IgaGVscGluZyB0aGUgdHlwZSBjaGVja2VyIHdpdGggdmFyYXJncyBtdWx0aWxpbmtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpZ2h0UmF5cyB7XHJcblxyXG4gIC8vIHNlZ21lbnRzIGZvciB0aGUgcmVhbCByYXlzIGF0IGEgcG9pbnQgaW4gdGltZVxyXG4gIHB1YmxpYyByZWFsU2VnbWVudHM6IExpZ2h0UmF5U2VnbWVudFtdO1xyXG5cclxuICAvLyBzZWdtZW50cyBmb3IgdGhlIHZpcnR1YWwgcmF5cyBhdCBhIHBvaW50IGluIHRpbWVcclxuICBwdWJsaWMgdmlydHVhbFNlZ21lbnRzOiBMaWdodFJheVNlZ21lbnRbXTtcclxuXHJcbiAgLy8gdGVsbHMgdmlldyB0aGF0IGl0IG5lZWRzIHRvIHVwZGF0ZSwgZmlyZXMgYWZ0ZXIgYWxsIHJheXMgYXJlIHByb2Nlc3NlZC5cclxuICBwdWJsaWMgcmVhZG9ubHkgcmF5c1Byb2Nlc3NlZEVtaXR0ZXI6IFRFbWl0dGVyO1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gb3B0aWNhbE9iamVjdFBvc2l0aW9uUHJvcGVydHkgLSBwb3NpdGlvbiBvZiB0aGUgb3B0aWNhbCBvYmplY3RcclxuICAgKiBAcGFyYW0gb3B0aWMgLSB0aGUgb3B0aWMgdGhhdCB0aGlzIGJ1bmRsZSBvZiByYXlzIG1heSBpbnRlcmFjdCB3aXRoXHJcbiAgICogQHBhcmFtIG9wdGljYWxJbWFnZSAtIG9wdGljYWwgaW1hZ2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmF5XHJcbiAgICogQHBhcmFtIHJheXNUeXBlUHJvcGVydHkgLSByZXByZXNlbnRhdGlvbiB1c2VkIGZvciByYXlzXHJcbiAgICogQHBhcmFtIHJheXNBbmltYXRpb25UaW1lUHJvcGVydHkgLSBlbGFwc2VkIHRpbWUgb2YgbGlnaHQgcmF5cyBhbmltYXRpb25cclxuICAgKiBAcGFyYW0gW3Byb2plY3Rpb25TY3JlZW5dIC0gb3B0aW9uYWwgcHJvamVjdGlvbiBzY3JlZW4gdGhhdCBibG9ja3MgcmF5c1xyXG4gICAqL1xyXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvciggb3B0aWNhbE9iamVjdFBvc2l0aW9uUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PFZlY3RvcjI+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aWM6IE9wdGljLFxyXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aWNhbEltYWdlOiBPcHRpY2FsSW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICByYXlzVHlwZVByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxSYXlzVHlwZT4sXHJcbiAgICAgICAgICAgICAgICAgICAgICByYXlzQW5pbWF0aW9uVGltZVByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxudW1iZXI+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgcHJvamVjdGlvblNjcmVlbj86IFByb2plY3Rpb25TY3JlZW4gKSB7XHJcblxyXG4gICAgdGhpcy5yZWFsU2VnbWVudHMgPSBbXTtcclxuICAgIHRoaXMudmlydHVhbFNlZ21lbnRzID0gW107XHJcbiAgICB0aGlzLnJheXNQcm9jZXNzZWRFbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuXHJcbiAgICAvLyBXaGVuIHRoZSBsaWdodCByYXlzIGFuaW1hdGlvbiBiZWdpbnMsIGhpZGUgdGhlIG9wdGljYWwgaW1hZ2UuIEl0IHdpbGwgYmUgbWFkZSB2aXNpYmxlIHdoZW4gYSByYXkgcmVhY2hlcyB0aGVcclxuICAgIC8vIGltYWdlIHBvc2l0aW9uLiAgSWYgUmF5cyBpcyBzZXQgdG8gJ05vbmUnLCBtYWtlIHRoZSBpbWFnZSB2aXNpYmxlIGltbWVkaWF0ZWx5LCBzaW5jZSB0aGVyZSB3aWxsIGJlIG5vIGFuaW1hdGlvbi5cclxuICAgIE11bHRpbGluay5tdWx0aWxpbmsoIFsgcmF5c1R5cGVQcm9wZXJ0eSwgcmF5c0FuaW1hdGlvblRpbWVQcm9wZXJ0eSBdLCAoIHJheXNUeXBlLCByYXlzQW5pbWF0aW9uVGltZSApID0+IHtcclxuICAgICAgaWYgKCByYXlzVHlwZSA9PT0gJ25vbmUnIHx8IHJheXNBbmltYXRpb25UaW1lID09PSAwICkge1xyXG4gICAgICAgIG9wdGljYWxJbWFnZS52aXNpYmxlUHJvcGVydHkudmFsdWUgPSAoIHJheXNUeXBlUHJvcGVydHkudmFsdWUgPT09ICdub25lJyApO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gVGhpbmdzIHRoYXQgcmVzdWx0IGluIGEgY2hhbmdlIHRvIHRoZSByYXlzLlxyXG4gICAgLy8gV2Ugb25seSBjYXJlIGFib3V0IHRoZSB0eXBlcyBvZiB0aGUgZmlyc3QgMyBkZXBlbmRlbmNpZXMsIGJlY2F1c2UgdGhlIGxpc3RlbmVyIG9ubHkgaGFzIDMgcGFyYW1ldGVycy5cclxuICAgIGNvbnN0IGJvbnVzUHJvcGVydHkgPSBwcm9qZWN0aW9uU2NyZWVuID8gcHJvamVjdGlvblNjcmVlbi5wb3NpdGlvblByb3BlcnR5IDogVkVDVE9SMl9QUk9QRVJUWTtcclxuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IFtcclxuICAgICAgb3B0aWNhbE9iamVjdFBvc2l0aW9uUHJvcGVydHksIHJheXNUeXBlUHJvcGVydHksIHJheXNBbmltYXRpb25UaW1lUHJvcGVydHksXHJcbiAgICAgIG9wdGljLnBvc2l0aW9uUHJvcGVydHksIG9wdGljLmRpYW1ldGVyUHJvcGVydHksIG9wdGljLmZvY2FsTGVuZ3RoUHJvcGVydHksIG9wdGljLm9wdGljU3VyZmFjZVR5cGVQcm9wZXJ0eSxcclxuICAgICAgYm9udXNQcm9wZXJ0eVxyXG4gICAgXSBhcyBjb25zdDtcclxuXHJcbiAgICAvLyBVcGRhdGUgYWxsIHJheXMsIHRoZW4gaW5mb3JtIGxpc3RlbmVycyB2aWEgcmF5c1Byb2Nlc3NlZEVtaXR0ZXIuXHJcbiAgICBNdWx0aWxpbmsubXVsdGlsaW5rKCBkZXBlbmRlbmNpZXMsXHJcbiAgICAgICggb3B0aWNhbE9iamVjdFBvc2l0aW9uLCByYXlzVHlwZSwgcmF5c0FuaW1hdGlvblRpbWUgKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIHRoZSBhcnJheXMuXHJcbiAgICAgICAgdGhpcy5yZWFsU2VnbWVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLnZpcnR1YWxTZWdtZW50cyA9IFtdO1xyXG5cclxuICAgICAgICAvLyB0aGUgcG9zaXRpb24gdGhlIG9wdGljYWxJbWFnZVxyXG4gICAgICAgIGNvbnN0IG9wdGljYWxJbWFnZVBvc2l0aW9uID0gb3B0aWNhbEltYWdlLnBvc2l0aW9uUHJvcGVydHkudmFsdWU7XHJcblxyXG4gICAgICAgIC8vIGlzIHRoZSBJbWFnZSB2aXJ0dWFsXHJcbiAgICAgICAgY29uc3QgaXNWaXJ0dWFsID0gKCBvcHRpY2FsSW1hZ2Uub3B0aWNhbEltYWdlVHlwZVByb3BlcnR5LnZhbHVlID09PSAndmlydHVhbCcgKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHRoZSBpbml0aWFsIGRpcmVjdGlvbnMgb2YgdGhlIHJheXNcclxuICAgICAgICBjb25zdCBkaXJlY3Rpb25zOiBWZWN0b3IyW10gPSBnZXRSYXlEaXJlY3Rpb25zKCByYXlzVHlwZSwgb3B0aWNhbE9iamVjdFBvc2l0aW9uLCBvcHRpYywgb3B0aWNhbEltYWdlUG9zaXRpb24gKTtcclxuXHJcbiAgICAgICAgLy8gbG9vcCBvdmVyIHRoZSBkaXJlY3Rpb24gb2YgZWFjaCByYXlcclxuICAgICAgICBkaXJlY3Rpb25zLmZvckVhY2goIGRpcmVjdGlvbiA9PiB7XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgTGlnaHRSYXksIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyByZWFsIGFuZCB2aXJ0dWFsIHJheSBzZWdtZW50cy5cclxuICAgICAgICAgIGNvbnN0IGxpZ2h0UmF5ID0gbmV3IExpZ2h0UmF5KCBvcHRpY2FsT2JqZWN0UG9zaXRpb24sIGRpcmVjdGlvbiwgcmF5c0FuaW1hdGlvblRpbWUsIG9wdGljLCBvcHRpY2FsSW1hZ2VQb3NpdGlvbiwgaXNWaXJ0dWFsLFxyXG4gICAgICAgICAgICByYXlzVHlwZSwgcHJvamVjdGlvblNjcmVlbiApO1xyXG5cclxuICAgICAgICAgIC8vIFNldCBvcHRpY2FsIGltYWdlJ3MgdmlzaWJpbGl0eSB0byB0cnVlIHdoZW4gYSByYXkgcmVhY2hlcyB0aGUgb3B0aWNhbCBpbWFnZSBvciBwcm9qZWN0aW9uIHNjcmVlbi5cclxuICAgICAgICAgIGlmICggbGlnaHRSYXkuaGFzUmVhY2hlZFRhcmdldCApIHtcclxuICAgICAgICAgICAgb3B0aWNhbEltYWdlLnZpc2libGVQcm9wZXJ0eS52YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQWRkIExpZ2h0UmF5U2VnbWVudHNcclxuICAgICAgICAgIHRoaXMucmVhbFNlZ21lbnRzLnB1c2goIC4uLmxpZ2h0UmF5LnJlYWxTZWdtZW50cyApO1xyXG4gICAgICAgICAgdGhpcy52aXJ0dWFsU2VnbWVudHMucHVzaCggLi4ubGlnaHRSYXkudmlydHVhbFNlZ21lbnRzICk7XHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgICAgICB0aGlzLnJheXNQcm9jZXNzZWRFbWl0dGVyLmVtaXQoKTtcclxuICAgICAgfSApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ2Rpc3Bvc2UgaXMgbm90IHN1cHBvcnRlZCwgZXhpc3RzIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbScgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBpbml0aWFsIGRpcmVjdGlvbnMgKGFzIHVuaXQgdmVjdG9ycykgb2YgdGhlIHJheXMgZm9yIHRoZSBkaWZmZXJlbnQgcmF5IHR5cGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmF5RGlyZWN0aW9ucyggcmF5c1R5cGU6IFJheXNUeXBlLCBvcHRpY2FsT2JqZWN0UG9zaXRpb246IFZlY3RvcjIsIG9wdGljOiBPcHRpYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aWNhbEltYWdlUG9zaXRpb246IFZlY3RvcjIgKTogVmVjdG9yMltdIHtcclxuXHJcbiAgLy8gZGlyZWN0aW9ucyBvZiB0aGUgbGlnaHQgcmF5cyBlbWFuYXRpbmcgZnJvbSBvcHRpY2FsT2JqZWN0UG9zaXRpb25cclxuICBjb25zdCBkaXJlY3Rpb25zOiBWZWN0b3IyW10gPSBbXTtcclxuXHJcbiAgLy8gdmVjdG9yIGZyb20gb2JqZWN0IHRvIG9wdGljXHJcbiAgY29uc3Qgb2JqZWN0T3B0aWNWZWN0b3IgPSBvcHRpYy5wb3NpdGlvblByb3BlcnR5LnZhbHVlLm1pbnVzKCBvcHRpY2FsT2JqZWN0UG9zaXRpb24gKTtcclxuXHJcbiAgaWYgKCByYXlzVHlwZSA9PT0gJ21hcmdpbmFsJyApIHtcclxuXHJcbiAgICAvLyAzIHJheXM6IHRocm91Z2ggY2VudGVyLCB0b3AsIGFuZCBib3R0b20gb2Ygb3B0aWMuXHJcblxyXG4gICAgLy8gIzE6IGNlbnRlciBvZiB0aGUgb3B0aWNcclxuICAgIGRpcmVjdGlvbnMucHVzaCggb2JqZWN0T3B0aWNWZWN0b3Iubm9ybWFsaXplZCgpICk7XHJcblxyXG4gICAgLy8gIzI6IHRvcCBvZiB0aGUgb3B0aWNcclxuICAgIGNvbnN0IHRvcFBvaW50ID0gb3B0aWMuZ2V0VG9wUG9pbnQoIG9wdGljYWxPYmplY3RQb3NpdGlvbiwgb3B0aWNhbEltYWdlUG9zaXRpb24gKTtcclxuICAgIGNvbnN0IHRvcERpcmVjdGlvbiA9IHRvcFBvaW50Lm1pbnVzKCBvcHRpY2FsT2JqZWN0UG9zaXRpb24gKS5ub3JtYWxpemVkKCk7XHJcbiAgICBkaXJlY3Rpb25zLnB1c2goIHRvcERpcmVjdGlvbiApO1xyXG5cclxuICAgIC8vICMzOiBib3R0b20gb2YgdGhlIG9wdGljXHJcbiAgICBjb25zdCBib3R0b21Qb2ludCA9IG9wdGljLmdldEJvdHRvbVBvaW50KCBvcHRpY2FsT2JqZWN0UG9zaXRpb24sIG9wdGljYWxJbWFnZVBvc2l0aW9uICk7XHJcbiAgICBjb25zdCBib3R0b21EaXJlY3Rpb24gPSBib3R0b21Qb2ludC5taW51cyggb3B0aWNhbE9iamVjdFBvc2l0aW9uICkubm9ybWFsaXplZCgpO1xyXG4gICAgZGlyZWN0aW9ucy5wdXNoKCBib3R0b21EaXJlY3Rpb24gKTtcclxuICB9XHJcbiAgZWxzZSBpZiAoIHJheXNUeXBlID09PSAncHJpbmNpcGFsJyApIHtcclxuXHJcbiAgICAvLyAzIHJheXM6IHBhcmFsbGVsIHRvIG9wdGljYWwgYXhpcywgdGhyb3VnaCBjZW50ZXIgb2Ygb3B0aWMsIHRocm91Z2ggZm9jYWwgcG9pbnQgb24gbGVmdCBzaWRlIG9mIG9wdGljXHJcbiAgICAvLyBUaGlzIHJlcHJlc2VudGF0aW9uIGNhbiByZXN1bHQgaW4gc29tZSBjb25mdXNpb24sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvZ2VvbWV0cmljLW9wdGljcy9pc3N1ZXMvMTQwLlxyXG5cclxuICAgIC8vICMxOiBwYXJhbGxlbCB0byB0aGUgb3B0aWNhbCBheGlzXHJcbiAgICBkaXJlY3Rpb25zLnB1c2goIG5ldyBWZWN0b3IyKCAxLCAwICkgKTtcclxuXHJcbiAgICAvLyAjMjogdGhyb3VnaCB0aGUgY2VudGVyIG9mIG9wdGljXHJcbiAgICBkaXJlY3Rpb25zLnB1c2goIG9iamVjdE9wdGljVmVjdG9yLm5vcm1hbGl6ZWQoKSApO1xyXG5cclxuICAgIC8vICMzOiB0aHJvdWdoIHRoZSBmb2NhbCBwb2ludFxyXG4gICAgY29uc3QgZmlyc3RGb2NhbFZlY3RvciA9IG9iamVjdE9wdGljVmVjdG9yLm1pbnVzWFkoIG9wdGljLmZvY2FsTGVuZ3RoUHJvcGVydHkudmFsdWUsIDAgKTtcclxuICAgIGlmICggZmlyc3RGb2NhbFZlY3Rvci54IDwgMCApIHtcclxuICAgICAgZmlyc3RGb2NhbFZlY3Rvci5uZWdhdGUoKTsgLy8gc2hvdWxkIHBvaW50IHRvIHRoZSByaWdodCwgdG8gaW5kaWNhdGUgdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGlnaHQgcmF5c1xyXG4gICAgfVxyXG4gICAgZGlyZWN0aW9ucy5wdXNoKCBmaXJzdEZvY2FsVmVjdG9yLm5vcm1hbGl6ZWQoKSApO1xyXG4gIH1cclxuICBlbHNlIGlmICggcmF5c1R5cGUgPT09ICdtYW55JyApIHtcclxuXHJcbiAgICAvLyBOdW1iZXIgb2YgcmF5cyBkZXBlbmRzIG9uIGhvdyBmYXIgb3B0aWNhbE9iamVjdFBvc2l0aW9uIGlzIGZyb20gdGhlIG9wdGljLiBCdXQgd2Ugd2FudCBhdCBsZWFzdCAyIHJheXMgdG9cclxuICAgIC8vIGdvIHRocm91Z2ggdGhlIG9wdGljLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2dlb21ldHJpYy1vcHRpY3MvaXNzdWVzLzI4OS5cclxuXHJcbiAgICAvLyBzdGFydGluZyBhbmdsZSBmb3IgZmFuIG9mIHJheXNcclxuICAgIGNvbnN0IHN0YXJ0aW5nQW5nbGUgPSBNQU5ZX0ZBTl9BTkdMRSAvIDI7XHJcblxyXG4gICAgLy8gc3ltbWV0cmljIGNvbmRpdGlvbiBmb3IgZW5kIGFuZ2xlXHJcbiAgICBjb25zdCBlbmRBbmdsZSA9IC1zdGFydGluZ0FuZ2xlO1xyXG5cclxuICAgIC8vIHggZGlzdGFuY2UgZnJvbSB0aGUgT2JqZWN0IHRvIHRoZSBvcHRpY1xyXG4gICAgY29uc3QgZGlzdGFuY2VYID0gTWF0aC5hYnMoIG9wdGljLnBvc2l0aW9uUHJvcGVydHkudmFsdWUueCAtIG9wdGljYWxPYmplY3RQb3NpdGlvbi54ICk7XHJcblxyXG4gICAgLy8gbnVtYmVyIG9mIHJheXNcclxuICAgIGNvbnN0IG51bWJlck9mUmF5cyA9IE1BTllfTUlOX1JBWVMgKiAoIE1hdGguZmxvb3IoIGRpc3RhbmNlWCAvIE1BTllfTUlOX1JBWVNfRElTVEFOQ0UgKSArIDEgKTtcclxuXHJcbiAgICAvLyBEZWdyZWVzIGJldHdlZW4gYWRqYWNlbnQgYXJyYXlzXHJcbiAgICBjb25zdCBkZWx0YVRoZXRhID0gKCBlbmRBbmdsZSAtIHN0YXJ0aW5nQW5nbGUgKSAvICggbnVtYmVyT2ZSYXlzIC0gMSApO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIGZhbiBvZiBlcXVpZGlzdGFudCByYXlzIGJldHdlZW4gc3RhcnRpbmdBbmdsZSBhbmQgZW5kQW5nbGUuXHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlJheXM7IGkrKyApIHtcclxuICAgICAgY29uc3QgYW5nbGUgPSBzdGFydGluZ0FuZ2xlICsgaSAqIGRlbHRhVGhldGE7XHJcbiAgICAgIGRpcmVjdGlvbnMucHVzaCggVmVjdG9yMi5jcmVhdGVQb2xhciggMSwgYW5nbGUgKSApO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZGlyZWN0aW9ucztcclxufVxyXG5cclxuZ2VvbWV0cmljT3B0aWNzLnJlZ2lzdGVyKCAnTGlnaHRSYXlzJywgTGlnaHRSYXlzICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxPQUFPLE1BQU0sZ0NBQWdDO0FBQ3BELE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsZUFBZSxNQUFNLDBCQUEwQjtBQUN0RCxPQUFPQyxRQUFRLE1BQTJCLGVBQWU7QUFLekQsT0FBT0MsS0FBSyxNQUFNLDZCQUE2QjtBQUUvQyxPQUFPQyxlQUFlLE1BQU0sdUNBQXVDO0FBQ25FLE9BQU9DLFNBQVMsTUFBTSxrQ0FBa0M7QUFHeEQ7QUFDQSxNQUFNQyxhQUFhLEdBQUcsRUFBRTtBQUN4QixNQUFNQyxzQkFBc0IsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUNwQyxNQUFNQyxjQUFjLEdBQUdMLEtBQUssQ0FBQ00sU0FBUyxDQUFFLEdBQUksQ0FBQyxDQUFDLENBQUM7QUFDL0MsTUFBTUMsZ0JBQWdCLEdBQUcsSUFBSU4sZUFBZSxDQUFFSixPQUFPLENBQUNXLElBQUssQ0FBQyxDQUFDLENBQUM7O0FBRTlELGVBQWUsTUFBTUMsU0FBUyxDQUFDO0VBRTdCOztFQUdBOztFQUdBOztFQUdBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDU0MsV0FBV0EsQ0FBRUMsNkJBQXlELEVBQ3pEQyxLQUFZLEVBQ1pDLFlBQTBCLEVBQzFCQyxnQkFBNkMsRUFDN0NDLHlCQUFvRCxF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