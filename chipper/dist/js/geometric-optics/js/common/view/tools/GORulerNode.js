// Copyright 2021-2022, University of Colorado Boulder

/**
 * GORulerNode is the view of a ruler. Responsibilities include:
 *
 * - It wraps a scenery-phet.RulerNode, which is re-created when the zoom level changes.
 * - As the zoom level is changed, the view dimensions remain constant, but the tick marks change.
 * - It handles dragging, including dragging back to the toolbox.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Sarah Chang (Swarthmore College)
 */

import DerivedProperty from '../../../../../axon/js/DerivedProperty.js';
import Utils from '../../../../../dot/js/Utils.js';
import PhetFont from '../../../../../scenery-phet/js/PhetFont.js';
import RulerNode from '../../../../../scenery-phet/js/RulerNode.js';
import geometricOptics from '../../../geometricOptics.js';
import GeometricOpticsStrings from '../../../GeometricOpticsStrings.js';
import GOConstants from '../../GOConstants.js';
import Vector2 from '../../../../../dot/js/Vector2.js';
import Tandem from '../../../../../tandem/js/Tandem.js';
import GORulerIcon from './GORulerIcon.js';
import GOToolNode from './GOToolNode.js';
import GOToolKeyboardDragListener from './GOToolKeyboardDragListener.js';
import GOToolDragListener from './GOToolDragListener.js';
import optionize from '../../../../../phet-core/js/optionize.js';

// constants
const MINIMUM_VISIBLE_LENGTH = GOConstants.RULER_MINIMUM_VISIBLE_LENGTH;
export default class GORulerNode extends GOToolNode {
  // See GOToolNode

  // the ruler model that is associated with this Node

  /**
   * @param ruler - model element
   * @param opticPositionProperty - position of the optic
   * @param zoomTransformProperty - model-view transform that the user controls by zooming in/out
   * @param zoomScaleProperty - scale factor for the current zoom level
   * @param visibleBoundsProperty - visible bounds of the ScreenView
   * @param providedOptions
   */
  constructor(ruler, opticPositionProperty, zoomTransformProperty, zoomScaleProperty, visibleBoundsProperty, providedOptions) {
    const options = optionize()({
      rotation: ruler.orientation === 'vertical' ? -Math.PI / 2 : 0
    }, providedOptions);
    super(ruler, options);
    this.icon = new GORulerIcon(ruler, this, zoomTransformProperty);
    this.ruler = ruler;
    this.opticPositionProperty = opticPositionProperty;

    // Create a RulerNode subcomponent whose scale matches the current zoom level.
    // Must be disposed, because it links to a translated string Property.
    let rulerNode;
    zoomTransformProperty.link(zoomTransform => {
      // zoomTransformProperty is derived from zoomScaleProperty, so zoomScaleProperty does not need to be
      // a dependency of this listener, and it's safe to use its value.
      assert && assert(zoomTransformProperty.hasDependency(zoomScaleProperty));
      const zoomScale = zoomScaleProperty.value;

      // update ruler size, so that view size remains the same
      ruler.scaleLength(zoomScale);

      // update view
      this.removeAllChildren();
      rulerNode && rulerNode.dispose();
      rulerNode = createRulerNode(this.ruler.length, zoomTransform, zoomScale);
      this.addChild(rulerNode);
    });

    // Origin is at leftBottom for a vertical ruler, leftTop for a horizontal ruler.
    ruler.positionProperty.link(position => {
      const viewPosition = zoomTransformProperty.value.modelToViewPosition(position);
      if (this.ruler.orientation === 'vertical') {
        this.leftBottom = viewPosition;
      } else {
        this.leftTop = viewPosition;
      }
    });

    // Update the ruler's model position to match this Node's view position, so that the ruler remains stationary
    // in the view, and the model is correct.
    zoomTransformProperty.lazyLink(zoomTransform => {
      ruler.positionProperty.value = this.ruler.orientation === 'vertical' ? zoomTransform.viewToModelPosition(this.leftBottom) : zoomTransform.viewToModelPosition(this.leftTop);
    });

    // Drag bounds for the ruler, in model coordinates.
    // This keeps a part of the ruler inside the visible bounds of the ScreenView.
    this.dragBoundsProperty = new DerivedProperty([visibleBoundsProperty, zoomTransformProperty], (visibleBounds, zoomTransform) => {
      let viewDragBounds;
      if (ruler.orientation === 'vertical') {
        // if vertical the left and right bounds of the ruler stay within visible bounds
        // minimum visible length of the ruler is always showing inside top and bottom visible bounds.
        viewDragBounds = visibleBounds.withOffsets(0, -MINIMUM_VISIBLE_LENGTH, -this.width, -MINIMUM_VISIBLE_LENGTH + this.height);
      } else {
        // if horizontal ruler, the bottom and top bounds of the ruler stay within visible bounds
        // minimum visible length of the ruler is always showing inside left  and right visible bounds.
        viewDragBounds = visibleBounds.withOffsets(this.width - MINIMUM_VISIBLE_LENGTH, 0, -MINIMUM_VISIBLE_LENGTH, -this.height);
      }
      return zoomTransform.viewToModelBounds(viewDragBounds);
    });

    // Keep the ruler inside the drag bounds.
    this.dragBoundsProperty.link(dragBounds => {
      ruler.positionProperty.value = dragBounds.closestPointTo(ruler.positionProperty.value);
    });

    // Return to the toolbox when the pointer is released inside the toolbox.
    // toolboxNode should be set by the time this is called.
    const dragReturnToToolbox = pointerPoint => this.toolboxNode.containsGlobalPoint(pointerPoint);

    // Dragging with the pointer.
    this.dragListener = new GOToolDragListener(ruler, this, zoomTransformProperty, this.dragBoundsProperty, dragReturnToToolbox, {
      tandem: options.tandem.createTandem('dragListener')
    });
    this.addInputListener(this.dragListener);

    // Return the ruler to the toolbox if the ruler's center point is inside the toolbox.
    // toolboxNode should be set by the time this is called.
    const keyboardDragReturnToToolbox = () => this.toolboxNode.containsGlobalPoint(this.parentToGlobalPoint(this.center));

    // Dragging with the keyboard.
    const keyboardDragListener = new GOToolKeyboardDragListener(ruler, this, zoomTransformProperty, this.dragBoundsProperty, keyboardDragReturnToToolbox, {
      tandem: options.tandem.createTandem('keyboardDragListener')
    });
    this.addInputListener(keyboardDragListener);
  }

  /**
   * Handles the 'J' (Jump) hotkey, which moves the ruler to the next 'interesting' point.
   * See https://github.com/phetsims/geometric-optics/issues/310
   */
  jumpToPoint() {
    const rulerPosition = this.ruler.positionProperty.value;

    // Find the points that are relevant.
    const relevantJumpPoints = this.jumpPoints.filter(jumpPoint =>
    // not null
    jumpPoint.positionProperty.value !== null &&
    // visible
    jumpPoint.visibleProperty.value &&
    // inside the tool's drag bounds, so the tool doesn't move out of bounds
    this.dragBoundsProperty.value.containsPoint(jumpPoint.positionProperty.value) &&
    // For horizontal rulers, exclude points to the right of the optic, because they are not useful.
    !(this.ruler.orientation === 'horizontal' && jumpPoint.positionProperty.value.x > this.opticPositionProperty.value.x) &&
    // For vertical rulers, exclude points on the optical axis (except the optic), because they are not useful.
    !(this.ruler.orientation === 'vertical' && jumpPoint.positionProperty.value.y === this.opticPositionProperty.value.y && !jumpPoint.positionProperty.value.equals(this.opticPositionProperty.value)));

    // Find the next jump point and move there.
    if (relevantJumpPoints.length > 0) {
      // Change the y coordinate of each point, based on the ruler's orientation. Horizontal rulers are placed on the
      // optical axis. Placement of vertical rulers depends on whether the jump point is above or below the optical
      // axis, and the ruler is placed so that we're always measuring a distance from the optical axis.
      const changeYCoordinates = points => points.map(point => {
        const opticY = this.opticPositionProperty.value.y;
        const y = this.ruler.orientation === 'horizontal' ? opticY : Math.min(point.y, opticY);
        return new Vector2(point.x, y);
      });

      // Get the next point, based on the ruler's position.
      const nextPoint = GOToolNode.getNextJumpPoint(relevantJumpPoints, rulerPosition, changeYCoordinates);

      // Move the ruler
      if (nextPoint) {
        this.ruler.positionProperty.value = nextPoint;
      }
    }
  }
}

/**
 * Creates a scenery-phet.RulerNode appropriate for the zoomTransform and zoom scale.
 */
function createRulerNode(rulerLength, zoomTransform, zoomScale) {
  // define the length ruler
  const rulerWidth = zoomTransform.modelToViewDeltaX(rulerLength);
  const majorTickInterval = 10 / zoomScale; // in model coordinate (cm)

  // separation between the major ticks mark
  const majorTickWidth = zoomTransform.modelToViewDeltaX(majorTickInterval);

  // set the units at the end of ruler
  const numberOfMajorTicks = Math.floor(rulerWidth / majorTickWidth) + 1;
  const unitsMajorTickIndex = numberOfMajorTicks - 3;

  // create major ticks label
  const majorTickLabels = [];
  for (let i = 0; i < numberOfMajorTicks; i++) {
    // skip labels on every other major ticks
    if (i % 2 === 0) {
      majorTickLabels[i] = Utils.toFixed(i * majorTickInterval, 0);
    } else {
      majorTickLabels[i] = '';
    }
  }
  return new RulerNode(rulerWidth, GOConstants.RULER_HEIGHT, majorTickWidth, majorTickLabels, GeometricOpticsStrings.centimetersStringProperty, {
    opacity: 0.8,
    minorTicksPerMajorTick: 4,
    majorTickFont: new PhetFont(13),
    unitsMajorTickIndex: unitsMajorTickIndex,
    insetsWidth: 0,
    // Because RulerNode instances are created dynamically, whenever the zoom level changes.
    // GORulerNode is therefore a wrapper around RulerNode, and will consequently not have the
    // same PhET-iO API as RulerNode.
    tandem: Tandem.OPT_OUT
  });
}
geometricOptics.register('GORulerNode', GORulerNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEZXJpdmVkUHJvcGVydHkiLCJVdGlscyIsIlBoZXRGb250IiwiUnVsZXJOb2RlIiwiZ2VvbWV0cmljT3B0aWNzIiwiR2VvbWV0cmljT3B0aWNzU3RyaW5ncyIsIkdPQ29uc3RhbnRzIiwiVmVjdG9yMiIsIlRhbmRlbSIsIkdPUnVsZXJJY29uIiwiR09Ub29sTm9kZSIsIkdPVG9vbEtleWJvYXJkRHJhZ0xpc3RlbmVyIiwiR09Ub29sRHJhZ0xpc3RlbmVyIiwib3B0aW9uaXplIiwiTUlOSU1VTV9WSVNJQkxFX0xFTkdUSCIsIlJVTEVSX01JTklNVU1fVklTSUJMRV9MRU5HVEgiLCJHT1J1bGVyTm9kZSIsImNvbnN0cnVjdG9yIiwicnVsZXIiLCJvcHRpY1Bvc2l0aW9uUHJvcGVydHkiLCJ6b29tVHJhbnNmb3JtUHJvcGVydHkiLCJ6b29tU2NhbGVQcm9wZXJ0eSIsInZpc2libGVCb3VuZHNQcm9wZXJ0eSIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJyb3RhdGlvbiIsIm9yaWVudGF0aW9uIiwiTWF0aCIsIlBJIiwiaWNvbiIsInJ1bGVyTm9kZSIsImxpbmsiLCJ6b29tVHJhbnNmb3JtIiwiYXNzZXJ0IiwiaGFzRGVwZW5kZW5jeSIsInpvb21TY2FsZSIsInZhbHVlIiwic2NhbGVMZW5ndGgiLCJyZW1vdmVBbGxDaGlsZHJlbiIsImRpc3Bvc2UiLCJjcmVhdGVSdWxlck5vZGUiLCJsZW5ndGgiLCJhZGRDaGlsZCIsInBvc2l0aW9uUHJvcGVydHkiLCJwb3NpdGlvbiIsInZpZXdQb3NpdGlvbiIsIm1vZGVsVG9WaWV3UG9zaXRpb24iLCJsZWZ0Qm90dG9tIiwibGVmdFRvcCIsImxhenlMaW5rIiwidmlld1RvTW9kZWxQb3NpdGlvbiIsImRyYWdCb3VuZHNQcm9wZXJ0eSIsInZpc2libGVCb3VuZHMiLCJ2aWV3RHJhZ0JvdW5kcyIsIndpdGhPZmZzZXRzIiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3VG9Nb2RlbEJvdW5kcyIsImRyYWdCb3VuZHMiLCJjbG9zZXN0UG9pbnRUbyIsImRyYWdSZXR1cm5Ub1Rvb2xib3giLCJwb2ludGVyUG9pbnQiLCJ0b29sYm94Tm9kZSIsImNvbnRhaW5zR2xvYmFsUG9pbnQiLCJkcmFnTGlzdGVuZXIiLCJ0YW5kZW0iLCJjcmVhdGVUYW5kZW0iLCJhZGRJbnB1dExpc3RlbmVyIiwia2V5Ym9hcmREcmFnUmV0dXJuVG9Ub29sYm94IiwicGFyZW50VG9HbG9iYWxQb2ludCIsImNlbnRlciIsImtleWJvYXJkRHJhZ0xpc3RlbmVyIiwianVtcFRvUG9pbnQiLCJydWxlclBvc2l0aW9uIiwicmVsZXZhbnRKdW1wUG9pbnRzIiwianVtcFBvaW50cyIsImZpbHRlciIsImp1bXBQb2ludCIsInZpc2libGVQcm9wZXJ0eSIsImNvbnRhaW5zUG9pbnQiLCJ4IiwieSIsImVxdWFscyIsImNoYW5nZVlDb29yZGluYXRlcyIsInBvaW50cyIsIm1hcCIsInBvaW50Iiwib3B0aWNZIiwibWluIiwibmV4dFBvaW50IiwiZ2V0TmV4dEp1bXBQb2ludCIsInJ1bGVyTGVuZ3RoIiwicnVsZXJXaWR0aCIsIm1vZGVsVG9WaWV3RGVsdGFYIiwibWFqb3JUaWNrSW50ZXJ2YWwiLCJtYWpvclRpY2tXaWR0aCIsIm51bWJlck9mTWFqb3JUaWNrcyIsImZsb29yIiwidW5pdHNNYWpvclRpY2tJbmRleCIsIm1ham9yVGlja0xhYmVscyIsImkiLCJ0b0ZpeGVkIiwiUlVMRVJfSEVJR0hUIiwiY2VudGltZXRlcnNTdHJpbmdQcm9wZXJ0eSIsIm9wYWNpdHkiLCJtaW5vclRpY2tzUGVyTWFqb3JUaWNrIiwibWFqb3JUaWNrRm9udCIsImluc2V0c1dpZHRoIiwiT1BUX09VVCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiR09SdWxlck5vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogR09SdWxlck5vZGUgaXMgdGhlIHZpZXcgb2YgYSBydWxlci4gUmVzcG9uc2liaWxpdGllcyBpbmNsdWRlOlxyXG4gKlxyXG4gKiAtIEl0IHdyYXBzIGEgc2NlbmVyeS1waGV0LlJ1bGVyTm9kZSwgd2hpY2ggaXMgcmUtY3JlYXRlZCB3aGVuIHRoZSB6b29tIGxldmVsIGNoYW5nZXMuXHJcbiAqIC0gQXMgdGhlIHpvb20gbGV2ZWwgaXMgY2hhbmdlZCwgdGhlIHZpZXcgZGltZW5zaW9ucyByZW1haW4gY29uc3RhbnQsIGJ1dCB0aGUgdGljayBtYXJrcyBjaGFuZ2UuXHJcbiAqIC0gSXQgaGFuZGxlcyBkcmFnZ2luZywgaW5jbHVkaW5nIGRyYWdnaW5nIGJhY2sgdG8gdGhlIHRvb2xib3guXHJcbiAqXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqIEBhdXRob3IgU2FyYWggQ2hhbmcgKFN3YXJ0aG1vcmUgQ29sbGVnZSlcclxuICovXHJcblxyXG5pbXBvcnQgRGVyaXZlZFByb3BlcnR5LCB7IFVua25vd25EZXJpdmVkUHJvcGVydHkgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9heG9uL2pzL0Rlcml2ZWRQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCBNb2RlbFZpZXdUcmFuc2Zvcm0yIGZyb20gJy4uLy4uLy4uLy4uLy4uL3BoZXRjb21tb24vanMvdmlldy9Nb2RlbFZpZXdUcmFuc2Zvcm0yLmpzJztcclxuaW1wb3J0IFBoZXRGb250IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9QaGV0Rm9udC5qcyc7XHJcbmltcG9ydCBSdWxlck5vZGUgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2NlbmVyeS1waGV0L2pzL1J1bGVyTm9kZS5qcyc7XHJcbmltcG9ydCB7IERyYWdMaXN0ZW5lciB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBnZW9tZXRyaWNPcHRpY3MgZnJvbSAnLi4vLi4vLi4vZ2VvbWV0cmljT3B0aWNzLmpzJztcclxuaW1wb3J0IEdlb21ldHJpY09wdGljc1N0cmluZ3MgZnJvbSAnLi4vLi4vLi4vR2VvbWV0cmljT3B0aWNzU3RyaW5ncy5qcyc7XHJcbmltcG9ydCBHT0NvbnN0YW50cyBmcm9tICcuLi8uLi9HT0NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBHT1J1bGVyIGZyb20gJy4uLy4uL21vZGVsL3Rvb2xzL0dPUnVsZXIuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBUYW5kZW0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdGFuZGVtL2pzL1RhbmRlbS5qcyc7XHJcbmltcG9ydCBHT1J1bGVySWNvbiBmcm9tICcuL0dPUnVsZXJJY29uLmpzJztcclxuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgR09Ub29sTm9kZSwgeyBHT1Rvb2xOb2RlT3B0aW9ucyB9IGZyb20gJy4vR09Ub29sTm9kZS5qcyc7XHJcbmltcG9ydCBHT1Rvb2xLZXlib2FyZERyYWdMaXN0ZW5lciBmcm9tICcuL0dPVG9vbEtleWJvYXJkRHJhZ0xpc3RlbmVyLmpzJztcclxuaW1wb3J0IEdPVG9vbERyYWdMaXN0ZW5lciBmcm9tICcuL0dPVG9vbERyYWdMaXN0ZW5lci5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUsIHsgRW1wdHlTZWxmT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IE1JTklNVU1fVklTSUJMRV9MRU5HVEggPSBHT0NvbnN0YW50cy5SVUxFUl9NSU5JTVVNX1ZJU0lCTEVfTEVOR1RIO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IEVtcHR5U2VsZk9wdGlvbnM7XHJcblxyXG5leHBvcnQgdHlwZSBHT1J1bGVyTm9kZU9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIEdPVG9vbE5vZGVPcHRpb25zO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR09SdWxlck5vZGUgZXh0ZW5kcyBHT1Rvb2xOb2RlIHtcclxuXHJcbiAgLy8gU2VlIEdPVG9vbE5vZGVcclxuICBwdWJsaWMgcmVhZG9ubHkgaWNvbjogR09SdWxlckljb247XHJcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRyYWdMaXN0ZW5lcjogRHJhZ0xpc3RlbmVyO1xyXG5cclxuICAvLyB0aGUgcnVsZXIgbW9kZWwgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBOb2RlXHJcbiAgcHVibGljIHJlYWRvbmx5IHJ1bGVyOiBHT1J1bGVyO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IG9wdGljUG9zaXRpb25Qcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8VmVjdG9yMj47XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgZHJhZ0JvdW5kc1Byb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxCb3VuZHMyPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHJ1bGVyIC0gbW9kZWwgZWxlbWVudFxyXG4gICAqIEBwYXJhbSBvcHRpY1Bvc2l0aW9uUHJvcGVydHkgLSBwb3NpdGlvbiBvZiB0aGUgb3B0aWNcclxuICAgKiBAcGFyYW0gem9vbVRyYW5zZm9ybVByb3BlcnR5IC0gbW9kZWwtdmlldyB0cmFuc2Zvcm0gdGhhdCB0aGUgdXNlciBjb250cm9scyBieSB6b29taW5nIGluL291dFxyXG4gICAqIEBwYXJhbSB6b29tU2NhbGVQcm9wZXJ0eSAtIHNjYWxlIGZhY3RvciBmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxyXG4gICAqIEBwYXJhbSB2aXNpYmxlQm91bmRzUHJvcGVydHkgLSB2aXNpYmxlIGJvdW5kcyBvZiB0aGUgU2NyZWVuVmlld1xyXG4gICAqIEBwYXJhbSBwcm92aWRlZE9wdGlvbnNcclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIHJ1bGVyOiBHT1J1bGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aWNQb3NpdGlvblByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxWZWN0b3IyPixcclxuICAgICAgICAgICAgICAgICAgICAgIHpvb21UcmFuc2Zvcm1Qcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8TW9kZWxWaWV3VHJhbnNmb3JtMj4gJiBQaWNrPFVua25vd25EZXJpdmVkUHJvcGVydHk8dW5rbm93bj4sICdoYXNEZXBlbmRlbmN5Jz4sXHJcbiAgICAgICAgICAgICAgICAgICAgICB6b29tU2NhbGVQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8bnVtYmVyPixcclxuICAgICAgICAgICAgICAgICAgICAgIHZpc2libGVCb3VuZHNQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8Qm91bmRzMj4sXHJcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZE9wdGlvbnM6IEdPUnVsZXJOb2RlT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPEdPUnVsZXJOb2RlT3B0aW9ucywgU2VsZk9wdGlvbnMsIEdPVG9vbE5vZGVPcHRpb25zPigpKCB7XHJcbiAgICAgIHJvdGF0aW9uOiAoIHJ1bGVyLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnICkgPyAoIC1NYXRoLlBJIC8gMiApIDogMFxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgc3VwZXIoIHJ1bGVyLCBvcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy5pY29uID0gbmV3IEdPUnVsZXJJY29uKCBydWxlciwgdGhpcywgem9vbVRyYW5zZm9ybVByb3BlcnR5ICk7XHJcbiAgICB0aGlzLnJ1bGVyID0gcnVsZXI7XHJcbiAgICB0aGlzLm9wdGljUG9zaXRpb25Qcm9wZXJ0eSA9IG9wdGljUG9zaXRpb25Qcm9wZXJ0eTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBSdWxlck5vZGUgc3ViY29tcG9uZW50IHdob3NlIHNjYWxlIG1hdGNoZXMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbC5cclxuICAgIC8vIE11c3QgYmUgZGlzcG9zZWQsIGJlY2F1c2UgaXQgbGlua3MgdG8gYSB0cmFuc2xhdGVkIHN0cmluZyBQcm9wZXJ0eS5cclxuICAgIGxldCBydWxlck5vZGU6IFJ1bGVyTm9kZTtcclxuICAgIHpvb21UcmFuc2Zvcm1Qcm9wZXJ0eS5saW5rKCAoIHpvb21UcmFuc2Zvcm06IE1vZGVsVmlld1RyYW5zZm9ybTIgKSA9PiB7XHJcblxyXG4gICAgICAvLyB6b29tVHJhbnNmb3JtUHJvcGVydHkgaXMgZGVyaXZlZCBmcm9tIHpvb21TY2FsZVByb3BlcnR5LCBzbyB6b29tU2NhbGVQcm9wZXJ0eSBkb2VzIG5vdCBuZWVkIHRvIGJlXHJcbiAgICAgIC8vIGEgZGVwZW5kZW5jeSBvZiB0aGlzIGxpc3RlbmVyLCBhbmQgaXQncyBzYWZlIHRvIHVzZSBpdHMgdmFsdWUuXHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHpvb21UcmFuc2Zvcm1Qcm9wZXJ0eS5oYXNEZXBlbmRlbmN5KCB6b29tU2NhbGVQcm9wZXJ0eSApICk7XHJcbiAgICAgIGNvbnN0IHpvb21TY2FsZSA9IHpvb21TY2FsZVByb3BlcnR5LnZhbHVlO1xyXG5cclxuICAgICAgLy8gdXBkYXRlIHJ1bGVyIHNpemUsIHNvIHRoYXQgdmlldyBzaXplIHJlbWFpbnMgdGhlIHNhbWVcclxuICAgICAgcnVsZXIuc2NhbGVMZW5ndGgoIHpvb21TY2FsZSApO1xyXG5cclxuICAgICAgLy8gdXBkYXRlIHZpZXdcclxuICAgICAgdGhpcy5yZW1vdmVBbGxDaGlsZHJlbigpO1xyXG4gICAgICBydWxlck5vZGUgJiYgcnVsZXJOb2RlLmRpc3Bvc2UoKTtcclxuICAgICAgcnVsZXJOb2RlID0gY3JlYXRlUnVsZXJOb2RlKCB0aGlzLnJ1bGVyLmxlbmd0aCwgem9vbVRyYW5zZm9ybSwgem9vbVNjYWxlICk7XHJcbiAgICAgIHRoaXMuYWRkQ2hpbGQoIHJ1bGVyTm9kZSApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIE9yaWdpbiBpcyBhdCBsZWZ0Qm90dG9tIGZvciBhIHZlcnRpY2FsIHJ1bGVyLCBsZWZ0VG9wIGZvciBhIGhvcml6b250YWwgcnVsZXIuXHJcbiAgICBydWxlci5wb3NpdGlvblByb3BlcnR5LmxpbmsoIHBvc2l0aW9uID0+IHtcclxuICAgICAgY29uc3Qgdmlld1Bvc2l0aW9uID0gem9vbVRyYW5zZm9ybVByb3BlcnR5LnZhbHVlLm1vZGVsVG9WaWV3UG9zaXRpb24oIHBvc2l0aW9uICk7XHJcbiAgICAgIGlmICggdGhpcy5ydWxlci5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyApIHtcclxuICAgICAgICB0aGlzLmxlZnRCb3R0b20gPSB2aWV3UG9zaXRpb247XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sZWZ0VG9wID0gdmlld1Bvc2l0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBydWxlcidzIG1vZGVsIHBvc2l0aW9uIHRvIG1hdGNoIHRoaXMgTm9kZSdzIHZpZXcgcG9zaXRpb24sIHNvIHRoYXQgdGhlIHJ1bGVyIHJlbWFpbnMgc3RhdGlvbmFyeVxyXG4gICAgLy8gaW4gdGhlIHZpZXcsIGFuZCB0aGUgbW9kZWwgaXMgY29ycmVjdC5cclxuICAgIHpvb21UcmFuc2Zvcm1Qcm9wZXJ0eS5sYXp5TGluayggKCB6b29tVHJhbnNmb3JtOiBNb2RlbFZpZXdUcmFuc2Zvcm0yICkgPT4ge1xyXG4gICAgICBydWxlci5wb3NpdGlvblByb3BlcnR5LnZhbHVlID0gKCB0aGlzLnJ1bGVyLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnICkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbVRyYW5zZm9ybS52aWV3VG9Nb2RlbFBvc2l0aW9uKCB0aGlzLmxlZnRCb3R0b20gKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tVHJhbnNmb3JtLnZpZXdUb01vZGVsUG9zaXRpb24oIHRoaXMubGVmdFRvcCApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIERyYWcgYm91bmRzIGZvciB0aGUgcnVsZXIsIGluIG1vZGVsIGNvb3JkaW5hdGVzLlxyXG4gICAgLy8gVGhpcyBrZWVwcyBhIHBhcnQgb2YgdGhlIHJ1bGVyIGluc2lkZSB0aGUgdmlzaWJsZSBib3VuZHMgb2YgdGhlIFNjcmVlblZpZXcuXHJcbiAgICB0aGlzLmRyYWdCb3VuZHNQcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoXHJcbiAgICAgIFsgdmlzaWJsZUJvdW5kc1Byb3BlcnR5LCB6b29tVHJhbnNmb3JtUHJvcGVydHkgXSxcclxuICAgICAgKCB2aXNpYmxlQm91bmRzLCB6b29tVHJhbnNmb3JtICkgPT4ge1xyXG4gICAgICAgIGxldCB2aWV3RHJhZ0JvdW5kcztcclxuICAgICAgICBpZiAoIHJ1bGVyLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnICkge1xyXG5cclxuICAgICAgICAgIC8vIGlmIHZlcnRpY2FsIHRoZSBsZWZ0IGFuZCByaWdodCBib3VuZHMgb2YgdGhlIHJ1bGVyIHN0YXkgd2l0aGluIHZpc2libGUgYm91bmRzXHJcbiAgICAgICAgICAvLyBtaW5pbXVtIHZpc2libGUgbGVuZ3RoIG9mIHRoZSBydWxlciBpcyBhbHdheXMgc2hvd2luZyBpbnNpZGUgdG9wIGFuZCBib3R0b20gdmlzaWJsZSBib3VuZHMuXHJcbiAgICAgICAgICB2aWV3RHJhZ0JvdW5kcyA9IHZpc2libGVCb3VuZHMud2l0aE9mZnNldHMoIDAsIC1NSU5JTVVNX1ZJU0lCTEVfTEVOR1RILFxyXG4gICAgICAgICAgICAtdGhpcy53aWR0aCwgLU1JTklNVU1fVklTSUJMRV9MRU5HVEggKyB0aGlzLmhlaWdodCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIC8vIGlmIGhvcml6b250YWwgcnVsZXIsIHRoZSBib3R0b20gYW5kIHRvcCBib3VuZHMgb2YgdGhlIHJ1bGVyIHN0YXkgd2l0aGluIHZpc2libGUgYm91bmRzXHJcbiAgICAgICAgICAvLyBtaW5pbXVtIHZpc2libGUgbGVuZ3RoIG9mIHRoZSBydWxlciBpcyBhbHdheXMgc2hvd2luZyBpbnNpZGUgbGVmdCAgYW5kIHJpZ2h0IHZpc2libGUgYm91bmRzLlxyXG4gICAgICAgICAgdmlld0RyYWdCb3VuZHMgPSB2aXNpYmxlQm91bmRzLndpdGhPZmZzZXRzKCB0aGlzLndpZHRoIC0gTUlOSU1VTV9WSVNJQkxFX0xFTkdUSCwgMCxcclxuICAgICAgICAgICAgLU1JTklNVU1fVklTSUJMRV9MRU5HVEgsIC10aGlzLmhlaWdodCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gem9vbVRyYW5zZm9ybS52aWV3VG9Nb2RlbEJvdW5kcyggdmlld0RyYWdCb3VuZHMgKTtcclxuICAgICAgfSApO1xyXG5cclxuICAgIC8vIEtlZXAgdGhlIHJ1bGVyIGluc2lkZSB0aGUgZHJhZyBib3VuZHMuXHJcbiAgICB0aGlzLmRyYWdCb3VuZHNQcm9wZXJ0eS5saW5rKCBkcmFnQm91bmRzID0+IHtcclxuICAgICAgcnVsZXIucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZSA9IGRyYWdCb3VuZHMuY2xvc2VzdFBvaW50VG8oIHJ1bGVyLnBvc2l0aW9uUHJvcGVydHkudmFsdWUgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gdG8gdGhlIHRvb2xib3ggd2hlbiB0aGUgcG9pbnRlciBpcyByZWxlYXNlZCBpbnNpZGUgdGhlIHRvb2xib3guXHJcbiAgICAvLyB0b29sYm94Tm9kZSBzaG91bGQgYmUgc2V0IGJ5IHRoZSB0aW1lIHRoaXMgaXMgY2FsbGVkLlxyXG4gICAgY29uc3QgZHJhZ1JldHVyblRvVG9vbGJveCA9ICggcG9pbnRlclBvaW50OiBWZWN0b3IyICkgPT4gdGhpcy50b29sYm94Tm9kZSEuY29udGFpbnNHbG9iYWxQb2ludCggcG9pbnRlclBvaW50ICk7XHJcblxyXG4gICAgLy8gRHJhZ2dpbmcgd2l0aCB0aGUgcG9pbnRlci5cclxuICAgIHRoaXMuZHJhZ0xpc3RlbmVyID0gbmV3IEdPVG9vbERyYWdMaXN0ZW5lciggcnVsZXIsIHRoaXMsIHpvb21UcmFuc2Zvcm1Qcm9wZXJ0eSwgdGhpcy5kcmFnQm91bmRzUHJvcGVydHksXHJcbiAgICAgIGRyYWdSZXR1cm5Ub1Rvb2xib3gsIHtcclxuICAgICAgICB0YW5kZW06IG9wdGlvbnMudGFuZGVtLmNyZWF0ZVRhbmRlbSggJ2RyYWdMaXN0ZW5lcicgKVxyXG4gICAgICB9ICk7XHJcbiAgICB0aGlzLmFkZElucHV0TGlzdGVuZXIoIHRoaXMuZHJhZ0xpc3RlbmVyICk7XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBydWxlciB0byB0aGUgdG9vbGJveCBpZiB0aGUgcnVsZXIncyBjZW50ZXIgcG9pbnQgaXMgaW5zaWRlIHRoZSB0b29sYm94LlxyXG4gICAgLy8gdG9vbGJveE5vZGUgc2hvdWxkIGJlIHNldCBieSB0aGUgdGltZSB0aGlzIGlzIGNhbGxlZC5cclxuICAgIGNvbnN0IGtleWJvYXJkRHJhZ1JldHVyblRvVG9vbGJveCA9ICgpID0+IHRoaXMudG9vbGJveE5vZGUhLmNvbnRhaW5zR2xvYmFsUG9pbnQoIHRoaXMucGFyZW50VG9HbG9iYWxQb2ludCggdGhpcy5jZW50ZXIgKSApO1xyXG5cclxuICAgIC8vIERyYWdnaW5nIHdpdGggdGhlIGtleWJvYXJkLlxyXG4gICAgY29uc3Qga2V5Ym9hcmREcmFnTGlzdGVuZXIgPSBuZXcgR09Ub29sS2V5Ym9hcmREcmFnTGlzdGVuZXIoIHJ1bGVyLCB0aGlzLCB6b29tVHJhbnNmb3JtUHJvcGVydHksXHJcbiAgICAgIHRoaXMuZHJhZ0JvdW5kc1Byb3BlcnR5LCBrZXlib2FyZERyYWdSZXR1cm5Ub1Rvb2xib3gsIHtcclxuICAgICAgICB0YW5kZW06IG9wdGlvbnMudGFuZGVtLmNyZWF0ZVRhbmRlbSggJ2tleWJvYXJkRHJhZ0xpc3RlbmVyJyApXHJcbiAgICAgIH0gKTtcclxuICAgIHRoaXMuYWRkSW5wdXRMaXN0ZW5lcigga2V5Ym9hcmREcmFnTGlzdGVuZXIgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgdGhlICdKJyAoSnVtcCkgaG90a2V5LCB3aGljaCBtb3ZlcyB0aGUgcnVsZXIgdG8gdGhlIG5leHQgJ2ludGVyZXN0aW5nJyBwb2ludC5cclxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2dlb21ldHJpYy1vcHRpY3MvaXNzdWVzLzMxMFxyXG4gICAqL1xyXG4gIHB1YmxpYyBqdW1wVG9Qb2ludCgpOiB2b2lkIHtcclxuXHJcbiAgICBjb25zdCBydWxlclBvc2l0aW9uID0gdGhpcy5ydWxlci5wb3NpdGlvblByb3BlcnR5LnZhbHVlO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIHBvaW50cyB0aGF0IGFyZSByZWxldmFudC5cclxuICAgIGNvbnN0IHJlbGV2YW50SnVtcFBvaW50cyA9IHRoaXMuanVtcFBvaW50cy5maWx0ZXIoIGp1bXBQb2ludCA9PlxyXG5cclxuICAgICAgLy8gbm90IG51bGxcclxuICAgICAgKCBqdW1wUG9pbnQucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZSAhPT0gbnVsbCApICYmXHJcblxyXG4gICAgICAvLyB2aXNpYmxlXHJcbiAgICAgIGp1bXBQb2ludC52aXNpYmxlUHJvcGVydHkudmFsdWUgJiZcclxuXHJcbiAgICAgIC8vIGluc2lkZSB0aGUgdG9vbCdzIGRyYWcgYm91bmRzLCBzbyB0aGUgdG9vbCBkb2Vzbid0IG1vdmUgb3V0IG9mIGJvdW5kc1xyXG4gICAgICB0aGlzLmRyYWdCb3VuZHNQcm9wZXJ0eS52YWx1ZS5jb250YWluc1BvaW50KCBqdW1wUG9pbnQucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZSApICYmXHJcblxyXG4gICAgICAvLyBGb3IgaG9yaXpvbnRhbCBydWxlcnMsIGV4Y2x1ZGUgcG9pbnRzIHRvIHRoZSByaWdodCBvZiB0aGUgb3B0aWMsIGJlY2F1c2UgdGhleSBhcmUgbm90IHVzZWZ1bC5cclxuICAgICAgISggdGhpcy5ydWxlci5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIGp1bXBQb2ludC5wb3NpdGlvblByb3BlcnR5LnZhbHVlLnggPiB0aGlzLm9wdGljUG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS54ICkgJiZcclxuXHJcbiAgICAgIC8vIEZvciB2ZXJ0aWNhbCBydWxlcnMsIGV4Y2x1ZGUgcG9pbnRzIG9uIHRoZSBvcHRpY2FsIGF4aXMgKGV4Y2VwdCB0aGUgb3B0aWMpLCBiZWNhdXNlIHRoZXkgYXJlIG5vdCB1c2VmdWwuXHJcbiAgICAgICEoIHRoaXMucnVsZXIub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiZcclxuICAgICAgKCBqdW1wUG9pbnQucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS55ID09PSB0aGlzLm9wdGljUG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS55ICYmXHJcbiAgICAgICFqdW1wUG9pbnQucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS5lcXVhbHMoIHRoaXMub3B0aWNQb3NpdGlvblByb3BlcnR5LnZhbHVlICkgKSApXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIG5leHQganVtcCBwb2ludCBhbmQgbW92ZSB0aGVyZS5cclxuICAgIGlmICggcmVsZXZhbnRKdW1wUG9pbnRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAvLyBDaGFuZ2UgdGhlIHkgY29vcmRpbmF0ZSBvZiBlYWNoIHBvaW50LCBiYXNlZCBvbiB0aGUgcnVsZXIncyBvcmllbnRhdGlvbi4gSG9yaXpvbnRhbCBydWxlcnMgYXJlIHBsYWNlZCBvbiB0aGVcclxuICAgICAgLy8gb3B0aWNhbCBheGlzLiBQbGFjZW1lbnQgb2YgdmVydGljYWwgcnVsZXJzIGRlcGVuZHMgb24gd2hldGhlciB0aGUganVtcCBwb2ludCBpcyBhYm92ZSBvciBiZWxvdyB0aGUgb3B0aWNhbFxyXG4gICAgICAvLyBheGlzLCBhbmQgdGhlIHJ1bGVyIGlzIHBsYWNlZCBzbyB0aGF0IHdlJ3JlIGFsd2F5cyBtZWFzdXJpbmcgYSBkaXN0YW5jZSBmcm9tIHRoZSBvcHRpY2FsIGF4aXMuXHJcbiAgICAgIGNvbnN0IGNoYW5nZVlDb29yZGluYXRlcyA9ICggcG9pbnRzOiBWZWN0b3IyW10gKSA9PiBwb2ludHMubWFwKCAoIHBvaW50OiBWZWN0b3IyICkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9wdGljWSA9IHRoaXMub3B0aWNQb3NpdGlvblByb3BlcnR5LnZhbHVlLnk7XHJcbiAgICAgICAgY29uc3QgeSA9ICggdGhpcy5ydWxlci5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnICkgPyBvcHRpY1kgOiBNYXRoLm1pbiggcG9pbnQueSwgb3B0aWNZICk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKCBwb2ludC54LCB5ICk7XHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgbmV4dCBwb2ludCwgYmFzZWQgb24gdGhlIHJ1bGVyJ3MgcG9zaXRpb24uXHJcbiAgICAgIGNvbnN0IG5leHRQb2ludCA9IEdPVG9vbE5vZGUuZ2V0TmV4dEp1bXBQb2ludCggcmVsZXZhbnRKdW1wUG9pbnRzLCBydWxlclBvc2l0aW9uLCBjaGFuZ2VZQ29vcmRpbmF0ZXMgKTtcclxuXHJcbiAgICAgIC8vIE1vdmUgdGhlIHJ1bGVyXHJcbiAgICAgIGlmICggbmV4dFBvaW50ICkge1xyXG4gICAgICAgIHRoaXMucnVsZXIucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZSA9IG5leHRQb2ludDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzY2VuZXJ5LXBoZXQuUnVsZXJOb2RlIGFwcHJvcHJpYXRlIGZvciB0aGUgem9vbVRyYW5zZm9ybSBhbmQgem9vbSBzY2FsZS5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJ1bGVyTm9kZSggcnVsZXJMZW5ndGg6IG51bWJlciwgem9vbVRyYW5zZm9ybTogTW9kZWxWaWV3VHJhbnNmb3JtMiwgem9vbVNjYWxlOiBudW1iZXIgKTogUnVsZXJOb2RlIHtcclxuXHJcbiAgLy8gZGVmaW5lIHRoZSBsZW5ndGggcnVsZXJcclxuICBjb25zdCBydWxlcldpZHRoID0gem9vbVRyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhWCggcnVsZXJMZW5ndGggKTtcclxuXHJcbiAgY29uc3QgbWFqb3JUaWNrSW50ZXJ2YWwgPSAxMCAvIHpvb21TY2FsZTsgLy8gaW4gbW9kZWwgY29vcmRpbmF0ZSAoY20pXHJcblxyXG4gIC8vIHNlcGFyYXRpb24gYmV0d2VlbiB0aGUgbWFqb3IgdGlja3MgbWFya1xyXG4gIGNvbnN0IG1ham9yVGlja1dpZHRoID0gem9vbVRyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhWCggbWFqb3JUaWNrSW50ZXJ2YWwgKTtcclxuXHJcbiAgLy8gc2V0IHRoZSB1bml0cyBhdCB0aGUgZW5kIG9mIHJ1bGVyXHJcbiAgY29uc3QgbnVtYmVyT2ZNYWpvclRpY2tzID0gTWF0aC5mbG9vciggcnVsZXJXaWR0aCAvIG1ham9yVGlja1dpZHRoICkgKyAxO1xyXG4gIGNvbnN0IHVuaXRzTWFqb3JUaWNrSW5kZXggPSBudW1iZXJPZk1ham9yVGlja3MgLSAzO1xyXG5cclxuICAvLyBjcmVhdGUgbWFqb3IgdGlja3MgbGFiZWxcclxuICBjb25zdCBtYWpvclRpY2tMYWJlbHMgPSBbXTtcclxuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBudW1iZXJPZk1ham9yVGlja3M7IGkrKyApIHtcclxuXHJcbiAgICAvLyBza2lwIGxhYmVscyBvbiBldmVyeSBvdGhlciBtYWpvciB0aWNrc1xyXG4gICAgaWYgKCBpICUgMiA9PT0gMCApIHtcclxuICAgICAgbWFqb3JUaWNrTGFiZWxzWyBpIF0gPSBVdGlscy50b0ZpeGVkKCBpICogbWFqb3JUaWNrSW50ZXJ2YWwsIDAgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBtYWpvclRpY2tMYWJlbHNbIGkgXSA9ICcnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBSdWxlck5vZGUoIHJ1bGVyV2lkdGgsIEdPQ29uc3RhbnRzLlJVTEVSX0hFSUdIVCxcclxuICAgIG1ham9yVGlja1dpZHRoLCBtYWpvclRpY2tMYWJlbHMsIEdlb21ldHJpY09wdGljc1N0cmluZ3MuY2VudGltZXRlcnNTdHJpbmdQcm9wZXJ0eSwge1xyXG4gICAgICBvcGFjaXR5OiAwLjgsXHJcbiAgICAgIG1pbm9yVGlja3NQZXJNYWpvclRpY2s6IDQsXHJcbiAgICAgIG1ham9yVGlja0ZvbnQ6IG5ldyBQaGV0Rm9udCggMTMgKSxcclxuICAgICAgdW5pdHNNYWpvclRpY2tJbmRleDogdW5pdHNNYWpvclRpY2tJbmRleCxcclxuICAgICAgaW5zZXRzV2lkdGg6IDAsXHJcblxyXG4gICAgICAvLyBCZWNhdXNlIFJ1bGVyTm9kZSBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQgZHluYW1pY2FsbHksIHdoZW5ldmVyIHRoZSB6b29tIGxldmVsIGNoYW5nZXMuXHJcbiAgICAgIC8vIEdPUnVsZXJOb2RlIGlzIHRoZXJlZm9yZSBhIHdyYXBwZXIgYXJvdW5kIFJ1bGVyTm9kZSwgYW5kIHdpbGwgY29uc2VxdWVudGx5IG5vdCBoYXZlIHRoZVxyXG4gICAgICAvLyBzYW1lIFBoRVQtaU8gQVBJIGFzIFJ1bGVyTm9kZS5cclxuICAgICAgdGFuZGVtOiBUYW5kZW0uT1BUX09VVFxyXG4gICAgfSApO1xyXG59XHJcblxyXG5nZW9tZXRyaWNPcHRpY3MucmVnaXN0ZXIoICdHT1J1bGVyTm9kZScsIEdPUnVsZXJOb2RlICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxlQUFlLE1BQWtDLDJDQUEyQztBQUVuRyxPQUFPQyxLQUFLLE1BQU0s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