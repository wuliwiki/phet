// Copyright 2021-2022, University of Colorado Boulder

/**
 * MirrorShapes is the set of Shapes that describe a mirror. All Shapes are in model coordinates.
 *
 * Designed as a first surface mirror (or front surface mirror), which is a mirror with the reflective surface being
 * above a backing. This is as opposed to a conventional, second surface mirror, with the reflective surface behind
 * a transparent substrate such as glass or acrylic.
 *
 * @author Martin Veillette
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import optionize from '../../../../phet-core/js/optionize.js';
import geometricOptics from '../../geometricOptics.js';
export default class MirrorShapes {
  // specific to MirrorShapes
  // reflective coating on the front (left-facing) surface of the mirror, with zero area
  // the mirror's backing
  // See OpticShapes
  // the mirror's reflective coating
  // rays do not pass through a mirror, so there is no hit testing on its back
  // the mirror's reflective coating
  /**
   * @param radiusOfCurvature - radius of curvature (ROC) at the center of the mirror
   * @param diameter - height of the mirror, width is foreshortened to provide 3D perspective
   * @param providedOptions
   */
  constructor(radiusOfCurvature, diameter, providedOptions) {
    const options = optionize()({
      // MirrorShapesOptions
      backingThickness: 5 // thickness of the backing of the mirror, in cm
    }, providedOptions);
    const sign = Math.sign(radiusOfCurvature);
    const magnitude = Math.abs(radiusOfCurvature);
    assert && assert(magnitude > diameter / 2);

    // convenience variable
    const backingThickness = options.backingThickness;

    // convenience variable
    const halfHeight = diameter / 2;

    // half of the width of the outline shape of the mirror along the x -axis
    const halfWidth = magnitude - Math.sqrt(magnitude ** 2 - halfHeight ** 2);

    // top and bottom surfaces of fill shape must be tilted to generate right angle corners
    const angle = Math.atan(halfHeight / magnitude);

    // vector offset between the two top corners and bottom corners of the shape with a magnitude of backingThickness
    const offsetTopVector = Vector2.createPolar(backingThickness, -sign * angle);
    const offsetBottomVector = Vector2.createPolar(backingThickness, sign * angle);

    // four corners of the mirror shape
    const topLeft = new Vector2(sign * halfWidth, halfHeight);
    const topRight = topLeft.plus(offsetTopVector);
    const bottomLeft = new Vector2(sign * halfWidth, -halfHeight);
    const bottomRight = bottomLeft.plus(offsetBottomVector);

    // control points: Note that the curve will not go through the control points.
    // rather, it will go through the two following points: (0,0) and ( backingThickness, 0 )
    const midLeft = new Vector2(-sign * halfWidth, 0);
    const midRight = midLeft.plusXY(backingThickness, 0);

    // reflective coating on the front (left-facing) surface of the mirror, with zero area.
    const reflectiveCoatingShape = new Shape().moveToPoint(topLeft).quadraticCurveToPoint(midLeft, bottomLeft).quadraticCurveToPoint(midLeft, topLeft).close();

    // the mirror's backing, counterclockwise from top-left
    const backingShape = new Shape().moveToPoint(topLeft).quadraticCurveToPoint(midLeft, bottomLeft).lineToPoint(bottomRight).quadraticCurveToPoint(midRight, topRight).close();
    this.reflectiveCoatingShape = reflectiveCoatingShape;
    this.backingShape = backingShape;
    this.frontShape = reflectiveCoatingShape;
    this.backShape = null; // because there is no ray hit testing on the back of a mirror
    this.activeBoundsShape = reflectiveCoatingShape;
  }
}
geometricOptics.register('MirrorShapes', MirrorShapes);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiU2hhcGUiLCJvcHRpb25pemUiLCJnZW9tZXRyaWNPcHRpY3MiLCJNaXJyb3JTaGFwZXMiLCJjb25zdHJ1Y3RvciIsInJhZGl1c09mQ3VydmF0dXJlIiwiZGlhbWV0ZXIiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwiYmFja2luZ1RoaWNrbmVzcyIsInNpZ24iLCJNYXRoIiwibWFnbml0dWRlIiwiYWJzIiwiYXNzZXJ0IiwiaGFsZkhlaWdodCIsImhhbGZXaWR0aCIsInNxcnQiLCJhbmdsZSIsImF0YW4iLCJvZmZzZXRUb3BWZWN0b3IiLCJjcmVhdGVQb2xhciIsIm9mZnNldEJvdHRvbVZlY3RvciIsInRvcExlZnQiLCJ0b3BSaWdodCIsInBsdXMiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJtaWRMZWZ0IiwibWlkUmlnaHQiLCJwbHVzWFkiLCJyZWZsZWN0aXZlQ29hdGluZ1NoYXBlIiwibW92ZVRvUG9pbnQiLCJxdWFkcmF0aWNDdXJ2ZVRvUG9pbnQiLCJjbG9zZSIsImJhY2tpbmdTaGFwZSIsImxpbmVUb1BvaW50IiwiZnJvbnRTaGFwZSIsImJhY2tTaGFwZSIsImFjdGl2ZUJvdW5kc1NoYXBlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJNaXJyb3JTaGFwZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogTWlycm9yU2hhcGVzIGlzIHRoZSBzZXQgb2YgU2hhcGVzIHRoYXQgZGVzY3JpYmUgYSBtaXJyb3IuIEFsbCBTaGFwZXMgYXJlIGluIG1vZGVsIGNvb3JkaW5hdGVzLlxyXG4gKlxyXG4gKiBEZXNpZ25lZCBhcyBhIGZpcnN0IHN1cmZhY2UgbWlycm9yIChvciBmcm9udCBzdXJmYWNlIG1pcnJvciksIHdoaWNoIGlzIGEgbWlycm9yIHdpdGggdGhlIHJlZmxlY3RpdmUgc3VyZmFjZSBiZWluZ1xyXG4gKiBhYm92ZSBhIGJhY2tpbmcuIFRoaXMgaXMgYXMgb3Bwb3NlZCB0byBhIGNvbnZlbnRpb25hbCwgc2Vjb25kIHN1cmZhY2UgbWlycm9yLCB3aXRoIHRoZSByZWZsZWN0aXZlIHN1cmZhY2UgYmVoaW5kXHJcbiAqIGEgdHJhbnNwYXJlbnQgc3Vic3RyYXRlIHN1Y2ggYXMgZ2xhc3Mgb3IgYWNyeWxpYy5cclxuICpcclxuICogQGF1dGhvciBNYXJ0aW4gVmVpbGxldHRlXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqL1xyXG5cclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBPcHRpY1NoYXBlcyBmcm9tICcuLi8uLi9jb21tb24vbW9kZWwvT3B0aWNTaGFwZXMuanMnO1xyXG5pbXBvcnQgZ2VvbWV0cmljT3B0aWNzIGZyb20gJy4uLy4uL2dlb21ldHJpY09wdGljcy5qcyc7XHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0ge1xyXG4gIGJhY2tpbmdUaGlja25lc3M/OiBudW1iZXI7IC8vIHRoaWNrbmVzcyBvZiB0aGUgYmFja2luZyBvZiB0aGUgbWlycm9yLCBpbiBjbVxyXG59O1xyXG5cclxudHlwZSBNaXJyb3JTaGFwZXNPcHRpb25zID0gU2VsZk9wdGlvbnM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNaXJyb3JTaGFwZXMgaW1wbGVtZW50cyBPcHRpY1NoYXBlcyB7XHJcblxyXG4gIC8vIHNwZWNpZmljIHRvIE1pcnJvclNoYXBlc1xyXG4gIHB1YmxpYyByZWFkb25seSByZWZsZWN0aXZlQ29hdGluZ1NoYXBlOiBTaGFwZTsgLy8gcmVmbGVjdGl2ZSBjb2F0aW5nIG9uIHRoZSBmcm9udCAobGVmdC1mYWNpbmcpIHN1cmZhY2Ugb2YgdGhlIG1pcnJvciwgd2l0aCB6ZXJvIGFyZWFcclxuICBwdWJsaWMgcmVhZG9ubHkgYmFja2luZ1NoYXBlOiBTaGFwZTsgLy8gdGhlIG1pcnJvcidzIGJhY2tpbmdcclxuXHJcbiAgLy8gU2VlIE9wdGljU2hhcGVzXHJcbiAgcHVibGljIHJlYWRvbmx5IGZyb250U2hhcGU6IFNoYXBlOyAvLyB0aGUgbWlycm9yJ3MgcmVmbGVjdGl2ZSBjb2F0aW5nXHJcbiAgcHVibGljIHJlYWRvbmx5IGJhY2tTaGFwZTogbnVsbDsgLy8gcmF5cyBkbyBub3QgcGFzcyB0aHJvdWdoIGEgbWlycm9yLCBzbyB0aGVyZSBpcyBubyBoaXQgdGVzdGluZyBvbiBpdHMgYmFja1xyXG4gIHB1YmxpYyByZWFkb25seSBhY3RpdmVCb3VuZHNTaGFwZTogU2hhcGU7IC8vIHRoZSBtaXJyb3IncyByZWZsZWN0aXZlIGNvYXRpbmdcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHJhZGl1c09mQ3VydmF0dXJlIC0gcmFkaXVzIG9mIGN1cnZhdHVyZSAoUk9DKSBhdCB0aGUgY2VudGVyIG9mIHRoZSBtaXJyb3JcclxuICAgKiBAcGFyYW0gZGlhbWV0ZXIgLSBoZWlnaHQgb2YgdGhlIG1pcnJvciwgd2lkdGggaXMgZm9yZXNob3J0ZW5lZCB0byBwcm92aWRlIDNEIHBlcnNwZWN0aXZlXHJcbiAgICogQHBhcmFtIHByb3ZpZGVkT3B0aW9uc1xyXG4gICAqL1xyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcmFkaXVzT2ZDdXJ2YXR1cmU6IG51bWJlciwgZGlhbWV0ZXI6IG51bWJlciwgcHJvdmlkZWRPcHRpb25zPzogTWlycm9yU2hhcGVzT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPE1pcnJvclNoYXBlc09wdGlvbnMsIFNlbGZPcHRpb25zPigpKCB7XHJcblxyXG4gICAgICAvLyBNaXJyb3JTaGFwZXNPcHRpb25zXHJcbiAgICAgIGJhY2tpbmdUaGlja25lc3M6IDUgLy8gdGhpY2tuZXNzIG9mIHRoZSBiYWNraW5nIG9mIHRoZSBtaXJyb3IsIGluIGNtXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICBjb25zdCBzaWduID0gTWF0aC5zaWduKCByYWRpdXNPZkN1cnZhdHVyZSApO1xyXG4gICAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5hYnMoIHJhZGl1c09mQ3VydmF0dXJlICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBtYWduaXR1ZGUgPiBkaWFtZXRlciAvIDIgKTtcclxuXHJcbiAgICAvLyBjb252ZW5pZW5jZSB2YXJpYWJsZVxyXG4gICAgY29uc3QgYmFja2luZ1RoaWNrbmVzcyA9IG9wdGlvbnMuYmFja2luZ1RoaWNrbmVzcztcclxuXHJcbiAgICAvLyBjb252ZW5pZW5jZSB2YXJpYWJsZVxyXG4gICAgY29uc3QgaGFsZkhlaWdodCA9IGRpYW1ldGVyIC8gMjtcclxuXHJcbiAgICAvLyBoYWxmIG9mIHRoZSB3aWR0aCBvZiB0aGUgb3V0bGluZSBzaGFwZSBvZiB0aGUgbWlycm9yIGFsb25nIHRoZSB4IC1heGlzXHJcbiAgICBjb25zdCBoYWxmV2lkdGggPSBtYWduaXR1ZGUgLSBNYXRoLnNxcnQoIG1hZ25pdHVkZSAqKiAyIC0gaGFsZkhlaWdodCAqKiAyICk7XHJcblxyXG4gICAgLy8gdG9wIGFuZCBib3R0b20gc3VyZmFjZXMgb2YgZmlsbCBzaGFwZSBtdXN0IGJlIHRpbHRlZCB0byBnZW5lcmF0ZSByaWdodCBhbmdsZSBjb3JuZXJzXHJcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbiggaGFsZkhlaWdodCAvIG1hZ25pdHVkZSApO1xyXG5cclxuICAgIC8vIHZlY3RvciBvZmZzZXQgYmV0d2VlbiB0aGUgdHdvIHRvcCBjb3JuZXJzIGFuZCBib3R0b20gY29ybmVycyBvZiB0aGUgc2hhcGUgd2l0aCBhIG1hZ25pdHVkZSBvZiBiYWNraW5nVGhpY2tuZXNzXHJcbiAgICBjb25zdCBvZmZzZXRUb3BWZWN0b3IgPSBWZWN0b3IyLmNyZWF0ZVBvbGFyKCBiYWNraW5nVGhpY2tuZXNzLCAtc2lnbiAqIGFuZ2xlICk7XHJcbiAgICBjb25zdCBvZmZzZXRCb3R0b21WZWN0b3IgPSBWZWN0b3IyLmNyZWF0ZVBvbGFyKCBiYWNraW5nVGhpY2tuZXNzLCBzaWduICogYW5nbGUgKTtcclxuXHJcbiAgICAvLyBmb3VyIGNvcm5lcnMgb2YgdGhlIG1pcnJvciBzaGFwZVxyXG4gICAgY29uc3QgdG9wTGVmdCA9IG5ldyBWZWN0b3IyKCBzaWduICogaGFsZldpZHRoLCBoYWxmSGVpZ2h0ICk7XHJcbiAgICBjb25zdCB0b3BSaWdodCA9IHRvcExlZnQucGx1cyggb2Zmc2V0VG9wVmVjdG9yICk7XHJcbiAgICBjb25zdCBib3R0b21MZWZ0ID0gbmV3IFZlY3RvcjIoIHNpZ24gKiBoYWxmV2lkdGgsIC1oYWxmSGVpZ2h0ICk7XHJcbiAgICBjb25zdCBib3R0b21SaWdodCA9IGJvdHRvbUxlZnQucGx1cyggb2Zmc2V0Qm90dG9tVmVjdG9yICk7XHJcblxyXG4gICAgLy8gY29udHJvbCBwb2ludHM6IE5vdGUgdGhhdCB0aGUgY3VydmUgd2lsbCBub3QgZ28gdGhyb3VnaCB0aGUgY29udHJvbCBwb2ludHMuXHJcbiAgICAvLyByYXRoZXIsIGl0IHdpbGwgZ28gdGhyb3VnaCB0aGUgdHdvIGZvbGxvd2luZyBwb2ludHM6ICgwLDApIGFuZCAoIGJhY2tpbmdUaGlja25lc3MsIDAgKVxyXG4gICAgY29uc3QgbWlkTGVmdCA9IG5ldyBWZWN0b3IyKCAtc2lnbiAqIGhhbGZXaWR0aCwgMCApO1xyXG4gICAgY29uc3QgbWlkUmlnaHQgPSBtaWRMZWZ0LnBsdXNYWSggYmFja2luZ1RoaWNrbmVzcywgMCApO1xyXG5cclxuICAgIC8vIHJlZmxlY3RpdmUgY29hdGluZyBvbiB0aGUgZnJvbnQgKGxlZnQtZmFjaW5nKSBzdXJmYWNlIG9mIHRoZSBtaXJyb3IsIHdpdGggemVybyBhcmVhLlxyXG4gICAgY29uc3QgcmVmbGVjdGl2ZUNvYXRpbmdTaGFwZSA9IG5ldyBTaGFwZSgpXHJcbiAgICAgIC5tb3ZlVG9Qb2ludCggdG9wTGVmdCApXHJcbiAgICAgIC5xdWFkcmF0aWNDdXJ2ZVRvUG9pbnQoIG1pZExlZnQsIGJvdHRvbUxlZnQgKVxyXG4gICAgICAucXVhZHJhdGljQ3VydmVUb1BvaW50KCBtaWRMZWZ0LCB0b3BMZWZ0IClcclxuICAgICAgLmNsb3NlKCk7XHJcblxyXG4gICAgLy8gdGhlIG1pcnJvcidzIGJhY2tpbmcsIGNvdW50ZXJjbG9ja3dpc2UgZnJvbSB0b3AtbGVmdFxyXG4gICAgY29uc3QgYmFja2luZ1NoYXBlID0gbmV3IFNoYXBlKClcclxuICAgICAgLm1vdmVUb1BvaW50KCB0b3BMZWZ0IClcclxuICAgICAgLnF1YWRyYXRpY0N1cnZlVG9Qb2ludCggbWlkTGVmdCwgYm90dG9tTGVmdCApXHJcbiAgICAgIC5saW5lVG9Qb2ludCggYm90dG9tUmlnaHQgKVxyXG4gICAgICAucXVhZHJhdGljQ3VydmVUb1BvaW50KCBtaWRSaWdodCwgdG9wUmlnaHQgKVxyXG4gICAgICAuY2xvc2UoKTtcclxuXHJcbiAgICB0aGlzLnJlZmxlY3RpdmVDb2F0aW5nU2hhcGUgPSByZWZsZWN0aXZlQ29hdGluZ1NoYXBlO1xyXG4gICAgdGhpcy5iYWNraW5nU2hhcGUgPSBiYWNraW5nU2hhcGU7XHJcbiAgICB0aGlzLmZyb250U2hhcGUgPSByZWZsZWN0aXZlQ29hdGluZ1NoYXBlO1xyXG4gICAgdGhpcy5iYWNrU2hhcGUgPSBudWxsOyAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHJheSBoaXQgdGVzdGluZyBvbiB0aGUgYmFjayBvZiBhIG1pcnJvclxyXG4gICAgdGhpcy5hY3RpdmVCb3VuZHNTaGFwZSA9IHJlZmxlY3RpdmVDb2F0aW5nU2hhcGU7XHJcbiAgfVxyXG59XHJcblxyXG5nZW9tZXRyaWNPcHRpY3MucmVnaXN0ZXIoICdNaXJyb3JTaGFwZXMnLCBNaXJyb3JTaGFwZXMgKTtcclxuIl0sIm1hcHBp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