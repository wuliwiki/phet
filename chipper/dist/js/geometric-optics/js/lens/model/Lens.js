// Copyright 2021-2023, University of Colorado Boulder

/**
 * Lens is the model of a lens.
 *
 * @author Martin Veillette
 * @author Chris Malley (PixelZoom, Inc.)
 */

import RangeWithValue from '../../../../dot/js/RangeWithValue.js';
import Optic from '../../common/model/Optic.js';
import geometricOptics from '../../geometricOptics.js';
import LensShapes from './LensShapes.js';
import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import Utils from '../../../../dot/js/Utils.js';
import optionize from '../../../../phet-core/js/optionize.js';
import GOQueryParameters from '../../common/GOQueryParameters.js';

// IOR is a fixed value for the 'direct' focal-length model.
const DIRECT_INDEX_OF_REFRACTION = 1.5;
export default class Lens extends Optic {
  // See Optic

  // opacity of the lens

  constructor(providedOptions) {
    const focalLengthModelsTandem = providedOptions.tandem.createTandem('focalLengthModels');
    const options = optionize()({
      // OpticOptions
      opticSurfaceTypes: ['convex', 'concave'],
      diameterRange: GOQueryParameters.dRangeLens,
      // in cm
      sign: 1,
      // a positive distance indicates that the image is to the right of the lens
      directFocalLengthModelOptions: {
        focalLengthMagnitudeRange: GOQueryParameters.fRangeLens,
        // in cm
        indexOfRefractionRange: new RangeWithValue(DIRECT_INDEX_OF_REFRACTION, DIRECT_INDEX_OF_REFRACTION, DIRECT_INDEX_OF_REFRACTION),
        // fixed and unitless
        tandem: focalLengthModelsTandem.createTandem('directFocalLengthModel')
      },
      indirectFocalLengthModelOptions: {
        radiusOfCurvatureMagnitudeRange: GOQueryParameters.rocRangeLens,
        // in cm
        indexOfRefractionRange: GOQueryParameters.iorRangeLens,
        // unitless
        tandem: focalLengthModelsTandem.createTandem('indirectFocalLengthModel')
      }
    }, providedOptions);
    assert && assert(!options.opticSurfaceTypes.includes('flat'), 'flat lens is not supported');
    assert && assert(options.directFocalLengthModelOptions.focalLengthMagnitudeRange.defaultValue === options.indirectFocalLengthModelOptions.radiusOfCurvatureMagnitudeRange.defaultValue);
    assert && assert(options.indirectFocalLengthModelOptions.indexOfRefractionRange.contains(DIRECT_INDEX_OF_REFRACTION));
    super(options);
    this.shapesProperty = new DerivedProperty([this.radiusOfCurvatureProperty, this.diameterProperty], (radiusOfCurvature, diameter) => new LensShapes(radiusOfCurvature, diameter));

    // Index of refraction determines the lens opacity.
    // The lens is never fully transparent, because its IOR is not equivalent to air.
    // See https://github.com/phetsims/geometric-optics/issues/242
    this.opacityProperty = new DerivedProperty([this.indexOfRefractionProperty], indexOfRefraction => {
      // Use the indirect model's IOR range in all cases, because the direct model's IOR is fixed.
      const range = this.indirectFocalLengthModel.indexOfRefractionProperty.range;
      return Utils.linear(range.min, range.max, 0.2, 1, indexOfRefraction);
    });
  }

  /**
   * Returns the most extreme position within the lens that would ensure that a ray would be transmitted (or reflected).
   * See https://github.com/phetsims/geometric-optics/issues/111
   * @param opticalObjectPosition
   * @param opticalImagePosition
   * @param isTop - true = top extreme, false = bottom extreme
   */
  getExtremumPoint(opticalObjectPosition, opticalImagePosition, isTop) {
    // Erode the bounds a tiny bit so that the point is always within the bounds.
    const activeBounds = this.getActiveBoundsTranslated().erodedY(1e-6);

    // convenience variables
    const leftPoint = isTop ? activeBounds.leftTop : activeBounds.leftBottom;
    const rightPoint = isTop ? activeBounds.rightTop : activeBounds.rightBottom;
    const opticSurfaceType = this.opticSurfaceTypeProperty.value;

    // extremum point along the direction of the ray, may not be on the optic itself
    let extremumPoint;
    if (opticSurfaceType === 'concave') {
      const opticPosition = this.positionProperty.value;

      // displacement vector from opticalImagePosition to the right corner of the lens
      const rightTarget = rightPoint.minus(opticalImagePosition);

      // displacement vector from opticalObjectPosition to the left corner of the lens
      const leftSource = leftPoint.minus(opticalObjectPosition);

      // yOffset (from center of lens) of a ray directed from opticalImagePosition to the right corner of lens
      const yOffset1 = rightPoint.y - opticPosition.y + (opticPosition.x - rightPoint.x) * rightTarget.y / rightTarget.x;

      // yOffset (from center of lens) of a ray directed from opticalImagePosition to the right corner of lens
      const yOffset2 = leftPoint.y - opticPosition.y + (opticPosition.x - leftPoint.x) * leftSource.y / leftSource.x;

      // find the smallest offset to ensure that a ray will always hit both front and back surfaces
      const offsetY = Math.abs(yOffset1) < Math.abs(yOffset2) ? yOffset1 : yOffset2;

      // get the direction of the ray as measured from the optical object
      extremumPoint = opticPosition.plusXY(0, offsetY);
    } else if (opticSurfaceType === 'convex') {
      // extremum point is based on the edge point (which is centered horizontally on the optic)
      extremumPoint = isTop ? activeBounds.centerTop : activeBounds.centerBottom;
    } else {
      throw new Error(`unsupported surface type for lens: ${opticSurfaceType}`);
    }
    return extremumPoint;
  }

  /**
   * Gets the shape of the back (right) surface of the lens.
   */
  getBackShapeTranslated() {
    const backShape = this.shapesProperty.value.backShape;
    assert && assert(backShape); // {Shape|null}
    return this.translatedShape(backShape);
  }

  /**
   * A lens is converging if it is convex.
   */
  isConverging(opticSurfaceType) {
    return opticSurfaceType === 'convex';
  }
}
geometricOptics.register('Lens', Lens);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSYW5nZVdpdGhWYWx1ZSIsIk9wdGljIiwiZ2VvbWV0cmljT3B0aWNzIiwiTGVuc1NoYXBlcyIsIkRlcml2ZWRQcm9wZXJ0eSIsIlV0aWxzIiwib3B0aW9uaXplIiwiR09RdWVyeVBhcmFtZXRlcnMiLCJESVJFQ1RfSU5ERVhfT0ZfUkVGUkFDVElPTiIsIkxlbnMiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVkT3B0aW9ucyIsImZvY2FsTGVuZ3RoTW9kZWxzVGFuZGVtIiwidGFuZGVtIiwiY3JlYXRlVGFuZGVtIiwib3B0aW9ucyIsIm9wdGljU3VyZmFjZVR5cGVzIiwiZGlhbWV0ZXJSYW5nZSIsImRSYW5nZUxlbnMiLCJzaWduIiwiZGlyZWN0Rm9jYWxMZW5ndGhNb2RlbE9wdGlvbnMiLCJmb2NhbExlbmd0aE1hZ25pdHVkZVJhbmdlIiwiZlJhbmdlTGVucyIsImluZGV4T2ZSZWZyYWN0aW9uUmFuZ2UiLCJpbmRpcmVjdEZvY2FsTGVuZ3RoTW9kZWxPcHRpb25zIiwicmFkaXVzT2ZDdXJ2YXR1cmVNYWduaXR1ZGVSYW5nZSIsInJvY1JhbmdlTGVucyIsImlvclJhbmdlTGVucyIsImFzc2VydCIsImluY2x1ZGVzIiwiZGVmYXVsdFZhbHVlIiwiY29udGFpbnMiLCJzaGFwZXNQcm9wZXJ0eSIsInJhZGl1c09mQ3VydmF0dXJlUHJvcGVydHkiLCJkaWFtZXRlclByb3BlcnR5IiwicmFkaXVzT2ZDdXJ2YXR1cmUiLCJkaWFtZXRlciIsIm9wYWNpdHlQcm9wZXJ0eSIsImluZGV4T2ZSZWZyYWN0aW9uUHJvcGVydHkiLCJpbmRleE9mUmVmcmFjdGlvbiIsInJhbmdlIiwiaW5kaXJlY3RGb2NhbExlbmd0aE1vZGVsIiwibGluZWFyIiwibWluIiwibWF4IiwiZ2V0RXh0cmVtdW1Qb2ludCIsIm9wdGljYWxPYmplY3RQb3NpdGlvbiIsIm9wdGljYWxJbWFnZVBvc2l0aW9uIiwiaXNUb3AiLCJhY3RpdmVCb3VuZHMiLCJnZXRBY3RpdmVCb3VuZHNUcmFuc2xhdGVkIiwiZXJvZGVkWSIsImxlZnRQb2ludCIsImxlZnRUb3AiLCJsZWZ0Qm90dG9tIiwicmlnaHRQb2ludCIsInJpZ2h0VG9wIiwicmlnaHRCb3R0b20iLCJvcHRpY1N1cmZhY2VUeXBlIiwib3B0aWNTdXJmYWNlVHlwZVByb3BlcnR5IiwidmFsdWUiLCJleHRyZW11bVBvaW50Iiwib3B0aWNQb3NpdGlvbiIsInBvc2l0aW9uUHJvcGVydHkiLCJyaWdodFRhcmdldCIsIm1pbnVzIiwibGVmdFNvdXJjZSIsInlPZmZzZXQxIiwieSIsIngiLCJ5T2Zmc2V0MiIsIm9mZnNldFkiLCJNYXRoIiwiYWJzIiwicGx1c1hZIiwiY2VudGVyVG9wIiwiY2VudGVyQm90dG9tIiwiRXJyb3IiLCJnZXRCYWNrU2hhcGVUcmFuc2xhdGVkIiwiYmFja1NoYXBlIiwidHJhbnNsYXRlZFNoYXBlIiwiaXNDb252ZXJnaW5nIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJMZW5zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIExlbnMgaXMgdGhlIG1vZGVsIG9mIGEgbGVucy5cclxuICpcclxuICogQGF1dGhvciBNYXJ0aW4gVmVpbGxldHRlXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqL1xyXG5cclxuaW1wb3J0IFJhbmdlV2l0aFZhbHVlIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9SYW5nZVdpdGhWYWx1ZS5qcyc7XHJcbmltcG9ydCBPcHRpYywgeyBPcHRpY09wdGlvbnMgfSBmcm9tICcuLi8uLi9jb21tb24vbW9kZWwvT3B0aWMuanMnO1xyXG5pbXBvcnQgZ2VvbWV0cmljT3B0aWNzIGZyb20gJy4uLy4uL2dlb21ldHJpY09wdGljcy5qcyc7XHJcbmltcG9ydCB7IE9wdGljU3VyZmFjZVR5cGUgfSBmcm9tICcuLi8uLi9jb21tb24vbW9kZWwvT3B0aWNTdXJmYWNlVHlwZS5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IExlbnNTaGFwZXMgZnJvbSAnLi9MZW5zU2hhcGVzLmpzJztcclxuaW1wb3J0IERlcml2ZWRQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0Rlcml2ZWRQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBUUmVhZE9ubHlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1RSZWFkT25seVByb3BlcnR5LmpzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSwgeyBFbXB0eVNlbGZPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBQaWNrUmVxdWlyZWQgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL1BpY2tSZXF1aXJlZC5qcyc7XHJcbmltcG9ydCBHT1F1ZXJ5UGFyYW1ldGVycyBmcm9tICcuLi8uLi9jb21tb24vR09RdWVyeVBhcmFtZXRlcnMuanMnO1xyXG5cclxuLy8gSU9SIGlzIGEgZml4ZWQgdmFsdWUgZm9yIHRoZSAnZGlyZWN0JyBmb2NhbC1sZW5ndGggbW9kZWwuXHJcbmNvbnN0IERJUkVDVF9JTkRFWF9PRl9SRUZSQUNUSU9OID0gMS41O1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IEVtcHR5U2VsZk9wdGlvbnM7XHJcblxyXG50eXBlIExlbnNPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBQaWNrUmVxdWlyZWQ8T3B0aWNPcHRpb25zLCAndGFuZGVtJz47XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZW5zIGV4dGVuZHMgT3B0aWMge1xyXG5cclxuICAvLyBTZWUgT3B0aWNcclxuICBwdWJsaWMgcmVhZG9ubHkgc2hhcGVzUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PExlbnNTaGFwZXM+O1xyXG5cclxuICAvLyBvcGFjaXR5IG9mIHRoZSBsZW5zXHJcbiAgcHVibGljIHJlYWRvbmx5IG9wYWNpdHlQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8bnVtYmVyPjtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBwcm92aWRlZE9wdGlvbnM6IExlbnNPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IGZvY2FsTGVuZ3RoTW9kZWxzVGFuZGVtID0gcHJvdmlkZWRPcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICdmb2NhbExlbmd0aE1vZGVscycgKTtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPExlbnNPcHRpb25zLCBTZWxmT3B0aW9ucywgT3B0aWNPcHRpb25zPigpKCB7XHJcblxyXG4gICAgICAvLyBPcHRpY09wdGlvbnNcclxuICAgICAgb3B0aWNTdXJmYWNlVHlwZXM6IFsgJ2NvbnZleCcsICdjb25jYXZlJyBdLFxyXG4gICAgICBkaWFtZXRlclJhbmdlOiBHT1F1ZXJ5UGFyYW1ldGVycy5kUmFuZ2VMZW5zLCAvLyBpbiBjbVxyXG4gICAgICBzaWduOiAxLCAvLyBhIHBvc2l0aXZlIGRpc3RhbmNlIGluZGljYXRlcyB0aGF0IHRoZSBpbWFnZSBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIGxlbnNcclxuICAgICAgZGlyZWN0Rm9jYWxMZW5ndGhNb2RlbE9wdGlvbnM6IHtcclxuICAgICAgICBmb2NhbExlbmd0aE1hZ25pdHVkZVJhbmdlOiBHT1F1ZXJ5UGFyYW1ldGVycy5mUmFuZ2VMZW5zLCAvLyBpbiBjbVxyXG4gICAgICAgIGluZGV4T2ZSZWZyYWN0aW9uUmFuZ2U6IG5ldyBSYW5nZVdpdGhWYWx1ZSggRElSRUNUX0lOREVYX09GX1JFRlJBQ1RJT04sIERJUkVDVF9JTkRFWF9PRl9SRUZSQUNUSU9OLCBESVJFQ1RfSU5ERVhfT0ZfUkVGUkFDVElPTiApLCAvLyBmaXhlZCBhbmQgdW5pdGxlc3NcclxuICAgICAgICB0YW5kZW06IGZvY2FsTGVuZ3RoTW9kZWxzVGFuZGVtLmNyZWF0ZVRhbmRlbSggJ2RpcmVjdEZvY2FsTGVuZ3RoTW9kZWwnIClcclxuICAgICAgfSxcclxuICAgICAgaW5kaXJlY3RGb2NhbExlbmd0aE1vZGVsT3B0aW9uczoge1xyXG4gICAgICAgIHJhZGl1c09mQ3VydmF0dXJlTWFnbml0dWRlUmFuZ2U6IEdPUXVlcnlQYXJhbWV0ZXJzLnJvY1JhbmdlTGVucywgLy8gaW4gY21cclxuICAgICAgICBpbmRleE9mUmVmcmFjdGlvblJhbmdlOiBHT1F1ZXJ5UGFyYW1ldGVycy5pb3JSYW5nZUxlbnMsIC8vIHVuaXRsZXNzXHJcbiAgICAgICAgdGFuZGVtOiBmb2NhbExlbmd0aE1vZGVsc1RhbmRlbS5jcmVhdGVUYW5kZW0oICdpbmRpcmVjdEZvY2FsTGVuZ3RoTW9kZWwnIClcclxuICAgICAgfVxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIW9wdGlvbnMub3B0aWNTdXJmYWNlVHlwZXMuaW5jbHVkZXMoICdmbGF0JyApLCAnZmxhdCBsZW5zIGlzIG5vdCBzdXBwb3J0ZWQnICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLmRpcmVjdEZvY2FsTGVuZ3RoTW9kZWxPcHRpb25zLmZvY2FsTGVuZ3RoTWFnbml0dWRlUmFuZ2UuZGVmYXVsdFZhbHVlID09PVxyXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbmRpcmVjdEZvY2FsTGVuZ3RoTW9kZWxPcHRpb25zLnJhZGl1c09mQ3VydmF0dXJlTWFnbml0dWRlUmFuZ2UuZGVmYXVsdFZhbHVlICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLmluZGlyZWN0Rm9jYWxMZW5ndGhNb2RlbE9wdGlvbnMuaW5kZXhPZlJlZnJhY3Rpb25SYW5nZS5jb250YWlucyggRElSRUNUX0lOREVYX09GX1JFRlJBQ1RJT04gKSApO1xyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy5zaGFwZXNQcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoXHJcbiAgICAgIFsgdGhpcy5yYWRpdXNPZkN1cnZhdHVyZVByb3BlcnR5LCB0aGlzLmRpYW1ldGVyUHJvcGVydHkgXSxcclxuICAgICAgKCByYWRpdXNPZkN1cnZhdHVyZSwgZGlhbWV0ZXIgKSA9PiBuZXcgTGVuc1NoYXBlcyggcmFkaXVzT2ZDdXJ2YXR1cmUsIGRpYW1ldGVyIClcclxuICAgICk7XHJcblxyXG4gICAgLy8gSW5kZXggb2YgcmVmcmFjdGlvbiBkZXRlcm1pbmVzIHRoZSBsZW5zIG9wYWNpdHkuXHJcbiAgICAvLyBUaGUgbGVucyBpcyBuZXZlciBmdWxseSB0cmFuc3BhcmVudCwgYmVjYXVzZSBpdHMgSU9SIGlzIG5vdCBlcXVpdmFsZW50IHRvIGFpci5cclxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvZ2VvbWV0cmljLW9wdGljcy9pc3N1ZXMvMjQyXHJcbiAgICB0aGlzLm9wYWNpdHlQcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoIFsgdGhpcy5pbmRleE9mUmVmcmFjdGlvblByb3BlcnR5IF0sXHJcbiAgICAgIGluZGV4T2ZSZWZyYWN0aW9uID0+IHtcclxuXHJcbiAgICAgICAgLy8gVXNlIHRoZSBpbmRpcmVjdCBtb2RlbCdzIElPUiByYW5nZSBpbiBhbGwgY2FzZXMsIGJlY2F1c2UgdGhlIGRpcmVjdCBtb2RlbCdzIElPUiBpcyBmaXhlZC5cclxuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuaW5kaXJlY3RGb2NhbExlbmd0aE1vZGVsLmluZGV4T2ZSZWZyYWN0aW9uUHJvcGVydHkucmFuZ2U7XHJcbiAgICAgICAgcmV0dXJuIFV0aWxzLmxpbmVhciggcmFuZ2UubWluLCByYW5nZS5tYXgsIDAuMiwgMSwgaW5kZXhPZlJlZnJhY3Rpb24gKTtcclxuICAgICAgfSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbW9zdCBleHRyZW1lIHBvc2l0aW9uIHdpdGhpbiB0aGUgbGVucyB0aGF0IHdvdWxkIGVuc3VyZSB0aGF0IGEgcmF5IHdvdWxkIGJlIHRyYW5zbWl0dGVkIChvciByZWZsZWN0ZWQpLlxyXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvZ2VvbWV0cmljLW9wdGljcy9pc3N1ZXMvMTExXHJcbiAgICogQHBhcmFtIG9wdGljYWxPYmplY3RQb3NpdGlvblxyXG4gICAqIEBwYXJhbSBvcHRpY2FsSW1hZ2VQb3NpdGlvblxyXG4gICAqIEBwYXJhbSBpc1RvcCAtIHRydWUgPSB0b3AgZXh0cmVtZSwgZmFsc2UgPSBib3R0b20gZXh0cmVtZVxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBnZXRFeHRyZW11bVBvaW50KCBvcHRpY2FsT2JqZWN0UG9zaXRpb246IFZlY3RvcjIsIG9wdGljYWxJbWFnZVBvc2l0aW9uOiBWZWN0b3IyLCBpc1RvcDogYm9vbGVhbiApOiBWZWN0b3IyIHtcclxuXHJcbiAgICAvLyBFcm9kZSB0aGUgYm91bmRzIGEgdGlueSBiaXQgc28gdGhhdCB0aGUgcG9pbnQgaXMgYWx3YXlzIHdpdGhpbiB0aGUgYm91bmRzLlxyXG4gICAgY29uc3QgYWN0aXZlQm91bmRzID0gdGhpcy5nZXRBY3RpdmVCb3VuZHNUcmFuc2xhdGVkKCkuZXJvZGVkWSggMWUtNiApO1xyXG5cclxuICAgIC8vIGNvbnZlbmllbmNlIHZhcmlhYmxlc1xyXG4gICAgY29uc3QgbGVmdFBvaW50ID0gaXNUb3AgPyBhY3RpdmVCb3VuZHMubGVmdFRvcCA6IGFjdGl2ZUJvdW5kcy5sZWZ0Qm90dG9tO1xyXG4gICAgY29uc3QgcmlnaHRQb2ludCA9IGlzVG9wID8gYWN0aXZlQm91bmRzLnJpZ2h0VG9wIDogYWN0aXZlQm91bmRzLnJpZ2h0Qm90dG9tO1xyXG4gICAgY29uc3Qgb3B0aWNTdXJmYWNlVHlwZSA9IHRoaXMub3B0aWNTdXJmYWNlVHlwZVByb3BlcnR5LnZhbHVlO1xyXG5cclxuICAgIC8vIGV4dHJlbXVtIHBvaW50IGFsb25nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJheSwgbWF5IG5vdCBiZSBvbiB0aGUgb3B0aWMgaXRzZWxmXHJcbiAgICBsZXQgZXh0cmVtdW1Qb2ludDtcclxuICAgIGlmICggb3B0aWNTdXJmYWNlVHlwZSA9PT0gJ2NvbmNhdmUnICkge1xyXG5cclxuICAgICAgY29uc3Qgb3B0aWNQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZTtcclxuXHJcbiAgICAgIC8vIGRpc3BsYWNlbWVudCB2ZWN0b3IgZnJvbSBvcHRpY2FsSW1hZ2VQb3NpdGlvbiB0byB0aGUgcmlnaHQgY29ybmVyIG9mIHRoZSBsZW5zXHJcbiAgICAgIGNvbnN0IHJpZ2h0VGFyZ2V0ID0gcmlnaHRQb2ludC5taW51cyggb3B0aWNhbEltYWdlUG9zaXRpb24gKTtcclxuXHJcbiAgICAgIC8vIGRpc3BsYWNlbWVudCB2ZWN0b3IgZnJvbSBvcHRpY2FsT2JqZWN0UG9zaXRpb24gdG8gdGhlIGxlZnQgY29ybmVyIG9mIHRoZSBsZW5zXHJcbiAgICAgIGNvbnN0IGxlZnRTb3VyY2UgPSBsZWZ0UG9pbnQubWludXMoIG9wdGljYWxPYmplY3RQb3NpdGlvbiApO1xyXG5cclxuICAgICAgLy8geU9mZnNldCAoZnJvbSBjZW50ZXIgb2YgbGVucykgb2YgYSByYXkgZGlyZWN0ZWQgZnJvbSBvcHRpY2FsSW1hZ2VQb3NpdGlvbiB0byB0aGUgcmlnaHQgY29ybmVyIG9mIGxlbnNcclxuICAgICAgY29uc3QgeU9mZnNldDEgPSAoIHJpZ2h0UG9pbnQueSAtIG9wdGljUG9zaXRpb24ueSApICsgKCBvcHRpY1Bvc2l0aW9uLnggLSByaWdodFBvaW50LnggKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRUYXJnZXQueSAvIHJpZ2h0VGFyZ2V0Lng7XHJcblxyXG4gICAgICAvLyB5T2Zmc2V0IChmcm9tIGNlbnRlciBvZiBsZW5zKSBvZiBhIHJheSBkaXJlY3RlZCBmcm9tIG9wdGljYWxJbWFnZVBvc2l0aW9uIHRvIHRoZSByaWdodCBjb3JuZXIgb2YgbGVuc1xyXG4gICAgICBjb25zdCB5T2Zmc2V0MiA9ICggbGVmdFBvaW50LnkgLSBvcHRpY1Bvc2l0aW9uLnkgKSArICggb3B0aWNQb3NpdGlvbi54IC0gbGVmdFBvaW50LnggKSAqIGxlZnRTb3VyY2UueSAvIGxlZnRTb3VyY2UueDtcclxuXHJcbiAgICAgIC8vIGZpbmQgdGhlIHNtYWxsZXN0IG9mZnNldCB0byBlbnN1cmUgdGhhdCBhIHJheSB3aWxsIGFsd2F5cyBoaXQgYm90aCBmcm9udCBhbmQgYmFjayBzdXJmYWNlc1xyXG4gICAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5hYnMoIHlPZmZzZXQxICkgPCBNYXRoLmFicyggeU9mZnNldDIgKSA/IHlPZmZzZXQxIDogeU9mZnNldDI7XHJcblxyXG4gICAgICAvLyBnZXQgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcmF5IGFzIG1lYXN1cmVkIGZyb20gdGhlIG9wdGljYWwgb2JqZWN0XHJcbiAgICAgIGV4dHJlbXVtUG9pbnQgPSBvcHRpY1Bvc2l0aW9uLnBsdXNYWSggMCwgb2Zmc2V0WSApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIG9wdGljU3VyZmFjZVR5cGUgPT09ICdjb252ZXgnICkge1xyXG5cclxuICAgICAgLy8gZXh0cmVtdW0gcG9pbnQgaXMgYmFzZWQgb24gdGhlIGVkZ2UgcG9pbnQgKHdoaWNoIGlzIGNlbnRlcmVkIGhvcml6b250YWxseSBvbiB0aGUgb3B0aWMpXHJcbiAgICAgIGV4dHJlbXVtUG9pbnQgPSBpc1RvcCA/IGFjdGl2ZUJvdW5kcy5jZW50ZXJUb3AgOiBhY3RpdmVCb3VuZHMuY2VudGVyQm90dG9tO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvciggYHVuc3VwcG9ydGVkIHN1cmZhY2UgdHlwZSBmb3IgbGVuczogJHtvcHRpY1N1cmZhY2VUeXBlfWAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXh0cmVtdW1Qb2ludDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHNoYXBlIG9mIHRoZSBiYWNrIChyaWdodCkgc3VyZmFjZSBvZiB0aGUgbGVucy5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0QmFja1NoYXBlVHJhbnNsYXRlZCgpOiBTaGFwZSB7XHJcbiAgICBjb25zdCBiYWNrU2hhcGUgPSB0aGlzLnNoYXBlc1Byb3BlcnR5LnZhbHVlLmJhY2tTaGFwZTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGJhY2tTaGFwZSApOyAvLyB7U2hhcGV8bnVsbH1cclxuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZWRTaGFwZSggYmFja1NoYXBlICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIGxlbnMgaXMgY29udmVyZ2luZyBpZiBpdCBpcyBjb252ZXguXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGlzQ29udmVyZ2luZyggb3B0aWNTdXJmYWNlVHlwZTogT3B0aWNTdXJmYWNlVHlwZSApOiBib29sZWFuIHtcclxuICAgIHJldHVybiAoIG9wdGljU3VyZmFjZVR5cGUgPT09ICdjb252ZXgnICk7XHJcbiAgfVxyXG59XHJcblxyXG5nZW9tZXRyaWNPcHRpY3MucmVnaXN0ZXIoICdMZW5zJywgTGVucyApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGNBQWMsTUFBTSxzQ0FBc0M7QUFDakUsT0FBT0MsS0FBSyxNQUF3Qiw2QkFBNkI7QUFDakUsT0FBT0MsZUFBZSxNQUFNLDBCQUEwQjtBQUd0RCxPQUFPQyxVQUFVLE1BQU0saUJBQWlCO0FBQ3hDLE9BQU9DLGVBQWUsTUFBTSx3Q0FBd0M7QUFFcEUsT0FBT0MsS0FBSyxNQUFNLDZCQUE2QjtBQUUvQyxPQUFPQyxTQUFTLE1BQTRCLHVDQUF1QztBQUVuRixPQUFPQyxpQkFBaUIsTUFB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