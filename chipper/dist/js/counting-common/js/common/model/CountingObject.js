// Copyright 2021-2023, University of Colorado Boulder

/**
 * Represents a number ranging from 1 to 9999, that the user can interact with. Contains multiple "base numbers"
 * for each non-zero digit.
 *
 * @author Sharfudeen Ashraf
 * @author Chris Klusendorf (PhET Interactive Simulations)
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import Emitter from '../../../../axon/js/Emitter.js';
import NumberProperty from '../../../../axon/js/NumberProperty.js';
import Bounds2 from '../../../../dot/js/Bounds2.js';
import Vector2Property from '../../../../dot/js/Vector2Property.js';
import countingCommon from '../../countingCommon.js';
import CountingCommonConstants from '../CountingCommonConstants.js';
import CountingCommonUtils from '../CountingCommonUtils.js';
import BaseNumber from './BaseNumber.js';
import Easing from '../../../../twixt/js/Easing.js';
import Animation from '../../../../twixt/js/Animation.js';
import optionize from '../../../../phet-core/js/optionize.js';
// Incremented for CountingObject IDs
let nextCountingObjectId = 1;
class CountingObject {
  // IDs required for map-like lookup, see https://github.com/phetsims/make-a-ten/issues/199

  // The number that this model represents, e.g. 324

  // Property that indicates where in model space the upper left corner of this shape is. In general, this should not
  // be set directly outside of this type, and should be manipulated through the methods defined below.
  // Flag that tracks whether the user is dragging this number around. Should be set externally, generally by the
  // view node.
  // If we are animating, this is the animation destination. null if not animating.
  // Whether this element is animating from one position to another, do not set externally.
  // Represents the non-zero place values in this number. 1034 will have three place values, 4, 30 and 1000, which
  // when summed will equal our number. Smallest place values are first in the array.
  // Fires when the animation towards our destination ends (we hit our destination).
  // our scale, used for animations
  // the opacity of the handle, if one exists. used for animations
  // whether the value of this paper number should be included in the sum of the model
  // store any animations so we can check if one is still running
  // whether grouping is enabled, which determines if this paper number is allowed to combine with others. groupable
  // objects also have a background, non-groupable objects do not.
  // local bounds, also set later by the view
  // bounds that should be used when animating. updated when the view is created
  // Emitter that can notify the view for this CountingObject that it should move to the front of its Node layer.
  /**
   * @param numberValue - Numeric value, e.g. 123
   * @param initialPosition
   * @param [providedOptions]
   */
  constructor(numberValue, initialPosition, providedOptions) {
    const options = optionize()({
      groupingEnabledProperty: new BooleanProperty(true)
    }, providedOptions);
    this.id = nextCountingObjectId++;
    this.numberValueProperty = new NumberProperty(numberValue);
    this.positionProperty = new Vector2Property(initialPosition.copy());
    this.userControlledProperty = new BooleanProperty(false);
    this.scaleProperty = new NumberProperty(1);
    this.handleOpacityProperty = new NumberProperty(1);
    this.groupingEnabledProperty = options.groupingEnabledProperty;
    this.includeInSumProperty = new BooleanProperty(true);
    this._destination = null;
    this.animating = false;
    this.animation = null;
    this.baseNumbers = CountingObject.getBaseNumbers(this.numberValueProperty.value);
    this.endAnimationEmitter = new Emitter({
      parameters: [{
        valueType: CountingObject
      }]
    });
    this.localBounds = this.baseNumbers[this.baseNumbers.length - 1].bounds;
    this.returnAnimationBounds = this.localBounds;
    this.moveToFrontEmitter = new Emitter();
  }

  /**
   * The number of digits in the number, including zeros, e.g. 1204 has 4 digits.
   */
  get digitLength() {
    assert && assert(this.numberValueProperty.value > 0);
    return CountingCommonUtils.digitsInNumber(this.numberValueProperty.value);
  }

  /**
   * Getter for our animating state.
   */
  get isAnimating() {
    return this.animating;
  }

  /**
   * Getter for our animation destination, null if not animating.
   */
  get destination() {
    assert && assert(!!this._destination === this.animating, 'we only have a destination if we are animating');
    return this._destination;
  }

  /**
   * Locate the boundary between the "move" input area and "split" input area, in the number's local bounds or provided
   * bounds.
   */
  getBoundaryY() {
    const moveToSplitRatio = CountingCommonConstants.SPLIT_BOUNDARY_HEIGHT_PROPORTION;
    return this.localBounds.maxY * (1 - moveToSplitRatio) + this.localBounds.minY * moveToSplitRatio;
  }

  /**
   * Returns the ideal spot to "drag" a number from (near the center of its move target) relative to its origin.
   */
  getDragTargetOffset() {
    return this.localBounds.center.plusXY(0, 0.15 * this.localBounds.height);
  }

  /**
   * Changes the number that this paper number represents.
   */
  changeNumber(numberValue) {
    this.baseNumbers = CountingObject.getBaseNumbers(numberValue);
    this.numberValueProperty.value = numberValue;
  }

  /**
   * Sets the destination of the number. If animate is false, it also sets the position.
   *
   * @param destination
   * @param animate - Whether to animate. If true, it will slide towards the destination. If false, it will immediately
   *                  set the position to be the same as the destination.
   * @param [providedOptions]
   */
  setDestination(destination, animate, providedOptions) {
    assert && assert(destination.isFinite());
    const options = optionize()({
      targetScale: 1,
      targetHandleOpacity: 1,
      useStandardAnimationSpeed: true,
      animationDuration: 0.5
    }, providedOptions);
    if (animate) {
      this.animating = true;
      this._destination = destination;
      this.animation && this.animation.stop();
      const distance = this.positionProperty.value.distance(destination);
      const standardSpeedAnimationDuration = CountingCommonConstants.ANIMATION_TIME_RANGE.constrainValue(distance / CountingCommonConstants.ANIMATION_SPEED);

      // calculate the time needed to get to the destination
      const animationDuration = options.useStandardAnimationSpeed ? standardSpeedAnimationDuration : options.animationDuration;
      this.animation = new Animation({
        duration: animationDuration,
        targets: [{
          property: this.positionProperty,
          to: destination,
          easing: Easing.QUADRATIC_IN_OUT
        }, {
          property: this.scaleProperty,
          to: options.targetScale,
          from: this.scaleProperty.value
        }, {
          property: this.handleOpacityProperty,
          to: options.targetHandleOpacity,
          from: this.handleOpacityProperty.value
        }]
      });
      this.animation.start();
      this.animation.finishEmitter.addListener(() => {
        this.animating = false;
        this._destination = null;
        this.endAnimationEmitter.emit(this);
        this.animation = null;
      });
    } else {
      this.positionProperty.value = destination;
      this.scaleProperty.value = options.targetScale;
    }
  }

  /**
   * If our paper number is outside the available view bounds, move it inside those bounds.
   *
   * @param viewBounds
   * @param newDestination
   * @param [animate] - Indicates if the new constrained position should be directly set or animated
   */
  setConstrainedDestination(viewBounds, newDestination, animate = false) {
    const originBounds = this.getOriginBounds(viewBounds);
    this.setDestination(originBounds.closestPointTo(newDestination), animate);
  }

  /**
   * Determine how our number's origin can be placed in the provided bounds.
   */
  getOriginBounds(viewBounds) {
    return new Bounds2(viewBounds.left - this.localBounds.left, viewBounds.top - this.localBounds.top, viewBounds.right - this.localBounds.right, viewBounds.bottom - this.localBounds.bottom).eroded(CountingCommonConstants.COUNTING_AREA_MARGIN);
  }

  /**
   * Returns the lowest place number whose bounds include the position.
   *
   * @param position - Position relative to this number's origin.
   */
  getBaseNumberAt(position) {
    for (let i = 0; i < this.baseNumbers.length; i++) {
      assert && assert(i === 0 || this.baseNumbers[i].place > this.baseNumbers[i - 1].place, 'Ensure that we start at lower places, required for this to work properly');
      const baseNumber = this.baseNumbers[i];
      if (baseNumber.bounds.containsPoint(position)) {
        return baseNumber;
      }
    }

    // Outside of the bounds, so we need to check each and determine the closest.
    for (let i = 0; i < this.baseNumbers.length; i++) {
      const baseNumber = this.baseNumbers[i];
      if (position.x > baseNumber.bounds.left) {
        return baseNumber;
      }
    }

    // Default the largest one.
    return this.baseNumbers[this.baseNumbers.length - 1];
  }

  /**
   * Given a number, returns an array of BaseNumbers that will represent the digit places.
   *
   * @param number - The number we want to break into digit places.
   */
  static getBaseNumbers(number) {
    assert && assert(number > 0 && number % 1 === 0);
    const result = [];

    // Divide by 10 each loop, using the remainder and place index to create the place numbers.
    let remainder = number;
    let place = 0;
    while (remainder !== 0) {
      const digit = remainder % 10;
      if (digit !== 0) {
        result.push(new BaseNumber(digit, place));
      }
      remainder = (remainder - digit) / 10;
      place++;
    }
    return result;
  }
  dispose() {
    this.numberValueProperty.dispose();
    this.positionProperty.dispose();
    this.userControlledProperty.dispose();
    this.scaleProperty.dispose();
    this.handleOpacityProperty.dispose();
    this.includeInSumProperty.dispose();
    this.moveToFrontEmitter.dispose();
  }
}
countingCommon.register('CountingObject', CountingObject);
export default CountingObject;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJFbWl0dGVyIiwiTnVtYmVyUHJvcGVydHkiLCJCb3VuZHMyIiwiVmVjdG9yMlByb3BlcnR5IiwiY291bnRpbmdDb21tb24iLCJDb3VudGluZ0NvbW1vbkNvbnN0YW50cyIsIkNvdW50aW5nQ29tbW9uVXRpbHMiLCJCYXNlTnVtYmVyIiwiRWFzaW5nIiwiQW5pbWF0aW9uIiwib3B0aW9uaXplIiwibmV4dENvdW50aW5nT2JqZWN0SWQiLCJDb3VudGluZ09iamVjdCIsImNvbnN0cnVjdG9yIiwibnVtYmVyVmFsdWUiLCJpbml0aWFsUG9zaXRpb24iLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwiZ3JvdXBpbmdFbmFibGVkUHJvcGVydHkiLCJpZCIsIm51bWJlclZhbHVlUHJvcGVydHkiLCJwb3NpdGlvblByb3BlcnR5IiwiY29weSIsInVzZXJDb250cm9sbGVkUHJvcGVydHkiLCJzY2FsZVByb3BlcnR5IiwiaGFuZGxlT3BhY2l0eVByb3BlcnR5IiwiaW5jbHVkZUluU3VtUHJvcGVydHkiLCJfZGVzdGluYXRpb24iLCJhbmltYXRpbmciLCJhbmltYXRpb24iLCJiYXNlTnVtYmVycyIsImdldEJhc2VOdW1iZXJzIiwidmFsdWUiLCJlbmRBbmltYXRpb25FbWl0dGVyIiwicGFyYW1ldGVycyIsInZhbHVlVHlwZSIsImxvY2FsQm91bmRzIiwibGVuZ3RoIiwiYm91bmRzIiwicmV0dXJuQW5pbWF0aW9uQm91bmRzIiwibW92ZVRvRnJvbnRFbWl0dGVyIiwiZGlnaXRMZW5ndGgiLCJhc3NlcnQiLCJkaWdpdHNJbk51bWJlciIsImlzQW5pbWF0aW5nIiwiZGVzdGluYXRpb24iLCJnZXRCb3VuZGFyeVkiLCJtb3ZlVG9TcGxpdFJhdGlvIiwiU1BMSVRfQk9VTkRBUllfSEVJR0hUX1BST1BPUlRJT04iLCJtYXhZIiwibWluWSIsImdldERyYWdUYXJnZXRPZmZzZXQiLCJjZW50ZXIiLCJwbHVzWFkiLCJoZWlnaHQiLCJjaGFuZ2VOdW1iZXIiLCJzZXREZXN0aW5hdGlvbiIsImFuaW1hdGUiLCJpc0Zpbml0ZSIsInRhcmdldFNjYWxlIiwidGFyZ2V0SGFuZGxlT3BhY2l0eSIsInVzZVN0YW5kYXJkQW5pbWF0aW9uU3BlZWQiLCJhbmltYXRpb25EdXJhdGlvbiIsInN0b3AiLCJkaXN0YW5jZSIsInN0YW5kYXJkU3BlZWRBbmltYXRpb25EdXJhdGlvbiIsIkFOSU1BVElPTl9USU1FX1JBTkdFIiwiY29uc3RyYWluVmFsdWUiLCJBTklNQVRJT05fU1BFRUQiLCJkdXJhdGlvbiIsInRhcmdldHMiLCJwcm9wZXJ0eSIsInRvIiwiZWFzaW5nIiwiUVVBRFJBVElDX0lOX09VVCIsImZyb20iLCJzdGFydCIsImZpbmlzaEVtaXR0ZXIiLCJhZGRMaXN0ZW5lciIsImVtaXQiLCJzZXRDb25zdHJhaW5lZERlc3RpbmF0aW9uIiwidmlld0JvdW5kcyIsIm5ld0Rlc3RpbmF0aW9uIiwib3JpZ2luQm91bmRzIiwiZ2V0T3JpZ2luQm91bmRzIiwiY2xvc2VzdFBvaW50VG8iLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJlcm9kZWQiLCJDT1VOVElOR19BUkVBX01BUkdJTiIsImdldEJhc2VOdW1iZXJBdCIsInBvc2l0aW9uIiwiaSIsInBsYWNlIiwiYmFzZU51bWJlciIsImNvbnRhaW5zUG9pbnQiLCJ4IiwibnVtYmVyIiwicmVzdWx0IiwicmVtYWluZGVyIiwiZGlnaXQiLCJwdXNoIiwiZGlzcG9zZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQ291bnRpbmdPYmplY3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIG51bWJlciByYW5naW5nIGZyb20gMSB0byA5OTk5LCB0aGF0IHRoZSB1c2VyIGNhbiBpbnRlcmFjdCB3aXRoLiBDb250YWlucyBtdWx0aXBsZSBcImJhc2UgbnVtYmVyc1wiXHJcbiAqIGZvciBlYWNoIG5vbi16ZXJvIGRpZ2l0LlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNoYXJmdWRlZW4gQXNocmFmXHJcbiAqIEBhdXRob3IgQ2hyaXMgS2x1c2VuZG9yZiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgQm9vbGVhblByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvQm9vbGVhblByb3BlcnR5LmpzJztcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9FbWl0dGVyLmpzJztcclxuaW1wb3J0IE51bWJlclByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvTnVtYmVyUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgQm91bmRzMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvQm91bmRzMi5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IFZlY3RvcjJQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMlByb3BlcnR5LmpzJztcclxuaW1wb3J0IGNvdW50aW5nQ29tbW9uIGZyb20gJy4uLy4uL2NvdW50aW5nQ29tbW9uLmpzJztcclxuaW1wb3J0IENvdW50aW5nQ29tbW9uQ29uc3RhbnRzIGZyb20gJy4uL0NvdW50aW5nQ29tbW9uQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IENvdW50aW5nQ29tbW9uVXRpbHMgZnJvbSAnLi4vQ291bnRpbmdDb21tb25VdGlscy5qcyc7XHJcbmltcG9ydCBCYXNlTnVtYmVyLCB7IFNpbmdsZURpZ2l0IH0gZnJvbSAnLi9CYXNlTnVtYmVyLmpzJztcclxuaW1wb3J0IEVhc2luZyBmcm9tICcuLi8uLi8uLi8uLi90d2l4dC9qcy9FYXNpbmcuanMnO1xyXG5pbXBvcnQgQW5pbWF0aW9uIGZyb20gJy4uLy4uLy4uLy4uL3R3aXh0L2pzL0FuaW1hdGlvbi5qcyc7XHJcbmltcG9ydCBUUmVhZE9ubHlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1RSZWFkT25seVByb3BlcnR5LmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IFRFbWl0dGVyIGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvVEVtaXR0ZXIuanMnO1xyXG5pbXBvcnQgVFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvVFByb3BlcnR5LmpzJztcclxuXHJcbnR5cGUgQ291bnRpbmdPYmplY3RPcHRpb25zID0ge1xyXG4gIGdyb3VwaW5nRW5hYmxlZFByb3BlcnR5PzogVFJlYWRPbmx5UHJvcGVydHk8Ym9vbGVhbj47XHJcbn07XHJcbnR5cGUgU2V0RGVzdGluYXRpb25PcHRpb25zID0ge1xyXG4gIHRhcmdldFNjYWxlPzogbnVtYmVyO1xyXG4gIHRhcmdldEhhbmRsZU9wYWNpdHk/OiBudW1iZXI7XHJcbiAgdXNlU3RhbmRhcmRBbmltYXRpb25TcGVlZD86IGJvb2xlYW47XHJcbiAgYW5pbWF0aW9uRHVyYXRpb24/OiBudW1iZXI7XHJcbn07XHJcblxyXG4vLyBJbmNyZW1lbnRlZCBmb3IgQ291bnRpbmdPYmplY3QgSURzXHJcbmxldCBuZXh0Q291bnRpbmdPYmplY3RJZCA9IDE7XHJcblxyXG5jbGFzcyBDb3VudGluZ09iamVjdCB7XHJcblxyXG4gIC8vIElEcyByZXF1aXJlZCBmb3IgbWFwLWxpa2UgbG9va3VwLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL21ha2UtYS10ZW4vaXNzdWVzLzE5OVxyXG4gIHB1YmxpYyByZWFkb25seSBpZDogbnVtYmVyO1xyXG5cclxuICAvLyBUaGUgbnVtYmVyIHRoYXQgdGhpcyBtb2RlbCByZXByZXNlbnRzLCBlLmcuIDMyNFxyXG4gIHB1YmxpYyByZWFkb25seSBudW1iZXJWYWx1ZVByb3BlcnR5OiBUUHJvcGVydHk8bnVtYmVyPjtcclxuXHJcbiAgLy8gUHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgd2hlcmUgaW4gbW9kZWwgc3BhY2UgdGhlIHVwcGVyIGxlZnQgY29ybmVyIG9mIHRoaXMgc2hhcGUgaXMuIEluIGdlbmVyYWwsIHRoaXMgc2hvdWxkIG5vdFxyXG4gIC8vIGJlIHNldCBkaXJlY3RseSBvdXRzaWRlIG9mIHRoaXMgdHlwZSwgYW5kIHNob3VsZCBiZSBtYW5pcHVsYXRlZCB0aHJvdWdoIHRoZSBtZXRob2RzIGRlZmluZWQgYmVsb3cuXHJcbiAgcHVibGljIHJlYWRvbmx5IHBvc2l0aW9uUHJvcGVydHk6IFRQcm9wZXJ0eTxWZWN0b3IyPjtcclxuXHJcbiAgLy8gRmxhZyB0aGF0IHRyYWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGRyYWdnaW5nIHRoaXMgbnVtYmVyIGFyb3VuZC4gU2hvdWxkIGJlIHNldCBleHRlcm5hbGx5LCBnZW5lcmFsbHkgYnkgdGhlXHJcbiAgLy8gdmlldyBub2RlLlxyXG4gIHB1YmxpYyByZWFkb25seSB1c2VyQ29udHJvbGxlZFByb3BlcnR5OiBUUHJvcGVydHk8Ym9vbGVhbj47XHJcblxyXG4gIC8vIElmIHdlIGFyZSBhbmltYXRpbmcsIHRoaXMgaXMgdGhlIGFuaW1hdGlvbiBkZXN0aW5hdGlvbi4gbnVsbCBpZiBub3QgYW5pbWF0aW5nLlxyXG4gIHByaXZhdGUgX2Rlc3RpbmF0aW9uOiBWZWN0b3IyIHwgbnVsbDtcclxuXHJcbiAgLy8gV2hldGhlciB0aGlzIGVsZW1lbnQgaXMgYW5pbWF0aW5nIGZyb20gb25lIHBvc2l0aW9uIHRvIGFub3RoZXIsIGRvIG5vdCBzZXQgZXh0ZXJuYWxseS5cclxuICBwcml2YXRlIGFuaW1hdGluZzogYm9vbGVhbjtcclxuXHJcbiAgLy8gUmVwcmVzZW50cyB0aGUgbm9uLXplcm8gcGxhY2UgdmFsdWVzIGluIHRoaXMgbnVtYmVyLiAxMDM0IHdpbGwgaGF2ZSB0aHJlZSBwbGFjZSB2YWx1ZXMsIDQsIDMwIGFuZCAxMDAwLCB3aGljaFxyXG4gIC8vIHdoZW4gc3VtbWVkIHdpbGwgZXF1YWwgb3VyIG51bWJlci4gU21hbGxlc3QgcGxhY2UgdmFsdWVzIGFyZSBmaXJzdCBpbiB0aGUgYXJyYXkuXHJcbiAgcHVibGljIGJhc2VOdW1iZXJzOiBCYXNlTnVtYmVyW107XHJcblxyXG4gIC8vIEZpcmVzIHdoZW4gdGhlIGFuaW1hdGlvbiB0b3dhcmRzIG91ciBkZXN0aW5hdGlvbiBlbmRzICh3ZSBoaXQgb3VyIGRlc3RpbmF0aW9uKS5cclxuICBwdWJsaWMgcmVhZG9ubHkgZW5kQW5pbWF0aW9uRW1pdHRlcjogVEVtaXR0ZXI8WyBDb3VudGluZ09iamVjdCBdPjtcclxuXHJcbiAgLy8gb3VyIHNjYWxlLCB1c2VkIGZvciBhbmltYXRpb25zXHJcbiAgcHVibGljIHJlYWRvbmx5IHNjYWxlUHJvcGVydHk6IFRQcm9wZXJ0eTxudW1iZXI+O1xyXG5cclxuICAvLyB0aGUgb3BhY2l0eSBvZiB0aGUgaGFuZGxlLCBpZiBvbmUgZXhpc3RzLiB1c2VkIGZvciBhbmltYXRpb25zXHJcbiAgcHVibGljIHJlYWRvbmx5IGhhbmRsZU9wYWNpdHlQcm9wZXJ0eTogVFByb3BlcnR5PG51bWJlcj47XHJcblxyXG4gIC8vIHdoZXRoZXIgdGhlIHZhbHVlIG9mIHRoaXMgcGFwZXIgbnVtYmVyIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgc3VtIG9mIHRoZSBtb2RlbFxyXG4gIHB1YmxpYyByZWFkb25seSBpbmNsdWRlSW5TdW1Qcm9wZXJ0eTogVFByb3BlcnR5PGJvb2xlYW4+O1xyXG5cclxuICAvLyBzdG9yZSBhbnkgYW5pbWF0aW9ucyBzbyB3ZSBjYW4gY2hlY2sgaWYgb25lIGlzIHN0aWxsIHJ1bm5pbmdcclxuICBwcml2YXRlIGFuaW1hdGlvbjogQW5pbWF0aW9uIHwgbnVsbDtcclxuXHJcbiAgLy8gd2hldGhlciBncm91cGluZyBpcyBlbmFibGVkLCB3aGljaCBkZXRlcm1pbmVzIGlmIHRoaXMgcGFwZXIgbnVtYmVyIGlzIGFsbG93ZWQgdG8gY29tYmluZSB3aXRoIG90aGVycy4gZ3JvdXBhYmxlXHJcbiAgLy8gb2JqZWN0cyBhbHNvIGhhdmUgYSBiYWNrZ3JvdW5kLCBub24tZ3JvdXBhYmxlIG9iamVjdHMgZG8gbm90LlxyXG4gIHB1YmxpYyByZWFkb25seSBncm91cGluZ0VuYWJsZWRQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8Ym9vbGVhbj47XHJcblxyXG4gIC8vIGxvY2FsIGJvdW5kcywgYWxzbyBzZXQgbGF0ZXIgYnkgdGhlIHZpZXdcclxuICBwdWJsaWMgbG9jYWxCb3VuZHM6IEJvdW5kczI7XHJcblxyXG4gIC8vIGJvdW5kcyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gYW5pbWF0aW5nLiB1cGRhdGVkIHdoZW4gdGhlIHZpZXcgaXMgY3JlYXRlZFxyXG4gIHB1YmxpYyByZXR1cm5BbmltYXRpb25Cb3VuZHM6IEJvdW5kczI7XHJcblxyXG4gIC8vIEVtaXR0ZXIgdGhhdCBjYW4gbm90aWZ5IHRoZSB2aWV3IGZvciB0aGlzIENvdW50aW5nT2JqZWN0IHRoYXQgaXQgc2hvdWxkIG1vdmUgdG8gdGhlIGZyb250IG9mIGl0cyBOb2RlIGxheWVyLlxyXG4gIHB1YmxpYyByZWFkb25seSBtb3ZlVG9Gcm9udEVtaXR0ZXI6IFRFbWl0dGVyO1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gbnVtYmVyVmFsdWUgLSBOdW1lcmljIHZhbHVlLCBlLmcuIDEyM1xyXG4gICAqIEBwYXJhbSBpbml0aWFsUG9zaXRpb25cclxuICAgKiBAcGFyYW0gW3Byb3ZpZGVkT3B0aW9uc11cclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIG51bWJlclZhbHVlOiBudW1iZXIsIGluaXRpYWxQb3NpdGlvbjogVmVjdG9yMiwgcHJvdmlkZWRPcHRpb25zPzogQ291bnRpbmdPYmplY3RPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8Q291bnRpbmdPYmplY3RPcHRpb25zLCBDb3VudGluZ09iamVjdE9wdGlvbnM+KCkoIHtcclxuICAgICAgZ3JvdXBpbmdFbmFibGVkUHJvcGVydHk6IG5ldyBCb29sZWFuUHJvcGVydHkoIHRydWUgKVxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy5pZCA9IG5leHRDb3VudGluZ09iamVjdElkKys7XHJcbiAgICB0aGlzLm51bWJlclZhbHVlUHJvcGVydHkgPSBuZXcgTnVtYmVyUHJvcGVydHkoIG51bWJlclZhbHVlICk7XHJcbiAgICB0aGlzLnBvc2l0aW9uUHJvcGVydHkgPSBuZXcgVmVjdG9yMlByb3BlcnR5KCBpbml0aWFsUG9zaXRpb24uY29weSgpICk7XHJcbiAgICB0aGlzLnVzZXJDb250cm9sbGVkUHJvcGVydHkgPSBuZXcgQm9vbGVhblByb3BlcnR5KCBmYWxzZSApO1xyXG4gICAgdGhpcy5zY2FsZVByb3BlcnR5ID0gbmV3IE51bWJlclByb3BlcnR5KCAxICk7XHJcbiAgICB0aGlzLmhhbmRsZU9wYWNpdHlQcm9wZXJ0eSA9IG5ldyBOdW1iZXJQcm9wZXJ0eSggMSApO1xyXG4gICAgdGhpcy5ncm91cGluZ0VuYWJsZWRQcm9wZXJ0eSA9IG9wdGlvbnMuZ3JvdXBpbmdFbmFibGVkUHJvcGVydHk7XHJcbiAgICB0aGlzLmluY2x1ZGVJblN1bVByb3BlcnR5ID0gbmV3IEJvb2xlYW5Qcm9wZXJ0eSggdHJ1ZSApO1xyXG4gICAgdGhpcy5fZGVzdGluYXRpb24gPSBudWxsO1xyXG4gICAgdGhpcy5hbmltYXRpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuYW5pbWF0aW9uID0gbnVsbDtcclxuICAgIHRoaXMuYmFzZU51bWJlcnMgPSBDb3VudGluZ09iamVjdC5nZXRCYXNlTnVtYmVycyggdGhpcy5udW1iZXJWYWx1ZVByb3BlcnR5LnZhbHVlICk7XHJcbiAgICB0aGlzLmVuZEFuaW1hdGlvbkVtaXR0ZXIgPSBuZXcgRW1pdHRlciggeyBwYXJhbWV0ZXJzOiBbIHsgdmFsdWVUeXBlOiBDb3VudGluZ09iamVjdCB9IF0gfSApO1xyXG4gICAgdGhpcy5sb2NhbEJvdW5kcyA9IHRoaXMuYmFzZU51bWJlcnNbIHRoaXMuYmFzZU51bWJlcnMubGVuZ3RoIC0gMSBdLmJvdW5kcztcclxuICAgIHRoaXMucmV0dXJuQW5pbWF0aW9uQm91bmRzID0gdGhpcy5sb2NhbEJvdW5kcztcclxuICAgIHRoaXMubW92ZVRvRnJvbnRFbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSBudW1iZXIsIGluY2x1ZGluZyB6ZXJvcywgZS5nLiAxMjA0IGhhcyA0IGRpZ2l0cy5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0IGRpZ2l0TGVuZ3RoKCk6IG51bWJlciB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLm51bWJlclZhbHVlUHJvcGVydHkudmFsdWUgPiAwICk7XHJcblxyXG4gICAgcmV0dXJuIENvdW50aW5nQ29tbW9uVXRpbHMuZGlnaXRzSW5OdW1iZXIoIHRoaXMubnVtYmVyVmFsdWVQcm9wZXJ0eS52YWx1ZSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciBvdXIgYW5pbWF0aW5nIHN0YXRlLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXQgaXNBbmltYXRpbmcoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5hbmltYXRpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIG91ciBhbmltYXRpb24gZGVzdGluYXRpb24sIG51bGwgaWYgbm90IGFuaW1hdGluZy5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0IGRlc3RpbmF0aW9uKCk6IFZlY3RvcjIgfCBudWxsIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICEhdGhpcy5fZGVzdGluYXRpb24gPT09IHRoaXMuYW5pbWF0aW5nLCAnd2Ugb25seSBoYXZlIGEgZGVzdGluYXRpb24gaWYgd2UgYXJlIGFuaW1hdGluZycgKTtcclxuICAgIHJldHVybiB0aGlzLl9kZXN0aW5hdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvY2F0ZSB0aGUgYm91bmRhcnkgYmV0d2VlbiB0aGUgXCJtb3ZlXCIgaW5wdXQgYXJlYSBhbmQgXCJzcGxpdFwiIGlucHV0IGFyZWEsIGluIHRoZSBudW1iZXIncyBsb2NhbCBib3VuZHMgb3IgcHJvdmlkZWRcclxuICAgKiBib3VuZHMuXHJcbiAgICovXHJcbiAgcHVibGljIGdldEJvdW5kYXJ5WSgpOiBudW1iZXIge1xyXG4gICAgY29uc3QgbW92ZVRvU3BsaXRSYXRpbyA9IENvdW50aW5nQ29tbW9uQ29uc3RhbnRzLlNQTElUX0JPVU5EQVJZX0hFSUdIVF9QUk9QT1JUSU9OO1xyXG4gICAgcmV0dXJuIHRoaXMubG9jYWxCb3VuZHMubWF4WSAqICggMSAtIG1vdmVUb1NwbGl0UmF0aW8gKSArIHRoaXMubG9jYWxCb3VuZHMubWluWSAqIG1vdmVUb1NwbGl0UmF0aW87XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBpZGVhbCBzcG90IHRvIFwiZHJhZ1wiIGEgbnVtYmVyIGZyb20gKG5lYXIgdGhlIGNlbnRlciBvZiBpdHMgbW92ZSB0YXJnZXQpIHJlbGF0aXZlIHRvIGl0cyBvcmlnaW4uXHJcbiAgICovXHJcbiAgcHVibGljIGdldERyYWdUYXJnZXRPZmZzZXQoKTogVmVjdG9yMiB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbEJvdW5kcy5jZW50ZXIucGx1c1hZKCAwLCAwLjE1ICogdGhpcy5sb2NhbEJvdW5kcy5oZWlnaHQgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoYW5nZXMgdGhlIG51bWJlciB0aGF0IHRoaXMgcGFwZXIgbnVtYmVyIHJlcHJlc2VudHMuXHJcbiAgICovXHJcbiAgcHVibGljIGNoYW5nZU51bWJlciggbnVtYmVyVmFsdWU6IG51bWJlciApOiB2b2lkIHtcclxuICAgIHRoaXMuYmFzZU51bWJlcnMgPSBDb3VudGluZ09iamVjdC5nZXRCYXNlTnVtYmVycyggbnVtYmVyVmFsdWUgKTtcclxuICAgIHRoaXMubnVtYmVyVmFsdWVQcm9wZXJ0eS52YWx1ZSA9IG51bWJlclZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIG51bWJlci4gSWYgYW5pbWF0ZSBpcyBmYWxzZSwgaXQgYWxzbyBzZXRzIHRoZSBwb3NpdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvblxyXG4gICAqIEBwYXJhbSBhbmltYXRlIC0gV2hldGhlciB0byBhbmltYXRlLiBJZiB0cnVlLCBpdCB3aWxsIHNsaWRlIHRvd2FyZHMgdGhlIGRlc3RpbmF0aW9uLiBJZiBmYWxzZSwgaXQgd2lsbCBpbW1lZGlhdGVseVxyXG4gICAqICAgICAgICAgICAgICAgICAgc2V0IHRoZSBwb3NpdGlvbiB0byBiZSB0aGUgc2FtZSBhcyB0aGUgZGVzdGluYXRpb24uXHJcbiAgICogQHBhcmFtIFtwcm92aWRlZE9wdGlvbnNdXHJcbiAgICovXHJcbiAgcHVibGljIHNldERlc3RpbmF0aW9uKCBkZXN0aW5hdGlvbjogVmVjdG9yMiwgYW5pbWF0ZTogYm9vbGVhbiwgcHJvdmlkZWRPcHRpb25zPzogU2V0RGVzdGluYXRpb25PcHRpb25zICk6IHZvaWQge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZGVzdGluYXRpb24uaXNGaW5pdGUoKSApO1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8U2V0RGVzdGluYXRpb25PcHRpb25zPigpKCB7XHJcbiAgICAgIHRhcmdldFNjYWxlOiAxLFxyXG4gICAgICB0YXJnZXRIYW5kbGVPcGFjaXR5OiAxLFxyXG4gICAgICB1c2VTdGFuZGFyZEFuaW1hdGlvblNwZWVkOiB0cnVlLFxyXG4gICAgICBhbmltYXRpb25EdXJhdGlvbjogMC41XHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICBpZiAoIGFuaW1hdGUgKSB7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW5nID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcclxuXHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uICYmIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcclxuICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnBvc2l0aW9uUHJvcGVydHkudmFsdWUuZGlzdGFuY2UoIGRlc3RpbmF0aW9uICk7XHJcbiAgICAgIGNvbnN0IHN0YW5kYXJkU3BlZWRBbmltYXRpb25EdXJhdGlvbiA9XHJcbiAgICAgICAgQ291bnRpbmdDb21tb25Db25zdGFudHMuQU5JTUFUSU9OX1RJTUVfUkFOR0UuY29uc3RyYWluVmFsdWUoIGRpc3RhbmNlIC8gQ291bnRpbmdDb21tb25Db25zdGFudHMuQU5JTUFUSU9OX1NQRUVEICk7XHJcblxyXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHRpbWUgbmVlZGVkIHRvIGdldCB0byB0aGUgZGVzdGluYXRpb25cclxuICAgICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb24gPSBvcHRpb25zLnVzZVN0YW5kYXJkQW5pbWF0aW9uU3BlZWQgPyBzdGFuZGFyZFNwZWVkQW5pbWF0aW9uRHVyYXRpb24gOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uO1xyXG5cclxuICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCB7XHJcbiAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgIHRhcmdldHM6IFsge1xyXG4gICAgICAgICAgcHJvcGVydHk6IHRoaXMucG9zaXRpb25Qcm9wZXJ0eSxcclxuICAgICAgICAgIHRvOiBkZXN0aW5hdGlvbixcclxuICAgICAgICAgIGVhc2luZzogRWFzaW5nLlFVQURSQVRJQ19JTl9PVVRcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBwcm9wZXJ0eTogdGhpcy5zY2FsZVByb3BlcnR5LFxyXG4gICAgICAgICAgdG86IG9wdGlvbnMudGFyZ2V0U2NhbGUsXHJcbiAgICAgICAgICBmcm9tOiB0aGlzLnNjYWxlUHJvcGVydHkudmFsdWVcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBwcm9wZXJ0eTogdGhpcy5oYW5kbGVPcGFjaXR5UHJvcGVydHksXHJcbiAgICAgICAgICB0bzogb3B0aW9ucy50YXJnZXRIYW5kbGVPcGFjaXR5LFxyXG4gICAgICAgICAgZnJvbTogdGhpcy5oYW5kbGVPcGFjaXR5UHJvcGVydHkudmFsdWVcclxuICAgICAgICB9IF1cclxuICAgICAgfSApO1xyXG5cclxuICAgICAgdGhpcy5hbmltYXRpb24uc3RhcnQoKTtcclxuICAgICAgdGhpcy5hbmltYXRpb24uZmluaXNoRW1pdHRlci5hZGRMaXN0ZW5lciggKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGVzdGluYXRpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW5kQW5pbWF0aW9uRW1pdHRlci5lbWl0KCB0aGlzICk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBudWxsO1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5wb3NpdGlvblByb3BlcnR5LnZhbHVlID0gZGVzdGluYXRpb247XHJcbiAgICAgIHRoaXMuc2NhbGVQcm9wZXJ0eS52YWx1ZSA9IG9wdGlvbnMudGFyZ2V0U2NhbGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZiBvdXIgcGFwZXIgbnVtYmVyIGlzIG91dHNpZGUgdGhlIGF2YWlsYWJsZSB2aWV3IGJvdW5kcywgbW92ZSBpdCBpbnNpZGUgdGhvc2UgYm91bmRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHZpZXdCb3VuZHNcclxuICAgKiBAcGFyYW0gbmV3RGVzdGluYXRpb25cclxuICAgKiBAcGFyYW0gW2FuaW1hdGVdIC0gSW5kaWNhdGVzIGlmIHRoZSBuZXcgY29uc3RyYWluZWQgcG9zaXRpb24gc2hvdWxkIGJlIGRpcmVjdGx5IHNldCBvciBhbmltYXRlZFxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRDb25zdHJhaW5lZERlc3RpbmF0aW9uKCB2aWV3Qm91bmRzOiBCb3VuZHMyLCBuZXdEZXN0aW5hdGlvbjogVmVjdG9yMiwgYW5pbWF0ZSA9IGZhbHNlICk6IHZvaWQge1xyXG4gICAgY29uc3Qgb3JpZ2luQm91bmRzID0gdGhpcy5nZXRPcmlnaW5Cb3VuZHMoIHZpZXdCb3VuZHMgKTtcclxuICAgIHRoaXMuc2V0RGVzdGluYXRpb24oIG9yaWdpbkJvdW5kcy5jbG9zZXN0UG9pbnRUbyggbmV3RGVzdGluYXRpb24gKSwgYW5pbWF0ZSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIGhvdyBvdXIgbnVtYmVyJ3Mgb3JpZ2luIGNhbiBiZSBwbGFjZWQgaW4gdGhlIHByb3ZpZGVkIGJvdW5kcy5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0T3JpZ2luQm91bmRzKCB2aWV3Qm91bmRzOiBCb3VuZHMyICk6IEJvdW5kczIge1xyXG4gICAgcmV0dXJuIG5ldyBCb3VuZHMyKFxyXG4gICAgICB2aWV3Qm91bmRzLmxlZnQgLSB0aGlzLmxvY2FsQm91bmRzLmxlZnQsXHJcbiAgICAgIHZpZXdCb3VuZHMudG9wIC0gdGhpcy5sb2NhbEJvdW5kcy50b3AsXHJcbiAgICAgIHZpZXdCb3VuZHMucmlnaHQgLSB0aGlzLmxvY2FsQm91bmRzLnJpZ2h0LFxyXG4gICAgICB2aWV3Qm91bmRzLmJvdHRvbSAtIHRoaXMubG9jYWxCb3VuZHMuYm90dG9tXHJcbiAgICApLmVyb2RlZCggQ291bnRpbmdDb21tb25Db25zdGFudHMuQ09VTlRJTkdfQVJFQV9NQVJHSU4gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGxvd2VzdCBwbGFjZSBudW1iZXIgd2hvc2UgYm91bmRzIGluY2x1ZGUgdGhlIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHBvc2l0aW9uIC0gUG9zaXRpb24gcmVsYXRpdmUgdG8gdGhpcyBudW1iZXIncyBvcmlnaW4uXHJcbiAgICovXHJcbiAgcHVibGljIGdldEJhc2VOdW1iZXJBdCggcG9zaXRpb246IFZlY3RvcjIgKTogQmFzZU51bWJlciB7XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLmJhc2VOdW1iZXJzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBpID09PSAwIHx8IHRoaXMuYmFzZU51bWJlcnNbIGkgXS5wbGFjZSA+IHRoaXMuYmFzZU51bWJlcnNbIGkgLSAxIF0ucGxhY2UsXHJcbiAgICAgICAgJ0Vuc3VyZSB0aGF0IHdlIHN0YXJ0IGF0IGxvd2VyIHBsYWNlcywgcmVxdWlyZWQgZm9yIHRoaXMgdG8gd29yayBwcm9wZXJseScgKTtcclxuXHJcbiAgICAgIGNvbnN0IGJhc2VOdW1iZXIgPSB0aGlzLmJhc2VOdW1iZXJzWyBpIF07XHJcblxyXG4gICAgICBpZiAoIGJhc2VOdW1iZXIuYm91bmRzLmNvbnRhaW5zUG9pbnQoIHBvc2l0aW9uICkgKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VOdW1iZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBPdXRzaWRlIG9mIHRoZSBib3VuZHMsIHNvIHdlIG5lZWQgdG8gY2hlY2sgZWFjaCBhbmQgZGV0ZXJtaW5lIHRoZSBjbG9zZXN0LlxyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5iYXNlTnVtYmVycy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgY29uc3QgYmFzZU51bWJlciA9IHRoaXMuYmFzZU51bWJlcnNbIGkgXTtcclxuICAgICAgaWYgKCBwb3NpdGlvbi54ID4gYmFzZU51bWJlci5ib3VuZHMubGVmdCApIHtcclxuICAgICAgICByZXR1cm4gYmFzZU51bWJlcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmF1bHQgdGhlIGxhcmdlc3Qgb25lLlxyXG4gICAgcmV0dXJuIHRoaXMuYmFzZU51bWJlcnNbIHRoaXMuYmFzZU51bWJlcnMubGVuZ3RoIC0gMSBdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBudW1iZXIsIHJldHVybnMgYW4gYXJyYXkgb2YgQmFzZU51bWJlcnMgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZGlnaXQgcGxhY2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG51bWJlciAtIFRoZSBudW1iZXIgd2Ugd2FudCB0byBicmVhayBpbnRvIGRpZ2l0IHBsYWNlcy5cclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIGdldEJhc2VOdW1iZXJzKCBudW1iZXI6IG51bWJlciApOiBCYXNlTnVtYmVyW10ge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggbnVtYmVyID4gMCAmJiBudW1iZXIgJSAxID09PSAwICk7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcblxyXG4gICAgLy8gRGl2aWRlIGJ5IDEwIGVhY2ggbG9vcCwgdXNpbmcgdGhlIHJlbWFpbmRlciBhbmQgcGxhY2UgaW5kZXggdG8gY3JlYXRlIHRoZSBwbGFjZSBudW1iZXJzLlxyXG4gICAgbGV0IHJlbWFpbmRlciA9IG51bWJlcjtcclxuICAgIGxldCBwbGFjZSA9IDA7XHJcbiAgICB3aGlsZSAoIHJlbWFpbmRlciAhPT0gMCApIHtcclxuICAgICAgY29uc3QgZGlnaXQgPSByZW1haW5kZXIgJSAxMDtcclxuICAgICAgaWYgKCBkaWdpdCAhPT0gMCApIHtcclxuICAgICAgICByZXN1bHQucHVzaCggbmV3IEJhc2VOdW1iZXIoIGRpZ2l0IGFzIFNpbmdsZURpZ2l0LCBwbGFjZSApICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlbWFpbmRlciA9ICggcmVtYWluZGVyIC0gZGlnaXQgKSAvIDEwO1xyXG4gICAgICBwbGFjZSsrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIHRoaXMubnVtYmVyVmFsdWVQcm9wZXJ0eS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLnBvc2l0aW9uUHJvcGVydHkuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy51c2VyQ29udHJvbGxlZFByb3BlcnR5LmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuc2NhbGVQcm9wZXJ0eS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLmhhbmRsZU9wYWNpdHlQcm9wZXJ0eS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLmluY2x1ZGVJblN1bVByb3BlcnR5LmRpc3Bvc2UoKTtcclxuICAgIHRoaXMubW92ZVRvRnJvbnRFbWl0dGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcblxyXG59XHJcblxyXG5jb3VudGluZ0NvbW1vbi5yZWdpc3RlciggJ0NvdW50aW5nT2JqZWN0JywgQ291bnRpbmdPYmplY3QgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvdW50aW5nT2JqZWN0O1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGVBQWUsTUFBTSx3Q0FBd0M7QUFDcEUsT0FBT0MsT0FBTyxNQUFNLGdDQUFnQztBQUNwRCxPQUFPQyxjQUFjLE1BQU0sdUNBQXVDO0FBQ2xFLE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFFbkQsT0FBT0MsZUFBZSxNQUFNLHVDQUF1QztBQUNuRSxPQUFPQyxjQUFjLE1BQU0seUJBQXlCO0FBQ3BELE9BQU9DLHVCQUF1QixNQUFNLCtCQUErQjtBQUNuRSxPQUFPQyxtQkFBbUIsTUFBTSwyQkFBMkI7QUFDM0QsT0FBT0MsVUFBVSxNQUF1QixpQkFBaUI7QUFDekQsT0FBT0MsTUFBTSxNQUFNLGdDQUFnQztBQUNuRCxPQUFPQyxTQUFTLE1BQU0sbUNBQW1DO0FBRXpELE9BQU9DLFNBQVMsTUFBTSx1Q0FBdUM7QUFjN0Q7QUFDQSxJQUFJQyxvQkFBb0IsR0FBRyxDQUFDO0FBRTVCLE1BQU1DLGNBQWMsQ0FBQztFQUVuQjs7RUFHQTs7RUFHQTtFQUNBO0VBR0E7RUFDQTtFQUdBO0VBR0E7RUFHQTtFQUNBO0VB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