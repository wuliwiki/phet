// Copyright 2019-2023, University of Colorado Boulder

/**
 * A static object used to send aria-live updates to a screen reader. These are alerts that are independent of user
 * focus. This will create and reference 'aria-live' elements in the HTML document and update their content. You
 * will need to get these elements and add them to the document through a reference to this.ariaLiveElements.
 * A number of elements such as the following are created and used:
 *
 *    <p id="elements-1-polite-1" aria-live="polite"></p>
 *    <p id="elements-1-polite-2" aria-live="polite"></p>
 *    <p id="elements-1-polite-3" aria-live="polite"></p>
 *    <p id="elements-1-polite-4" aria-live="polite"></p>
 *
 *    <p id="elements-1-assertive-1" aria-live="assertive"></p>
 *    <p id="elements-1-assertive-2" aria-live="assertive"></p>
 *    <p id="elements-1-assertive-3" aria-live="assertive"></p>
 *    <p id="elements-1-assertive-4" aria-live="assertive"></p>
 *
 * It was discovered that cycling through using these elements prevented a VoiceOver bug where alerts would interrupt
 * each other. Starting from the first element, content is set on each element in order and cycles through.
 *
 * Many aria-live and related attributes were tested, but none were well supported or particularly useful for PhET sims,
 * see https://github.com/phetsims/chipper/issues/472.
 *
 * @author Jesse Greenberg
 * @author John Blanco
 */

import stepTimer from '../../axon/js/stepTimer.js';
import Enumeration from '../../phet-core/js/Enumeration.js';
import EnumerationValue from '../../phet-core/js/EnumerationValue.js';
import optionize from '../../phet-core/js/optionize.js';
import platform from '../../phet-core/js/platform.js';
import { PDOMUtils } from '../../scenery/js/imports.js';
import Announcer from './Announcer.js';
import utteranceQueueNamespace from './utteranceQueueNamespace.js';
// constants
const NUMBER_OF_ARIA_LIVE_ELEMENTS = 4;

// one indexed for the element ids, unique to each AriaLiveAnnouncer instance
let ariaLiveAnnouncerIndex = 1;

// Possible supported values for the `aria-live` attributes created in AriaLiveAnnouncer.
class AriaLive extends EnumerationValue {
  constructor(attributeString) {
    super();
    this.attributeString = attributeString;
  }
  static POLITE = new AriaLive('polite');
  static ASSERTIVE = new AriaLive('assertive');
  static enumeration = new Enumeration(AriaLive);
}

// Options for the announce method

/**
 * @returns - a container holding each aria-live elements created
 */
function createBatchOfPriorityLiveElements(ariaLivePriority) {
  const priority = ariaLivePriority.attributeString;
  const container = document.createElement('div');
  for (let i = 1; i <= NUMBER_OF_ARIA_LIVE_ELEMENTS; i++) {
    const newParagraph = document.createElement('p');
    newParagraph.setAttribute('id', `elements-${ariaLiveAnnouncerIndex}-${priority}-${i}`);

    // set aria-live on individual paragraph elements to prevent VoiceOver from interrupting alerts, see
    // https://github.com/phetsims/molecules-and-light/issues/235
    newParagraph.setAttribute('aria-live', priority);
    container.appendChild(newParagraph);
  }
  return container;
}
class AriaLiveAnnouncer extends Announcer {
  // index of current aria-live element to use, updated every time an event triggers

  // DOM elements which will receive the updated content.

  // The Announcer only speaks one Utterance per this interval or else VoiceOver reads alerts out of order.
  // This is also the interval at which alert content is cleared from the DOM once set so that it cannot be found
  // with the virtual cursor after setting.
  static ARIA_LIVE_DELAY = 200;
  constructor(providedOptions) {
    const options = optionize()({
      // By default, don't care about response collector Properties, as they are designed for Voicing more than
      // aria-live description.
      respectResponseCollectorProperties: false
    }, providedOptions);
    super(options);
    this.politeElementIndex = 0;
    this.assertiveElementIndex = 0;
    this.ariaLiveContainer = document.createElement('div'); //container div
    this.ariaLiveContainer.setAttribute('id', `aria-live-elements-${ariaLiveAnnouncerIndex}`);
    this.ariaLiveContainer.setAttribute('style', 'position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; ' + 'clip: rect(0px 0px 0px 0px); pointer-events: none;');

    // By having four elements and cycling through each one, we can get around a VoiceOver bug where a new
    // alert would interrupt the previous alert if it wasn't finished speaking, see https://github.com/phetsims/scenery-phet/issues/362
    const politeElementContainer = createBatchOfPriorityLiveElements(AriaLive.POLITE);
    const assertiveElementContainer = createBatchOfPriorityLiveElements(AriaLive.ASSERTIVE);
    this.ariaLiveContainer.appendChild(politeElementContainer);
    this.ariaLiveContainer.appendChild(assertiveElementContainer);
    this.politeElements = Array.from(politeElementContainer.children);
    this.assertiveElements = Array.from(assertiveElementContainer.children);

    // increment index so the next AriaLiveAnnouncer instance has different ids for its elements.
    ariaLiveAnnouncerIndex++;
  }

  /**
   * Announce an alert, setting textContent to an aria-live element.
   */
  announce(announceText, utterance, providedOptions) {
    const options = optionize()({
      // By default, alert to a polite aria-live element
      ariaLivePriority: AriaLive.POLITE
    }, providedOptions);

    // aria-live and AT has no API to detect successful speech, we can only assume every announce is successful
    this.hasSpoken = true;

    // Don't update if null
    if (announceText) {
      if (options.ariaLivePriority === AriaLive.POLITE) {
        const element = this.politeElements[this.politeElementIndex];
        this.updateLiveElement(element, announceText, utterance);

        // update index for next time
        this.politeElementIndex = (this.politeElementIndex + 1) % this.politeElements.length;
      } else if (options.ariaLivePriority === AriaLive.ASSERTIVE) {
        const element = this.assertiveElements[this.assertiveElementIndex];
        this.updateLiveElement(element, announceText, utterance);
        // update index for next time
        this.assertiveElementIndex = (this.assertiveElementIndex + 1) % this.assertiveElements.length;
      } else {
        assert && assert(false, 'unsupported aria live prioirity');
      }
    }

    // With aria-live we don't have information about when the screen reader is done speaking
    // the content, so we have to emit this right away
    this.announcementCompleteEmitter.emit(utterance, announceText);
  }

  /**
   * The implementation of cancel for AriaLiveAnnouncer. We do not know whether the AT is speaking content so
   * this function is a no-op for aria-live.
   */
  cancel() {
    // See docs
  }

  /**
   * The implementation of cancelUtterance for AriaLiveAnnouncer. We do not know whether the AT is speaking content so
   * this function is a no-op for aria-live.
   */
  cancelUtterance(utterance) {
    // See docs
  }

  /**
   * Update an element with the 'aria-live' attribute by setting its text content.
   *
   * @param liveElement - the HTML element that will send the alert to the assistive technology
   * @param textContent - the content to be announced
   * @param utterance
   */
  updateLiveElement(liveElement, textContent, utterance) {
    // fully clear the old textContent so that sequential alerts with identical text will be announced, which
    // some screen readers might have prevented
    liveElement.textContent = '';

    // element must be visible for alerts to be spoken
    liveElement.hidden = false;

    // UtteranceQueue cannot announce again until after the following timeouts.
    this.readyToAnnounce = false;

    // must be done asynchronously from setting hidden above or else the screen reader
    // will fail to read the content
    stepTimer.setTimeout(() => {
      // make sure that the utterance is not out of date right before it is actually sent to assistive technology
      if (utterance.predicate()) {
        PDOMUtils.setTextContent(liveElement, textContent);

        // Hide the content so that it cant be read with the virtual cursor. Must be done
        // behind at least 200 ms delay or else alerts may be missed by NVDA and VoiceOver, see
        // https://github.com/phetsims/scenery-phet/issues/491
        stepTimer.setTimeout(() => {
          if (platform.safari) {
            // Using `hidden` rather than clearing textContent works better on mobile VO,
            // see https://github.com/phetsims/scenery-phet/issues/490
            liveElement.hidden = true;
          } else {
            liveElement.textContent = '';
          }

          // Wait until after this timeout to let the UtteranceQueue can announce Utterances again. This delay
          // seems to be necessary to force VoiceOver to speak aria-live alerts in first-in-first-out order.
          // See https://github.com/phetsims/utterance-queue/issues/88
          this.readyToAnnounce = true;
        }, AriaLiveAnnouncer.ARIA_LIVE_DELAY);
      } else {
        this.readyToAnnounce = true; // If the predicate fails, we are ready to announce again.
      }
    }, 0);
  }

  // Possible values for the `aria-live` attribute (priority) that can be alerted (like "polite" and
  // "assertive"), see AriaLiveAnnounceOptions for details.
  static AriaLive = AriaLive;
}
utteranceQueueNamespace.register('AriaLiveAnnouncer', AriaLiveAnnouncer);
export default AriaLiveAnnouncer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJzdGVwVGltZXIiLCJFbnVtZXJhdGlvbiIsIkVudW1lcmF0aW9uVmFsdWUiLCJvcHRpb25pemUiLCJwbGF0Zm9ybSIsIlBET01VdGlscyIsIkFubm91bmNlciIsInV0dGVyYW5jZVF1ZXVlTmFtZXNwYWNlIiwiTlVNQkVSX09GX0FSSUFfTElWRV9FTEVNRU5UUyIsImFyaWFMaXZlQW5ub3VuY2VySW5kZXgiLCJBcmlhTGl2ZSIsImNvbnN0cnVjdG9yIiwiYXR0cmlidXRlU3RyaW5nIiwiUE9MSVRFIiwiQVNTRVJUSVZFIiwiZW51bWVyYXRpb24iLCJjcmVhdGVCYXRjaE9mUHJpb3JpdHlMaXZlRWxlbWVudHMiLCJhcmlhTGl2ZVByaW9yaXR5IiwicHJpb3JpdHkiLCJjb250YWluZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpIiwibmV3UGFyYWdyYXBoIiwic2V0QXR0cmlidXRlIiwiYXBwZW5kQ2hpbGQiLCJBcmlhTGl2ZUFubm91bmNlciIsIkFSSUFfTElWRV9ERUxBWSIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJyZXNwZWN0UmVzcG9uc2VDb2xsZWN0b3JQcm9wZXJ0aWVzIiwicG9saXRlRWxlbWVudEluZGV4IiwiYXNzZXJ0aXZlRWxlbWVudEluZGV4IiwiYXJpYUxpdmVDb250YWluZXIiLCJwb2xpdGVFbGVtZW50Q29udGFpbmVyIiwiYXNzZXJ0aXZlRWxlbWVudENvbnRhaW5lciIsInBvbGl0ZUVsZW1lbnRzIiwiQXJyYXkiLCJmcm9tIiwiY2hpbGRyZW4iLCJhc3NlcnRpdmVFbGVtZW50cyIsImFubm91bmNlIiwiYW5ub3VuY2VUZXh0IiwidXR0ZXJhbmNlIiwiaGFzU3Bva2VuIiwiZWxlbWVudCIsInVwZGF0ZUxpdmVFbGVtZW50IiwibGVuZ3RoIiwiYXNzZXJ0IiwiYW5ub3VuY2VtZW50Q29tcGxldGVFbWl0dGVyIiwiZW1pdCIsImNhbmNlbCIsImNhbmNlbFV0dGVyYW5jZSIsImxpdmVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJoaWRkZW4iLCJyZWFkeVRvQW5ub3VuY2UiLCJzZXRUaW1lb3V0IiwicHJlZGljYXRlIiwic2V0VGV4dENvbnRlbnQiLCJzYWZhcmkiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkFyaWFMaXZlQW5ub3VuY2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE5LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgc3RhdGljIG9iamVjdCB1c2VkIHRvIHNlbmQgYXJpYS1saXZlIHVwZGF0ZXMgdG8gYSBzY3JlZW4gcmVhZGVyLiBUaGVzZSBhcmUgYWxlcnRzIHRoYXQgYXJlIGluZGVwZW5kZW50IG9mIHVzZXJcclxuICogZm9jdXMuIFRoaXMgd2lsbCBjcmVhdGUgYW5kIHJlZmVyZW5jZSAnYXJpYS1saXZlJyBlbGVtZW50cyBpbiB0aGUgSFRNTCBkb2N1bWVudCBhbmQgdXBkYXRlIHRoZWlyIGNvbnRlbnQuIFlvdVxyXG4gKiB3aWxsIG5lZWQgdG8gZ2V0IHRoZXNlIGVsZW1lbnRzIGFuZCBhZGQgdGhlbSB0byB0aGUgZG9jdW1lbnQgdGhyb3VnaCBhIHJlZmVyZW5jZSB0byB0aGlzLmFyaWFMaXZlRWxlbWVudHMuXHJcbiAqIEEgbnVtYmVyIG9mIGVsZW1lbnRzIHN1Y2ggYXMgdGhlIGZvbGxvd2luZyBhcmUgY3JlYXRlZCBhbmQgdXNlZDpcclxuICpcclxuICogICAgPHAgaWQ9XCJlbGVtZW50cy0xLXBvbGl0ZS0xXCIgYXJpYS1saXZlPVwicG9saXRlXCI+PC9wPlxyXG4gKiAgICA8cCBpZD1cImVsZW1lbnRzLTEtcG9saXRlLTJcIiBhcmlhLWxpdmU9XCJwb2xpdGVcIj48L3A+XHJcbiAqICAgIDxwIGlkPVwiZWxlbWVudHMtMS1wb2xpdGUtM1wiIGFyaWEtbGl2ZT1cInBvbGl0ZVwiPjwvcD5cclxuICogICAgPHAgaWQ9XCJlbGVtZW50cy0xLXBvbGl0ZS00XCIgYXJpYS1saXZlPVwicG9saXRlXCI+PC9wPlxyXG4gKlxyXG4gKiAgICA8cCBpZD1cImVsZW1lbnRzLTEtYXNzZXJ0aXZlLTFcIiBhcmlhLWxpdmU9XCJhc3NlcnRpdmVcIj48L3A+XHJcbiAqICAgIDxwIGlkPVwiZWxlbWVudHMtMS1hc3NlcnRpdmUtMlwiIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiPjwvcD5cclxuICogICAgPHAgaWQ9XCJlbGVtZW50cy0xLWFzc2VydGl2ZS0zXCIgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCI+PC9wPlxyXG4gKiAgICA8cCBpZD1cImVsZW1lbnRzLTEtYXNzZXJ0aXZlLTRcIiBhcmlhLWxpdmU9XCJhc3NlcnRpdmVcIj48L3A+XHJcbiAqXHJcbiAqIEl0IHdhcyBkaXNjb3ZlcmVkIHRoYXQgY3ljbGluZyB0aHJvdWdoIHVzaW5nIHRoZXNlIGVsZW1lbnRzIHByZXZlbnRlZCBhIFZvaWNlT3ZlciBidWcgd2hlcmUgYWxlcnRzIHdvdWxkIGludGVycnVwdFxyXG4gKiBlYWNoIG90aGVyLiBTdGFydGluZyBmcm9tIHRoZSBmaXJzdCBlbGVtZW50LCBjb250ZW50IGlzIHNldCBvbiBlYWNoIGVsZW1lbnQgaW4gb3JkZXIgYW5kIGN5Y2xlcyB0aHJvdWdoLlxyXG4gKlxyXG4gKiBNYW55IGFyaWEtbGl2ZSBhbmQgcmVsYXRlZCBhdHRyaWJ1dGVzIHdlcmUgdGVzdGVkLCBidXQgbm9uZSB3ZXJlIHdlbGwgc3VwcG9ydGVkIG9yIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIFBoRVQgc2ltcyxcclxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jaGlwcGVyL2lzc3Vlcy80NzIuXHJcbiAqXHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICovXHJcblxyXG5pbXBvcnQgc3RlcFRpbWVyIGZyb20gJy4uLy4uL2F4b24vanMvc3RlcFRpbWVyLmpzJztcclxuaW1wb3J0IEVudW1lcmF0aW9uIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9FbnVtZXJhdGlvbi5qcyc7XHJcbmltcG9ydCBFbnVtZXJhdGlvblZhbHVlIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9FbnVtZXJhdGlvblZhbHVlLmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSwgeyBFbXB0eVNlbGZPcHRpb25zIH0gZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvcGxhdGZvcm0uanMnO1xyXG5pbXBvcnQgeyBQRE9NVXRpbHMgfSBmcm9tICcuLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgQW5ub3VuY2VyLCB7IEFubm91bmNlckFubm91bmNlT3B0aW9ucywgQW5ub3VuY2VyT3B0aW9ucyB9IGZyb20gJy4vQW5ub3VuY2VyLmpzJztcclxuaW1wb3J0IFV0dGVyYW5jZSBmcm9tICcuL1V0dGVyYW5jZS5qcyc7XHJcbmltcG9ydCB1dHRlcmFuY2VRdWV1ZU5hbWVzcGFjZSBmcm9tICcuL3V0dGVyYW5jZVF1ZXVlTmFtZXNwYWNlLmpzJztcclxuaW1wb3J0IHsgUmVzb2x2ZWRSZXNwb25zZSB9IGZyb20gJy4vUmVzcG9uc2VQYWNrZXQuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IE5VTUJFUl9PRl9BUklBX0xJVkVfRUxFTUVOVFMgPSA0O1xyXG5cclxuLy8gb25lIGluZGV4ZWQgZm9yIHRoZSBlbGVtZW50IGlkcywgdW5pcXVlIHRvIGVhY2ggQXJpYUxpdmVBbm5vdW5jZXIgaW5zdGFuY2VcclxubGV0IGFyaWFMaXZlQW5ub3VuY2VySW5kZXggPSAxO1xyXG5cclxuLy8gUG9zc2libGUgc3VwcG9ydGVkIHZhbHVlcyBmb3IgdGhlIGBhcmlhLWxpdmVgIGF0dHJpYnV0ZXMgY3JlYXRlZCBpbiBBcmlhTGl2ZUFubm91bmNlci5cclxuY2xhc3MgQXJpYUxpdmUgZXh0ZW5kcyBFbnVtZXJhdGlvblZhbHVlIHtcclxuICBwdWJsaWMgY29uc3RydWN0b3IoIHB1YmxpYyByZWFkb25seSBhdHRyaWJ1dGVTdHJpbmc6IHN0cmluZyApIHsgc3VwZXIoKTt9XHJcblxyXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUE9MSVRFID0gbmV3IEFyaWFMaXZlKCAncG9saXRlJyApO1xyXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQVNTRVJUSVZFID0gbmV3IEFyaWFMaXZlKCAnYXNzZXJ0aXZlJyApO1xyXG5cclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGVudW1lcmF0aW9uID0gbmV3IEVudW1lcmF0aW9uKCBBcmlhTGl2ZSApO1xyXG59XHJcblxyXG4vLyBPcHRpb25zIGZvciB0aGUgYW5ub3VuY2UgbWV0aG9kXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSB7XHJcbiAgYXJpYUxpdmVQcmlvcml0eT86IEFyaWFMaXZlO1xyXG59O1xyXG50eXBlIEFyaWFMaXZlQW5ub3VuY2VyQW5ub3VuY2VPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBBbm5vdW5jZXJBbm5vdW5jZU9wdGlvbnM7XHJcblxyXG4vKipcclxuICogQHJldHVybnMgLSBhIGNvbnRhaW5lciBob2xkaW5nIGVhY2ggYXJpYS1saXZlIGVsZW1lbnRzIGNyZWF0ZWRcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoT2ZQcmlvcml0eUxpdmVFbGVtZW50cyggYXJpYUxpdmVQcmlvcml0eTogQXJpYUxpdmUgKTogSFRNTERpdkVsZW1lbnQge1xyXG4gIGNvbnN0IHByaW9yaXR5ID0gYXJpYUxpdmVQcmlvcml0eS5hdHRyaWJ1dGVTdHJpbmc7XHJcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcclxuICBmb3IgKCBsZXQgaSA9IDE7IGkgPD0gTlVNQkVSX09GX0FSSUFfTElWRV9FTEVNRU5UUzsgaSsrICkge1xyXG4gICAgY29uc3QgbmV3UGFyYWdyYXBoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3AnICk7XHJcbiAgICBuZXdQYXJhZ3JhcGguc2V0QXR0cmlidXRlKCAnaWQnLCBgZWxlbWVudHMtJHthcmlhTGl2ZUFubm91bmNlckluZGV4fS0ke3ByaW9yaXR5fS0ke2l9YCApO1xyXG5cclxuICAgIC8vIHNldCBhcmlhLWxpdmUgb24gaW5kaXZpZHVhbCBwYXJhZ3JhcGggZWxlbWVudHMgdG8gcHJldmVudCBWb2ljZU92ZXIgZnJvbSBpbnRlcnJ1cHRpbmcgYWxlcnRzLCBzZWVcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9tb2xlY3VsZXMtYW5kLWxpZ2h0L2lzc3Vlcy8yMzVcclxuICAgIG5ld1BhcmFncmFwaC5zZXRBdHRyaWJ1dGUoICdhcmlhLWxpdmUnLCBwcmlvcml0eSApO1xyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKCBuZXdQYXJhZ3JhcGggKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjb250YWluZXI7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEFyaWFMaXZlQW5ub3VuY2VyT3B0aW9ucyA9IEFubm91bmNlck9wdGlvbnM7XHJcblxyXG5jbGFzcyBBcmlhTGl2ZUFubm91bmNlciBleHRlbmRzIEFubm91bmNlciB7XHJcblxyXG4gIC8vIGluZGV4IG9mIGN1cnJlbnQgYXJpYS1saXZlIGVsZW1lbnQgdG8gdXNlLCB1cGRhdGVkIGV2ZXJ5IHRpbWUgYW4gZXZlbnQgdHJpZ2dlcnNcclxuICBwcml2YXRlIHBvbGl0ZUVsZW1lbnRJbmRleDogbnVtYmVyO1xyXG4gIHByaXZhdGUgYXNzZXJ0aXZlRWxlbWVudEluZGV4OiBudW1iZXI7XHJcblxyXG4gIHB1YmxpYyByZWFkb25seSBhcmlhTGl2ZUNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQ7XHJcblxyXG4gIC8vIERPTSBlbGVtZW50cyB3aGljaCB3aWxsIHJlY2VpdmUgdGhlIHVwZGF0ZWQgY29udGVudC5cclxuICBwcml2YXRlIHJlYWRvbmx5IHBvbGl0ZUVsZW1lbnRzOiBIVE1MRWxlbWVudFtdO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgYXNzZXJ0aXZlRWxlbWVudHM6IEhUTUxFbGVtZW50W107XHJcblxyXG4gIC8vIFRoZSBBbm5vdW5jZXIgb25seSBzcGVha3Mgb25lIFV0dGVyYW5jZSBwZXIgdGhpcyBpbnRlcnZhbCBvciBlbHNlIFZvaWNlT3ZlciByZWFkcyBhbGVydHMgb3V0IG9mIG9yZGVyLlxyXG4gIC8vIFRoaXMgaXMgYWxzbyB0aGUgaW50ZXJ2YWwgYXQgd2hpY2ggYWxlcnQgY29udGVudCBpcyBjbGVhcmVkIGZyb20gdGhlIERPTSBvbmNlIHNldCBzbyB0aGF0IGl0IGNhbm5vdCBiZSBmb3VuZFxyXG4gIC8vIHdpdGggdGhlIHZpcnR1YWwgY3Vyc29yIGFmdGVyIHNldHRpbmcuXHJcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBBUklBX0xJVkVfREVMQVkgPSAyMDA7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcHJvdmlkZWRPcHRpb25zPzogQXJpYUxpdmVBbm5vdW5jZXJPcHRpb25zICkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxBcmlhTGl2ZUFubm91bmNlck9wdGlvbnMsIEVtcHR5U2VsZk9wdGlvbnMsIEFubm91bmNlck9wdGlvbnM+KCkoIHtcclxuXHJcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIGRvbid0IGNhcmUgYWJvdXQgcmVzcG9uc2UgY29sbGVjdG9yIFByb3BlcnRpZXMsIGFzIHRoZXkgYXJlIGRlc2lnbmVkIGZvciBWb2ljaW5nIG1vcmUgdGhhblxyXG4gICAgICAvLyBhcmlhLWxpdmUgZGVzY3JpcHRpb24uXHJcbiAgICAgIHJlc3BlY3RSZXNwb25zZUNvbGxlY3RvclByb3BlcnRpZXM6IGZhbHNlXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICBzdXBlciggb3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMucG9saXRlRWxlbWVudEluZGV4ID0gMDtcclxuICAgIHRoaXMuYXNzZXJ0aXZlRWxlbWVudEluZGV4ID0gMDtcclxuXHJcbiAgICB0aGlzLmFyaWFMaXZlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTsgLy9jb250YWluZXIgZGl2XHJcbiAgICB0aGlzLmFyaWFMaXZlQ29udGFpbmVyLnNldEF0dHJpYnV0ZSggJ2lkJywgYGFyaWEtbGl2ZS1lbGVtZW50cy0ke2FyaWFMaXZlQW5ub3VuY2VySW5kZXh9YCApO1xyXG4gICAgdGhpcy5hcmlhTGl2ZUNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoICdzdHlsZScsICdwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDBweDsgdG9wOiAwcHg7IHdpZHRoOiAwcHg7IGhlaWdodDogMHB4OyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xpcDogcmVjdCgwcHggMHB4IDBweCAwcHgpOyBwb2ludGVyLWV2ZW50czogbm9uZTsnICk7XHJcblxyXG4gICAgLy8gQnkgaGF2aW5nIGZvdXIgZWxlbWVudHMgYW5kIGN5Y2xpbmcgdGhyb3VnaCBlYWNoIG9uZSwgd2UgY2FuIGdldCBhcm91bmQgYSBWb2ljZU92ZXIgYnVnIHdoZXJlIGEgbmV3XHJcbiAgICAvLyBhbGVydCB3b3VsZCBpbnRlcnJ1cHQgdGhlIHByZXZpb3VzIGFsZXJ0IGlmIGl0IHdhc24ndCBmaW5pc2hlZCBzcGVha2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zY2VuZXJ5LXBoZXQvaXNzdWVzLzM2MlxyXG4gICAgY29uc3QgcG9saXRlRWxlbWVudENvbnRhaW5lciA9IGNyZWF0ZUJhdGNoT2ZQcmlvcml0eUxpdmVFbGVtZW50cyggQXJpYUxpdmUuUE9MSVRFICk7XHJcbiAgICBjb25zdCBhc3NlcnRpdmVFbGVtZW50Q29udGFpbmVyID0gY3JlYXRlQmF0Y2hPZlByaW9yaXR5TGl2ZUVsZW1lbnRzKCBBcmlhTGl2ZS5BU1NFUlRJVkUgKTtcclxuXHJcbiAgICB0aGlzLmFyaWFMaXZlQ29udGFpbmVyLmFwcGVuZENoaWxkKCBwb2xpdGVFbGVtZW50Q29udGFpbmVyICk7XHJcbiAgICB0aGlzLmFyaWFMaXZlQ29udGFpbmVyLmFwcGVuZENoaWxkKCBhc3NlcnRpdmVFbGVtZW50Q29udGFpbmVyICk7XHJcblxyXG4gICAgdGhpcy5wb2xpdGVFbGVtZW50cyA9IEFycmF5LmZyb20oIHBvbGl0ZUVsZW1lbnRDb250YWluZXIuY2hpbGRyZW4gKSBhcyBIVE1MRWxlbWVudFtdO1xyXG4gICAgdGhpcy5hc3NlcnRpdmVFbGVtZW50cyA9IEFycmF5LmZyb20oIGFzc2VydGl2ZUVsZW1lbnRDb250YWluZXIuY2hpbGRyZW4gKSBhcyBIVE1MRWxlbWVudFtdO1xyXG5cclxuICAgIC8vIGluY3JlbWVudCBpbmRleCBzbyB0aGUgbmV4dCBBcmlhTGl2ZUFubm91bmNlciBpbnN0YW5jZSBoYXMgZGlmZmVyZW50IGlkcyBmb3IgaXRzIGVsZW1lbnRzLlxyXG4gICAgYXJpYUxpdmVBbm5vdW5jZXJJbmRleCsrO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5ub3VuY2UgYW4gYWxlcnQsIHNldHRpbmcgdGV4dENvbnRlbnQgdG8gYW4gYXJpYS1saXZlIGVsZW1lbnQuXHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIGFubm91bmNlKCBhbm5vdW5jZVRleHQ6IFJlc29sdmVkUmVzcG9uc2UsIHV0dGVyYW5jZTogVXR0ZXJhbmNlLCBwcm92aWRlZE9wdGlvbnM/OiBBcmlhTGl2ZUFubm91bmNlckFubm91bmNlT3B0aW9ucyApOiB2b2lkIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPEFyaWFMaXZlQW5ub3VuY2VyQW5ub3VuY2VPcHRpb25zLCBTZWxmT3B0aW9ucz4oKSgge1xyXG5cclxuICAgICAgLy8gQnkgZGVmYXVsdCwgYWxlcnQgdG8gYSBwb2xpdGUgYXJpYS1saXZlIGVsZW1lbnRcclxuICAgICAgYXJpYUxpdmVQcmlvcml0eTogQXJpYUxpdmUuUE9MSVRFXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBhcmlhLWxpdmUgYW5kIEFUIGhhcyBubyBBUEkgdG8gZGV0ZWN0IHN1Y2Nlc3NmdWwgc3BlZWNoLCB3ZSBjYW4gb25seSBhc3N1bWUgZXZlcnkgYW5ub3VuY2UgaXMgc3VjY2Vzc2Z1bFxyXG4gICAgdGhpcy5oYXNTcG9rZW4gPSB0cnVlO1xyXG5cclxuICAgIC8vIERvbid0IHVwZGF0ZSBpZiBudWxsXHJcbiAgICBpZiAoIGFubm91bmNlVGV4dCApIHtcclxuXHJcbiAgICAgIGlmICggb3B0aW9ucy5hcmlhTGl2ZVByaW9yaXR5ID09PSBBcmlhTGl2ZS5QT0xJVEUgKSB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucG9saXRlRWxlbWVudHNbIHRoaXMucG9saXRlRWxlbWVudEluZGV4IF07XHJcbiAgICAgICAgdGhpcy51cGRhdGVMaXZlRWxlbWVudCggZWxlbWVudCwgYW5ub3VuY2VUZXh0LCB1dHRlcmFuY2UgKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGluZGV4IGZvciBuZXh0IHRpbWVcclxuICAgICAgICB0aGlzLnBvbGl0ZUVsZW1lbnRJbmRleCA9ICggdGhpcy5wb2xpdGVFbGVtZW50SW5kZXggKyAxICkgJSB0aGlzLnBvbGl0ZUVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICggb3B0aW9ucy5hcmlhTGl2ZVByaW9yaXR5ID09PSBBcmlhTGl2ZS5BU1NFUlRJVkUgKSB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuYXNzZXJ0aXZlRWxlbWVudHNbIHRoaXMuYXNzZXJ0aXZlRWxlbWVudEluZGV4IF07XHJcbiAgICAgICAgdGhpcy51cGRhdGVMaXZlRWxlbWVudCggZWxlbWVudCwgYW5ub3VuY2VUZXh0LCB1dHRlcmFuY2UgKTtcclxuICAgICAgICAvLyB1cGRhdGUgaW5kZXggZm9yIG5leHQgdGltZVxyXG4gICAgICAgIHRoaXMuYXNzZXJ0aXZlRWxlbWVudEluZGV4ID0gKCB0aGlzLmFzc2VydGl2ZUVsZW1lbnRJbmRleCArIDEgKSAlIHRoaXMuYXNzZXJ0aXZlRWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCAndW5zdXBwb3J0ZWQgYXJpYSBsaXZlIHByaW9pcml0eScgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFdpdGggYXJpYS1saXZlIHdlIGRvbid0IGhhdmUgaW5mb3JtYXRpb24gYWJvdXQgd2hlbiB0aGUgc2NyZWVuIHJlYWRlciBpcyBkb25lIHNwZWFraW5nXHJcbiAgICAvLyB0aGUgY29udGVudCwgc28gd2UgaGF2ZSB0byBlbWl0IHRoaXMgcmlnaHQgYXdheVxyXG4gICAgdGhpcy5hbm5vdW5jZW1lbnRDb21wbGV0ZUVtaXR0ZXIuZW1pdCggdXR0ZXJhbmNlLCBhbm5vdW5jZVRleHQgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBjYW5jZWwgZm9yIEFyaWFMaXZlQW5ub3VuY2VyLiBXZSBkbyBub3Qga25vdyB3aGV0aGVyIHRoZSBBVCBpcyBzcGVha2luZyBjb250ZW50IHNvXHJcbiAgICogdGhpcyBmdW5jdGlvbiBpcyBhIG5vLW9wIGZvciBhcmlhLWxpdmUuXHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIGNhbmNlbCgpOiB2b2lkIHtcclxuICAgIC8vIFNlZSBkb2NzXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgY2FuY2VsVXR0ZXJhbmNlIGZvciBBcmlhTGl2ZUFubm91bmNlci4gV2UgZG8gbm90IGtub3cgd2hldGhlciB0aGUgQVQgaXMgc3BlYWtpbmcgY29udGVudCBzb1xyXG4gICAqIHRoaXMgZnVuY3Rpb24gaXMgYSBuby1vcCBmb3IgYXJpYS1saXZlLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBjYW5jZWxVdHRlcmFuY2UoIHV0dGVyYW5jZTogVXR0ZXJhbmNlICk6IHZvaWQge1xyXG4gICAgLy8gU2VlIGRvY3NcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhbiBlbGVtZW50IHdpdGggdGhlICdhcmlhLWxpdmUnIGF0dHJpYnV0ZSBieSBzZXR0aW5nIGl0cyB0ZXh0IGNvbnRlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbGl2ZUVsZW1lbnQgLSB0aGUgSFRNTCBlbGVtZW50IHRoYXQgd2lsbCBzZW5kIHRoZSBhbGVydCB0byB0aGUgYXNzaXN0aXZlIHRlY2hub2xvZ3lcclxuICAgKiBAcGFyYW0gdGV4dENvbnRlbnQgLSB0aGUgY29udGVudCB0byBiZSBhbm5vdW5jZWRcclxuICAgKiBAcGFyYW0gdXR0ZXJhbmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB1cGRhdGVMaXZlRWxlbWVudCggbGl2ZUVsZW1lbnQ6IEhUTUxFbGVtZW50LCB0ZXh0Q29udGVudDogc3RyaW5nIHwgbnVtYmVyLCB1dHRlcmFuY2U6IFV0dGVyYW5jZSApOiB2b2lkIHtcclxuXHJcbiAgICAvLyBmdWxseSBjbGVhciB0aGUgb2xkIHRleHRDb250ZW50IHNvIHRoYXQgc2VxdWVudGlhbCBhbGVydHMgd2l0aCBpZGVudGljYWwgdGV4dCB3aWxsIGJlIGFubm91bmNlZCwgd2hpY2hcclxuICAgIC8vIHNvbWUgc2NyZWVuIHJlYWRlcnMgbWlnaHQgaGF2ZSBwcmV2ZW50ZWRcclxuICAgIGxpdmVFbGVtZW50LnRleHRDb250ZW50ID0gJyc7XHJcblxyXG4gICAgLy8gZWxlbWVudCBtdXN0IGJlIHZpc2libGUgZm9yIGFsZXJ0cyB0byBiZSBzcG9rZW5cclxuICAgIGxpdmVFbGVtZW50LmhpZGRlbiA9IGZhbHNlO1xyXG5cclxuICAgIC8vIFV0dGVyYW5jZVF1ZXVlIGNhbm5vdCBhbm5vdW5jZSBhZ2FpbiB1bnRpbCBhZnRlciB0aGUgZm9sbG93aW5nIHRpbWVvdXRzLlxyXG4gICAgdGhpcy5yZWFkeVRvQW5ub3VuY2UgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBtdXN0IGJlIGRvbmUgYXN5bmNocm9ub3VzbHkgZnJvbSBzZXR0aW5nIGhpZGRlbiBhYm92ZSBvciBlbHNlIHRoZSBzY3JlZW4gcmVhZGVyXHJcbiAgICAvLyB3aWxsIGZhaWwgdG8gcmVhZCB0aGUgY29udGVudFxyXG4gICAgc3RlcFRpbWVyLnNldFRpbWVvdXQoICgpID0+IHtcclxuXHJcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSB1dHRlcmFuY2UgaXMgbm90IG91dCBvZiBkYXRlIHJpZ2h0IGJlZm9yZSBpdCBpcyBhY3R1YWxseSBzZW50IHRvIGFzc2lzdGl2ZSB0ZWNobm9sb2d5XHJcbiAgICAgIGlmICggdXR0ZXJhbmNlLnByZWRpY2F0ZSgpICkge1xyXG5cclxuICAgICAgICBQRE9NVXRpbHMuc2V0VGV4dENvbnRlbnQoIGxpdmVFbGVtZW50LCB0ZXh0Q29udGVudCApO1xyXG5cclxuICAgICAgICAvLyBIaWRlIHRoZSBjb250ZW50IHNvIHRoYXQgaXQgY2FudCBiZSByZWFkIHdpdGggdGhlIHZpcnR1YWwgY3Vyc29yLiBNdXN0IGJlIGRvbmVcclxuICAgICAgICAvLyBiZWhpbmQgYXQgbGVhc3QgMjAwIG1zIGRlbGF5IG9yIGVsc2UgYWxlcnRzIG1heSBiZSBtaXNzZWQgYnkgTlZEQSBhbmQgVm9pY2VPdmVyLCBzZWVcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc2NlbmVyeS1waGV0L2lzc3Vlcy80OTFcclxuICAgICAgICBzdGVwVGltZXIuc2V0VGltZW91dCggKCkgPT4ge1xyXG5cclxuICAgICAgICAgIGlmICggcGxhdGZvcm0uc2FmYXJpICkge1xyXG5cclxuICAgICAgICAgICAgLy8gVXNpbmcgYGhpZGRlbmAgcmF0aGVyIHRoYW4gY2xlYXJpbmcgdGV4dENvbnRlbnQgd29ya3MgYmV0dGVyIG9uIG1vYmlsZSBWTyxcclxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zY2VuZXJ5LXBoZXQvaXNzdWVzLzQ5MFxyXG4gICAgICAgICAgICBsaXZlRWxlbWVudC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxpdmVFbGVtZW50LnRleHRDb250ZW50ID0gJyc7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gV2FpdCB1bnRpbCBhZnRlciB0aGlzIHRpbWVvdXQgdG8gbGV0IHRoZSBVdHRlcmFuY2VRdWV1ZSBjYW4gYW5ub3VuY2UgVXR0ZXJhbmNlcyBhZ2Fpbi4gVGhpcyBkZWxheVxyXG4gICAgICAgICAgLy8gc2VlbXMgdG8gYmUgbmVjZXNzYXJ5IHRvIGZvcmNlIFZvaWNlT3ZlciB0byBzcGVhayBhcmlhLWxpdmUgYWxlcnRzIGluIGZpcnN0LWluLWZpcnN0LW91dCBvcmRlci5cclxuICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdXR0ZXJhbmNlLXF1ZXVlL2lzc3Vlcy84OFxyXG4gICAgICAgICAgdGhpcy5yZWFkeVRvQW5ub3VuY2UgPSB0cnVlO1xyXG4gICAgICAgIH0sIEFyaWFMaXZlQW5ub3VuY2VyLkFSSUFfTElWRV9ERUxBWSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMucmVhZHlUb0Fubm91bmNlID0gdHJ1ZTsgLy8gSWYgdGhlIHByZWRpY2F0ZSBmYWlscywgd2UgYXJlIHJlYWR5IHRvIGFubm91bmNlIGFnYWluLlxyXG4gICAgICB9XHJcbiAgICB9LCAwICk7XHJcbiAgfVxyXG5cclxuICAvLyBQb3NzaWJsZSB2YWx1ZXMgZm9yIHRoZSBgYXJpYS1saXZlYCBhdHRyaWJ1dGUgKHByaW9yaXR5KSB0aGF0IGNhbiBiZSBhbGVydGVkIChsaWtlIFwicG9saXRlXCIgYW5kXHJcbiAgLy8gXCJhc3NlcnRpdmVcIiksIHNlZSBBcmlhTGl2ZUFubm91bmNlT3B0aW9ucyBmb3IgZGV0YWlscy5cclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFyaWFMaXZlID0gQXJpYUxpdmU7XHJcbn1cclxuXHJcbnV0dGVyYW5jZVF1ZXVlTmFtZXNwYWNlLnJlZ2lzdGVyKCAnQXJpYUxpdmVBbm5vdW5jZXInLCBBcmlhTGl2ZUFubm91bmNlciApO1xyXG5leHBvcnQgZGVmYXVsdCBBcmlhTGl2ZUFubm91bmNlcjsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFNBQVMsTUFBTSw0QkFBNEI7QUFDbEQsT0FBT0MsV0FBVyxNQUFNLG1DQUFtQztBQUMzRCxPQUFPQyxnQkFBZ0IsTUFBTSx3Q0FBd0M7QUFDckUsT0FBT0MsU0FBUyxNQUE0QixpQ0FBaUM7QUFDN0UsT0FBT0MsUUFBUSxNQUFNLGdDQUFnQztBQUNyRCxTQUFTQyxTQUFTLFFBQVEsNkJBQTZCO0FBQ3ZELE9BQU9DLFNBQVMsTUFBc0QsZ0JBQWdCO0FBRXRGLE9BQU9DLHVCQUF1QixNQUFNLDhCQUE4QjtBQUdsRTtBQUNBLE1BQU1DLDRCQUE0QixHQUFHLENBQUM7O0FBRXRDO0FBQ0EsSUFBSUMsc0JBQXNCLEdBQUcsQ0FBQzs7QUFFOUI7QUFDQSxNQUFNQyxRQUFRLFNBQVNSLGdCQUFnQixDQUFDO0VBQy9CUyxXQUFXQSxDQUFrQkMsZUFBdUIsRUFBRztJQUFFLEtBQUssQ0FBQyxDQUFDO0lBQUMsS0FBcENBLGVBQXVCLEdBQXZCQSxlQUF1QjtFQUFhO0VBRXhFLE9BQXVCQyxNQUFNLEdBQUcsSUFBSUgsUUFBUSxDQUFFLFFBQVMsQ0FBQztFQUN4RCxPQUF1QkksU0FBUyxHQUFHLElBQUlKLFFBQVEsQ0FBRSxXQUFZLENBQUM7RUFFOUQsT0FBdUJLLFdBQVcsR0FBRyxJQUFJZCxXQUFXLENBQUVTLFFBQVMsQ0FBQztBQUNsRTs7QUFFQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQSxTQUFTTSxpQ0FBaUNBLENB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