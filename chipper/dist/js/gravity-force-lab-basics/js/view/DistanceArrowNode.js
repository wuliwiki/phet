// Copyright 2017-2023, University of Colorado Boulder

/**
 * Double headed arrow that shows the distance between the two masses in gravity-force-lab-basics.  The arrow
 * goes from the center of one mass to the other.
 *
 * @author Steele Dalton (PhET Interactive Simulations)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import Multilink from '../../../axon/js/Multilink.js';
import merge from '../../../phet-core/js/merge.js';
import StringUtils from '../../../phetcommon/js/util/StringUtils.js';
import ArrowNode from '../../../scenery-phet/js/ArrowNode.js';
import PhetFont from '../../../scenery-phet/js/PhetFont.js';
import { Node, ReadingBlock, Text } from '../../../scenery/js/imports.js';
import gravityForceLabBasics from '../gravityForceLabBasics.js';
import GravityForceLabBasicsStrings from '../GravityForceLabBasicsStrings.js';
const distanceUnitsPatternString = GravityForceLabBasicsStrings.distanceUnitsPattern;
const distanceKilometersPatternString = GravityForceLabBasicsStrings.a11y.voicing.distanceKilometersPattern;
const distanceArrowReadingBlockNameResponseString = GravityForceLabBasicsStrings.a11y.voicing.distanceArrowReadingBlockNameResponse;

// constants
const HEAD_WIDTH = 8;
const HEAD_HEIGHT = 8;
class DistanceArrowNode extends ReadingBlock(Node) {
  /**
   * @mixes {ReadingBlock}
   * @param {GFLBModel} model
   * @param {ModelViewTransform2} modelViewTransform
   * @param {PositionDescriber} positionDescriber
   * @param {Object} [options]
   */
  constructor(model, modelViewTransform, positionDescriber, options) {
    options = merge({
      readingBlockHintResponse: distanceArrowReadingBlockNameResponseString,
      // the content of this ReadingBlock is generally provided with other interaction and so it should not
      // add any content in the PDOM or be added to the navigation order, but it is still available for mouse and touch
      readingBlockTagName: null
    }, options);
    super();
    const arrowNode = new ArrowNode(model.object1.positionProperty.get(), 0, model.object2.positionProperty.get(), 0, {
      doubleHead: true,
      tailWidth: 0.5,
      headHeight: HEAD_HEIGHT,
      headWidth: HEAD_WIDTH,
      stroke: '#BFBFBF',
      fill: '#BFBFBF'
    });
    this.addChild(arrowNode);

    // the label
    const labelText = new Text(StringUtils.fillIn(distanceUnitsPatternString, {
      distance: 0
    }), {
      font: new PhetFont(12),
      bottom: arrowNode.top + 3 * HEAD_WIDTH / 4,
      tandem: options.tandem.createTandem('labelText'),
      stringPropertyOptions: {
        phetioReadOnly: true
      },
      phetioDocumentation: 'The distance as text between the two masses'
    });
    this.addChild(labelText);

    // DistanceArrowNode exists for life of sim and does not need disposal
    Multilink.multilink([model.object1.positionProperty, model.object2.positionProperty], (position1, position2) => {
      // update the arrow node width
      const viewPosition1 = modelViewTransform.modelToViewX(position1);
      const viewPosition2 = modelViewTransform.modelToViewX(position2);
      arrowNode.setTailAndTip(viewPosition1, 0, viewPosition2, 0);
      const distanceInKm = model.separationProperty.get() / 1000; // m to km

      // update label text and center, distance in meters so divide by 1000 to read out in km
      labelText.setString(StringUtils.fillIn(distanceUnitsPatternString, {
        distance: distanceInKm
      }));

      // voicing - update the ReadingBlock content
      this.readingBlockNameResponse = StringUtils.fillIn(distanceKilometersPatternString, {
        distance: distanceInKm
      });
      labelText.centerX = arrowNode.centerX;
    });
    this.mutate(options);
  }
}
gravityForceLabBasics.register('DistanceArrowNode', DistanceArrowNode);
export default DistanceArrowNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNdWx0aWxpbmsiLCJtZXJnZSIsIlN0cmluZ1V0aWxzIiwiQXJyb3dOb2RlIiwiUGhldEZvbnQiLCJOb2RlIiwiUmVhZGluZ0Jsb2NrIiwiVGV4dCIsImdyYXZpdHlGb3JjZUxhYkJhc2ljcyIsIkdyYXZpdHlGb3JjZUxhYkJhc2ljc1N0cmluZ3MiLCJkaXN0YW5jZVVuaXRzUGF0dGVyblN0cmluZyIsImRpc3RhbmNlVW5pdHNQYXR0ZXJuIiwiZGlzdGFuY2VLaWxvbWV0ZXJzUGF0dGVyblN0cmluZyIsImExMXkiLCJ2b2ljaW5nIiwiZGlzdGFuY2VLaWxvbWV0ZXJzUGF0dGVybiIsImRpc3RhbmNlQXJyb3dSZWFkaW5nQmxvY2tOYW1lUmVzcG9uc2VTdHJpbmciLCJkaXN0YW5jZUFycm93UmVhZGluZ0Jsb2NrTmFtZVJlc3BvbnNlIiwiSEVBRF9XSURUSCIsIkhFQURfSEVJR0hUIiwiRGlzdGFuY2VBcnJvd05vZGUiLCJjb25zdHJ1Y3RvciIsIm1vZGVsIiwibW9kZWxWaWV3VHJhbnNmb3JtIiwicG9zaXRpb25EZXNjcmliZXIiLCJvcHRpb25zIiwicmVhZGluZ0Jsb2NrSGludFJlc3BvbnNlIiwicmVhZGluZ0Jsb2NrVGFnTmFtZSIsImFycm93Tm9kZSIsIm9iamVjdDEiLCJwb3NpdGlvblByb3BlcnR5IiwiZ2V0Iiwib2JqZWN0MiIsImRvdWJsZUhlYWQiLCJ0YWlsV2lkdGgiLCJoZWFkSGVpZ2h0IiwiaGVhZFdpZHRoIiwic3Ryb2tlIiwiZmlsbCIsImFkZENoaWxkIiwibGFiZWxUZXh0IiwiZmlsbEluIiwiZGlzdGFuY2UiLCJmb250IiwiYm90dG9tIiwidG9wIiwidGFuZGVtIiwiY3JlYXRlVGFuZGVtIiwic3RyaW5nUHJvcGVydHlPcHRpb25zIiwicGhldGlvUmVhZE9ubHkiLCJwaGV0aW9Eb2N1bWVudGF0aW9uIiwibXVsdGlsaW5rIiwicG9zaXRpb24xIiwicG9zaXRpb24yIiwidmlld1Bvc2l0aW9uMSIsIm1vZGVsVG9WaWV3WCIsInZpZXdQb3NpdGlvbjIiLCJzZXRUYWlsQW5kVGlwIiwiZGlzdGFuY2VJbkttIiwic2VwYXJhdGlvblByb3BlcnR5Iiwic2V0U3RyaW5nIiwicmVhZGluZ0Jsb2NrTmFtZVJlc3BvbnNlIiwiY2VudGVyWCIsIm11dGF0ZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRGlzdGFuY2VBcnJvd05vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTctMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogRG91YmxlIGhlYWRlZCBhcnJvdyB0aGF0IHNob3dzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gbWFzc2VzIGluIGdyYXZpdHktZm9yY2UtbGFiLWJhc2ljcy4gIFRoZSBhcnJvd1xyXG4gKiBnb2VzIGZyb20gdGhlIGNlbnRlciBvZiBvbmUgbWFzcyB0byB0aGUgb3RoZXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgU3RlZWxlIERhbHRvbiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBKZXNzZSBHcmVlbmJlcmcgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IE11bHRpbGluayBmcm9tICcuLi8uLi8uLi9heG9uL2pzL011bHRpbGluay5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgU3RyaW5nVXRpbHMgZnJvbSAnLi4vLi4vLi4vcGhldGNvbW1vbi9qcy91dGlsL1N0cmluZ1V0aWxzLmpzJztcclxuaW1wb3J0IEFycm93Tm9kZSBmcm9tICcuLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvQXJyb3dOb2RlLmpzJztcclxuaW1wb3J0IFBoZXRGb250IGZyb20gJy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9QaGV0Rm9udC5qcyc7XHJcbmltcG9ydCB7IE5vZGUsIFJlYWRpbmdCbG9jaywgVGV4dCB9IGZyb20gJy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBncmF2aXR5Rm9yY2VMYWJCYXNpY3MgZnJvbSAnLi4vZ3Jhdml0eUZvcmNlTGFiQmFzaWNzLmpzJztcclxuaW1wb3J0IEdyYXZpdHlGb3JjZUxhYkJhc2ljc1N0cmluZ3MgZnJvbSAnLi4vR3Jhdml0eUZvcmNlTGFiQmFzaWNzU3RyaW5ncy5qcyc7XHJcblxyXG5jb25zdCBkaXN0YW5jZVVuaXRzUGF0dGVyblN0cmluZyA9IEdyYXZpdHlGb3JjZUxhYkJhc2ljc1N0cmluZ3MuZGlzdGFuY2VVbml0c1BhdHRlcm47XHJcbmNvbnN0IGRpc3RhbmNlS2lsb21ldGVyc1BhdHRlcm5TdHJpbmcgPSBHcmF2aXR5Rm9yY2VMYWJCYXNpY3NTdHJpbmdzLmExMXkudm9pY2luZy5kaXN0YW5jZUtpbG9tZXRlcnNQYXR0ZXJuO1xyXG5jb25zdCBkaXN0YW5jZUFycm93UmVhZGluZ0Jsb2NrTmFtZVJlc3BvbnNlU3RyaW5nID0gR3Jhdml0eUZvcmNlTGFiQmFzaWNzU3RyaW5ncy5hMTF5LnZvaWNpbmcuZGlzdGFuY2VBcnJvd1JlYWRpbmdCbG9ja05hbWVSZXNwb25zZTtcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBIRUFEX1dJRFRIID0gODtcclxuY29uc3QgSEVBRF9IRUlHSFQgPSA4O1xyXG5cclxuY2xhc3MgRGlzdGFuY2VBcnJvd05vZGUgZXh0ZW5kcyBSZWFkaW5nQmxvY2soIE5vZGUgKSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBtaXhlcyB7UmVhZGluZ0Jsb2NrfVxyXG4gICAqIEBwYXJhbSB7R0ZMQk1vZGVsfSBtb2RlbFxyXG4gICAqIEBwYXJhbSB7TW9kZWxWaWV3VHJhbnNmb3JtMn0gbW9kZWxWaWV3VHJhbnNmb3JtXHJcbiAgICogQHBhcmFtIHtQb3NpdGlvbkRlc2NyaWJlcn0gcG9zaXRpb25EZXNjcmliZXJcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIG1vZGVsLCBtb2RlbFZpZXdUcmFuc2Zvcm0sIHBvc2l0aW9uRGVzY3JpYmVyLCBvcHRpb25zICkge1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG4gICAgICByZWFkaW5nQmxvY2tIaW50UmVzcG9uc2U6IGRpc3RhbmNlQXJyb3dSZWFkaW5nQmxvY2tOYW1lUmVzcG9uc2VTdHJpbmcsXHJcblxyXG4gICAgICAvLyB0aGUgY29udGVudCBvZiB0aGlzIFJlYWRpbmdCbG9jayBpcyBnZW5lcmFsbHkgcHJvdmlkZWQgd2l0aCBvdGhlciBpbnRlcmFjdGlvbiBhbmQgc28gaXQgc2hvdWxkIG5vdFxyXG4gICAgICAvLyBhZGQgYW55IGNvbnRlbnQgaW4gdGhlIFBET00gb3IgYmUgYWRkZWQgdG8gdGhlIG5hdmlnYXRpb24gb3JkZXIsIGJ1dCBpdCBpcyBzdGlsbCBhdmFpbGFibGUgZm9yIG1vdXNlIGFuZCB0b3VjaFxyXG4gICAgICByZWFkaW5nQmxvY2tUYWdOYW1lOiBudWxsXHJcbiAgICB9LCBvcHRpb25zICk7XHJcblxyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBjb25zdCBhcnJvd05vZGUgPSBuZXcgQXJyb3dOb2RlKCBtb2RlbC5vYmplY3QxLnBvc2l0aW9uUHJvcGVydHkuZ2V0KCksIDAsXHJcbiAgICAgIG1vZGVsLm9iamVjdDIucG9zaXRpb25Qcm9wZXJ0eS5nZXQoKSwgMCwge1xyXG4gICAgICAgIGRvdWJsZUhlYWQ6IHRydWUsXHJcbiAgICAgICAgdGFpbFdpZHRoOiAwLjUsXHJcbiAgICAgICAgaGVhZEhlaWdodDogSEVBRF9IRUlHSFQsXHJcbiAgICAgICAgaGVhZFdpZHRoOiBIRUFEX1dJRFRILFxyXG4gICAgICAgIHN0cm9rZTogJyNCRkJGQkYnLFxyXG4gICAgICAgIGZpbGw6ICcjQkZCRkJGJ1xyXG4gICAgICB9ICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCBhcnJvd05vZGUgKTtcclxuXHJcbiAgICAvLyB0aGUgbGFiZWxcclxuICAgIGNvbnN0IGxhYmVsVGV4dCA9IG5ldyBUZXh0KCBTdHJpbmdVdGlscy5maWxsSW4oIGRpc3RhbmNlVW5pdHNQYXR0ZXJuU3RyaW5nLCB7IGRpc3RhbmNlOiAwIH0gKSwge1xyXG4gICAgICBmb250OiBuZXcgUGhldEZvbnQoIDEyICksXHJcbiAgICAgIGJvdHRvbTogYXJyb3dOb2RlLnRvcCArICggMyAqIEhFQURfV0lEVEggLyA0ICksXHJcbiAgICAgIHRhbmRlbTogb3B0aW9ucy50YW5kZW0uY3JlYXRlVGFuZGVtKCAnbGFiZWxUZXh0JyApLFxyXG4gICAgICBzdHJpbmdQcm9wZXJ0eU9wdGlvbnM6IHsgcGhldGlvUmVhZE9ubHk6IHRydWUgfSxcclxuICAgICAgcGhldGlvRG9jdW1lbnRhdGlvbjogJ1RoZSBkaXN0YW5jZSBhcyB0ZXh0IGJldHdlZW4gdGhlIHR3byBtYXNzZXMnXHJcbiAgICB9ICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCBsYWJlbFRleHQgKTtcclxuXHJcbiAgICAvLyBEaXN0YW5jZUFycm93Tm9kZSBleGlzdHMgZm9yIGxpZmUgb2Ygc2ltIGFuZCBkb2VzIG5vdCBuZWVkIGRpc3Bvc2FsXHJcbiAgICBNdWx0aWxpbmsubXVsdGlsaW5rKCBbIG1vZGVsLm9iamVjdDEucG9zaXRpb25Qcm9wZXJ0eSwgbW9kZWwub2JqZWN0Mi5wb3NpdGlvblByb3BlcnR5IF0sXHJcbiAgICAgICggcG9zaXRpb24xLCBwb3NpdGlvbjIgKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYXJyb3cgbm9kZSB3aWR0aFxyXG4gICAgICAgIGNvbnN0IHZpZXdQb3NpdGlvbjEgPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdYKCBwb3NpdGlvbjEgKTtcclxuICAgICAgICBjb25zdCB2aWV3UG9zaXRpb24yID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3WCggcG9zaXRpb24yICk7XHJcbiAgICAgICAgYXJyb3dOb2RlLnNldFRhaWxBbmRUaXAoIHZpZXdQb3NpdGlvbjEsIDAsIHZpZXdQb3NpdGlvbjIsIDAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2VJbkttID0gbW9kZWwuc2VwYXJhdGlvblByb3BlcnR5LmdldCgpIC8gMTAwMDsgLy8gbSB0byBrbVxyXG5cclxuICAgICAgICAvLyB1cGRhdGUgbGFiZWwgdGV4dCBhbmQgY2VudGVyLCBkaXN0YW5jZSBpbiBtZXRlcnMgc28gZGl2aWRlIGJ5IDEwMDAgdG8gcmVhZCBvdXQgaW4ga21cclxuICAgICAgICBsYWJlbFRleHQuc2V0U3RyaW5nKCBTdHJpbmdVdGlscy5maWxsSW4oIGRpc3RhbmNlVW5pdHNQYXR0ZXJuU3RyaW5nLCB7XHJcbiAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2VJbkttXHJcbiAgICAgICAgfSApICk7XHJcblxyXG4gICAgICAgIC8vIHZvaWNpbmcgLSB1cGRhdGUgdGhlIFJlYWRpbmdCbG9jayBjb250ZW50XHJcbiAgICAgICAgdGhpcy5yZWFkaW5nQmxvY2tOYW1lUmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIGRpc3RhbmNlS2lsb21ldGVyc1BhdHRlcm5TdHJpbmcsIHtcclxuICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZUluS21cclxuICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgIGxhYmVsVGV4dC5jZW50ZXJYID0gYXJyb3dOb2RlLmNlbnRlclg7XHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICB0aGlzLm11dGF0ZSggb3B0aW9ucyApO1xyXG4gIH1cclxufVxyXG5cclxuZ3Jhdml0eUZvcmNlTGFiQmFzaWNzLnJlZ2lzdGVyKCAnRGlzdGFuY2VBcnJvd05vZGUnLCBEaXN0YW5jZUFycm93Tm9kZSApO1xyXG5leHBvcnQgZGVmYXVsdCBEaXN0YW5jZUFycm93Tm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFNBQVMsTUFBTSwrQkFBK0I7QUFDckQsT0FBT0MsS0FBSyxNQUFNLGdD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