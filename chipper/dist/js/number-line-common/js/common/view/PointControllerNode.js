// Copyright 2020-2022, University of Colorado Boulder

/**
 * PointControllerNode is a Scenery node that represents a point controller in the view.  Interactions with point
 * controller nodes enable the user to add, remove, and manipulate points on a number line.
 *
 * @author John Blanco (PhET Interactive Simulations)
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import Property from '../../../../axon/js/Property.js';
import LockToNumberLine from '../../../../number-line-common/js/common/model/LockToNumberLine.js';
import merge from '../../../../phet-core/js/merge.js';
import Orientation from '../../../../phet-core/js/Orientation.js';
import ShadedSphereNode from '../../../../scenery-phet/js/ShadedSphereNode.js';
import { DragListener, Line, Node } from '../../../../scenery/js/imports.js';
import numberLineCommon from '../../numberLineCommon.js';

// constants
const SPHERE_RADIUS = 10; // in screen coords, radius of sphere that is used if no controller node is provided
const ALWAYS_TRUE_PROPERTY = new BooleanProperty(true);
class PointControllerNode extends Node {
  /**
   * @param {PointController} pointController
   * @param {Object} [options]
   * @public
   */
  constructor(pointController, options) {
    options = merge({
      // {node} - The node used for the view representation.  Its X and Y position will be set based on the position
      // of the corresponding point controller, so it should be set up with the appropriate offset bounds.  A shaded
      // sphere is created if no node is provided.
      node: null,
      // {boolean} - controls whether there is a line drawn from this controller to the number line
      connectorLine: true,
      // {BooleanProperty} - if the connector line is present, this boolean Property can optionally be provided to
      // control its visibility
      connectorLineVisibleProperty: ALWAYS_TRUE_PROPERTY,
      cursor: 'pointer'
    }, options);
    super(options);

    // Create and add the line that will connect to the number line point.
    const connectorLine = new Line(0, 0, 0, 0, {
      stroke: 'gray'
    });
    connectorLine.visible = false;
    this.addChild(connectorLine);

    // @private {Node} - the node that the user will drag to move the point controller around.  If a node is not
    // provided by the client, a default node is created.
    this.draggableNode = options.node || new ShadedSphereNode(SPHERE_RADIUS * 2, {
      mainColor: pointController.color
    });
    this.addChild(this.draggableNode);

    // function to update the visibility of the connector line
    const updateConnectorLineVisibility = () => {
      connectorLine.visible = options.connectorLineVisibleProperty.value && pointController.isControllingNumberLinePoint();
    };

    // A point controller node is visible most of the time, but if it is controlling a point that goes outside of the
    // displayed range of the number line, it should be invisible.
    const updatePointControllerVisibility = () => {
      if (pointController.numberLinePoints.length >= 1) {
        let atLeastOnePointVisible = false;
        pointController.numberLines.forEach(numberLine => {
          pointController.numberLinePoints.forEach(point => {
            if (numberLine.isPointInDisplayedRange(point)) {
              atLeastOnePointVisible = true;
            }
          });
        });
        this.visible = atLeastOnePointVisible;
      } else {
        // always visible if not controlling a point
        this.visible = true;
      }
    };

    // If this point controller is permanently attached to a number line, monitor that number line for changes to its
    // displayed range and make updates to this node's visibility.
    if (pointController.lockToNumberLine === LockToNumberLine.ALWAYS) {
      // As of this writing, there is no support for having a point controller permanently locked to multiple number
      // lines, and it seems like an unlikely case, so the following assert checks that there is only one.  If support
      // for point controllers that are locked to multiple number lines is ever needed, this will need to change.
      assert && assert(pointController.numberLines.length === 1);

      // Listen for changes to the number line's displayed range and update visibility.
      const numberLine = pointController.numberLines[0];
      numberLine.displayedRangeProperty.link(updatePointControllerVisibility);
    }

    // Handle changes to the point controller position.
    const updateAppearanceOnPositionChange = position => {
      if (options.connectorLine && pointController.isControllingNumberLinePoint()) {
        // As of this writing (Nov 2019), PointControllerNode only handles drawing connector lines to a single point.
        // It would be possible to handle multiple points, but this has not been needed thus far and is therefore not
        // handled. If you need it, feel free to add it.
        assert && assert(pointController.numberLinePoints.length === 1, 'incorrect number of points controlled');

        // Update the connector line.
        const pointPosition = pointController.numberLinePoints.get(0).getPositionInModelSpace();
        connectorLine.setLine(position.x, position.y, pointPosition.x, pointPosition.y);
      }
      updateConnectorLineVisibility();
      this.draggableNode.translation = position;
      updatePointControllerVisibility();
    };
    pointController.positionProperty.link(updateAppearanceOnPositionChange);

    // Closure that moves this point controller node to the front of the z-order.
    const moveToFront = () => {
      this.moveToFront();
    };

    // Move this point controller to the front of the z-order if any of it's currently controlled points change.
    pointController.numberLinePoints.forEach(numberLinePoint => {
      numberLinePoint.valueProperty.link(moveToFront);
    });

    // Watch for new controlled points and add listeners to manage layering.
    const pointAddedListener = numberLinePoint => {
      numberLinePoint.valueProperty.link(moveToFront);
    };
    pointController.numberLinePoints.addItemAddedListener(pointAddedListener);

    // Remove our listeners from points that are removed from this point controller's list.
    const pointRemovedListener = removedNumberLinePoint => {
      removedNumberLinePoint.valueProperty.unlink(moveToFront);
    };
    pointController.numberLinePoints.addItemRemovedListener(pointRemovedListener);
    if (options.connectorLineVisibleProperty !== ALWAYS_TRUE_PROPERTY) {
      assert && assert(options.connectorLine, 'must have connector line turned on for the viz Property to make sense');
      options.connectorLineVisibleProperty.link(updateConnectorLineVisibility);
    }
    const handlePointControllerScaleChange = scale => {
      this.draggableNode.setScaleMagnitude(scale);
    };
    pointController.scaleProperty.link(handlePointControllerScaleChange);

    // Pop to the front of the z-order when dragged.
    const dragStateChangeHandler = dragging => {
      if (dragging) {
        this.moveToFront();
      }
    };
    pointController.isDraggingProperty.link(dragStateChangeHandler);

    // Don't allow the point controller node to be grabbed if it is animating somewhere.
    const inProgressAnimationChangedHandler = inProgressAnimation => {
      this.pickable = inProgressAnimation === null;
    };
    pointController.inProgressAnimationProperty.link(inProgressAnimationChangedHandler);

    // drag handler if intended to be dragged
    if (options.pickable !== false) {
      let pointOffset;
      this.addInputListener(new DragListener({
        dragBoundsProperty: new Property(this.layoutBounds),
        start: event => {
          pointController.isDraggingProperty.value = true;
          const point = this.draggableNode.globalToParentPoint(event.pointer.point); // pointer in parent frame
          const relativePoint = point.minus(this.draggableNode); // pointer in local frame
          const startingOffset = relativePoint.dividedScalar(pointController.scaleProperty.value).minus(relativePoint); // if node has a scale, find offset of node after it is set to 1.0 scale
          pointController.scaleProperty.value = 1.0;
          pointController.proposePosition(this.draggableNode.translation.minus(startingOffset) // if node had scale, move it to where pointer clicked
          );

          pointOffset = point.minus(this.draggableNode);
        },
        drag: event => {
          pointController.isDraggingProperty.value = true; // necessary in case isDraggingProperty is changed while dragging
          const parentPoint = this.globalToParentPoint(event.pointer.point);
          pointController.proposePosition(parentPoint.minus(pointOffset));
        },
        end: () => {
          pointController.isDraggingProperty.value = false;
        }
      }));
    }

    // If the default point controller node is being used, create and hook up the listener that will update touch
    // areas as the orientation changes so that the point controllers can be easily grabbed by a user's finger without
    // covering them up.
    let setTouchDilationBasedOnOrientation;
    if (!options.node) {
      setTouchDilationBasedOnOrientation = orientation => {
        const nominalBounds = this.draggableNode.localBounds;
        let touchAreaBounds;
        if (orientation === Orientation.HORIZONTAL) {
          const dilatedBounds = nominalBounds.dilateXY(SPHERE_RADIUS / 2, SPHERE_RADIUS * 2);
          touchAreaBounds = dilatedBounds.shiftedY(SPHERE_RADIUS * 1.5);
        } else {
          const dilatedBounds = nominalBounds.dilateXY(SPHERE_RADIUS * 2, SPHERE_RADIUS / 2);
          touchAreaBounds = dilatedBounds.shiftedX(SPHERE_RADIUS * 1.5);
        }
        this.draggableNode.setTouchArea(touchAreaBounds);
      };
      pointController.numberLines[0].orientationProperty.link(setTouchDilationBasedOnOrientation);
    }

    // @private
    this.disposePointControllerNode = () => {
      pointController.positionProperty.unlink(updateAppearanceOnPositionChange);
      pointController.isDraggingProperty.unlink(dragStateChangeHandler);
      pointController.inProgressAnimationProperty.unlink(inProgressAnimationChangedHandler);
      if (options.connectorLineVisibleProperty.hasListener(updateConnectorLineVisibility)) {
        options.connectorLineVisibleProperty.unlink(updateConnectorLineVisibility);
      }
      pointController.numberLines.forEach(numberLine => {
        if (numberLine.displayedRangeProperty.hasListener(updatePointControllerVisibility)) {
          numberLine.displayedRangeProperty.unlink(updatePointControllerVisibility);
        }
        if (numberLine.orientationProperty.hasListener(setTouchDilationBasedOnOrientation)) {
          numberLine.orientationProperty.unlink(setTouchDilationBasedOnOrientation);
        }
      });
      pointController.numberLinePoints.removeItemAddedListener(pointAddedListener);
      pointController.numberLinePoints.removeItemRemovedListener(pointRemovedListener);
      pointController.numberLinePoints.forEach(numberLinePoint => {
        numberLinePoint.valueProperty.unlink(moveToFront);
      });
    };
  }

  /**
   * Clean up any linkages or other references that could lead to memory leaks.
   * @public
   * @override
   */
  dispose() {
    this.interruptSubtreeInput(); // Make sure there are no in-progress interactions, see #106.
    this.disposePointControllerNode();
    super.dispose();
  }
}
numberLineCommon.register('PointControllerNode', PointControllerNode);
export default PointControllerNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJQcm9wZXJ0eSIsIkxvY2tUb051bWJlckxpbmUiLCJtZXJnZSIsIk9yaWVudGF0aW9uIiwiU2hhZGVkU3BoZXJlTm9kZSIsIkRyYWdMaXN0ZW5lciIsIkxpbmUiLCJOb2RlIiwibnVtYmVyTGluZUNvbW1vbiIsIlNQSEVSRV9SQURJVVMiLCJBTFdBWVNfVFJVRV9QUk9QRVJUWSIsIlBvaW50Q29udHJvbGxlck5vZGUiLCJjb25zdHJ1Y3RvciIsInBvaW50Q29udHJvbGxlciIsIm9wdGlvbnMiLCJub2RlIiwiY29ubmVjdG9yTGluZSIsImNvbm5lY3RvckxpbmVWaXNpYmxlUHJvcGVydHkiLCJjdXJzb3IiLCJzdHJva2UiLCJ2aXNpYmxlIiwiYWRkQ2hpbGQiLCJkcmFnZ2FibGVOb2RlIiwibWFpbkNvbG9yIiwiY29sb3IiLCJ1cGRhdGVDb25uZWN0b3JMaW5lVmlzaWJpbGl0eSIsInZhbHVlIiwiaXNDb250cm9sbGluZ051bWJlckxpbmVQb2ludCIsInVwZGF0ZVBvaW50Q29udHJvbGxlclZpc2liaWxpdHkiLCJudW1iZXJMaW5lUG9pbnRzIiwibGVuZ3RoIiwiYXRMZWFzdE9uZVBvaW50VmlzaWJsZSIsIm51bWJlckxpbmVzIiwiZm9yRWFjaCIsIm51bWJlckxpbmUiLCJwb2ludCIsImlzUG9pbnRJbkRpc3BsYXllZFJhbmdlIiwibG9ja1RvTnVtYmVyTGluZSIsIkFMV0FZUyIsImFzc2VydCIsImRpc3BsYXllZFJhbmdlUHJvcGVydHkiLCJsaW5rIiwidXBkYXRlQXBwZWFyYW5jZU9uUG9zaXRpb25DaGFuZ2UiLCJwb3NpdGlvbiIsInBvaW50UG9zaXRpb24iLCJnZXQiLCJnZXRQb3NpdGlvbkluTW9kZWxTcGFjZSIsInNldExpbmUiLCJ4IiwieSIsInRyYW5zbGF0aW9uIiwicG9zaXRpb25Qcm9wZXJ0eSIsIm1vdmVUb0Zyb250IiwibnVtYmVyTGluZVBvaW50IiwidmFsdWVQcm9wZXJ0eSIsInBvaW50QWRkZWRMaXN0ZW5lciIsImFkZEl0ZW1BZGRlZExpc3RlbmVyIiwicG9pbnRSZW1vdmVkTGlzdGVuZXIiLCJyZW1vdmVkTnVtYmVyTGluZVBvaW50IiwidW5saW5rIiwiYWRkSXRlbVJlbW92ZWRMaXN0ZW5lciIsImhhbmRsZVBvaW50Q29udHJvbGxlclNjYWxlQ2hhbmdlIiwic2NhbGUiLCJzZXRTY2FsZU1hZ25pdHVkZSIsInNjYWxlUHJvcGVydHkiLCJkcmFnU3RhdGVDaGFuZ2VIYW5kbGVyIiwiZHJhZ2dpbmciLCJpc0RyYWdnaW5nUHJvcGVydHkiLCJpblByb2dyZXNzQW5pbWF0aW9uQ2hhbmdlZEhhbmRsZXIiLCJpblByb2dyZXNzQW5pbWF0aW9uIiwicGlja2FibGUiLCJpblByb2dyZXNzQW5pbWF0aW9uUHJvcGVydHkiLCJwb2ludE9mZnNldCIsImFkZElucHV0TGlzdGVuZXIiLCJkcmFnQm91bmRzUHJvcGVydHkiLCJsYXlvdXRCb3VuZHMiLCJzdGFydCIsImV2ZW50IiwiZ2xvYmFsVG9QYXJlbnRQb2ludCIsInBvaW50ZXIiLCJyZWxhdGl2ZVBvaW50IiwibWludXMiLCJzdGFydGluZ09mZnNldCIsImRpdmlkZWRTY2FsYXIiLCJwcm9wb3NlUG9zaXRpb24iLCJkcmFnIiwicGFyZW50UG9pbnQiLCJlbmQiLCJzZXRUb3VjaERpbGF0aW9uQmFzZWRPbk9yaWVudGF0aW9uIiwib3JpZW50YXRpb24iLCJub21pbmFsQm91bmRzIiwibG9jYWxCb3VuZHMiLCJ0b3VjaEFyZWFCb3VuZHMiLCJIT1JJWk9OVEFMIiwiZGlsYXRlZEJvdW5kcyIsImRpbGF0ZVhZIiwic2hpZnRlZFkiLCJzaGlmdGVkWCIsInNldFRvdWNoQXJlYSIsIm9yaWVudGF0aW9uUHJvcGVydHkiLCJkaXNwb3NlUG9pbnRDb250cm9sbGVyTm9kZSIsImhhc0xpc3RlbmVyIiwicmVtb3ZlSXRlbUFkZGVkTGlzdGVuZXIiLCJyZW1vdmVJdGVtUmVtb3ZlZExpc3RlbmVyIiwiZGlzcG9zZSIsImludGVycnVwdFN1YnRyZWVJbnB1dCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiUG9pbnRDb250cm9sbGVyTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMC0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBQb2ludENvbnRyb2xsZXJOb2RlIGlzIGEgU2NlbmVyeSBub2RlIHRoYXQgcmVwcmVzZW50cyBhIHBvaW50IGNvbnRyb2xsZXIgaW4gdGhlIHZpZXcuICBJbnRlcmFjdGlvbnMgd2l0aCBwb2ludFxyXG4gKiBjb250cm9sbGVyIG5vZGVzIGVuYWJsZSB0aGUgdXNlciB0byBhZGQsIHJlbW92ZSwgYW5kIG1hbmlwdWxhdGUgcG9pbnRzIG9uIGEgbnVtYmVyIGxpbmUuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY28gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IEJvb2xlYW5Qcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0Jvb2xlYW5Qcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IExvY2tUb051bWJlckxpbmUgZnJvbSAnLi4vLi4vLi4vLi4vbnVtYmVyLWxpbmUtY29tbW9uL2pzL2NvbW1vbi9tb2RlbC9Mb2NrVG9OdW1iZXJMaW5lLmpzJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCBPcmllbnRhdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvT3JpZW50YXRpb24uanMnO1xyXG5pbXBvcnQgU2hhZGVkU3BoZXJlTm9kZSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvU2hhZGVkU3BoZXJlTm9kZS5qcyc7XHJcbmltcG9ydCB7IERyYWdMaXN0ZW5lciwgTGluZSwgTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBudW1iZXJMaW5lQ29tbW9uIGZyb20gJy4uLy4uL251bWJlckxpbmVDb21tb24uanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IFNQSEVSRV9SQURJVVMgPSAxMDsgLy8gaW4gc2NyZWVuIGNvb3JkcywgcmFkaXVzIG9mIHNwaGVyZSB0aGF0IGlzIHVzZWQgaWYgbm8gY29udHJvbGxlciBub2RlIGlzIHByb3ZpZGVkXHJcbmNvbnN0IEFMV0FZU19UUlVFX1BST1BFUlRZID0gbmV3IEJvb2xlYW5Qcm9wZXJ0eSggdHJ1ZSApO1xyXG5cclxuY2xhc3MgUG9pbnRDb250cm9sbGVyTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1BvaW50Q29udHJvbGxlcn0gcG9pbnRDb250cm9sbGVyXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggcG9pbnRDb250cm9sbGVyLCBvcHRpb25zICkge1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG5cclxuICAgICAgLy8ge25vZGV9IC0gVGhlIG5vZGUgdXNlZCBmb3IgdGhlIHZpZXcgcmVwcmVzZW50YXRpb24uICBJdHMgWCBhbmQgWSBwb3NpdGlvbiB3aWxsIGJlIHNldCBiYXNlZCBvbiB0aGUgcG9zaXRpb25cclxuICAgICAgLy8gb2YgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgY29udHJvbGxlciwgc28gaXQgc2hvdWxkIGJlIHNldCB1cCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBvZmZzZXQgYm91bmRzLiAgQSBzaGFkZWRcclxuICAgICAgLy8gc3BoZXJlIGlzIGNyZWF0ZWQgaWYgbm8gbm9kZSBpcyBwcm92aWRlZC5cclxuICAgICAgbm9kZTogbnVsbCxcclxuXHJcbiAgICAgIC8vIHtib29sZWFufSAtIGNvbnRyb2xzIHdoZXRoZXIgdGhlcmUgaXMgYSBsaW5lIGRyYXduIGZyb20gdGhpcyBjb250cm9sbGVyIHRvIHRoZSBudW1iZXIgbGluZVxyXG4gICAgICBjb25uZWN0b3JMaW5lOiB0cnVlLFxyXG5cclxuICAgICAgLy8ge0Jvb2xlYW5Qcm9wZXJ0eX0gLSBpZiB0aGUgY29ubmVjdG9yIGxpbmUgaXMgcHJlc2VudCwgdGhpcyBib29sZWFuIFByb3BlcnR5IGNhbiBvcHRpb25hbGx5IGJlIHByb3ZpZGVkIHRvXHJcbiAgICAgIC8vIGNvbnRyb2wgaXRzIHZpc2liaWxpdHlcclxuICAgICAgY29ubmVjdG9yTGluZVZpc2libGVQcm9wZXJ0eTogQUxXQVlTX1RSVUVfUFJPUEVSVFksXHJcblxyXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJ1xyXG5cclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICBzdXBlciggb3B0aW9ucyApO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhbmQgYWRkIHRoZSBsaW5lIHRoYXQgd2lsbCBjb25uZWN0IHRvIHRoZSBudW1iZXIgbGluZSBwb2ludC5cclxuICAgIGNvbnN0IGNvbm5lY3RvckxpbmUgPSBuZXcgTGluZSggMCwgMCwgMCwgMCwgeyBzdHJva2U6ICdncmF5JyB9ICk7XHJcbiAgICBjb25uZWN0b3JMaW5lLnZpc2libGUgPSBmYWxzZTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIGNvbm5lY3RvckxpbmUgKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7Tm9kZX0gLSB0aGUgbm9kZSB0aGF0IHRoZSB1c2VyIHdpbGwgZHJhZyB0byBtb3ZlIHRoZSBwb2ludCBjb250cm9sbGVyIGFyb3VuZC4gIElmIGEgbm9kZSBpcyBub3RcclxuICAgIC8vIHByb3ZpZGVkIGJ5IHRoZSBjbGllbnQsIGEgZGVmYXVsdCBub2RlIGlzIGNyZWF0ZWQuXHJcbiAgICB0aGlzLmRyYWdnYWJsZU5vZGUgPSBvcHRpb25zLm5vZGUgfHwgbmV3IFNoYWRlZFNwaGVyZU5vZGUoIFNQSEVSRV9SQURJVVMgKiAyLCB7XHJcbiAgICAgIG1haW5Db2xvcjogcG9pbnRDb250cm9sbGVyLmNvbG9yXHJcbiAgICB9ICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCB0aGlzLmRyYWdnYWJsZU5vZGUgKTtcclxuXHJcbiAgICAvLyBmdW5jdGlvbiB0byB1cGRhdGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGNvbm5lY3RvciBsaW5lXHJcbiAgICBjb25zdCB1cGRhdGVDb25uZWN0b3JMaW5lVmlzaWJpbGl0eSA9ICgpID0+IHtcclxuICAgICAgY29ubmVjdG9yTGluZS52aXNpYmxlID0gb3B0aW9ucy5jb25uZWN0b3JMaW5lVmlzaWJsZVByb3BlcnR5LnZhbHVlICYmIHBvaW50Q29udHJvbGxlci5pc0NvbnRyb2xsaW5nTnVtYmVyTGluZVBvaW50KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEEgcG9pbnQgY29udHJvbGxlciBub2RlIGlzIHZpc2libGUgbW9zdCBvZiB0aGUgdGltZSwgYnV0IGlmIGl0IGlzIGNvbnRyb2xsaW5nIGEgcG9pbnQgdGhhdCBnb2VzIG91dHNpZGUgb2YgdGhlXHJcbiAgICAvLyBkaXNwbGF5ZWQgcmFuZ2Ugb2YgdGhlIG51bWJlciBsaW5lLCBpdCBzaG91bGQgYmUgaW52aXNpYmxlLlxyXG4gICAgY29uc3QgdXBkYXRlUG9pbnRDb250cm9sbGVyVmlzaWJpbGl0eSA9ICgpID0+IHtcclxuICAgICAgaWYgKCBwb2ludENvbnRyb2xsZXIubnVtYmVyTGluZVBvaW50cy5sZW5ndGggPj0gMSApIHtcclxuICAgICAgICBsZXQgYXRMZWFzdE9uZVBvaW50VmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHBvaW50Q29udHJvbGxlci5udW1iZXJMaW5lcy5mb3JFYWNoKCBudW1iZXJMaW5lID0+IHtcclxuICAgICAgICAgIHBvaW50Q29udHJvbGxlci5udW1iZXJMaW5lUG9pbnRzLmZvckVhY2goIHBvaW50ID0+IHtcclxuICAgICAgICAgICAgaWYgKCBudW1iZXJMaW5lLmlzUG9pbnRJbkRpc3BsYXllZFJhbmdlKCBwb2ludCApICkge1xyXG4gICAgICAgICAgICAgIGF0TGVhc3RPbmVQb2ludFZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9ICk7XHJcbiAgICAgICAgfSApO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGF0TGVhc3RPbmVQb2ludFZpc2libGU7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIGFsd2F5cyB2aXNpYmxlIGlmIG5vdCBjb250cm9sbGluZyBhIHBvaW50XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJZiB0aGlzIHBvaW50IGNvbnRyb2xsZXIgaXMgcGVybWFuZW50bHkgYXR0YWNoZWQgdG8gYSBudW1iZXIgbGluZSwgbW9uaXRvciB0aGF0IG51bWJlciBsaW5lIGZvciBjaGFuZ2VzIHRvIGl0c1xyXG4gICAgLy8gZGlzcGxheWVkIHJhbmdlIGFuZCBtYWtlIHVwZGF0ZXMgdG8gdGhpcyBub2RlJ3MgdmlzaWJpbGl0eS5cclxuICAgIGlmICggcG9pbnRDb250cm9sbGVyLmxvY2tUb051bWJlckxpbmUgPT09IExvY2tUb051bWJlckxpbmUuQUxXQVlTICkge1xyXG5cclxuICAgICAgLy8gQXMgb2YgdGhpcyB3cml0aW5nLCB0aGVyZSBpcyBubyBzdXBwb3J0IGZvciBoYXZpbmcgYSBwb2ludCBjb250cm9sbGVyIHBlcm1hbmVudGx5IGxvY2tlZCB0byBtdWx0aXBsZSBudW1iZXJcclxuICAgICAgLy8gbGluZXMsIGFuZCBpdCBzZWVtcyBsaWtlIGFuIHVubGlrZWx5IGNhc2UsIHNvIHRoZSBmb2xsb3dpbmcgYXNzZXJ0IGNoZWNrcyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lLiAgSWYgc3VwcG9ydFxyXG4gICAgICAvLyBmb3IgcG9pbnQgY29udHJvbGxlcnMgdGhhdCBhcmUgbG9ja2VkIHRvIG11bHRpcGxlIG51bWJlciBsaW5lcyBpcyBldmVyIG5lZWRlZCwgdGhpcyB3aWxsIG5lZWQgdG8gY2hhbmdlLlxyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwb2ludENvbnRyb2xsZXIubnVtYmVyTGluZXMubGVuZ3RoID09PSAxICk7XHJcblxyXG4gICAgICAvLyBMaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdGhlIG51bWJlciBsaW5lJ3MgZGlzcGxheWVkIHJhbmdlIGFuZCB1cGRhdGUgdmlzaWJpbGl0eS5cclxuICAgICAgY29uc3QgbnVtYmVyTGluZSA9IHBvaW50Q29udHJvbGxlci5udW1iZXJMaW5lc1sgMCBdO1xyXG4gICAgICBudW1iZXJMaW5lLmRpc3BsYXllZFJhbmdlUHJvcGVydHkubGluayggdXBkYXRlUG9pbnRDb250cm9sbGVyVmlzaWJpbGl0eSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEhhbmRsZSBjaGFuZ2VzIHRvIHRoZSBwb2ludCBjb250cm9sbGVyIHBvc2l0aW9uLlxyXG4gICAgY29uc3QgdXBkYXRlQXBwZWFyYW5jZU9uUG9zaXRpb25DaGFuZ2UgPSBwb3NpdGlvbiA9PiB7XHJcbiAgICAgIGlmICggb3B0aW9ucy5jb25uZWN0b3JMaW5lICYmIHBvaW50Q29udHJvbGxlci5pc0NvbnRyb2xsaW5nTnVtYmVyTGluZVBvaW50KCkgKSB7XHJcblxyXG4gICAgICAgIC8vIEFzIG9mIHRoaXMgd3JpdGluZyAoTm92IDIwMTkpLCBQb2ludENvbnRyb2xsZXJOb2RlIG9ubHkgaGFuZGxlcyBkcmF3aW5nIGNvbm5lY3RvciBsaW5lcyB0byBhIHNpbmdsZSBwb2ludC5cclxuICAgICAgICAvLyBJdCB3b3VsZCBiZSBwb3NzaWJsZSB0byBoYW5kbGUgbXVsdGlwbGUgcG9pbnRzLCBidXQgdGhpcyBoYXMgbm90IGJlZW4gbmVlZGVkIHRodXMgZmFyIGFuZCBpcyB0aGVyZWZvcmUgbm90XHJcbiAgICAgICAgLy8gaGFuZGxlZC4gSWYgeW91IG5lZWQgaXQsIGZlZWwgZnJlZSB0byBhZGQgaXQuXHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggcG9pbnRDb250cm9sbGVyLm51bWJlckxpbmVQb2ludHMubGVuZ3RoID09PSAxLCAnaW5jb3JyZWN0IG51bWJlciBvZiBwb2ludHMgY29udHJvbGxlZCcgKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjb25uZWN0b3IgbGluZS5cclxuICAgICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gcG9pbnRDb250cm9sbGVyLm51bWJlckxpbmVQb2ludHMuZ2V0KCAwICkuZ2V0UG9zaXRpb25Jbk1vZGVsU3BhY2UoKTtcclxuICAgICAgICBjb25uZWN0b3JMaW5lLnNldExpbmUoIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55ICk7XHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlQ29ubmVjdG9yTGluZVZpc2liaWxpdHkoKTtcclxuICAgICAgdGhpcy5kcmFnZ2FibGVOb2RlLnRyYW5zbGF0aW9uID0gcG9zaXRpb247XHJcbiAgICAgIHVwZGF0ZVBvaW50Q29udHJvbGxlclZpc2liaWxpdHkoKTtcclxuICAgIH07XHJcbiAgICBwb2ludENvbnRyb2xsZXIucG9zaXRpb25Qcm9wZXJ0eS5saW5rKCB1cGRhdGVBcHBlYXJhbmNlT25Qb3NpdGlvbkNoYW5nZSApO1xyXG5cclxuICAgIC8vIENsb3N1cmUgdGhhdCBtb3ZlcyB0aGlzIHBvaW50IGNvbnRyb2xsZXIgbm9kZSB0byB0aGUgZnJvbnQgb2YgdGhlIHotb3JkZXIuXHJcbiAgICBjb25zdCBtb3ZlVG9Gcm9udCA9ICgpID0+IHsgdGhpcy5tb3ZlVG9Gcm9udCgpOyB9O1xyXG5cclxuICAgIC8vIE1vdmUgdGhpcyBwb2ludCBjb250cm9sbGVyIHRvIHRoZSBmcm9udCBvZiB0aGUgei1vcmRlciBpZiBhbnkgb2YgaXQncyBjdXJyZW50bHkgY29udHJvbGxlZCBwb2ludHMgY2hhbmdlLlxyXG4gICAgcG9pbnRDb250cm9sbGVyLm51bWJlckxpbmVQb2ludHMuZm9yRWFjaCggbnVtYmVyTGluZVBvaW50ID0+IHtcclxuICAgICAgbnVtYmVyTGluZVBvaW50LnZhbHVlUHJvcGVydHkubGluayggbW92ZVRvRnJvbnQgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBXYXRjaCBmb3IgbmV3IGNvbnRyb2xsZWQgcG9pbnRzIGFuZCBhZGQgbGlzdGVuZXJzIHRvIG1hbmFnZSBsYXllcmluZy5cclxuICAgIGNvbnN0IHBvaW50QWRkZWRMaXN0ZW5lciA9IG51bWJlckxpbmVQb2ludCA9PiB7XHJcbiAgICAgIG51bWJlckxpbmVQb2ludC52YWx1ZVByb3BlcnR5LmxpbmsoIG1vdmVUb0Zyb250ICk7XHJcbiAgICB9O1xyXG4gICAgcG9pbnRDb250cm9sbGVyLm51bWJlckxpbmVQb2ludHMuYWRkSXRlbUFkZGVkTGlzdGVuZXIoIHBvaW50QWRkZWRMaXN0ZW5lciApO1xyXG5cclxuICAgIC8vIFJlbW92ZSBvdXIgbGlzdGVuZXJzIGZyb20gcG9pbnRzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSB0aGlzIHBvaW50IGNvbnRyb2xsZXIncyBsaXN0LlxyXG4gICAgY29uc3QgcG9pbnRSZW1vdmVkTGlzdGVuZXIgPSByZW1vdmVkTnVtYmVyTGluZVBvaW50ID0+IHtcclxuICAgICAgcmVtb3ZlZE51bWJlckxpbmVQb2ludC52YWx1ZVByb3BlcnR5LnVubGluayggbW92ZVRvRnJvbnQgKTtcclxuICAgIH07XHJcbiAgICBwb2ludENvbnRyb2xsZXIubnVtYmVyTGluZVBvaW50cy5hZGRJdGVtUmVtb3ZlZExpc3RlbmVyKCBwb2ludFJlbW92ZWRMaXN0ZW5lciApO1xyXG5cclxuICAgIGlmICggb3B0aW9ucy5jb25uZWN0b3JMaW5lVmlzaWJsZVByb3BlcnR5ICE9PSBBTFdBWVNfVFJVRV9QUk9QRVJUWSApIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggb3B0aW9ucy5jb25uZWN0b3JMaW5lLCAnbXVzdCBoYXZlIGNvbm5lY3RvciBsaW5lIHR1cm5lZCBvbiBmb3IgdGhlIHZpeiBQcm9wZXJ0eSB0byBtYWtlIHNlbnNlJyApO1xyXG4gICAgICBvcHRpb25zLmNvbm5lY3RvckxpbmVWaXNpYmxlUHJvcGVydHkubGluayggdXBkYXRlQ29ubmVjdG9yTGluZVZpc2liaWxpdHkgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVQb2ludENvbnRyb2xsZXJTY2FsZUNoYW5nZSA9IHNjYWxlID0+IHtcclxuICAgICAgdGhpcy5kcmFnZ2FibGVOb2RlLnNldFNjYWxlTWFnbml0dWRlKCBzY2FsZSApO1xyXG4gICAgfTtcclxuICAgIHBvaW50Q29udHJvbGxlci5zY2FsZVByb3BlcnR5LmxpbmsoIGhhbmRsZVBvaW50Q29udHJvbGxlclNjYWxlQ2hhbmdlICk7XHJcblxyXG4gICAgLy8gUG9wIHRvIHRoZSBmcm9udCBvZiB0aGUgei1vcmRlciB3aGVuIGRyYWdnZWQuXHJcbiAgICBjb25zdCBkcmFnU3RhdGVDaGFuZ2VIYW5kbGVyID0gZHJhZ2dpbmcgPT4ge1xyXG4gICAgICBpZiAoIGRyYWdnaW5nICkge1xyXG4gICAgICAgIHRoaXMubW92ZVRvRnJvbnQoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHBvaW50Q29udHJvbGxlci5pc0RyYWdnaW5nUHJvcGVydHkubGluayggZHJhZ1N0YXRlQ2hhbmdlSGFuZGxlciApO1xyXG5cclxuICAgIC8vIERvbid0IGFsbG93IHRoZSBwb2ludCBjb250cm9sbGVyIG5vZGUgdG8gYmUgZ3JhYmJlZCBpZiBpdCBpcyBhbmltYXRpbmcgc29tZXdoZXJlLlxyXG4gICAgY29uc3QgaW5Qcm9ncmVzc0FuaW1hdGlvbkNoYW5nZWRIYW5kbGVyID0gaW5Qcm9ncmVzc0FuaW1hdGlvbiA9PiB7XHJcbiAgICAgIHRoaXMucGlja2FibGUgPSBpblByb2dyZXNzQW5pbWF0aW9uID09PSBudWxsO1xyXG4gICAgfTtcclxuICAgIHBvaW50Q29udHJvbGxlci5pblByb2dyZXNzQW5pbWF0aW9uUHJvcGVydHkubGluayggaW5Qcm9ncmVzc0FuaW1hdGlvbkNoYW5nZWRIYW5kbGVyICk7XHJcblxyXG4gICAgLy8gZHJhZyBoYW5kbGVyIGlmIGludGVuZGVkIHRvIGJlIGRyYWdnZWRcclxuICAgIGlmICggb3B0aW9ucy5waWNrYWJsZSAhPT0gZmFsc2UgKSB7XHJcbiAgICAgIGxldCBwb2ludE9mZnNldDtcclxuICAgICAgdGhpcy5hZGRJbnB1dExpc3RlbmVyKCBuZXcgRHJhZ0xpc3RlbmVyKCB7XHJcblxyXG4gICAgICAgIGRyYWdCb3VuZHNQcm9wZXJ0eTogbmV3IFByb3BlcnR5KCB0aGlzLmxheW91dEJvdW5kcyApLFxyXG5cclxuICAgICAgICBzdGFydDogZXZlbnQgPT4ge1xyXG4gICAgICAgICAgcG9pbnRDb250cm9sbGVyLmlzRHJhZ2dpbmdQcm9wZXJ0eS52YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuZHJhZ2dhYmxlTm9kZS5nbG9iYWxUb1BhcmVudFBvaW50KCBldmVudC5wb2ludGVyLnBvaW50ICk7IC8vIHBvaW50ZXIgaW4gcGFyZW50IGZyYW1lXHJcbiAgICAgICAgICBjb25zdCByZWxhdGl2ZVBvaW50ID0gcG9pbnQubWludXMoIHRoaXMuZHJhZ2dhYmxlTm9kZSApOyAvLyBwb2ludGVyIGluIGxvY2FsIGZyYW1lXHJcbiAgICAgICAgICBjb25zdCBzdGFydGluZ09mZnNldCA9IHJlbGF0aXZlUG9pbnRcclxuICAgICAgICAgICAgLmRpdmlkZWRTY2FsYXIoIHBvaW50Q29udHJvbGxlci5zY2FsZVByb3BlcnR5LnZhbHVlIClcclxuICAgICAgICAgICAgLm1pbnVzKCByZWxhdGl2ZVBvaW50ICk7IC8vIGlmIG5vZGUgaGFzIGEgc2NhbGUsIGZpbmQgb2Zmc2V0IG9mIG5vZGUgYWZ0ZXIgaXQgaXMgc2V0IHRvIDEuMCBzY2FsZVxyXG4gICAgICAgICAgcG9pbnRDb250cm9sbGVyLnNjYWxlUHJvcGVydHkudmFsdWUgPSAxLjA7XHJcbiAgICAgICAgICBwb2ludENvbnRyb2xsZXIucHJvcG9zZVBvc2l0aW9uKFxyXG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZU5vZGUudHJhbnNsYXRpb24ubWludXMoIHN0YXJ0aW5nT2Zmc2V0ICkgLy8gaWYgbm9kZSBoYWQgc2NhbGUsIG1vdmUgaXQgdG8gd2hlcmUgcG9pbnRlciBjbGlja2VkXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgcG9pbnRPZmZzZXQgPSBwb2ludC5taW51cyggdGhpcy5kcmFnZ2FibGVOb2RlICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZHJhZzogZXZlbnQgPT4ge1xyXG4gICAgICAgICAgcG9pbnRDb250cm9sbGVyLmlzRHJhZ2dpbmdQcm9wZXJ0eS52YWx1ZSA9IHRydWU7IC8vIG5lY2Vzc2FyeSBpbiBjYXNlIGlzRHJhZ2dpbmdQcm9wZXJ0eSBpcyBjaGFuZ2VkIHdoaWxlIGRyYWdnaW5nXHJcbiAgICAgICAgICBjb25zdCBwYXJlbnRQb2ludCA9IHRoaXMuZ2xvYmFsVG9QYXJlbnRQb2ludCggZXZlbnQucG9pbnRlci5wb2ludCApO1xyXG4gICAgICAgICAgcG9pbnRDb250cm9sbGVyLnByb3Bvc2VQb3NpdGlvbiggcGFyZW50UG9pbnQubWludXMoIHBvaW50T2Zmc2V0ICkgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlbmQ6ICgpID0+IHtcclxuICAgICAgICAgIHBvaW50Q29udHJvbGxlci5pc0RyYWdnaW5nUHJvcGVydHkudmFsdWUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gKSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSBkZWZhdWx0IHBvaW50IGNvbnRyb2xsZXIgbm9kZSBpcyBiZWluZyB1c2VkLCBjcmVhdGUgYW5kIGhvb2sgdXAgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCB1cGRhdGUgdG91Y2hcclxuICAgIC8vIGFyZWFzIGFzIHRoZSBvcmllbnRhdGlvbiBjaGFuZ2VzIHNvIHRoYXQgdGhlIHBvaW50IGNvbnRyb2xsZXJzIGNhbiBiZSBlYXNpbHkgZ3JhYmJlZCBieSBhIHVzZXIncyBmaW5nZXIgd2l0aG91dFxyXG4gICAgLy8gY292ZXJpbmcgdGhlbSB1cC5cclxuICAgIGxldCBzZXRUb3VjaERpbGF0aW9uQmFzZWRPbk9yaWVudGF0aW9uO1xyXG4gICAgaWYgKCAhb3B0aW9ucy5ub2RlICkge1xyXG4gICAgICBzZXRUb3VjaERpbGF0aW9uQmFzZWRPbk9yaWVudGF0aW9uID0gb3JpZW50YXRpb24gPT4ge1xyXG4gICAgICAgIGNvbnN0IG5vbWluYWxCb3VuZHMgPSB0aGlzLmRyYWdnYWJsZU5vZGUubG9jYWxCb3VuZHM7XHJcbiAgICAgICAgbGV0IHRvdWNoQXJlYUJvdW5kcztcclxuICAgICAgICBpZiAoIG9yaWVudGF0aW9uID09PSBPcmllbnRhdGlvbi5IT1JJWk9OVEFMICkge1xyXG4gICAgICAgICAgY29uc3QgZGlsYXRlZEJvdW5kcyA9IG5vbWluYWxCb3VuZHMuZGlsYXRlWFkoIFNQSEVSRV9SQURJVVMgLyAyLCBTUEhFUkVfUkFESVVTICogMiApO1xyXG4gICAgICAgICAgdG91Y2hBcmVhQm91bmRzID0gZGlsYXRlZEJvdW5kcy5zaGlmdGVkWSggU1BIRVJFX1JBRElVUyAqIDEuNSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IGRpbGF0ZWRCb3VuZHMgPSBub21pbmFsQm91bmRzLmRpbGF0ZVhZKCBTUEhFUkVfUkFESVVTICogMiwgU1BIRVJFX1JBRElVUyAvIDIgKTtcclxuICAgICAgICAgIHRvdWNoQXJlYUJvdW5kcyA9IGRpbGF0ZWRCb3VuZHMuc2hpZnRlZFgoIFNQSEVSRV9SQURJVVMgKiAxLjUgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kcmFnZ2FibGVOb2RlLnNldFRvdWNoQXJlYSggdG91Y2hBcmVhQm91bmRzICk7XHJcbiAgICAgIH07XHJcbiAgICAgIHBvaW50Q29udHJvbGxlci5udW1iZXJMaW5lc1sgMCBdLm9yaWVudGF0aW9uUHJvcGVydHkubGluayggc2V0VG91Y2hEaWxhdGlvbkJhc2VkT25PcmllbnRhdGlvbiApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBwcml2YXRlXHJcbiAgICB0aGlzLmRpc3Bvc2VQb2ludENvbnRyb2xsZXJOb2RlID0gKCkgPT4ge1xyXG4gICAgICBwb2ludENvbnRyb2xsZXIucG9zaXRpb25Qcm9wZXJ0eS51bmxpbmsoIHVwZGF0ZUFwcGVhcmFuY2VPblBvc2l0aW9uQ2hhbmdlICk7XHJcbiAgICAgIHBvaW50Q29udHJvbGxlci5pc0RyYWdnaW5nUHJvcGVydHkudW5saW5rKCBkcmFnU3RhdGVDaGFuZ2VIYW5kbGVyICk7XHJcbiAgICAgIHBvaW50Q29udHJvbGxlci5pblByb2dyZXNzQW5pbWF0aW9uUHJvcGVydHkudW5saW5rKCBpblByb2dyZXNzQW5pbWF0aW9uQ2hhbmdlZEhhbmRsZXIgKTtcclxuICAgICAgaWYgKCBvcHRpb25zLmNvbm5lY3RvckxpbmVWaXNpYmxlUHJvcGVydHkuaGFzTGlzdGVuZXIoIHVwZGF0ZUNvbm5lY3RvckxpbmVWaXNpYmlsaXR5ICkgKSB7XHJcbiAgICAgICAgb3B0aW9ucy5jb25uZWN0b3JMaW5lVmlzaWJsZVByb3BlcnR5LnVubGluayggdXBkYXRlQ29ubmVjdG9yTGluZVZpc2liaWxpdHkgKTtcclxuICAgICAgfVxyXG4gICAgICBwb2ludENvbnRyb2xsZXIubnVtYmVyTGluZXMuZm9yRWFjaCggbnVtYmVyTGluZSA9PiB7XHJcbiAgICAgICAgaWYgKCBudW1iZXJMaW5lLmRpc3BsYXllZFJhbmdlUHJvcGVydHkuaGFzTGlzdGVuZXIoIHVwZGF0ZVBvaW50Q29udHJvbGxlclZpc2liaWxpdHkgKSApIHtcclxuICAgICAgICAgIG51bWJlckxpbmUuZGlzcGxheWVkUmFuZ2VQcm9wZXJ0eS51bmxpbmsoIHVwZGF0ZVBvaW50Q29udHJvbGxlclZpc2liaWxpdHkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBudW1iZXJMaW5lLm9yaWVudGF0aW9uUHJvcGVydHkuaGFzTGlzdGVuZXIoIHNldFRvdWNoRGlsYXRpb25CYXNlZE9uT3JpZW50YXRpb24gKSApIHtcclxuICAgICAgICAgIG51bWJlckxpbmUub3JpZW50YXRpb25Qcm9wZXJ0eS51bmxpbmsoIHNldFRvdWNoRGlsYXRpb25CYXNlZE9uT3JpZW50YXRpb24gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gKTtcclxuICAgICAgcG9pbnRDb250cm9sbGVyLm51bWJlckxpbmVQb2ludHMucmVtb3ZlSXRlbUFkZGVkTGlzdGVuZXIoIHBvaW50QWRkZWRMaXN0ZW5lciApO1xyXG4gICAgICBwb2ludENvbnRyb2xsZXIubnVtYmVyTGluZVBvaW50cy5yZW1vdmVJdGVtUmVtb3ZlZExpc3RlbmVyKCBwb2ludFJlbW92ZWRMaXN0ZW5lciApO1xyXG4gICAgICBwb2ludENvbnRyb2xsZXIubnVtYmVyTGluZVBvaW50cy5mb3JFYWNoKCBudW1iZXJMaW5lUG9pbnQgPT4ge1xyXG4gICAgICAgIG51bWJlckxpbmVQb2ludC52YWx1ZVByb3BlcnR5LnVubGluayggbW92ZVRvRnJvbnQgKTtcclxuICAgICAgfSApO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFuIHVwIGFueSBsaW5rYWdlcyBvciBvdGhlciByZWZlcmVuY2VzIHRoYXQgY291bGQgbGVhZCB0byBtZW1vcnkgbGVha3MuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLmludGVycnVwdFN1YnRyZWVJbnB1dCgpOyAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIGluLXByb2dyZXNzIGludGVyYWN0aW9ucywgc2VlICMxMDYuXHJcbiAgICB0aGlzLmRpc3Bvc2VQb2ludENvbnRyb2xsZXJOb2RlKCk7XHJcbiAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG59XHJcblxyXG5udW1iZXJMaW5lQ29tbW9uLnJlZ2lzdGVyKCAnUG9pbnRDb250cm9sbGVyTm9kZScsIFBvaW50Q29udHJvbGxlck5vZGUgKTtcclxuZXhwb3J0IGRlZmF1bHQgUG9pbnRDb250cm9sbGVyTm9kZTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsZUFBZSxNQUFNLHdDQUF3QztBQUNwRSxPQUFPQyxRQUFRLE1BQU0saUNBQWlDO0FBQ3RELE9BQU9DLGdCQUFnQixNQUFNLG9FQUFvRTtBQUNqRyxPQUFPQyxLQUFLLE1BQU0sbUNBQW1DO0FBQ3JELE9BQU9DLFdBQVcsTUFBTSx5Q0FBeUM7QUFDakUsT0FBT0MsZ0JBQWdCLE1BQU0saURBQWlEO0FBQzlFLFNBQVNDLFlBQVksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLFFBQVEsbUNBQW1DO0FBQzVFLE9BQU9DLGdCQUFnQixNQUFNLDJCQUEyQjs7QUFFeEQ7QUFDQSxNQUFNQyxhQUFhLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDMUIsTUFBTUMsb0JBQW9CLEdBQUcsSUFBSVgsZUFBZSxDQUFFLElBQUssQ0FBQztBQUV4RCxNQUFNWSxtQkFBbUIsU0FBU0osSUFBSSxDQUFDO0VBRXJDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRUssV0FBV0EsQ0FBRUMsZUFBZSxFQUFFQyxPQUFPLEVBQUc7SUFFdENBLE9BQU8sR0FBR1osS0FBSyxDQUFFO01BRWY7TUFDQTtNQUNBO01BQ0FhLElBQUksRUFBRSxJQUFJO01BRVY7TUFDQUMsYUFBYSxFQUFFLElBQUk7TUFFbkI7TUFDQTtNQUNBQyw0QkFBNEIsRUFBRVAsb0JBQW9CO01BRWxEUSxNQUFNLEVBQUU7SUFFVixDQUFDLEVBQUVKLE9BQVEsQ0FBQztJQUVaLEtBQUssQ0FBRUEsT0FBUSxDQUFDOztJQUVoQjtJQUNBLE1BQU1FLGFBQWEsR0FBRyxJQUFJVixJQUFJLENBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFO01BQUVhLE1BQU0sRUFBRTtJQUFPLENBQUUsQ0FBQztJQUNoRUgsYUFBYSxDQUFDSSxPQUFP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