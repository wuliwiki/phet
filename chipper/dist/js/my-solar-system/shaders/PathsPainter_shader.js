/* eslint-disable */
export default "precision mediump float;\nvarying vec2 vPosition;\nuniform mat3 uMatrixInverse;\nuniform sampler2D uData;\nuniform vec2 uTextureSize;\nuniform ivec4 uPathLength;\nuniform int uMaxPathLength;\nuniform int uActiveBodies;\nuniform mat4 uColorMatrix;\nuniform vec4 uBackgroundColor;\n\n// NOTE: This is best hardcoded as a constant (we could replace in JS if needed)\nconst int maxPathLength = 32 * 32 / 4;\n\nvec2 globalToModel( in vec2 modelPoint ) {\n  return ( uMatrixInverse * vec3( modelPoint, 1.0 ) ).xy;\n}\n\n// Given an index into our \"vec3 data array\", returns the vec3\nvec4 fetch( in int index ) {\n  vec2 coordinates = vec2( mod( float( index ), uTextureSize.x ), floor( float( index ) / uTextureSize.x ) );\n  return texture2D( uData, ( coordinates + 0.5 ) / uTextureSize );\n}\n\n// Signed distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n// For one body, calculate the path stroke in a specific modelPosition\nvec4 getStroke( in vec2 modelPosition, in int bodyIndex, in vec3 planetColor ) {\n\n  float radius = 3.0;\n  float minDistance = 100000.0;\n\n  vec2 lastPosition = vec2( 0.0 );\n\n\n  int bodyPathLength =  ( bodyIndex == 0 ) ? uPathLength.x :\n                        ( bodyIndex == 1 ) ? uPathLength.y :\n                        ( bodyIndex == 2 ) ? uPathLength.z :\n                        ( bodyIndex == 3 ) ? uPathLength.w : 0;\n\n  float inversePathLength = 1.0 / float( bodyPathLength + 1 );\n\n  for ( int vertexIndex = 0; vertexIndex < maxPathLength; vertexIndex++ ) {\n    if ( vertexIndex >= bodyPathLength ) {\n      break;\n    }\n    vec2 position = fetch( bodyIndex * uMaxPathLength + vertexIndex ).xy;\n\n    if ( vertexIndex > 0 ) {\n      float dist = sdSegment( modelPosition, lastPosition, position );\n\n      minDistance = min( minDistance, dist + ( 1.0 - float( vertexIndex ) * inversePathLength ) * radius );\n    }\n\n    lastPosition = position;\n  }\n  return vec4( planetColor, smoothstep( radius, radius - 2.0, minDistance ) );\n}\n\n// Returns the color from the vertex shader\nvoid main( void ) {\n  vec2 modelPosition = globalToModel( vPosition );\n  vec4 color = uBackgroundColor;\n\n  for ( int bodyIndex = 0 ; bodyIndex < 4 ; bodyIndex++ ) {\n    if ( bodyIndex < uActiveBodies ){\n      vec4 stroke = getStroke( modelPosition, bodyIndex, uColorMatrix[ bodyIndex ].xyz );\n\n      color.rgb = stroke.a * stroke.rgb + color.a * color.rgb * ( 1.0 - stroke.a );\n      color.a = stroke.a + color.a * ( 1.0 - stroke.a );\n    }\n  }\n  gl_FragColor = color;\n}";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUGF0aHNQYWludGVyX3NoYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG5leHBvcnQgZGVmYXVsdCBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnZhcnlpbmcgdmVjMiB2UG9zaXRpb247XFxudW5pZm9ybSBtYXQzIHVNYXRyaXhJbnZlcnNlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVEYXRhO1xcbnVuaWZvcm0gdmVjMiB1VGV4dHVyZVNpemU7XFxudW5pZm9ybSBpdmVjNCB1UGF0aExlbmd0aDtcXG51bmlmb3JtIGludCB1TWF4UGF0aExlbmd0aDtcXG51bmlmb3JtIGludCB1QWN0aXZlQm9kaWVzO1xcbnVuaWZvcm0gbWF0NCB1Q29sb3JNYXRyaXg7XFxudW5pZm9ybSB2ZWM0IHVCYWNrZ3JvdW5kQ29sb3I7XFxuXFxuLy8gTk9URTogVGhpcyBpcyBiZXN0IGhhcmRjb2RlZCBhcyBhIGNvbnN0YW50ICh3ZSBjb3VsZCByZXBsYWNlIGluIEpTIGlmIG5lZWRlZClcXG5jb25zdCBpbnQgbWF4UGF0aExlbmd0aCA9IDMyICogMzIgLyA0O1xcblxcbnZlYzIgZ2xvYmFsVG9Nb2RlbCggaW4gdmVjMiBtb2RlbFBvaW50ICkge1xcbiAgcmV0dXJuICggdU1hdHJpeEludmVyc2UgKiB2ZWMzKCBtb2RlbFBvaW50LCAxLjAgKSApLnh5O1xcbn1cXG5cXG4vLyBHaXZlbiBhbiBpbmRleCBpbnRvIG91ciBcXFwidmVjMyBkYXRhIGFycmF5XFxcIiwgcmV0dXJucyB0aGUgdmVjM1xcbnZlYzQgZmV0Y2goIGluIGludCBpbmRleCApIHtcXG4gIHZlYzIgY29vcmRpbmF0ZXMgPSB2ZWMyKCBtb2QoIGZsb2F0KCBpbmRleCApLCB1VGV4dHVyZVNpemUueCApLCBmbG9vciggZmxvYXQoIGluZGV4ICkgLyB1VGV4dHVyZVNpemUueCApICk7XFxuICByZXR1cm4gdGV4dHVyZTJEKCB1RGF0YSwgKCBjb29yZGluYXRlcyArIDAuNSApIC8gdVRleHR1cmVTaXplICk7XFxufVxcblxcbi8vIFNpZ25lZCBkaXN0YW5jZSB0byBhIGxpbmUgc2VnbWVudFxcbmZsb2F0IHNkU2VnbWVudCggaW4gdmVjMiBwLCBpbiB2ZWMyIGEsIGluIHZlYzIgYiApIHtcXG4gIHZlYzIgcGEgPSBwLWEsIGJhID0gYi1hO1xcbiAgZmxvYXQgaCA9IGNsYW1wKCBkb3QocGEsYmEpL2RvdChiYSxiYSksIDAuMCwgMS4wICk7XFxuICByZXR1cm4gbGVuZ3RoKCBwYSAtIGJhKmggKTtcXG59XFxuXFxuLy8gRm9yIG9uZSBib2R5LCBjYWxjdWxhdGUgdGhlIHBhdGggc3Ryb2tlIGluIGEgc3BlY2lmaWMgbW9kZWxQb3NpdGlvblxcbnZlYzQgZ2V0U3Ryb2tlKCBpbiB2ZWMyIG1vZGVsUG9zaXRpb24sIGluIGludCBib2R5SW5kZXgsIGluIHZlYzMgcGxhbmV0Q29sb3IgKSB7XFxuXFxuICBmbG9hdCByYWRpdXMgPSAzLjA7XFxuICBmbG9hdCBtaW5EaXN0YW5jZSA9IDEwMDAwMC4wO1xcblxcbiAgdmVjMiBsYXN0UG9zaXRpb24gPSB2ZWMyKCAwLjAgKTtcXG5cXG5cXG4gIGludCBib2R5UGF0aExlbmd0aCA9ICAoIGJvZHlJbmRleCA9PSAwICkgPyB1UGF0aExlbmd0aC54IDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGJvZHlJbmRleCA9PSAxICkgPyB1UGF0aExlbmd0aC55IDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGJvZHlJbmRleCA9PSAyICkgPyB1UGF0aExlbmd0aC56IDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGJvZHlJbmRleCA9PSAzICkgPyB1UGF0aExlbmd0aC53IDogMDtcXG5cXG4gIGZsb2F0IGludmVyc2VQYXRoTGVuZ3RoID0gMS4wIC8gZmxvYXQoIGJvZHlQYXRoTGVuZ3RoICsgMSApO1xcblxcbiAgZm9yICggaW50IHZlcnRleEluZGV4ID0gMDsgdmVydGV4SW5kZXggPCBtYXhQYXRoTGVuZ3RoOyB2ZXJ0ZXhJbmRleCsrICkge1xcbiAgICBpZiAoIHZlcnRleEluZGV4ID49IGJvZHlQYXRoTGVuZ3RoICkge1xcbiAgICAgIGJyZWFrO1xcbiAgICB9XFxuICAgIHZlYzIgcG9zaXRpb24gPSBmZXRjaCggYm9keUluZGV4ICogdU1heFBhdGhMZW5ndGggKyB2ZXJ0ZXhJbmRleCApLnh5O1xcblxcbiAgICBpZiAoIHZlcnRleEluZGV4ID4gMCApIHtcXG4gICAgICBmbG9hdCBkaXN0ID0gc2RTZWdtZW50KCBtb2RlbFBvc2l0aW9uLCBsYXN0UG9zaXRpb24sIHBvc2l0aW9uICk7XFxuXFxuICAgICAgbWluRGlzdGFuY2UgPSBtaW4oIG1pbkRpc3RhbmNlLCBkaXN0ICsgKCAxLjAgLSBmbG9hdCggdmVydGV4SW5kZXggKSAqIGludmVyc2VQYXRoTGVuZ3RoICkgKiByYWRpdXMgKTtcXG4gICAgfVxcblxcbiAgICBsYXN0UG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gIH1cXG4gIHJldHVybiB2ZWM0KCBwbGFuZXRDb2xvciwgc21vb3Roc3RlcCggcmFkaXVzLCByYWRpdXMgLSAyLjAsIG1pbkRpc3RhbmNlICkgKTtcXG59XFxuXFxuLy8gUmV0dXJucyB0aGUgY29sb3IgZnJvbSB0aGUgdmVydGV4IHNoYWRlclxcbnZvaWQgbWFpbiggdm9pZCApIHtcXG4gIHZlYzIgbW9kZWxQb3NpdGlvbiA9IGdsb2JhbFRvTW9kZWwoIHZQb3NpdGlvbiApO1xcbiAgdmVjNCBjb2xvciA9IHVCYWNrZ3JvdW5kQ29sb3I7XFxuXFxuICBmb3IgKCBpbnQgYm9keUluZGV4ID0gMCA7IGJvZHlJbmRleCA8IDQgOyBib2R5SW5kZXgrKyApIHtcXG4gICAgaWYgKCBib2R5SW5kZXggPCB1QWN0aXZlQm9kaWVzICl7XFxuICAgICAgdmVjNCBzdHJva2UgPSBnZXRTdHJva2UoIG1vZGVsUG9zaXRpb24sIGJvZHlJbmRleCwgdUNvbG9yTWF0cml4WyBib2R5SW5kZXggXS54eXogKTtcXG5cXG4gICAgICBjb2xvci5yZ2IgPSBzdHJva2UuYSAqIHN0cm9rZS5yZ2IgKyBjb2xvci5hICogY29sb3IucmdiICogKCAxLjAgLSBzdHJva2UuYSApO1xcbiAgICAgIGNvbG9yLmEgPSBzdHJva2UuYSArIGNvbG9yLmEgKiAoIDEuMCAtIHN0cm9rZS5hICk7XFxuICAgIH1cXG4gIH1cXG4gIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxlQUFlLDZtRkFBNm1GIn0=