// Copyright 2018-2022, University of Colorado Boulder

/**
 * Challenge generator for game level 1.
 * See specification in https://docs.google.com/document/d/1vG5U9HhcqVGMvmGGXry28PLqlNWj25lStDP2vSWgUOo/edit.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import dotRandom from '../../../../dot/js/dotRandom.js';
import optionize from '../../../../phet-core/js/optionize.js';
import Fraction from '../../../../phetcommon/js/model/Fraction.js';
import StringUtils from '../../../../phetcommon/js/util/StringUtils.js';
import equalityExplorer from '../../equalityExplorer.js';
import Challenge from './Challenge.js';
import ChallengeGenerator from './ChallengeGenerator.js';

// strings (debug)
const PATTERN1 = 'type 1, ax = c<br>' + 'x = {{x}}<br>' + 'a = {{a}}<br>' + 'c = a * x = {{c}}';
const PATTERN2 = 'type 2, x + b = c<br>' + 'x = {{x}}<br>' + 'b = {{b}}<br>' + 'c = x + b = {{c}}';
const PATTERN3 = 'type 3, x/d = c<br>' + 'c = {{c}}<br>' + 'd = {{d}}<br>' + 'x = c * d = {{x}} ';

// constants
const MAX_ATTEMPTS = 50; // max attempts in a while loop

export default class ChallengeGenerator1 extends ChallengeGenerator {
  // methods for generating the 3 types of challenges

  constructor(providedOptions) {
    const options = optionize()({
      // SelfOptions
      aValues: ChallengeGenerator.rangeToArray(2, 10),
      dValues: ChallengeGenerator.rangeToArray(2, 10)
    }, providedOptions);
    super();
    this.xValues = ChallengeGenerator.rangeToArray(-40, 40);
    this.aValues = options.aValues;
    this.bValues = ChallengeGenerator.rangeToArray(-10, 10);
    this.cValues = ChallengeGenerator.rangeToArray(-10, 10);
    this.dValues = options.dValues;
    this.challengeTypeMethods = [() => this.nextType1(), () => this.nextType2(), () => this.nextType3()];
  }

  /**
   * Generates the next challenge.
   */
  nextChallengeProtected() {
    if (this.numberOfChallenges < 3) {
      // For the first 3 challenges, generate 1 of each type, in order.
      return this.challengeTypeMethods[this.numberOfChallenges]();
    } else {
      // After the first 3 challenges, randomly select the challenge type.
      return dotRandom.sample(this.challengeTypeMethods)();
    }
  }

  /**
   * Generates the next 'type 1' challenge.
   *
   * Form: ax = c
   * Let x be a random integer between [-40,40], x !== 0
   * Let a be a random integer between [-10, 10], a !== [0, 1]
   * Let c = a*x, c !== 0
   *
   * @param [a] - if you'd like to use a specific value of a, otherwise randomly selected
   */
  nextType1(a) {
    const x = this.randomX(this.xValues);
    a = a !== undefined ? a : ChallengeGenerator.randomValue(this.aValues, [0, 1]);
    const c = a * x;

    // Verify that computations meeting design requirements.
    assert && assert(x !== 0, 'x is 0');
    assert && assert(a !== 0, 'a is 0');
    assert && assert(c !== 0, 'c is 0');

    // derivation that corresponds to design doc, displayed with 'showAnswers' query parameter
    const debugDerivation = StringUtils.fillIn(PATTERN1, {
      x: x,
      a: a,
      c: c
    });

    // ax + 0 = 0x + c
    return new Challenge(x, Fraction.fromInteger(a), Fraction.fromInteger(0), Fraction.fromInteger(0), Fraction.fromInteger(c), debugDerivation);
  }

  /**
   * Generates the next 'type 2' challenge.
   *
   * Form: x + b = c
   * Let x be a random integer between [-40,40], x !== 0
   * Let b be a random integer between [-10, 10], b !== 0
   * Let c = x + b, c == 0 is OK
   */
  nextType2() {
    const x = this.randomX(this.xValues);
    const b = ChallengeGenerator.randomValue(this.bValues, [0]);
    const c = x + b;

    // Verify that computations meeting design requirements.
    assert && assert(x !== 0, 'x is 0');
    assert && assert(b !== 0, 'b is 0');

    // derivation that corresponds to design doc, displayed with 'showAnswers' query parameter
    const debugDerivation = StringUtils.fillIn(PATTERN2, {
      x: x,
      b: b,
      c: c
    });

    // 1x + b = 0x + c
    return new Challenge(x, Fraction.fromInteger(1), Fraction.fromInteger(b), Fraction.fromInteger(0), Fraction.fromInteger(c), debugDerivation);
  }

  /**
   * Generates the next 'type 3' challenge.
   *
   * Form: x/d = c
   * Let c be a random integer between [-10,10], c !== 0
   * Let d be a random integer between [-10, 10], d !== [0, 1]
   * Let x = c * d, x !== 0
   */
  nextType3() {
    let x = this.xPrevious;
    let c = 0;
    let d = 0;
    let attempts = 0; // to prevent an improbable infinite while loop
    while (x === this.xPrevious && attempts < MAX_ATTEMPTS) {
      attempts++;
      c = ChallengeGenerator.randomValue(this.cValues, [0]);
      d = ChallengeGenerator.randomValue(this.dValues, [0, 1]);
      x = c * d;
    }

    // Verify that computations meeting design requirements.
    assert && assert(c !== 0, 'c is 0');
    assert && assert(d !== 0, 'd is 0');
    assert && assert(d !== 1, 'd is 1');
    assert && assert(x !== 0, 'x is 0');
    assert && assert(x !== this.xPrevious || attempts === MAX_ATTEMPTS, `x === xPrevious: ${x}`);
    this.xPrevious = x;

    // derivation that corresponds to design doc, displayed with 'showAnswers' query parameter
    const debugDerivation = StringUtils.fillIn(PATTERN3, {
      x: x,
      c: c,
      d: d
    });

    // (1/d)x + 0 = 0x + c
    return new Challenge(x, new Fraction(1, d), Fraction.fromInteger(0), Fraction.fromInteger(0), Fraction.fromInteger(c), debugDerivation);
  }
}
equalityExplorer.register('ChallengeGenerator1', ChallengeGenerator1);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3RSYW5kb20iLCJvcHRpb25pemUiLCJGcmFjdGlvbiIsIlN0cmluZ1V0aWxzIiwiZXF1YWxpdHlFeHBsb3JlciIsIkNoYWxsZW5nZSIsIkNoYWxsZW5nZUdlbmVyYXRvciIsIlBBVFRFUk4xIiwiUEFUVEVSTjIiLCJQQVRURVJOMyIsIk1BWF9BVFRFTVBUUyIsIkNoYWxsZW5nZUdlbmVyYXRvcjEiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJhVmFsdWVzIiwicmFuZ2VUb0FycmF5IiwiZFZhbHVlcyIsInhWYWx1ZXMiLCJiVmFsdWVzIiwiY1ZhbHVlcyIsImNoYWxsZW5nZVR5cGVNZXRob2RzIiwibmV4dFR5cGUxIiwibmV4dFR5cGUyIiwibmV4dFR5cGUzIiwibmV4dENoYWxsZW5nZVByb3RlY3RlZCIsIm51bWJlck9mQ2hhbGxlbmdlcyIsInNhbXBsZSIsImEiLCJ4IiwicmFuZG9tWCIsInVuZGVmaW5lZCIsInJhbmRvbVZhbHVlIiwiYyIsImFzc2VydCIsImRlYnVnRGVyaXZhdGlvbiIsImZpbGxJbiIsImZyb21JbnRlZ2VyIiwiYiIsInhQcmV2aW91cyIsImQiLCJhdHRlbXB0cyIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQ2hhbGxlbmdlR2VuZXJhdG9yMS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBDaGFsbGVuZ2UgZ2VuZXJhdG9yIGZvciBnYW1lIGxldmVsIDEuXHJcbiAqIFNlZSBzcGVjaWZpY2F0aW9uIGluIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMXZHNVU5SGhjcVZHTXZtR0dYcnkyOFBMcWxOV2oyNWxTdERQMnZTV2dVT28vZWRpdC5cclxuICpcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgZG90UmFuZG9tIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9kb3RSYW5kb20uanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgRnJhY3Rpb24gZnJvbSAnLi4vLi4vLi4vLi4vcGhldGNvbW1vbi9qcy9tb2RlbC9GcmFjdGlvbi5qcyc7XHJcbmltcG9ydCBTdHJpbmdVdGlscyBmcm9tICcuLi8uLi8uLi8uLi9waGV0Y29tbW9uL2pzL3V0aWwvU3RyaW5nVXRpbHMuanMnO1xyXG5pbXBvcnQgZXF1YWxpdHlFeHBsb3JlciBmcm9tICcuLi8uLi9lcXVhbGl0eUV4cGxvcmVyLmpzJztcclxuaW1wb3J0IENoYWxsZW5nZSBmcm9tICcuL0NoYWxsZW5nZS5qcyc7XHJcbmltcG9ydCBDaGFsbGVuZ2VHZW5lcmF0b3IgZnJvbSAnLi9DaGFsbGVuZ2VHZW5lcmF0b3IuanMnO1xyXG5cclxuLy8gc3RyaW5ncyAoZGVidWcpXHJcbmNvbnN0IFBBVFRFUk4xID0gJ3R5cGUgMSwgYXggPSBjPGJyPicgK1xyXG4gICAgICAgICAgICAgICAgICd4ID0ge3t4fX08YnI+JyArXHJcbiAgICAgICAgICAgICAgICAgJ2EgPSB7e2F9fTxicj4nICtcclxuICAgICAgICAgICAgICAgICAnYyA9IGEgKiB4ID0ge3tjfX0nO1xyXG5jb25zdCBQQVRURVJOMiA9ICd0eXBlIDIsIHggKyBiID0gYzxicj4nICtcclxuICAgICAgICAgICAgICAgICAneCA9IHt7eH19PGJyPicgK1xyXG4gICAgICAgICAgICAgICAgICdiID0ge3tifX08YnI+JyArXHJcbiAgICAgICAgICAgICAgICAgJ2MgPSB4ICsgYiA9IHt7Y319JztcclxuY29uc3QgUEFUVEVSTjMgPSAndHlwZSAzLCB4L2QgPSBjPGJyPicgK1xyXG4gICAgICAgICAgICAgICAgICdjID0ge3tjfX08YnI+JyArXHJcbiAgICAgICAgICAgICAgICAgJ2QgPSB7e2R9fTxicj4nICtcclxuICAgICAgICAgICAgICAgICAneCA9IGMgKiBkID0ge3t4fX0gJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBNQVhfQVRURU1QVFMgPSA1MDsgLy8gbWF4IGF0dGVtcHRzIGluIGEgd2hpbGUgbG9vcFxyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuXHJcbiAgLy8gVGhlc2Ugc2V0cyBvZiB2YWx1ZXMgYXJlIGRpZmZlcmVudCBmb3IgTGV2ZWwgMiwgc28gYXJlIHByb3ZpZGVkIGFzIG9wdGlvbnMuXHJcbiAgYVZhbHVlcz86IG51bWJlcltdO1xyXG4gIGRWYWx1ZXM/OiBudW1iZXJbXTtcclxufTtcclxuXHJcbnR5cGUgQ2hhbGxlbmdlR2VuZXJhdG9yMU9wdGlvbnMgPSBTZWxmT3B0aW9ucztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYWxsZW5nZUdlbmVyYXRvcjEgZXh0ZW5kcyBDaGFsbGVuZ2VHZW5lcmF0b3Ige1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IHhWYWx1ZXM6IG51bWJlcltdO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgYVZhbHVlczogbnVtYmVyW107XHJcbiAgcHJpdmF0ZSByZWFkb25seSBiVmFsdWVzOiBudW1iZXJbXTtcclxuICBwcml2YXRlIHJlYWRvbmx5IGNWYWx1ZXM6IG51bWJlcltdO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgZFZhbHVlczogbnVtYmVyW107XHJcblxyXG4gIC8vIG1ldGhvZHMgZm9yIGdlbmVyYXRpbmcgdGhlIDMgdHlwZXMgb2YgY2hhbGxlbmdlc1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgY2hhbGxlbmdlVHlwZU1ldGhvZHM6ICggKCkgPT4gQ2hhbGxlbmdlIClbXTtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBwcm92aWRlZE9wdGlvbnM/OiBDaGFsbGVuZ2VHZW5lcmF0b3IxT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPENoYWxsZW5nZUdlbmVyYXRvcjFPcHRpb25zLCBTZWxmT3B0aW9ucz4oKSgge1xyXG5cclxuICAgICAgLy8gU2VsZk9wdGlvbnNcclxuICAgICAgYVZhbHVlczogQ2hhbGxlbmdlR2VuZXJhdG9yLnJhbmdlVG9BcnJheSggMiwgMTAgKSxcclxuICAgICAgZFZhbHVlczogQ2hhbGxlbmdlR2VuZXJhdG9yLnJhbmdlVG9BcnJheSggMiwgMTAgKVxyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLnhWYWx1ZXMgPSBDaGFsbGVuZ2VHZW5lcmF0b3IucmFuZ2VUb0FycmF5KCAtNDAsIDQwICk7XHJcbiAgICB0aGlzLmFWYWx1ZXMgPSBvcHRpb25zLmFWYWx1ZXM7XHJcbiAgICB0aGlzLmJWYWx1ZXMgPSBDaGFsbGVuZ2VHZW5lcmF0b3IucmFuZ2VUb0FycmF5KCAtMTAsIDEwICk7XHJcbiAgICB0aGlzLmNWYWx1ZXMgPSBDaGFsbGVuZ2VHZW5lcmF0b3IucmFuZ2VUb0FycmF5KCAtMTAsIDEwICk7XHJcbiAgICB0aGlzLmRWYWx1ZXMgPSBvcHRpb25zLmRWYWx1ZXM7XHJcblxyXG4gICAgdGhpcy5jaGFsbGVuZ2VUeXBlTWV0aG9kcyA9IFtcclxuICAgICAgKCkgPT4gdGhpcy5uZXh0VHlwZTEoKSxcclxuICAgICAgKCkgPT4gdGhpcy5uZXh0VHlwZTIoKSxcclxuICAgICAgKCkgPT4gdGhpcy5uZXh0VHlwZTMoKVxyXG4gICAgXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyB0aGUgbmV4dCBjaGFsbGVuZ2UuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIG92ZXJyaWRlIG5leHRDaGFsbGVuZ2VQcm90ZWN0ZWQoKTogQ2hhbGxlbmdlIHtcclxuICAgIGlmICggdGhpcy5udW1iZXJPZkNoYWxsZW5nZXMgPCAzICkge1xyXG5cclxuICAgICAgLy8gRm9yIHRoZSBmaXJzdCAzIGNoYWxsZW5nZXMsIGdlbmVyYXRlIDEgb2YgZWFjaCB0eXBlLCBpbiBvcmRlci5cclxuICAgICAgcmV0dXJuIHRoaXMuY2hhbGxlbmdlVHlwZU1ldGhvZHNbIHRoaXMubnVtYmVyT2ZDaGFsbGVuZ2VzIF0oKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgLy8gQWZ0ZXIgdGhlIGZpcnN0IDMgY2hhbGxlbmdlcywgcmFuZG9tbHkgc2VsZWN0IHRoZSBjaGFsbGVuZ2UgdHlwZS5cclxuICAgICAgcmV0dXJuIGRvdFJhbmRvbS5zYW1wbGUoIHRoaXMuY2hhbGxlbmdlVHlwZU1ldGhvZHMgKSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIHRoZSBuZXh0ICd0eXBlIDEnIGNoYWxsZW5nZS5cclxuICAgKlxyXG4gICAqIEZvcm06IGF4ID0gY1xyXG4gICAqIExldCB4IGJlIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBbLTQwLDQwXSwgeCAhPT0gMFxyXG4gICAqIExldCBhIGJlIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBbLTEwLCAxMF0sIGEgIT09IFswLCAxXVxyXG4gICAqIExldCBjID0gYSp4LCBjICE9PSAwXHJcbiAgICpcclxuICAgKiBAcGFyYW0gW2FdIC0gaWYgeW91J2QgbGlrZSB0byB1c2UgYSBzcGVjaWZpYyB2YWx1ZSBvZiBhLCBvdGhlcndpc2UgcmFuZG9tbHkgc2VsZWN0ZWRcclxuICAgKi9cclxuICBwdWJsaWMgbmV4dFR5cGUxKCBhPzogbnVtYmVyICk6IENoYWxsZW5nZSB7XHJcblxyXG4gICAgY29uc3QgeCA9IHRoaXMucmFuZG9tWCggdGhpcy54VmFsdWVzICk7XHJcbiAgICBhID0gKCBhICE9PSB1bmRlZmluZWQgKSA/IGEgOiBDaGFsbGVuZ2VHZW5lcmF0b3IucmFuZG9tVmFsdWUoIHRoaXMuYVZhbHVlcywgWyAwLCAxIF0gKTtcclxuICAgIGNvbnN0IGMgPSBhICogeDtcclxuXHJcbiAgICAvLyBWZXJpZnkgdGhhdCBjb21wdXRhdGlvbnMgbWVldGluZyBkZXNpZ24gcmVxdWlyZW1lbnRzLlxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggeCAhPT0gMCwgJ3ggaXMgMCcgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGEgIT09IDAsICdhIGlzIDAnICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBjICE9PSAwLCAnYyBpcyAwJyApO1xyXG5cclxuICAgIC8vIGRlcml2YXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byBkZXNpZ24gZG9jLCBkaXNwbGF5ZWQgd2l0aCAnc2hvd0Fuc3dlcnMnIHF1ZXJ5IHBhcmFtZXRlclxyXG4gICAgY29uc3QgZGVidWdEZXJpdmF0aW9uID0gU3RyaW5nVXRpbHMuZmlsbEluKCBQQVRURVJOMSwgeyB4OiB4LCBhOiBhLCBjOiBjIH0gKTtcclxuXHJcbiAgICAvLyBheCArIDAgPSAweCArIGNcclxuICAgIHJldHVybiBuZXcgQ2hhbGxlbmdlKCB4LFxyXG4gICAgICBGcmFjdGlvbi5mcm9tSW50ZWdlciggYSApLCBGcmFjdGlvbi5mcm9tSW50ZWdlciggMCApLFxyXG4gICAgICBGcmFjdGlvbi5mcm9tSW50ZWdlciggMCApLCBGcmFjdGlvbi5mcm9tSW50ZWdlciggYyApLFxyXG4gICAgICBkZWJ1Z0Rlcml2YXRpb24gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyB0aGUgbmV4dCAndHlwZSAyJyBjaGFsbGVuZ2UuXHJcbiAgICpcclxuICAgKiBGb3JtOiB4ICsgYiA9IGNcclxuICAgKiBMZXQgeCBiZSBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gWy00MCw0MF0sIHggIT09IDBcclxuICAgKiBMZXQgYiBiZSBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gWy0xMCwgMTBdLCBiICE9PSAwXHJcbiAgICogTGV0IGMgPSB4ICsgYiwgYyA9PSAwIGlzIE9LXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIG5leHRUeXBlMigpOiBDaGFsbGVuZ2Uge1xyXG5cclxuICAgIGNvbnN0IHggPSB0aGlzLnJhbmRvbVgoIHRoaXMueFZhbHVlcyApO1xyXG4gICAgY29uc3QgYiA9IENoYWxsZW5nZUdlbmVyYXRvci5yYW5kb21WYWx1ZSggdGhpcy5iVmFsdWVzLCBbIDAgXSApO1xyXG4gICAgY29uc3QgYyA9IHggKyBiO1xyXG5cclxuICAgIC8vIFZlcmlmeSB0aGF0IGNvbXB1dGF0aW9ucyBtZWV0aW5nIGRlc2lnbiByZXF1aXJlbWVudHMuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB4ICE9PSAwLCAneCBpcyAwJyApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggYiAhPT0gMCwgJ2IgaXMgMCcgKTtcclxuXHJcbiAgICAvLyBkZXJpdmF0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gZGVzaWduIGRvYywgZGlzcGxheWVkIHdpdGggJ3Nob3dBbnN3ZXJzJyBxdWVyeSBwYXJhbWV0ZXJcclxuICAgIGNvbnN0IGRlYnVnRGVyaXZhdGlvbiA9IFN0cmluZ1V0aWxzLmZpbGxJbiggUEFUVEVSTjIsIHsgeDogeCwgYjogYiwgYzogYyB9ICk7XHJcblxyXG4gICAgLy8gMXggKyBiID0gMHggKyBjXHJcbiAgICByZXR1cm4gbmV3IENoYWxsZW5nZSggeCxcclxuICAgICAgRnJhY3Rpb24uZnJvbUludGVnZXIoIDEgKSwgRnJhY3Rpb24uZnJvbUludGVnZXIoIGIgKSxcclxuICAgICAgRnJhY3Rpb24uZnJvbUludGVnZXIoIDAgKSwgRnJhY3Rpb24uZnJvbUludGVnZXIoIGMgKSxcclxuICAgICAgZGVidWdEZXJpdmF0aW9uICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgdGhlIG5leHQgJ3R5cGUgMycgY2hhbGxlbmdlLlxyXG4gICAqXHJcbiAgICogRm9ybTogeC9kID0gY1xyXG4gICAqIExldCBjIGJlIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBbLTEwLDEwXSwgYyAhPT0gMFxyXG4gICAqIExldCBkIGJlIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBbLTEwLCAxMF0sIGQgIT09IFswLCAxXVxyXG4gICAqIExldCB4ID0gYyAqIGQsIHggIT09IDBcclxuICAgKi9cclxuICBwdWJsaWMgbmV4dFR5cGUzKCk6IENoYWxsZW5nZSB7XHJcblxyXG4gICAgbGV0IHggPSB0aGlzLnhQcmV2aW91cztcclxuICAgIGxldCBjID0gMDtcclxuICAgIGxldCBkID0gMDtcclxuICAgIGxldCBhdHRlbXB0cyA9IDA7IC8vIHRvIHByZXZlbnQgYW4gaW1wcm9iYWJsZSBpbmZpbml0ZSB3aGlsZSBsb29wXHJcbiAgICB3aGlsZSAoIHggPT09IHRoaXMueFByZXZpb3VzICYmIGF0dGVtcHRzIDwgTUFYX0FUVEVNUFRTICkge1xyXG4gICAgICBhdHRlbXB0cysrO1xyXG4gICAgICBjID0gQ2hhbGxlbmdlR2VuZXJhdG9yLnJhbmRvbVZhbHVlKCB0aGlzLmNWYWx1ZXMsIFsgMCBdICk7XHJcbiAgICAgIGQgPSBDaGFsbGVuZ2VHZW5lcmF0b3IucmFuZG9tVmFsdWUoIHRoaXMuZFZhbHVlcywgWyAwLCAxIF0gKTtcclxuICAgICAgeCA9IGMgKiBkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZlcmlmeSB0aGF0IGNvbXB1dGF0aW9ucyBtZWV0aW5nIGRlc2lnbiByZXF1aXJlbWVudHMuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBjICE9PSAwLCAnYyBpcyAwJyApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZCAhPT0gMCwgJ2QgaXMgMCcgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGQgIT09IDEsICdkIGlzIDEnICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB4ICE9PSAwLCAneCBpcyAwJyApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggeCAhPT0gdGhpcy54UHJldmlvdXMgfHwgYXR0ZW1wdHMgPT09IE1BWF9BVFRFTVBUUywgYHggPT09IHhQcmV2aW91czogJHt4fWAgKTtcclxuICAgIHRoaXMueFByZXZpb3VzID0geDtcclxuXHJcbiAgICAvLyBkZXJpdmF0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gZGVzaWduIGRvYywgZGlzcGxheWVkIHdpdGggJ3Nob3dBbnN3ZXJzJyBxdWVyeSBwYXJhbWV0ZXJcclxuICAgIGNvbnN0IGRlYnVnRGVyaXZhdGlvbiA9IFN0cmluZ1V0aWxzLmZpbGxJbiggUEFUVEVSTjMsIHsgeDogeCwgYzogYywgZDogZCB9ICk7XHJcblxyXG4gICAgLy8gKDEvZCl4ICsgMCA9IDB4ICsgY1xyXG4gICAgcmV0dXJuIG5ldyBDaGFsbGVuZ2UoIHgsXHJcbiAgICAgIG5ldyBGcmFjdGlvbiggMSwgZCApLCBGcmFjdGlvbi5mcm9tSW50ZWdlciggMCApLFxyXG4gICAgICBGcmFjdGlvbi5mcm9tSW50ZWdlciggMCApLCBGcmFjdGlvbi5mcm9tSW50ZWdlciggYyApLFxyXG4gICAgICBkZWJ1Z0Rlcml2YXRpb24gKTtcclxuICB9XHJcbn1cclxuXHJcbmVxdWFsaXR5RXhwbG9yZXIucmVnaXN0ZXIoICdDaGFsbGVuZ2VHZW5lcmF0b3IxJywgQ2hhbGxlbmdlR2VuZXJhdG9yMSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFNBQVMsTUFBTSxpQ0FBaUM7QUFDdkQsT0FBT0MsU0FBUyxNQUFNLHVDQUF1QztBQUM3RCxPQUFPQyxRQUFRLE1BQU0sNkNBQTZDO0FBQ2xFLE9BQU9DLFdBQVcsTUFBTSwrQ0FBK0M7QUFDdkUsT0FBT0MsZ0JBQWdCLE1BQU0sMkJBQTJCO0FBQ3hELE9BQU9DLFNBQVMsTUFBTSxnQkFBZ0I7QUFDdEMsT0FBT0Msa0JBQWtCLE1BQU0seUJBQXlCOztBQUV4RDtBQUNBLE1BQU1DLFFBQVEsR0FBRyxvQkFBb0IsR0FDcEIsZUFBZSxHQUNmLGVBQWUsR0FDZixtQkFBbUI7QUFDcEMsTUFBTUMsUUFBUSxHQUFHLHVCQUF1QixHQUN2QixlQUFlLEdBQ2YsZUFBZSxHQUNmLG1CQUFtQjtBQUNwQyxNQUFNQyxRQUFRLEdBQUcscUJBQXFCLEdBQ3JCLGVBQWUsR0FDZixlQUFlLEdBQ2Ysb0JBQW9COztBQUVyQztBQUNBLE1BQU1D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