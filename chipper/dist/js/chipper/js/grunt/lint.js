// Copyright 2022-2023, University of Colorado Boulder

/**
 * Runs the lint rules on the specified files.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */

// modules
const _ = require('lodash');
const {
  ESLint
} = require('eslint'); // eslint-disable-line require-statement-match
const fs = require('fs');
const chipAway = require('./chipAway');
const disableWithComment = require('./disableWithComment');
const showCommandLineProgress = require('../common/showCommandLineProgress');
const CacheLayer = require('../common/CacheLayer');
const crypto = require('crypto');

// constants
const EXCLUDE_REPOS = [];

// "Pattern" is really a path, we assume here that gruntfiles help keep the right directory stucture and can just pop
// out of the repo running the command
const repoToPattern = repo => `../${repo}`;
async function consoleLogResults(results) {
  // No need to have the same ESLint just to format
  const formatter = await new ESLint().loadFormatter('stylish');
  const resultText = formatter.format(results);
  console.log(`\n${resultText}\n`);
}

/**
 * Create an ESLint client and lint a single repo
 * @param {string} repo
 * @param {Object} [options]
 * @returns {Promise<Object>} - results from linting files, see ESLint.lintFiles
 */
const lintOneRepo = async (repo, options) => {
  options = _.extend({
    cache: true,
    fix: false,
    format: false,
    inProgressErrorLogging: false // print out the
  }, options);

  // Hash on tsconfig file so when tsconfig changes it invalidates the cache.  NOTE this is a known memory leak.  May
  // need to clear the cache directory in a few years?
  const tsconfigFile = fs.readFileSync('../chipper/tsconfig/all/tsconfig.json', 'utf-8');

  // Also cache on package.json so that when eslint plugins change, it will invalidate the caches. Note this will
  // have false positives because it is possible to change package.json without changing
  // the eslint plugins
  const packageJSON = fs.readFileSync('../chipper/package.json', 'utf-8');
  const hash = crypto.createHash('md5').update(tsconfigFile + packageJSON).digest('hex');
  const eslintConfig = {
    // optional auto-fix
    fix: options.fix,
    // Caching only checks changed files or when the list of rules is changed.  Changing the implementation of a
    // custom rule does not invalidate the cache.  Caches are declared in .eslintcache files in the directory where
    // the process was run from. If false, this will delete the `cacheLocation` file.
    cache: options.cache,
    // Where to store the target-specific cache file.  Use only first 4 digits of hash to improve readability
    // at the risk of having more key collisions
    cacheLocation: `../chipper/eslint/cache/${repo}-${hash.substring(0, 8)}.eslintcache`,
    ignorePath: '../chipper/eslint/.eslintignore',
    resolvePluginsRelativeTo: '../chipper/',
    // Our custom rules live here
    rulePaths: ['../chipper/eslint/rules'],
    extensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'],
    // If no lintable files are found, it is not an error
    errorOnUnmatchedPattern: false
  };
  const cacheKey = `lintRepo#${repo}`;
  if (options.cache && CacheLayer.isCacheSafe(cacheKey)) {
    // console.log( 'lint cache hit: ' + cacheKey );
    return [];
  } else {
    // console.log( 'lint cache fail: ' + cacheKey );
  }
  const config = {};
  const configExtends = [];
  if (options.format) {
    configExtends.push('../chipper/eslint/format_eslintrc.js');
  }
  config.extends = configExtends;
  eslintConfig.baseConfig = config;
  const eslint = new ESLint(eslintConfig);
  const results = await eslint.lintFiles(repoToPattern(repo));
  const totalWarnings = _.sum(results.map(result => result.warningCount));
  const totalErrors = _.sum(results.map(result => result.errorCount));
  if (options.cache && totalWarnings === 0 && totalErrors === 0) {
    CacheLayer.onSuccess(cacheKey);
  }
  if (options.inProgressErrorLogging && totalWarnings + totalErrors > 0) {
    console.log(`\n\n${repo}:`);
    await consoleLogResults(results);
  }
  return results;
};

/**
 * Lints the specified repositories.
 * @public
 *
 * @param {string[]} repos - list of repos to lint
 * @param {Object} [options]
 * @returns {Promise<{results:Object,ok:boolean}>} - results from linting files, see ESLint.lintFiles (all results, not just errors).
 */
const lint = async (repos, options) => {
  // Run all linting from chipper so the ESLint cache will be shared, see https://github.com/phetsims/chipper/issues/1286
  const cwd = process.cwd();
  process.chdir('../chipper');
  options = _.merge({
    cache: true,
    format: false,
    // append an extra set of rules for formatting code.
    fix: false,
    // whether fixes should be written to disk
    chipAway: false,
    // returns responsible dev info for easier chipping.
    disableWithComment: false,
    // replaces failing typescript lines with eslint disable and related comment
    showProgressBar: true
  }, options);

  // filter out all unlintable repos. An unlintable repo is one that has no `js` in it, so it will fail when trying to
  // lint it.  Also, if the user doesn't have some repos checked out, those should be skipped
  repos = repos.filter(repo => !EXCLUDE_REPOS.includes(repo) && fs.existsSync(repoToPattern(repo)));
  const inProgressErrorLogging = repos.length > 1;
  const allResults = [];
  for (let i = 0; i < repos.length; i++) {
    options.showProgressBar && repos.length > 1 && showCommandLineProgress(i / repos.length, false);
    try {
      const results = await lintOneRepo(repos[i], {
        cache: options.cache,
        format: options.format,
        fix: options.fix,
        inProgressErrorLogging: inProgressErrorLogging
      });
      allResults.push(...results);
    } catch (e) {
      console.error(e); // make sure that the error ends up on stderr
      throw e;
    }
  }
  options.showProgressBar && repos.length > 1 && showCommandLineProgress(1, true);

  // 3. Modify the files with the fixed code.
  if (options.fix) {
    await ESLint.outputFixes(allResults);
  }

  // Parse the results.
  const totalWarnings = _.sum(allResults.map(result => result.warningCount));
  const totalErrors = _.sum(allResults.map(result => result.errorCount));

  // Output results on errors.
  if (totalWarnings + totalErrors > 0) {
    // This exact string is used in AQUA/QuickServer to parse messaging for slack reporting
    const IMPORTANT_MESSAGE_DO_NOT_EDIT = 'All results (repeated from above)';
    inProgressErrorLogging && console.log(`\n\n${IMPORTANT_MESSAGE_DO_NOT_EDIT}\n`);
    await consoleLogResults(allResults);

    // The chip-away option provides a quick and easy method to assign devs to their respective repositories.
    // Check ./chipAway.js for more information.
    if (options.chipAway) {
      const message = chipAway(allResults);
      console.log('Results from chipAway: \n' + message);
    }
    if (options.disableWithComment) {
      disableWithComment(allResults);
    }
  }
  process.chdir(cwd);
  const ok = totalWarnings + totalErrors === 0;
  return {
    results: allResults,
    ok: ok
  };
};

// Mark the version so that the pre-commit hook will only try to use the promise-based API, this means
// it won't run lint precommit hook on SHAs before the promise-based API
lint.chipperAPIVersion = 'promisesPerRepo1';
module.exports = lint;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfIiwicmVxdWlyZSIsIkVTTGludCIsImZzIiwiY2hpcEF3YXkiLCJkaXNhYmxlV2l0aENvbW1lbnQiLCJzaG93Q29tbWFuZExpbmVQcm9ncmVzcyIsIkNhY2hlTGF5ZXIiLCJjcnlwdG8iLCJFWENMVURFX1JFUE9TIiwicmVwb1RvUGF0dGVybiIsInJlcG8iLCJjb25zb2xlTG9nUmVzdWx0cyIsInJlc3VsdHMiLCJmb3JtYXR0ZXIiLCJsb2FkRm9ybWF0dGVyIiwicmVzdWx0VGV4dCIsImZvcm1hdCIsImNvbnNvbGUiLCJsb2ciLCJsaW50T25lUmVwbyIsIm9wdGlvbnMiLCJleHRlbmQiLCJjYWNoZSIsImZpeCIsImluUHJvZ3Jlc3NFcnJvckxvZ2dpbmciLCJ0c2NvbmZpZ0ZpbGUiLCJyZWFkRmlsZVN5bmMiLCJwYWNrYWdlSlNPTiIsImhhc2giLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZGlnZXN0IiwiZXNsaW50Q29uZmlnIiwiY2FjaGVMb2NhdGlvbiIsInN1YnN0cmluZyIsImlnbm9yZVBhdGgiLCJyZXNvbHZlUGx1Z2luc1JlbGF0aXZlVG8iLCJydWxlUGF0aHMiLCJleHRlbnNpb25zIiwiZXJyb3JPblVubWF0Y2hlZFBhdHRlcm4iLCJjYWNoZUtleSIsImlzQ2FjaGVTYWZlIiwiY29uZmlnIiwiY29uZmlnRXh0ZW5kcyIsInB1c2giLCJleHRlbmRzIiwiYmFzZUNvbmZpZyIsImVzbGludCIsImxpbnRGaWxlcyIsInRvdGFsV2FybmluZ3MiLCJzdW0iLCJtYXAiLCJyZXN1bHQiLCJ3YXJuaW5nQ291bnQiLCJ0b3RhbEVycm9ycyIsImVycm9yQ291bnQiLCJvblN1Y2Nlc3MiLCJsaW50IiwicmVwb3MiLCJjd2QiLCJwcm9jZXNzIiwiY2hkaXIiLCJtZXJnZSIsInNob3dQcm9ncmVzc0JhciIsImZpbHRlciIsImluY2x1ZGVzIiwiZXhpc3RzU3luYyIsImxlbmd0aCIsImFsbFJlc3VsdHMiLCJpIiwiZSIsImVycm9yIiwib3V0cHV0Rml4ZXMiLCJJTVBPUlRBTlRfTUVTU0FHRV9ET19OT1RfRURJVCIsIm1lc3NhZ2UiLCJvayIsImNoaXBwZXJBUElWZXJzaW9uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbImxpbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjItMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogUnVucyB0aGUgbGludCBydWxlcyBvbiB0aGUgc3BlY2lmaWVkIGZpbGVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKiBAYXV0aG9yIE1pY2hhZWwgS2F1em1hbm4gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuXHJcbi8vIG1vZHVsZXNcclxuY29uc3QgXyA9IHJlcXVpcmUoICdsb2Rhc2gnICk7XHJcbmNvbnN0IHsgRVNMaW50IH0gPSByZXF1aXJlKCAnZXNsaW50JyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtc3RhdGVtZW50LW1hdGNoXHJcbmNvbnN0IGZzID0gcmVxdWlyZSggJ2ZzJyApO1xyXG5jb25zdCBjaGlwQXdheSA9IHJlcXVpcmUoICcuL2NoaXBBd2F5JyApO1xyXG5jb25zdCBkaXNhYmxlV2l0aENvbW1lbnQgPSByZXF1aXJlKCAnLi9kaXNhYmxlV2l0aENvbW1lbnQnICk7XHJcbmNvbnN0IHNob3dDb21tYW5kTGluZVByb2dyZXNzID0gcmVxdWlyZSggJy4uL2NvbW1vbi9zaG93Q29tbWFuZExpbmVQcm9ncmVzcycgKTtcclxuY29uc3QgQ2FjaGVMYXllciA9IHJlcXVpcmUoICcuLi9jb21tb24vQ2FjaGVMYXllcicgKTtcclxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSggJ2NyeXB0bycgKTtcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBFWENMVURFX1JFUE9TID0gW107XHJcblxyXG4vLyBcIlBhdHRlcm5cIiBpcyByZWFsbHkgYSBwYXRoLCB3ZSBhc3N1bWUgaGVyZSB0aGF0IGdydW50ZmlsZXMgaGVscCBrZWVwIHRoZSByaWdodCBkaXJlY3Rvcnkgc3R1Y3R1cmUgYW5kIGNhbiBqdXN0IHBvcFxyXG4vLyBvdXQgb2YgdGhlIHJlcG8gcnVubmluZyB0aGUgY29tbWFuZFxyXG5jb25zdCByZXBvVG9QYXR0ZXJuID0gcmVwbyA9PiBgLi4vJHtyZXBvfWA7XHJcblxyXG5hc3luYyBmdW5jdGlvbiBjb25zb2xlTG9nUmVzdWx0cyggcmVzdWx0cyApIHtcclxuXHJcbiAgLy8gTm8gbmVlZCB0byBoYXZlIHRoZSBzYW1lIEVTTGludCBqdXN0IHRvIGZvcm1hdFxyXG4gIGNvbnN0IGZvcm1hdHRlciA9IGF3YWl0IG5ldyBFU0xpbnQoKS5sb2FkRm9ybWF0dGVyKCAnc3R5bGlzaCcgKTtcclxuICBjb25zdCByZXN1bHRUZXh0ID0gZm9ybWF0dGVyLmZvcm1hdCggcmVzdWx0cyApO1xyXG4gIGNvbnNvbGUubG9nKCBgXFxuJHtyZXN1bHRUZXh0fVxcbmAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBFU0xpbnQgY2xpZW50IGFuZCBsaW50IGEgc2luZ2xlIHJlcG9cclxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIHJlc3VsdHMgZnJvbSBsaW50aW5nIGZpbGVzLCBzZWUgRVNMaW50LmxpbnRGaWxlc1xyXG4gKi9cclxuY29uc3QgbGludE9uZVJlcG8gPSBhc3luYyAoIHJlcG8sIG9wdGlvbnMgKSA9PiB7XHJcblxyXG4gIG9wdGlvbnMgPSBfLmV4dGVuZCgge1xyXG4gICAgY2FjaGU6IHRydWUsXHJcbiAgICBmaXg6IGZhbHNlLFxyXG4gICAgZm9ybWF0OiBmYWxzZSxcclxuICAgIGluUHJvZ3Jlc3NFcnJvckxvZ2dpbmc6IGZhbHNlIC8vIHByaW50IG91dCB0aGVcclxuICB9LCBvcHRpb25zICk7XHJcblxyXG4gIC8vIEhhc2ggb24gdHNjb25maWcgZmlsZSBzbyB3aGVuIHRzY29uZmlnIGNoYW5nZXMgaXQgaW52YWxpZGF0ZXMgdGhlIGNhY2hlLiAgTk9URSB0aGlzIGlzIGEga25vd24gbWVtb3J5IGxlYWsuICBNYXlcclxuICAvLyBuZWVkIHRvIGNsZWFyIHRoZSBjYWNoZSBkaXJlY3RvcnkgaW4gYSBmZXcgeWVhcnM/XHJcbiAgY29uc3QgdHNjb25maWdGaWxlID0gZnMucmVhZEZpbGVTeW5jKCAnLi4vY2hpcHBlci90c2NvbmZpZy9hbGwvdHNjb25maWcuanNvbicsICd1dGYtOCcgKTtcclxuXHJcbiAgLy8gQWxzbyBjYWNoZSBvbiBwYWNrYWdlLmpzb24gc28gdGhhdCB3aGVuIGVzbGludCBwbHVnaW5zIGNoYW5nZSwgaXQgd2lsbCBpbnZhbGlkYXRlIHRoZSBjYWNoZXMuIE5vdGUgdGhpcyB3aWxsXHJcbiAgLy8gaGF2ZSBmYWxzZSBwb3NpdGl2ZXMgYmVjYXVzZSBpdCBpcyBwb3NzaWJsZSB0byBjaGFuZ2UgcGFja2FnZS5qc29uIHdpdGhvdXQgY2hhbmdpbmdcclxuICAvLyB0aGUgZXNsaW50IHBsdWdpbnNcclxuICBjb25zdCBwYWNrYWdlSlNPTiA9IGZzLnJlYWRGaWxlU3luYyggJy4uL2NoaXBwZXIvcGFja2FnZS5qc29uJywgJ3V0Zi04JyApO1xyXG5cclxuICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goICdtZDUnICkudXBkYXRlKCB0c2NvbmZpZ0ZpbGUgKyBwYWNrYWdlSlNPTiApLmRpZ2VzdCggJ2hleCcgKTtcclxuXHJcbiAgY29uc3QgZXNsaW50Q29uZmlnID0ge1xyXG5cclxuICAgIC8vIG9wdGlvbmFsIGF1dG8tZml4XHJcbiAgICBmaXg6IG9wdGlvbnMuZml4LFxyXG5cclxuICAgIC8vIENhY2hpbmcgb25seSBjaGVja3MgY2hhbmdlZCBmaWxlcyBvciB3aGVuIHRoZSBsaXN0IG9mIHJ1bGVzIGlzIGNoYW5nZWQuICBDaGFuZ2luZyB0aGUgaW1wbGVtZW50YXRpb24gb2YgYVxyXG4gICAgLy8gY3VzdG9tIHJ1bGUgZG9lcyBub3QgaW52YWxpZGF0ZSB0aGUgY2FjaGUuICBDYWNoZXMgYXJlIGRlY2xhcmVkIGluIC5lc2xpbnRjYWNoZSBmaWxlcyBpbiB0aGUgZGlyZWN0b3J5IHdoZXJlXHJcbiAgICAvLyB0aGUgcHJvY2VzcyB3YXMgcnVuIGZyb20uIElmIGZhbHNlLCB0aGlzIHdpbGwgZGVsZXRlIHRoZSBgY2FjaGVMb2NhdGlvbmAgZmlsZS5cclxuICAgIGNhY2hlOiBvcHRpb25zLmNhY2hlLFxyXG5cclxuICAgIC8vIFdoZXJlIHRvIHN0b3JlIHRoZSB0YXJnZXQtc3BlY2lmaWMgY2FjaGUgZmlsZS4gIFVzZSBvbmx5IGZpcnN0IDQgZGlnaXRzIG9mIGhhc2ggdG8gaW1wcm92ZSByZWFkYWJpbGl0eVxyXG4gICAgLy8gYXQgdGhlIHJpc2sgb2YgaGF2aW5nIG1vcmUga2V5IGNvbGxpc2lvbnNcclxuICAgIGNhY2hlTG9jYXRpb246IGAuLi9jaGlwcGVyL2VzbGludC9jYWNoZS8ke3JlcG99LSR7aGFzaC5zdWJzdHJpbmcoIDAsIDggKX0uZXNsaW50Y2FjaGVgLFxyXG5cclxuICAgIGlnbm9yZVBhdGg6ICcuLi9jaGlwcGVyL2VzbGludC8uZXNsaW50aWdub3JlJyxcclxuXHJcbiAgICByZXNvbHZlUGx1Z2luc1JlbGF0aXZlVG86ICcuLi9jaGlwcGVyLycsXHJcblxyXG4gICAgLy8gT3VyIGN1c3RvbSBydWxlcyBsaXZlIGhlcmVcclxuICAgIHJ1bGVQYXRoczogWyAnLi4vY2hpcHBlci9lc2xpbnQvcnVsZXMnIF0sXHJcblxyXG4gICAgZXh0ZW5zaW9uczogWyAnLmpzJywgJy5qc3gnLCAnLnRzJywgJy50c3gnLCAnLm1qcycsICcuY2pzJyBdLFxyXG5cclxuICAgIC8vIElmIG5vIGxpbnRhYmxlIGZpbGVzIGFyZSBmb3VuZCwgaXQgaXMgbm90IGFuIGVycm9yXHJcbiAgICBlcnJvck9uVW5tYXRjaGVkUGF0dGVybjogZmFsc2VcclxuICB9O1xyXG5cclxuICBjb25zdCBjYWNoZUtleSA9IGBsaW50UmVwbyMke3JlcG99YDtcclxuXHJcbiAgaWYgKCBvcHRpb25zLmNhY2hlICYmIENhY2hlTGF5ZXIuaXNDYWNoZVNhZmUoIGNhY2hlS2V5ICkgKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyggJ2xpbnQgY2FjaGUgaGl0OiAnICsgY2FjaGVLZXkgKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyggJ2xpbnQgY2FjaGUgZmFpbDogJyArIGNhY2hlS2V5ICk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjb25maWcgPSB7fTtcclxuICBjb25zdCBjb25maWdFeHRlbmRzID0gW107XHJcbiAgaWYgKCBvcHRpb25zLmZvcm1hdCApIHtcclxuICAgIGNvbmZpZ0V4dGVuZHMucHVzaCggJy4uL2NoaXBwZXIvZXNsaW50L2Zvcm1hdF9lc2xpbnRyYy5qcycgKTtcclxuICB9XHJcblxyXG4gIGNvbmZpZy5leHRlbmRzID0gY29uZmlnRXh0ZW5kcztcclxuICBlc2xpbnRDb25maWcuYmFzZUNvbmZpZyA9IGNvbmZpZztcclxuXHJcbiAgY29uc3QgZXNsaW50ID0gbmV3IEVTTGludCggZXNsaW50Q29uZmlnICk7XHJcblxyXG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBlc2xpbnQubGludEZpbGVzKCByZXBvVG9QYXR0ZXJuKCByZXBvICkgKTtcclxuXHJcbiAgY29uc3QgdG90YWxXYXJuaW5ncyA9IF8uc3VtKCByZXN1bHRzLm1hcCggcmVzdWx0ID0+IHJlc3VsdC53YXJuaW5nQ291bnQgKSApO1xyXG4gIGNvbnN0IHRvdGFsRXJyb3JzID0gXy5zdW0oIHJlc3VsdHMubWFwKCByZXN1bHQgPT4gcmVzdWx0LmVycm9yQ291bnQgKSApO1xyXG4gIGlmICggb3B0aW9ucy5jYWNoZSAmJiB0b3RhbFdhcm5pbmdzID09PSAwICYmIHRvdGFsRXJyb3JzID09PSAwICkge1xyXG4gICAgQ2FjaGVMYXllci5vblN1Y2Nlc3MoIGNhY2hlS2V5ICk7XHJcbiAgfVxyXG5cclxuICBpZiAoIG9wdGlvbnMuaW5Qcm9ncmVzc0Vycm9yTG9nZ2luZyAmJiB0b3RhbFdhcm5pbmdzICsgdG90YWxFcnJvcnMgPiAwICkge1xyXG4gICAgY29uc29sZS5sb2coIGBcXG5cXG4ke3JlcG99OmAgKTtcclxuICAgIGF3YWl0IGNvbnNvbGVMb2dSZXN1bHRzKCByZXN1bHRzICk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0cztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBMaW50cyB0aGUgc3BlY2lmaWVkIHJlcG9zaXRvcmllcy5cclxuICogQHB1YmxpY1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSByZXBvcyAtIGxpc3Qgb2YgcmVwb3MgdG8gbGludFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHtyZXN1bHRzOk9iamVjdCxvazpib29sZWFufT59IC0gcmVzdWx0cyBmcm9tIGxpbnRpbmcgZmlsZXMsIHNlZSBFU0xpbnQubGludEZpbGVzIChhbGwgcmVzdWx0cywgbm90IGp1c3QgZXJyb3JzKS5cclxuICovXHJcbmNvbnN0IGxpbnQgPSBhc3luYyAoIHJlcG9zLCBvcHRpb25zICkgPT4ge1xyXG5cclxuICAvLyBSdW4gYWxsIGxpbnRpbmcgZnJvbSBjaGlwcGVyIHNvIHRoZSBFU0xpbnQgY2FjaGUgd2lsbCBiZSBzaGFyZWQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvY2hpcHBlci9pc3N1ZXMvMTI4NlxyXG4gIGNvbnN0IGN3ZCA9IHByb2Nlc3MuY3dkKCk7XHJcbiAgcHJvY2Vzcy5jaGRpciggJy4uL2NoaXBwZXInICk7XHJcblxyXG4gIG9wdGlvbnMgPSBfLm1lcmdlKCB7XHJcbiAgICBjYWNoZTogdHJ1ZSxcclxuICAgIGZvcm1hdDogZmFsc2UsIC8vIGFwcGVuZCBhbiBleHRyYSBzZXQgb2YgcnVsZXMgZm9yIGZvcm1hdHRpbmcgY29kZS5cclxuICAgIGZpeDogZmFsc2UsIC8vIHdoZXRoZXIgZml4ZXMgc2hvdWxkIGJlIHdyaXR0ZW4gdG8gZGlza1xyXG4gICAgY2hpcEF3YXk6IGZhbHNlLCAvLyByZXR1cm5zIHJlc3BvbnNpYmxlIGRldiBpbmZvIGZvciBlYXNpZXIgY2hpcHBpbmcuXHJcbiAgICBkaXNhYmxlV2l0aENvbW1lbnQ6IGZhbHNlLCAvLyByZXBsYWNlcyBmYWlsaW5nIHR5cGVzY3JpcHQgbGluZXMgd2l0aCBlc2xpbnQgZGlzYWJsZSBhbmQgcmVsYXRlZCBjb21tZW50XHJcbiAgICBzaG93UHJvZ3Jlc3NCYXI6IHRydWVcclxuICB9LCBvcHRpb25zICk7XHJcblxyXG4gIC8vIGZpbHRlciBvdXQgYWxsIHVubGludGFibGUgcmVwb3MuIEFuIHVubGludGFibGUgcmVwbyBpcyBvbmUgdGhhdCBoYXMgbm8gYGpzYCBpbiBpdCwgc28gaXQgd2lsbCBmYWlsIHdoZW4gdHJ5aW5nIHRvXHJcbiAgLy8gbGludCBpdC4gIEFsc28sIGlmIHRoZSB1c2VyIGRvZXNuJ3QgaGF2ZSBzb21lIHJlcG9zIGNoZWNrZWQgb3V0LCB0aG9zZSBzaG91bGQgYmUgc2tpcHBlZFxyXG4gIHJlcG9zID0gcmVwb3MuZmlsdGVyKCByZXBvID0+ICFFWENMVURFX1JFUE9TLmluY2x1ZGVzKCByZXBvICkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcy5leGlzdHNTeW5jKCByZXBvVG9QYXR0ZXJuKCByZXBvICkgKSApO1xyXG5cclxuICBjb25zdCBpblByb2dyZXNzRXJyb3JMb2dnaW5nID0gcmVwb3MubGVuZ3RoID4gMTtcclxuXHJcbiAgY29uc3QgYWxsUmVzdWx0cyA9IFtdO1xyXG4gIGZvciAoIGxldCBpID0gMDsgaSA8IHJlcG9zLmxlbmd0aDsgaSsrICkge1xyXG4gICAgb3B0aW9ucy5zaG93UHJvZ3Jlc3NCYXIgJiYgcmVwb3MubGVuZ3RoID4gMSAmJiBzaG93Q29tbWFuZExpbmVQcm9ncmVzcyggaSAvIHJlcG9zLmxlbmd0aCwgZmFsc2UgKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgbGludE9uZVJlcG8oIHJlcG9zWyBpIF0sIHtcclxuICAgICAgICBjYWNoZTogb3B0aW9ucy5jYWNoZSxcclxuICAgICAgICBmb3JtYXQ6IG9wdGlvbnMuZm9ybWF0LFxyXG4gICAgICAgIGZpeDogb3B0aW9ucy5maXgsXHJcbiAgICAgICAgaW5Qcm9ncmVzc0Vycm9yTG9nZ2luZzogaW5Qcm9ncmVzc0Vycm9yTG9nZ2luZ1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICBhbGxSZXN1bHRzLnB1c2goIC4uLnJlc3VsdHMgKTtcclxuICAgIH1cclxuICAgIGNhdGNoKCBlICkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCBlICk7IC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBlcnJvciBlbmRzIHVwIG9uIHN0ZGVyclxyXG4gICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb3B0aW9ucy5zaG93UHJvZ3Jlc3NCYXIgJiYgcmVwb3MubGVuZ3RoID4gMSAmJiBzaG93Q29tbWFuZExpbmVQcm9ncmVzcyggMSwgdHJ1ZSApO1xyXG5cclxuICAvLyAzLiBNb2RpZnkgdGhlIGZpbGVzIHdpdGggdGhlIGZpeGVkIGNvZGUuXHJcbiAgaWYgKCBvcHRpb25zLmZpeCApIHtcclxuICAgIGF3YWl0IEVTTGludC5vdXRwdXRGaXhlcyggYWxsUmVzdWx0cyApO1xyXG4gIH1cclxuXHJcbiAgLy8gUGFyc2UgdGhlIHJlc3VsdHMuXHJcbiAgY29uc3QgdG90YWxXYXJuaW5ncyA9IF8uc3VtKCBhbGxSZXN1bHRzLm1hcCggcmVzdWx0ID0+IHJlc3VsdC53YXJuaW5nQ291bnQgKSApO1xyXG4gIGNvbnN0IHRvdGFsRXJyb3JzID0gXy5zdW0oIGFsbFJlc3VsdHMubWFwKCByZXN1bHQgPT4gcmVzdWx0LmVycm9yQ291bnQgKSApO1xyXG5cclxuICAvLyBPdXRwdXQgcmVzdWx0cyBvbiBlcnJvcnMuXHJcbiAgaWYgKCB0b3RhbFdhcm5pbmdzICsgdG90YWxFcnJvcnMgPiAwICkge1xyXG5cclxuICAgIC8vIFRoaXMgZXhhY3Qgc3RyaW5nIGlzIHVzZWQgaW4gQVFVQS9RdWlja1NlcnZlciB0byBwYXJzZSBtZXNzYWdpbmcgZm9yIHNsYWNrIHJlcG9ydGluZ1xyXG4gICAgY29uc3QgSU1QT1JUQU5UX01FU1NBR0VfRE9fTk9UX0VESVQgPSAnQWxsIHJlc3VsdHMgKHJlcGVhdGVkIGZyb20gYWJvdmUpJztcclxuICAgIGluUHJvZ3Jlc3NFcnJvckxvZ2dpbmcgJiYgY29uc29sZS5sb2coIGBcXG5cXG4ke0lNUE9SVEFOVF9NRVNTQUdFX0RPX05PVF9FRElUfVxcbmAgKTtcclxuXHJcbiAgICBhd2FpdCBjb25zb2xlTG9nUmVzdWx0cyggYWxsUmVzdWx0cyApO1xyXG5cclxuICAgIC8vIFRoZSBjaGlwLWF3YXkgb3B0aW9uIHByb3ZpZGVzIGEgcXVpY2sgYW5kIGVhc3kgbWV0aG9kIHRvIGFzc2lnbiBkZXZzIHRvIHRoZWlyIHJlc3BlY3RpdmUgcmVwb3NpdG9yaWVzLlxyXG4gICAgLy8gQ2hlY2sgLi9jaGlwQXdheS5qcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgIGlmICggb3B0aW9ucy5jaGlwQXdheSApIHtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IGNoaXBBd2F5KCBhbGxSZXN1bHRzICk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCAnUmVzdWx0cyBmcm9tIGNoaXBBd2F5OiBcXG4nICsgbWVzc2FnZSApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICggb3B0aW9ucy5kaXNhYmxlV2l0aENvbW1lbnQgKSB7XHJcbiAgICAgIGRpc2FibGVXaXRoQ29tbWVudCggYWxsUmVzdWx0cyApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJvY2Vzcy5jaGRpciggY3dkICk7XHJcblxyXG4gIGNvbnN0IG9rID0gdG90YWxXYXJuaW5ncyArIHRvdGFsRXJyb3JzID09PSAwO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcmVzdWx0czogYWxsUmVzdWx0cyxcclxuICAgIG9rOiBva1xyXG4gIH07XHJcbn07XHJcblxyXG4vLyBNYXJrIHRoZSB2ZXJzaW9uIHNvIHRoYXQgdGhlIHByZS1jb21taXQgaG9vayB3aWxsIG9ubHkgdHJ5IHRvIHVzZSB0aGUgcHJvbWlzZS1iYXNlZCBBUEksIHRoaXMgbWVhbnNcclxuLy8gaXQgd29uJ3QgcnVuIGxpbnQgcHJlY29tbWl0IGhvb2sgb24gU0hBcyBiZWZvcmUgdGhlIHByb21pc2UtYmFzZWQgQVBJXHJcbmxpbnQuY2hpcHBlckFQSVZlcnNpb24gPSAncHJvbWlzZXNQZXJSZXBvMSc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxpbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQSxNQUFNQSxDQUFDLEdBQUdDLE9BQU8sQ0FBRSxRQUFTLENBQUM7QUFDN0IsTUFBTTtFQUFFQztBQUFPLENBQUMsR0FBR0QsT0FBTyxDQUFFLFFBQVMsQ0FBQyxDQUFDLENBQUM7QUFDeEMsTUFBTUUsRUFBRSxHQUFHRixPQUFPLENBQUUsSUFBSyxDQUFDO0FBQzFCLE1BQU1HLFFBQVEsR0FBR0gsT0FBTyxDQUFFLFlBQWEsQ0FBQztBQUN4QyxNQUFNSSxrQkFBa0IsR0FBR0osT0FBTyxDQUFFLHNCQUF1QixDQUFDO0FBQzVELE1BQU1LLHVCQUF1QixHQUFHTCxPQUFPLENBQUUsbUNBQW9DLENBQUM7QUFDOUUsTUFBTU0sVUFBVSxHQUFHTixPQUFPLENBQUUsc0JBQXVCLENBQUM7QUFDcEQsTUFBTU8sTUFBTSxHQUFHUCxPQUFPLENBQUUsUUFBUyxDQUFDOztBQUVsQztBQUNBLE1BQU1RLGFBQWEsR0FBRyxFQUFFOztBQUV4QjtBQUNBO0FBQ0EsTUFBTUMsYUFBYSxHQUFHQyxJQUFJLElBQUssTUFBS0EsSUFBSyxFQUFDO0FBRTFDLGVBQWVDLGlCQUFpQkEsQ0FBRUMsT0FBTyxFQUFHO0VBRTFDO0VBQ0Es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