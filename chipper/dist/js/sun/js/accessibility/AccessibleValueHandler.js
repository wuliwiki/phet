// Copyright 2019-2023, University of Colorado Boulder

/**
 * A trait for subtypes of Node. Meant for Nodes with a value that "run" on a NumberProperty and handles formatting,
 * mapping, and aria-valuetext updating in the PDOM.
 *
 * Also implements the listeners that respond to accessible input, such as keydown, keyup, input, and change
 * events, which may come from a keyboard or other assistive device. Use getAccessibleValueHandlerInputListener() to get
 * these listeners to add to your Node with addInputListener().
 *
 * Browsers have limitations for the interaction of a slider when the range is not evenly divisible by the step size.
 * Rather than allow the browser to natively change the valueProperty with an input event, this trait implements a
 * totally custom interaction keeping the general slider behavior the same.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import Utils from '../../../dot/js/Utils.js';
import assertHasProperties from '../../../phet-core/js/assertHasProperties.js';
import Orientation from '../../../phet-core/js/Orientation.js';
import { KeyboardUtils, PDOMUtils, Voicing } from '../../../scenery/js/imports.js';
import Utterance from '../../../utterance-queue/js/Utterance.js';
import sun from '../sun.js';
import optionize, { combineOptions } from '../../../phet-core/js/optionize.js';
import Multilink from '../../../axon/js/Multilink.js';
// constants
const DEFAULT_TAG_NAME = 'input';
const toString = v => `${v}`;

// Options for the Voicing response that happens at the end of
const DEFAULT_VOICING_ON_END_RESPONSE_OPTIONS = {
  withNameResponse: false,
  // no need to repeat the name every change
  withObjectResponse: true,
  // response for the new value
  onlyOnValueChange: true // no response if value did not change
};

// Function signature for voicingOnEndResponse.

// do not use ParentOptions here!
/**
 * @param Type
 * @param optionsArgPosition - zero-indexed number that the options argument is provided at
 */
const AccessibleValueHandler = (Type, optionsArgPosition) => {
  // eslint-disable-line @typescript-eslint/explicit-module-boundary-types
  return class AccessibleValueHandler extends Voicing(Type) {
    // track previous values for callbacks outside of Property listeners

    // The Property value when an interaction starts, so it can be used as the "old" value
    // when generating a context response at the end of an interaction with a11yCreateContextResponseAlert.
    // The utterance sent to the utteranceQueue when the value changes, alert content generated by
    // optional a11yCreateContextResponseAlert. The alertStableDelay on this utterance will increase if the input
    // receives many interactions before the utterance can be announced so that VoiceOver has time to read the
    // aria-valuetext (object response) before the alert (context response).
    // Number of times the input has changed in value before the utterance made was able to be spoken, only applicable
    // if using a11yCreateContextResponseAlert
    // in ms, see options for documentation.
    // Whether an input event has been handled. If handled, we will not respond to the
    // change event. An AT (particularly VoiceOver) may send a change event (and not an input event) to the
    // browser in response to a user gesture. We need to handle that change event, without also handling the
    // input event in case a device sends both events to the browser.
    // Some browsers will receive `input` events when the user tabs away from the slider or
    // on some key presses - if we receive a keydown event for a tab key, do not allow input or change events
    // setting to enable/disable rounding to the step size
    // key is the event.code for the range key, value is whether it is down
    // When context responses are supported, this counter is used to determine a mutable delay between hearing the
    // same response.
    // Options for the Voicing response at the end of interaction with this component.
    constructor(...args) {
      const providedOptions = args[optionsArgPosition];
      assert && assert(providedOptions, 'providedOptions has required options');
      assert && assert(providedOptions.enabledRangeProperty, 'enabledRangeProperty is a required option');
      assert && assert(providedOptions.valueProperty, 'valueProperty is a required option');
      const enabledRangeProperty = providedOptions.enabledRangeProperty;

      // if rounding to keyboard step, keyboardStep must be defined so values aren't skipped and the slider
      // doesn't get stuck while rounding to the nearest value, see https://github.com/phetsims/sun/issues/410
      if (assert && providedOptions && providedOptions.roundToStepSize) {
        assert(providedOptions.keyboardStep, 'rounding to keyboardStep, define appropriate keyboardStep to round to');
      }
      const defaults = {
        // other
        startInput: _.noop,
        endInput: _.noop,
        onInput: _.noop,
        constrainValue: _.identity,
        keyboardStep: (enabledRangeProperty.get().max - enabledRangeProperty.get().min) / 20,
        shiftKeyboardStep: (enabledRangeProperty.get().max - enabledRangeProperty.get().min) / 100,
        pageKeyboardStep: (enabledRangeProperty.get().max - enabledRangeProperty.get().min) / 10,
        ariaOrientation: Orientation.HORIZONTAL,
        panTargetNode: null,
        roundToStepSize: false,
        a11yMapPDOMValue: _.identity,
        a11yMapValue: _.identity,
        a11yRepeatEqualValueText: true,
        a11yCreateAriaValueText: toString,
        // by default make sure it returns a string
        a11yCreateContextResponseAlert: null,
        contextResponsePerValueChangeDelay: 700,
        contextResponseMaxDelay: 1500,
        a11yDependencies: [],
        voicingOnEndResponseOptions: DEFAULT_VOICING_ON_END_RESPONSE_OPTIONS,
        // @ts-expect-error - TODO: we should be able to have the public API be just null, and internally set to string, Limitation (IV), see https://github.com/phetsims/phet-core/issues/128
        tagName: DEFAULT_TAG_NAME,
        // parent options that we must provide a default to use
        inputType: null
      };
      const options = optionize()(defaults, providedOptions);
      assert && providedOptions && assert(!providedOptions.hasOwnProperty('tagName') || providedOptions.tagName === null, 'AccessibleValueHandler sets its own tagName. Only provide tagName to clear accessible content from the PDOM');

      // cannot be set by client
      assert && providedOptions && assert(!providedOptions.hasOwnProperty('inputType'), 'AccessibleValueHandler sets its own inputType.');
      options.inputType = 'range';
      args[optionsArgPosition] = options;
      super(...args);

      // members of the Node API that are used by this trait
      assertHasProperties(this, ['inputValue', 'setPDOMAttribute']);
      this._valueProperty = options.valueProperty;
      this._enabledRangeProperty = enabledRangeProperty;
      this._startInput = options.startInput;
      this._onInput = options.onInput;
      this._endInput = options.endInput;
      this._constrainValue = options.constrainValue;
      this._a11yMapValue = options.a11yMapValue;
      this._panTargetNode = options.panTargetNode;

      // initialized with setKeyboardStep which does some validating
      this._keyboardStep = defaults.keyboardStep;
      this.setKeyboardStep(options.keyboardStep);
      this._shiftKeyboardStep = defaults.shiftKeyboardStep;
      this.setShiftKeyboardStep(options.shiftKeyboardStep);
      this._pageKeyboardStep = defaults.pageKeyboardStep;
      this.setPageKeyboardStep(options.pageKeyboardStep);
      this._shiftKey = false;
      this._ariaOrientation = defaults.ariaOrientation;
      this.ariaOrientation = options.ariaOrientation;
      this._oldValue = null;
      this._valueOnStart = this._valueProperty.value;
      this._a11yCreateContextResponseAlert = options.a11yCreateContextResponseAlert;
      this._timesValueTextChangedBeforeAlerting = 0;
      this._contextResponseUtterance = new Utterance();
      this._contextResponsePerValueChangeDelay = options.contextResponsePerValueChangeDelay;
      this._contextResponseMaxDelay = options.contextResponseMaxDelay;
      this._a11yInputHandled = false;
      this._blockInput = false;
      this._rangeKeysDown = {};
      this._roundToStepSize = options.roundToStepSize;
      this._a11yMapPDOMValue = options.a11yMapPDOMValue;
      this._a11yCreateAriaValueText = options.a11yCreateAriaValueText;
      this._dependenciesMultilink = null;
      this._a11yRepeatEqualValueText = options.a11yRepeatEqualValueText;
      this._timesChangedBeforeAlerting = 0;
      this._voicingOnEndResponseOptions = options.voicingOnEndResponseOptions;

      // be called last, after options have been set to `this`.
      this.setA11yDependencies(options.a11yDependencies);

      // listeners, must be unlinked in dispose
      const enabledRangeObserver = enabledRange => {
        const mappedMin = this._getMappedValue(enabledRange.min);
        const mappedMax = this._getMappedValue(enabledRange.max);

        // pdom - update enabled slider range for AT, required for screen reader events to behave correctly
        this.setPDOMAttribute('min', mappedMin);
        this.setPDOMAttribute('max', mappedMax);

        // update the step attribute slider element - this attribute is only added because it is required to
        // receive accessibility events on all browsers, and is totally separate from the step values above that
        // will modify the valueProperty. See function for more information.
        this._updateSiblingStepAttribute();
      };
      this._enabledRangeProperty.link(enabledRangeObserver);

      // when the property changes, be sure to update the accessible input value and aria-valuetext which is read
      // by assistive technology when the value changes
      const valuePropertyListener = () => {
        const mappedValue = this._getMappedValue();

        // set the aria-valuenow attribute in case the AT requires it to read the value correctly, some may
        // fall back on this from aria-valuetext see
        // https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-valuetext_attribute#Possible_effects_on_user_agents_and_assistive_technology
        this.setPDOMAttribute('aria-valuenow', mappedValue);

        // update the PDOM input value on Property change
        this.inputValue = mappedValue;
      };
      this._valueProperty.link(valuePropertyListener);
      this._disposeAccessibleValueHandler = () => {
        this._enabledRangeProperty.unlink(enabledRangeObserver);
        this._valueProperty.unlink(valuePropertyListener);
        this._dependenciesMultilink && this._dependenciesMultilink.dispose();
        this._panTargetNode = null;
      };
    }

    /**
     * There are some features of AccessibleValueHandler that support updating when more than just the valueProperty
     * changes. Use this method to set the dependency Properties for this value handler. This will blow away the
     * previous list (like Node.children).
     */
    setA11yDependencies(dependencies) {
      assert && assert(!dependencies.includes(this._valueProperty), 'The value Property is already a dependency, and does not need to be added to this list');

      // dispose the previous multilink, there is only one set of dependencies, though they can be overwritten.
      this._dependenciesMultilink && this._dependenciesMultilink.dispose();
      this._dependenciesMultilink = Multilink.multilinkAny(dependencies.concat([this._valueProperty]), () => {
        this._updateAriaValueText(this._oldValue);
        this._oldValue = this._valueProperty.value;
      });
    }
    _updateAriaValueText(oldPropertyValue) {
      const mappedValue = this._getMappedValue();

      // create the dynamic aria-valuetext from a11yCreateAriaValueText.
      const newAriaValueTextValueType = this._a11yCreateAriaValueText(mappedValue, this._valueProperty.value, oldPropertyValue);
      let newAriaValueText = PDOMUtils.unwrapStringProperty(newAriaValueTextValueType);

      // eslint-disable-next-line no-simple-type-checking-assertions
      assert && assert(typeof newAriaValueText === 'string');

      // Make sure that the new aria-valuetext is different from the previous one, so that if they are the same
      // the screen reader will still read the new text - adding a hairSpace registers as a new string, but the
      // screen reader won't read that character.
      const hairSpace = '\u200A';
      if (this._a11yRepeatEqualValueText && this.ariaValueText && newAriaValueText === this.ariaValueText.replace(new RegExp(hairSpace, 'g'), '')) {
        newAriaValueText = this.ariaValueText + hairSpace;
      }
      this.ariaValueText = newAriaValueText;
    }

    /**
     * If generating an alert when the user changes the slider value, create the alert content and send it
     * to the utteranceQueue. For VoiceOver, it is important that if the value is changed multiple times before
     * the alert can be spoken, we provide more time for the AT to finish speaking aria-valuetext. Otherwise, the
     * alert may be lost. See https://github.com/phetsims/gravity-force-lab-basics/issues/146.
     */
    alertContextResponse() {
      // Alerting will occur to each connected display's UtteranceQueue, but we should only increment delay once per
      // time this function is called.
      let timesChangedBeforeAlertingIncremented = false;
      if (this._a11yCreateContextResponseAlert) {
        const mappedValue = this._getMappedValue();
        const endInteractionAlert = this._a11yCreateContextResponseAlert(mappedValue, this._valueProperty.value, this._valueOnStart);

        // only if it returned an alert
        if (endInteractionAlert) {
          this._contextResponseUtterance.alert = endInteractionAlert;
          this.forEachUtteranceQueue(utteranceQueue => {
            // Only increment a single time, this has the constraint that if different utteranceQueues move this
            // alert through at a different time, the delay could be inconsistent, but in general it should work well.
            if (timesChangedBeforeAlertingIncremented) {
              // use the current value for this._timesChangedBeforeAlerting
            } else if (utteranceQueue.hasUtterance(this._contextResponseUtterance)) {
              timesChangedBeforeAlertingIncremented = true;
              this._timesChangedBeforeAlerting++;
            } else {
              this._timesChangedBeforeAlerting = 1;
            }

            // Adjust the delay of the utterance based on number of times it has been re-added to the queue. Each
            // time the aria-valuetext changes, this method is called, we want to make sure to give enough time for the
            // aria-valuetext to fully complete before alerting this context response.
            this._contextResponseUtterance.alertStableDelay = Math.min(this._contextResponseMaxDelay, this._timesChangedBeforeAlerting * this._contextResponsePerValueChangeDelay);
            utteranceQueue.addToBack(this._contextResponseUtterance);
          });
        }
      }
    }

    /**
     * Should be called after the model dependencies have been reset
     */
    reset() {
      // reset the aria-valuetext creator if it supports that
      this._a11yCreateAriaValueText.reset && this._a11yCreateAriaValueText.reset();
      this._a11yCreateContextResponseAlert && this._a11yCreateContextResponseAlert.reset && this._a11yCreateContextResponseAlert.reset();
      this._timesChangedBeforeAlerting = 0;
      // on reset, make sure that the PDOM descriptions are completely up to date.
      this._updateAriaValueText(null);
    }

    /**
     * get the formatted value based on the current value of the Property.
     * @param [value] - if not provided, will use the current value of the valueProperty
     */
    _getMappedValue(value = this._valueProperty.value) {
      const mappedValue = this._a11yMapPDOMValue(value);
      return mappedValue;
    }

    /**
     * Return the input listener that could be attached to mixed in types of AccessibleValueHandler to support
     * interaction.
     */
    getAccessibleValueHandlerInputListener() {
      return {
        keydown: this.handleKeyDown.bind(this),
        keyup: this.handleKeyUp.bind(this),
        input: this.handleInput.bind(this),
        change: this.handleChange.bind(this),
        blur: this.handleBlur.bind(this)
      };
    }

    /**
     * Handle a keydown event so that the value handler behaves like a traditional input that modifies
     * a number. We expect the following:
     *   - Up Arrow/Right Arrow increments value by keyboardStep
     *   - Down Arrow/Left Arrow decrements value by step size
     *   - Page up/Page down will increment/decrement value pageKeyboardStep
     *   - Home/End will set value to min/max value for the range
     *   - Pressing shift with an arrow key will increment/decrement value by shiftKeyboardStep
     *
     * Add this as an input listener to the `keydown` event to the Node mixing in AccessibleValueHandler.
     */
    handleKeyDown(event) {
      const domEvent = event.domEvent;
      const key = KeyboardUtils.getEventCode(domEvent);
      if (!key) {
        return;
      }
      this._shiftKey = domEvent.shiftKey;

      // if we receive a 'tab' keydown event, do not allow the browser to react to this like a submission and
      // prevent responding to the `input` event
      if (KeyboardUtils.isKeyEvent(domEvent, KeyboardUtils.KEY_TAB)) {
        this._blockInput = true;
      }
      if (this.enabledProperty.get()) {
        // Prevent default so browser doesn't change input value automatically
        if (KeyboardUtils.isRangeKey(domEvent)) {
          // This should prevent any "change" and "input" events so we don't change the value twice, but it also
          // prevents a VoiceOver issue where pressing arrow keys both changes the slider value AND moves the
          // virtual cursor. This needs to be done every range key event so that we don't change the value with
          // an 'input' or 'change' event, even when the meta key is down.
          domEvent.preventDefault();

          // On Mac, we don't get a keyup event when the meta key is down so don't change the value or do
          // anything that assumes we will get a corresponding keyup event, see
          // https://stackoverflow.com/questions/11818637/why-does-javascript-drop-keyup-events-when-the-metakey-is-pressed-on-mac-browser
          if (!domEvent.metaKey) {
            // signify that this listener is reserved for dragging so that other listeners can change
            // their behavior during scenery event dispatch
            event.pointer.reserveForKeyboardDrag();

            // whether we will use constrainValue to modify the proposed value, see usages below
            let useConstrainValue = true;

            // if this is the first keydown this is the start of the drag interaction
            if (!this._anyKeysDown()) {
              this._onInteractionStart(event);
            }

            // track that a new key is being held down
            this._rangeKeysDown[key] = true;
            let newValue = this._valueProperty.get();
            if (KeyboardUtils.isAnyKeyEvent(domEvent, [KeyboardUtils.KEY_END, KeyboardUtils.KEY_HOME])) {
              // on 'end' and 'home' snap to max and min of enabled range respectively (this is typical browser
              // behavior for sliders)
              if (key === KeyboardUtils.KEY_END) {
                newValue = this._enabledRangeProperty.get().max;
              } else if (key === KeyboardUtils.KEY_HOME) {
                newValue = this._enabledRangeProperty.get().min;
              }
            } else {
              let stepSize;
              if (key === KeyboardUtils.KEY_PAGE_UP || key === KeyboardUtils.KEY_PAGE_DOWN) {
                // on page up and page down, the default step size is 1/10 of the range (this is typical browser behavior)
                stepSize = this.pageKeyboardStep;
                if (key === KeyboardUtils.KEY_PAGE_UP) {
                  newValue = this._valueProperty.get() + stepSize;
                } else if (key === KeyboardUtils.KEY_PAGE_DOWN) {
                  newValue = this._valueProperty.get() - stepSize;
                }
              } else if (KeyboardUtils.isArrowKey(domEvent)) {
                // if the shift key is pressed down, modify the step size (this is atypical browser behavior for sliders)
                stepSize = domEvent.shiftKey ? this.shiftKeyboardStep : this.keyboardStep;

                // Temporary workaround, if using shift key with arrow keys to use the shiftKeyboardStep, don't
                // use constrainValue because the constrainValue is often smaller than the values allowed by
                // constrainValue. See https://github.com/phetsims/sun/issues/698.
                useConstrainValue = !domEvent.shiftKey;
                if (key === KeyboardUtils.KEY_RIGHT_ARROW || key === KeyboardUtils.KEY_UP_ARROW) {
                  newValue = this._valueProperty.get() + stepSize;
                } else if (key === KeyboardUtils.KEY_LEFT_ARROW || key === KeyboardUtils.KEY_DOWN_ARROW) {
                  newValue = this._valueProperty.get() - stepSize;
                }
                if (this._roundToStepSize) {
                  newValue = roundValue(newValue, this._valueProperty.get(), stepSize);
                }
              }
            }

            // Map the value.
            const mappedValue = this._a11yMapValue(newValue, this._valueProperty.get());

            // Optionally constrain the value. Only constrain if modifying by shiftKeyboardStep because that step size
            // may allow finer precision than constrainValue. This is a workaround for
            // https://github.com/phetsims/sun/issues/698, and is actually a problem for all keyboard steps if they
            // are smaller than values allowed by constrainValue. In https://github.com/phetsims/sun/issues/703 we
            // will work to resolve this more generally.
            let constrainedValue = mappedValue;
            if (useConstrainValue) {
              constrainedValue = this._constrainValue(mappedValue);
            }

            // limit the value to the enabled range
            this._valueProperty.set(Utils.clamp(constrainedValue, this._enabledRangeProperty.get().min, this._enabledRangeProperty.get().max));

            // optional callback after the valueProperty is set (even if set to the same value) so that the listener
            // can use the new value.
            this._onInput(event);
          }
        }
      }
    }

    /**
     * Handle key up event on this accessible slider, managing the shift key, and calling an optional endDrag
     * function on release. Add this as an input listener to the node mixing in AccessibleValueHandler.
     */
    handleKeyUp(event) {
      const key = KeyboardUtils.getEventCode(event.domEvent);

      // handle case where user tabbed to this input while an arrow key might have been held down
      if (this._allKeysUp()) {
        return;
      }

      // reset shift key flag when we release it
      if (KeyboardUtils.SHIFT_KEYS.includes(key)) {
        this._shiftKey = false;
      }
      if (this.enabledProperty.get()) {
        if (KeyboardUtils.isRangeKey(event.domEvent)) {
          this._rangeKeysDown[key] = false;

          // when all range keys are released, we are done dragging
          if (this._allKeysUp()) {
            this._onInteractionEnd(event);
          }
        }
      }
    }

    /**
     * VoiceOver sends a "change" event to the slider (NOT an input event), so we need to handle the case when
     * a change event is sent but an input event ins't handled. Guarded against the case that BOTH change and
     * input are sent to the browser by the AT.
     *
     * Add this as a listener to the 'change' input event on the Node that is mixing in AccessibleValueHandler.
     */
    handleChange(event) {
      if (!this._a11yInputHandled) {
        this.handleInput(event);
      }
      this._a11yInputHandled = false;
    }

    /**
     * Handle a direct 'input' event that might come from assistive technology. It is possible that the user agent
     * (particularly VoiceOver, or a switch device) will initiate an input event directly without going through
     * keydown. In that case, handle the change depending on which direction the user tried to go. We determine
     * this by detecting how the input value changed in response to the `input` event relative to the current
     * value of the valueProperty.
     *
     * Note that it is important to handle the "input" event, rather than the "change" event. The "input" will
     * fire when the value changes from a gesture, while the "change" will only happen on submission, like as
     * navigating away from the element.
     *
     * Add this as a listener to the `input` event on the Node that is mixing in AccessibleValueHandler.
     */
    handleInput(event) {
      if (this.enabledProperty.get() && !this._blockInput) {
        // don't handle again on "change" event
        this._a11yInputHandled = true;
        let newValue = this._valueProperty.get();
        const inputValue = parseFloat(event.domEvent.target.value);
        const stepSize = this._shiftKey ? this.shiftKeyboardStep : this.keyboardStep;
        const mappedValue = this._getMappedValue();

        // start of change event is start of drag
        this._onInteractionStart(event);
        if (inputValue > mappedValue) {
          newValue = this._valueProperty.get() + stepSize;
        } else if (inputValue < mappedValue) {
          newValue = this._valueProperty.get() - stepSize;
        }
        if (this._roundToStepSize) {
          newValue = roundValue(newValue, this._valueProperty.get(), stepSize);
        }

        // limit to enabled range
        newValue = Utils.clamp(newValue, this._enabledRangeProperty.get().min, this._enabledRangeProperty.get().max);

        // optionally constrain value
        this._valueProperty.set(this._constrainValue(this._a11yMapValue(newValue, this._valueProperty.get())));

        // only one change per input, but still call optional onInput function - after valueProperty is set (even if
        // set to the same value) so listener can use new value.
        this._onInput(event);

        // end of change is the end of a drag
        this._onInteractionEnd(event);
      }

      // don't block the next input after receiving one, some AT may send either `keydown` or `input` events
      // depending on modifier keys so we need to be ready to receive either on next interaction
      this._blockInput = false;
    }

    /**
     * Fires when the accessible slider loses focus.
     *
     * Add this as a listener on the `blur` event to the Node that is mixing in AccessibleValueHandler.
     */
    handleBlur(event) {
      // if any range keys are currently down, call end drag because user has stopped dragging to do something else
      if (this._anyKeysDown()) {
        this._onInteractionEnd(event);
      }

      // reset flag in case we shift-tabbed away from slider
      this._shiftKey = false;

      // when focus leaves this element stop blocking input events
      this._blockInput = false;

      // reset counter for range keys down
      this._rangeKeysDown = {};
    }

    /**
     * Interaction with this input has started, save the value on start so that it can be used as an "old" value
     * when generating the context response with option a11yCreateContextResponse.
     */
    _onInteractionStart(event) {
      this._valueOnStart = this._valueProperty.value;
      this._startInput(event);
    }

    /**
     * Interaction with this input has completed, generate an utterance describing changes if necessary and call
     * optional "end" function.
     */
    _onInteractionEnd(event) {
      this.alertContextResponse();
      this.voicingOnEndResponse(this._valueOnStart);
      this._endInput(event);
    }

    /**
     * Set the delta for the value Property when using arrow keys to interact with the Node.
     */
    setKeyboardStep(keyboardStep) {
      assert && assert(keyboardStep >= 0, 'keyboard step must be non-negative');
      this._keyboardStep = keyboardStep;
    }
    set keyboardStep(keyboardStep) {
      this.setKeyboardStep(keyboardStep);
    }
    get keyboardStep() {
      return this.getKeyboardStep();
    }

    /**
     * Get the delta for value Property when using arrow keys.
     */
    getKeyboardStep() {
      return this._keyboardStep;
    }

    /**
     * Set the delta for value Property when using arrow keys with shift to interact with the Node.
     */
    setShiftKeyboardStep(shiftKeyboardStep) {
      assert && assert(shiftKeyboardStep >= 0, 'shift keyboard step must be non-negative');
      this._shiftKeyboardStep = shiftKeyboardStep;
    }
    set shiftKeyboardStep(shiftKeyboardStep) {
      this.setShiftKeyboardStep(shiftKeyboardStep);
    }
    get shiftKeyboardStep() {
      return this.getShiftKeyboardStep();
    }

    /**
     * Get the delta for value Property when using arrow keys with shift to interact with the Node.
     */
    getShiftKeyboardStep() {
      return this._shiftKeyboardStep;
    }

    /**
     * Returns whether the shift key is currently held down on this slider, changing the size of step.
     */
    getShiftKeyDown() {
      return this._shiftKey;
    }
    get shiftKeyDown() {
      return this.getShiftKeyDown();
    }

    /**
     * Set the delta for value Property when using page up/page down to interact with the Node.
     */
    setPageKeyboardStep(pageKeyboardStep) {
      assert && assert(pageKeyboardStep >= 0, 'page keyboard step must be non-negative');
      this._pageKeyboardStep = pageKeyboardStep;
    }
    set pageKeyboardStep(pageKeyboardStep) {
      this.setPageKeyboardStep(pageKeyboardStep);
    }
    get pageKeyboardStep() {
      return this.getPageKeyboardStep();
    }

    /**
     * Get the delta for value Property when using page up/page down to interact with the Node.
     */
    getPageKeyboardStep() {
      return this._pageKeyboardStep;
    }

    /**
     * Set the orientation for the slider as specified by https://www.w3.org/TR/wai-aria-1.1/#aria-orientation.
     * Depending on the value of this attribute, a screen reader will give different indications about which
     * arrow keys should be used
     */
    setAriaOrientation(orientation) {
      this._ariaOrientation = orientation;
      this.setPDOMAttribute('aria-orientation', orientation.ariaOrientation);
    }
    set ariaOrientation(orientation) {
      this.setAriaOrientation(orientation);
    }
    get ariaOrientation() {
      return this._ariaOrientation;
    }

    /**
     * Get the orientation of the accessible slider, see setAriaOrientation for information on the behavior of this
     * attribute.
     */
    getAriaOrientation() {
      return this._ariaOrientation;
    }

    /**
     * Returns true if all range keys are currently up (not held down).
     */
    _allKeysUp() {
      return _.every(this._rangeKeysDown, entry => !entry);
    }

    /**
     * Returns true if any range keys are currently down on this slider. Useful for determining when to call
     * startDrag or endDrag based on interaction.
     */
    _anyKeysDown() {
      return !!_.find(this._rangeKeysDown, entry => entry);
    }

    /**
     * Set the `step` attribute on accessible siblings for this Node. The step attribute must be non zero
     * for the accessible input to receive accessibility events and only certain slider input values are
     * allowed depending on `step`, `min`, and `max` attributes. Only values which are equal to min value plus
     * the basis of step are allowed. In other words, the following must always be true:
     * value = min + n * step where value <= max and n is an integer.
     *
     * If the input value is set to anything else, the result is confusing
     * keyboard behavior and the screen reader will say "Invalid" when the value changes.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number#step
     *
     * This limitation is too restrictive for PhET as many sliders span physical ranges with keyboard steps that
     * are design to be convenient or pedagogically useful. For example, a slider that spans 0.01 to 15 requires
     * a step of 1, but DOM specification would only allow values 0.01, 1.01, 2.01, ...
     * This restriction is why `step` attribute cannot equal keyboardStep of this trait.
     *
     * We tried to use the `any` attribute which is valid according to DOM specification but screen readers
     * generally don't support it. See https://github.com/phetsims/sun/issues/413.
     *
     * Also, if the step attribute is too small relative to the entire range of the slider VoiceOver doesn't allow
     * any input events because...VoiceOver is just interesting like that.
     *
     * Current workaround for all of this is to set the step size to support the precision of the value required
     * by the client so that all values are allowed. If we encounter the VoiceOver case described above we fall
     * back to setting the step size at 1/100th of the max value since the keyboard step generally evenly divides
     * the max value rather than the full range.
     */
    _updateSiblingStepAttribute() {
      const smallestStep = Math.min(this.keyboardStep, this.shiftKeyboardStep, this.pageKeyboardStep);
      let stepValue = Math.pow(10, -Utils.numberOfDecimalPlaces(smallestStep));
      const mappedMin = this._getMappedValue(this._enabledRangeProperty.get().min);
      const mappedMax = this._getMappedValue(this._enabledRangeProperty.get().max);
      const mappedLength = mappedMax - mappedMin;

      // step is too small relative to full range for VoiceOver to receive input, fall back to portion of
      // the max value as a workaround
      if (stepValue / mappedLength < 1e-5) {
        stepValue = mappedMax / 100;
      }
      this.setPDOMAttribute('step', stepValue);
    }

    /**
     * Call this to trigger the voicing response spoken when an interaction ends. Will speak the current
     * name and object responses (according to options). Set those responses of Voicing.ts to hear up-to-date
     * Voicing responses at the end of an interaction.
     *
     * @param valueOnStart - Property value at the start of the interaction.
     * @param providedOptions
     */
    voicingOnEndResponse(valueOnStart, providedOptions) {
      const options = combineOptions({}, this._voicingOnEndResponseOptions, providedOptions);
      const valueChanged = valueOnStart !== this._valueProperty.value;
      const valueAtMinMax = this._valueProperty.value === this._enabledRangeProperty.value.min || this._valueProperty.value === this._enabledRangeProperty.value.max;

      // content required to speak a response and add to back of UtteranceQueue.
      const responseContentExists = !!(options.withNameResponse && this.voicingNameResponse) || !!(options.withObjectResponse && this.voicingObjectResponse);
      const shouldSpeak = (!options.onlyOnValueChange ||
      // speak each time if onlyOnValueChange is false.
      valueAtMinMax ||
      // always speak at edges, for "go beyond" responses
      valueChanged) &&
      // If the value changed
      responseContentExists;
      shouldSpeak && this.voicingSpeakFullResponse({
        nameResponse: options.withNameResponse ? this.voicingNameResponse : null,
        objectResponse: options.withObjectResponse ? this.voicingObjectResponse : null,
        hintResponse: null // no hint, there was just a successful interaction
      });
    }

    dispose() {
      this._disposeAccessibleValueHandler();
      super.dispose();
    }
  };
};
sun.register('AccessibleValueHandler', AccessibleValueHandler);

/**
 * Round the value to the nearest step size.
 *
 * @param newValue - value to be rounded
 * @param currentValue - current value of the Property associated with this slider
 * @param stepSize - the delta for this manipulation
 */
const roundValue = function (newValue, currentValue, stepSize) {
  let roundValue = newValue;
  if (stepSize !== 0) {
    // round the value to the nearest keyboard step
    roundValue = Utils.roundSymmetric(roundValue / stepSize) * stepSize;

    // go back a step if we went too far due to rounding
    roundValue = correctRounding(roundValue, currentValue, stepSize);
  }
  return roundValue;
};

/**
 * Helper function, it is possible due to rounding to go up or down a step if we have passed the nearest step during
 * keyboard interaction. This function corrects that.
 *
 */
const correctRounding = function (newValue, currentValue, stepSize) {
  let correctedValue = newValue;
  const proposedStep = Math.abs(newValue - currentValue);
  const stepToFar = proposedStep > stepSize;

  // it is possible that proposedStep will be larger than the stepSize but only because of precision
  // constraints with floating point values, don't correct if that is the cases
  const stepsAboutEqual = Utils.equalsEpsilon(proposedStep, stepSize, 1e-14);
  if (stepToFar && !stepsAboutEqual) {
    correctedValue += newValue > currentValue ? -stepSize : stepSize;
  }
  return correctedValue;
};
AccessibleValueHandler.DEFAULT_TAG_NAME = DEFAULT_TAG_NAME;
export default AccessibleValueHandler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJVdGlscyIsImFzc2VydEhhc1Byb3BlcnRpZXMiLCJPcmllbnRhdGlvbiIsIktleWJvYXJkVXRpbHMiLCJQRE9NVXRpbHMiLCJWb2ljaW5nIiwiVXR0ZXJhbmNlIiwic3VuIiwib3B0aW9uaXplIiwiY29tYmluZU9wdGlvbnMiLCJNdWx0aWxpbmsiLCJERUZBVUxUX1RBR19OQU1FIiwidG9TdHJpbmciLCJ2IiwiREVGQVVMVF9WT0lDSU5HX09OX0VORF9SRVNQT05TRV9PUFRJT05TIiwid2l0aE5hbWVSZXNwb25zZSIsIndpdGhPYmplY3RSZXNwb25zZSIsIm9ubHlPblZhbHVlQ2hhbmdlIiwiQWNjZXNzaWJsZVZhbHVlSGFuZGxlciIsIlR5cGUiLCJvcHRpb25zQXJnUG9zaXRpb24iLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJwcm92aWRlZE9wdGlvbnMiLCJhc3NlcnQiLCJlbmFibGVkUmFuZ2VQcm9wZXJ0eSIsInZhbHVlUHJvcGVydHkiLCJyb3VuZFRvU3RlcFNpemUiLCJrZXlib2FyZFN0ZXAiLCJkZWZhdWx0cyIsInN0YXJ0SW5wdXQiLCJfIiwibm9vcCIsImVuZElucHV0Iiwib25JbnB1dCIsImNvbnN0cmFpblZhbHVlIiwiaWRlbnRpdHkiLCJnZXQiLCJtYXgiLCJtaW4iLCJzaGlmdEtleWJvYXJkU3RlcCIsInBhZ2VLZXlib2FyZFN0ZXAiLCJhcmlhT3JpZW50YXRpb24iLCJIT1JJWk9OVEFMIiwicGFuVGFyZ2V0Tm9kZSIsImExMXlNYXBQRE9NVmFsdWUiLCJhMTF5TWFwVmFsdWUiLCJhMTF5UmVwZWF0RXF1YWxWYWx1ZVRleHQiLCJhMTF5Q3JlYXRlQXJpYVZhbHVlVGV4dCIsImExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydCIsImNvbnRleHRSZXNwb25zZVBlclZhbHVlQ2hhbmdlRGVsYXkiLCJjb250ZXh0UmVzcG9uc2VNYXhEZWxheSIsImExMXlEZXBlbmRlbmNpZXMiLCJ2b2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnMiLCJ0YWdOYW1lIiwiaW5wdXRUeXBlIiwib3B0aW9ucyIsImhhc093blByb3BlcnR5IiwiX3ZhbHVlUHJvcGVydHkiLCJfZW5hYmxlZFJhbmdlUHJvcGVydHkiLCJfc3RhcnRJbnB1dCIsIl9vbklucHV0IiwiX2VuZElucHV0IiwiX2NvbnN0cmFpblZhbHVlIiwiX2ExMXlNYXBWYWx1ZSIsIl9wYW5UYXJnZXROb2RlIiwiX2tleWJvYXJkU3RlcCIsInNldEtleWJvYXJkU3RlcCIsIl9zaGlmdEtleWJvYXJkU3RlcCIsInNldFNoaWZ0S2V5Ym9hcmRTdGVwIiwiX3BhZ2VLZXlib2FyZFN0ZXAiLCJzZXRQYWdlS2V5Ym9hcmRTdGVwIiwiX3NoaWZ0S2V5IiwiX2FyaWFPcmllbnRhdGlvbiIsIl9vbGRWYWx1ZSIsIl92YWx1ZU9uU3RhcnQiLCJ2YWx1ZSIsIl9hMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnQiLCJfdGltZXNWYWx1ZVRleHRDaGFuZ2VkQmVmb3JlQWxlcnRpbmciLCJfY29udGV4dFJlc3BvbnNlVXR0ZXJhbmNlIiwiX2NvbnRleHRSZXNwb25zZVBlclZhbHVlQ2hhbmdlRGVsYXkiLCJfY29udGV4dFJlc3BvbnNlTWF4RGVsYXkiLCJfYTExeUlucHV0SGFuZGxlZCIsIl9ibG9ja0lucHV0IiwiX3JhbmdlS2V5c0Rvd24iLCJfcm91bmRUb1N0ZXBTaXplIiwiX2ExMXlNYXBQRE9NVmFsdWUiLCJfYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQiLCJfZGVwZW5kZW5jaWVzTXVsdGlsaW5rIiwiX2ExMXlSZXBlYXRFcXVhbFZhbHVlVGV4dCIsIl90aW1lc0NoYW5nZWRCZWZvcmVBbGVydGluZyIsIl92b2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnMiLCJzZXRBMTF5RGVwZW5kZW5jaWVzIiwiZW5hYmxlZFJhbmdlT2JzZXJ2ZXIiLCJlbmFibGVkUmFuZ2UiLCJtYXBwZWRNaW4iLCJfZ2V0TWFwcGVkVmFsdWUiLCJtYXBwZWRNYXgiLCJzZXRQRE9NQXR0cmlidXRlIiwiX3VwZGF0ZVNpYmxpbmdTdGVwQXR0cmlidXRlIiwibGluayIsInZhbHVlUHJvcGVydHlMaXN0ZW5lciIsIm1hcHBlZFZhbHVlIiwiaW5wdXRWYWx1ZSIsIl9kaXNwb3NlQWNjZXNzaWJsZVZhbHVlSGFuZGxlciIsInVubGluayIsImRpc3Bvc2UiLCJkZXBlbmRlbmNpZXMiLCJpbmNsdWRlcyIsIm11bHRpbGlua0FueSIsImNvbmNhdCIsIl91cGRhdGVBcmlhVmFsdWVUZXh0Iiwib2xkUHJvcGVydHlWYWx1ZSIsIm5ld0FyaWFWYWx1ZVRleHRWYWx1ZVR5cGUiLCJuZXdBcmlhVmFsdWVUZXh0IiwidW53cmFwU3RyaW5nUHJvcGVydHkiLCJoYWlyU3BhY2UiLCJhcmlhVmFsdWVUZXh0IiwicmVwbGFjZSIsIlJlZ0V4cCIsImFsZXJ0Q29udGV4dFJlc3BvbnNlIiwidGltZXNDaGFuZ2VkQmVmb3JlQWxlcnRpbmdJbmNyZW1lbnRlZCIsImVuZEludGVyYWN0aW9uQWxlcnQiLCJhbGVydCIsImZvckVhY2hVdHRlcmFuY2VRdWV1ZSIsInV0dGVyYW5jZVF1ZXVlIiwiaGFzVXR0ZXJhbmNlIiwiYWxlcnRTdGFibGVEZWxheSIsIk1hdGgiLCJhZGRUb0JhY2siLCJyZXNldCIsImdldEFjY2Vzc2libGVWYWx1ZUhhbmRsZXJJbnB1dExpc3RlbmVyIiwia2V5ZG93biIsImhhbmRsZUtleURvd24iLCJiaW5kIiwia2V5dXAiLCJoYW5kbGVLZXlVcCIsImlucHV0IiwiaGFuZGxlSW5wdXQiLCJjaGFuZ2UiLCJoYW5kbGVDaGFuZ2UiLCJibHVyIiwiaGFuZGxlQmx1ciIsImV2ZW50IiwiZG9tRXZlbnQiLCJrZXkiLCJnZXRFdmVudENvZGUiLCJzaGlmdEtleSIsImlzS2V5RXZlbnQiLCJLRVlfVEFCIiwiZW5hYmxlZFByb3BlcnR5IiwiaXNSYW5nZUtleSIsInByZXZlbnREZWZhdWx0IiwibWV0YUtleSIsInBvaW50ZXIiLCJyZXNlcnZlRm9yS2V5Ym9hcmREcmFnIiwidXNlQ29uc3RyYWluVmFsdWUiLCJfYW55S2V5c0Rvd24iLCJfb25JbnRlcmFjdGlvblN0YXJ0IiwibmV3VmFsdWUiLCJpc0FueUtleUV2ZW50IiwiS0VZX0VORCIsIktFWV9IT01FIiwic3RlcFNpemUiLCJLRVlfUEFHRV9VUCIsIktFWV9QQUdFX0RPV04iLCJpc0Fycm93S2V5IiwiS0VZX1JJR0hUX0FSUk9XIiwiS0VZX1VQX0FSUk9XIiwiS0VZX0xFRlRfQVJST1ciLCJLRVlfRE9XTl9BUlJPVyIsInJvdW5kVmFsdWUiLCJjb25zdHJhaW5lZFZhbHVlIiwic2V0IiwiY2xhbXAiLCJfYWxsS2V5c1VwIiwiU0hJRlRfS0VZUyIsIl9vbkludGVyYWN0aW9uRW5kIiwicGFyc2VGbG9hdCIsInRhcmdldCIsInZvaWNpbmdPbkVuZFJlc3BvbnNlIiwiZ2V0S2V5Ym9hcmRTdGVwIiwiZ2V0U2hpZnRLZXlib2FyZFN0ZXAiLCJnZXRTaGlmdEtleURvd24iLCJzaGlmdEtleURvd24iLCJnZXRQYWdlS2V5Ym9hcmRTdGVwIiwic2V0QXJpYU9yaWVudGF0aW9uIiwib3JpZW50YXRpb24iLCJnZXRBcmlhT3JpZW50YXRpb24iLCJldmVyeSIsImVudHJ5IiwiZmluZCIsInNtYWxsZXN0U3RlcCIsInN0ZXBWYWx1ZSIsInBvdyIsIm51bWJlck9mRGVjaW1hbFBsYWNlcyIsIm1hcHBlZExlbmd0aCIsInZhbHVlT25TdGFydCIsInZhbHVlQ2hhbmdlZCIsInZhbHVlQXRNaW5NYXgiLCJyZXNwb25zZUNvbnRlbnRFeGlzdHMiLCJ2b2ljaW5nTmFtZVJlc3BvbnNlIiwidm9pY2luZ09iamVjdFJlc3BvbnNlIiwic2hvdWxkU3BlYWsiLCJ2b2ljaW5nU3BlYWtGdWxsUmVzcG9uc2UiLCJuYW1lUmVzcG9uc2UiLCJvYmplY3RSZXNwb25zZSIsImhpbnRSZXNwb25zZSIsInJlZ2lzdGVyIiwiY3VycmVudFZhbHVlIiwicm91bmRTeW1tZXRyaWMiLCJjb3JyZWN0Um91bmRpbmciLCJjb3JyZWN0ZWRWYWx1ZSIsInByb3Bvc2VkU3RlcCIsImFicyIsInN0ZXBUb0ZhciIsInN0ZXBzQWJvdXRFcXVhbCIsImVxdWFsc0Vwc2lsb24iXSwic291cmNlcyI6WyJBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE5LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgdHJhaXQgZm9yIHN1YnR5cGVzIG9mIE5vZGUuIE1lYW50IGZvciBOb2RlcyB3aXRoIGEgdmFsdWUgdGhhdCBcInJ1blwiIG9uIGEgTnVtYmVyUHJvcGVydHkgYW5kIGhhbmRsZXMgZm9ybWF0dGluZyxcclxuICogbWFwcGluZywgYW5kIGFyaWEtdmFsdWV0ZXh0IHVwZGF0aW5nIGluIHRoZSBQRE9NLlxyXG4gKlxyXG4gKiBBbHNvIGltcGxlbWVudHMgdGhlIGxpc3RlbmVycyB0aGF0IHJlc3BvbmQgdG8gYWNjZXNzaWJsZSBpbnB1dCwgc3VjaCBhcyBrZXlkb3duLCBrZXl1cCwgaW5wdXQsIGFuZCBjaGFuZ2VcclxuICogZXZlbnRzLCB3aGljaCBtYXkgY29tZSBmcm9tIGEga2V5Ym9hcmQgb3Igb3RoZXIgYXNzaXN0aXZlIGRldmljZS4gVXNlIGdldEFjY2Vzc2libGVWYWx1ZUhhbmRsZXJJbnB1dExpc3RlbmVyKCkgdG8gZ2V0XHJcbiAqIHRoZXNlIGxpc3RlbmVycyB0byBhZGQgdG8geW91ciBOb2RlIHdpdGggYWRkSW5wdXRMaXN0ZW5lcigpLlxyXG4gKlxyXG4gKiBCcm93c2VycyBoYXZlIGxpbWl0YXRpb25zIGZvciB0aGUgaW50ZXJhY3Rpb24gb2YgYSBzbGlkZXIgd2hlbiB0aGUgcmFuZ2UgaXMgbm90IGV2ZW5seSBkaXZpc2libGUgYnkgdGhlIHN0ZXAgc2l6ZS5cclxuICogUmF0aGVyIHRoYW4gYWxsb3cgdGhlIGJyb3dzZXIgdG8gbmF0aXZlbHkgY2hhbmdlIHRoZSB2YWx1ZVByb3BlcnR5IHdpdGggYW4gaW5wdXQgZXZlbnQsIHRoaXMgdHJhaXQgaW1wbGVtZW50cyBhXHJcbiAqIHRvdGFsbHkgY3VzdG9tIGludGVyYWN0aW9uIGtlZXBpbmcgdGhlIGdlbmVyYWwgc2xpZGVyIGJlaGF2aW9yIHRoZSBzYW1lLlxyXG4gKlxyXG4gKiBAYXV0aG9yIE1pY2hhZWwgS2F1em1hbm4gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi8uLi9kb3QvanMvVXRpbHMuanMnO1xyXG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi4vLi4vLi4vZG90L2pzL1JhbmdlLmpzJztcclxuaW1wb3J0IGFzc2VydEhhc1Byb3BlcnRpZXMgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL2Fzc2VydEhhc1Byb3BlcnRpZXMuanMnO1xyXG5pbXBvcnQgT3JpZW50YXRpb24gZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL09yaWVudGF0aW9uLmpzJztcclxuaW1wb3J0IHsgS2V5Ym9hcmRVdGlscywgTm9kZSwgTm9kZU9wdGlvbnMsIFBET01VdGlscywgUERPTVZhbHVlVHlwZSwgU2NlbmVyeUV2ZW50LCBTY2VuZXJ5TGlzdGVuZXJGdW5jdGlvbiwgVElucHV0TGlzdGVuZXIsIFZvaWNpbmcsIFZvaWNpbmdPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IFV0dGVyYW5jZSBmcm9tICcuLi8uLi8uLi91dHRlcmFuY2UtcXVldWUvanMvVXR0ZXJhbmNlLmpzJztcclxuaW1wb3J0IHN1biBmcm9tICcuLi9zdW4uanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplLCB7IGNvbWJpbmVPcHRpb25zLCBPcHRpb25pemVEZWZhdWx0cyB9IGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgTXVsdGlsaW5rLCB7IFVua25vd25NdWx0aWxpbmsgfSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL011bHRpbGluay5qcyc7XHJcbmltcG9ydCBVdHRlcmFuY2VRdWV1ZSBmcm9tICcuLi8uLi8uLi91dHRlcmFuY2UtcXVldWUvanMvVXR0ZXJhbmNlUXVldWUuanMnO1xyXG5pbXBvcnQgVFByb3BlcnR5IGZyb20gJy4uLy4uLy4uL2F4b24vanMvVFByb3BlcnR5LmpzJztcclxuaW1wb3J0IENvbnN0cnVjdG9yIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9Db25zdHJ1Y3Rvci5qcyc7XHJcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgREVGQVVMVF9UQUdfTkFNRSA9ICdpbnB1dCc7XHJcbmNvbnN0IHRvU3RyaW5nID0gKCB2OiBJbnRlbnRpb25hbEFueSApID0+IGAke3Z9YDtcclxuXHJcbi8vIE9wdGlvbnMgZm9yIHRoZSBWb2ljaW5nIHJlc3BvbnNlIHRoYXQgaGFwcGVucyBhdCB0aGUgZW5kIG9mXHJcbmNvbnN0IERFRkFVTFRfVk9JQ0lOR19PTl9FTkRfUkVTUE9OU0VfT1BUSU9OUyA9IHtcclxuICB3aXRoTmFtZVJlc3BvbnNlOiBmYWxzZSwgLy8gbm8gbmVlZCB0byByZXBlYXQgdGhlIG5hbWUgZXZlcnkgY2hhbmdlXHJcbiAgd2l0aE9iamVjdFJlc3BvbnNlOiB0cnVlLCAvLyByZXNwb25zZSBmb3IgdGhlIG5ldyB2YWx1ZVxyXG4gIG9ubHlPblZhbHVlQ2hhbmdlOiB0cnVlIC8vIG5vIHJlc3BvbnNlIGlmIHZhbHVlIGRpZCBub3QgY2hhbmdlXHJcbn07XHJcblxyXG50eXBlIENyZWF0ZVRleHRGdW5jdGlvbiA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHBkb21NYXBwZWRWYWx1ZSAtIHNlZVxyXG4gICAqIEBwYXJhbSBuZXdWYWx1ZSAtIHRoZSBuZXcgdmFsdWUsIHVuZm9ybWF0dGVkXHJcbiAgICogQHBhcmFtIHByZXZpb3VzVmFsdWUgLSBqdXN0IHRoZSBcIm9sZFZhbHVlXCIgZnJvbSB0aGUgUHJvcGVydHkgbGlzdGVuZXJcclxuICAgKiBAcmV0dXJucyAtIHRleHQvcmVzcG9uc2Uvc3RyaW5nIHRvIGJlIHNldCB0byB0aGUgcHJpbWFyeVNpYmxpbmcsIG51bGwgbWVhbnMgbm90aGluZyB3aWxsIGhhcHBlblxyXG4gICAqICovXHJcbiAgKCBwZG9tTWFwcGVkVmFsdWU6IG51bWJlciwgbmV3VmFsdWU6IG51bWJlciwgcHJldmlvdXNWYWx1ZTogbnVtYmVyIHwgbnVsbCApOiBQRE9NVmFsdWVUeXBlIHwgbnVsbDtcclxuXHJcbiAgLy8gaWYgdGhpcyBmdW5jdGlvbiBuZWVkcyByZXNldHRpbmcsIGluY2x1ZGUgYSBgcmVzZXRgIGZpZWxkIG9uIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlXHJcbiAgLy8gQWNjZXNzaWJsZVZhbHVlSGFuZGxlciBpcyByZXNldC5cclxuICByZXNldD86ICgpID0+IHZvaWQ7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBWb2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnMgPSB7XHJcblxyXG4gIC8vIFNob3VsZCB0aGUgVm9pY2luZyByZXNwb25zZSBiZSBzcG9rZW4gaWYgdGhlIGludGVyYWN0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgdmFsdWU/XHJcbiAgb25seU9uVmFsdWVDaGFuZ2U/OiBib29sZWFuO1xyXG5cclxuICAvLyBTaG91bGQgdGhlIFZvaWNpbmcgcmVzcG9uc2UgaW5jbHVkZSB0aGUgbmFtZSByZXNwb25zZT9cclxuICB3aXRoTmFtZVJlc3BvbnNlPzogYm9vbGVhbjtcclxuXHJcbiAgLy8gU2hvdWxkIHRoZSBWb2ljaW5nIHJlc3BvbnNlIGluY2x1ZGUgdGhlIG9iamVjdCByZXNwb25zZT9cclxuICB3aXRoT2JqZWN0UmVzcG9uc2U/OiBib29sZWFuO1xyXG59O1xyXG5cclxuLy8gRnVuY3Rpb24gc2lnbmF0dXJlIGZvciB2b2ljaW5nT25FbmRSZXNwb25zZS5cclxuZXhwb3J0IHR5cGUgVm9pY2luZ09uRW5kUmVzcG9uc2UgPSAoIHZhbHVlT25TdGFydDogbnVtYmVyLCBwcm92aWRlZE9wdGlvbnM/OiBWb2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnMgKSA9PiB2b2lkO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuICB2YWx1ZVByb3BlcnR5OiBUUHJvcGVydHk8bnVtYmVyPjtcclxuICBlbmFibGVkUmFuZ2VQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8UmFuZ2U+O1xyXG5cclxuICAvLyBjYWxsZWQgd2hlbiBpbnB1dCBiZWdpbnMgZnJvbSB1c2VyIGludGVyYWN0aW9uXHJcbiAgc3RhcnRJbnB1dD86ICggZXZlbnQ6IFNjZW5lcnlFdmVudCApID0+IHZvaWQ7XHJcblxyXG4gIC8vIGNhbGxlZCB3aGVuIGlucHV0IGVuZHMgZnJvbSB1c2VyIGludGVyYWN0aW9uXHJcbiAgZW5kSW5wdXQ/OiAoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgfCBudWxsICkgPT4gdm9pZDtcclxuXHJcbiAgLy8gQ2FsbGVkIGFmdGVyIGFueSB1c2VyIGlucHV0IG9udG8gdGhpcyBjb21wb25lbnQuIFRoZSB2YWx1ZSB3aWxsIG1vc3QgbGlrZWx5IGNoYW5nZSBhcyBhIHJlc3VsdCBvZiB0aGlzIGlucHV0LFxyXG4gIC8vIGJ1dCBkb2Vzbid0IGhhdmUgdG8sIGxpa2Ugd2hlbiBhdCB0aGUgbWluL21heCBvZiB0aGUgdmFsdWUgcmFuZ2UuIFVzZWZ1bCBmb3IgaW5wdXQgZGV2aWNlcyB0aGF0IHN1cHBvcnQgXCJwcmVzc1xyXG4gIC8vIGFuZCBob2xkXCIgaW5wdXQuIEhvd2V2ZXIsIGJld2FyZSB0aGF0IHNvbWUgaW5wdXQgZGV2aWNlcywgc3VjaCBhcyBhIHN3aXRjaCwgaGF2ZSBubyBjb25jZXB0IG9mIFwicHJlc3MgYW5kIGhvbGRcIlxyXG4gIC8vIGFuZCB3aWxsIHRyaWdnZXIgb25jZSBwZXIgaW5wdXQuIEluIHRob3NlIGNhc2VzLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9uY2UgcGVyIGlucHV0IChlYWNoIGlucHV0IHdpbGwgbG9va1xyXG4gIC8vIGxpa2Ugc3RhcnRJbnB1dC0+b25JbnB1dC0+ZW5kSW5wdXQgYWxsIGZyb20gb25lIGJyb3dzZXIgZXZlbnQpLlxyXG4gIG9uSW5wdXQ/OiAoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgKSA9PiB2b2lkO1xyXG5cclxuICAvLyBDb25zdHJhaW5zIHRoZSB2YWx1ZSwgcmV0dXJuaW5nIGEgbmV3IHZhbHVlIGZvciB0aGUgdmFsdWVQcm9wZXJ0eSBpbnN0ZWFkLiBDYWxsZWQgYmVmb3JlIHRoZSB2YWx1ZVByb3BlcnR5IGlzIHNldC5cclxuICAvLyBTdWJ0eXBlcyBjYW4gdXNlIHRoaXMgZm9yIG90aGVyIGZvcm1zIG9mIGlucHV0IGFzIHdlbGwuXHJcbiAgLy8gRm9yIGtleWJvYXJkIGlucHV0LCB0aGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIHNoaWZ0IGtleSBpcyBOT1QgZG93biBiZWNhdXNlIGl0IGlzIG9mdGVuIHRoZSBjYXNlIHRoYXRcclxuICAvLyBzaGlmdEtleWJvYXJkU3RlcCBpcyBhIHNtYWxsZXIgc3RlcCBzaXplIHRoZW4gd2hhdCBpcyBhbGxvd2VkIGJ5IGNvbnN0cmFpblZhbHVlLlxyXG4gIGNvbnN0cmFpblZhbHVlPzogKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyO1xyXG5cclxuICAvLyBkZWx0YSBmb3IgdGhlIHZhbHVlUHJvcGVydHkgZm9yIGVhY2ggcHJlc3Mgb2YgdGhlIGFycm93IGtleXNcclxuICBrZXlib2FyZFN0ZXA/OiBudW1iZXI7XHJcblxyXG4gIC8vIGRlbHRhIGZvciB0aGUgdmFsdWVQcm9wZXJ0eSBmb3IgZWFjaCBwcmVzcyBvZiB0aGUgYXJyb3cga2V5cyB3aGlsZSB0aGUgc2hpZnQgbW9kaWZpZXIgaXMgZG93blxyXG4gIHNoaWZ0S2V5Ym9hcmRTdGVwPzogbnVtYmVyO1xyXG5cclxuICAvLyBkZWx0YSBmb3IgdGhlIHZhbHVlUHJvcGVydHkgZm9yIGVhY2ggcHJlc3Mgb2YgXCJQYWdlIFVwXCIgYW5kIFwiUGFnZSBEb3duXCJcclxuICBwYWdlS2V5Ym9hcmRTdGVwPzogbnVtYmVyO1xyXG5cclxuICAvLyBzcGVjaWZ5IG9yaWVudGF0aW9uLCByZWFkIGJ5IGFzc2lzdGl2ZSB0ZWNobm9sb2d5XHJcbiAgYXJpYU9yaWVudGF0aW9uPzogT3JpZW50YXRpb247XHJcblxyXG4gIC8vIFVwb24gYWNjZXNzaWJsZSBpbnB1dCwgd2Ugd2lsbCB0cnkgdG8ga2VlcCB0aGlzIE5vZGUgaW4gdmlldyBvZiB0aGUgYW5pbWF0ZWRQYW5ab29tU2luZ2xldG9uLlxyXG4gIC8vIElmIG51bGwsICd0aGlzJyBpcyB1c2VkICh0aGUgTm9kZSBtaXhpbmcgQWNjZXNzaWJsZVZhbHVlSGFuZGxlcilcclxuICBwYW5UYXJnZXROb2RlPzogbnVsbCB8IE5vZGU7XHJcblxyXG4gIC8vIFdoZW4gc2V0dGluZyB0aGUgUHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgUERPTSBpbnB1dCwgdGhpcyBvcHRpb24gY29udHJvbHMgd2hldGhlciBvciBub3QgdG9cclxuICAvLyByb3VuZCB0aGUgdmFsdWUgdG8gYSBtdWx0aXBsZSBvZiB0aGUga2V5Ym9hcmRTdGVwLiBUaGlzIHdpbGwgb25seSByb3VuZCB0aGUgdmFsdWUgb24gbm9ybWFsIGtleSBwcmVzc2VzLFxyXG4gIC8vIHJvdW5kaW5nIHdpbGwgbm90IG9jY3VyIG9uIGxhcmdlIGp1bXBzIGxpa2UgcGFnZSB1cC9wYWdlIGRvd24vaG9tZS9lbmQuXHJcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9ncmF2aXR5LWZvcmNlLWxhYi1iYXNpY3MvaXNzdWVzLzcyXHJcbiAgcm91bmRUb1N0ZXBTaXplPzogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogTWFwIHRoZSB2YWx1ZVByb3BlcnR5IHZhbHVlIHRvIGFub3RoZXIgbnVtYmVyIHRoYXQgd2lsbCBiZSByZWFkIGJ5IGFzc2lzdGl2ZSBkZXZpY2VzIG9uXHJcbiAgICogdmFsdWVQcm9wZXJ0eSBjaGFuZ2VzIGZyb20gdGhlIFBET00gdmFsdWVzLiBUaGlzIGlzIHVzZWQgdG8gc2V0IHRoZSB2YWx1ZXMgZm9yIGFyaWEtdmFsdWV0ZXh0IGFuZCB0aGUgb25cclxuICAgKiBjaGFuZ2UgYWxlcnQsIGFzIHdlbGwgYXMgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzIG9uIHRoZSBQRE9NIGlucHV0OlxyXG4gICAqICAgIHZhbHVlXHJcbiAgICogICAgYXJpYS12YWx1ZW5vd1xyXG4gICAqICAgIG1pblxyXG4gICAqICAgIG1heFxyXG4gICAqICAgIHN0ZXBcclxuICAgKlxyXG4gICAqIEZvciB0aGlzIHJlYXNvbiwgaXQgaXMgaW1wb3J0YW50IHRoYXQgdGhlIG1hcHBlZCBcIm1pblwiIHdvdWxkIG5vdCBiZSBiaWdnZXIgdGhhbiB0aGUgbWFwcGVkIFwibWF4XCIgZnJvbSB0aGVcclxuICAgKiBlbmFibGVkUmFuZ2VQcm9wZXJ0eS5cclxuICAgKi9cclxuICBhMTF5TWFwUERPTVZhbHVlPzogKCB2YWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgYmVmb3JlIGNvbnN0cmFpbmluZyBhbmQgc2V0dGluZyB0aGUgUHJvcGVydHkuIFRoaXMgaXMgdXNlZnVsIGluIHJhcmUgY2FzZXMgd2hlcmUgdGhlIHZhbHVlIGJlaW5nIHNldFxyXG4gICAqIGJ5IEFjY2Vzc2libGVWYWx1ZUhhbmRsZXIgbWF5IGNoYW5nZSBiYXNlZCBvbiBvdXRzaWRlIGxvZ2ljLiBUaGlzIGlzIGZvciBtYXBwaW5nIHZhbHVlIGNoYW5nZXMgZnJvbSBpbnB1dCBsaXN0ZW5lcnNcclxuICAgKiBhc3NpZ25lZCBpbiB0aGlzIHR5cGUgKGtleWJvYXJkL2FsdC1pbnB1dCkgdG8gYSBuZXcgdmFsdWUgYmVmb3JlIHRoZSB2YWx1ZSBpcyBzZXQuXHJcbiAgICovXHJcbiAgYTExeU1hcFZhbHVlPzogKCBuZXdWYWx1ZTogbnVtYmVyLCBwcmV2aW91c1ZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIHRydWUsIHRoZSBhcmlhLXZhbHVldGV4dCB3aWxsIGJlIHNwb2tlbiBldmVyeSB2YWx1ZSBjaGFuZ2UsIGV2ZW4gaWYgdGhlIGFyaWEtdmFsdWV0ZXh0IGRvZXNuJ3RcclxuICAgKiBhY3R1YWxseSBjaGFuZ2UuIEJ5IGRlZmF1bHQsIHNjcmVlbiByZWFkZXJzIHdvbid0IHNwZWFrIGFyaWEtdmFsdWV0ZXh0IGlmIGl0IHJlbWFpbnMgdGhlIHNhbWUgZm9yXHJcbiAgICogbXVsdGlwbGUgdmFsdWVzLlxyXG4gICAqL1xyXG4gIGExMXlSZXBlYXRFcXVhbFZhbHVlVGV4dD86IGJvb2xlYW47XHJcblxyXG4gIC8qKlxyXG4gICAqIGFyaWEtdmFsdWV0ZXh0IGNyZWF0aW9uIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbiB0aGUgdmFsdWVQcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gICAqIFRoaXMgc3RyaW5nIGlzIHJlYWQgYnkgQVQgZXZlcnkgdGltZSB0aGUgc2xpZGVyIHZhbHVlIGNoYW5nZXMuIFRoaXMgaXMgb2Z0ZW4gY2FsbGVkIHRoZSBcIm9iamVjdCByZXNwb25zZVwiXHJcbiAgICogZm9yIHRoaXMgaW50ZXJhY3Rpb24uXHJcbiAgICovXHJcbiAgYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQ/OiBDcmVhdGVUZXh0RnVuY3Rpb247XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBjb250ZW50IGZvciBhbiBhbGVydCB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgdXR0ZXJhbmNlUXVldWUgd2hlbiB0aGUgdXNlciBmaW5pc2hlcyBpbnRlcmFjdGluZ1xyXG4gICAqIHdpdGggdGhlIGlucHV0LiBJcyBub3QgZ2VuZXJhdGVkIGV2ZXJ5IGNoYW5nZSwgYnV0IG9uIGV2ZXJ5IFwiZHJhZ1wiIGludGVyYWN0aW9uLCB0aGlzIGlzIGNhbGxlZCB3aXRoXHJcbiAgICogZW5kSW5wdXQuIFdpdGggYSBrZXlib2FyZCwgdGhpcyB3aWxsIGJlIGNhbGxlZCBldmVuIHdpdGggbm8gdmFsdWUgY2hhbmdlIChvbiB0aGUga2V5IHVwIGV2ZW50IGVuZGluZyB0aGVcclxuICAgKiBpbnRlcmFjdGlvbiksIE9uIGEgdG91Y2ggc3lzdGVtIGxpa2UgaU9TIHdpdGggVm9pY2UgT3ZlciBob3dldmVyLCBpbnB1dCBhbmQgY2hhbmdlIGV2ZW50cyB3aWxsIG9ubHkgZmlyZVxyXG4gICAqIHdoZW4gdGhlcmUgaXMgYSBQcm9wZXJ0eSB2YWx1ZSBjaGFuZ2UsIHNvIFwiZWRnZVwiIGFsZXJ0cyB3aWxsIG5vdCBmaXJlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2dyYXZpdHktZm9yY2UtbGFiLWJhc2ljcy9pc3N1ZXMvMTg1LlxyXG4gICAqIFRoaXMgYWxlcnQgaXMgb2Z0ZW4gY2FsbGVkIHRoZSBcImNvbnRleHQgcmVzcG9uc2VcIiBiZWNhdXNlIGl0IGlzIHRpbWVkIHRvIG9ubHkgYWxlcnQgYWZ0ZXIgYW4gaW50ZXJhY3Rpb25cclxuICAgKiBlbmQsIGluc3RlYWQgb2YgZWFjaCB0aW1lIHRoZSB2YWx1ZSBjaGFuZ2VzLlxyXG4gICAqXHJcbiAgICogSWYgZnVuY3Rpb24gcmV0dXJucyBudWxsLCB0aGVuIG5vIGFsZXJ0IHdpbGwgYmUgc2VudCB0byB1dHRlcmFuY2VRdWV1ZSBmb3IgYWxlcnRpbmcuXHJcbiAgICpcclxuICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBhbHNvIHN1cHBvcnQgYSBgcmVzZXRgIGZ1bmN0aW9uIG9uIGl0LCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgQWNjZXNzaWJsZVZhbHVlSGFuZGxlciBpcyByZXNldFxyXG4gICAqL1xyXG4gIGExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydD86IENyZWF0ZVRleHRGdW5jdGlvbiB8IG51bGw7XHJcblxyXG4gIC8vIFRoaXMgY29lZmZpY2llbnQgaXMgbXVsdGlwbGllZCBieSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkIHdpdGhvdXQgdGhlIGNvbnRleHQgcmVzcG9uc2VcclxuICAvLyBhbGVydGluZy4gVGhpcyBudW1iZXIgaXMgbWVhbnQgdG8gZ2l2ZSB0aGUgc2NyZWVuIHJlYWRlciBlbm91Z2ggY2hhbmNlIHRvIGZpbmlzaCByZWFkaW5nIHRoZSBhcmlhLXZhbHVldGV4dCxcclxuICAvLyB3aGljaCBjb3VsZCB0YWtlIGxvbmdlciB0aGUgbW9yZSB0aW1lIHRoZSB2YWx1ZSBjaGFuZ2VzLiBXZSB3YW50IHRvIGdpdmUgZW5vdWdoIHRpbWUgZm9yIFZPIHRvIHJlYWRcclxuICAvLyBhcmlhLXZhbHVldGV4dCBidXQgZG9uJ3Qgd2FudCB0byBoYXZlIHRvbyBtdWNoIHNpbGVuY2UgYmVmb3JlIHRoZSBhbGVydCBpcyBzcG9rZW4uXHJcbiAgY29udGV4dFJlc3BvbnNlUGVyVmFsdWVDaGFuZ2VEZWxheT86IG51bWJlcjtcclxuXHJcbiAgLy8gaW4gbXMsIFdoZW4gdGhlIHZhbHVlUHJvcGVydHkgY2hhbmdlcyByZXBlYXRlZGx5LCB3aGF0IGlzIHRoZSBtYXhpbXVtIHRpbWUgdG8gc2V0IHRoZVxyXG4gIC8vIGFsZXJ0U3RhYmxlRGVsYXkgZm9yIHRoZSBjb250ZXh0IHJlc3BvbnNlIHRvLiBUaGlzIHZhbHVlIHNob3VsZCBiZSBzbWFsbCBlbm91Z2ggdGhhdCBpdCBmZWVscyBsaWtlIHlvdSBhcmVcclxuICAvLyBhaXRpbmcgZm9yIHRoaXMgYWxlcnQgYWZ0ZXIgYW4gaW50ZXJhY3Rpb24uIFRoaXMgc2hvdWxkIGJlIGFsdGVyZWQgZGVwZW5kaW5nIG9uIGhvdyBxdWlja2x5IHlvdSBleHBlY3QgdGhlXHJcbiAgLy8gdmFsdWUgdG8gY2hhbmdlLiBXZSB3YW50IHRvIGdpdmUgZW5vdWdoIHRpbWUgZm9yIFZPIHRvIHJlYWQgYXJpYS12YWx1ZXRleHQgYnV0IGRvbid0IHdhbnQgdG8gaGF2ZSB0b28gbXVjaFxyXG4gIC8vIHNpbGVuY2UgYmVmb3JlIHRoZSBhbGVydCBpcyBzcG9rZW4uXHJcbiAgY29udGV4dFJlc3BvbnNlTWF4RGVsYXk/OiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3QgdGhlIGRlcGVuZGVuY2llcyB0aGlzIE5vZGUncyBQRE9NIGRlc2NyaXB0aW9ucyBoYXZlLiBUaGlzIHNob3VsZCBub3QgaW5jbHVkZSB0aGUgdmFsdWVQcm9wZXJ0eSwgYnV0XHJcbiAgICogc2hvdWxkIGxpc3QgYW55IFByb3BlcnRpZXMgd2hvc2UgY2hhbmdlIHNob3VsZCB0cmlnZ2VyIGEgZGVzY3JpcHRpb24gdXBkYXRlIGZvciB0aGlzIE5vZGUuXHJcbiAgICovXHJcbiAgYTExeURlcGVuZGVuY2llcz86IFRSZWFkT25seVByb3BlcnR5PEludGVudGlvbmFsQW55PltdO1xyXG5cclxuICAvLyBPbmx5IHByb3ZpZGUgdGFnTmFtZSB0byBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBQRE9NLCBvdGhlcndpc2UsIEFjY2Vzc2libGVWYWx1ZUhhbmRsZXJcclxuICAvLyBzZXRzIGl0cyBvd24gdGFnTmFtZS5cclxuICB0YWdOYW1lPzogbnVsbDtcclxuXHJcbiAgLy8gQ3VzdG9taXphdGlvbnMgZm9yIHRoZSB2b2ljaW5nT25FbmRSZXNwb25zZSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCB0byB2b2ljZSBjb250ZW50IGF0IHRoZSBlbmRcclxuICAvLyBvZiBhbiBpbnRlcmFjdGlvbi5cclxuICB2b2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnM/OiBWb2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnM7XHJcbn07XHJcblxyXG50eXBlIFBhcmVudE9wdGlvbnMgPSBWb2ljaW5nT3B0aW9ucyAmIE5vZGVPcHRpb25zO1xyXG5cclxuZXhwb3J0IHR5cGUgQWNjZXNzaWJsZVZhbHVlSGFuZGxlck9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIFZvaWNpbmdPcHRpb25zOyAvLyBkbyBub3QgdXNlIFBhcmVudE9wdGlvbnMgaGVyZSFcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gVHlwZVxyXG4gKiBAcGFyYW0gb3B0aW9uc0FyZ1Bvc2l0aW9uIC0gemVyby1pbmRleGVkIG51bWJlciB0aGF0IHRoZSBvcHRpb25zIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGF0XHJcbiAqL1xyXG5jb25zdCBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyID0gPFN1cGVyVHlwZSBleHRlbmRzIENvbnN0cnVjdG9yPE5vZGU+PiggVHlwZTogU3VwZXJUeXBlLCBvcHRpb25zQXJnUG9zaXRpb246IG51bWJlciApID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXHJcbiAgcmV0dXJuIGNsYXNzIEFjY2Vzc2libGVWYWx1ZUhhbmRsZXIgZXh0ZW5kcyBWb2ljaW5nKCBUeXBlICkge1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfdmFsdWVQcm9wZXJ0eTogVFByb3BlcnR5PG51bWJlcj47XHJcbiAgICBwcml2YXRlIF9lbmFibGVkUmFuZ2VQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8UmFuZ2U+O1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfc3RhcnRJbnB1dDogU2NlbmVyeUxpc3RlbmVyRnVuY3Rpb247XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9vbklucHV0OiBTY2VuZXJ5TGlzdGVuZXJGdW5jdGlvbjtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2VuZElucHV0OiBTY2VuZXJ5TGlzdGVuZXJGdW5jdGlvbjtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2NvbnN0cmFpblZhbHVlOiAoICggdmFsdWU6IG51bWJlciApID0+IG51bWJlciApO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfYTExeU1hcFZhbHVlOiAoICggbmV3VmFsdWU6IG51bWJlciwgcHJldmlvdXNWYWx1ZTogbnVtYmVyICkgPT4gbnVtYmVyICk7XHJcbiAgICBwcml2YXRlIF9wYW5UYXJnZXROb2RlOiBOb2RlIHwgbnVsbDtcclxuICAgIHByaXZhdGUgX2tleWJvYXJkU3RlcDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfc2hpZnRLZXlib2FyZFN0ZXA6IG51bWJlcjtcclxuICAgIHByaXZhdGUgX3BhZ2VLZXlib2FyZFN0ZXA6IG51bWJlcjtcclxuICAgIHByaXZhdGUgX2FyaWFPcmllbnRhdGlvbjogT3JpZW50YXRpb247XHJcbiAgICBwcml2YXRlIF9zaGlmdEtleTogYm9vbGVhbjtcclxuXHJcbiAgICAvLyB0cmFjayBwcmV2aW91cyB2YWx1ZXMgZm9yIGNhbGxiYWNrcyBvdXRzaWRlIG9mIFByb3BlcnR5IGxpc3RlbmVyc1xyXG4gICAgcHJpdmF0ZSBfb2xkVmFsdWU6IG51bWJlciB8IG51bGw7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfYTExeUNyZWF0ZUNvbnRleHRSZXNwb25zZUFsZXJ0OiBDcmVhdGVUZXh0RnVuY3Rpb24gfCBudWxsO1xyXG5cclxuICAgIC8vIFRoZSBQcm9wZXJ0eSB2YWx1ZSB3aGVuIGFuIGludGVyYWN0aW9uIHN0YXJ0cywgc28gaXQgY2FuIGJlIHVzZWQgYXMgdGhlIFwib2xkXCIgdmFsdWVcclxuICAgIC8vIHdoZW4gZ2VuZXJhdGluZyBhIGNvbnRleHQgcmVzcG9uc2UgYXQgdGhlIGVuZCBvZiBhbiBpbnRlcmFjdGlvbiB3aXRoIGExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydC5cclxuICAgIHByaXZhdGUgX3ZhbHVlT25TdGFydDogbnVtYmVyO1xyXG5cclxuICAgIC8vIFRoZSB1dHRlcmFuY2Ugc2VudCB0byB0aGUgdXR0ZXJhbmNlUXVldWUgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcywgYWxlcnQgY29udGVudCBnZW5lcmF0ZWQgYnlcclxuICAgIC8vIG9wdGlvbmFsIGExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydC4gVGhlIGFsZXJ0U3RhYmxlRGVsYXkgb24gdGhpcyB1dHRlcmFuY2Ugd2lsbCBpbmNyZWFzZSBpZiB0aGUgaW5wdXRcclxuICAgIC8vIHJlY2VpdmVzIG1hbnkgaW50ZXJhY3Rpb25zIGJlZm9yZSB0aGUgdXR0ZXJhbmNlIGNhbiBiZSBhbm5vdW5jZWQgc28gdGhhdCBWb2ljZU92ZXIgaGFzIHRpbWUgdG8gcmVhZCB0aGVcclxuICAgIC8vIGFyaWEtdmFsdWV0ZXh0IChvYmplY3QgcmVzcG9uc2UpIGJlZm9yZSB0aGUgYWxlcnQgKGNvbnRleHQgcmVzcG9uc2UpLlxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfY29udGV4dFJlc3BvbnNlVXR0ZXJhbmNlOiBVdHRlcmFuY2U7XHJcblxyXG4gICAgLy8gTnVtYmVyIG9mIHRpbWVzIHRoZSBpbnB1dCBoYXMgY2hhbmdlZCBpbiB2YWx1ZSBiZWZvcmUgdGhlIHV0dGVyYW5jZSBtYWRlIHdhcyBhYmxlIHRvIGJlIHNwb2tlbiwgb25seSBhcHBsaWNhYmxlXHJcbiAgICAvLyBpZiB1c2luZyBhMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnRcclxuICAgIHByaXZhdGUgX3RpbWVzVmFsdWVUZXh0Q2hhbmdlZEJlZm9yZUFsZXJ0aW5nOiBudW1iZXI7XHJcblxyXG4gICAgLy8gaW4gbXMsIHNlZSBvcHRpb25zIGZvciBkb2N1bWVudGF0aW9uLlxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfY29udGV4dFJlc3BvbnNlUGVyVmFsdWVDaGFuZ2VEZWxheTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfY29udGV4dFJlc3BvbnNlTWF4RGVsYXk6IG51bWJlcjtcclxuXHJcbiAgICAvLyBXaGV0aGVyIGFuIGlucHV0IGV2ZW50IGhhcyBiZWVuIGhhbmRsZWQuIElmIGhhbmRsZWQsIHdlIHdpbGwgbm90IHJlc3BvbmQgdG8gdGhlXHJcbiAgICAvLyBjaGFuZ2UgZXZlbnQuIEFuIEFUIChwYXJ0aWN1bGFybHkgVm9pY2VPdmVyKSBtYXkgc2VuZCBhIGNoYW5nZSBldmVudCAoYW5kIG5vdCBhbiBpbnB1dCBldmVudCkgdG8gdGhlXHJcbiAgICAvLyBicm93c2VyIGluIHJlc3BvbnNlIHRvIGEgdXNlciBnZXN0dXJlLiBXZSBuZWVkIHRvIGhhbmRsZSB0aGF0IGNoYW5nZSBldmVudCwgd2l0aG91dCBhbHNvIGhhbmRsaW5nIHRoZVxyXG4gICAgLy8gaW5wdXQgZXZlbnQgaW4gY2FzZSBhIGRldmljZSBzZW5kcyBib3RoIGV2ZW50cyB0byB0aGUgYnJvd3Nlci5cclxuICAgIHByaXZhdGUgX2ExMXlJbnB1dEhhbmRsZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgLy8gU29tZSBicm93c2VycyB3aWxsIHJlY2VpdmUgYGlucHV0YCBldmVudHMgd2hlbiB0aGUgdXNlciB0YWJzIGF3YXkgZnJvbSB0aGUgc2xpZGVyIG9yXHJcbiAgICAvLyBvbiBzb21lIGtleSBwcmVzc2VzIC0gaWYgd2UgcmVjZWl2ZSBhIGtleWRvd24gZXZlbnQgZm9yIGEgdGFiIGtleSwgZG8gbm90IGFsbG93IGlucHV0IG9yIGNoYW5nZSBldmVudHNcclxuICAgIHByaXZhdGUgX2Jsb2NrSW5wdXQ6IGJvb2xlYW47XHJcblxyXG4gICAgLy8gc2V0dGluZyB0byBlbmFibGUvZGlzYWJsZSByb3VuZGluZyB0byB0aGUgc3RlcCBzaXplXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9yb3VuZFRvU3RlcFNpemU6IGJvb2xlYW47XHJcblxyXG4gICAgLy8ga2V5IGlzIHRoZSBldmVudC5jb2RlIGZvciB0aGUgcmFuZ2Uga2V5LCB2YWx1ZSBpcyB3aGV0aGVyIGl0IGlzIGRvd25cclxuICAgIHByaXZhdGUgX3JhbmdlS2V5c0Rvd246IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+O1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfYTExeU1hcFBET01WYWx1ZTogKCAoIHZhbHVlOiBudW1iZXIgKSA9PiBudW1iZXIgKTtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2ExMXlDcmVhdGVBcmlhVmFsdWVUZXh0OiBDcmVhdGVUZXh0RnVuY3Rpb247XHJcbiAgICBwcml2YXRlIF9kZXBlbmRlbmNpZXNNdWx0aWxpbms6IFVua25vd25NdWx0aWxpbmsgfCBudWxsO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfYTExeVJlcGVhdEVxdWFsVmFsdWVUZXh0OiBib29sZWFuO1xyXG5cclxuICAgIC8vIFdoZW4gY29udGV4dCByZXNwb25zZXMgYXJlIHN1cHBvcnRlZCwgdGhpcyBjb3VudGVyIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGEgbXV0YWJsZSBkZWxheSBiZXR3ZWVuIGhlYXJpbmcgdGhlXHJcbiAgICAvLyBzYW1lIHJlc3BvbnNlLlxyXG4gICAgcHJpdmF0ZSBfdGltZXNDaGFuZ2VkQmVmb3JlQWxlcnRpbmc6IG51bWJlcjtcclxuXHJcbiAgICAvLyBPcHRpb25zIGZvciB0aGUgVm9pY2luZyByZXNwb25zZSBhdCB0aGUgZW5kIG9mIGludGVyYWN0aW9uIHdpdGggdGhpcyBjb21wb25lbnQuXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF92b2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnM6IFZvaWNpbmdPbkVuZFJlc3BvbnNlT3B0aW9ucztcclxuXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9kaXNwb3NlQWNjZXNzaWJsZVZhbHVlSGFuZGxlcjogKCkgPT4gdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoIC4uLmFyZ3M6IEludGVudGlvbmFsQW55W10gKSB7XHJcblxyXG4gICAgICBjb25zdCBwcm92aWRlZE9wdGlvbnMgPSBhcmdzWyBvcHRpb25zQXJnUG9zaXRpb24gXSBhcyBBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyT3B0aW9ucztcclxuXHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHByb3ZpZGVkT3B0aW9ucywgJ3Byb3ZpZGVkT3B0aW9ucyBoYXMgcmVxdWlyZWQgb3B0aW9ucycgKTtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggcHJvdmlkZWRPcHRpb25zLmVuYWJsZWRSYW5nZVByb3BlcnR5LCAnZW5hYmxlZFJhbmdlUHJvcGVydHkgaXMgYSByZXF1aXJlZCBvcHRpb24nICk7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHByb3ZpZGVkT3B0aW9ucy52YWx1ZVByb3BlcnR5LCAndmFsdWVQcm9wZXJ0eSBpcyBhIHJlcXVpcmVkIG9wdGlvbicgKTtcclxuICAgICAgY29uc3QgZW5hYmxlZFJhbmdlUHJvcGVydHkgPSBwcm92aWRlZE9wdGlvbnMuZW5hYmxlZFJhbmdlUHJvcGVydHk7XHJcblxyXG4gICAgICAvLyBpZiByb3VuZGluZyB0byBrZXlib2FyZCBzdGVwLCBrZXlib2FyZFN0ZXAgbXVzdCBiZSBkZWZpbmVkIHNvIHZhbHVlcyBhcmVuJ3Qgc2tpcHBlZCBhbmQgdGhlIHNsaWRlclxyXG4gICAgICAvLyBkb2Vzbid0IGdldCBzdHVjayB3aGlsZSByb3VuZGluZyB0byB0aGUgbmVhcmVzdCB2YWx1ZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zdW4vaXNzdWVzLzQxMFxyXG4gICAgICBpZiAoIGFzc2VydCAmJiBwcm92aWRlZE9wdGlvbnMgJiYgcHJvdmlkZWRPcHRpb25zLnJvdW5kVG9TdGVwU2l6ZSApIHtcclxuICAgICAgICBhc3NlcnQoIHByb3ZpZGVkT3B0aW9ucy5rZXlib2FyZFN0ZXAsICdyb3VuZGluZyB0byBrZXlib2FyZFN0ZXAsIGRlZmluZSBhcHByb3ByaWF0ZSBrZXlib2FyZFN0ZXAgdG8gcm91bmQgdG8nICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRlZmF1bHRzOiBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucywgUGFyZW50T3B0aW9ucz4gPSB7XHJcblxyXG4gICAgICAgIC8vIG90aGVyXHJcbiAgICAgICAgc3RhcnRJbnB1dDogXy5ub29wLFxyXG4gICAgICAgIGVuZElucHV0OiBfLm5vb3AsXHJcbiAgICAgICAgb25JbnB1dDogXy5ub29wLFxyXG4gICAgICAgIGNvbnN0cmFpblZhbHVlOiBfLmlkZW50aXR5LFxyXG4gICAgICAgIGtleWJvYXJkU3RlcDogKCBlbmFibGVkUmFuZ2VQcm9wZXJ0eS5nZXQoKS5tYXggLSBlbmFibGVkUmFuZ2VQcm9wZXJ0eS5nZXQoKS5taW4gKSAvIDIwLFxyXG4gICAgICAgIHNoaWZ0S2V5Ym9hcmRTdGVwOiAoIGVuYWJsZWRSYW5nZVByb3BlcnR5LmdldCgpLm1heCAtIGVuYWJsZWRSYW5nZVByb3BlcnR5LmdldCgpLm1pbiApIC8gMTAwLFxyXG4gICAgICAgIHBhZ2VLZXlib2FyZFN0ZXA6ICggZW5hYmxlZFJhbmdlUHJvcGVydHkuZ2V0KCkubWF4IC0gZW5hYmxlZFJhbmdlUHJvcGVydHkuZ2V0KCkubWluICkgLyAxMCxcclxuICAgICAgICBhcmlhT3JpZW50YXRpb246IE9yaWVudGF0aW9uLkhPUklaT05UQUwsXHJcbiAgICAgICAgcGFuVGFyZ2V0Tm9kZTogbnVsbCxcclxuICAgICAgICByb3VuZFRvU3RlcFNpemU6IGZhbHNlLFxyXG4gICAgICAgIGExMXlNYXBQRE9NVmFsdWU6IF8uaWRlbnRpdHksXHJcbiAgICAgICAgYTExeU1hcFZhbHVlOiBfLmlkZW50aXR5LFxyXG4gICAgICAgIGExMXlSZXBlYXRFcXVhbFZhbHVlVGV4dDogdHJ1ZSxcclxuICAgICAgICBhMTF5Q3JlYXRlQXJpYVZhbHVlVGV4dDogdG9TdHJpbmcsIC8vIGJ5IGRlZmF1bHQgbWFrZSBzdXJlIGl0IHJldHVybnMgYSBzdHJpbmdcclxuICAgICAgICBhMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnQ6IG51bGwsXHJcbiAgICAgICAgY29udGV4dFJlc3BvbnNlUGVyVmFsdWVDaGFuZ2VEZWxheTogNzAwLFxyXG4gICAgICAgIGNvbnRleHRSZXNwb25zZU1heERlbGF5OiAxNTAwLFxyXG4gICAgICAgIGExMXlEZXBlbmRlbmNpZXM6IFtdLFxyXG4gICAgICAgIHZvaWNpbmdPbkVuZFJlc3BvbnNlT3B0aW9uczogREVGQVVMVF9WT0lDSU5HX09OX0VORF9SRVNQT05TRV9PUFRJT05TLFxyXG5cclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gVE9ETzogd2Ugc2hvdWxkIGJlIGFibGUgdG8gaGF2ZSB0aGUgcHVibGljIEFQSSBiZSBqdXN0IG51bGwsIGFuZCBpbnRlcm5hbGx5IHNldCB0byBzdHJpbmcsIExpbWl0YXRpb24gKElWKSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9waGV0LWNvcmUvaXNzdWVzLzEyOFxyXG4gICAgICAgIHRhZ05hbWU6IERFRkFVTFRfVEFHX05BTUUsXHJcblxyXG4gICAgICAgIC8vIHBhcmVudCBvcHRpb25zIHRoYXQgd2UgbXVzdCBwcm92aWRlIGEgZGVmYXVsdCB0byB1c2VcclxuICAgICAgICBpbnB1dFR5cGU6IG51bGxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8QWNjZXNzaWJsZVZhbHVlSGFuZGxlck9wdGlvbnMsIFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zPigpKCBkZWZhdWx0cywgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgICBhc3NlcnQgJiYgcHJvdmlkZWRPcHRpb25zICYmIGFzc2VydCggIXByb3ZpZGVkT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSggJ3RhZ05hbWUnICkgfHwgcHJvdmlkZWRPcHRpb25zLnRhZ05hbWUgPT09IG51bGwsXHJcbiAgICAgICAgJ0FjY2Vzc2libGVWYWx1ZUhhbmRsZXIgc2V0cyBpdHMgb3duIHRhZ05hbWUuIE9ubHkgcHJvdmlkZSB0YWdOYW1lIHRvIGNsZWFyIGFjY2Vzc2libGUgY29udGVudCBmcm9tIHRoZSBQRE9NJyApO1xyXG5cclxuICAgICAgLy8gY2Fubm90IGJlIHNldCBieSBjbGllbnRcclxuICAgICAgYXNzZXJ0ICYmIHByb3ZpZGVkT3B0aW9ucyAmJiBhc3NlcnQoICFwcm92aWRlZE9wdGlvbnMuaGFzT3duUHJvcGVydHkoICdpbnB1dFR5cGUnICksICdBY2Nlc3NpYmxlVmFsdWVIYW5kbGVyIHNldHMgaXRzIG93biBpbnB1dFR5cGUuJyApO1xyXG4gICAgICBvcHRpb25zLmlucHV0VHlwZSA9ICdyYW5nZSc7XHJcblxyXG4gICAgICBhcmdzWyBvcHRpb25zQXJnUG9zaXRpb24gXSA9IG9wdGlvbnM7XHJcbiAgICAgIHN1cGVyKCAuLi5hcmdzICk7XHJcblxyXG4gICAgICAvLyBtZW1iZXJzIG9mIHRoZSBOb2RlIEFQSSB0aGF0IGFyZSB1c2VkIGJ5IHRoaXMgdHJhaXRcclxuICAgICAgYXNzZXJ0SGFzUHJvcGVydGllcyggdGhpcywgWyAnaW5wdXRWYWx1ZScsICdzZXRQRE9NQXR0cmlidXRlJyBdICk7XHJcblxyXG4gICAgICB0aGlzLl92YWx1ZVByb3BlcnR5ID0gb3B0aW9ucy52YWx1ZVByb3BlcnR5O1xyXG4gICAgICB0aGlzLl9lbmFibGVkUmFuZ2VQcm9wZXJ0eSA9IGVuYWJsZWRSYW5nZVByb3BlcnR5O1xyXG4gICAgICB0aGlzLl9zdGFydElucHV0ID0gb3B0aW9ucy5zdGFydElucHV0O1xyXG4gICAgICB0aGlzLl9vbklucHV0ID0gb3B0aW9ucy5vbklucHV0O1xyXG4gICAgICB0aGlzLl9lbmRJbnB1dCA9IG9wdGlvbnMuZW5kSW5wdXQ7XHJcbiAgICAgIHRoaXMuX2NvbnN0cmFpblZhbHVlID0gb3B0aW9ucy5jb25zdHJhaW5WYWx1ZTtcclxuICAgICAgdGhpcy5fYTExeU1hcFZhbHVlID0gb3B0aW9ucy5hMTF5TWFwVmFsdWU7XHJcbiAgICAgIHRoaXMuX3BhblRhcmdldE5vZGUgPSBvcHRpb25zLnBhblRhcmdldE5vZGU7XHJcblxyXG4gICAgICAvLyBpbml0aWFsaXplZCB3aXRoIHNldEtleWJvYXJkU3RlcCB3aGljaCBkb2VzIHNvbWUgdmFsaWRhdGluZ1xyXG4gICAgICB0aGlzLl9rZXlib2FyZFN0ZXAgPSBkZWZhdWx0cy5rZXlib2FyZFN0ZXA7XHJcbiAgICAgIHRoaXMuc2V0S2V5Ym9hcmRTdGVwKCBvcHRpb25zLmtleWJvYXJkU3RlcCApO1xyXG5cclxuICAgICAgdGhpcy5fc2hpZnRLZXlib2FyZFN0ZXAgPSBkZWZhdWx0cy5zaGlmdEtleWJvYXJkU3RlcDtcclxuICAgICAgdGhpcy5zZXRTaGlmdEtleWJvYXJkU3RlcCggb3B0aW9ucy5zaGlmdEtleWJvYXJkU3RlcCApO1xyXG5cclxuICAgICAgdGhpcy5fcGFnZUtleWJvYXJkU3RlcCA9IGRlZmF1bHRzLnBhZ2VLZXlib2FyZFN0ZXA7XHJcbiAgICAgIHRoaXMuc2V0UGFnZUtleWJvYXJkU3RlcCggb3B0aW9ucy5wYWdlS2V5Ym9hcmRTdGVwICk7XHJcblxyXG4gICAgICB0aGlzLl9zaGlmdEtleSA9IGZhbHNlO1xyXG5cclxuICAgICAgdGhpcy5fYXJpYU9yaWVudGF0aW9uID0gZGVmYXVsdHMuYXJpYU9yaWVudGF0aW9uO1xyXG4gICAgICB0aGlzLmFyaWFPcmllbnRhdGlvbiA9IG9wdGlvbnMuYXJpYU9yaWVudGF0aW9uO1xyXG5cclxuICAgICAgdGhpcy5fb2xkVmFsdWUgPSBudWxsO1xyXG4gICAgICB0aGlzLl92YWx1ZU9uU3RhcnQgPSB0aGlzLl92YWx1ZVByb3BlcnR5LnZhbHVlO1xyXG4gICAgICB0aGlzLl9hMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnQgPSBvcHRpb25zLmExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydDtcclxuICAgICAgdGhpcy5fdGltZXNWYWx1ZVRleHRDaGFuZ2VkQmVmb3JlQWxlcnRpbmcgPSAwO1xyXG4gICAgICB0aGlzLl9jb250ZXh0UmVzcG9uc2VVdHRlcmFuY2UgPSBuZXcgVXR0ZXJhbmNlKCk7XHJcbiAgICAgIHRoaXMuX2NvbnRleHRSZXNwb25zZVBlclZhbHVlQ2hhbmdlRGVsYXkgPSBvcHRpb25zLmNvbnRleHRSZXNwb25zZVBlclZhbHVlQ2hhbmdlRGVsYXk7XHJcbiAgICAgIHRoaXMuX2NvbnRleHRSZXNwb25zZU1heERlbGF5ID0gb3B0aW9ucy5jb250ZXh0UmVzcG9uc2VNYXhEZWxheTtcclxuICAgICAgdGhpcy5fYTExeUlucHV0SGFuZGxlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9ibG9ja0lucHV0ID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX3JhbmdlS2V5c0Rvd24gPSB7fTtcclxuICAgICAgdGhpcy5fcm91bmRUb1N0ZXBTaXplID0gb3B0aW9ucy5yb3VuZFRvU3RlcFNpemU7XHJcbiAgICAgIHRoaXMuX2ExMXlNYXBQRE9NVmFsdWUgPSBvcHRpb25zLmExMXlNYXBQRE9NVmFsdWU7XHJcbiAgICAgIHRoaXMuX2ExMXlDcmVhdGVBcmlhVmFsdWVUZXh0ID0gb3B0aW9ucy5hMTF5Q3JlYXRlQXJpYVZhbHVlVGV4dDtcclxuICAgICAgdGhpcy5fZGVwZW5kZW5jaWVzTXVsdGlsaW5rID0gbnVsbDtcclxuICAgICAgdGhpcy5fYTExeVJlcGVhdEVxdWFsVmFsdWVUZXh0ID0gb3B0aW9ucy5hMTF5UmVwZWF0RXF1YWxWYWx1ZVRleHQ7XHJcbiAgICAgIHRoaXMuX3RpbWVzQ2hhbmdlZEJlZm9yZUFsZXJ0aW5nID0gMDtcclxuICAgICAgdGhpcy5fdm9pY2luZ09uRW5kUmVzcG9uc2VPcHRpb25zID0gb3B0aW9ucy52b2ljaW5nT25FbmRSZXNwb25zZU9wdGlvbnM7XHJcblxyXG4gICAgICAvLyBiZSBjYWxsZWQgbGFzdCwgYWZ0ZXIgb3B0aW9ucyBoYXZlIGJlZW4gc2V0IHRvIGB0aGlzYC5cclxuICAgICAgdGhpcy5zZXRBMTF5RGVwZW5kZW5jaWVzKCBvcHRpb25zLmExMXlEZXBlbmRlbmNpZXMgKTtcclxuXHJcbiAgICAgIC8vIGxpc3RlbmVycywgbXVzdCBiZSB1bmxpbmtlZCBpbiBkaXNwb3NlXHJcbiAgICAgIGNvbnN0IGVuYWJsZWRSYW5nZU9ic2VydmVyID0gKCBlbmFibGVkUmFuZ2U6IFJhbmdlICkgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCBtYXBwZWRNaW4gPSB0aGlzLl9nZXRNYXBwZWRWYWx1ZSggZW5hYmxlZFJhbmdlLm1pbiApO1xyXG4gICAgICAgIGNvbnN0IG1hcHBlZE1heCA9IHRoaXMuX2dldE1hcHBlZFZhbHVlKCBlbmFibGVkUmFuZ2UubWF4ICk7XHJcblxyXG4gICAgICAgIC8vIHBkb20gLSB1cGRhdGUgZW5hYmxlZCBzbGlkZXIgcmFuZ2UgZm9yIEFULCByZXF1aXJlZCBmb3Igc2NyZWVuIHJlYWRlciBldmVudHMgdG8gYmVoYXZlIGNvcnJlY3RseVxyXG4gICAgICAgIHRoaXMuc2V0UERPTUF0dHJpYnV0ZSggJ21pbicsIG1hcHBlZE1pbiApO1xyXG4gICAgICAgIHRoaXMuc2V0UERPTUF0dHJpYnV0ZSggJ21heCcsIG1hcHBlZE1heCApO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0ZXAgYXR0cmlidXRlIHNsaWRlciBlbGVtZW50IC0gdGhpcyBhdHRyaWJ1dGUgaXMgb25seSBhZGRlZCBiZWNhdXNlIGl0IGlzIHJlcXVpcmVkIHRvXHJcbiAgICAgICAgLy8gcmVjZWl2ZSBhY2Nlc3NpYmlsaXR5IGV2ZW50cyBvbiBhbGwgYnJvd3NlcnMsIGFuZCBpcyB0b3RhbGx5IHNlcGFyYXRlIGZyb20gdGhlIHN0ZXAgdmFsdWVzIGFib3ZlIHRoYXRcclxuICAgICAgICAvLyB3aWxsIG1vZGlmeSB0aGUgdmFsdWVQcm9wZXJ0eS4gU2VlIGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVNpYmxpbmdTdGVwQXR0cmlidXRlKCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuX2VuYWJsZWRSYW5nZVByb3BlcnR5LmxpbmsoIGVuYWJsZWRSYW5nZU9ic2VydmVyICk7XHJcblxyXG4gICAgICAvLyB3aGVuIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLCBiZSBzdXJlIHRvIHVwZGF0ZSB0aGUgYWNjZXNzaWJsZSBpbnB1dCB2YWx1ZSBhbmQgYXJpYS12YWx1ZXRleHQgd2hpY2ggaXMgcmVhZFxyXG4gICAgICAvLyBieSBhc3Npc3RpdmUgdGVjaG5vbG9neSB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzXHJcbiAgICAgIGNvbnN0IHZhbHVlUHJvcGVydHlMaXN0ZW5lciA9ICgpID0+IHtcclxuXHJcbiAgICAgICAgY29uc3QgbWFwcGVkVmFsdWUgPSB0aGlzLl9nZXRNYXBwZWRWYWx1ZSgpO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIGFyaWEtdmFsdWVub3cgYXR0cmlidXRlIGluIGNhc2UgdGhlIEFUIHJlcXVpcmVzIGl0IHRvIHJlYWQgdGhlIHZhbHVlIGNvcnJlY3RseSwgc29tZSBtYXlcclxuICAgICAgICAvLyBmYWxsIGJhY2sgb24gdGhpcyBmcm9tIGFyaWEtdmFsdWV0ZXh0IHNlZVxyXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FjY2Vzc2liaWxpdHkvQVJJQS9BUklBX1RlY2huaXF1ZXMvVXNpbmdfdGhlX2FyaWEtdmFsdWV0ZXh0X2F0dHJpYnV0ZSNQb3NzaWJsZV9lZmZlY3RzX29uX3VzZXJfYWdlbnRzX2FuZF9hc3Npc3RpdmVfdGVjaG5vbG9neVxyXG4gICAgICAgIHRoaXMuc2V0UERPTUF0dHJpYnV0ZSggJ2FyaWEtdmFsdWVub3cnLCBtYXBwZWRWYWx1ZSApO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgdGhlIFBET00gaW5wdXQgdmFsdWUgb24gUHJvcGVydHkgY2hhbmdlXHJcbiAgICAgICAgdGhpcy5pbnB1dFZhbHVlID0gbWFwcGVkVmFsdWU7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuX3ZhbHVlUHJvcGVydHkubGluayggdmFsdWVQcm9wZXJ0eUxpc3RlbmVyICk7XHJcblxyXG4gICAgICB0aGlzLl9kaXNwb3NlQWNjZXNzaWJsZVZhbHVlSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLl9lbmFibGVkUmFuZ2VQcm9wZXJ0eS51bmxpbmsoIGVuYWJsZWRSYW5nZU9ic2VydmVyICk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWVQcm9wZXJ0eS51bmxpbmsoIHZhbHVlUHJvcGVydHlMaXN0ZW5lciApO1xyXG4gICAgICAgIHRoaXMuX2RlcGVuZGVuY2llc011bHRpbGluayAmJiB0aGlzLl9kZXBlbmRlbmNpZXNNdWx0aWxpbmsuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuX3BhblRhcmdldE5vZGUgPSBudWxsO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlcmUgYXJlIHNvbWUgZmVhdHVyZXMgb2YgQWNjZXNzaWJsZVZhbHVlSGFuZGxlciB0aGF0IHN1cHBvcnQgdXBkYXRpbmcgd2hlbiBtb3JlIHRoYW4ganVzdCB0aGUgdmFsdWVQcm9wZXJ0eVxyXG4gICAgICogY2hhbmdlcy4gVXNlIHRoaXMgbWV0aG9kIHRvIHNldCB0aGUgZGVwZW5kZW5jeSBQcm9wZXJ0aWVzIGZvciB0aGlzIHZhbHVlIGhhbmRsZXIuIFRoaXMgd2lsbCBibG93IGF3YXkgdGhlXHJcbiAgICAgKiBwcmV2aW91cyBsaXN0IChsaWtlIE5vZGUuY2hpbGRyZW4pLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0QTExeURlcGVuZGVuY2llcyggZGVwZW5kZW5jaWVzOiBUUmVhZE9ubHlQcm9wZXJ0eTxJbnRlbnRpb25hbEFueT5bXSApOiB2b2lkIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggIWRlcGVuZGVuY2llcy5pbmNsdWRlcyggdGhpcy5fdmFsdWVQcm9wZXJ0eSApLFxyXG4gICAgICAgICdUaGUgdmFsdWUgUHJvcGVydHkgaXMgYWxyZWFkeSBhIGRlcGVuZGVuY3ksIGFuZCBkb2VzIG5vdCBuZWVkIHRvIGJlIGFkZGVkIHRvIHRoaXMgbGlzdCcgKTtcclxuXHJcbiAgICAgIC8vIGRpc3Bvc2UgdGhlIHByZXZpb3VzIG11bHRpbGluaywgdGhlcmUgaXMgb25seSBvbmUgc2V0IG9mIGRlcGVuZGVuY2llcywgdGhvdWdoIHRoZXkgY2FuIGJlIG92ZXJ3cml0dGVuLlxyXG4gICAgICB0aGlzLl9kZXBlbmRlbmNpZXNNdWx0aWxpbmsgJiYgdGhpcy5fZGVwZW5kZW5jaWVzTXVsdGlsaW5rLmRpc3Bvc2UoKTtcclxuXHJcbiAgICAgIHRoaXMuX2RlcGVuZGVuY2llc011bHRpbGluayA9IE11bHRpbGluay5tdWx0aWxpbmtBbnkoIGRlcGVuZGVuY2llcy5jb25jYXQoIFsgdGhpcy5fdmFsdWVQcm9wZXJ0eSBdICksICgpID0+IHtcclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlQXJpYVZhbHVlVGV4dCggdGhpcy5fb2xkVmFsdWUgKTtcclxuXHJcbiAgICAgICAgdGhpcy5fb2xkVmFsdWUgPSB0aGlzLl92YWx1ZVByb3BlcnR5LnZhbHVlO1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfdXBkYXRlQXJpYVZhbHVlVGV4dCggb2xkUHJvcGVydHlWYWx1ZTogbnVtYmVyIHwgbnVsbCApOiB2b2lkIHtcclxuICAgICAgY29uc3QgbWFwcGVkVmFsdWUgPSB0aGlzLl9nZXRNYXBwZWRWYWx1ZSgpO1xyXG5cclxuICAgICAgLy8gY3JlYXRlIHRoZSBkeW5hbWljIGFyaWEtdmFsdWV0ZXh0IGZyb20gYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQuXHJcbiAgICAgIGNvbnN0IG5ld0FyaWFWYWx1ZVRleHRWYWx1ZVR5cGUgPSB0aGlzLl9hMTF5Q3JlYXRlQXJpYVZhbHVlVGV4dCggbWFwcGVkVmFsdWUsIHRoaXMuX3ZhbHVlUHJvcGVydHkudmFsdWUsIG9sZFByb3BlcnR5VmFsdWUgKTtcclxuICAgICAgbGV0IG5ld0FyaWFWYWx1ZVRleHQgPSBQRE9NVXRpbHMudW53cmFwU3RyaW5nUHJvcGVydHkoIG5ld0FyaWFWYWx1ZVRleHRWYWx1ZVR5cGUgKSE7XHJcblxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2ltcGxlLXR5cGUtY2hlY2tpbmctYXNzZXJ0aW9uc1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0eXBlb2YgbmV3QXJpYVZhbHVlVGV4dCA9PT0gJ3N0cmluZycgKTtcclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBuZXcgYXJpYS12YWx1ZXRleHQgaXMgZGlmZmVyZW50IGZyb20gdGhlIHByZXZpb3VzIG9uZSwgc28gdGhhdCBpZiB0aGV5IGFyZSB0aGUgc2FtZVxyXG4gICAgICAvLyB0aGUgc2NyZWVuIHJlYWRlciB3aWxsIHN0aWxsIHJlYWQgdGhlIG5ldyB0ZXh0IC0gYWRkaW5nIGEgaGFpclNwYWNlIHJlZ2lzdGVycyBhcyBhIG5ldyBzdHJpbmcsIGJ1dCB0aGVcclxuICAgICAgLy8gc2NyZWVuIHJlYWRlciB3b24ndCByZWFkIHRoYXQgY2hhcmFjdGVyLlxyXG4gICAgICBjb25zdCBoYWlyU3BhY2UgPSAnXFx1MjAwQSc7XHJcbiAgICAgIGlmICggdGhpcy5fYTExeVJlcGVhdEVxdWFsVmFsdWVUZXh0ICYmIHRoaXMuYXJpYVZhbHVlVGV4dCAmJiBuZXdBcmlhVmFsdWVUZXh0ID09PSB0aGlzLmFyaWFWYWx1ZVRleHQucmVwbGFjZSggbmV3IFJlZ0V4cCggaGFpclNwYWNlLCAnZycgKSwgJycgKSApIHtcclxuICAgICAgICBuZXdBcmlhVmFsdWVUZXh0ID0gdGhpcy5hcmlhVmFsdWVUZXh0ICsgaGFpclNwYWNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmFyaWFWYWx1ZVRleHQgPSBuZXdBcmlhVmFsdWVUZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgZ2VuZXJhdGluZyBhbiBhbGVydCB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIHNsaWRlciB2YWx1ZSwgY3JlYXRlIHRoZSBhbGVydCBjb250ZW50IGFuZCBzZW5kIGl0XHJcbiAgICAgKiB0byB0aGUgdXR0ZXJhbmNlUXVldWUuIEZvciBWb2ljZU92ZXIsIGl0IGlzIGltcG9ydGFudCB0aGF0IGlmIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkIG11bHRpcGxlIHRpbWVzIGJlZm9yZVxyXG4gICAgICogdGhlIGFsZXJ0IGNhbiBiZSBzcG9rZW4sIHdlIHByb3ZpZGUgbW9yZSB0aW1lIGZvciB0aGUgQVQgdG8gZmluaXNoIHNwZWFraW5nIGFyaWEtdmFsdWV0ZXh0LiBPdGhlcndpc2UsIHRoZVxyXG4gICAgICogYWxlcnQgbWF5IGJlIGxvc3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvZ3Jhdml0eS1mb3JjZS1sYWItYmFzaWNzL2lzc3Vlcy8xNDYuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhbGVydENvbnRleHRSZXNwb25zZSgpOiB2b2lkIHtcclxuXHJcbiAgICAgIC8vIEFsZXJ0aW5nIHdpbGwgb2NjdXIgdG8gZWFjaCBjb25uZWN0ZWQgZGlzcGxheSdzIFV0dGVyYW5jZVF1ZXVlLCBidXQgd2Ugc2hvdWxkIG9ubHkgaW5jcmVtZW50IGRlbGF5IG9uY2UgcGVyXHJcbiAgICAgIC8vIHRpbWUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQuXHJcbiAgICAgIGxldCB0aW1lc0NoYW5nZWRCZWZvcmVBbGVydGluZ0luY3JlbWVudGVkID0gZmFsc2U7XHJcbiAgICAgIGlmICggdGhpcy5fYTExeUNyZWF0ZUNvbnRleHRSZXNwb25zZUFsZXJ0ICkge1xyXG5cclxuICAgICAgICBjb25zdCBtYXBwZWRWYWx1ZSA9IHRoaXMuX2dldE1hcHBlZFZhbHVlKCk7XHJcbiAgICAgICAgY29uc3QgZW5kSW50ZXJhY3Rpb25BbGVydCA9IHRoaXMuX2ExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydCggbWFwcGVkVmFsdWUsIHRoaXMuX3ZhbHVlUHJvcGVydHkudmFsdWUsIHRoaXMuX3ZhbHVlT25TdGFydCApO1xyXG5cclxuICAgICAgICAvLyBvbmx5IGlmIGl0IHJldHVybmVkIGFuIGFsZXJ0XHJcbiAgICAgICAgaWYgKCBlbmRJbnRlcmFjdGlvbkFsZXJ0ICkge1xyXG4gICAgICAgICAgdGhpcy5fY29udGV4dFJlc3BvbnNlVXR0ZXJhbmNlLmFsZXJ0ID0gZW5kSW50ZXJhY3Rpb25BbGVydDtcclxuICAgICAgICAgIHRoaXMuZm9yRWFjaFV0dGVyYW5jZVF1ZXVlKCAoIHV0dGVyYW5jZVF1ZXVlOiBVdHRlcmFuY2VRdWV1ZSApID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgaW5jcmVtZW50IGEgc2luZ2xlIHRpbWUsIHRoaXMgaGFzIHRoZSBjb25zdHJhaW50IHRoYXQgaWYgZGlmZmVyZW50IHV0dGVyYW5jZVF1ZXVlcyBtb3ZlIHRoaXNcclxuICAgICAgICAgICAgLy8gYWxlcnQgdGhyb3VnaCBhdCBhIGRpZmZlcmVudCB0aW1lLCB0aGUgZGVsYXkgY291bGQgYmUgaW5jb25zaXN0ZW50LCBidXQgaW4gZ2VuZXJhbCBpdCBzaG91bGQgd29yayB3ZWxsLlxyXG4gICAgICAgICAgICBpZiAoIHRpbWVzQ2hhbmdlZEJlZm9yZUFsZXJ0aW5nSW5jcmVtZW50ZWQgKSB7XHJcbiAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlIGZvciB0aGlzLl90aW1lc0NoYW5nZWRCZWZvcmVBbGVydGluZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCB1dHRlcmFuY2VRdWV1ZS5oYXNVdHRlcmFuY2UoIHRoaXMuX2NvbnRleHRSZXNwb25zZVV0dGVyYW5jZSApICkge1xyXG4gICAgICAgICAgICAgIHRpbWVzQ2hhbmdlZEJlZm9yZUFsZXJ0aW5nSW5jcmVtZW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIHRoaXMuX3RpbWVzQ2hhbmdlZEJlZm9yZUFsZXJ0aW5nKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fdGltZXNDaGFuZ2VkQmVmb3JlQWxlcnRpbmcgPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGp1c3QgdGhlIGRlbGF5IG9mIHRoZSB1dHRlcmFuY2UgYmFzZWQgb24gbnVtYmVyIG9mIHRpbWVzIGl0IGhhcyBiZWVuIHJlLWFkZGVkIHRvIHRoZSBxdWV1ZS4gRWFjaFxyXG4gICAgICAgICAgICAvLyB0aW1lIHRoZSBhcmlhLXZhbHVldGV4dCBjaGFuZ2VzLCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRvIGdpdmUgZW5vdWdoIHRpbWUgZm9yIHRoZVxyXG4gICAgICAgICAgICAvLyBhcmlhLXZhbHVldGV4dCB0byBmdWxseSBjb21wbGV0ZSBiZWZvcmUgYWxlcnRpbmcgdGhpcyBjb250ZXh0IHJlc3BvbnNlLlxyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0UmVzcG9uc2VVdHRlcmFuY2UuYWxlcnRTdGFibGVEZWxheSA9IE1hdGgubWluKCB0aGlzLl9jb250ZXh0UmVzcG9uc2VNYXhEZWxheSxcclxuICAgICAgICAgICAgICB0aGlzLl90aW1lc0NoYW5nZWRCZWZvcmVBbGVydGluZyAqIHRoaXMuX2NvbnRleHRSZXNwb25zZVBlclZhbHVlQ2hhbmdlRGVsYXkgKTtcclxuXHJcbiAgICAgICAgICAgIHV0dGVyYW5jZVF1ZXVlLmFkZFRvQmFjayggdGhpcy5fY29udGV4dFJlc3BvbnNlVXR0ZXJhbmNlICk7XHJcbiAgICAgICAgICB9ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoZSBtb2RlbCBkZXBlbmRlbmNpZXMgaGF2ZSBiZWVuIHJlc2V0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuXHJcbiAgICAgIC8vIHJlc2V0IHRoZSBhcmlhLXZhbHVldGV4dCBjcmVhdG9yIGlmIGl0IHN1cHBvcnRzIHRoYXRcclxuICAgICAgdGhpcy5fYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQucmVzZXQgJiYgdGhpcy5fYTExeUNyZWF0ZUFyaWFWYWx1ZVRleHQucmVzZXQoKTtcclxuICAgICAgdGhpcy5fYTExeUNyZWF0ZUNvbnRleHRSZXNwb25zZUFsZXJ0ICYmIHRoaXMuX2ExMXlDcmVhdGVDb250ZXh0UmVzcG9uc2VBbGVydC5yZXNldCAmJiB0aGlzLl9hMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlQWxlcnQucmVzZXQoKTtcclxuXHJcbiAgICAgIHRoaXMuX3RpbWVzQ2hhbmdlZEJlZm9yZUFsZXJ0aW5nID0gMDtcclxuICAgICAgLy8gb24gcmVzZXQsIG1ha2Ugc3VyZSB0aGF0IHRoZSBQRE9NIGRlc2NyaXB0aW9ucyBhcmUgY29tcGxldGVseSB1cCB0byBkYXRlLlxyXG4gICAgICB0aGlzLl91cGRhdGVBcmlhVmFsdWVUZXh0KCBudWxsICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQgdGhlIGZvcm1hdHRlZCB2YWx1ZSBiYXNlZCBvbiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgUHJvcGVydHkuXHJcbiAgICAgKiBAcGFyYW0gW3ZhbHVlXSAtIGlmIG5vdCBwcm92aWRlZCwgd2lsbCB1c2UgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHZhbHVlUHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfZ2V0TWFwcGVkVmFsdWUoIHZhbHVlOiBudW1iZXIgPSB0aGlzLl92YWx1ZVByb3BlcnR5LnZhbHVlICk6IG51bWJlciB7XHJcbiAgICAgIGNvbnN0IG1hcHBlZFZhbHVlID0gdGhpcy5fYTExeU1hcFBET01WYWx1ZSggdmFsdWUgKTtcclxuICAgICAgcmV0dXJuIG1hcHBlZFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBpbnB1dCBsaXN0ZW5lciB0aGF0IGNvdWxkIGJlIGF0dGFjaGVkIHRvIG1peGVkIGluIHR5cGVzIG9mIEFjY2Vzc2libGVWYWx1ZUhhbmRsZXIgdG8gc3VwcG9ydFxyXG4gICAgICogaW50ZXJhY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBY2Nlc3NpYmxlVmFsdWVIYW5kbGVySW5wdXRMaXN0ZW5lcigpOiBUSW5wdXRMaXN0ZW5lciB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAga2V5ZG93bjogdGhpcy5oYW5kbGVLZXlEb3duLmJpbmQoIHRoaXMgKSxcclxuICAgICAgICBrZXl1cDogdGhpcy5oYW5kbGVLZXlVcC5iaW5kKCB0aGlzICksXHJcbiAgICAgICAgaW5wdXQ6IHRoaXMuaGFuZGxlSW5wdXQuYmluZCggdGhpcyApLFxyXG4gICAgICAgIGNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2UuYmluZCggdGhpcyApLFxyXG4gICAgICAgIGJsdXI6IHRoaXMuaGFuZGxlQmx1ci5iaW5kKCB0aGlzIClcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBhIGtleWRvd24gZXZlbnQgc28gdGhhdCB0aGUgdmFsdWUgaGFuZGxlciBiZWhhdmVzIGxpa2UgYSB0cmFkaXRpb25hbCBpbnB1dCB0aGF0IG1vZGlmaWVzXHJcbiAgICAgKiBhIG51bWJlci4gV2UgZXhwZWN0IHRoZSBmb2xsb3dpbmc6XHJcbiAgICAgKiAgIC0gVXAgQXJyb3cvUmlnaHQgQXJyb3cgaW5jcmVtZW50cyB2YWx1ZSBieSBrZXlib2FyZFN0ZXBcclxuICAgICAqICAgLSBEb3duIEFycm93L0xlZnQgQXJyb3cgZGVjcmVtZW50cyB2YWx1ZSBieSBzdGVwIHNpemVcclxuICAgICAqICAgLSBQYWdlIHVwL1BhZ2UgZG93biB3aWxsIGluY3JlbWVudC9kZWNyZW1lbnQgdmFsdWUgcGFnZUtleWJvYXJkU3RlcFxyXG4gICAgICogICAtIEhvbWUvRW5kIHdpbGwgc2V0IHZhbHVlIHRvIG1pbi9tYXggdmFsdWUgZm9yIHRoZSByYW5nZVxyXG4gICAgICogICAtIFByZXNzaW5nIHNoaWZ0IHdpdGggYW4gYXJyb3cga2V5IHdpbGwgaW5jcmVtZW50L2RlY3JlbWVudCB2YWx1ZSBieSBzaGlmdEtleWJvYXJkU3RlcFxyXG4gICAgICpcclxuICAgICAqIEFkZCB0aGlzIGFzIGFuIGlucHV0IGxpc3RlbmVyIHRvIHRoZSBga2V5ZG93bmAgZXZlbnQgdG8gdGhlIE5vZGUgbWl4aW5nIGluIEFjY2Vzc2libGVWYWx1ZUhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBoYW5kbGVLZXlEb3duKCBldmVudDogU2NlbmVyeUV2ZW50PEtleWJvYXJkRXZlbnQ+ICk6IHZvaWQge1xyXG5cclxuICAgICAgY29uc3QgZG9tRXZlbnQgPSBldmVudC5kb21FdmVudCE7XHJcblxyXG4gICAgICBjb25zdCBrZXkgPSBLZXlib2FyZFV0aWxzLmdldEV2ZW50Q29kZSggZG9tRXZlbnQgKTtcclxuXHJcbiAgICAgIGlmICggIWtleSApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3NoaWZ0S2V5ID0gZG9tRXZlbnQuc2hpZnRLZXk7XHJcblxyXG5cclxuICAgICAgLy8gaWYgd2UgcmVjZWl2ZSBhICd0YWInIGtleWRvd24gZXZlbnQsIGRvIG5vdCBhbGxvdyB0aGUgYnJvd3NlciB0byByZWFjdCB0byB0aGlzIGxpa2UgYSBzdWJtaXNzaW9uIGFuZFxyXG4gICAgICAvLyBwcmV2ZW50IHJlc3BvbmRpbmcgdG8gdGhlIGBpbnB1dGAgZXZlbnRcclxuICAgICAgaWYgKCBLZXlib2FyZFV0aWxzLmlzS2V5RXZlbnQoIGRvbUV2ZW50LCBLZXlib2FyZFV0aWxzLktFWV9UQUIgKSApIHtcclxuICAgICAgICB0aGlzLl9ibG9ja0lucHV0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCB0aGlzLmVuYWJsZWRQcm9wZXJ0eS5nZXQoKSApIHtcclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IHNvIGJyb3dzZXIgZG9lc24ndCBjaGFuZ2UgaW5wdXQgdmFsdWUgYXV0b21hdGljYWxseVxyXG4gICAgICAgIGlmICggS2V5Ym9hcmRVdGlscy5pc1JhbmdlS2V5KCBkb21FdmVudCApICkge1xyXG5cclxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIHByZXZlbnQgYW55IFwiY2hhbmdlXCIgYW5kIFwiaW5wdXRcIiBldmVudHMgc28gd2UgZG9uJ3QgY2hhbmdlIHRoZSB2YWx1ZSB0d2ljZSwgYnV0IGl0IGFsc29cclxuICAgICAgICAgIC8vIHByZXZlbnRzIGEgVm9pY2VPdmVyIGlzc3VlIHdoZXJlIHByZXNzaW5nIGFycm93IGtleXMgYm90aCBjaGFuZ2VzIHRoZSBzbGlkZXIgdmFsdWUgQU5EIG1vdmVzIHRoZVxyXG4gICAgICAgICAgLy8gdmlydHVhbCBjdXJzb3IuIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSBldmVyeSByYW5nZSBrZXkgZXZlbnQgc28gdGhhdCB3ZSBkb24ndCBjaGFuZ2UgdGhlIHZhbHVlIHdpdGhcclxuICAgICAgICAgIC8vIGFuICdpbnB1dCcgb3IgJ2NoYW5nZScgZXZlbnQsIGV2ZW4gd2hlbiB0aGUgbWV0YSBrZXkgaXMgZG93bi5cclxuICAgICAgICAgIGRvbUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgLy8gT24gTWFjLCB3ZSBkb24ndCBnZXQgYSBrZXl1cCBldmVudCB3aGVuIHRoZSBtZXRhIGtleSBpcyBkb3duIHNvIGRvbid0IGNoYW5nZSB0aGUgdmFsdWUgb3IgZG9cclxuICAgICAgICAgIC8vIGFueXRoaW5nIHRoYXQgYXNzdW1lcyB3ZSB3aWxsIGdldCBhIGNvcnJlc3BvbmRpbmcga2V5dXAgZXZlbnQsIHNlZVxyXG4gICAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE4MTg2Mzcvd2h5LWRvZXMtamF2YXNjcmlwdC1kcm9wLWtleXVwLWV2ZW50cy13aGVuLXRoZS1tZXRha2V5LWlzLXByZXNzZWQtb24tbWFjLWJyb3dzZXJcclxuICAgICAgICAgIGlmICggIWRvbUV2ZW50Lm1ldGFLZXkgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBzaWduaWZ5IHRoYXQgdGhpcyBsaXN0ZW5lciBpcyByZXNlcnZlZCBmb3IgZHJhZ2dpbmcgc28gdGhhdCBvdGhlciBsaXN0ZW5lcnMgY2FuIGNoYW5nZVxyXG4gICAgICAgICAgICAvLyB0aGVpciBiZWhhdmlvciBkdXJpbmcgc2NlbmVyeSBldmVudCBkaXNwYXRjaFxyXG4gICAgICAgICAgICBldmVudC5wb2ludGVyLnJlc2VydmVGb3JLZXlib2FyZERyYWcoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgd2Ugd2lsbCB1c2UgY29uc3RyYWluVmFsdWUgdG8gbW9kaWZ5IHRoZSBwcm9wb3NlZCB2YWx1ZSwgc2VlIHVzYWdlcyBiZWxvd1xyXG4gICAgICAgICAgICBsZXQgdXNlQ29uc3RyYWluVmFsdWUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgZmlyc3Qga2V5ZG93biB0aGlzIGlzIHRoZSBzdGFydCBvZiB0aGUgZHJhZyBpbnRlcmFjdGlvblxyXG4gICAgICAgICAgICBpZiAoICF0aGlzLl9hbnlLZXlzRG93bigpICkge1xyXG4gICAgICAgICAgICAgIHRoaXMuX29uSW50ZXJhY3Rpb25TdGFydCggZXZlbnQgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdHJhY2sgdGhhdCBhIG5ldyBrZXkgaXMgYmVpbmcgaGVsZCBkb3duXHJcbiAgICAgICAgICAgIHRoaXMuX3JhbmdlS2V5c0Rvd25bIGtleSBdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IHRoaXMuX3ZhbHVlUHJvcGVydHkuZ2V0KCk7XHJcbiAgICAgICAgICAgIGlmICggS2V5Ym9hcmRVdGlscy5pc0FueUtleUV2ZW50KCBkb21FdmVudCwgWyBLZXlib2FyZFV0aWxzLktFWV9FTkQsIEtleWJvYXJkVXRpbHMuS0VZX0hPTUUgXSApICkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBvbiAnZW5kJyBhbmQgJ2hvbWUnIHNuYXAgdG8gbWF4IGFuZCBtaW4gb2YgZW5hYmxlZCByYW5nZSByZXNwZWN0aXZlbHkgKHRoaXMgaXMgdHlwaWNhbCBicm93c2VyXHJcbiAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgZm9yIHNsaWRlcnMpXHJcbiAgICAgICAgICAgICAgaWYgKCBrZXkgPT09IEtleWJvYXJkVXRpbHMuS0VZX0VORCApIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5fZW5hYmxlZFJhbmdlUHJvcGVydHkuZ2V0KCkubWF4O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIGlmICgga2V5ID09PSBLZXlib2FyZFV0aWxzLktFWV9IT01FICkge1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLl9lbmFibGVkUmFuZ2VQcm9wZXJ0eS5nZXQoKS5taW47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIGxldCBzdGVwU2l6ZTtcclxuICAgICAgICAgICAgICBpZiAoIGtleSA9PT0gS2V5Ym9hcmRVdGlscy5LRVlfUEFHRV9VUCB8fCBrZXkgPT09IEtleWJvYXJkVXRpbHMuS0VZX1BBR0VfRE9XTiApIHtcclxuICAgICAgICAgICAgICAgIC8vIG9uIHBhZ2UgdXAgYW5kIHBhZ2UgZG93biwgdGhlIGRlZmF1bHQgc3RlcCBzaXplIGlzIDEvMTAgb2YgdGhlIHJhbmdlICh0aGlzIGlzIHR5cGljYWwgYnJvd3NlciBiZWhhdmlvcilcclxuICAgICAgICAgICAgICAgIHN0ZXBTaXplID0gdGhpcy5wYWdlS2V5Ym9hcmRTdGVwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgga2V5ID09PSBLZXlib2FyZFV0aWxzLktFWV9QQUdFX1VQICkge1xyXG4gICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuX3ZhbHVlUHJvcGVydHkuZ2V0KCkgKyBzdGVwU2l6ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBrZXkgPT09IEtleWJvYXJkVXRpbHMuS0VZX1BBR0VfRE9XTiApIHtcclxuICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLl92YWx1ZVByb3BlcnR5LmdldCgpIC0gc3RlcFNpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKCBLZXlib2FyZFV0aWxzLmlzQXJyb3dLZXkoIGRvbUV2ZW50ICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkIGRvd24sIG1vZGlmeSB0aGUgc3RlcCBzaXplICh0aGlzIGlzIGF0eXBpY2FsIGJyb3dzZXIgYmVoYXZpb3IgZm9yIHNsaWRlcnMpXHJcbiAgICAgICAgICAgICAgICBzdGVwU2l6ZSA9IGRvbUV2ZW50LnNoaWZ0S2V5ID8gdGhpcy5zaGlmdEtleWJvYXJkU3RlcCA6IHRoaXMua2V5Ym9hcmRTdGVwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kLCBpZiB1c2luZyBzaGlmdCBrZXkgd2l0aCBhcnJvdyBrZXlzIHRvIHVzZSB0aGUgc2hpZnRLZXlib2FyZFN0ZXAsIGRvbid0XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgY29uc3RyYWluVmFsdWUgYmVjYXVzZSB0aGUgY29uc3RyYWluVmFsdWUgaXMgb2Z0ZW4gc21hbGxlciB0aGFuIHRoZSB2YWx1ZXMgYWxsb3dlZCBieVxyXG4gICAgICAgICAgICAgICAgLy8gY29uc3RyYWluVmFsdWUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc3VuL2lzc3Vlcy82OTguXHJcbiAgICAgICAgICAgICAgICB1c2VDb25zdHJhaW5WYWx1ZSA9ICFkb21FdmVudC5zaGlmdEtleTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGtleSA9PT0gS2V5Ym9hcmRVdGlscy5LRVlfUklHSFRfQVJST1cgfHwga2V5ID09PSBLZXlib2FyZFV0aWxzLktFWV9VUF9BUlJPVyApIHtcclxuICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLl92YWx1ZVByb3BlcnR5LmdldCgpICsgc3RlcFNpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgga2V5ID09PSBLZXlib2FyZFV0aWxzLktFWV9MRUZUX0FSUk9XIHx8IGtleSA9PT0gS2V5Ym9hcmRVdGlscy5LRVlfRE9XTl9BUlJPVyApIHtcclxuICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLl92YWx1ZVByb3BlcnR5LmdldCgpIC0gc3RlcFNpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLl9yb3VuZFRvU3RlcFNpemUgKSB7XHJcbiAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gcm91bmRWYWx1ZSggbmV3VmFsdWUsIHRoaXMuX3ZhbHVlUHJvcGVydHkuZ2V0KCksIHN0ZXBTaXplICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYXAgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICBjb25zdCBtYXBwZWRWYWx1ZSA9IHRoaXMuX2ExMXlNYXBWYWx1ZSggbmV3VmFsdWUsIHRoaXMuX3ZhbHVlUHJvcGVydHkuZ2V0KCkgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsbHkgY29uc3RyYWluIHRoZSB2YWx1ZS4gT25seSBjb25zdHJhaW4gaWYgbW9kaWZ5aW5nIGJ5IHNoaWZ0S2V5Ym9hcmRTdGVwIGJlY2F1c2UgdGhhdCBzdGVwIHNpemVcclxuICAgICAgICAgICAgLy8gbWF5IGFsbG93IGZpbmVyIHByZWNpc2lvbiB0aGFuIGNvbnN0cmFpblZhbHVlLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvNjk4LCBhbmQgaXMgYWN0dWFsbHkgYSBwcm9ibGVtIGZvciBhbGwga2V5Ym9hcmQgc3RlcHMgaWYgdGhleVxyXG4gICAgICAgICAgICAvLyBhcmUgc21hbGxlciB0aGFuIHZhbHVlcyBhbGxvd2VkIGJ5IGNvbnN0cmFpblZhbHVlLiBJbiBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc3VuL2lzc3Vlcy83MDMgd2VcclxuICAgICAgICAgICAgLy8gd2lsbCB3b3JrIHRvIHJlc29sdmUgdGhpcyBtb3JlIGdlbmVyYWxseS5cclxuICAgICAgICAgICAgbGV0IGNvbnN0cmFpbmVkVmFsdWUgPSBtYXBwZWRWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKCB1c2VDb25zdHJhaW5WYWx1ZSApIHtcclxuICAgICAgICAgICAgICBjb25zdHJhaW5lZFZhbHVlID0gdGhpcy5fY29uc3RyYWluVmFsdWUoIG1hcHBlZFZhbHVlICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGxpbWl0IHRoZSB2YWx1ZSB0byB0aGUgZW5hYmxlZCByYW5nZVxyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZVByb3BlcnR5LnNldCggVXRpbHMuY2xhbXAoIGNvbnN0cmFpbmVkVmFsdWUsIHRoaXMuX2VuYWJsZWRSYW5nZVByb3BlcnR5LmdldCgpLm1pbiwgdGhpcy5fZW5hYmxlZFJhbmdlUHJvcGVydHkuZ2V0KCkubWF4ICkgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG9wdGlvbmFsIGNhbGxiYWNrIGFmdGVyIHRoZSB2YWx1ZVByb3BlcnR5IGlzIHNldCAoZXZlbiBpZiBzZXQgdG8gdGhlIHNhbWUgdmFsdWUpIHNvIHRoYXQgdGhlIGxpc3RlbmVyXHJcbiAgICAgICAgICAgIC8vIGNhbiB1c2UgdGhlIG5ldyB2YWx1ZS5cclxuICAgICAgICAgICAgdGhpcy5fb25JbnB1dCggZXZlbnQgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBrZXkgdXAgZXZlbnQgb24gdGhpcyBhY2Nlc3NpYmxlIHNsaWRlciwgbWFuYWdpbmcgdGhlIHNoaWZ0IGtleSwgYW5kIGNhbGxpbmcgYW4gb3B0aW9uYWwgZW5kRHJhZ1xyXG4gICAgICogZnVuY3Rpb24gb24gcmVsZWFzZS4gQWRkIHRoaXMgYXMgYW4gaW5wdXQgbGlzdGVuZXIgdG8gdGhlIG5vZGUgbWl4aW5nIGluIEFjY2Vzc2libGVWYWx1ZUhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBoYW5kbGVLZXlVcCggZXZlbnQ6IFNjZW5lcnlFdmVudDxLZXlib2FyZEV2ZW50PiApOiB2b2lkIHtcclxuICAgICAgY29uc3Qga2V5ID0gS2V5Ym9hcmRVdGlscy5nZXRFdmVudENvZGUoIGV2ZW50LmRvbUV2ZW50ICkhO1xyXG5cclxuICAgICAgLy8gaGFuZGxlIGNhc2Ugd2hlcmUgdXNlciB0YWJiZWQgdG8gdGhpcyBpbnB1dCB3aGlsZSBhbiBhcnJvdyBrZXkgbWlnaHQgaGF2ZSBiZWVuIGhlbGQgZG93blxyXG4gICAgICBpZiAoIHRoaXMuX2FsbEtleXNVcCgpICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcmVzZXQgc2hpZnQga2V5IGZsYWcgd2hlbiB3ZSByZWxlYXNlIGl0XHJcbiAgICAgIGlmICggS2V5Ym9hcmRVdGlscy5TSElGVF9LRVlTLmluY2x1ZGVzKCBrZXkgKSApIHtcclxuICAgICAgICB0aGlzLl9zaGlmdEtleSA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIHRoaXMuZW5hYmxlZFByb3BlcnR5LmdldCgpICkge1xyXG4gICAgICAgIGlmICggS2V5Ym9hcmRVdGlscy5pc1JhbmdlS2V5KCBldmVudC5kb21FdmVudCApICkge1xyXG4gICAgICAgICAgdGhpcy5fcmFuZ2VLZXlzRG93blsga2V5IF0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAvLyB3aGVuIGFsbCByYW5nZSBrZXlzIGFyZSByZWxlYXNlZCwgd2UgYXJlIGRvbmUgZHJhZ2dpbmdcclxuICAgICAgICAgIGlmICggdGhpcy5fYWxsS2V5c1VwKCkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uSW50ZXJhY3Rpb25FbmQoIGV2ZW50ICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWb2ljZU92ZXIgc2VuZHMgYSBcImNoYW5nZVwiIGV2ZW50IHRvIHRoZSBzbGlkZXIgKE5PVCBhbiBpbnB1dCBldmVudCksIHNvIHdlIG5lZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZW5cclxuICAgICAqIGEgY2hhbmdlIGV2ZW50IGlzIHNlbnQgYnV0IGFuIGlucHV0IGV2ZW50IGlucyd0IGhhbmRsZWQuIEd1YXJkZWQgYWdhaW5zdCB0aGUgY2FzZSB0aGF0IEJPVEggY2hhbmdlIGFuZFxyXG4gICAgICogaW5wdXQgYXJlIHNlbnQgdG8gdGhlIGJyb3dzZXIgYnkgdGhlIEFULlxyXG4gICAgICpcclxuICAgICAqIEFkZCB0aGlzIGFzIGEgbGlzdGVuZXIgdG8gdGhlICdjaGFuZ2UnIGlucHV0IGV2ZW50IG9uIHRoZSBOb2RlIHRoYXQgaXMgbWl4aW5nIGluIEFjY2Vzc2libGVWYWx1ZUhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBoYW5kbGVDaGFuZ2UoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgKTogdm9pZCB7XHJcblxyXG4gICAgICBpZiAoICF0aGlzLl9hMTF5SW5wdXRIYW5kbGVkICkge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlSW5wdXQoIGV2ZW50ICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2ExMXlJbnB1dEhhbmRsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBhIGRpcmVjdCAnaW5wdXQnIGV2ZW50IHRoYXQgbWlnaHQgY29tZSBmcm9tIGFzc2lzdGl2ZSB0ZWNobm9sb2d5LiBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSB1c2VyIGFnZW50XHJcbiAgICAgKiAocGFydGljdWxhcmx5IFZvaWNlT3Zlciwgb3IgYSBzd2l0Y2ggZGV2aWNlKSB3aWxsIGluaXRpYXRlIGFuIGlucHV0IGV2ZW50IGRpcmVjdGx5IHdpdGhvdXQgZ29pbmcgdGhyb3VnaFxyXG4gICAgICoga2V5ZG93bi4gSW4gdGhhdCBjYXNlLCBoYW5kbGUgdGhlIGNoYW5nZSBkZXBlbmRpbmcgb24gd2hpY2ggZGlyZWN0aW9uIHRoZSB1c2VyIHRyaWVkIHRvIGdvLiBXZSBkZXRlcm1pbmVcclxuICAgICAqIHRoaXMgYnkgZGV0ZWN0aW5nIGhvdyB0aGUgaW5wdXQgdmFsdWUgY2hhbmdlZCBpbiByZXNwb25zZSB0byB0aGUgYGlucHV0YCBldmVudCByZWxhdGl2ZSB0byB0aGUgY3VycmVudFxyXG4gICAgICogdmFsdWUgb2YgdGhlIHZhbHVlUHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IGl0IGlzIGltcG9ydGFudCB0byBoYW5kbGUgdGhlIFwiaW5wdXRcIiBldmVudCwgcmF0aGVyIHRoYW4gdGhlIFwiY2hhbmdlXCIgZXZlbnQuIFRoZSBcImlucHV0XCIgd2lsbFxyXG4gICAgICogZmlyZSB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIGZyb20gYSBnZXN0dXJlLCB3aGlsZSB0aGUgXCJjaGFuZ2VcIiB3aWxsIG9ubHkgaGFwcGVuIG9uIHN1Ym1pc3Npb24sIGxpa2UgYXNcclxuICAgICAqIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEFkZCB0aGlzIGFzIGEgbGlzdGVuZXIgdG8gdGhlIGBpbnB1dGAgZXZlbnQgb24gdGhlIE5vZGUgdGhhdCBpcyBtaXhpbmcgaW4gQWNjZXNzaWJsZVZhbHVlSGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGhhbmRsZUlucHV0KCBldmVudDogU2NlbmVyeUV2ZW50ICk6IHZvaWQge1xyXG4gICAgICBpZiAoIHRoaXMuZW5hYmxlZFByb3BlcnR5LmdldCgpICYmICF0aGlzLl9ibG9ja0lucHV0ICkge1xyXG5cclxuICAgICAgICAvLyBkb24ndCBoYW5kbGUgYWdhaW4gb24gXCJjaGFuZ2VcIiBldmVudFxyXG4gICAgICAgIHRoaXMuX2ExMXlJbnB1dEhhbmRsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICBsZXQgbmV3VmFsdWUgPSB0aGlzLl92YWx1ZVByb3BlcnR5LmdldCgpO1xyXG5cclxuICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gcGFyc2VGbG9hdCggKCBldmVudC5kb21FdmVudCEudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQgKS52YWx1ZSApO1xyXG4gICAgICAgIGNvbnN0IHN0ZXBTaXplID0gdGhpcy5fc2hpZnRLZXkgPyB0aGlzLnNoaWZ0S2V5Ym9hcmRTdGVwIDogdGhpcy5rZXlib2FyZFN0ZXA7XHJcbiAgICAgICAgY29uc3QgbWFwcGVkVmFsdWUgPSB0aGlzLl9nZXRNYXBwZWRWYWx1ZSgpO1xyXG5cclxuICAgICAgICAvLyBzdGFydCBvZiBjaGFuZ2UgZXZlbnQgaXMgc3RhcnQgb2YgZHJhZ1xyXG4gICAgICAgIHRoaXMuX29uSW50ZXJhY3Rpb25TdGFydCggZXZlbnQgKTtcclxuXHJcbiAgICAgICAgaWYgKCBpbnB1dFZhbHVlID4gbWFwcGVkVmFsdWUgKSB7XHJcbiAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuX3ZhbHVlUHJvcGVydHkuZ2V0KCkgKyBzdGVwU2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIGlucHV0VmFsdWUgPCBtYXBwZWRWYWx1ZSApIHtcclxuICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5fdmFsdWVQcm9wZXJ0eS5nZXQoKSAtIHN0ZXBTaXplO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLl9yb3VuZFRvU3RlcFNpemUgKSB7XHJcbiAgICAgICAgICBuZXdWYWx1ZSA9IHJvdW5kVmFsdWUoIG5ld1ZhbHVlLCB0aGlzLl92YWx1ZVByb3BlcnR5LmdldCgpLCBzdGVwU2l6ZSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbGltaXQgdG8gZW5hYmxlZCByYW5nZVxyXG4gICAgICAgIG5ld1ZhbHVlID0gVXRpbHMuY2xhbXAoIG5ld1ZhbHVlLCB0aGlzLl9lbmFibGVkUmFuZ2VQcm9wZXJ0eS5nZXQoKS5taW4sIHRoaXMuX2VuYWJsZWRSYW5nZVByb3BlcnR5LmdldCgpLm1heCApO1xyXG5cclxuICAgICAgICAvLyBvcHRpb25hbGx5IGNvbnN0cmFpbiB2YWx1ZVxyXG4gICAgICAgIHRoaXMuX3ZhbHVlUHJvcGVydHkuc2V0KCB0aGlzLl9jb25zdHJhaW5WYWx1ZSggdGhpcy5fYTExeU1hcFZhbHVlKCBuZXdWYWx1ZSwgdGhpcy5fdmFsdWVQcm9wZXJ0eS5nZXQoKSApICkgKTtcclxuXHJcbiAgICAgICAgLy8gb25seSBvbmUgY2hhbmdlIHBlciBpbnB1dCwgYnV0IHN0aWxsIGNhbGwgb3B0aW9uYWwgb25JbnB1dCBmdW5jdGlvbiAtIGFmdGVyIHZhbHVlUHJvcGVydHkgaXMgc2V0IChldmVuIGlmXHJcbiAgICAgICAgLy8gc2V0IHRvIHRoZSBzYW1lIHZhbHVlKSBzbyBsaXN0ZW5lciBjYW4gdXNlIG5ldyB2YWx1ZS5cclxuICAgICAgICB0aGlzLl9vbklucHV0KCBldmVudCApO1xyXG5cclxuICAgICAgICAvLyBlbmQgb2YgY2hhbmdlIGlzIHRoZSBlbmQgb2YgYSBkcmFnXHJcbiAgICAgICAgdGhpcy5fb25JbnRlcmFjdGlvbkVuZCggZXZlbnQgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZG9uJ3QgYmxvY2sgdGhlIG5leHQgaW5wdXQgYWZ0ZXIgcmVjZWl2aW5nIG9uZSwgc29tZSBBVCBtYXkgc2VuZCBlaXRoZXIgYGtleWRvd25gIG9yIGBpbnB1dGAgZXZlbnRzXHJcbiAgICAgIC8vIGRlcGVuZGluZyBvbiBtb2RpZmllciBrZXlzIHNvIHdlIG5lZWQgdG8gYmUgcmVhZHkgdG8gcmVjZWl2ZSBlaXRoZXIgb24gbmV4dCBpbnRlcmFjdGlvblxyXG4gICAgICB0aGlzLl9ibG9ja0lucHV0ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBhY2Nlc3NpYmxlIHNsaWRlciBsb3NlcyBmb2N1cy5cclxuICAgICAqXHJcbiAgICAgKiBBZGQgdGhpcyBhcyBhIGxpc3RlbmVyIG9uIHRoZSBgYmx1cmAgZXZlbnQgdG8gdGhlIE5vZGUgdGhhdCBpcyBtaXhpbmcgaW4gQWNjZXNzaWJsZVZhbHVlSGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGhhbmRsZUJsdXIoIGV2ZW50OiBTY2VuZXJ5RXZlbnQ8Rm9jdXNFdmVudD4gKTogdm9pZCB7XHJcblxyXG4gICAgICAvLyBpZiBhbnkgcmFuZ2Uga2V5cyBhcmUgY3VycmVudGx5IGRvd24sIGNhbGwgZW5kIGRyYWcgYmVjYXVzZSB1c2VyIGhhcyBzdG9wcGVkIGRyYWdnaW5nIHRvIGRvIHNvbWV0aGluZyBlbHNlXHJcbiAgICAgIGlmICggdGhpcy5fYW55S2V5c0Rvd24oKSApIHtcclxuICAgICAgICB0aGlzLl9vbkludGVyYWN0aW9uRW5kKCBldmVudCApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZXNldCBmbGFnIGluIGNhc2Ugd2Ugc2hpZnQtdGFiYmVkIGF3YXkgZnJvbSBzbGlkZXJcclxuICAgICAgdGhpcy5fc2hpZnRLZXkgPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIHdoZW4gZm9jdXMgbGVhdmVzIHRoaXMgZWxlbWVudCBzdG9wIGJsb2NraW5nIGlucHV0IGV2ZW50c1xyXG4gICAgICB0aGlzLl9ibG9ja0lucHV0ID0gZmFsc2U7XHJcblxyXG4gICAgICAvLyByZXNldCBjb3VudGVyIGZvciByYW5nZSBrZXlzIGRvd25cclxuICAgICAgdGhpcy5fcmFuZ2VLZXlzRG93biA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJhY3Rpb24gd2l0aCB0aGlzIGlucHV0IGhhcyBzdGFydGVkLCBzYXZlIHRoZSB2YWx1ZSBvbiBzdGFydCBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGFzIGFuIFwib2xkXCIgdmFsdWVcclxuICAgICAqIHdoZW4gZ2VuZXJhdGluZyB0aGUgY29udGV4dCByZXNwb25zZSB3aXRoIG9wdGlvbiBhMTF5Q3JlYXRlQ29udGV4dFJlc3BvbnNlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9vbkludGVyYWN0aW9uU3RhcnQoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuX3ZhbHVlT25TdGFydCA9IHRoaXMuX3ZhbHVlUHJvcGVydHkudmFsdWU7XHJcbiAgICAgIHRoaXMuX3N0YXJ0SW5wdXQoIGV2ZW50ICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcmFjdGlvbiB3aXRoIHRoaXMgaW5wdXQgaGFzIGNvbXBsZXRlZCwgZ2VuZXJhdGUgYW4gdXR0ZXJhbmNlIGRlc2NyaWJpbmcgY2hhbmdlcyBpZiBuZWNlc3NhcnkgYW5kIGNhbGxcclxuICAgICAqIG9wdGlvbmFsIFwiZW5kXCIgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX29uSW50ZXJhY3Rpb25FbmQoIGV2ZW50OiBTY2VuZXJ5RXZlbnQgKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYWxlcnRDb250ZXh0UmVzcG9uc2UoKTtcclxuICAgICAgdGhpcy52b2ljaW5nT25FbmRSZXNwb25zZSggdGhpcy5fdmFsdWVPblN0YXJ0ICk7XHJcbiAgICAgIHRoaXMuX2VuZElucHV0KCBldmVudCApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBkZWx0YSBmb3IgdGhlIHZhbHVlIFByb3BlcnR5IHdoZW4gdXNpbmcgYXJyb3cga2V5cyB0byBpbnRlcmFjdCB3aXRoIHRoZSBOb2RlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0S2V5Ym9hcmRTdGVwKCBrZXlib2FyZFN0ZXA6IG51bWJlciApOiB2b2lkIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCgga2V5Ym9hcmRTdGVwID49IDAsICdrZXlib2FyZCBzdGVwIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyApO1xyXG5cclxuICAgICAgdGhpcy5fa2V5Ym9hcmRTdGVwID0ga2V5Ym9hcmRTdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQga2V5Ym9hcmRTdGVwKCBrZXlib2FyZFN0ZXA6IG51bWJlciApIHsgdGhpcy5zZXRLZXlib2FyZFN0ZXAoIGtleWJvYXJkU3RlcCApOyB9XHJcblxyXG4gICAgcHVibGljIGdldCBrZXlib2FyZFN0ZXAoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZ2V0S2V5Ym9hcmRTdGVwKCk7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGVsdGEgZm9yIHZhbHVlIFByb3BlcnR5IHdoZW4gdXNpbmcgYXJyb3cga2V5cy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEtleWJvYXJkU3RlcCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5fa2V5Ym9hcmRTdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBkZWx0YSBmb3IgdmFsdWUgUHJvcGVydHkgd2hlbiB1c2luZyBhcnJvdyBrZXlzIHdpdGggc2hpZnQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgTm9kZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNoaWZ0S2V5Ym9hcmRTdGVwKCBzaGlmdEtleWJvYXJkU3RlcDogbnVtYmVyICk6IHZvaWQge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBzaGlmdEtleWJvYXJkU3RlcCA+PSAwLCAnc2hpZnQga2V5Ym9hcmQgc3RlcCBtdXN0IGJlIG5vbi1uZWdhdGl2ZScgKTtcclxuXHJcbiAgICAgIHRoaXMuX3NoaWZ0S2V5Ym9hcmRTdGVwID0gc2hpZnRLZXlib2FyZFN0ZXA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBzaGlmdEtleWJvYXJkU3RlcCggc2hpZnRLZXlib2FyZFN0ZXA6IG51bWJlciApIHsgdGhpcy5zZXRTaGlmdEtleWJvYXJkU3RlcCggc2hpZnRLZXlib2FyZFN0ZXAgKTsgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgc2hpZnRLZXlib2FyZFN0ZXAoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZ2V0U2hpZnRLZXlib2FyZFN0ZXAoKTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkZWx0YSBmb3IgdmFsdWUgUHJvcGVydHkgd2hlbiB1c2luZyBhcnJvdyBrZXlzIHdpdGggc2hpZnQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgTm9kZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNoaWZ0S2V5Ym9hcmRTdGVwKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zaGlmdEtleWJvYXJkU3RlcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgc2hpZnQga2V5IGlzIGN1cnJlbnRseSBoZWxkIGRvd24gb24gdGhpcyBzbGlkZXIsIGNoYW5naW5nIHRoZSBzaXplIG9mIHN0ZXAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTaGlmdEtleURvd24oKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zaGlmdEtleTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHNoaWZ0S2V5RG93bigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuZ2V0U2hpZnRLZXlEb3duKCk7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZGVsdGEgZm9yIHZhbHVlIFByb3BlcnR5IHdoZW4gdXNpbmcgcGFnZSB1cC9wYWdlIGRvd24gdG8gaW50ZXJhY3Qgd2l0aCB0aGUgTm9kZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFBhZ2VLZXlib2FyZFN0ZXAoIHBhZ2VLZXlib2FyZFN0ZXA6IG51bWJlciApOiB2b2lkIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggcGFnZUtleWJvYXJkU3RlcCA+PSAwLCAncGFnZSBrZXlib2FyZCBzdGVwIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyApO1xyXG5cclxuICAgICAgdGhpcy5fcGFnZUtleWJvYXJkU3RlcCA9IHBhZ2VLZXlib2FyZFN0ZXA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBwYWdlS2V5Ym9hcmRTdGVwKCBwYWdlS2V5Ym9hcmRTdGVwOiBudW1iZXIgKSB7IHRoaXMuc2V0UGFnZUtleWJvYXJkU3RlcCggcGFnZUtleWJvYXJkU3RlcCApOyB9XHJcblxyXG4gICAgcHVibGljIGdldCBwYWdlS2V5Ym9hcmRTdGVwKCk6IG51bWJlciB7IHJldHVybiB0aGlzLmdldFBhZ2VLZXlib2FyZFN0ZXAoKTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkZWx0YSBmb3IgdmFsdWUgUHJvcGVydHkgd2hlbiB1c2luZyBwYWdlIHVwL3BhZ2UgZG93biB0byBpbnRlcmFjdCB3aXRoIHRoZSBOb2RlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UGFnZUtleWJvYXJkU3RlcCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5fcGFnZUtleWJvYXJkU3RlcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgb3JpZW50YXRpb24gZm9yIHRoZSBzbGlkZXIgYXMgc3BlY2lmaWVkIGJ5IGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS0xLjEvI2FyaWEtb3JpZW50YXRpb24uXHJcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIHRoaXMgYXR0cmlidXRlLCBhIHNjcmVlbiByZWFkZXIgd2lsbCBnaXZlIGRpZmZlcmVudCBpbmRpY2F0aW9ucyBhYm91dCB3aGljaFxyXG4gICAgICogYXJyb3cga2V5cyBzaG91bGQgYmUgdXNlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0QXJpYU9yaWVudGF0aW9uKCBvcmllbnRhdGlvbjogT3JpZW50YXRpb24gKTogdm9pZCB7XHJcblxyXG4gICAgICB0aGlzLl9hcmlhT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcclxuICAgICAgdGhpcy5zZXRQRE9NQXR0cmlidXRlKCAnYXJpYS1vcmllbnRhdGlvbicsIG9yaWVudGF0aW9uLmFyaWFPcmllbnRhdGlvbiApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgYXJpYU9yaWVudGF0aW9uKCBvcmllbnRhdGlvbjogT3JpZW50YXRpb24gKSB7IHRoaXMuc2V0QXJpYU9yaWVudGF0aW9uKCBvcmllbnRhdGlvbiApOyB9XHJcblxyXG4gICAgcHVibGljIGdldCBhcmlhT3JpZW50YXRpb24oKTogT3JpZW50YXRpb24geyByZXR1cm4gdGhpcy5fYXJpYU9yaWVudGF0aW9uOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBhY2Nlc3NpYmxlIHNsaWRlciwgc2VlIHNldEFyaWFPcmllbnRhdGlvbiBmb3IgaW5mb3JtYXRpb24gb24gdGhlIGJlaGF2aW9yIG9mIHRoaXNcclxuICAgICAqIGF0dHJpYnV0ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEFyaWFPcmllbnRhdGlvbigpOiBPcmllbnRhdGlvbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9hcmlhT3JpZW50YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIHJhbmdlIGtleXMgYXJlIGN1cnJlbnRseSB1cCAobm90IGhlbGQgZG93bikuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2FsbEtleXNVcCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIF8uZXZlcnkoIHRoaXMuX3JhbmdlS2V5c0Rvd24sIGVudHJ5ID0+ICFlbnRyeSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFueSByYW5nZSBrZXlzIGFyZSBjdXJyZW50bHkgZG93biBvbiB0aGlzIHNsaWRlci4gVXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGVuIHRvIGNhbGxcclxuICAgICAqIHN0YXJ0RHJhZyBvciBlbmREcmFnIGJhc2VkIG9uIGludGVyYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9hbnlLZXlzRG93bigpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuICEhXy5maW5kKCB0aGlzLl9yYW5nZUtleXNEb3duLCBlbnRyeSA9PiBlbnRyeSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBgc3RlcGAgYXR0cmlidXRlIG9uIGFjY2Vzc2libGUgc2libGluZ3MgZm9yIHRoaXMgTm9kZS4gVGhlIHN0ZXAgYXR0cmlidXRlIG11c3QgYmUgbm9uIHplcm9cclxuICAgICAqIGZvciB0aGUgYWNjZXNzaWJsZSBpbnB1dCB0byByZWNlaXZlIGFjY2Vzc2liaWxpdHkgZXZlbnRzIGFuZCBvbmx5IGNlcnRhaW4gc2xpZGVyIGlucHV0IHZhbHVlcyBhcmVcclxuICAgICAqIGFsbG93ZWQgZGVwZW5kaW5nIG9uIGBzdGVwYCwgYG1pbmAsIGFuZCBgbWF4YCBhdHRyaWJ1dGVzLiBPbmx5IHZhbHVlcyB3aGljaCBhcmUgZXF1YWwgdG8gbWluIHZhbHVlIHBsdXNcclxuICAgICAqIHRoZSBiYXNpcyBvZiBzdGVwIGFyZSBhbGxvd2VkLiBJbiBvdGhlciB3b3JkcywgdGhlIGZvbGxvd2luZyBtdXN0IGFsd2F5cyBiZSB0cnVlOlxyXG4gICAgICogdmFsdWUgPSBtaW4gKyBuICogc3RlcCB3aGVyZSB2YWx1ZSA8PSBtYXggYW5kIG4gaXMgYW4gaW50ZWdlci5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgc2V0IHRvIGFueXRoaW5nIGVsc2UsIHRoZSByZXN1bHQgaXMgY29uZnVzaW5nXHJcbiAgICAgKiBrZXlib2FyZCBiZWhhdmlvciBhbmQgdGhlIHNjcmVlbiByZWFkZXIgd2lsbCBzYXkgXCJJbnZhbGlkXCIgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy5cclxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQvbnVtYmVyI3N0ZXBcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGxpbWl0YXRpb24gaXMgdG9vIHJlc3RyaWN0aXZlIGZvciBQaEVUIGFzIG1hbnkgc2xpZGVycyBzcGFuIHBoeXNpY2FsIHJhbmdlcyB3aXRoIGtleWJvYXJkIHN0ZXBzIHRoYXRcclxuICAgICAqIGFyZSBkZXNpZ24gdG8gYmUgY29udmVuaWVudCBvciBwZWRhZ29naWNhbGx5IHVzZWZ1bC4gRm9yIGV4YW1wbGUsIGEgc2xpZGVyIHRoYXQgc3BhbnMgMC4wMSB0byAxNSByZXF1aXJlc1xyXG4gICAgICogYSBzdGVwIG9mIDEsIGJ1dCBET00gc3BlY2lmaWNhdGlvbiB3b3VsZCBvbmx5IGFsbG93IHZhbHVlcyAwLjAxLCAxLjAxLCAyLjAxLCAuLi5cclxuICAgICAqIFRoaXMgcmVzdHJpY3Rpb24gaXMgd2h5IGBzdGVwYCBhdHRyaWJ1dGUgY2Fubm90IGVxdWFsIGtleWJvYXJkU3RlcCBvZiB0aGlzIHRyYWl0LlxyXG4gICAgICpcclxuICAgICAqIFdlIHRyaWVkIHRvIHVzZSB0aGUgYGFueWAgYXR0cmlidXRlIHdoaWNoIGlzIHZhbGlkIGFjY29yZGluZyB0byBET00gc3BlY2lmaWNhdGlvbiBidXQgc2NyZWVuIHJlYWRlcnNcclxuICAgICAqIGdlbmVyYWxseSBkb24ndCBzdXBwb3J0IGl0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3N1bi9pc3N1ZXMvNDEzLlxyXG4gICAgICpcclxuICAgICAqIEFsc28sIGlmIHRoZSBzdGVwIGF0dHJpYnV0ZSBpcyB0b28gc21hbGwgcmVsYXRpdmUgdG8gdGhlIGVudGlyZSByYW5nZSBvZiB0aGUgc2xpZGVyIFZvaWNlT3ZlciBkb2Vzbid0IGFsbG93XHJcbiAgICAgKiBhbnkgaW5wdXQgZXZlbnRzIGJlY2F1c2UuLi5Wb2ljZU92ZXIgaXMganVzdCBpbnRlcmVzdGluZyBsaWtlIHRoYXQuXHJcbiAgICAgKlxyXG4gICAgICogQ3VycmVudCB3b3JrYXJvdW5kIGZvciBhbGwgb2YgdGhpcyBpcyB0byBzZXQgdGhlIHN0ZXAgc2l6ZSB0byBzdXBwb3J0IHRoZSBwcmVjaXNpb24gb2YgdGhlIHZhbHVlIHJlcXVpcmVkXHJcbiAgICAgKiBieSB0aGUgY2xpZW50IHNvIHRoYXQgYWxsIHZhbHVlcyBhcmUgYWxsb3dlZC4gSWYgd2UgZW5jb3VudGVyIHRoZSBWb2ljZU92ZXIgY2FzZSBkZXNjcmliZWQgYWJvdmUgd2UgZmFsbFxyXG4gICAgICogYmFjayB0byBzZXR0aW5nIHRoZSBzdGVwIHNpemUgYXQgMS8xMDB0aCBvZiB0aGUgbWF4IHZhbHVlIHNpbmNlIHRoZSBrZXlib2FyZCBzdGVwIGdlbmVyYWxseSBldmVubHkgZGl2aWRlc1xyXG4gICAgICogdGhlIG1heCB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZnVsbCByYW5nZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfdXBkYXRlU2libGluZ1N0ZXBBdHRyaWJ1dGUoKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IHNtYWxsZXN0U3RlcCA9IE1hdGgubWluKCB0aGlzLmtleWJvYXJkU3RlcCwgdGhpcy5zaGlmdEtleWJvYXJkU3RlcCwgdGhpcy5wYWdlS2V5Ym9hcmRTdGVwICk7XHJcbiAgICAgIGxldCBzdGVwVmFsdWUgPSBNYXRoLnBvdyggMTAsIC1VdGlscy5udW1iZXJPZkRlY2ltYWxQbGFjZXMoIHNtYWxsZXN0U3RlcCApICk7XHJcblxyXG4gICAgICBjb25zdCBtYXBwZWRNaW4gPSB0aGlzLl9nZXRNYXBwZWRWYWx1ZSggdGhpcy5fZW5hYmxlZFJhbmdlUHJvcGVydHkuZ2V0KCkubWluICk7XHJcbiAgICAgIGNvbnN0IG1hcHBlZE1heCA9IHRoaXMuX2dldE1hcHBlZFZhbHVlKCB0aGlzLl9lbmFibGVkUmFuZ2VQcm9wZXJ0eS5nZXQoKS5tYXggKTtcclxuICAgICAgY29uc3QgbWFwcGVkTGVuZ3RoID0gbWFwcGVkTWF4IC0gbWFwcGVkTWluO1xyXG5cclxuICAgICAgLy8gc3RlcCBpcyB0b28gc21hbGwgcmVsYXRpdmUgdG8gZnVsbCByYW5nZSBmb3IgVm9pY2VPdmVyIHRvIHJlY2VpdmUgaW5wdXQsIGZhbGwgYmFjayB0byBwb3J0aW9uIG9mXHJcbiAgICAgIC8vIHRoZSBtYXggdmFsdWUgYXMgYSB3b3JrYXJvdW5kXHJcbiAgICAgIGlmICggc3RlcFZhbHVlIC8gbWFwcGVkTGVuZ3RoIDwgMWUtNSApIHtcclxuICAgICAgICBzdGVwVmFsdWUgPSBtYXBwZWRNYXggLyAxMDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuc2V0UERPTUF0dHJpYnV0ZSggJ3N0ZXAnLCBzdGVwVmFsdWUgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGwgdGhpcyB0byB0cmlnZ2VyIHRoZSB2b2ljaW5nIHJlc3BvbnNlIHNwb2tlbiB3aGVuIGFuIGludGVyYWN0aW9uIGVuZHMuIFdpbGwgc3BlYWsgdGhlIGN1cnJlbnRcclxuICAgICAqIG5hbWUgYW5kIG9iamVjdCByZXNwb25zZXMgKGFjY29yZGluZyB0byBvcHRpb25zKS4gU2V0IHRob3NlIHJlc3BvbnNlcyBvZiBWb2ljaW5nLnRzIHRvIGhlYXIgdXAtdG8tZGF0ZVxyXG4gICAgICogVm9pY2luZyByZXNwb25zZXMgYXQgdGhlIGVuZCBvZiBhbiBpbnRlcmFjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVPblN0YXJ0IC0gUHJvcGVydHkgdmFsdWUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnRlcmFjdGlvbi5cclxuICAgICAqIEBwYXJhbSBwcm92aWRlZE9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHZvaWNpbmdPbkVuZFJlc3BvbnNlKCB2YWx1ZU9uU3RhcnQ6IG51bWJlciwgcHJvdmlkZWRPcHRpb25zPzogVm9pY2luZ09uRW5kUmVzcG9uc2VPcHRpb25zICk6IHZvaWQge1xyXG4gICAgICBjb25zdCBvcHRpb25zID0gY29tYmluZU9wdGlvbnM8Vm9pY2luZ09uRW5kUmVzcG9uc2VPcHRpb25zPigge30sIHRoaXMuX3ZvaWNpbmdPbkVuZFJlc3BvbnNlT3B0aW9ucywgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgICBjb25zdCB2YWx1ZUNoYW5nZWQgPSB2YWx1ZU9uU3RhcnQgIT09IHRoaXMuX3ZhbHVlUHJvcGVydHkudmFsdWU7XHJcbiAgICAgIGNvbnN0IHZhbHVlQXRNaW5NYXggPSB0aGlzLl92YWx1ZVByb3BlcnR5LnZhbHVlID09PSB0aGlzLl9lbmFibGVkUmFuZ2VQcm9wZXJ0eS52YWx1ZS5taW4gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlUHJvcGVydHkudmFsdWUgPT09IHRoaXMuX2VuYWJsZWRSYW5nZVByb3BlcnR5LnZhbHVlLm1heDtcclxuXHJcbiAgICAgIC8vIGNvbnRlbnQgcmVxdWlyZWQgdG8gc3BlYWsgYSByZXNwb25zZSBhbmQgYWRkIHRvIGJhY2sgb2YgVXR0ZXJhbmNlUXVldWUuXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudEV4aXN0cyA9ICEhKCBvcHRpb25zLndpdGhOYW1lUmVzcG9uc2UgJiYgdGhpcy52b2ljaW5nTmFtZVJlc3BvbnNlICkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgISEoIG9wdGlvbnMud2l0aE9iamVjdFJlc3BvbnNlICYmIHRoaXMudm9pY2luZ09iamVjdFJlc3BvbnNlICk7XHJcbiAgICAgIGNvbnN0IHNob3VsZFNwZWFrID0gKCAhb3B0aW9ucy5vbmx5T25WYWx1ZUNoYW5nZSB8fCAvLyBzcGVhayBlYWNoIHRpbWUgaWYgb25seU9uVmFsdWVDaGFuZ2UgaXMgZmFsc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUF0TWluTWF4IHx8IC8vIGFsd2F5cyBzcGVhayBhdCBlZGdlcywgZm9yIFwiZ28gYmV5b25kXCIgcmVzcG9uc2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUNoYW5nZWQgKSAmJiAvLyBJZiB0aGUgdmFsdWUgY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29udGVudEV4aXN0cztcclxuXHJcbiAgICAgIHNob3VsZFNwZWFrICYmIHRoaXMudm9pY2luZ1NwZWFrRnVsbFJlc3BvbnNlKCB7XHJcbiAgICAgICAgbmFtZVJlc3BvbnNlOiBvcHRpb25zLndpdGhOYW1lUmVzcG9uc2UgPyB0aGlzLnZvaWNpbmdOYW1lUmVzcG9uc2UgOiBudWxsLFxyXG4gICAgICAgIG9iamVjdFJlc3BvbnNlOiBvcHRpb25zLndpdGhPYmplY3RSZXNwb25zZSA/IHRoaXMudm9pY2luZ09iamVjdFJlc3BvbnNlIDogbnVsbCxcclxuICAgICAgICBoaW50UmVzcG9uc2U6IG51bGwgLy8gbm8gaGludCwgdGhlcmUgd2FzIGp1c3QgYSBzdWNjZXNzZnVsIGludGVyYWN0aW9uXHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5fZGlzcG9zZUFjY2Vzc2libGVWYWx1ZUhhbmRsZXIoKTtcclxuXHJcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxuc3VuLnJlZ2lzdGVyKCAnQWNjZXNzaWJsZVZhbHVlSGFuZGxlcicsIEFjY2Vzc2libGVWYWx1ZUhhbmRsZXIgKTtcclxuXHJcbi8qKlxyXG4gKiBSb3VuZCB0aGUgdmFsdWUgdG8gdGhlIG5lYXJlc3Qgc3RlcCBzaXplLlxyXG4gKlxyXG4gKiBAcGFyYW0gbmV3VmFsdWUgLSB2YWx1ZSB0byBiZSByb3VuZGVkXHJcbiAqIEBwYXJhbSBjdXJyZW50VmFsdWUgLSBjdXJyZW50IHZhbHVlIG9mIHRoZSBQcm9wZXJ0eSBhc3NvY2lhdGVkIHdpdGggdGhpcyBzbGlkZXJcclxuICogQHBhcmFtIHN0ZXBTaXplIC0gdGhlIGRlbHRhIGZvciB0aGlzIG1hbmlwdWxhdGlvblxyXG4gKi9cclxuY29uc3Qgcm91bmRWYWx1ZSA9IGZ1bmN0aW9uKCBuZXdWYWx1ZTogbnVtYmVyLCBjdXJyZW50VmFsdWU6IG51bWJlciwgc3RlcFNpemU6IG51bWJlciApOiBudW1iZXIge1xyXG4gIGxldCByb3VuZFZhbHVlID0gbmV3VmFsdWU7XHJcbiAgaWYgKCBzdGVwU2l6ZSAhPT0gMCApIHtcclxuXHJcbiAgICAvLyByb3VuZCB0aGUgdmFsdWUgdG8gdGhlIG5lYXJlc3Qga2V5Ym9hcmQgc3RlcFxyXG4gICAgcm91bmRWYWx1ZSA9IFV0aWxzLnJvdW5kU3ltbWV0cmljKCByb3VuZFZhbHVlIC8gc3RlcFNpemUgKSAqIHN0ZXBTaXplO1xyXG5cclxuICAgIC8vIGdvIGJhY2sgYSBzdGVwIGlmIHdlIHdlbnQgdG9vIGZhciBkdWUgdG8gcm91bmRpbmdcclxuICAgIHJvdW5kVmFsdWUgPSBjb3JyZWN0Um91bmRpbmcoIHJvdW5kVmFsdWUsIGN1cnJlbnRWYWx1ZSwgc3RlcFNpemUgKTtcclxuICB9XHJcbiAgcmV0dXJuIHJvdW5kVmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uLCBpdCBpcyBwb3NzaWJsZSBkdWUgdG8gcm91bmRpbmcgdG8gZ28gdXAgb3IgZG93biBhIHN0ZXAgaWYgd2UgaGF2ZSBwYXNzZWQgdGhlIG5lYXJlc3Qgc3RlcCBkdXJpbmdcclxuICoga2V5Ym9hcmQgaW50ZXJhY3Rpb24uIFRoaXMgZnVuY3Rpb24gY29ycmVjdHMgdGhhdC5cclxuICpcclxuICovXHJcbmNvbnN0IGNvcnJlY3RSb3VuZGluZyA9IGZ1bmN0aW9uKCBuZXdWYWx1ZTogbnVtYmVyLCBjdXJyZW50VmFsdWU6IG51bWJlciwgc3RlcFNpemU6IG51bWJlciApOiBudW1iZXIge1xyXG4gIGxldCBjb3JyZWN0ZWRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG5cclxuICBjb25zdCBwcm9wb3NlZFN0ZXAgPSBNYXRoLmFicyggbmV3VmFsdWUgLSBjdXJyZW50VmFsdWUgKTtcclxuICBjb25zdCBzdGVwVG9GYXIgPSBwcm9wb3NlZFN0ZXAgPiBzdGVwU2l6ZTtcclxuXHJcbiAgLy8gaXQgaXMgcG9zc2libGUgdGhhdCBwcm9wb3NlZFN0ZXAgd2lsbCBiZSBsYXJnZXIgdGhhbiB0aGUgc3RlcFNpemUgYnV0IG9ubHkgYmVjYXVzZSBvZiBwcmVjaXNpb25cclxuICAvLyBjb25zdHJhaW50cyB3aXRoIGZsb2F0aW5nIHBvaW50IHZhbHVlcywgZG9uJ3QgY29ycmVjdCBpZiB0aGF0IGlzIHRoZSBjYXNlc1xyXG4gIGNvbnN0IHN0ZXBzQWJvdXRFcXVhbCA9IFV0aWxzLmVxdWFsc0Vwc2lsb24oIHByb3Bvc2VkU3RlcCwgc3RlcFNpemUsIDFlLTE0ICk7XHJcbiAgaWYgKCBzdGVwVG9GYXIgJiYgIXN0ZXBzQWJvdXRFcXVhbCApIHtcclxuICAgIGNvcnJlY3RlZFZhbHVlICs9ICggbmV3VmFsdWUgPiBjdXJyZW50VmFsdWUgKSA/ICggLXN0ZXBTaXplICkgOiBzdGVwU2l6ZTtcclxuICB9XHJcbiAgcmV0dXJuIGNvcnJlY3RlZFZhbHVlO1xyXG59O1xyXG5cclxuQWNjZXNzaWJsZVZhbHVlSGFuZGxlci5ERUZBVUxUX1RBR19OQU1FID0gREVGQVVMVF9UQUdfTkFNRTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFjY2Vzc2libGVWYWx1ZUhhbmRsZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsS0FBSyxNQUFNLDBCQUEwQjtBQUU1QyxPQUFPQyxtQkFBbUIsTUFBTSw4Q0FBOEM7QUFDOUUsT0FBT0MsV0FBVyxNQUFNLHNDQUFzQztBQUM5RCxTQUFTQyxhQUFhLEVBQXFCQyxTQUFTLEVBQXdFQyxPQUFPLFFBQXdCLGdDQUFnQztBQUMzTCxPQUFPQyxTQUFTLE1BQU0sMENBQTBDO0FBQ2hFLE9BQU9DLEdBQUcsTUFBTSxXQUFXO0FBQzNCLE9BQU9DLFNBQVMsSUFBSUMs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