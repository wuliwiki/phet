// Copyright 2020-2023, University of Colorado Boulder

/**
 * ChartTransform defines the chart dimensions in model and view coordinate frames, and provides transform methods
 * for moving between those coordinate frames.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import Emitter from '../../axon/js/Emitter.js';
import Range from '../../dot/js/Range.js';
import Transform1 from '../../dot/js/Transform1.js';
import Utils from '../../dot/js/Utils.js';
import Vector2 from '../../dot/js/Vector2.js';
import optionize from '../../phet-core/js/optionize.js';
import Orientation from '../../phet-core/js/Orientation.js';
import bamboo from './bamboo.js';
class ChartTransform {
  // fires when some aspects of this transform changes

  constructor(providedOptions) {
    const options = optionize()({
      // SelfOptions
      viewWidth: 100,
      modelXRange: new Range(-1, 1),
      modelXRangeInverted: false,
      xTransform: new Transform1(x => x, x => x),
      viewHeight: 100,
      modelYRange: new Range(-1, 1),
      modelYRangeInverted: false,
      yTransform: new Transform1(x => x, x => x)
    }, providedOptions);
    assert && assert(options.xTransform instanceof Transform1, 'xTransform must be of type Transform');
    assert && assert(options.yTransform instanceof Transform1, 'yTransform must be of type Transform');
    this.changedEmitter = new Emitter();
    this.viewWidth = options.viewWidth;
    this.viewHeight = options.viewHeight;
    this.modelXRange = options.modelXRange;
    this.modelXRangeInverted = options.modelXRangeInverted;
    this.modelYRange = options.modelYRange;
    this.modelYRangeInverted = options.modelYRangeInverted;
    this.xTransform = options.xTransform;
    this.yTransform = options.yTransform;
  }
  dispose() {
    this.changedEmitter.dispose();
  }

  /**
   * For the axis that corresponds to Orientation, iterates over the range and performs an operation (specified by
   * callback) at regular intervals (specified by spacing).
   * @param axisOrientation
   * @param spacing - the spacing (delta) between operations, in model coordinates
   * @param origin - the origin for the operation, in model coordinates. The operation is guaranteed to occur at this position.
   * @param clippingType - if something is clipped elsewhere, we allow slack so it doesn't disappear from view like a flicker
   * @param callback
   */
  forEachSpacing(axisOrientation, spacing, origin, clippingType, callback) {
    const [nMin, nMax] = this.getSpacingBorders(axisOrientation, spacing, origin, clippingType);
    for (let n = nMin; n <= nMax + 1E-6; n++) {
      const modelPosition = n * spacing + origin;
      const viewPosition = this.modelToView(axisOrientation, modelPosition);
      callback(modelPosition, viewPosition);
    }
  }

  // Transforms a model coordinate {number} to a view coordinate {number} for the axis that corresponds to Orientation.
  modelToView(axisOrientation, value) {
    const modelRange = axisOrientation === Orientation.HORIZONTAL ? this.modelXRange : this.modelYRange;
    const viewDimension = axisOrientation === Orientation.HORIZONTAL ? this.viewWidth : this.viewHeight;
    const transform = axisOrientation === Orientation.HORIZONTAL ? this.xTransform : this.yTransform;
    const inverted = axisOrientation === Orientation.HORIZONTAL ? this.modelXRangeInverted : this.modelYRangeInverted;
    const transformedValue = transform.evaluate(value);
    assert && assert(!isNaN(transformedValue), 'transformed value was NaN');
    assert && assert(Number.isFinite(transformedValue), 'transformed value was not finite');
    const lowSide = inverted ? viewDimension : 0;
    const highSide = inverted ? 0 : viewDimension;

    // For vertical, +y is usually up
    const viewValue = axisOrientation === Orientation.HORIZONTAL ? Utils.linear(transform.evaluate(modelRange.min), transform.evaluate(modelRange.max), lowSide, highSide, transformedValue) : Utils.linear(transform.evaluate(modelRange.max), transform.evaluate(modelRange.min), lowSide, highSide, transformedValue);
    assert && assert(Number.isFinite(viewValue), 'viewValue should be finite');
    assert && assert(!isNaN(viewValue), 'viewValue should be a number');
    return viewValue;
  }

  // Transforms a model coordinate {number} to a view coordinate {number} for the x axis.
  modelToViewX(x) {
    return this.modelToView(Orientation.HORIZONTAL, x);
  }

  // Transforms a model coordinate {number} to a view coordinate {number} for the y axis.
  modelToViewY(y) {
    return this.modelToView(Orientation.VERTICAL, y);
  }

  // Transforms model x,y coordinates to a view position.
  modelToViewXY(x, y) {
    return new Vector2(this.modelToViewX(x), this.modelToViewY(y));
  }

  // Transforms a model position to a view position.
  modelToViewPosition(position) {
    return this.modelToViewXY(position.x, position.y);
  }

  // Transforms a model delta {number} to a view delta {number} for the axis that corresponds to Orientation.
  modelToViewDelta(axisOrientation, modelDelta) {
    return this.modelToView(axisOrientation, modelDelta) - this.modelToView(axisOrientation, 0);
  }

  // Transforms a model delta {number} to a view delta {number} for the x axis.
  modelToViewDeltaX(dx) {
    return this.modelToViewDelta(Orientation.HORIZONTAL, dx);
  }

  // Transforms a model delta {number} to a view delta {number} for the y axis.
  modelToViewDeltaY(dy) {
    return this.modelToViewDelta(Orientation.VERTICAL, dy);
  }

  // Transforms a model delta pair of numbers to view Vector2
  modelToViewDeltaXY(dx, dy) {
    return new Vector2(this.modelToViewDeltaX(dx), this.modelToViewDeltaY(dy));
  }

  // Converts a scalar value from view coordinates to model coordinates, along the specified axis.  The inverse of modelToView.
  viewToModel(axisOrientation, value) {
    const modelRange = axisOrientation === Orientation.HORIZONTAL ? this.modelXRange : this.modelYRange;
    const viewDimension = axisOrientation === Orientation.HORIZONTAL ? this.viewWidth : this.viewHeight;
    const transform = axisOrientation === Orientation.HORIZONTAL ? this.xTransform : this.yTransform;
    const inverted = axisOrientation === Orientation.HORIZONTAL ? this.modelXRangeInverted : this.modelYRangeInverted;
    const lowSide = inverted ? viewDimension : 0;
    const highSide = inverted ? 0 : viewDimension;

    // For vertical, +y is usually up
    const out = axisOrientation === Orientation.HORIZONTAL ? Utils.linear(lowSide, highSide, transform.evaluate(modelRange.min), transform.evaluate(modelRange.max), value) : Utils.linear(lowSide, highSide, transform.evaluate(modelRange.max), transform.evaluate(modelRange.min), value);
    assert && assert(Number.isFinite(out), 'out value should be finite');
    assert && assert(!isNaN(out), 'out value should be a number');
    const modelValue = transform.inverse(out);
    assert && assert(Number.isFinite(modelValue), 'modelValue should be finite');
    assert && assert(!isNaN(modelValue), 'modelValue should be a number');
    return modelValue;
  }

  // Convert a view position to a model position, in the horizontal direction.
  viewToModelX(x) {
    return this.viewToModel(Orientation.HORIZONTAL, x);
  }

  // Convert a view position to a model position, in the vertical direction.
  viewToModelY(y) {
    return this.viewToModel(Orientation.VERTICAL, y);
  }

  // Convert a view position to a model position, for a coordinate specified as x,y.
  viewToModelXY(x, y) {
    return new Vector2(this.viewToModelX(x), this.viewToModelY(y));
  }

  // Convert a view position to a model position.
  viewToModelPosition(position) {
    return this.viewToModelXY(position.x, position.y);
  }

  // Convert a delta in the view to a delta in the model, in the horizontal direction.
  viewToModelDeltaX(dx) {
    return this.viewToModelX(dx) - this.viewToModelX(0);
  }

  // Convert a delta in the view to a delta in the model, in the vertical direction.
  viewToModelDeltaY(dy) {
    return this.viewToModelY(dy) - this.viewToModelY(0);
  }

  // Convert a delta in the view to a delta in the model, for a Vector2
  viewToModelDelta(deltaVector) {
    return this.viewToModelPosition(deltaVector).minus(this.viewToModelPosition(Vector2.ZERO));
  }

  // Sets the view width.
  setViewWidth(viewWidth) {
    if (viewWidth !== this.viewWidth) {
      this.viewWidth = viewWidth;
      this.changedEmitter.emit();
    }
  }

  // Sets the view height.
  setViewHeight(viewHeight) {
    if (viewHeight !== this.viewHeight) {
      this.viewHeight = viewHeight;
      this.changedEmitter.emit();
    }
  }

  // Sets the Range for the model's x dimension.
  setModelXRange(modelXRange) {
    if (!modelXRange.equals(this.modelXRange)) {
      this.modelXRange = modelXRange;
      this.changedEmitter.emit();
    }
  }

  // Sets the Range for the model's y dimension.
  setModelYRange(modelYRange) {
    if (!modelYRange.equals(this.modelYRange)) {
      this.modelYRange = modelYRange;
      this.changedEmitter.emit();
    }
  }

  // Gets the model range for the axis that corresponds to Orientation.
  getModelRange(axisOrientation) {
    return axisOrientation === Orientation.HORIZONTAL ? this.modelXRange : this.modelYRange;
  }

  // Sets the model-to-view scaling function for the x-axis.
  setXTransform(xTransform) {
    if (this.xTransform !== xTransform) {
      this.xTransform = xTransform;
      this.changedEmitter.emit();
    }
  }

  // Sets the model-to-view scaling function for the y-axis.
  setYTransform(yTransform) {
    if (this.yTransform !== yTransform) {
      this.yTransform = yTransform;
      this.changedEmitter.emit();
    }
  }
  getSpacingBorders(axisOrientation, spacing, origin, clippingType) {
    const modelRange = this.getModelRange(axisOrientation);
    const nMin = getValueForSpacing(modelRange.min, clippingType, origin, spacing, Math.ceil);
    const nMax = getValueForSpacing(modelRange.max, clippingType, origin, spacing, Math.floor);
    return [nMin, nMax];
  }
}

/**
 * Solve for spaced value.
 * n * spacing + origin = x
 * n = (x-origin)/spacing, where n is an integer
 */
function getValueForSpacing(value, clippingType, origin, spacing, round) {
  return clippingType === 'lenient' ? Utils.roundSymmetric((value - origin) / spacing) : round((value - origin) / spacing);
}
bamboo.register('ChartTransform', ChartTransform);
export default ChartTransform;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFbWl0dGVyIiwiUmFuZ2UiLCJUcmFuc2Zvcm0xIiwiVXRpbHMiLCJWZWN0b3IyIiwib3B0aW9uaXplIiwiT3JpZW50YXRpb24iLCJiYW1ib28iLCJDaGFydFRyYW5zZm9ybSIsImNvbnN0cnVjdG9yIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsInZpZXdXaWR0aCIsIm1vZGVsWFJhbmdlIiwibW9kZWxYUmFuZ2VJbnZlcnRlZCIsInhUcmFuc2Zvcm0iLCJ4Iiwidmlld0hlaWdodCIsIm1vZGVsWVJhbmdlIiwibW9kZWxZUmFuZ2VJbnZlcnRlZCIsInlUcmFuc2Zvcm0iLCJhc3NlcnQiLCJjaGFuZ2VkRW1pdHRlciIsImRpc3Bvc2UiLCJmb3JFYWNoU3BhY2luZyIsImF4aXNPcmllbnRhdGlvbiIsInNwYWNpbmciLCJvcmlnaW4iLCJjbGlwcGluZ1R5cGUiLCJjYWxsYmFjayIsIm5NaW4iLCJuTWF4IiwiZ2V0U3BhY2luZ0JvcmRlcnMiLCJuIiwibW9kZWxQb3NpdGlvbiIsInZpZXdQb3NpdGlvbiIsIm1vZGVsVG9WaWV3IiwidmFsdWUiLCJtb2RlbFJhbmdlIiwiSE9SSVpPTlRBTCIsInZpZXdEaW1lbnNpb24iLCJ0cmFuc2Zvcm0iLCJpbnZlcnRlZCIsInRyYW5zZm9ybWVkVmFsdWUiLCJldmFsdWF0ZSIsImlzTmFOIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJsb3dTaWRlIiwiaGlnaFNpZGUiLCJ2aWV3VmFsdWUiLCJsaW5lYXIiLCJtaW4iLCJtYXgiLCJtb2RlbFRvVmlld1giLCJtb2RlbFRvVmlld1kiLCJ5IiwiVkVSVElDQUwiLCJtb2RlbFRvVmlld1hZIiwibW9kZWxUb1ZpZXdQb3NpdGlvbiIsInBvc2l0aW9uIiwibW9kZWxUb1ZpZXdEZWx0YSIsIm1vZGVsRGVsdGEiLCJtb2RlbFRvVmlld0RlbHRhWCIsImR4IiwibW9kZWxUb1ZpZXdEZWx0YVkiLCJkeSIsIm1vZGVsVG9WaWV3RGVsdGFYWSIsInZpZXdUb01vZGVsIiwib3V0IiwibW9kZWxWYWx1ZSIsImludmVyc2UiLCJ2aWV3VG9Nb2RlbFgiLCJ2aWV3VG9Nb2RlbFkiLCJ2aWV3VG9Nb2RlbFhZIiwidmlld1RvTW9kZWxQb3NpdGlvbiIsInZpZXdUb01vZGVsRGVsdGFYIiwidmlld1RvTW9kZWxEZWx0YVkiLCJ2aWV3VG9Nb2RlbERlbHRhIiwiZGVsdGFWZWN0b3IiLCJtaW51cyIsIlpFUk8iLCJzZXRWaWV3V2lkdGgiLCJlbWl0Iiwic2V0Vmlld0hlaWdodCIsInNldE1vZGVsWFJhbmdlIiwiZXF1YWxzIiwic2V0TW9kZWxZUmFuZ2UiLCJnZXRNb2RlbFJhbmdlIiwic2V0WFRyYW5zZm9ybSIsInNldFlUcmFuc2Zvcm0iLCJnZXRWYWx1ZUZvclNwYWNpbmciLCJNYXRoIiwiY2VpbCIsImZsb29yIiwicm91bmQiLCJyb3VuZFN5bW1ldHJpYyIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQ2hhcnRUcmFuc2Zvcm0udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQ2hhcnRUcmFuc2Zvcm0gZGVmaW5lcyB0aGUgY2hhcnQgZGltZW5zaW9ucyBpbiBtb2RlbCBhbmQgdmlldyBjb29yZGluYXRlIGZyYW1lcywgYW5kIHByb3ZpZGVzIHRyYW5zZm9ybSBtZXRob2RzXHJcbiAqIGZvciBtb3ZpbmcgYmV0d2VlbiB0aG9zZSBjb29yZGluYXRlIGZyYW1lcy5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgRW1pdHRlciBmcm9tICcuLi8uLi9heG9uL2pzL0VtaXR0ZXIuanMnO1xyXG5pbXBvcnQgVEVtaXR0ZXIgZnJvbSAnLi4vLi4vYXhvbi9qcy9URW1pdHRlci5qcyc7XHJcbmltcG9ydCBSYW5nZSBmcm9tICcuLi8uLi9kb3QvanMvUmFuZ2UuanMnO1xyXG5pbXBvcnQgVHJhbnNmb3JtMSBmcm9tICcuLi8uLi9kb3QvanMvVHJhbnNmb3JtMS5qcyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi9kb3QvanMvVXRpbHMuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBPcmllbnRhdGlvbiBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvT3JpZW50YXRpb24uanMnO1xyXG5pbXBvcnQgYmFtYm9vIGZyb20gJy4vYmFtYm9vLmpzJztcclxuaW1wb3J0IENsaXBwaW5nVHlwZSBmcm9tICcuL0NsaXBwaW5nVHlwZS5qcyc7XHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0ge1xyXG5cclxuICAvLyBUaGUgaG9yaXpvbnRhbCBheGlzIGlzIHJlZmVycmVkIHRvIGFzIHRoZSBcInhcIiBheGlzLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWQgdG8gZGVwaWN0IGFub3RoZXIgZGltZW5zaW9uLCBzdWNoIGFzIFwidGltZVwiXHJcbiAgdmlld1dpZHRoPzogbnVtYmVyOyAvLyB3aWR0aCBpbiB2aWV3IGNvb3JkaW5hdGVzXHJcbiAgbW9kZWxYUmFuZ2U/OiBSYW5nZTsgLy8gcmFuZ2Ugb2YgdGhlIHggYXhpcywgaW4gbW9kZWwgY29vcmRpbmF0ZXNcclxuICBtb2RlbFhSYW5nZUludmVydGVkPzogYm9vbGVhbjtcclxuICB4VHJhbnNmb3JtPzogVHJhbnNmb3JtMTsgLy8gbW9kZWwtdG8tdmlldyBzY2FsaW5nIGZ1bmN0aW9uIGZvciB0aGUgeCBheGlzXHJcblxyXG4gIC8vIFRoZSB2ZXJ0aWNhbCBheGlzIGlzIHJlZmVycmVkIHRvIGFzIHRoZSBcInlcIiBheGlzLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWQgdG8gZGVwaWN0IGFub3RoZXIgZGltZW5zaW9uIHN1Y2ggYXMgXCJ3aWR0aFwiXHJcbiAgdmlld0hlaWdodD86IG51bWJlcjsgLy8gaGVpZ2h0IGluIHZpZXcgY29vcmRpbmF0ZXNcclxuICBtb2RlbFlSYW5nZT86IFJhbmdlOyAvLyByYW5nZSBvZiB0aGUgeSBheGlzLCBpbiBtb2RlbCBjb29yZGluYXRlc1xyXG4gIG1vZGVsWVJhbmdlSW52ZXJ0ZWQ/OiBib29sZWFuO1xyXG4gIHlUcmFuc2Zvcm0/OiBUcmFuc2Zvcm0xOyAvLyBtb2RlbC10by12aWV3IHNjYWxpbmcgZnVuY3Rpb24gZm9yIHRoZSB5IGF4aXNcclxufTtcclxuZXhwb3J0IHR5cGUgQ2hhcnRUcmFuc2Zvcm1PcHRpb25zID0gU2VsZk9wdGlvbnM7XHJcblxyXG5jbGFzcyBDaGFydFRyYW5zZm9ybSB7XHJcblxyXG4gIC8vIGZpcmVzIHdoZW4gc29tZSBhc3BlY3RzIG9mIHRoaXMgdHJhbnNmb3JtIGNoYW5nZXNcclxuICBwdWJsaWMgcmVhZG9ubHkgY2hhbmdlZEVtaXR0ZXI6IFRFbWl0dGVyO1xyXG5cclxuICBwdWJsaWMgdmlld1dpZHRoOiBudW1iZXI7XHJcbiAgcHVibGljIHZpZXdIZWlnaHQ6IG51bWJlcjtcclxuICBwdWJsaWMgbW9kZWxYUmFuZ2U6IFJhbmdlO1xyXG4gIHB1YmxpYyBtb2RlbFlSYW5nZTogUmFuZ2U7XHJcbiAgcHVibGljIHhUcmFuc2Zvcm06IFRyYW5zZm9ybTE7XHJcbiAgcHVibGljIHlUcmFuc2Zvcm06IFRyYW5zZm9ybTE7XHJcbiAgcHVibGljIG1vZGVsWFJhbmdlSW52ZXJ0ZWQ6IGJvb2xlYW47XHJcbiAgcHVibGljIG1vZGVsWVJhbmdlSW52ZXJ0ZWQ6IGJvb2xlYW47XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcHJvdmlkZWRPcHRpb25zPzogQ2hhcnRUcmFuc2Zvcm1PcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8Q2hhcnRUcmFuc2Zvcm1PcHRpb25zLCBTZWxmT3B0aW9ucz4oKSgge1xyXG5cclxuICAgICAgLy8gU2VsZk9wdGlvbnNcclxuICAgICAgdmlld1dpZHRoOiAxMDAsXHJcbiAgICAgIG1vZGVsWFJhbmdlOiBuZXcgUmFuZ2UoIC0xLCAxICksXHJcbiAgICAgIG1vZGVsWFJhbmdlSW52ZXJ0ZWQ6IGZhbHNlLFxyXG4gICAgICB4VHJhbnNmb3JtOiBuZXcgVHJhbnNmb3JtMSggeCA9PiB4LCB4ID0+IHggKSxcclxuXHJcbiAgICAgIHZpZXdIZWlnaHQ6IDEwMCxcclxuICAgICAgbW9kZWxZUmFuZ2U6IG5ldyBSYW5nZSggLTEsIDEgKSxcclxuICAgICAgbW9kZWxZUmFuZ2VJbnZlcnRlZDogZmFsc2UsXHJcbiAgICAgIHlUcmFuc2Zvcm06IG5ldyBUcmFuc2Zvcm0xKCB4ID0+IHgsIHggPT4geCApXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLnhUcmFuc2Zvcm0gaW5zdGFuY2VvZiBUcmFuc2Zvcm0xLCAneFRyYW5zZm9ybSBtdXN0IGJlIG9mIHR5cGUgVHJhbnNmb3JtJyApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggb3B0aW9ucy55VHJhbnNmb3JtIGluc3RhbmNlb2YgVHJhbnNmb3JtMSwgJ3lUcmFuc2Zvcm0gbXVzdCBiZSBvZiB0eXBlIFRyYW5zZm9ybScgKTtcclxuXHJcbiAgICB0aGlzLmNoYW5nZWRFbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuXHJcbiAgICB0aGlzLnZpZXdXaWR0aCA9IG9wdGlvbnMudmlld1dpZHRoO1xyXG4gICAgdGhpcy52aWV3SGVpZ2h0ID0gb3B0aW9ucy52aWV3SGVpZ2h0O1xyXG5cclxuICAgIHRoaXMubW9kZWxYUmFuZ2UgPSBvcHRpb25zLm1vZGVsWFJhbmdlO1xyXG4gICAgdGhpcy5tb2RlbFhSYW5nZUludmVydGVkID0gb3B0aW9ucy5tb2RlbFhSYW5nZUludmVydGVkO1xyXG5cclxuICAgIHRoaXMubW9kZWxZUmFuZ2UgPSBvcHRpb25zLm1vZGVsWVJhbmdlO1xyXG4gICAgdGhpcy5tb2RlbFlSYW5nZUludmVydGVkID0gb3B0aW9ucy5tb2RlbFlSYW5nZUludmVydGVkO1xyXG5cclxuICAgIHRoaXMueFRyYW5zZm9ybSA9IG9wdGlvbnMueFRyYW5zZm9ybTtcclxuICAgIHRoaXMueVRyYW5zZm9ybSA9IG9wdGlvbnMueVRyYW5zZm9ybTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5jaGFuZ2VkRW1pdHRlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGb3IgdGhlIGF4aXMgdGhhdCBjb3JyZXNwb25kcyB0byBPcmllbnRhdGlvbiwgaXRlcmF0ZXMgb3ZlciB0aGUgcmFuZ2UgYW5kIHBlcmZvcm1zIGFuIG9wZXJhdGlvbiAoc3BlY2lmaWVkIGJ5XHJcbiAgICogY2FsbGJhY2spIGF0IHJlZ3VsYXIgaW50ZXJ2YWxzIChzcGVjaWZpZWQgYnkgc3BhY2luZykuXHJcbiAgICogQHBhcmFtIGF4aXNPcmllbnRhdGlvblxyXG4gICAqIEBwYXJhbSBzcGFjaW5nIC0gdGhlIHNwYWNpbmcgKGRlbHRhKSBiZXR3ZWVuIG9wZXJhdGlvbnMsIGluIG1vZGVsIGNvb3JkaW5hdGVzXHJcbiAgICogQHBhcmFtIG9yaWdpbiAtIHRoZSBvcmlnaW4gZm9yIHRoZSBvcGVyYXRpb24sIGluIG1vZGVsIGNvb3JkaW5hdGVzLiBUaGUgb3BlcmF0aW9uIGlzIGd1YXJhbnRlZWQgdG8gb2NjdXIgYXQgdGhpcyBwb3NpdGlvbi5cclxuICAgKiBAcGFyYW0gY2xpcHBpbmdUeXBlIC0gaWYgc29tZXRoaW5nIGlzIGNsaXBwZWQgZWxzZXdoZXJlLCB3ZSBhbGxvdyBzbGFjayBzbyBpdCBkb2Vzbid0IGRpc2FwcGVhciBmcm9tIHZpZXcgbGlrZSBhIGZsaWNrZXJcclxuICAgKiBAcGFyYW0gY2FsbGJhY2tcclxuICAgKi9cclxuICBwdWJsaWMgZm9yRWFjaFNwYWNpbmcoIGF4aXNPcmllbnRhdGlvbjogT3JpZW50YXRpb24sIHNwYWNpbmc6IG51bWJlciwgb3JpZ2luOiBudW1iZXIsIGNsaXBwaW5nVHlwZTogQ2xpcHBpbmdUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6ICggbW9kZWxQb3NpdGlvbjogbnVtYmVyLCB2aWV3UG9zaXRpb246IG51bWJlciApID0+IHZvaWQgKTogdm9pZCB7XHJcbiAgICBjb25zdCBbIG5NaW4sIG5NYXggXSA9IHRoaXMuZ2V0U3BhY2luZ0JvcmRlcnMoIGF4aXNPcmllbnRhdGlvbiwgc3BhY2luZywgb3JpZ2luLCBjbGlwcGluZ1R5cGUgKTtcclxuXHJcbiAgICBmb3IgKCBsZXQgbiA9IG5NaW47IG4gPD0gbk1heCArIDFFLTY7IG4rKyApIHtcclxuICAgICAgY29uc3QgbW9kZWxQb3NpdGlvbiA9IG4gKiBzcGFjaW5nICsgb3JpZ2luO1xyXG4gICAgICBjb25zdCB2aWV3UG9zaXRpb24gPSB0aGlzLm1vZGVsVG9WaWV3KCBheGlzT3JpZW50YXRpb24sIG1vZGVsUG9zaXRpb24gKTtcclxuICAgICAgY2FsbGJhY2soIG1vZGVsUG9zaXRpb24sIHZpZXdQb3NpdGlvbiApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVHJhbnNmb3JtcyBhIG1vZGVsIGNvb3JkaW5hdGUge251bWJlcn0gdG8gYSB2aWV3IGNvb3JkaW5hdGUge251bWJlcn0gZm9yIHRoZSBheGlzIHRoYXQgY29ycmVzcG9uZHMgdG8gT3JpZW50YXRpb24uXHJcbiAgcHVibGljIG1vZGVsVG9WaWV3KCBheGlzT3JpZW50YXRpb246IE9yaWVudGF0aW9uLCB2YWx1ZTogbnVtYmVyICk6IG51bWJlciB7XHJcblxyXG4gICAgY29uc3QgbW9kZWxSYW5nZSA9IGF4aXNPcmllbnRhdGlvbiA9PT0gT3JpZW50YXRpb24uSE9SSVpPTlRBTCA/IHRoaXMubW9kZWxYUmFuZ2UgOiB0aGlzLm1vZGVsWVJhbmdlO1xyXG4gICAgY29uc3Qgdmlld0RpbWVuc2lvbiA9IGF4aXNPcmllbnRhdGlvbiA9PT0gT3JpZW50YXRpb24uSE9SSVpPTlRBTCA/IHRoaXMudmlld1dpZHRoIDogdGhpcy52aWV3SGVpZ2h0O1xyXG4gICAgY29uc3QgdHJhbnNmb3JtID0gYXhpc09yaWVudGF0aW9uID09PSBPcmllbnRhdGlvbi5IT1JJWk9OVEFMID8gdGhpcy54VHJhbnNmb3JtIDogdGhpcy55VHJhbnNmb3JtO1xyXG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBheGlzT3JpZW50YXRpb24gPT09IE9yaWVudGF0aW9uLkhPUklaT05UQUwgPyB0aGlzLm1vZGVsWFJhbmdlSW52ZXJ0ZWQgOiB0aGlzLm1vZGVsWVJhbmdlSW52ZXJ0ZWQ7XHJcblxyXG4gICAgY29uc3QgdHJhbnNmb3JtZWRWYWx1ZSA9IHRyYW5zZm9ybS5ldmFsdWF0ZSggdmFsdWUgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICFpc05hTiggdHJhbnNmb3JtZWRWYWx1ZSApLCAndHJhbnNmb3JtZWQgdmFsdWUgd2FzIE5hTicgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIE51bWJlci5pc0Zpbml0ZSggdHJhbnNmb3JtZWRWYWx1ZSApLCAndHJhbnNmb3JtZWQgdmFsdWUgd2FzIG5vdCBmaW5pdGUnICk7XHJcblxyXG4gICAgY29uc3QgbG93U2lkZSA9IGludmVydGVkID8gdmlld0RpbWVuc2lvbiA6IDA7XHJcbiAgICBjb25zdCBoaWdoU2lkZSA9IGludmVydGVkID8gMCA6IHZpZXdEaW1lbnNpb247XHJcblxyXG4gICAgLy8gRm9yIHZlcnRpY2FsLCAreSBpcyB1c3VhbGx5IHVwXHJcbiAgICBjb25zdCB2aWV3VmFsdWUgPSBheGlzT3JpZW50YXRpb24gPT09IE9yaWVudGF0aW9uLkhPUklaT05UQUwgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgVXRpbHMubGluZWFyKCB0cmFuc2Zvcm0uZXZhbHVhdGUoIG1vZGVsUmFuZ2UubWluICksIHRyYW5zZm9ybS5ldmFsdWF0ZSggbW9kZWxSYW5nZS5tYXggKSwgbG93U2lkZSwgaGlnaFNpZGUsIHRyYW5zZm9ybWVkVmFsdWUgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICBVdGlscy5saW5lYXIoIHRyYW5zZm9ybS5ldmFsdWF0ZSggbW9kZWxSYW5nZS5tYXggKSwgdHJhbnNmb3JtLmV2YWx1YXRlKCBtb2RlbFJhbmdlLm1pbiApLCBsb3dTaWRlLCBoaWdoU2lkZSwgdHJhbnNmb3JtZWRWYWx1ZSApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggTnVtYmVyLmlzRmluaXRlKCB2aWV3VmFsdWUgKSwgJ3ZpZXdWYWx1ZSBzaG91bGQgYmUgZmluaXRlJyApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIWlzTmFOKCB2aWV3VmFsdWUgKSwgJ3ZpZXdWYWx1ZSBzaG91bGQgYmUgYSBudW1iZXInICk7XHJcblxyXG4gICAgcmV0dXJuIHZpZXdWYWx1ZTtcclxuICB9XHJcblxyXG4gIC8vIFRyYW5zZm9ybXMgYSBtb2RlbCBjb29yZGluYXRlIHtudW1iZXJ9IHRvIGEgdmlldyBjb29yZGluYXRlIHtudW1iZXJ9IGZvciB0aGUgeCBheGlzLlxyXG4gIHB1YmxpYyBtb2RlbFRvVmlld1goIHg6IG51bWJlciApOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubW9kZWxUb1ZpZXcoIE9yaWVudGF0aW9uLkhPUklaT05UQUwsIHggKTtcclxuICB9XHJcblxyXG4gIC8vIFRyYW5zZm9ybXMgYSBtb2RlbCBjb29yZGluYXRlIHtudW1iZXJ9IHRvIGEgdmlldyBjb29yZGluYXRlIHtudW1iZXJ9IGZvciB0aGUgeSBheGlzLlxyXG4gIHB1YmxpYyBtb2RlbFRvVmlld1koIHk6IG51bWJlciApOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubW9kZWxUb1ZpZXcoIE9yaWVudGF0aW9uLlZFUlRJQ0FMLCB5ICk7XHJcbiAgfVxyXG5cclxuICAvLyBUcmFuc2Zvcm1zIG1vZGVsIHgseSBjb29yZGluYXRlcyB0byBhIHZpZXcgcG9zaXRpb24uXHJcbiAgcHVibGljIG1vZGVsVG9WaWV3WFkoIHg6IG51bWJlciwgeTogbnVtYmVyICk6IFZlY3RvcjIge1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKCB0aGlzLm1vZGVsVG9WaWV3WCggeCApLCB0aGlzLm1vZGVsVG9WaWV3WSggeSApICk7XHJcbiAgfVxyXG5cclxuICAvLyBUcmFuc2Zvcm1zIGEgbW9kZWwgcG9zaXRpb24gdG8gYSB2aWV3IHBvc2l0aW9uLlxyXG4gIHB1YmxpYyBtb2RlbFRvVmlld1Bvc2l0aW9uKCBwb3NpdGlvbjogVmVjdG9yMiApOiBWZWN0b3IyIHtcclxuICAgIHJldHVybiB0aGlzLm1vZGVsVG9WaWV3WFkoIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkgKTtcclxuICB9XHJcblxyXG4gIC8vIFRyYW5zZm9ybXMgYSBtb2RlbCBkZWx0YSB7bnVtYmVyfSB0byBhIHZpZXcgZGVsdGEge251bWJlcn0gZm9yIHRoZSBheGlzIHRoYXQgY29ycmVzcG9uZHMgdG8gT3JpZW50YXRpb24uXHJcbiAgcHVibGljIG1vZGVsVG9WaWV3RGVsdGEoIGF4aXNPcmllbnRhdGlvbjogT3JpZW50YXRpb24sIG1vZGVsRGVsdGE6IG51bWJlciApOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubW9kZWxUb1ZpZXcoIGF4aXNPcmllbnRhdGlvbiwgbW9kZWxEZWx0YSApIC0gdGhpcy5tb2RlbFRvVmlldyggYXhpc09yaWVudGF0aW9uLCAwICk7XHJcbiAgfVxyXG5cclxuICAvLyBUcmFuc2Zvcm1zIGEgbW9kZWwgZGVsdGEge251bWJlcn0gdG8gYSB2aWV3IGRlbHRhIHtudW1iZXJ9IGZvciB0aGUgeCBheGlzLlxyXG4gIHB1YmxpYyBtb2RlbFRvVmlld0RlbHRhWCggZHg6IG51bWJlciApOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubW9kZWxUb1ZpZXdEZWx0YSggT3JpZW50YXRpb24uSE9SSVpPTlRBTCwgZHggKTtcclxuICB9XHJcblxyXG4gIC8vIFRyYW5zZm9ybXMgYSBtb2RlbCBkZWx0YSB7bnVtYmVyfSB0byBhIHZpZXcgZGVsdGEge251bWJlcn0gZm9yIHRoZSB5IGF4aXMuXHJcbiAgcHVibGljIG1vZGVsVG9WaWV3RGVsdGFZKCBkeTogbnVtYmVyICk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5tb2RlbFRvVmlld0RlbHRhKCBPcmllbnRhdGlvbi5WRVJUSUNBTCwgZHkgKTtcclxuICB9XHJcblxyXG4gIC8vIFRyYW5zZm9ybXMgYSBtb2RlbCBkZWx0YSBwYWlyIG9mIG51bWJlcnMgdG8gdmlldyBWZWN0b3IyXHJcbiAgcHVibGljIG1vZGVsVG9WaWV3RGVsdGFYWSggZHg6IG51bWJlciwgZHk6IG51bWJlciApOiBWZWN0b3IyIHtcclxuICAgIHJldHVybiBuZXcgVmVjdG9yMiggdGhpcy5tb2RlbFRvVmlld0RlbHRhWCggZHggKSwgdGhpcy5tb2RlbFRvVmlld0RlbHRhWSggZHkgKSApO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydHMgYSBzY2FsYXIgdmFsdWUgZnJvbSB2aWV3IGNvb3JkaW5hdGVzIHRvIG1vZGVsIGNvb3JkaW5hdGVzLCBhbG9uZyB0aGUgc3BlY2lmaWVkIGF4aXMuICBUaGUgaW52ZXJzZSBvZiBtb2RlbFRvVmlldy5cclxuICBwdWJsaWMgdmlld1RvTW9kZWwoIGF4aXNPcmllbnRhdGlvbjogT3JpZW50YXRpb24sIHZhbHVlOiBudW1iZXIgKTogbnVtYmVyIHtcclxuXHJcbiAgICBjb25zdCBtb2RlbFJhbmdlID0gYXhpc09yaWVudGF0aW9uID09PSBPcmllbnRhdGlvbi5IT1JJWk9OVEFMID8gdGhpcy5tb2RlbFhSYW5nZSA6IHRoaXMubW9kZWxZUmFuZ2U7XHJcbiAgICBjb25zdCB2aWV3RGltZW5zaW9uID0gYXhpc09yaWVudGF0aW9uID09PSBPcmllbnRhdGlvbi5IT1JJWk9OVEFMID8gdGhpcy52aWV3V2lkdGggOiB0aGlzLnZpZXdIZWlnaHQ7XHJcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBheGlzT3JpZW50YXRpb24gPT09IE9yaWVudGF0aW9uLkhPUklaT05UQUwgPyB0aGlzLnhUcmFuc2Zvcm0gOiB0aGlzLnlUcmFuc2Zvcm07XHJcbiAgICBjb25zdCBpbnZlcnRlZCA9IGF4aXNPcmllbnRhdGlvbiA9PT0gT3JpZW50YXRpb24uSE9SSVpPTlRBTCA/IHRoaXMubW9kZWxYUmFuZ2VJbnZlcnRlZCA6IHRoaXMubW9kZWxZUmFuZ2VJbnZlcnRlZDtcclxuXHJcbiAgICBjb25zdCBsb3dTaWRlID0gaW52ZXJ0ZWQgPyB2aWV3RGltZW5zaW9uIDogMDtcclxuICAgIGNvbnN0IGhpZ2hTaWRlID0gaW52ZXJ0ZWQgPyAwIDogdmlld0RpbWVuc2lvbjtcclxuXHJcbiAgICAvLyBGb3IgdmVydGljYWwsICt5IGlzIHVzdWFsbHkgdXBcclxuICAgIGNvbnN0IG91dCA9IGF4aXNPcmllbnRhdGlvbiA9PT0gT3JpZW50YXRpb24uSE9SSVpPTlRBTCA/XHJcbiAgICAgICAgICAgICAgICBVdGlscy5saW5lYXIoIGxvd1NpZGUsIGhpZ2hTaWRlLCB0cmFuc2Zvcm0uZXZhbHVhdGUoIG1vZGVsUmFuZ2UubWluICksIHRyYW5zZm9ybS5ldmFsdWF0ZSggbW9kZWxSYW5nZS5tYXggKSwgdmFsdWUgKSA6XHJcbiAgICAgICAgICAgICAgICBVdGlscy5saW5lYXIoIGxvd1NpZGUsIGhpZ2hTaWRlLCB0cmFuc2Zvcm0uZXZhbHVhdGUoIG1vZGVsUmFuZ2UubWF4ICksIHRyYW5zZm9ybS5ldmFsdWF0ZSggbW9kZWxSYW5nZS5taW4gKSwgdmFsdWUgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIE51bWJlci5pc0Zpbml0ZSggb3V0ICksICdvdXQgdmFsdWUgc2hvdWxkIGJlIGZpbml0ZScgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICFpc05hTiggb3V0ICksICdvdXQgdmFsdWUgc2hvdWxkIGJlIGEgbnVtYmVyJyApO1xyXG5cclxuICAgIGNvbnN0IG1vZGVsVmFsdWUgPSB0cmFuc2Zvcm0uaW52ZXJzZSggb3V0ICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBOdW1iZXIuaXNGaW5pdGUoIG1vZGVsVmFsdWUgKSwgJ21vZGVsVmFsdWUgc2hvdWxkIGJlIGZpbml0ZScgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICFpc05hTiggbW9kZWxWYWx1ZSApLCAnbW9kZWxWYWx1ZSBzaG91bGQgYmUgYSBudW1iZXInICk7XHJcblxyXG4gICAgcmV0dXJuIG1vZGVsVmFsdWU7XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IGEgdmlldyBwb3NpdGlvbiB0byBhIG1vZGVsIHBvc2l0aW9uLCBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24uXHJcbiAgcHVibGljIHZpZXdUb01vZGVsWCggeDogbnVtYmVyICk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy52aWV3VG9Nb2RlbCggT3JpZW50YXRpb24uSE9SSVpPTlRBTCwgeCApO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBhIHZpZXcgcG9zaXRpb24gdG8gYSBtb2RlbCBwb3NpdGlvbiwgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbi5cclxuICBwdWJsaWMgdmlld1RvTW9kZWxZKCB5OiBudW1iZXIgKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLnZpZXdUb01vZGVsKCBPcmllbnRhdGlvbi5WRVJUSUNBTCwgeSApO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBhIHZpZXcgcG9zaXRpb24gdG8gYSBtb2RlbCBwb3NpdGlvbiwgZm9yIGEgY29vcmRpbmF0ZSBzcGVjaWZpZWQgYXMgeCx5LlxyXG4gIHB1YmxpYyB2aWV3VG9Nb2RlbFhZKCB4OiBudW1iZXIsIHk6IG51bWJlciApOiBWZWN0b3IyIHtcclxuICAgIHJldHVybiBuZXcgVmVjdG9yMiggdGhpcy52aWV3VG9Nb2RlbFgoIHggKSwgdGhpcy52aWV3VG9Nb2RlbFkoIHkgKSApO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBhIHZpZXcgcG9zaXRpb24gdG8gYSBtb2RlbCBwb3NpdGlvbi5cclxuICBwdWJsaWMgdmlld1RvTW9kZWxQb3NpdGlvbiggcG9zaXRpb246IFZlY3RvcjIgKTogVmVjdG9yMiB7XHJcbiAgICByZXR1cm4gdGhpcy52aWV3VG9Nb2RlbFhZKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55ICk7XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IGEgZGVsdGEgaW4gdGhlIHZpZXcgdG8gYSBkZWx0YSBpbiB0aGUgbW9kZWwsIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbi5cclxuICBwdWJsaWMgdmlld1RvTW9kZWxEZWx0YVgoIGR4OiBudW1iZXIgKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLnZpZXdUb01vZGVsWCggZHggKSAtIHRoaXMudmlld1RvTW9kZWxYKCAwICk7XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IGEgZGVsdGEgaW4gdGhlIHZpZXcgdG8gYSBkZWx0YSBpbiB0aGUgbW9kZWwsIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24uXHJcbiAgcHVibGljIHZpZXdUb01vZGVsRGVsdGFZKCBkeTogbnVtYmVyICk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy52aWV3VG9Nb2RlbFkoIGR5ICkgLSB0aGlzLnZpZXdUb01vZGVsWSggMCApO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBhIGRlbHRhIGluIHRoZSB2aWV3IHRvIGEgZGVsdGEgaW4gdGhlIG1vZGVsLCBmb3IgYSBWZWN0b3IyXHJcbiAgcHVibGljIHZpZXdUb01vZGVsRGVsdGEoIGRlbHRhVmVjdG9yOiBWZWN0b3IyICk6IFZlY3RvcjIge1xyXG4gICAgcmV0dXJuIHRoaXMudmlld1RvTW9kZWxQb3NpdGlvbiggZGVsdGFWZWN0b3IgKS5taW51cyggdGhpcy52aWV3VG9Nb2RlbFBvc2l0aW9uKCBWZWN0b3IyLlpFUk8gKSApO1xyXG4gIH1cclxuXHJcbiAgLy8gU2V0cyB0aGUgdmlldyB3aWR0aC5cclxuICBwdWJsaWMgc2V0Vmlld1dpZHRoKCB2aWV3V2lkdGg6IG51bWJlciApOiB2b2lkIHtcclxuICAgIGlmICggdmlld1dpZHRoICE9PSB0aGlzLnZpZXdXaWR0aCApIHtcclxuICAgICAgdGhpcy52aWV3V2lkdGggPSB2aWV3V2lkdGg7XHJcbiAgICAgIHRoaXMuY2hhbmdlZEVtaXR0ZXIuZW1pdCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2V0cyB0aGUgdmlldyBoZWlnaHQuXHJcbiAgcHVibGljIHNldFZpZXdIZWlnaHQoIHZpZXdIZWlnaHQ6IG51bWJlciApOiB2b2lkIHtcclxuICAgIGlmICggdmlld0hlaWdodCAhPT0gdGhpcy52aWV3SGVpZ2h0ICkge1xyXG4gICAgICB0aGlzLnZpZXdIZWlnaHQgPSB2aWV3SGVpZ2h0O1xyXG4gICAgICB0aGlzLmNoYW5nZWRFbWl0dGVyLmVtaXQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFNldHMgdGhlIFJhbmdlIGZvciB0aGUgbW9kZWwncyB4IGRpbWVuc2lvbi5cclxuICBwdWJsaWMgc2V0TW9kZWxYUmFuZ2UoIG1vZGVsWFJhbmdlOiBSYW5nZSApOiB2b2lkIHtcclxuICAgIGlmICggIW1vZGVsWFJhbmdlLmVxdWFscyggdGhpcy5tb2RlbFhSYW5nZSApICkge1xyXG4gICAgICB0aGlzLm1vZGVsWFJhbmdlID0gbW9kZWxYUmFuZ2U7XHJcbiAgICAgIHRoaXMuY2hhbmdlZEVtaXR0ZXIuZW1pdCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2V0cyB0aGUgUmFuZ2UgZm9yIHRoZSBtb2RlbCdzIHkgZGltZW5zaW9uLlxyXG4gIHB1YmxpYyBzZXRNb2RlbFlSYW5nZSggbW9kZWxZUmFuZ2U6IFJhbmdlICk6IHZvaWQge1xyXG4gICAgaWYgKCAhbW9kZWxZUmFuZ2UuZXF1YWxzKCB0aGlzLm1vZGVsWVJhbmdlICkgKSB7XHJcbiAgICAgIHRoaXMubW9kZWxZUmFuZ2UgPSBtb2RlbFlSYW5nZTtcclxuICAgICAgdGhpcy5jaGFuZ2VkRW1pdHRlci5lbWl0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBHZXRzIHRoZSBtb2RlbCByYW5nZSBmb3IgdGhlIGF4aXMgdGhhdCBjb3JyZXNwb25kcyB0byBPcmllbnRhdGlvbi5cclxuICBwdWJsaWMgZ2V0TW9kZWxSYW5nZSggYXhpc09yaWVudGF0aW9uOiBPcmllbnRhdGlvbiApOiBSYW5nZSB7XHJcbiAgICByZXR1cm4gKCBheGlzT3JpZW50YXRpb24gPT09IE9yaWVudGF0aW9uLkhPUklaT05UQUwgKSA/IHRoaXMubW9kZWxYUmFuZ2UgOiB0aGlzLm1vZGVsWVJhbmdlO1xyXG4gIH1cclxuXHJcbiAgLy8gU2V0cyB0aGUgbW9kZWwtdG8tdmlldyBzY2FsaW5nIGZ1bmN0aW9uIGZvciB0aGUgeC1heGlzLlxyXG4gIHB1YmxpYyBzZXRYVHJhbnNmb3JtKCB4VHJhbnNmb3JtOiBUcmFuc2Zvcm0xICk6IHZvaWQge1xyXG4gICAgaWYgKCB0aGlzLnhUcmFuc2Zvcm0gIT09IHhUcmFuc2Zvcm0gKSB7XHJcbiAgICAgIHRoaXMueFRyYW5zZm9ybSA9IHhUcmFuc2Zvcm07XHJcbiAgICAgIHRoaXMuY2hhbmdlZEVtaXR0ZXIuZW1pdCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2V0cyB0aGUgbW9kZWwtdG8tdmlldyBzY2FsaW5nIGZ1bmN0aW9uIGZvciB0aGUgeS1heGlzLlxyXG4gIHB1YmxpYyBzZXRZVHJhbnNmb3JtKCB5VHJhbnNmb3JtOiBUcmFuc2Zvcm0xICk6IHZvaWQge1xyXG4gICAgaWYgKCB0aGlzLnlUcmFuc2Zvcm0gIT09IHlUcmFuc2Zvcm0gKSB7XHJcbiAgICAgIHRoaXMueVRyYW5zZm9ybSA9IHlUcmFuc2Zvcm07XHJcbiAgICAgIHRoaXMuY2hhbmdlZEVtaXR0ZXIuZW1pdCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldFNwYWNpbmdCb3JkZXJzKCBheGlzT3JpZW50YXRpb246IE9yaWVudGF0aW9uLCBzcGFjaW5nOiBudW1iZXIsIG9yaWdpbjogbnVtYmVyLCBjbGlwcGluZ1R5cGU6IENsaXBwaW5nVHlwZSApOiBudW1iZXJbXSB7XHJcbiAgICBjb25zdCBtb2RlbFJhbmdlID0gdGhpcy5nZXRNb2RlbFJhbmdlKCBheGlzT3JpZW50YXRpb24gKTtcclxuICAgIGNvbnN0IG5NaW4gPSBnZXRWYWx1ZUZvclNwYWNpbmcoIG1vZGVsUmFuZ2UubWluLCBjbGlwcGluZ1R5cGUsIG9yaWdpbiwgc3BhY2luZywgTWF0aC5jZWlsICk7XHJcbiAgICBjb25zdCBuTWF4ID0gZ2V0VmFsdWVGb3JTcGFjaW5nKCBtb2RlbFJhbmdlLm1heCwgY2xpcHBpbmdUeXBlLCBvcmlnaW4sIHNwYWNpbmcsIE1hdGguZmxvb3IgKTtcclxuXHJcbiAgICByZXR1cm4gWyBuTWluLCBuTWF4IF07XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU29sdmUgZm9yIHNwYWNlZCB2YWx1ZS5cclxuICogbiAqIHNwYWNpbmcgKyBvcmlnaW4gPSB4XHJcbiAqIG4gPSAoeC1vcmlnaW4pL3NwYWNpbmcsIHdoZXJlIG4gaXMgYW4gaW50ZWdlclxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VmFsdWVGb3JTcGFjaW5nKCB2YWx1ZTogbnVtYmVyLCBjbGlwcGluZ1R5cGU6IENsaXBwaW5nVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG51bWJlciwgc3BhY2luZzogbnVtYmVyLCByb3VuZDogKCBuOiBudW1iZXIgKSA9PiBudW1iZXIgKTogbnVtYmVyIHtcclxuICByZXR1cm4gY2xpcHBpbmdUeXBlID09PSAnbGVuaWVudCcgP1xyXG4gICAgICAgICBVdGlscy5yb3VuZFN5bW1ldHJpYyggKCB2YWx1ZSAtIG9yaWdpbiApIC8gc3BhY2luZyApIDpcclxuICAgICAgICAgcm91bmQoICggdmFsdWUgLSBvcmlnaW4gKSAvIHNwYWNpbmcgKTtcclxufVxyXG5cclxuYmFtYm9vLnJlZ2lzdGVyKCAnQ2hhcnRUcmFuc2Zvcm0nLCBDaGFydFRyYW5zZm9ybSApO1xyXG5leHBvcnQgZGVmYXVsdCBDaGFydFRyYW5zZm9ybTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFN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