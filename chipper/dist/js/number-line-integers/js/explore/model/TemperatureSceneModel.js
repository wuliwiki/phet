// Copyright 2019-2022, University of Colorado Boulder

/**
 * TemperatureSceneModel is the model for the "Temperature" scene in the "Explore" screen
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Saurabh Totey
 * @author Arnab Purkayastha
 */

import EnumerationDeprecatedProperty from '../../../../axon/js/EnumerationDeprecatedProperty.js';
import NumberProperty from '../../../../axon/js/NumberProperty.js';
import Bounds2 from '../../../../dot/js/Bounds2.js';
import Range from '../../../../dot/js/Range.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import LockToNumberLine from '../../../../number-line-common/js/common/model/LockToNumberLine.js';
import Orientation from '../../../../phet-core/js/Orientation.js';
import NLIConstants from '../../common/NLIConstants.js';
import NLIQueryParameters from '../../common/NLIQueryParameters.js';
import numberLineIntegers from '../../numberLineIntegers.js';
import NumberLineIntegersStrings from '../../NumberLineIntegersStrings.js';
import reverseRobinsonProjector from './reverseRobinsonProjector.js';
import SceneModel from './SceneModel.js';
import temperatureDataSet from './temperatureDataSet.js';
import TemperaturePointController from './TemperaturePointController.js';
const thermometerALabelString = NumberLineIntegersStrings.thermometerALabel;
const thermometerBLabelString = NumberLineIntegersStrings.thermometerBLabel;
const thermometerCLabelString = NumberLineIntegersStrings.thermometerCLabel;

// constants
const SCENE_BOUNDS = NLIConstants.NLI_LAYOUT_BOUNDS; // bounds for the scenes match the layout bounds
const THERMOMETER_LABELS = [thermometerALabelString, thermometerBLabelString, thermometerCLabelString];
const MAP_WIDTH = 550; // in screen coordinates
const MAP_HEIGHT = 280; // in screen coordinates
const MAP_CENTER = new Vector2(SCENE_BOUNDS.centerX, SCENE_BOUNDS.height * 0.465);
const MAP_BOUNDS = new Bounds2(MAP_CENTER.x - MAP_WIDTH / 2, MAP_CENTER.y - MAP_HEIGHT / 2, MAP_CENTER.x + MAP_WIDTH / 2, MAP_CENTER.y + MAP_HEIGHT / 2);
const CELSIUS_NUMBER_LINE_RANGE = new Range(-64, 42);
const FAHRENHEIT_NUMBER_LINE_RANGE = new Range(-83, 108);
const NUMBER_LINE_HEIGHT = 490; // empirically determined by visual appearance
const X_MOVE_AMOUNT = 1; // in model/view coords, amount to move a point controller to avoid overlap with another
const Y_MOVE_AMOUNT = 1; // in model/view coords, amount to move a point controller to avoid overlap with another
const FAHRENHEIT_NUMBER_LINE_INDEX = 0;
const CELSIUS_NUMBER_LINE_INDEX = 1;
class TemperatureSceneModel extends SceneModel {
  /**
   * @public
   */
  constructor() {
    // The base class has a single number line, so make that one the Fahrenheit version.
    super({
      // two number lines, one for Fahrenheit and one for Celsius
      numberOfNumberLines: 2,
      commonNumberLineOptions: {
        initialOrientation: Orientation.VERTICAL,
        heightInModelSpace: NUMBER_LINE_HEIGHT,
        labelsInitiallyVisible: true
      },
      numberLineZeroPositions: [getNumberLineZeroPosition(FAHRENHEIT_NUMBER_LINE_RANGE), getNumberLineZeroPosition(CELSIUS_NUMBER_LINE_RANGE)],
      uniqueNumberLineOptionsList: [{
        initialDisplayedRange: FAHRENHEIT_NUMBER_LINE_RANGE
      }, {
        initialDisplayedRange: CELSIUS_NUMBER_LINE_RANGE
      }]
    });

    // @public (read-only) {Bounds2} - bounds of the map area
    this.mapBounds = MAP_BOUNDS;

    // @public
    this.monthProperty = new NumberProperty(1);

    // @public
    this.temperatureUnitsProperty = new EnumerationDeprecatedProperty(NLIConstants.TEMPERATURE_UNITS, NLIQueryParameters.defaultCelsius ? NLIConstants.TEMPERATURE_UNITS.CELSIUS : NLIConstants.TEMPERATURE_UNITS.FAHRENHEIT);

    // Specify the position of the box that will hold the thermometers.
    const boxWidth = MAP_WIDTH * 0.5;
    const boxHeight = (SCENE_BOUNDS.maxY - MAP_BOUNDS.maxY) * 0.4;
    const boxCenterX = MAP_CENTER.x;
    const boxBottom = SCENE_BOUNDS.maxY - 16; // empirically determined to match up with other scenes

    // @public (read-only) {Bounds2} - holding area for the thermometers
    this.thermometerBoxBounds = new Bounds2(boxCenterX - boxWidth / 2, boxBottom - boxHeight, boxCenterX + boxWidth / 2, boxBottom);

    // @public (read-only) - the point controllers that can be moved into the elevation scene
    this.permanentPointControllers = _.times(3, i => new TemperaturePointController(this, THERMOMETER_LABELS[i], {
      numberLines: this.numberLines,
      lockToNumberLine: LockToNumberLine.NEVER,
      scaleInBox: 0.5
    }));

    // Put the permanent point controllers in their starting positions.
    this.permanentPointControllers.forEach(pointController => {
      this.putPointControllerInBox(pointController);
    });

    // Monitor each point controller for when it is dropped and check for whether actions are needed.
    this.permanentPointControllers.forEach(pointController => {
      pointController.isDraggingProperty.lazyLink(isDragging => {
        if (!isDragging) {
          if (!pointController.isOverMapProperty.value) {
            // The point controller was released outside of the map area, so put it away in the holding box.
            this.putPointControllerInBox(pointController, true);
          } else {
            // The point controller was dropped on the map, resolve any overlap with other point controllers.
            this.resolvePointControllerOverlap();
          }
        }
      });
    });

    // When the month changes, check and resolve any overlap in temperature values that may have occurred.
    this.monthProperty.lazyLink(() => {
      this.resolvePointControllerOverlap();
    });
  }

  /**
   * Get the temperature at the specified position.
   * @param {Vector2} position - model coordinates for where to get the temperature
   * @returns {number|null} - the temperature in degrees Kelvin if the position is over the map, null otherwise
   * @public
   */
  getTemperatureAtPosition(position) {
    // Convert the position into normalized values based on the map's position and size.  These values assume a total
    // span of 1 in the vertical and horizontal directions with the point (0,0) being in the center of the map.
    const normalizedXPosition = (position.x - this.mapBounds.centerX) / this.mapBounds.width;
    const normalizedYPosition = (this.mapBounds.centerY - position.y) / this.mapBounds.height;

    // Test if the position is over the rectangle that contains the map.  This does *not* test the corners of the
    // rectangle to see whether the point is inside the Robinson projection - that happens further below.
    if (normalizedXPosition < -0.5 || normalizedXPosition > 0.5 || normalizedYPosition < -0.5 || normalizedYPosition > 0.5) {
      // The point is not over the map rectangle - bail.
      return null;
    }

    // Convert the normalized x and y values into latitude and longitude values.
    const latLong = reverseRobinsonProjector.xyToLatLong(normalizedXPosition, normalizedYPosition);

    // Return null if position is not in map bounds.
    if (latLong.latitude > 90 || latLong.latitude < -90 || latLong.longitude > 180 || latLong.longitude < -180) {
      return null;
    }

    // Return the temperature at this position on the surface of the Earth for the current month.
    return temperatureDataSet.getNearSurfaceTemperature(this.monthProperty.value, latLong.latitude, latLong.longitude);
  }

  /**
   * @public
   */
  get celsiusNumberLine() {
    return this.numberLines[CELSIUS_NUMBER_LINE_INDEX];
  }

  /**
   * @public
   */
  get fahrenheitNumberLine() {
    return this.numberLines[FAHRENHEIT_NUMBER_LINE_INDEX];
  }

  /**
   * Place the provided point controller into the holding box, generally done on init, reset, and when the user "puts
   * it away".
   * @param {TemperaturePointController} pointController
   * @param {boolean} [animate] - controls whether to animate the return to the box or do it instantly
   * @private
   */
  putPointControllerInBox(pointController, animate = false) {
    const index = this.permanentPointControllers.indexOf(pointController);
    const numPositions = this.permanentPointControllers.length;

    // error checking
    assert && assert(index >= 0, 'point controller not found on list');
    assert && assert(!pointController.isControllingNumberLinePoint(), 'point controller should not be put away while controlling a point');
    const spacing = this.thermometerBoxBounds.width / numPositions;
    const destination = new Vector2(this.thermometerBoxBounds.minX + spacing / 2 + spacing * index, this.thermometerBoxBounds.centerY + 25 // empirically determined so that thermometers are vertically centered
    );

    pointController.goToPosition(destination, animate);
  }

  /**
   * Resolve any temperature overlap between the point controllers.  Because the temperature is the same at the same
   * position, this will also resolve any positional overlap.
   * @private
   */
  resolvePointControllerOverlap() {
    // Make a list of all point controller that are currently on the map.
    const pointControllersOnMap = this.permanentPointControllers.filter(pointController => {
      return pointController.isOverMapProperty.value && !pointController.isDraggingProperty.value;
    });
    if (pointControllersOnMap.length >= 2) {
      // Sort the point controllers such that the most recently added ones are towards the front of the array.
      pointControllersOnMap.sort((pc1, pc2) => {
        return pc2.droppedOnMapTimestamp - pc1.droppedOnMapTimestamp;
      });

      // Loop through all controllers, moving them as necessary to eliminate temperature or position overlap.
      _.times(pointControllersOnMap.length - 1, () => {
        // Pull the first controller from the front of the list.
        const pointControllerUnderTest = pointControllersOnMap.splice(0, 1)[0];
        const startPosition = pointControllerUnderTest.positionProperty.value.copy();
        let moveCount = 0;

        // Test for overlap with all other temperature point controllers, move if detected.
        while (_.some(pointControllersOnMap, pc => pc.celsiusTemperatureProperty.value === pointControllerUnderTest.celsiusTemperatureProperty.value)) {
          // Overlap detected, move the point controller towards the a reasonably large area of the map.
          const xMovement = (startPosition.x > MAP_CENTER.x ? -1 : 1) * (moveCount + 1) * X_MOVE_AMOUNT;
          const yMovement = (startPosition.y > MAP_CENTER.y ? -1 : 1) * (moveCount + 1) * Y_MOVE_AMOUNT;

          // Calculate the new proposed position.
          const newProposedPosition = pointControllerUnderTest.positionProperty.value.plusXY(xMovement, yMovement);

          // There could be some rare cases where a point controller moves all the way across the map and doesn't find
          // a position with a non-overlapping temperature.  For instance, if all the temperature values on the map
          // are the same, this could happen.  Since this seems very unlikely, we test for it and assert if it
          // happens.
          assert && assert(this.getTemperatureAtPosition(newProposedPosition) !== null, 'unable to find position with different temperature value');

          // Move the point controller.
          pointControllerUnderTest.positionProperty.set(newProposedPosition);
          moveCount++;
        }
      });
    }
  }

  /**
   * @override
   * @public
   */
  reset() {
    // Only reset the temperature units on a full reset, not a scene reset, see
    // https://github.com/phetsims/number-line-integers/issues/86.
    this.temperatureUnitsProperty.reset();
    this.numberLines.forEach(nl => {
      nl.reset();
    });
    super.reset();
  }

  /**
   * Restore initial state.
   * @public
   */
  resetScene() {
    this.monthProperty.reset();
    this.numberLines.forEach(nl => {
      nl.removeAllPoints();
    });

    // Put the point controllers back into their starting positions.
    this.permanentPointControllers.forEach(pointController => {
      pointController.reset();
      this.putPointControllerInBox(pointController);
    });
  }
}

// static fields
TemperatureSceneModel.CELSIUS_NUMBER_LINE_INDEX = CELSIUS_NUMBER_LINE_INDEX;
TemperatureSceneModel.FAHRENHEIT_NUMBER_LINE_INDEX = FAHRENHEIT_NUMBER_LINE_INDEX;

/**
 * helper function to avoid code duplication
 */
function getNumberLineZeroPosition(range) {
  return new Vector2(
  // halfway between the left edge of the scene and the left edge of the map
  (SCENE_BOUNDS.minX + MAP_BOUNDS.minX) / 2,
  // centers number line vertically within scene
  0.5 * SCENE_BOUNDS.height + NUMBER_LINE_HEIGHT * (0.5 + range.min / range.getLength()));
}
numberLineIntegers.register('TemperatureSceneModel', TemperatureSceneModel);
export default TemperatureSceneModel;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFbnVtZXJhdGlvbkRlcHJlY2F0ZWRQcm9wZXJ0eSIsIk51bWJlclByb3BlcnR5IiwiQm91bmRzMiIsIlJhbmdlIiwiVmVjdG9yMiIsIkxvY2tUb051bWJlckxpbmUiLCJPcmllbnRhdGlvbiIsIk5MSUNvbnN0YW50cyIsIk5MSVF1ZXJ5UGFyYW1ldGVycyIsIm51bWJlckxpbmVJbnRlZ2VycyIsIk51bWJlckxpbmVJbnRlZ2Vyc1N0cmluZ3MiLCJyZXZlcnNlUm9iaW5zb25Qcm9qZWN0b3IiLCJTY2VuZU1vZGVsIiwidGVtcGVyYXR1cmVEYXRhU2V0IiwiVGVtcGVyYXR1cmVQb2ludENvbnRyb2xsZXIiLCJ0aGVybW9tZXRlckFMYWJlbFN0cmluZyIsInRoZXJtb21ldGVyQUxhYmVsIiwidGhlcm1vbWV0ZXJCTGFiZWxTdHJpbmciLCJ0aGVybW9tZXRlckJMYWJlbCIsInRoZXJtb21ldGVyQ0xhYmVsU3RyaW5nIiwidGhlcm1vbWV0ZXJDTGFiZWwiLCJTQ0VORV9CT1VORFMiLCJOTElfTEFZT1VUX0JPVU5EUyIsIlRIRVJNT01FVEVSX0xBQkVMUyIsIk1BUF9XSURUSCIsIk1BUF9IRUlHSFQiLCJNQVBfQ0VOVEVSIiwiY2VudGVyWCIsImhlaWdodCIsIk1BUF9CT1VORFMiLCJ4IiwieSIsIkNFTFNJVVNfTlVNQkVSX0xJTkVfUkFOR0UiLCJGQUhSRU5IRUlUX05VTUJFUl9MSU5FX1JBTkdFIiwiTlVNQkVSX0xJTkVfSEVJR0hUIiwiWF9NT1ZFX0FNT1VOVCIsIllfTU9WRV9BTU9VTlQiLCJGQUhSRU5IRUlUX05VTUJFUl9MSU5FX0lOREVYIiwiQ0VMU0lVU19OVU1CRVJfTElORV9JTkRFWCIsIlRlbXBlcmF0dXJlU2NlbmVNb2RlbCIsImNvbnN0cnVjdG9yIiwibnVtYmVyT2ZOdW1iZXJMaW5lcyIsImNvbW1vbk51bWJlckxpbmVPcHRpb25zIiwiaW5pdGlhbE9yaWVudGF0aW9uIiwiVkVSVElDQUwiLCJoZWlnaHRJbk1vZGVsU3BhY2UiLCJsYWJlbHNJbml0aWFsbHlWaXNpYmxlIiwibnVtYmVyTGluZVplcm9Qb3NpdGlvbnMiLCJnZXROdW1iZXJMaW5lWmVyb1Bvc2l0aW9uIiwidW5pcXVlTnVtYmVyTGluZU9wdGlvbnNMaXN0IiwiaW5pdGlhbERpc3BsYXllZFJhbmdlIiwibWFwQm91bmRzIiwibW9udGhQcm9wZXJ0eSIsInRlbXBlcmF0dXJlVW5pdHNQcm9wZXJ0eSIsIlRFTVBFUkFUVVJFX1VOSVRTIiwiZGVmYXVsdENlbHNpdXMiLCJDRUxTSVVTIiwiRkFIUkVOSEVJVCIsImJveFdpZHRoIiwiYm94SGVpZ2h0IiwibWF4WSIsImJveENlbnRlclgiLCJib3hCb3R0b20iLCJ0aGVybW9tZXRlckJveEJvdW5kcyIsInBlcm1hbmVudFBvaW50Q29udHJvbGxlcnMiLCJfIiwidGltZXMiLCJpIiwibnVtYmVyTGluZXMiLCJsb2NrVG9OdW1iZXJMaW5lIiwiTkVWRVIiLCJzY2FsZUluQm94IiwiZm9yRWFjaCIsInBvaW50Q29udHJvbGxlciIsInB1dFBvaW50Q29udHJvbGxlckluQm94IiwiaXNEcmFnZ2luZ1Byb3BlcnR5IiwibGF6eUxpbmsiLCJpc0RyYWdnaW5nIiwiaXNPdmVyTWFwUHJvcGVydHkiLCJ2YWx1ZSIsInJlc29sdmVQb2ludENvbnRyb2xsZXJPdmVybGFwIiwiZ2V0VGVtcGVyYXR1cmVBdFBvc2l0aW9uIiwicG9zaXRpb24iLCJub3JtYWxpemVkWFBvc2l0aW9uIiwid2lkdGgiLCJub3JtYWxpemVkWVBvc2l0aW9uIiwiY2VudGVyWSIsImxhdExvbmciLCJ4eVRvTGF0TG9uZyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiZ2V0TmVhclN1cmZhY2VUZW1wZXJhdHVyZSIsImNlbHNpdXNOdW1iZXJMaW5lIiwiZmFocmVuaGVpdE51bWJlckxpbmUiLCJhbmltYXRlIiwiaW5kZXgiLCJpbmRleE9mIiwibnVtUG9zaXRpb25zIiwibGVuZ3RoIiwiYXNzZXJ0IiwiaXNDb250cm9sbGluZ051bWJlckxpbmVQb2ludCIsInNwYWNpbmciLCJkZXN0aW5hdGlvbiIsIm1pblgiLCJnb1RvUG9zaXRpb24iLCJwb2ludENvbnRyb2xsZXJzT25NYXAiLCJmaWx0ZXIiLCJzb3J0IiwicGMxIiwicGMyIiwiZHJvcHBlZE9uTWFwVGltZXN0YW1wIiwicG9pbnRDb250cm9sbGVyVW5kZXJUZXN0Iiwic3BsaWNlIiwic3RhcnRQb3NpdGlvbiIsInBvc2l0aW9uUHJvcGVydHkiLCJjb3B5IiwibW92ZUNvdW50Iiwic29tZSIsInBjIiwiY2Vsc2l1c1RlbXBlcmF0dXJlUHJvcGVydHkiLCJ4TW92ZW1lbnQiLCJ5TW92ZW1lbnQiLCJuZXdQcm9wb3NlZFBvc2l0aW9uIiwicGx1c1hZIiwic2V0IiwicmVzZXQiLCJubCIsInJlc2V0U2NlbmUiLCJyZW1vdmVBbGxQb2ludHMiLCJyYW5nZSIsIm1pbiIsImdldExlbmd0aCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiVGVtcGVyYXR1cmVTY2VuZU1vZGVsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE5LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFRlbXBlcmF0dXJlU2NlbmVNb2RlbCBpcyB0aGUgbW9kZWwgZm9yIHRoZSBcIlRlbXBlcmF0dXJlXCIgc2NlbmUgaW4gdGhlIFwiRXhwbG9yZVwiIHNjcmVlblxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKiBAYXV0aG9yIFNhdXJhYmggVG90ZXlcclxuICogQGF1dGhvciBBcm5hYiBQdXJrYXlhc3RoYVxyXG4gKi9cclxuXHJcbmltcG9ydCBFbnVtZXJhdGlvbkRlcHJlY2F0ZWRQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0VudW1lcmF0aW9uRGVwcmVjYXRlZFByb3BlcnR5LmpzJztcclxuaW1wb3J0IE51bWJlclByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvTnVtYmVyUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgQm91bmRzMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvQm91bmRzMi5qcyc7XHJcbmltcG9ydCBSYW5nZSBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvUmFuZ2UuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBMb2NrVG9OdW1iZXJMaW5lIGZyb20gJy4uLy4uLy4uLy4uL251bWJlci1saW5lLWNvbW1vbi9qcy9jb21tb24vbW9kZWwvTG9ja1RvTnVtYmVyTGluZS5qcyc7XHJcbmltcG9ydCBPcmllbnRhdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvT3JpZW50YXRpb24uanMnO1xyXG5pbXBvcnQgTkxJQ29uc3RhbnRzIGZyb20gJy4uLy4uL2NvbW1vbi9OTElDb25zdGFudHMuanMnO1xyXG5pbXBvcnQgTkxJUXVlcnlQYXJhbWV0ZXJzIGZyb20gJy4uLy4uL2NvbW1vbi9OTElRdWVyeVBhcmFtZXRlcnMuanMnO1xyXG5pbXBvcnQgbnVtYmVyTGluZUludGVnZXJzIGZyb20gJy4uLy4uL251bWJlckxpbmVJbnRlZ2Vycy5qcyc7XHJcbmltcG9ydCBOdW1iZXJMaW5lSW50ZWdlcnNTdHJpbmdzIGZyb20gJy4uLy4uL051bWJlckxpbmVJbnRlZ2Vyc1N0cmluZ3MuanMnO1xyXG5pbXBvcnQgcmV2ZXJzZVJvYmluc29uUHJvamVjdG9yIGZyb20gJy4vcmV2ZXJzZVJvYmluc29uUHJvamVjdG9yLmpzJztcclxuaW1wb3J0IFNjZW5lTW9kZWwgZnJvbSAnLi9TY2VuZU1vZGVsLmpzJztcclxuaW1wb3J0IHRlbXBlcmF0dXJlRGF0YVNldCBmcm9tICcuL3RlbXBlcmF0dXJlRGF0YVNldC5qcyc7XHJcbmltcG9ydCBUZW1wZXJhdHVyZVBvaW50Q29udHJvbGxlciBmcm9tICcuL1RlbXBlcmF0dXJlUG9pbnRDb250cm9sbGVyLmpzJztcclxuXHJcbmNvbnN0IHRoZXJtb21ldGVyQUxhYmVsU3RyaW5nID0gTnVtYmVyTGluZUludGVnZXJzU3RyaW5ncy50aGVybW9tZXRlckFMYWJlbDtcclxuY29uc3QgdGhlcm1vbWV0ZXJCTGFiZWxTdHJpbmcgPSBOdW1iZXJMaW5lSW50ZWdlcnNTdHJpbmdzLnRoZXJtb21ldGVyQkxhYmVsO1xyXG5jb25zdCB0aGVybW9tZXRlckNMYWJlbFN0cmluZyA9IE51bWJlckxpbmVJbnRlZ2Vyc1N0cmluZ3MudGhlcm1vbWV0ZXJDTGFiZWw7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgU0NFTkVfQk9VTkRTID0gTkxJQ29uc3RhbnRzLk5MSV9MQVlPVVRfQk9VTkRTOyAvLyBib3VuZHMgZm9yIHRoZSBzY2VuZXMgbWF0Y2ggdGhlIGxheW91dCBib3VuZHNcclxuY29uc3QgVEhFUk1PTUVURVJfTEFCRUxTID0gWyB0aGVybW9tZXRlckFMYWJlbFN0cmluZywgdGhlcm1vbWV0ZXJCTGFiZWxTdHJpbmcsIHRoZXJtb21ldGVyQ0xhYmVsU3RyaW5nIF07XHJcbmNvbnN0IE1BUF9XSURUSCA9IDU1MDsgLy8gaW4gc2NyZWVuIGNvb3JkaW5hdGVzXHJcbmNvbnN0IE1BUF9IRUlHSFQgPSAyODA7IC8vIGluIHNjcmVlbiBjb29yZGluYXRlc1xyXG5jb25zdCBNQVBfQ0VOVEVSID0gbmV3IFZlY3RvcjIoXHJcbiAgU0NFTkVfQk9VTkRTLmNlbnRlclgsXHJcbiAgU0NFTkVfQk9VTkRTLmhlaWdodCAqIDAuNDY1XHJcbik7XHJcbmNvbnN0IE1BUF9CT1VORFMgPSBuZXcgQm91bmRzMihcclxuICBNQVBfQ0VOVEVSLnggLSBNQVBfV0lEVEggLyAyLFxyXG4gIE1BUF9DRU5URVIueSAtIE1BUF9IRUlHSFQgLyAyLFxyXG4gIE1BUF9DRU5URVIueCArIE1BUF9XSURUSCAvIDIsXHJcbiAgTUFQX0NFTlRFUi55ICsgTUFQX0hFSUdIVCAvIDJcclxuKTtcclxuY29uc3QgQ0VMU0lVU19OVU1CRVJfTElORV9SQU5HRSA9IG5ldyBSYW5nZSggLTY0LCA0MiApO1xyXG5jb25zdCBGQUhSRU5IRUlUX05VTUJFUl9MSU5FX1JBTkdFID0gbmV3IFJhbmdlKCAtODMsIDEwOCApO1xyXG5jb25zdCBOVU1CRVJfTElORV9IRUlHSFQgPSA0OTA7IC8vIGVtcGlyaWNhbGx5IGRldGVybWluZWQgYnkgdmlzdWFsIGFwcGVhcmFuY2VcclxuY29uc3QgWF9NT1ZFX0FNT1VOVCA9IDE7IC8vIGluIG1vZGVsL3ZpZXcgY29vcmRzLCBhbW91bnQgdG8gbW92ZSBhIHBvaW50IGNvbnRyb2xsZXIgdG8gYXZvaWQgb3ZlcmxhcCB3aXRoIGFub3RoZXJcclxuY29uc3QgWV9NT1ZFX0FNT1VOVCA9IDE7IC8vIGluIG1vZGVsL3ZpZXcgY29vcmRzLCBhbW91bnQgdG8gbW92ZSBhIHBvaW50IGNvbnRyb2xsZXIgdG8gYXZvaWQgb3ZlcmxhcCB3aXRoIGFub3RoZXJcclxuY29uc3QgRkFIUkVOSEVJVF9OVU1CRVJfTElORV9JTkRFWCA9IDA7XHJcbmNvbnN0IENFTFNJVVNfTlVNQkVSX0xJTkVfSU5ERVggPSAxO1xyXG5cclxuY2xhc3MgVGVtcGVyYXR1cmVTY2VuZU1vZGVsIGV4dGVuZHMgU2NlbmVNb2RlbCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuXHJcbiAgICAvLyBUaGUgYmFzZSBjbGFzcyBoYXMgYSBzaW5nbGUgbnVtYmVyIGxpbmUsIHNvIG1ha2UgdGhhdCBvbmUgdGhlIEZhaHJlbmhlaXQgdmVyc2lvbi5cclxuICAgIHN1cGVyKCB7XHJcblxyXG4gICAgICAvLyB0d28gbnVtYmVyIGxpbmVzLCBvbmUgZm9yIEZhaHJlbmhlaXQgYW5kIG9uZSBmb3IgQ2Vsc2l1c1xyXG4gICAgICBudW1iZXJPZk51bWJlckxpbmVzOiAyLFxyXG5cclxuICAgICAgY29tbW9uTnVtYmVyTGluZU9wdGlvbnM6IHtcclxuICAgICAgICBpbml0aWFsT3JpZW50YXRpb246IE9yaWVudGF0aW9uLlZFUlRJQ0FMLFxyXG4gICAgICAgIGhlaWdodEluTW9kZWxTcGFjZTogTlVNQkVSX0xJTkVfSEVJR0hULFxyXG4gICAgICAgIGxhYmVsc0luaXRpYWxseVZpc2libGU6IHRydWVcclxuICAgICAgfSxcclxuXHJcbiAgICAgIG51bWJlckxpbmVaZXJvUG9zaXRpb25zOiBbXHJcbiAgICAgICAgZ2V0TnVtYmVyTGluZVplcm9Qb3NpdGlvbiggRkFIUkVOSEVJVF9OVU1CRVJfTElORV9SQU5HRSApLFxyXG4gICAgICAgIGdldE51bWJlckxpbmVaZXJvUG9zaXRpb24oIENFTFNJVVNfTlVNQkVSX0xJTkVfUkFOR0UgKVxyXG4gICAgICBdLFxyXG5cclxuICAgICAgdW5pcXVlTnVtYmVyTGluZU9wdGlvbnNMaXN0OiBbXHJcbiAgICAgICAgeyBpbml0aWFsRGlzcGxheWVkUmFuZ2U6IEZBSFJFTkhFSVRfTlVNQkVSX0xJTkVfUkFOR0UgfSxcclxuICAgICAgICB7IGluaXRpYWxEaXNwbGF5ZWRSYW5nZTogQ0VMU0lVU19OVU1CRVJfTElORV9SQU5HRSB9XHJcbiAgICAgIF1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpIHtCb3VuZHMyfSAtIGJvdW5kcyBvZiB0aGUgbWFwIGFyZWFcclxuICAgIHRoaXMubWFwQm91bmRzID0gTUFQX0JPVU5EUztcclxuXHJcbiAgICAvLyBAcHVibGljXHJcbiAgICB0aGlzLm1vbnRoUHJvcGVydHkgPSBuZXcgTnVtYmVyUHJvcGVydHkoIDEgKTtcclxuXHJcbiAgICAvLyBAcHVibGljXHJcbiAgICB0aGlzLnRlbXBlcmF0dXJlVW5pdHNQcm9wZXJ0eSA9IG5ldyBFbnVtZXJhdGlvbkRlcHJlY2F0ZWRQcm9wZXJ0eShcclxuICAgICAgTkxJQ29uc3RhbnRzLlRFTVBFUkFUVVJFX1VOSVRTLFxyXG4gICAgICBOTElRdWVyeVBhcmFtZXRlcnMuZGVmYXVsdENlbHNpdXMgPyBOTElDb25zdGFudHMuVEVNUEVSQVRVUkVfVU5JVFMuQ0VMU0lVUyA6IE5MSUNvbnN0YW50cy5URU1QRVJBVFVSRV9VTklUUy5GQUhSRU5IRUlUXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFNwZWNpZnkgdGhlIHBvc2l0aW9uIG9mIHRoZSBib3ggdGhhdCB3aWxsIGhvbGQgdGhlIHRoZXJtb21ldGVycy5cclxuICAgIGNvbnN0IGJveFdpZHRoID0gTUFQX1dJRFRIICogMC41O1xyXG4gICAgY29uc3QgYm94SGVpZ2h0ID0gKCBTQ0VORV9CT1VORFMubWF4WSAtIE1BUF9CT1VORFMubWF4WSApICogMC40O1xyXG4gICAgY29uc3QgYm94Q2VudGVyWCA9IE1BUF9DRU5URVIueDtcclxuICAgIGNvbnN0IGJveEJvdHRvbSA9IFNDRU5FX0JPVU5EUy5tYXhZIC0gMTY7IC8vIGVtcGlyaWNhbGx5IGRldGVybWluZWQgdG8gbWF0Y2ggdXAgd2l0aCBvdGhlciBzY2VuZXNcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpIHtCb3VuZHMyfSAtIGhvbGRpbmcgYXJlYSBmb3IgdGhlIHRoZXJtb21ldGVyc1xyXG4gICAgdGhpcy50aGVybW9tZXRlckJveEJvdW5kcyA9IG5ldyBCb3VuZHMyKFxyXG4gICAgICBib3hDZW50ZXJYIC0gYm94V2lkdGggLyAyLFxyXG4gICAgICBib3hCb3R0b20gLSBib3hIZWlnaHQsXHJcbiAgICAgIGJveENlbnRlclggKyBib3hXaWR0aCAvIDIsXHJcbiAgICAgIGJveEJvdHRvbVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpIC0gdGhlIHBvaW50IGNvbnRyb2xsZXJzIHRoYXQgY2FuIGJlIG1vdmVkIGludG8gdGhlIGVsZXZhdGlvbiBzY2VuZVxyXG4gICAgdGhpcy5wZXJtYW5lbnRQb2ludENvbnRyb2xsZXJzID0gXy50aW1lcyggMywgaSA9PiBuZXcgVGVtcGVyYXR1cmVQb2ludENvbnRyb2xsZXIoXHJcbiAgICAgIHRoaXMsXHJcbiAgICAgIFRIRVJNT01FVEVSX0xBQkVMU1sgaSBdLFxyXG4gICAgICB7XHJcbiAgICAgICAgbnVtYmVyTGluZXM6IHRoaXMubnVtYmVyTGluZXMsXHJcbiAgICAgICAgbG9ja1RvTnVtYmVyTGluZTogTG9ja1RvTnVtYmVyTGluZS5ORVZFUixcclxuICAgICAgICBzY2FsZUluQm94OiAwLjVcclxuICAgICAgfVxyXG4gICAgKSApO1xyXG5cclxuICAgIC8vIFB1dCB0aGUgcGVybWFuZW50IHBvaW50IGNvbnRyb2xsZXJzIGluIHRoZWlyIHN0YXJ0aW5nIHBvc2l0aW9ucy5cclxuICAgIHRoaXMucGVybWFuZW50UG9pbnRDb250cm9sbGVycy5mb3JFYWNoKCBwb2ludENvbnRyb2xsZXIgPT4ge1xyXG4gICAgICB0aGlzLnB1dFBvaW50Q29udHJvbGxlckluQm94KCBwb2ludENvbnRyb2xsZXIgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBNb25pdG9yIGVhY2ggcG9pbnQgY29udHJvbGxlciBmb3Igd2hlbiBpdCBpcyBkcm9wcGVkIGFuZCBjaGVjayBmb3Igd2hldGhlciBhY3Rpb25zIGFyZSBuZWVkZWQuXHJcbiAgICB0aGlzLnBlcm1hbmVudFBvaW50Q29udHJvbGxlcnMuZm9yRWFjaCggcG9pbnRDb250cm9sbGVyID0+IHtcclxuICAgICAgcG9pbnRDb250cm9sbGVyLmlzRHJhZ2dpbmdQcm9wZXJ0eS5sYXp5TGluayggaXNEcmFnZ2luZyA9PiB7XHJcbiAgICAgICAgaWYgKCAhaXNEcmFnZ2luZyApIHtcclxuICAgICAgICAgIGlmICggIXBvaW50Q29udHJvbGxlci5pc092ZXJNYXBQcm9wZXJ0eS52YWx1ZSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBwb2ludCBjb250cm9sbGVyIHdhcyByZWxlYXNlZCBvdXRzaWRlIG9mIHRoZSBtYXAgYXJlYSwgc28gcHV0IGl0IGF3YXkgaW4gdGhlIGhvbGRpbmcgYm94LlxyXG4gICAgICAgICAgICB0aGlzLnB1dFBvaW50Q29udHJvbGxlckluQm94KCBwb2ludENvbnRyb2xsZXIsIHRydWUgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHBvaW50IGNvbnRyb2xsZXIgd2FzIGRyb3BwZWQgb24gdGhlIG1hcCwgcmVzb2x2ZSBhbnkgb3ZlcmxhcCB3aXRoIG90aGVyIHBvaW50IGNvbnRyb2xsZXJzLlxyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVQb2ludENvbnRyb2xsZXJPdmVybGFwKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9ICk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gV2hlbiB0aGUgbW9udGggY2hhbmdlcywgY2hlY2sgYW5kIHJlc29sdmUgYW55IG92ZXJsYXAgaW4gdGVtcGVyYXR1cmUgdmFsdWVzIHRoYXQgbWF5IGhhdmUgb2NjdXJyZWQuXHJcbiAgICB0aGlzLm1vbnRoUHJvcGVydHkubGF6eUxpbmsoICgpID0+IHtcclxuICAgICAgdGhpcy5yZXNvbHZlUG9pbnRDb250cm9sbGVyT3ZlcmxhcCgpO1xyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSB0ZW1wZXJhdHVyZSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxyXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gcG9zaXRpb24gLSBtb2RlbCBjb29yZGluYXRlcyBmb3Igd2hlcmUgdG8gZ2V0IHRoZSB0ZW1wZXJhdHVyZVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH0gLSB0aGUgdGVtcGVyYXR1cmUgaW4gZGVncmVlcyBLZWx2aW4gaWYgdGhlIHBvc2l0aW9uIGlzIG92ZXIgdGhlIG1hcCwgbnVsbCBvdGhlcndpc2VcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgZ2V0VGVtcGVyYXR1cmVBdFBvc2l0aW9uKCBwb3NpdGlvbiApIHtcclxuXHJcbiAgICAvLyBDb252ZXJ0IHRoZSBwb3NpdGlvbiBpbnRvIG5vcm1hbGl6ZWQgdmFsdWVzIGJhc2VkIG9uIHRoZSBtYXAncyBwb3NpdGlvbiBhbmQgc2l6ZS4gIFRoZXNlIHZhbHVlcyBhc3N1bWUgYSB0b3RhbFxyXG4gICAgLy8gc3BhbiBvZiAxIGluIHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBkaXJlY3Rpb25zIHdpdGggdGhlIHBvaW50ICgwLDApIGJlaW5nIGluIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC5cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRYUG9zaXRpb24gPSAoIHBvc2l0aW9uLnggLSB0aGlzLm1hcEJvdW5kcy5jZW50ZXJYICkgLyB0aGlzLm1hcEJvdW5kcy53aWR0aDtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRZUG9zaXRpb24gPSAoIHRoaXMubWFwQm91bmRzLmNlbnRlclkgLSBwb3NpdGlvbi55ICkgLyB0aGlzLm1hcEJvdW5kcy5oZWlnaHQ7XHJcblxyXG4gICAgLy8gVGVzdCBpZiB0aGUgcG9zaXRpb24gaXMgb3ZlciB0aGUgcmVjdGFuZ2xlIHRoYXQgY29udGFpbnMgdGhlIG1hcC4gIFRoaXMgZG9lcyAqbm90KiB0ZXN0IHRoZSBjb3JuZXJzIG9mIHRoZVxyXG4gICAgLy8gcmVjdGFuZ2xlIHRvIHNlZSB3aGV0aGVyIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIFJvYmluc29uIHByb2plY3Rpb24gLSB0aGF0IGhhcHBlbnMgZnVydGhlciBiZWxvdy5cclxuICAgIGlmICggbm9ybWFsaXplZFhQb3NpdGlvbiA8IC0wLjUgfHwgbm9ybWFsaXplZFhQb3NpdGlvbiA+IDAuNSB8fFxyXG4gICAgICAgICBub3JtYWxpemVkWVBvc2l0aW9uIDwgLTAuNSB8fCBub3JtYWxpemVkWVBvc2l0aW9uID4gMC41ICkge1xyXG5cclxuICAgICAgLy8gVGhlIHBvaW50IGlzIG5vdCBvdmVyIHRoZSBtYXAgcmVjdGFuZ2xlIC0gYmFpbC5cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCB0aGUgbm9ybWFsaXplZCB4IGFuZCB5IHZhbHVlcyBpbnRvIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgdmFsdWVzLlxyXG4gICAgY29uc3QgbGF0TG9uZyA9IHJldmVyc2VSb2JpbnNvblByb2plY3Rvci54eVRvTGF0TG9uZyggbm9ybWFsaXplZFhQb3NpdGlvbiwgbm9ybWFsaXplZFlQb3NpdGlvbiApO1xyXG5cclxuICAgIC8vIFJldHVybiBudWxsIGlmIHBvc2l0aW9uIGlzIG5vdCBpbiBtYXAgYm91bmRzLlxyXG4gICAgaWYgKCBsYXRMb25nLmxhdGl0dWRlID4gOTAgfHwgbGF0TG9uZy5sYXRpdHVkZSA8IC05MCB8fFxyXG4gICAgICAgICBsYXRMb25nLmxvbmdpdHVkZSA+IDE4MCB8fCBsYXRMb25nLmxvbmdpdHVkZSA8IC0xODAgKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybiB0aGUgdGVtcGVyYXR1cmUgYXQgdGhpcyBwb3NpdGlvbiBvbiB0aGUgc3VyZmFjZSBvZiB0aGUgRWFydGggZm9yIHRoZSBjdXJyZW50IG1vbnRoLlxyXG4gICAgcmV0dXJuIHRlbXBlcmF0dXJlRGF0YVNldC5nZXROZWFyU3VyZmFjZVRlbXBlcmF0dXJlKFxyXG4gICAgICB0aGlzLm1vbnRoUHJvcGVydHkudmFsdWUsXHJcbiAgICAgIGxhdExvbmcubGF0aXR1ZGUsXHJcbiAgICAgIGxhdExvbmcubG9uZ2l0dWRlXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGdldCBjZWxzaXVzTnVtYmVyTGluZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm51bWJlckxpbmVzWyBDRUxTSVVTX05VTUJFUl9MSU5FX0lOREVYIF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgZ2V0IGZhaHJlbmhlaXROdW1iZXJMaW5lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubnVtYmVyTGluZXNbIEZBSFJFTkhFSVRfTlVNQkVSX0xJTkVfSU5ERVggXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBsYWNlIHRoZSBwcm92aWRlZCBwb2ludCBjb250cm9sbGVyIGludG8gdGhlIGhvbGRpbmcgYm94LCBnZW5lcmFsbHkgZG9uZSBvbiBpbml0LCByZXNldCwgYW5kIHdoZW4gdGhlIHVzZXIgXCJwdXRzXHJcbiAgICogaXQgYXdheVwiLlxyXG4gICAqIEBwYXJhbSB7VGVtcGVyYXR1cmVQb2ludENvbnRyb2xsZXJ9IHBvaW50Q29udHJvbGxlclxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FuaW1hdGVdIC0gY29udHJvbHMgd2hldGhlciB0byBhbmltYXRlIHRoZSByZXR1cm4gdG8gdGhlIGJveCBvciBkbyBpdCBpbnN0YW50bHlcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHB1dFBvaW50Q29udHJvbGxlckluQm94KCBwb2ludENvbnRyb2xsZXIsIGFuaW1hdGUgPSBmYWxzZSApIHtcclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wZXJtYW5lbnRQb2ludENvbnRyb2xsZXJzLmluZGV4T2YoIHBvaW50Q29udHJvbGxlciApO1xyXG4gICAgY29uc3QgbnVtUG9zaXRpb25zID0gdGhpcy5wZXJtYW5lbnRQb2ludENvbnRyb2xsZXJzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBlcnJvciBjaGVja2luZ1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggaW5kZXggPj0gMCwgJ3BvaW50IGNvbnRyb2xsZXIgbm90IGZvdW5kIG9uIGxpc3QnICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KFxyXG4gICAgICAhcG9pbnRDb250cm9sbGVyLmlzQ29udHJvbGxpbmdOdW1iZXJMaW5lUG9pbnQoKSxcclxuICAgICAgJ3BvaW50IGNvbnRyb2xsZXIgc2hvdWxkIG5vdCBiZSBwdXQgYXdheSB3aGlsZSBjb250cm9sbGluZyBhIHBvaW50J1xyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy50aGVybW9tZXRlckJveEJvdW5kcy53aWR0aCAvIG51bVBvc2l0aW9ucztcclxuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgIHRoaXMudGhlcm1vbWV0ZXJCb3hCb3VuZHMubWluWCArIHNwYWNpbmcgLyAyICsgc3BhY2luZyAqIGluZGV4LFxyXG4gICAgICB0aGlzLnRoZXJtb21ldGVyQm94Qm91bmRzLmNlbnRlclkgKyAyNSAvLyBlbXBpcmljYWxseSBkZXRlcm1pbmVkIHNvIHRoYXQgdGhlcm1vbWV0ZXJzIGFyZSB2ZXJ0aWNhbGx5IGNlbnRlcmVkXHJcbiAgICApO1xyXG4gICAgcG9pbnRDb250cm9sbGVyLmdvVG9Qb3NpdGlvbiggZGVzdGluYXRpb24sIGFuaW1hdGUgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc29sdmUgYW55IHRlbXBlcmF0dXJlIG92ZXJsYXAgYmV0d2VlbiB0aGUgcG9pbnQgY29udHJvbGxlcnMuICBCZWNhdXNlIHRoZSB0ZW1wZXJhdHVyZSBpcyB0aGUgc2FtZSBhdCB0aGUgc2FtZVxyXG4gICAqIHBvc2l0aW9uLCB0aGlzIHdpbGwgYWxzbyByZXNvbHZlIGFueSBwb3NpdGlvbmFsIG92ZXJsYXAuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICByZXNvbHZlUG9pbnRDb250cm9sbGVyT3ZlcmxhcCgpIHtcclxuXHJcbiAgICAvLyBNYWtlIGEgbGlzdCBvZiBhbGwgcG9pbnQgY29udHJvbGxlciB0aGF0IGFyZSBjdXJyZW50bHkgb24gdGhlIG1hcC5cclxuICAgIGNvbnN0IHBvaW50Q29udHJvbGxlcnNPbk1hcCA9IHRoaXMucGVybWFuZW50UG9pbnRDb250cm9sbGVycy5maWx0ZXIoIHBvaW50Q29udHJvbGxlciA9PiB7XHJcbiAgICAgIHJldHVybiBwb2ludENvbnRyb2xsZXIuaXNPdmVyTWFwUHJvcGVydHkudmFsdWUgJiYgIXBvaW50Q29udHJvbGxlci5pc0RyYWdnaW5nUHJvcGVydHkudmFsdWU7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgaWYgKCBwb2ludENvbnRyb2xsZXJzT25NYXAubGVuZ3RoID49IDIgKSB7XHJcblxyXG4gICAgICAvLyBTb3J0IHRoZSBwb2ludCBjb250cm9sbGVycyBzdWNoIHRoYXQgdGhlIG1vc3QgcmVjZW50bHkgYWRkZWQgb25lcyBhcmUgdG93YXJkcyB0aGUgZnJvbnQgb2YgdGhlIGFycmF5LlxyXG4gICAgICBwb2ludENvbnRyb2xsZXJzT25NYXAuc29ydCggKCBwYzEsIHBjMiApID0+IHtcclxuICAgICAgICByZXR1cm4gcGMyLmRyb3BwZWRPbk1hcFRpbWVzdGFtcCAtIHBjMS5kcm9wcGVkT25NYXBUaW1lc3RhbXA7XHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgY29udHJvbGxlcnMsIG1vdmluZyB0aGVtIGFzIG5lY2Vzc2FyeSB0byBlbGltaW5hdGUgdGVtcGVyYXR1cmUgb3IgcG9zaXRpb24gb3ZlcmxhcC5cclxuICAgICAgXy50aW1lcyggcG9pbnRDb250cm9sbGVyc09uTWFwLmxlbmd0aCAtIDEsICgpID0+IHtcclxuXHJcbiAgICAgICAgLy8gUHVsbCB0aGUgZmlyc3QgY29udHJvbGxlciBmcm9tIHRoZSBmcm9udCBvZiB0aGUgbGlzdC5cclxuICAgICAgICBjb25zdCBwb2ludENvbnRyb2xsZXJVbmRlclRlc3QgPSBwb2ludENvbnRyb2xsZXJzT25NYXAuc3BsaWNlKCAwLCAxIClbIDAgXTtcclxuICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gcG9pbnRDb250cm9sbGVyVW5kZXJUZXN0LnBvc2l0aW9uUHJvcGVydHkudmFsdWUuY29weSgpO1xyXG4gICAgICAgIGxldCBtb3ZlQ291bnQgPSAwO1xyXG5cclxuICAgICAgICAvLyBUZXN0IGZvciBvdmVybGFwIHdpdGggYWxsIG90aGVyIHRlbXBlcmF0dXJlIHBvaW50IGNvbnRyb2xsZXJzLCBtb3ZlIGlmIGRldGVjdGVkLlxyXG4gICAgICAgIHdoaWxlICggXy5zb21lKFxyXG4gICAgICAgICAgcG9pbnRDb250cm9sbGVyc09uTWFwLFxyXG4gICAgICAgICAgcGMgPT4gcGMuY2Vsc2l1c1RlbXBlcmF0dXJlUHJvcGVydHkudmFsdWUgPT09IHBvaW50Q29udHJvbGxlclVuZGVyVGVzdC5jZWxzaXVzVGVtcGVyYXR1cmVQcm9wZXJ0eS52YWx1ZSApXHJcbiAgICAgICAgICApIHtcclxuXHJcbiAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLCBtb3ZlIHRoZSBwb2ludCBjb250cm9sbGVyIHRvd2FyZHMgdGhlIGEgcmVhc29uYWJseSBsYXJnZSBhcmVhIG9mIHRoZSBtYXAuXHJcbiAgICAgICAgICBjb25zdCB4TW92ZW1lbnQgPSAoIHN0YXJ0UG9zaXRpb24ueCA+IE1BUF9DRU5URVIueCA/IC0xIDogMSApICogKCBtb3ZlQ291bnQgKyAxICkgKiBYX01PVkVfQU1PVU5UO1xyXG4gICAgICAgICAgY29uc3QgeU1vdmVtZW50ID0gKCBzdGFydFBvc2l0aW9uLnkgPiBNQVBfQ0VOVEVSLnkgPyAtMSA6IDEgKSAqICggbW92ZUNvdW50ICsgMSApICogWV9NT1ZFX0FNT1VOVDtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5ldyBwcm9wb3NlZCBwb3NpdGlvbi5cclxuICAgICAgICAgIGNvbnN0IG5ld1Byb3Bvc2VkUG9zaXRpb24gPSBwb2ludENvbnRyb2xsZXJVbmRlclRlc3QucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS5wbHVzWFkoIHhNb3ZlbWVudCwgeU1vdmVtZW50ICk7XHJcblxyXG4gICAgICAgICAgLy8gVGhlcmUgY291bGQgYmUgc29tZSByYXJlIGNhc2VzIHdoZXJlIGEgcG9pbnQgY29udHJvbGxlciBtb3ZlcyBhbGwgdGhlIHdheSBhY3Jvc3MgdGhlIG1hcCBhbmQgZG9lc24ndCBmaW5kXHJcbiAgICAgICAgICAvLyBhIHBvc2l0aW9uIHdpdGggYSBub24tb3ZlcmxhcHBpbmcgdGVtcGVyYXR1cmUuICBGb3IgaW5zdGFuY2UsIGlmIGFsbCB0aGUgdGVtcGVyYXR1cmUgdmFsdWVzIG9uIHRoZSBtYXBcclxuICAgICAgICAgIC8vIGFyZSB0aGUgc2FtZSwgdGhpcyBjb3VsZCBoYXBwZW4uICBTaW5jZSB0aGlzIHNlZW1zIHZlcnkgdW5saWtlbHksIHdlIHRlc3QgZm9yIGl0IGFuZCBhc3NlcnQgaWYgaXRcclxuICAgICAgICAgIC8vIGhhcHBlbnMuXHJcbiAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KFxyXG4gICAgICAgICAgICB0aGlzLmdldFRlbXBlcmF0dXJlQXRQb3NpdGlvbiggbmV3UHJvcG9zZWRQb3NpdGlvbiApICE9PSBudWxsLFxyXG4gICAgICAgICAgICAndW5hYmxlIHRvIGZpbmQgcG9zaXRpb24gd2l0aCBkaWZmZXJlbnQgdGVtcGVyYXR1cmUgdmFsdWUnXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIE1vdmUgdGhlIHBvaW50IGNvbnRyb2xsZXIuXHJcbiAgICAgICAgICBwb2ludENvbnRyb2xsZXJVbmRlclRlc3QucG9zaXRpb25Qcm9wZXJ0eS5zZXQoIG5ld1Byb3Bvc2VkUG9zaXRpb24gKTtcclxuXHJcbiAgICAgICAgICBtb3ZlQ291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICByZXNldCgpIHtcclxuXHJcbiAgICAvLyBPbmx5IHJlc2V0IHRoZSB0ZW1wZXJhdHVyZSB1bml0cyBvbiBhIGZ1bGwgcmVzZXQsIG5vdCBhIHNjZW5lIHJlc2V0LCBzZWVcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9udW1iZXItbGluZS1pbnRlZ2Vycy9pc3N1ZXMvODYuXHJcbiAgICB0aGlzLnRlbXBlcmF0dXJlVW5pdHNQcm9wZXJ0eS5yZXNldCgpO1xyXG4gICAgdGhpcy5udW1iZXJMaW5lcy5mb3JFYWNoKCBubCA9PiB7IG5sLnJlc2V0KCk7IH0gKTtcclxuXHJcbiAgICBzdXBlci5yZXNldCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdG9yZSBpbml0aWFsIHN0YXRlLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICByZXNldFNjZW5lKCkge1xyXG5cclxuICAgIHRoaXMubW9udGhQcm9wZXJ0eS5yZXNldCgpO1xyXG4gICAgdGhpcy5udW1iZXJMaW5lcy5mb3JFYWNoKCBubCA9PiB7IG5sLnJlbW92ZUFsbFBvaW50cygpOyB9ICk7XHJcblxyXG4gICAgLy8gUHV0IHRoZSBwb2ludCBjb250cm9sbGVycyBiYWNrIGludG8gdGhlaXIgc3RhcnRpbmcgcG9zaXRpb25zLlxyXG4gICAgdGhpcy5wZXJtYW5lbnRQb2ludENvbnRyb2xsZXJzLmZvckVhY2goIHBvaW50Q29udHJvbGxlciA9PiB7XHJcbiAgICAgIHBvaW50Q29udHJvbGxlci5yZXNldCgpO1xyXG4gICAgICB0aGlzLnB1dFBvaW50Q29udHJvbGxlckluQm94KCBwb2ludENvbnRyb2xsZXIgKTtcclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHN0YXRpYyBmaWVsZHNcclxuVGVtcGVyYXR1cmVTY2VuZU1vZGVsLkNFTFNJVVNfTlVNQkVSX0xJTkVfSU5ERVggPSBDRUxTSVVTX05VTUJFUl9MSU5FX0lOREVYO1xyXG5UZW1wZXJhdHVyZVNjZW5lTW9kZWwuRkFIUkVOSEVJVF9OVU1CRVJfTElORV9JTkRFWCA9IEZBSFJFTkhFSVRfTlVNQkVSX0xJTkVfSU5ERVg7XHJcblxyXG4vKipcclxuICogaGVscGVyIGZ1bmN0aW9uIHRvIGF2b2lkIGNvZGUgZHVwbGljYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGdldE51bWJlckxpbmVaZXJvUG9zaXRpb24oIHJhbmdlICkge1xyXG4gIHJldHVybiBuZXcgVmVjdG9yMihcclxuICAgIC8vIGhhbGZ3YXkgYmV0d2VlbiB0aGUgbGVmdCBlZGdlIG9mIHRoZSBzY2VuZSBhbmQgdGhlIGxlZnQgZWRnZSBvZiB0aGUgbWFwXHJcbiAgICAoIFNDRU5FX0JPVU5EUy5taW5YICsgTUFQX0JPVU5EUy5taW5YICkgLyAyLFxyXG5cclxuICAgIC8vIGNlbnRlcnMgbnVtYmVyIGxpbmUgdmVydGljYWxseSB3aXRoaW4gc2NlbmVcclxuICAgIDAuNSAqIFNDRU5FX0JPVU5EUy5oZWlnaHQgKyBOVU1CRVJfTElORV9IRUlHSFQgKiAoIDAuNSArIHJhbmdlLm1pbiAvIHJhbmdlLmdldExlbmd0aCgpIClcclxuICApO1xyXG59XHJcblxyXG5udW1iZXJMaW5lSW50ZWdlcnMucmVnaXN0ZXIoICdUZW1wZXJhdHVyZVNjZW5lTW9kZWwnLCBUZW1wZXJhdHVyZVNjZW5lTW9kZWwgKTtcclxuZXhwb3J0IGRlZmF1bHQgVGVtcGVyYXR1cmVTY2VuZU1vZGVsO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLDZCQUE2QixNQUFNLHNEQUFzRDtBQUNoRyxPQUFPQyxjQUFjLE1BQU0sdUNBQXVDO0FBQ2xFLE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsS0FBSyxNQUFNLDZCQUE2QjtBQUMvQyxPQUFPQyxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLGdCQUFnQixNQUFNLG9FQUFvRTtBQUNqRyxPQUFPQyxXQUFXLE1BQU0seUNBQXlDO0FBQ2pFLE9BQU9DLFlBQVksTUFBTSw4QkFBOEI7QUFDdkQsT0FBT0Msa0JBQWtCLE1BQU0sb0NBQW9DO0FBQ25FLE9BQU9DLGtCQUFrQixNQUFNLDZCQUE2QjtBQUM1RCxPQUFPQyx5QkFBeUIsTUFBTSxvQ0FBb0M7QUFDMUUsT0FBT0Msd0JBQXdCLE1BQU0sK0JBQStCO0FBQ3BFLE9BQU9DLFVBQVUsTUFBTSxpQkFBaUI7QUFDeEMsT0FBT0Msa0JBQWtCLE1BQU0seUJBQXlCO0FBQ3hELE9BQU9DLDBCQUEwQixNQUFNLGlDQUFpQztBQUV4RSxNQUFNQyx1QkFBdUIsR0FBR0wseUJBQXlCLENBQUNNLGlCQUFpQjtBQUMzRSxNQUFNQyx1QkFBdUIsR0FBR1AseUJBQXlCLENBQUNRLGlCQUFpQjtBQUMzRSxNQUFNQyx1QkFB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