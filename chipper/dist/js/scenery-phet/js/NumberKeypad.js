// Copyright 2015-2022, University of Colorado Boulder

/**
 * A scenery node that looks like a number key pad and allows the user to enter a number. The entered number is not
 * displayed by this node - it is intended to be used in conjunction with a separate display of some sort.
 *
 * @author John Blanco
 * @author Andrey Zelenkov (MLearner)
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Property from '../../axon/js/Property.js';
import deprecationWarning from '../../phet-core/js/deprecationWarning.js';
import InstanceRegistry from '../../phet-core/js/documentation/InstanceRegistry.js';
import merge from '../../phet-core/js/merge.js';
import { HBox, Node, Text, VBox } from '../../scenery/js/imports.js';
import RectangularPushButton from '../../sun/js/buttons/RectangularPushButton.js';
import BackspaceIcon from './BackspaceIcon.js';
import PhetFont from './PhetFont.js';
import sceneryPhet from './sceneryPhet.js';

// string
const DECIMAL_POINT = '.'; //TODO localize, https://github.com/phetsims/scenery-phet/issues/333

/**
 * @deprecated - This keypad has been replaced by a more flexible and general version.
 * While there are no plans to go back and replace existing usages, new implementations should use Keypad.js.
 * See https://github.com/phetsims/scenery-phet/issues/283 for the history of this. -jbphet, Aug 2017
 */
class NumberKeypad extends Node {
  /**
   * @param {Object} [options]
   * @deprecated
   */
  constructor(options) {
    assert && deprecationWarning('NumberKeypad is deprecated, please use Keypad instead');
    options = merge({
      buttonFont: new PhetFont({
        size: 20
      }),
      minButtonWidth: 35,
      minButtonHeight: 35,
      decimalPointKey: false,
      xSpacing: 10,
      ySpacing: 10,
      keyColor: 'white',
      valueStringProperty: new Property(''),
      // {function(string, string)} validates a key press, see example and documentation in validateMaxDigits
      validateKey: NumberKeypad.validateMaxDigits({
        maxDigits: 8
      })
    }, options);
    super();

    // @public (read-only) - sequence of key values entered by the user
    this.valueStringProperty = options.valueStringProperty;

    // @private - when true, the next key press will clear valueStringProperty
    this._clearOnNextKeyPress = false;

    // options for keys
    const keyOptions = {
      minWidth: options.minButtonWidth,
      minHeight: options.minButtonHeight,
      baseColor: options.keyColor,
      font: options.buttonFont
    };

    // create the backspace key
    const backspaceIcon = new BackspaceIcon();
    backspaceIcon.scale(Math.min(options.minButtonWidth / backspaceIcon.width * 0.7, options.minButtonHeight * 0.65 / backspaceIcon.height));
    const backspaceKey = new RectangularPushButton({
      content: backspaceIcon,
      minWidth: keyOptions.minWidth,
      minHeight: keyOptions.minHeight,
      xMargin: 1,
      baseColor: keyOptions.baseColor,
      listener: () => {
        if (this.valueStringProperty.value.length > 0) {
          // The backspace key ignores and resets the clearOnNextKeyPress flag. The rationale is that if a user has
          // entered an incorrect value and wants to correct it by using the backspace, then it should work like
          // the backspace always does instead of clearing the display.
          this._clearOnNextKeyPress = false;

          // Remove the last character
          this.valueStringProperty.set(this.valueStringProperty.get().slice(0, -1));
        }
      }
    });

    /**
     * Called when a key is pressed.
     * @param {string} keyString - string associated with the key that was pressed
     */
    const keyCallback = keyString => {
      // If set to clear the value on the next key press, clear the existing string.
      if (this._clearOnNextKeyPress) {
        this.valueStringProperty.value = '';
        this._clearOnNextKeyPress = false;
      }

      // process the keyString
      this.valueStringProperty.value = options.validateKey(keyString, this.valueStringProperty.value);
    };

    // create the bottom row of keys, which can vary based on options
    const bottomRowChildren = [];
    if (options.decimalPointKey) {
      // add a decimal point key plus a normal width zero key
      bottomRowChildren.push(createKey(DECIMAL_POINT, keyCallback, keyOptions));
      bottomRowChildren.push(createKey('0', keyCallback, keyOptions));
    } else {
      // add a double-width zero key instead of the decimal point key
      const doubleRowButtonKeySpec = merge({}, keyOptions, {
        minWidth: keyOptions.minWidth * 2 + options.xSpacing
      });
      bottomRowChildren.push(createKey('0', keyCallback, doubleRowButtonKeySpec));
    }
    bottomRowChildren.push(backspaceKey);

    // add the rest of the keys
    const vBox = new VBox({
      spacing: options.ySpacing,
      children: [new HBox({
        spacing: options.xSpacing,
        children: [createKey('7', keyCallback, keyOptions), createKey('8', keyCallback, keyOptions), createKey('9', keyCallback, keyOptions)]
      }), new HBox({
        spacing: options.xSpacing,
        children: [createKey('4', keyCallback, keyOptions), createKey('5', keyCallback, keyOptions), createKey('6', keyCallback, keyOptions)]
      }), new HBox({
        spacing: options.xSpacing,
        children: [createKey('1', keyCallback, keyOptions), createKey('2', keyCallback, keyOptions), createKey('3', keyCallback, keyOptions)]
      }), new HBox({
        spacing: options.xSpacing,
        children: bottomRowChildren
      })]
    });
    assert && assert(!options.children, 'NumberKeyPad sets children');
    options.children = [vBox];
    this.mutate(options);

    // support for binder documentation, stripped out in builds and only runs when ?binder is specified
    assert && phet.chipper.queryParameters.binder && InstanceRegistry.registerDataURL('scenery-phet', 'NumberKeypad', this);
  }
  get clearOnNextKeyPress() {
    return this.getClearOnNextKeyPress();
  }
  set clearOnNextKeyPress(value) {
    this.setClearOnNextKeyPress(value);
  }

  /**
   * Creates a validation function that constrains the value to a maximum number of digits, with 1 leading zero.
   * @param {Object} [options]
   * @returns {function(string, string)}
   * @public
   */
  static validateMaxDigits(options) {
    options = merge({
      maxDigits: 8 // {number} the maximum number of digits (numbers)
    }, options);
    assert && assert(options.maxDigits > 0, `invalid maxDigits: ${options.maxDigits}`);

    /**
     * Creates the new string that results from pressing a key.
     * @param {string} keyString - string associated with the key that was pressed
     * @param {string} valueString - string that corresponds to the sequence of keys that have been pressed
     * @returns {string} the result
     */
    return function (keyString, valueString) {
      const hasDecimalPoint = valueString.indexOf(DECIMAL_POINT) !== -1;
      const numberOfDigits = hasDecimalPoint ? valueString.length - 1 : valueString.length;
      let newValueString;
      if (valueString === '0' && keyString === '0') {
        // ignore multiple leading zeros
        newValueString = valueString;
      } else if (valueString === '0' && keyString !== '0' && keyString !== DECIMAL_POINT) {
        // replace a leading 0 that's not followed by a decimal point with this key
        newValueString = keyString;
      } else if (keyString !== DECIMAL_POINT && numberOfDigits < options.maxDigits) {
        // constrain to maxDigits
        newValueString = valueString + keyString;
      } else if (keyString === DECIMAL_POINT && valueString.indexOf(DECIMAL_POINT) === -1) {
        // allow one decimal point
        newValueString = valueString + keyString;
      } else {
        // ignore keyString
        newValueString = valueString;
      }
      return newValueString;
    };
  }

  /**
   * Clear anything that has been accumulated in the valueStringProperty field.
   * @public
   */
  clear() {
    this.valueStringProperty.value = '';
  }

  /**
   * Determines whether pressing a key (except for the backspace) will clear the existing value.
   * @param {boolean} clearOnNextKeyPress
   * @public
   */
  setClearOnNextKeyPress(clearOnNextKeyPress) {
    this._clearOnNextKeyPress = clearOnNextKeyPress;
  }

  /**
   * Will pressing a key (except for the backspace point) clear the existing value?
   * @returns {boolean}
   * @public
   */
  getClearOnNextKeyPress() {
    return this._clearOnNextKeyPress;
  }
}

/**
 * Creates a key for the keypad.
 * @param {string} keyString - string that appears on the key
 * @param {function(string)} callback - called when the key is pressed
 * @param {Object} keyOptions - see RectangularPushButton.options
 * @returns {Node}
 */
function createKey(keyString, callback, keyOptions) {
  return new RectangularPushButton({
    content: new Text(keyString, {
      font: keyOptions.font
    }),
    baseColor: keyOptions.baseColor,
    minWidth: keyOptions.minWidth,
    minHeight: keyOptions.minHeight,
    xMargin: 5,
    yMargin: 5,
    listener: function () {
      callback(keyString);
    }
  });
}

// @public
NumberKeypad.DECIMAL_POINT = DECIMAL_POINT;
sceneryPhet.register('NumberKeypad', NumberKeypad);
export default NumberKeypad;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQcm9wZXJ0eSIsImRlcHJlY2F0aW9uV2FybmluZyIsIkluc3RhbmNlUmVnaXN0cnkiLCJtZXJnZSIsIkhCb3giLCJOb2RlIiwiVGV4dCIsIlZCb3giLCJSZWN0YW5ndWxhclB1c2hCdXR0b24iLCJCYWNrc3BhY2VJY29uIiwiUGhldEZvbnQiLCJzY2VuZXJ5UGhldCIsIkRFQ0lNQUxfUE9JTlQiLCJOdW1iZXJLZXlwYWQiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJhc3NlcnQiLCJidXR0b25Gb250Iiwic2l6ZSIsIm1pbkJ1dHRvbldpZHRoIiwibWluQnV0dG9uSGVpZ2h0IiwiZGVjaW1hbFBvaW50S2V5IiwieFNwYWNpbmciLCJ5U3BhY2luZyIsImtleUNvbG9yIiwidmFsdWVTdHJpbmdQcm9wZXJ0eSIsInZhbGlkYXRlS2V5IiwidmFsaWRhdGVNYXhEaWdpdHMiLCJtYXhEaWdpdHMiLCJfY2xlYXJPbk5leHRLZXlQcmVzcyIsImtleU9wdGlvbnMiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsImJhc2VDb2xvciIsImZvbnQiLCJiYWNrc3BhY2VJY29uIiwic2NhbGUiLCJNYXRoIiwibWluIiwid2lkdGgiLCJoZWlnaHQiLCJiYWNrc3BhY2VLZXkiLCJjb250ZW50IiwieE1hcmdpbiIsImxpc3RlbmVyIiwidmFsdWUiLCJsZW5ndGgiLCJzZXQiLCJnZXQiLCJzbGljZSIsImtleUNhbGxiYWNrIiwia2V5U3RyaW5nIiwiYm90dG9tUm93Q2hpbGRyZW4iLCJwdXNoIiwiY3JlYXRlS2V5IiwiZG91YmxlUm93QnV0dG9uS2V5U3BlYyIsInZCb3giLCJzcGFjaW5nIiwiY2hpbGRyZW4iLCJtdXRhdGUiLCJwaGV0IiwiY2hpcHBlciIsInF1ZXJ5UGFyYW1ldGVycyIsImJpbmRlciIsInJlZ2lzdGVyRGF0YVVSTCIsImNsZWFyT25OZXh0S2V5UHJlc3MiLCJnZXRDbGVhck9uTmV4dEtleVByZXNzIiwic2V0Q2xlYXJPbk5leHRLZXlQcmVzcyIsInZhbHVlU3RyaW5nIiwiaGFzRGVjaW1hbFBvaW50IiwiaW5kZXhPZiIsIm51bWJlck9mRGlnaXRzIiwibmV3VmFsdWVTdHJpbmciLCJjbGVhciIsImNhbGxiYWNrIiwieU1hcmdpbiIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiTnVtYmVyS2V5cGFkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgc2NlbmVyeSBub2RlIHRoYXQgbG9va3MgbGlrZSBhIG51bWJlciBrZXkgcGFkIGFuZCBhbGxvd3MgdGhlIHVzZXIgdG8gZW50ZXIgYSBudW1iZXIuIFRoZSBlbnRlcmVkIG51bWJlciBpcyBub3RcclxuICogZGlzcGxheWVkIGJ5IHRoaXMgbm9kZSAtIGl0IGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhIHNlcGFyYXRlIGRpc3BsYXkgb2Ygc29tZSBzb3J0LlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvXHJcbiAqIEBhdXRob3IgQW5kcmV5IFplbGVua292IChNTGVhcm5lcilcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgUHJvcGVydHkgZnJvbSAnLi4vLi4vYXhvbi9qcy9Qcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBkZXByZWNhdGlvbldhcm5pbmcgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL2RlcHJlY2F0aW9uV2FybmluZy5qcyc7XHJcbmltcG9ydCBJbnN0YW5jZVJlZ2lzdHJ5IGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9kb2N1bWVudGF0aW9uL0luc3RhbmNlUmVnaXN0cnkuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL21lcmdlLmpzJztcclxuaW1wb3J0IHsgSEJveCwgTm9kZSwgVGV4dCwgVkJveCB9IGZyb20gJy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBSZWN0YW5ndWxhclB1c2hCdXR0b24gZnJvbSAnLi4vLi4vc3VuL2pzL2J1dHRvbnMvUmVjdGFuZ3VsYXJQdXNoQnV0dG9uLmpzJztcclxuaW1wb3J0IEJhY2tzcGFjZUljb24gZnJvbSAnLi9CYWNrc3BhY2VJY29uLmpzJztcclxuaW1wb3J0IFBoZXRGb250IGZyb20gJy4vUGhldEZvbnQuanMnO1xyXG5pbXBvcnQgc2NlbmVyeVBoZXQgZnJvbSAnLi9zY2VuZXJ5UGhldC5qcyc7XHJcblxyXG4vLyBzdHJpbmdcclxuY29uc3QgREVDSU1BTF9QT0lOVCA9ICcuJzsgLy9UT0RPIGxvY2FsaXplLCBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc2NlbmVyeS1waGV0L2lzc3Vlcy8zMzNcclxuXHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCAtIFRoaXMga2V5cGFkIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IGEgbW9yZSBmbGV4aWJsZSBhbmQgZ2VuZXJhbCB2ZXJzaW9uLlxyXG4gKiBXaGlsZSB0aGVyZSBhcmUgbm8gcGxhbnMgdG8gZ28gYmFjayBhbmQgcmVwbGFjZSBleGlzdGluZyB1c2FnZXMsIG5ldyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHVzZSBLZXlwYWQuanMuXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc2NlbmVyeS1waGV0L2lzc3Vlcy8yODMgZm9yIHRoZSBoaXN0b3J5IG9mIHRoaXMuIC1qYnBoZXQsIEF1ZyAyMDE3XHJcbiAqL1xyXG5jbGFzcyBOdW1iZXJLZXlwYWQgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqIEBkZXByZWNhdGVkXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIG9wdGlvbnMgKSB7XHJcbiAgICBhc3NlcnQgJiYgZGVwcmVjYXRpb25XYXJuaW5nKCAnTnVtYmVyS2V5cGFkIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgS2V5cGFkIGluc3RlYWQnICk7XHJcblxyXG4gICAgb3B0aW9ucyA9IG1lcmdlKCB7XHJcbiAgICAgIGJ1dHRvbkZvbnQ6IG5ldyBQaGV0Rm9udCggeyBzaXplOiAyMCB9ICksXHJcbiAgICAgIG1pbkJ1dHRvbldpZHRoOiAzNSxcclxuICAgICAgbWluQnV0dG9uSGVpZ2h0OiAzNSxcclxuICAgICAgZGVjaW1hbFBvaW50S2V5OiBmYWxzZSxcclxuICAgICAgeFNwYWNpbmc6IDEwLFxyXG4gICAgICB5U3BhY2luZzogMTAsXHJcbiAgICAgIGtleUNvbG9yOiAnd2hpdGUnLFxyXG4gICAgICB2YWx1ZVN0cmluZ1Byb3BlcnR5OiBuZXcgUHJvcGVydHkoICcnICksXHJcblxyXG4gICAgICAvLyB7ZnVuY3Rpb24oc3RyaW5nLCBzdHJpbmcpfSB2YWxpZGF0ZXMgYSBrZXkgcHJlc3MsIHNlZSBleGFtcGxlIGFuZCBkb2N1bWVudGF0aW9uIGluIHZhbGlkYXRlTWF4RGlnaXRzXHJcbiAgICAgIHZhbGlkYXRlS2V5OiBOdW1iZXJLZXlwYWQudmFsaWRhdGVNYXhEaWdpdHMoIHsgbWF4RGlnaXRzOiA4IH0gKVxyXG4gICAgfSwgb3B0aW9ucyApO1xyXG5cclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyAocmVhZC1vbmx5KSAtIHNlcXVlbmNlIG9mIGtleSB2YWx1ZXMgZW50ZXJlZCBieSB0aGUgdXNlclxyXG4gICAgdGhpcy52YWx1ZVN0cmluZ1Byb3BlcnR5ID0gb3B0aW9ucy52YWx1ZVN0cmluZ1Byb3BlcnR5O1xyXG5cclxuICAgIC8vIEBwcml2YXRlIC0gd2hlbiB0cnVlLCB0aGUgbmV4dCBrZXkgcHJlc3Mgd2lsbCBjbGVhciB2YWx1ZVN0cmluZ1Byb3BlcnR5XHJcbiAgICB0aGlzLl9jbGVhck9uTmV4dEtleVByZXNzID0gZmFsc2U7XHJcblxyXG4gICAgLy8gb3B0aW9ucyBmb3Iga2V5c1xyXG4gICAgY29uc3Qga2V5T3B0aW9ucyA9IHtcclxuICAgICAgbWluV2lkdGg6IG9wdGlvbnMubWluQnV0dG9uV2lkdGgsXHJcbiAgICAgIG1pbkhlaWdodDogb3B0aW9ucy5taW5CdXR0b25IZWlnaHQsXHJcbiAgICAgIGJhc2VDb2xvcjogb3B0aW9ucy5rZXlDb2xvcixcclxuICAgICAgZm9udDogb3B0aW9ucy5idXR0b25Gb250XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgYmFja3NwYWNlIGtleVxyXG4gICAgY29uc3QgYmFja3NwYWNlSWNvbiA9IG5ldyBCYWNrc3BhY2VJY29uKCk7XHJcbiAgICBiYWNrc3BhY2VJY29uLnNjYWxlKCBNYXRoLm1pbiggb3B0aW9ucy5taW5CdXR0b25XaWR0aCAvIGJhY2tzcGFjZUljb24ud2lkdGggKiAwLjcsICggb3B0aW9ucy5taW5CdXR0b25IZWlnaHQgKiAwLjY1ICkgLyBiYWNrc3BhY2VJY29uLmhlaWdodCApICk7XHJcbiAgICBjb25zdCBiYWNrc3BhY2VLZXkgPSBuZXcgUmVjdGFuZ3VsYXJQdXNoQnV0dG9uKCB7XHJcbiAgICAgIGNvbnRlbnQ6IGJhY2tzcGFjZUljb24sXHJcbiAgICAgIG1pbldpZHRoOiBrZXlPcHRpb25zLm1pbldpZHRoLFxyXG4gICAgICBtaW5IZWlnaHQ6IGtleU9wdGlvbnMubWluSGVpZ2h0LFxyXG4gICAgICB4TWFyZ2luOiAxLFxyXG4gICAgICBiYXNlQ29sb3I6IGtleU9wdGlvbnMuYmFzZUNvbG9yLFxyXG4gICAgICBsaXN0ZW5lcjogKCkgPT4ge1xyXG4gICAgICAgIGlmICggdGhpcy52YWx1ZVN0cmluZ1Byb3BlcnR5LnZhbHVlLmxlbmd0aCA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIGJhY2tzcGFjZSBrZXkgaWdub3JlcyBhbmQgcmVzZXRzIHRoZSBjbGVhck9uTmV4dEtleVByZXNzIGZsYWcuIFRoZSByYXRpb25hbGUgaXMgdGhhdCBpZiBhIHVzZXIgaGFzXHJcbiAgICAgICAgICAvLyBlbnRlcmVkIGFuIGluY29ycmVjdCB2YWx1ZSBhbmQgd2FudHMgdG8gY29ycmVjdCBpdCBieSB1c2luZyB0aGUgYmFja3NwYWNlLCB0aGVuIGl0IHNob3VsZCB3b3JrIGxpa2VcclxuICAgICAgICAgIC8vIHRoZSBiYWNrc3BhY2UgYWx3YXlzIGRvZXMgaW5zdGVhZCBvZiBjbGVhcmluZyB0aGUgZGlzcGxheS5cclxuICAgICAgICAgIHRoaXMuX2NsZWFyT25OZXh0S2V5UHJlc3MgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgY2hhcmFjdGVyXHJcbiAgICAgICAgICB0aGlzLnZhbHVlU3RyaW5nUHJvcGVydHkuc2V0KCB0aGlzLnZhbHVlU3RyaW5nUHJvcGVydHkuZ2V0KCkuc2xpY2UoIDAsIC0xICkgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIGEga2V5IGlzIHByZXNzZWQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5U3RyaW5nIC0gc3RyaW5nIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IHRoYXQgd2FzIHByZXNzZWRcclxuICAgICAqL1xyXG4gICAgY29uc3Qga2V5Q2FsbGJhY2sgPSBrZXlTdHJpbmcgPT4ge1xyXG5cclxuICAgICAgLy8gSWYgc2V0IHRvIGNsZWFyIHRoZSB2YWx1ZSBvbiB0aGUgbmV4dCBrZXkgcHJlc3MsIGNsZWFyIHRoZSBleGlzdGluZyBzdHJpbmcuXHJcbiAgICAgIGlmICggdGhpcy5fY2xlYXJPbk5leHRLZXlQcmVzcyApIHtcclxuICAgICAgICB0aGlzLnZhbHVlU3RyaW5nUHJvcGVydHkudmFsdWUgPSAnJztcclxuICAgICAgICB0aGlzLl9jbGVhck9uTmV4dEtleVByZXNzID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHByb2Nlc3MgdGhlIGtleVN0cmluZ1xyXG4gICAgICB0aGlzLnZhbHVlU3RyaW5nUHJvcGVydHkudmFsdWUgPSBvcHRpb25zLnZhbGlkYXRlS2V5KCBrZXlTdHJpbmcsIHRoaXMudmFsdWVTdHJpbmdQcm9wZXJ0eS52YWx1ZSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBjcmVhdGUgdGhlIGJvdHRvbSByb3cgb2Yga2V5cywgd2hpY2ggY2FuIHZhcnkgYmFzZWQgb24gb3B0aW9uc1xyXG4gICAgY29uc3QgYm90dG9tUm93Q2hpbGRyZW4gPSBbXTtcclxuICAgIGlmICggb3B0aW9ucy5kZWNpbWFsUG9pbnRLZXkgKSB7XHJcblxyXG4gICAgICAvLyBhZGQgYSBkZWNpbWFsIHBvaW50IGtleSBwbHVzIGEgbm9ybWFsIHdpZHRoIHplcm8ga2V5XHJcbiAgICAgIGJvdHRvbVJvd0NoaWxkcmVuLnB1c2goIGNyZWF0ZUtleSggREVDSU1BTF9QT0lOVCwga2V5Q2FsbGJhY2ssIGtleU9wdGlvbnMgKSApO1xyXG4gICAgICBib3R0b21Sb3dDaGlsZHJlbi5wdXNoKCBjcmVhdGVLZXkoICcwJywga2V5Q2FsbGJhY2ssIGtleU9wdGlvbnMgKSApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcblxyXG4gICAgICAvLyBhZGQgYSBkb3VibGUtd2lkdGggemVybyBrZXkgaW5zdGVhZCBvZiB0aGUgZGVjaW1hbCBwb2ludCBrZXlcclxuICAgICAgY29uc3QgZG91YmxlUm93QnV0dG9uS2V5U3BlYyA9IG1lcmdlKCB7fSwga2V5T3B0aW9ucywgeyBtaW5XaWR0aDoga2V5T3B0aW9ucy5taW5XaWR0aCAqIDIgKyBvcHRpb25zLnhTcGFjaW5nIH0gKTtcclxuICAgICAgYm90dG9tUm93Q2hpbGRyZW4ucHVzaCggY3JlYXRlS2V5KCAnMCcsIGtleUNhbGxiYWNrLCBkb3VibGVSb3dCdXR0b25LZXlTcGVjICkgKTtcclxuICAgIH1cclxuICAgIGJvdHRvbVJvd0NoaWxkcmVuLnB1c2goIGJhY2tzcGFjZUtleSApO1xyXG5cclxuICAgIC8vIGFkZCB0aGUgcmVzdCBvZiB0aGUga2V5c1xyXG4gICAgY29uc3QgdkJveCA9IG5ldyBWQm94KCB7XHJcbiAgICAgIHNwYWNpbmc6IG9wdGlvbnMueVNwYWNpbmcsXHJcbiAgICAgIGNoaWxkcmVuOiBbXHJcbiAgICAgICAgbmV3IEhCb3goIHtcclxuICAgICAgICAgIHNwYWNpbmc6IG9wdGlvbnMueFNwYWNpbmcsXHJcbiAgICAgICAgICBjaGlsZHJlbjogW1xyXG4gICAgICAgICAgICBjcmVhdGVLZXkoICc3Jywga2V5Q2FsbGJhY2ssIGtleU9wdGlvbnMgKSxcclxuICAgICAgICAgICAgY3JlYXRlS2V5KCAnOCcsIGtleUNhbGxiYWNrLCBrZXlPcHRpb25zICksXHJcbiAgICAgICAgICAgIGNyZWF0ZUtleSggJzknLCBrZXlDYWxsYmFjaywga2V5T3B0aW9ucyApXHJcbiAgICAgICAgICBdXHJcbiAgICAgICAgfSApLFxyXG4gICAgICAgIG5ldyBIQm94KCB7XHJcbiAgICAgICAgICBzcGFjaW5nOiBvcHRpb25zLnhTcGFjaW5nLFxyXG4gICAgICAgICAgY2hpbGRyZW46IFtcclxuICAgICAgICAgICAgY3JlYXRlS2V5KCAnNCcsIGtleUNhbGxiYWNrLCBrZXlPcHRpb25zICksXHJcbiAgICAgICAgICAgIGNyZWF0ZUtleSggJzUnLCBrZXlDYWxsYmFjaywga2V5T3B0aW9ucyApLFxyXG4gICAgICAgICAgICBjcmVhdGVLZXkoICc2Jywga2V5Q2FsbGJhY2ssIGtleU9wdGlvbnMgKVxyXG4gICAgICAgICAgXVxyXG4gICAgICAgIH0gKSxcclxuICAgICAgICBuZXcgSEJveCgge1xyXG4gICAgICAgICAgc3BhY2luZzogb3B0aW9ucy54U3BhY2luZyxcclxuICAgICAgICAgIGNoaWxkcmVuOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZUtleSggJzEnLCBrZXlDYWxsYmFjaywga2V5T3B0aW9ucyApLFxyXG4gICAgICAgICAgICBjcmVhdGVLZXkoICcyJywga2V5Q2FsbGJhY2ssIGtleU9wdGlvbnMgKSxcclxuICAgICAgICAgICAgY3JlYXRlS2V5KCAnMycsIGtleUNhbGxiYWNrLCBrZXlPcHRpb25zIClcclxuICAgICAgICAgIF1cclxuICAgICAgICB9ICksXHJcbiAgICAgICAgbmV3IEhCb3goIHtcclxuICAgICAgICAgIHNwYWNpbmc6IG9wdGlvbnMueFNwYWNpbmcsXHJcbiAgICAgICAgICBjaGlsZHJlbjogYm90dG9tUm93Q2hpbGRyZW5cclxuICAgICAgICB9IClcclxuICAgICAgXVxyXG4gICAgfSApO1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICFvcHRpb25zLmNoaWxkcmVuLCAnTnVtYmVyS2V5UGFkIHNldHMgY2hpbGRyZW4nICk7XHJcbiAgICBvcHRpb25zLmNoaWxkcmVuID0gWyB2Qm94IF07XHJcblxyXG4gICAgdGhpcy5tdXRhdGUoIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBzdXBwb3J0IGZvciBiaW5kZXIgZG9jdW1lbnRhdGlvbiwgc3RyaXBwZWQgb3V0IGluIGJ1aWxkcyBhbmQgb25seSBydW5zIHdoZW4gP2JpbmRlciBpcyBzcGVjaWZpZWRcclxuICAgIGFzc2VydCAmJiBwaGV0LmNoaXBwZXIucXVlcnlQYXJhbWV0ZXJzLmJpbmRlciAmJiBJbnN0YW5jZVJlZ2lzdHJ5LnJlZ2lzdGVyRGF0YVVSTCggJ3NjZW5lcnktcGhldCcsICdOdW1iZXJLZXlwYWQnLCB0aGlzICk7XHJcbiAgfVxyXG5cclxuICBnZXQgY2xlYXJPbk5leHRLZXlQcmVzcygpIHsgcmV0dXJuIHRoaXMuZ2V0Q2xlYXJPbk5leHRLZXlQcmVzcygpOyB9XHJcblxyXG4gIHNldCBjbGVhck9uTmV4dEtleVByZXNzKCB2YWx1ZSApIHsgdGhpcy5zZXRDbGVhck9uTmV4dEtleVByZXNzKCB2YWx1ZSApOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHRoYXQgY29uc3RyYWlucyB0aGUgdmFsdWUgdG8gYSBtYXhpbXVtIG51bWJlciBvZiBkaWdpdHMsIHdpdGggMSBsZWFkaW5nIHplcm8uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZyl9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHN0YXRpYyB2YWxpZGF0ZU1heERpZ2l0cyggb3B0aW9ucyApIHtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuICAgICAgbWF4RGlnaXRzOiA4IC8vIHtudW1iZXJ9IHRoZSBtYXhpbXVtIG51bWJlciBvZiBkaWdpdHMgKG51bWJlcnMpXHJcbiAgICB9LCBvcHRpb25zICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLm1heERpZ2l0cyA+IDAsIGBpbnZhbGlkIG1heERpZ2l0czogJHtvcHRpb25zLm1heERpZ2l0c31gICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBuZXcgc3RyaW5nIHRoYXQgcmVzdWx0cyBmcm9tIHByZXNzaW5nIGEga2V5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVN0cmluZyAtIHN0cmluZyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSB0aGF0IHdhcyBwcmVzc2VkXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVTdHJpbmcgLSBzdHJpbmcgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgc2VxdWVuY2Ugb2Yga2V5cyB0aGF0IGhhdmUgYmVlbiBwcmVzc2VkXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcmVzdWx0XHJcbiAgICAgKi9cclxuICAgIHJldHVybiBmdW5jdGlvbigga2V5U3RyaW5nLCB2YWx1ZVN0cmluZyApIHtcclxuXHJcbiAgICAgIGNvbnN0IGhhc0RlY2ltYWxQb2ludCA9IHZhbHVlU3RyaW5nLmluZGV4T2YoIERFQ0lNQUxfUE9JTlQgKSAhPT0gLTE7XHJcbiAgICAgIGNvbnN0IG51bWJlck9mRGlnaXRzID0gaGFzRGVjaW1hbFBvaW50ID8gdmFsdWVTdHJpbmcubGVuZ3RoIC0gMSA6IHZhbHVlU3RyaW5nLmxlbmd0aDtcclxuXHJcbiAgICAgIGxldCBuZXdWYWx1ZVN0cmluZztcclxuICAgICAgaWYgKCB2YWx1ZVN0cmluZyA9PT0gJzAnICYmIGtleVN0cmluZyA9PT0gJzAnICkge1xyXG5cclxuICAgICAgICAvLyBpZ25vcmUgbXVsdGlwbGUgbGVhZGluZyB6ZXJvc1xyXG4gICAgICAgIG5ld1ZhbHVlU3RyaW5nID0gdmFsdWVTdHJpbmc7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoIHZhbHVlU3RyaW5nID09PSAnMCcgJiYga2V5U3RyaW5nICE9PSAnMCcgJiYga2V5U3RyaW5nICE9PSBERUNJTUFMX1BPSU5UICkge1xyXG5cclxuICAgICAgICAvLyByZXBsYWNlIGEgbGVhZGluZyAwIHRoYXQncyBub3QgZm9sbG93ZWQgYnkgYSBkZWNpbWFsIHBvaW50IHdpdGggdGhpcyBrZXlcclxuICAgICAgICBuZXdWYWx1ZVN0cmluZyA9IGtleVN0cmluZztcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICgga2V5U3RyaW5nICE9PSBERUNJTUFMX1BPSU5UICYmIG51bWJlck9mRGlnaXRzIDwgb3B0aW9ucy5tYXhEaWdpdHMgKSB7XHJcblxyXG4gICAgICAgIC8vIGNvbnN0cmFpbiB0byBtYXhEaWdpdHNcclxuICAgICAgICBuZXdWYWx1ZVN0cmluZyA9IHZhbHVlU3RyaW5nICsga2V5U3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCBrZXlTdHJpbmcgPT09IERFQ0lNQUxfUE9JTlQgJiYgdmFsdWVTdHJpbmcuaW5kZXhPZiggREVDSU1BTF9QT0lOVCApID09PSAtMSApIHtcclxuXHJcbiAgICAgICAgLy8gYWxsb3cgb25lIGRlY2ltYWwgcG9pbnRcclxuICAgICAgICBuZXdWYWx1ZVN0cmluZyA9IHZhbHVlU3RyaW5nICsga2V5U3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBpZ25vcmUga2V5U3RyaW5nXHJcbiAgICAgICAgbmV3VmFsdWVTdHJpbmcgPSB2YWx1ZVN0cmluZztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5ld1ZhbHVlU3RyaW5nO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFyIGFueXRoaW5nIHRoYXQgaGFzIGJlZW4gYWNjdW11bGF0ZWQgaW4gdGhlIHZhbHVlU3RyaW5nUHJvcGVydHkgZmllbGQuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy52YWx1ZVN0cmluZ1Byb3BlcnR5LnZhbHVlID0gJyc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgcHJlc3NpbmcgYSBrZXkgKGV4Y2VwdCBmb3IgdGhlIGJhY2tzcGFjZSkgd2lsbCBjbGVhciB0aGUgZXhpc3RpbmcgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBjbGVhck9uTmV4dEtleVByZXNzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHNldENsZWFyT25OZXh0S2V5UHJlc3MoIGNsZWFyT25OZXh0S2V5UHJlc3MgKSB7XHJcbiAgICB0aGlzLl9jbGVhck9uTmV4dEtleVByZXNzID0gY2xlYXJPbk5leHRLZXlQcmVzcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdpbGwgcHJlc3NpbmcgYSBrZXkgKGV4Y2VwdCBmb3IgdGhlIGJhY2tzcGFjZSBwb2ludCkgY2xlYXIgdGhlIGV4aXN0aW5nIHZhbHVlP1xyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBnZXRDbGVhck9uTmV4dEtleVByZXNzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NsZWFyT25OZXh0S2V5UHJlc3M7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGtleSBmb3IgdGhlIGtleXBhZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleVN0cmluZyAtIHN0cmluZyB0aGF0IGFwcGVhcnMgb24gdGhlIGtleVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyl9IGNhbGxiYWNrIC0gY2FsbGVkIHdoZW4gdGhlIGtleSBpcyBwcmVzc2VkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXlPcHRpb25zIC0gc2VlIFJlY3Rhbmd1bGFyUHVzaEJ1dHRvbi5vcHRpb25zXHJcbiAqIEByZXR1cm5zIHtOb2RlfVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlS2V5KCBrZXlTdHJpbmcsIGNhbGxiYWNrLCBrZXlPcHRpb25zICkge1xyXG4gIHJldHVybiBuZXcgUmVjdGFuZ3VsYXJQdXNoQnV0dG9uKCB7XHJcbiAgICBjb250ZW50OiBuZXcgVGV4dCgga2V5U3RyaW5nLCB7IGZvbnQ6IGtleU9wdGlvbnMuZm9udCB9ICksXHJcbiAgICBiYXNlQ29sb3I6IGtleU9wdGlvbnMuYmFzZUNvbG9yLFxyXG4gICAgbWluV2lkdGg6IGtleU9wdGlvbnMubWluV2lkdGgsXHJcbiAgICBtaW5IZWlnaHQ6IGtleU9wdGlvbnMubWluSGVpZ2h0LFxyXG4gICAgeE1hcmdpbjogNSxcclxuICAgIHlNYXJnaW46IDUsXHJcbiAgICBsaXN0ZW5lcjogZnVuY3Rpb24oKSB7IGNhbGxiYWNrKCBrZXlTdHJpbmcgKTsgfVxyXG4gIH0gKTtcclxufVxyXG5cclxuLy8gQHB1YmxpY1xyXG5OdW1iZXJLZXlwYWQuREVDSU1BTF9QT0lOVCA9IERFQ0lNQUxfUE9JTlQ7XHJcblxyXG5zY2VuZXJ5UGhldC5yZWdpc3RlciggJ051bWJlcktleXBhZCcsIE51bWJlcktleXBhZCApO1xyXG5leHBvcnQgZGVmYXVsdCBOdW1iZXJLZXlwYWQ7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFFBQVEsTUFBTSwyQkFBMkI7QUFDaEQsT0FBT0Msa0JBQWtCLE1BQU0sMENBQTBDO0FBQ3pFLE9BQU9DLGdCQUFnQixNQUFNLHNEQUFzRDtBQUNuRixPQUFPQyxLQUFLLE1BQU0sNkJBQTZCO0FBQy9DLFNBQVNDLElBQUksRUFB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