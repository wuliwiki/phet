// Copyright 2013-2022, University of Colorado Boulder

/**
 * RulerNode is the visual representation of a ruler.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import { Shape } from '../../kite/js/imports.js';
import InstanceRegistry from '../../phet-core/js/documentation/InstanceRegistry.js';
import optionize from '../../phet-core/js/optionize.js';
import { Node, Path, Rectangle, Text } from '../../scenery/js/imports.js';
import Tandem from '../../tandem/js/Tandem.js';
import PhetFont from './PhetFont.js';
import sceneryPhet from './sceneryPhet.js';

// constants
const DEFAULT_FONT = new PhetFont(18);
class RulerNode extends Node {
  static DEFAULT_FILL = 'rgb(236, 225, 113)';

  /**
   * @param rulerWidth  distance between left-most and right-most tick, insets will be added to this
   * @param rulerHeight
   * @param majorTickWidth
   * @param majorTickLabels
   * @param units
   * @param providedOptions
   */
  constructor(rulerWidth, rulerHeight, majorTickWidth, majorTickLabels, units, providedOptions) {
    // default options
    const options = optionize()({
      // SelfOptions
      backgroundFill: RulerNode.DEFAULT_FILL,
      backgroundStroke: 'black',
      backgroundLineWidth: 1,
      insetsWidth: 14,
      majorTickFont: DEFAULT_FONT,
      majorTickHeight: 0.4 * rulerHeight / 2,
      majorTickStroke: 'black',
      majorTickLineWidth: 1,
      minorTickFont: DEFAULT_FONT,
      minorTickHeight: 0.2 * rulerHeight / 2,
      minorTickStroke: 'black',
      minorTickLineWidth: 1,
      minorTicksPerMajorTick: 0,
      unitsFont: DEFAULT_FONT,
      unitsMajorTickIndex: 0,
      unitsSpacing: 3,
      tickMarksOnTop: true,
      tickMarksOnBottom: true,
      // NodeOptions
      tandem: Tandem.REQUIRED,
      tandemNameSuffix: 'RulerNode'
    }, providedOptions);

    // things you're likely to mess up, add more as needed
    assert && assert(Math.floor(rulerWidth / majorTickWidth) + 1 === majorTickLabels.length); // do we have enough major tick labels?
    assert && assert(options.unitsMajorTickIndex < majorTickLabels.length);
    assert && assert(options.majorTickHeight < rulerHeight / 2);
    assert && assert(options.minorTickHeight < rulerHeight / 2);
    super();

    // background
    const backgroundNode = new Rectangle(0, 0, rulerWidth + 2 * options.insetsWidth, rulerHeight, {
      fill: options.backgroundFill,
      stroke: options.backgroundStroke,
      lineWidth: options.backgroundLineWidth
    });
    this.addChild(backgroundNode);

    // Lay out tick marks from left to right
    const minorTickWidth = majorTickWidth / (options.minorTicksPerMajorTick + 1);
    const numberOfTicks = Math.floor(rulerWidth / minorTickWidth) + 1;
    let x = options.insetsWidth;
    let majorTickIndex = 0;

    // Minimize number of nodes by using one path for each type of tick line
    const majorTickLinesShape = new Shape();
    const minorTickLinesShape = new Shape();

    // Units label, which is positioned and (if necessary) scaled later
    const unitsLabelText = new Text(units, {
      font: options.unitsFont,
      pickable: false,
      tandem: options.tandem.createTandem('unitsLabelText')
    });
    let unitsLabelMaxWidth = Number.POSITIVE_INFINITY;
    this.addChild(unitsLabelText);
    for (let i = 0; i < numberOfTicks; i++) {
      if (i % (options.minorTicksPerMajorTick + 1) === 0) {
        // assumes that the first (leftmost) tick is a major tick

        // Major tick

        // Create the tick label regardless of whether we add it, since it's required to layout the units label
        const majorTickLabel = majorTickLabels[majorTickIndex];
        const majorTickLabelNode = new Text(majorTickLabel, {
          font: options.majorTickFont,
          centerX: x,
          centerY: backgroundNode.centerY,
          pickable: false
        });

        // Only add a major tick at leftmost or rightmost end if the insetsWidth is nonzero
        if (options.insetsWidth !== 0 || i !== 0 && i !== numberOfTicks - 1) {
          // label, only added as a child if it's non-empty (and non-null)
          if (majorTickLabel) {
            this.addChild(majorTickLabelNode);
          }

          // line
          if (options.tickMarksOnTop) {
            majorTickLinesShape.moveTo(x, 0).lineTo(x, options.majorTickHeight);
          }
          if (options.tickMarksOnBottom) {
            majorTickLinesShape.moveTo(x, rulerHeight - options.majorTickHeight).lineTo(x, rulerHeight);
          }
        }

        // Position the units label
        if (majorTickIndex === options.unitsMajorTickIndex) {
          unitsLabelText.left = majorTickLabelNode.right + options.unitsSpacing;
          unitsLabelText.y = majorTickLabelNode.y;
        } else if (majorTickIndex > options.unitsMajorTickIndex && unitsLabelMaxWidth === Number.POSITIVE_INFINITY && majorTickLabelNode.width > 0) {
          // make sure the units label fits between the tick mark labels
          unitsLabelMaxWidth = majorTickLabelNode.left - options.unitsSpacing - unitsLabelText.left;
          assert && assert(unitsLabelMaxWidth > 0, 'space for units label is negative or zero');
          unitsLabelText.maxWidth = unitsLabelMaxWidth;
        }
        majorTickIndex++;
      } else {
        // Minor tick
        // Only add a minor tick at leftmost or rightmost end if the insetsWidth is nonzero
        if (options.insetsWidth !== 0 || i !== 0 && i !== numberOfTicks - 1) {
          if (options.tickMarksOnTop) {
            minorTickLinesShape.moveTo(x, 0).lineTo(x, options.minorTickHeight);
          }
          if (options.tickMarksOnBottom) {
            minorTickLinesShape.moveTo(x, rulerHeight - options.minorTickHeight).lineTo(x, rulerHeight);
          }
        }
      }
      x += minorTickWidth;
    }

    // Handle the case where the units label extends off the edge of the ruler.  This is kind of a corner case, but was
    // seen when testing long strings on Pendulum Lab.
    if (unitsLabelText.bounds.maxX > backgroundNode.bounds.maxX - options.unitsSpacing) {
      unitsLabelMaxWidth = backgroundNode.bounds.maxX - options.unitsSpacing - unitsLabelText.x;
      unitsLabelText.scale(unitsLabelMaxWidth / unitsLabelText.width);
    }

    // Major tick lines
    this.addChild(new Path(majorTickLinesShape, {
      stroke: options.majorTickStroke,
      lineWidth: options.majorTickLineWidth,
      pickable: false
    }));

    // Minor tick lines
    this.addChild(new Path(minorTickLinesShape, {
      stroke: options.minorTickStroke,
      lineWidth: options.minorTickLineWidth,
      pickable: false
    }));
    this.mutate(options);
    this.disposeRulerNode = () => {
      unitsLabelText.dispose(); // because may be linked to a translated StringProperty
    };

    // support for binder documentation, stripped out in builds and only runs when ?binder is specified
    assert && phet.chipper.queryParameters.binder && InstanceRegistry.registerDataURL('scenery-phet', 'RulerNode', this);
  }
  dispose() {
    this.disposeRulerNode();
    super.dispose();
  }
}
sceneryPhet.register('RulerNode', RulerNode);
export default RulerNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTaGFwZSIsIkluc3RhbmNlUmVnaXN0cnkiLCJvcHRpb25pemUiLCJOb2RlIiwiUGF0aCIsIlJlY3RhbmdsZSIsIlRleHQiLCJUYW5kZW0iLCJQaGV0Rm9udCIsInNjZW5lcnlQaGV0IiwiREVGQVVMVF9GT05UIiwiUnVsZXJOb2RlIiwiREVGQVVMVF9GSUxMIiwiY29uc3RydWN0b3IiLCJydWxlcldpZHRoIiwicnVsZXJIZWlnaHQiLCJtYWpvclRpY2tXaWR0aCIsIm1ham9yVGlja0xhYmVscyIsInVuaXRzIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsImJhY2tncm91bmRGaWxsIiwiYmFja2dyb3VuZFN0cm9rZSIsImJhY2tncm91bmRMaW5lV2lkdGgiLCJpbnNldHNXaWR0aCIsIm1ham9yVGlja0ZvbnQiLCJtYWpvclRpY2tIZWlnaHQiLCJtYWpvclRpY2tTdHJva2UiLCJtYWpvclRpY2tMaW5lV2lkdGgiLCJtaW5vclRpY2tGb250IiwibWlub3JUaWNrSGVpZ2h0IiwibWlub3JUaWNrU3Ryb2tlIiwibWlub3JUaWNrTGluZVdpZHRoIiwibWlub3JUaWNrc1Blck1ham9yVGljayIsInVuaXRzRm9udCIsInVuaXRzTWFqb3JUaWNrSW5kZXgiLCJ1bml0c1NwYWNpbmciLCJ0aWNrTWFya3NPblRvcCIsInRpY2tNYXJrc09uQm90dG9tIiwidGFuZGVtIiwiUkVRVUlSRUQiLCJ0YW5kZW1OYW1lU3VmZml4IiwiYXNzZXJ0IiwiTWF0aCIsImZsb29yIiwibGVuZ3RoIiwiYmFja2dyb3VuZE5vZGUiLCJmaWxsIiwic3Ryb2tlIiwibGluZVdpZHRoIiwiYWRkQ2hpbGQiLCJtaW5vclRpY2tXaWR0aCIsIm51bWJlck9mVGlja3MiLCJ4IiwibWFqb3JUaWNrSW5kZXgiLCJtYWpvclRpY2tMaW5lc1NoYXBlIiwibWlub3JUaWNrTGluZXNTaGFwZSIsInVuaXRzTGFiZWxUZXh0IiwiZm9udCIsInBpY2thYmxlIiwiY3JlYXRlVGFuZGVtIiwidW5pdHNMYWJlbE1heFdpZHRoIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJpIiwibWFqb3JUaWNrTGFiZWwiLCJtYWpvclRpY2tMYWJlbE5vZGUiLCJjZW50ZXJYIiwiY2VudGVyWSIsIm1vdmVUbyIsImxpbmVUbyIsImxlZnQiLCJyaWdodCIsInkiLCJ3aWR0aCIsIm1heFdpZHRoIiwiYm91bmRzIiwibWF4WCIsInNjYWxlIiwibXV0YXRlIiwiZGlzcG9zZVJ1bGVyTm9kZSIsImRpc3Bvc2UiLCJwaGV0IiwiY2hpcHBlciIsInF1ZXJ5UGFyYW1ldGVycyIsImJpbmRlciIsInJlZ2lzdGVyRGF0YVVSTCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiUnVsZXJOb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDEzLTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFJ1bGVyTm9kZSBpcyB0aGUgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgcnVsZXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqL1xyXG5cclxuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBJbnN0YW5jZVJlZ2lzdHJ5IGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9kb2N1bWVudGF0aW9uL0luc3RhbmNlUmVnaXN0cnkuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgeyBGb250LCBOb2RlLCBOb2RlT3B0aW9ucywgUGF0aCwgUmVjdGFuZ2xlLCBUQ29sb3IsIFRleHQgfSBmcm9tICcuLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgVGFuZGVtIGZyb20gJy4uLy4uL3RhbmRlbS9qcy9UYW5kZW0uanMnO1xyXG5pbXBvcnQgUGhldEZvbnQgZnJvbSAnLi9QaGV0Rm9udC5qcyc7XHJcbmltcG9ydCBzY2VuZXJ5UGhldCBmcm9tICcuL3NjZW5lcnlQaGV0LmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBERUZBVUxUX0ZPTlQgPSBuZXcgUGhldEZvbnQoIDE4ICk7XHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0ge1xyXG5cclxuICAvLyBib2R5IG9mIHRoZSBydWxlclxyXG4gIGJhY2tncm91bmRGaWxsPzogVENvbG9yO1xyXG4gIGJhY2tncm91bmRTdHJva2U/OiBUQ29sb3I7XHJcbiAgYmFja2dyb3VuZExpbmVXaWR0aD86IG51bWJlcjtcclxuICBpbnNldHNXaWR0aD86IG51bWJlcjsgLy8gc3BhY2UgYmV0d2VlbiB0aGUgZW5kcyBvZiB0aGUgcnVsZXIgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCB0aWNrIG1hcmtzXHJcblxyXG4gIC8vIG1ham9yIHRpY2sgb3B0aW9uc1xyXG4gIG1ham9yVGlja0ZvbnQ/OiBGb250O1xyXG4gIG1ham9yVGlja0hlaWdodD86IG51bWJlcjtcclxuICBtYWpvclRpY2tTdHJva2U/OiBUQ29sb3I7XHJcbiAgbWFqb3JUaWNrTGluZVdpZHRoPzogbnVtYmVyO1xyXG5cclxuICAvLyBtaW5vciB0aWNrIG9wdGlvbnNcclxuICBtaW5vclRpY2tGb250PzogRm9udDtcclxuICBtaW5vclRpY2tIZWlnaHQ/OiBudW1iZXI7XHJcbiAgbWlub3JUaWNrU3Ryb2tlPzogVENvbG9yO1xyXG4gIG1pbm9yVGlja0xpbmVXaWR0aD86IG51bWJlcjtcclxuICBtaW5vclRpY2tzUGVyTWFqb3JUaWNrPzogbnVtYmVyO1xyXG5cclxuICAvLyB1bml0cyBvcHRpb25zXHJcbiAgdW5pdHNGb250PzogRm9udDtcclxuICB1bml0c01ham9yVGlja0luZGV4PzogbnVtYmVyOyAvLyB1bml0cyB3aWxsIGJlIHBsYWNlZCB0byB0aGUgcmlnaHQgb2YgdGhpcyBtYWpvciB0aWNrXHJcbiAgdW5pdHNTcGFjaW5nPzogbnVtYmVyOyAvLyBob3Jpem9udGFsIHNwYWNlIGJldHdlZW4gdGhlIHRpY2sgbGFiZWwgYW5kIHRoZSB1bml0c1xyXG5cclxuICAvLyBhcHBlYXJhbmNlIG9wdGlvbnNcclxuICB0aWNrTWFya3NPblRvcD86IGJvb2xlYW47XHJcbiAgdGlja01hcmtzT25Cb3R0b20/OiBib29sZWFuO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgUnVsZXJOb2RlT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgTm9kZU9wdGlvbnM7XHJcblxyXG5jbGFzcyBSdWxlck5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgcHJpdmF0ZSByZWFkb25seSBkaXNwb3NlUnVsZXJOb2RlOiAoKSA9PiB2b2lkO1xyXG5cclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfRklMTCA9ICdyZ2IoMjM2LCAyMjUsIDExMyknO1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gcnVsZXJXaWR0aCAgZGlzdGFuY2UgYmV0d2VlbiBsZWZ0LW1vc3QgYW5kIHJpZ2h0LW1vc3QgdGljaywgaW5zZXRzIHdpbGwgYmUgYWRkZWQgdG8gdGhpc1xyXG4gICAqIEBwYXJhbSBydWxlckhlaWdodFxyXG4gICAqIEBwYXJhbSBtYWpvclRpY2tXaWR0aFxyXG4gICAqIEBwYXJhbSBtYWpvclRpY2tMYWJlbHNcclxuICAgKiBAcGFyYW0gdW5pdHNcclxuICAgKiBAcGFyYW0gcHJvdmlkZWRPcHRpb25zXHJcbiAgICovXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBydWxlcldpZHRoOiBudW1iZXIsIHJ1bGVySGVpZ2h0OiBudW1iZXIsIG1ham9yVGlja1dpZHRoOiBudW1iZXIsIG1ham9yVGlja0xhYmVsczogc3RyaW5nW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICB1bml0czogc3RyaW5nIHwgVFJlYWRPbmx5UHJvcGVydHk8c3RyaW5nPiwgcHJvdmlkZWRPcHRpb25zPzogUnVsZXJOb2RlT3B0aW9ucyApIHtcclxuXHJcbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8UnVsZXJOb2RlT3B0aW9ucywgU2VsZk9wdGlvbnMsIE5vZGVPcHRpb25zPigpKCB7XHJcblxyXG4gICAgICAvLyBTZWxmT3B0aW9uc1xyXG4gICAgICBiYWNrZ3JvdW5kRmlsbDogUnVsZXJOb2RlLkRFRkFVTFRfRklMTCxcclxuICAgICAgYmFja2dyb3VuZFN0cm9rZTogJ2JsYWNrJyxcclxuICAgICAgYmFja2dyb3VuZExpbmVXaWR0aDogMSxcclxuICAgICAgaW5zZXRzV2lkdGg6IDE0LFxyXG4gICAgICBtYWpvclRpY2tGb250OiBERUZBVUxUX0ZPTlQsXHJcbiAgICAgIG1ham9yVGlja0hlaWdodDogKCAwLjQgKiBydWxlckhlaWdodCApIC8gMixcclxuICAgICAgbWFqb3JUaWNrU3Ryb2tlOiAnYmxhY2snLFxyXG4gICAgICBtYWpvclRpY2tMaW5lV2lkdGg6IDEsXHJcbiAgICAgIG1pbm9yVGlja0ZvbnQ6IERFRkFVTFRfRk9OVCxcclxuICAgICAgbWlub3JUaWNrSGVpZ2h0OiAoIDAuMiAqIHJ1bGVySGVpZ2h0ICkgLyAyLFxyXG4gICAgICBtaW5vclRpY2tTdHJva2U6ICdibGFjaycsXHJcbiAgICAgIG1pbm9yVGlja0xpbmVXaWR0aDogMSxcclxuICAgICAgbWlub3JUaWNrc1Blck1ham9yVGljazogMCxcclxuICAgICAgdW5pdHNGb250OiBERUZBVUxUX0ZPTlQsXHJcbiAgICAgIHVuaXRzTWFqb3JUaWNrSW5kZXg6IDAsXHJcbiAgICAgIHVuaXRzU3BhY2luZzogMyxcclxuICAgICAgdGlja01hcmtzT25Ub3A6IHRydWUsXHJcbiAgICAgIHRpY2tNYXJrc09uQm90dG9tOiB0cnVlLFxyXG5cclxuICAgICAgLy8gTm9kZU9wdGlvbnNcclxuICAgICAgdGFuZGVtOiBUYW5kZW0uUkVRVUlSRUQsXHJcbiAgICAgIHRhbmRlbU5hbWVTdWZmaXg6ICdSdWxlck5vZGUnXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyB0aGluZ3MgeW91J3JlIGxpa2VseSB0byBtZXNzIHVwLCBhZGQgbW9yZSBhcyBuZWVkZWRcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIE1hdGguZmxvb3IoIHJ1bGVyV2lkdGggLyBtYWpvclRpY2tXaWR0aCApICsgMSA9PT0gbWFqb3JUaWNrTGFiZWxzLmxlbmd0aCApOyAvLyBkbyB3ZSBoYXZlIGVub3VnaCBtYWpvciB0aWNrIGxhYmVscz9cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG9wdGlvbnMudW5pdHNNYWpvclRpY2tJbmRleCA8IG1ham9yVGlja0xhYmVscy5sZW5ndGggKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG9wdGlvbnMubWFqb3JUaWNrSGVpZ2h0IDwgcnVsZXJIZWlnaHQgLyAyICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvcHRpb25zLm1pbm9yVGlja0hlaWdodCA8IHJ1bGVySGVpZ2h0IC8gMiApO1xyXG5cclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLy8gYmFja2dyb3VuZFxyXG4gICAgY29uc3QgYmFja2dyb3VuZE5vZGUgPSBuZXcgUmVjdGFuZ2xlKCAwLCAwLCBydWxlcldpZHRoICsgKCAyICogb3B0aW9ucy5pbnNldHNXaWR0aCApLCBydWxlckhlaWdodCwge1xyXG4gICAgICBmaWxsOiBvcHRpb25zLmJhY2tncm91bmRGaWxsLFxyXG4gICAgICBzdHJva2U6IG9wdGlvbnMuYmFja2dyb3VuZFN0cm9rZSxcclxuICAgICAgbGluZVdpZHRoOiBvcHRpb25zLmJhY2tncm91bmRMaW5lV2lkdGhcclxuICAgIH0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIGJhY2tncm91bmROb2RlICk7XHJcblxyXG4gICAgLy8gTGF5IG91dCB0aWNrIG1hcmtzIGZyb20gbGVmdCB0byByaWdodFxyXG4gICAgY29uc3QgbWlub3JUaWNrV2lkdGggPSBtYWpvclRpY2tXaWR0aCAvICggb3B0aW9ucy5taW5vclRpY2tzUGVyTWFqb3JUaWNrICsgMSApO1xyXG4gICAgY29uc3QgbnVtYmVyT2ZUaWNrcyA9IE1hdGguZmxvb3IoIHJ1bGVyV2lkdGggLyBtaW5vclRpY2tXaWR0aCApICsgMTtcclxuICAgIGxldCB4ID0gb3B0aW9ucy5pbnNldHNXaWR0aDtcclxuICAgIGxldCBtYWpvclRpY2tJbmRleCA9IDA7XHJcblxyXG4gICAgLy8gTWluaW1pemUgbnVtYmVyIG9mIG5vZGVzIGJ5IHVzaW5nIG9uZSBwYXRoIGZvciBlYWNoIHR5cGUgb2YgdGljayBsaW5lXHJcbiAgICBjb25zdCBtYWpvclRpY2tMaW5lc1NoYXBlID0gbmV3IFNoYXBlKCk7XHJcbiAgICBjb25zdCBtaW5vclRpY2tMaW5lc1NoYXBlID0gbmV3IFNoYXBlKCk7XHJcblxyXG4gICAgLy8gVW5pdHMgbGFiZWwsIHdoaWNoIGlzIHBvc2l0aW9uZWQgYW5kIChpZiBuZWNlc3NhcnkpIHNjYWxlZCBsYXRlclxyXG4gICAgY29uc3QgdW5pdHNMYWJlbFRleHQgPSBuZXcgVGV4dCggdW5pdHMsIHtcclxuICAgICAgZm9udDogb3B0aW9ucy51bml0c0ZvbnQsXHJcbiAgICAgIHBpY2thYmxlOiBmYWxzZSxcclxuICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICd1bml0c0xhYmVsVGV4dCcgKVxyXG4gICAgfSApO1xyXG4gICAgbGV0IHVuaXRzTGFiZWxNYXhXaWR0aCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIHVuaXRzTGFiZWxUZXh0ICk7XHJcblxyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUaWNrczsgaSsrICkge1xyXG5cclxuICAgICAgaWYgKCBpICUgKCBvcHRpb25zLm1pbm9yVGlja3NQZXJNYWpvclRpY2sgKyAxICkgPT09IDAgKSB7ICAvLyBhc3N1bWVzIHRoYXQgdGhlIGZpcnN0IChsZWZ0bW9zdCkgdGljayBpcyBhIG1ham9yIHRpY2tcclxuXHJcbiAgICAgICAgLy8gTWFqb3IgdGlja1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIHRpY2sgbGFiZWwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlIGFkZCBpdCwgc2luY2UgaXQncyByZXF1aXJlZCB0byBsYXlvdXQgdGhlIHVuaXRzIGxhYmVsXHJcbiAgICAgICAgY29uc3QgbWFqb3JUaWNrTGFiZWwgPSBtYWpvclRpY2tMYWJlbHNbIG1ham9yVGlja0luZGV4IF07XHJcbiAgICAgICAgY29uc3QgbWFqb3JUaWNrTGFiZWxOb2RlID0gbmV3IFRleHQoIG1ham9yVGlja0xhYmVsLCB7XHJcbiAgICAgICAgICBmb250OiBvcHRpb25zLm1ham9yVGlja0ZvbnQsXHJcbiAgICAgICAgICBjZW50ZXJYOiB4LFxyXG4gICAgICAgICAgY2VudGVyWTogYmFja2dyb3VuZE5vZGUuY2VudGVyWSxcclxuICAgICAgICAgIHBpY2thYmxlOiBmYWxzZVxyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgLy8gT25seSBhZGQgYSBtYWpvciB0aWNrIGF0IGxlZnRtb3N0IG9yIHJpZ2h0bW9zdCBlbmQgaWYgdGhlIGluc2V0c1dpZHRoIGlzIG5vbnplcm9cclxuICAgICAgICBpZiAoIG9wdGlvbnMuaW5zZXRzV2lkdGggIT09IDAgfHwgKCBpICE9PSAwICYmIGkgIT09IG51bWJlck9mVGlja3MgLSAxICkgKSB7XHJcblxyXG4gICAgICAgICAgLy8gbGFiZWwsIG9ubHkgYWRkZWQgYXMgYSBjaGlsZCBpZiBpdCdzIG5vbi1lbXB0eSAoYW5kIG5vbi1udWxsKVxyXG4gICAgICAgICAgaWYgKCBtYWpvclRpY2tMYWJlbCApIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZCggbWFqb3JUaWNrTGFiZWxOb2RlICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gbGluZVxyXG4gICAgICAgICAgaWYgKCBvcHRpb25zLnRpY2tNYXJrc09uVG9wICkge1xyXG4gICAgICAgICAgICBtYWpvclRpY2tMaW5lc1NoYXBlLm1vdmVUbyggeCwgMCApLmxpbmVUbyggeCwgb3B0aW9ucy5tYWpvclRpY2tIZWlnaHQgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICggb3B0aW9ucy50aWNrTWFya3NPbkJvdHRvbSApIHtcclxuICAgICAgICAgICAgbWFqb3JUaWNrTGluZXNTaGFwZS5tb3ZlVG8oIHgsIHJ1bGVySGVpZ2h0IC0gb3B0aW9ucy5tYWpvclRpY2tIZWlnaHQgKS5saW5lVG8oIHgsIHJ1bGVySGVpZ2h0ICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdW5pdHMgbGFiZWxcclxuICAgICAgICBpZiAoIG1ham9yVGlja0luZGV4ID09PSBvcHRpb25zLnVuaXRzTWFqb3JUaWNrSW5kZXggKSB7XHJcbiAgICAgICAgICB1bml0c0xhYmVsVGV4dC5sZWZ0ID0gbWFqb3JUaWNrTGFiZWxOb2RlLnJpZ2h0ICsgb3B0aW9ucy51bml0c1NwYWNpbmc7XHJcbiAgICAgICAgICB1bml0c0xhYmVsVGV4dC55ID0gbWFqb3JUaWNrTGFiZWxOb2RlLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCBtYWpvclRpY2tJbmRleCA+IG9wdGlvbnMudW5pdHNNYWpvclRpY2tJbmRleCAmJiB1bml0c0xhYmVsTWF4V2lkdGggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJiBtYWpvclRpY2tMYWJlbE5vZGUud2lkdGggPiAwICkge1xyXG5cclxuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgdW5pdHMgbGFiZWwgZml0cyBiZXR3ZWVuIHRoZSB0aWNrIG1hcmsgbGFiZWxzXHJcbiAgICAgICAgICB1bml0c0xhYmVsTWF4V2lkdGggPSBtYWpvclRpY2tMYWJlbE5vZGUubGVmdCAtIG9wdGlvbnMudW5pdHNTcGFjaW5nIC0gdW5pdHNMYWJlbFRleHQubGVmdDtcclxuICAgICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHVuaXRzTGFiZWxNYXhXaWR0aCA+IDAsICdzcGFjZSBmb3IgdW5pdHMgbGFiZWwgaXMgbmVnYXRpdmUgb3IgemVybycgKTtcclxuICAgICAgICAgIHVuaXRzTGFiZWxUZXh0Lm1heFdpZHRoID0gdW5pdHNMYWJlbE1heFdpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWFqb3JUaWNrSW5kZXgrKztcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyBNaW5vciB0aWNrXHJcbiAgICAgICAgLy8gT25seSBhZGQgYSBtaW5vciB0aWNrIGF0IGxlZnRtb3N0IG9yIHJpZ2h0bW9zdCBlbmQgaWYgdGhlIGluc2V0c1dpZHRoIGlzIG5vbnplcm9cclxuICAgICAgICBpZiAoIG9wdGlvbnMuaW5zZXRzV2lkdGggIT09IDAgfHwgKCBpICE9PSAwICYmIGkgIT09IG51bWJlck9mVGlja3MgLSAxICkgKSB7XHJcbiAgICAgICAgICBpZiAoIG9wdGlvbnMudGlja01hcmtzT25Ub3AgKSB7XHJcbiAgICAgICAgICAgIG1pbm9yVGlja0xpbmVzU2hhcGUubW92ZVRvKCB4LCAwICkubGluZVRvKCB4LCBvcHRpb25zLm1pbm9yVGlja0hlaWdodCApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCBvcHRpb25zLnRpY2tNYXJrc09uQm90dG9tICkge1xyXG4gICAgICAgICAgICBtaW5vclRpY2tMaW5lc1NoYXBlLm1vdmVUbyggeCwgcnVsZXJIZWlnaHQgLSBvcHRpb25zLm1pbm9yVGlja0hlaWdodCApLmxpbmVUbyggeCwgcnVsZXJIZWlnaHQgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgeCArPSBtaW5vclRpY2tXaWR0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIHVuaXRzIGxhYmVsIGV4dGVuZHMgb2ZmIHRoZSBlZGdlIG9mIHRoZSBydWxlci4gIFRoaXMgaXMga2luZCBvZiBhIGNvcm5lciBjYXNlLCBidXQgd2FzXHJcbiAgICAvLyBzZWVuIHdoZW4gdGVzdGluZyBsb25nIHN0cmluZ3Mgb24gUGVuZHVsdW0gTGFiLlxyXG4gICAgaWYgKCB1bml0c0xhYmVsVGV4dC5ib3VuZHMubWF4WCA+IGJhY2tncm91bmROb2RlLmJvdW5kcy5tYXhYIC0gb3B0aW9ucy51bml0c1NwYWNpbmcgKSB7XHJcbiAgICAgIHVuaXRzTGFiZWxNYXhXaWR0aCA9ICggYmFja2dyb3VuZE5vZGUuYm91bmRzLm1heFggLSBvcHRpb25zLnVuaXRzU3BhY2luZyApIC0gdW5pdHNMYWJlbFRleHQueDtcclxuICAgICAgdW5pdHNMYWJlbFRleHQuc2NhbGUoIHVuaXRzTGFiZWxNYXhXaWR0aCAvIHVuaXRzTGFiZWxUZXh0LndpZHRoICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFqb3IgdGljayBsaW5lc1xyXG4gICAgdGhpcy5hZGRDaGlsZCggbmV3IFBhdGgoIG1ham9yVGlja0xpbmVzU2hhcGUsIHtcclxuICAgICAgc3Ryb2tlOiBvcHRpb25zLm1ham9yVGlja1N0cm9rZSxcclxuICAgICAgbGluZVdpZHRoOiBvcHRpb25zLm1ham9yVGlja0xpbmVXaWR0aCxcclxuICAgICAgcGlja2FibGU6IGZhbHNlXHJcbiAgICB9ICkgKTtcclxuXHJcbiAgICAvLyBNaW5vciB0aWNrIGxpbmVzXHJcbiAgICB0aGlzLmFkZENoaWxkKCBuZXcgUGF0aCggbWlub3JUaWNrTGluZXNTaGFwZSwge1xyXG4gICAgICBzdHJva2U6IG9wdGlvbnMubWlub3JUaWNrU3Ryb2tlLFxyXG4gICAgICBsaW5lV2lkdGg6IG9wdGlvbnMubWlub3JUaWNrTGluZVdpZHRoLFxyXG4gICAgICBwaWNrYWJsZTogZmFsc2VcclxuICAgIH0gKSApO1xyXG5cclxuICAgIHRoaXMubXV0YXRlKCBvcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy5kaXNwb3NlUnVsZXJOb2RlID0gKCkgPT4ge1xyXG4gICAgICB1bml0c0xhYmVsVGV4dC5kaXNwb3NlKCk7IC8vIGJlY2F1c2UgbWF5IGJlIGxpbmtlZCB0byBhIHRyYW5zbGF0ZWQgU3RyaW5nUHJvcGVydHlcclxuICAgIH07XHJcblxyXG4gICAgLy8gc3VwcG9ydCBmb3IgYmluZGVyIGRvY3VtZW50YXRpb24sIHN0cmlwcGVkIG91dCBpbiBidWlsZHMgYW5kIG9ubHkgcnVucyB3aGVuID9iaW5kZXIgaXMgc3BlY2lmaWVkXHJcbiAgICBhc3NlcnQgJiYgcGhldC5jaGlwcGVyLnF1ZXJ5UGFyYW1ldGVycy5iaW5kZXIgJiYgSW5zdGFuY2VSZWdpc3RyeS5yZWdpc3RlckRhdGFVUkwoICdzY2VuZXJ5LXBoZXQnLCAnUnVsZXJOb2RlJywgdGhpcyApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLmRpc3Bvc2VSdWxlck5vZGUoKTtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbnNjZW5lcnlQaGV0LnJlZ2lzdGVyKCAnUnVsZXJOb2RlJywgUnVsZXJOb2RlICk7XHJcbmV4cG9ydCBkZWZhdWx0IFJ1bGVyTm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0EsU0FBU0EsS0FBSyxRQUFRLDBCQUEwQjtBQUNoRCxPQUFPQyxnQkFBZ0IsTUFBTSxzREFBc0Q7QUFDbkYsT0FBT0MsU0FBUyxNQUFNLGlDQUFpQztBQUN2RCxTQUFlQyxJQUFJLEVBQWVDLElBQUksRUFBRUMsU0FBUyxFQUFVQyxJQUFJLFFBQVEsNkJBQTZCO0FBQ3BHLE9BQU9DLE1BQU0sTUFBTSwyQkFBMkI7QUFDOUMsT0FBT0MsUUFBUSxNQUFNLGVBQWU7QUFDcEMsT0FBT0MsV0FBVyxNQUFNLGtCQUFrQjs7QUFFMUM7QUFDQSxNQUFNQyxZQUFZLEdBQUcsSUFBSUYsUUFBUSxDQUFFLEVBQUcsQ0FBQztBQW1DdkMsTUFBTUcsU0FBUyxTQUFTUixJQUFJLENBQUM7RUFJM0IsT0FBdUJTLFlBQVksR0FBRyxvQkFBb0I7O0VBRTFEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDU0MsV0FBV0EsQ0FBRUMsVUFBa0IsRUFBRUMsV0FBbUIsRUFBRUMsY0FBc0IsRUFBRUMsZUFBeUIsRUFDMUZDLEtBQXlDLEVBQUVDLGVBQWtDLEVBQUc7SUFFbEc7SUFDQSxNQUFNQyxPQUFPLEdBQUdsQixTQUFTLENBQTZDLENBQUMsQ0FBRTtNQUV2RTtNQUNBbUIsY0FBYyxFQUFFVixTQUFTLENBQUNDLFlBQVk7TUFDdENVLGdCQUFnQixFQUFFLE9BQU87TUFDekJDLG1CQUFtQixFQUFFLENBQUM7TUFDdEJDLFdBQVcsRUFBRSxFQUFFO01BQ2ZDLGFBQWEsRUFBRWYsWUFBWTtNQUMzQmdCLGVBQWUsRUFBSSxHQUFHLEdBQUdYLFdBQVcsR0FBSyxDQUFDO01BQzFDWSxlQUFlLEVBQUUsT0FBTztNQUN4QkMsa0JBQWtCLEVBQUUsQ0FBQztNQUNyQkMsYUFBYSxFQUFFbkIsWUFBWTtNQUMzQm9CLGVBQWUsRUFBSSxHQUFHLEdBQUdmLFdBQVcsR0FBSyxDQUFDO01BQzFDZ0IsZUFBZSxFQUFFLE9BQU87TUFDeEJDLGtCQUFrQixFQUFFLENBQUM7TUFDckJDLHNCQUFzQixFQUFFLENBQUM7TUFDekJDLFNBQVMsRUFBRXhCLFlBQVk7TUFDdkJ5QixtQkFBbUIsRUFBRSxDQUFDO01BQ3RCQyxZQUFZLEVBQUUsQ0FBQztNQUNmQyxjQUFjLEVBQUUsSUFBSTtNQUNwQkMsaUJBQWlCLEVBQUUsSUFBSTtNQUV2QjtNQUNBQyxNQUFNLEVBQUVoQyxNQUFNLENBQUNpQyxRQUFRO01BQ3ZCQyxnQkFBZ0IsRUFBRTtJQUNwQixDQUFDLEVBQUV0QixlQUFnQixDQUFDOztJQUVwQjtJQUNBdUIsTUFBTSxJQUFJQSxNQUFNLENBQUVDLElBQUksQ0FBQ0MsS0FBSyxDQUFFOUIsVUFBVSxHQUFHRSxjQUFlLENBQUMsR0FBRyxDQUFDLEtBQUtDLGVBQWUsQ0FBQzRCLE1BQU8sQ0FBQyxDQUFDLENBQUM7SUFDOUZILE1BQU0sSUFBSUEsTUFBTSxDQUFFdEIsT0FBTyxDQUFDZSxtQkFBbUIsR0FBR2xCLGVBQWUsQ0FBQzRCLE1BQU8sQ0FBQztJQUN4RUgsTUFBTSxJQUFJQSxNQUFNLENBQUV0QixPQUFPLENBQUNNLGVBQWUsR0FBR1gsV0FBVyxHQUFHLENBQUUsQ0FBQztJQUM3RDJCLE1BQU0sSUFBSUEsTUFBTSxDQUFFdEIsT0FBTyxDQUFDVSxlQUFlLEdBQUdmLFdBQVcsR0FBRyxDQUFFLENBQUM7SUFFN0QsS0FBSyxDQUFDLENBQUM7O0lBRVA7SUFDQSxNQUFNK0IsY0FBYyxHQUFHLElBQUl6QyxTQUFTLENBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRVMsVUFBVSxHQUFLLENBQUMsR0FBR00sT0FBTyxDQUFDSSxXQUFhLEVBQUVULFdBQVcsRUFBRTtNQUNqR2dDLElBQUksRUFBRTNCLE9BQU8sQ0FBQ0MsY0FBYztNQUM1QjJCLE1BQU0sRUFBRTVCLE9BQU8sQ0FBQ0UsZ0JBQWdCO01BQ2hDMkIsU0FBUyxFQUFFN0IsT0FBTyxDQUFDRztJQUNyQixDQUFFLENBQUM7SUFDSCxJQUFJLENBQUMyQixRQUFRLENBQUVKLGNBQWUsQ0FBQzs7SUFFL0I7SUFDQSxNQUFNSyxjQUFjLEdBQUduQyxjQUFjLElBQUtJLE9BQU8sQ0FBQ2Esc0JBQXNCLEdBQUcsQ0FBQyxDQUFFO0lBQzlFLE1BQU1tQixhQUFhLEdBQUdULElBQUksQ0FBQ0MsS0FBSyxDQUFFOUIsVUFBVSxHQUFHcUMsY0FBZSxDQUFDLEdBQUcsQ0FBQztJQUNuRSxJQUFJRSxDQUFDLEdBQUdqQyxPQUFPLENBQUNJLFdBQVc7SUFDM0IsSUFBSThCLGNBQWMsR0FBRyxDQUFDOztJQUV0QjtJQUNBLE1BQU1DLG1CQUFtQixHQUFHLElBQUl2RCxLQUFLLENBQUMsQ0FBQztJQUN2QyxNQUFNd0QsbUJBQW1CLEdBQUcsSUFBSXhELEtBQUssQ0FBQyxDQUFDOztJQUV2QztJQUNBLE1BQU15RCxjQUFjLEdBQUcsSUFBSW5ELElBQUksQ0FBRVksS0FBSyxFQUFFO01BQ3RDd0MsSUFBSSxFQUFFdEMsT0FBTyxDQUFDYyxTQUFTO01BQ3ZCeUIsUUFBUSxFQUFFLEtBQUs7TUFDZnBCLE1BQU0sRUFBRW5CLE9BQU8sQ0FBQ21CLE1BQU0sQ0FBQ3FCLFlBQVksQ0FBRSxnQkFBaUI7SUFDeEQsQ0FBRSxDQUFDO0lBQ0gsSUFBSUMsa0JBQWtCLEdBQUdDLE1BQU0sQ0FBQ0MsaUJBQWlCO0lBQ2pELElBQUksQ0FBQ2IsUUFBUSxDQUFFTyxjQUFlLENBQUM7SUFFL0IsS0FBTSxJQUFJTyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdaLGFBQWEsRUFBRVksQ0FBQyxFQUFFLEVBQUc7TUFFeEMsSUFBS0EsQ0FBQyxJQUFLNUMsT0FBTyxDQUFDYSxzQkFBc0IsR0FBRyxDQUFDLENBQUUsS0FBSyxDQUFDLEVBQUc7UUFBRzs7UUFFekQ7O1FBRUE7UUFDQSxNQUFNZ0MsY0FBYyxHQUFHaEQsZUFBZSxDQUFFcUMsY0FBYyxDQUFFO1FBQ3hELE1BQU1ZLGtCQUFrQixHQUFHLElBQUk1RCxJQUFJLENBQUUyRCxjQUFjLEVBQUU7VUFDbkRQLElBQUksRUFBRXRDLE9BQU8sQ0FBQ0ssYUFBYTtVQUMzQjBDLE9BQU8sRUFBRWQsQ0FBQztVQUNWZSxPQUFPLEVBQUV0QixjQUFjLENBQUNzQixPQUFPO1VBQy9CVCxRQUFRLEVBQUU7UUFDWixDQUFFLENBQUM7O1FBRUg7UUFDQSxJQUFLdkMsT0FBTyxDQUFDSSxXQUFXLEtBQUssQ0FBQyxJQUFNd0MsQ0FBQyxLQUFLLENBQUMsSUFBSUEsQ0FBQyxLQUFLWixhQUFhLEdBQUcsQ0FBRyxFQUFHO1VBRXpFO1VBQ0EsSUFBS2EsY0FBYyxFQUFHO1lBQ3BCLElBQUksQ0FBQ2YsUUFBUSxDQUFFZ0Isa0JBQW1CLENBQUM7VUFDckM7O1VBRUE7VUFDQSxJQUFLOUMsT0FBTyxDQUFDaUIsY0FBYyxFQUFHO1lBQzVCa0IsbUJBQW1CLENBQUNjLE1BQU0sQ0FBRWhCLENBQUMsRUFBRSxDQUFFLENBQUMsQ0FBQ2lCLE1BQU0sQ0FBRWpCLENBQUMsRUFBRWpDLE9BQU8sQ0FBQ00sZUFBZ0IsQ0FBQztVQUN6RTtVQUNBLElBQUtOLE9BQU8sQ0FBQ2tCLGlCQUFpQixFQUFHO1lBQy9CaUIsbUJBQW1CLENBQUNjLE1BQU0sQ0FBRWhCLENBQUMsRUFBRXRDLFdBQVcsR0FBR0ssT0FBTyxDQUFDTSxlQUFnQixDQUFDLENBQUM0QyxNQUFNLENBQUVqQixDQUFDLEVBQUV0QyxXQUFZLENBQUM7VUFDakc7UUFDRjs7UUFFQTtRQUNBLElBQUt1QyxjQUFjLEtBQUtsQyxPQUFPLENBQUNlLG1CQUFtQixFQUFHO1VBQ3BEc0IsY0FBYyxDQUFDYyxJQUFJLEdBQUdMLGtCQUFrQixDQUFDTSxLQUFLLEdBQUdwRCxPQUFPLENBQUNnQixZQUFZO1VBQ3JFcUIsY0FBYyxDQUFDZ0IsQ0FBQyxHQUFHUCxrQkFBa0IsQ0FBQ08sQ0FBQztRQUN6QyxDQUFDLE1BQ0ksSUFBS25CLGNBQWMsR0FBR2xDLE9BQU8sQ0FBQ2UsbUJBQW1CLElBQUkwQixrQkFBa0IsS0FBS0MsTUFBTSxDQUFDQyxpQkFBaUIsSUFBSUcsa0JBQWtCLENBQUNRLEtBQUssR0FBRyxDQUFDLEVBQUc7VUFFMUk7VUFDQWIsa0JBQWtCLEdBQUdLLGtCQUFrQixDQUFDSyxJQUFJLEdBQUduRCxPQUFPLENBQUNnQixZQUFZLEdBQUdxQixjQUFjLENBQUNjLElBQUk7VUFDekY3QixNQUFNLElBQUlBLE1BQU0sQ0FBRW1CLGtCQUFrQixHQUFHLENBQUMsRUFBRSwyQ0FBNEMsQ0FBQztVQUN2RkosY0FBYyxDQUFDa0IsUUFBUSxHQUFHZCxrQkFBa0I7UUFDOUM7UUFFQVAsY0FBYyxFQUFFO01BQ2xCLENBQUMsTUFDSTtRQUNIO1FBQ0E7UUFDQSxJQUFLbEMsT0FBTyxDQUFDSSxXQUFXLEtBQUssQ0FBQyxJQUFNd0MsQ0FBQyxLQUFLLENBQUMsSUFBSUEsQ0FBQyxLQUFLWixhQUFhLEdBQUcsQ0FBRyxFQUFHO1VBQ3pFLElBQUtoQyxPQUFPLENBQUNpQixjQUFjLEVBQUc7WUFDNUJtQixtQkFBbUIsQ0FBQ2EsTUFBTSxDQUFFaEIsQ0FBQyxFQUFFLENBQUUsQ0FBQyxDQUFDaUIsTUFBTSxDQUFFakIsQ0FBQyxFQUFFakMsT0FBTyxDQUFDVSxlQUFnQixDQUFDO1VBQ3pFO1VBQ0EsSUFBS1YsT0FBTyxDQUFDa0IsaUJBQWlCLEVBQUc7WUFDL0JrQixtQkFBbUIsQ0FBQ2EsTUFBTSxDQUFFaEIsQ0FBQyxFQUFFdEMsV0FBVyxHQUFHSyxPQUFPLENBQUNVLGVBQWdCLENBQUMsQ0FBQ3dDLE1BQU0sQ0FBRWpCLENBQUMsRUFBRXRDLFdBQVksQ0FBQztVQUNqRztRQUNGO01BQ0Y7TUFDQXNDLENBQUMsSUFBSUYsY0FBYztJQUNyQjs7SUFFQTtJQUNBO0lBQ0EsSUFBS00sY0FBYyxDQUFDbUIsTUFBTSxDQUFDQyxJQUFJLEdBQUcvQixjQUFjLENBQUM4QixNQUFNLENBQUNDLElBQUksR0FBR3pELE9BQU8sQ0FBQ2dCLFlBQVksRUFBRztNQUNwRnlCLGtCQUFrQixHQUFLZixjQUFjLENBQUM4QixNQUFNLENBQUNDLElBQUksR0FBR3pELE9BQU8sQ0FBQ2dCLFlBQVksR0FBS3FCLGNBQWMsQ0FBQ0osQ0FBQztNQUM3RkksY0FBYyxDQUFDcUIsS0FBSyxDQUFFakIsa0JBQWtCLEdBQUdKLGNBQWMsQ0FBQ2lCLEtBQU0sQ0FBQztJQUNuRTs7SUFFQTtJQUNBLElBQUksQ0FBQ3hCLFFBQVEsQ0FBRSxJQUFJOUMsSUFBSSxDQUFFbUQsbUJBQW1CLEVBQUU7TUFDNUNQLE1BQU0sRUFBRTVCLE9BQU8sQ0FBQ08sZUFBZTtNQUMvQnNCLFNBQVMsRUFBRTdCLE9BQU8sQ0FBQ1Esa0JBQWtCO01BQ3JDK0IsUUFBUSxFQUFFO0lBQ1osQ0FBRSxDQUFFLENBQUM7O0lBRUw7SUFDQSxJQUFJLENBQUNULFFBQVEsQ0FBRSxJQUFJOUMsSUFBSSxDQUFFb0QsbUJBQW1CLEVBQUU7TUFDNUNSLE1BQU0sRUFBRTVCLE9BQU8sQ0FBQ1csZUFBZTtNQUMvQmtCLFNBQVMsRUFBRTdCLE9BQU8sQ0FBQ1ksa0JBQWtCO01BQ3JDMkIsUUFBUSxFQUFFO0lBQ1osQ0FBRSxDQUFFLENBQUM7SUFFTCxJQUFJLENBQUNvQixNQUFNLENBQUUzRCxPQUFRLENBQUM7SUFFdEIsSUFBSSxDQUFDNEQsZ0JBQWdCLEdBQUcsTUFBTTtNQUM1QnZCLGNBQWMsQ0FBQ3dCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QixDQUFDOztJQUVEO0lBQ0F2QyxNQUFNLElBQUl3QyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsZUFBZSxDQUFDQyxNQUFNLElBQUlwRixnQkFBZ0IsQ0FBQ3FGLGVBQWUsQ0FBRSxjQUFjLEVBQUUsV0FBVyxFQUFFLElBQUssQ0FBQztFQUN4SDtFQUVnQkwsT0FBT0EsQ0FBQSxFQUFTO0lBQzlCLElBQUksQ0FBQ0QsZ0JBQWdCLENBQUMsQ0FBQztJQUN2QixLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDO0VBQ2pCO0FBQ0Y7QUFFQXhFLFdBQVcsQ0FBQzhFLFFBQVEsQ0FBRSxXQUFXLEVBQUU1RSxTQUFVLENBQUM7QUFDOUMsZUFBZUEsU0FBUyJ9