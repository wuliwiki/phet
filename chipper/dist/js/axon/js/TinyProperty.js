// Copyright 2020-2023, University of Colorado Boulder

/**
 * A lightweight version of Property (that satisfies some of the interface), meant for high-performance applications
 * where validation, phet-io support and other things are not needed.
 *
 * This directly extends TinyEmitter in order to save memory.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import axon from './axon.js';
import TinyEmitter from './TinyEmitter.js';
export default class TinyProperty extends TinyEmitter {
  // Store the internal value -- NOT for general use (but used in Scenery for performance)

  // Forces use of the deep equality checks. Keeps some compatibility with the Property interface to have the equality
  // check in this type too. Not defining in the general case for memory usage, only using if we notice this flag set.
  constructor(value, onBeforeNotify, hasListenerOrderDependencies) {
    super(onBeforeNotify, hasListenerOrderDependencies);
    this._value = value;
  }

  /**
   * Returns the value.
   *
   * You can also use the es5 getter (property.value) but this means is provided for inner loops
   * or internal code that must be fast.
   */
  get() {
    return this._value;
  }

  /**
   * Returns the value.
   */
  get value() {
    return this.get();
  }

  /**
   * Sets the value.
   */
  set value(newValue) {
    this.set(newValue);
  }

  /**
   * Sets the value and notifies listeners, unless deferred or disposed. You can also use the es5 getter
   * (property.value) but this means is provided for inner loops or internal code that must be fast. If the value
   * hasn't changed, this is a no-op.
   */
  set(value) {
    if (!this.equalsValue(value)) {
      const oldValue = this._value;
      this.setPropertyValue(value);
      this.notifyListeners(oldValue);
    }
  }

  /**
   * Sets the value without notifying any listeners. This is a place to override if a subtype performs additional work
   * when setting the value.
   */
  setPropertyValue(value) {
    this._value = value;
  }

  /**
   * Returns true if and only if the specified value equals the value of this property
   */
  equalsValue(value) {
    return this.areValuesEqual(value, this._value);
  }

  /**
   * Determines equality semantics for the wrapped type, including whether notifications are sent out when the
   * wrapped value changes, and whether onValue is triggered.
   * (Property)
   *
   * useDeepEquality: true => Use the `equals` method on the values
   * useDeepEquality: false => Use === for equality test
   *
   * Alternatively different implementation can be provided by subclasses or instances to change the equals
   * definition. See #10 and #73 and #115
   */
  areValuesEqual(a, b) {
    if (this.useDeepEquality) {
      const aObject = a;
      const bObject = b;
      if (aObject && bObject && aObject.constructor === bObject.constructor) {
        assert && assert(!!aObject.equals, 'no equals function for 1st arg');
        assert && assert(!!bObject.equals, 'no equals function for 2nd arg');
        assert && assert(aObject.equals(bObject) === bObject.equals(aObject), 'incompatible equality checks');
        return aObject.equals(bObject);
      }
    }

    // Reference equality for objects, value equality for primitives
    return a === b;
  }

  /**
   * Directly notifies listeners of changes.
   */
  notifyListeners(oldValue) {
    // We use this._value here for performance, AND to avoid calling onAccessAttempt unnecessarily.
    this.emit(this._value, oldValue, this);
  }

  /**
   * Adds listener and calls it immediately. If listener is already registered, this is a no-op. The initial
   * notification provides the current value for newValue and null for oldValue.
   */
  link(listener) {
    this.addListener(listener);
    listener(this._value, null, this); // null should be used when an object is expected but unavailable
  }

  /**
   * Add an listener to the TinyProperty, without calling it back right away. This is used when you need to register a
   * listener without an immediate callback.
   */
  lazyLink(listener) {
    this.addListener(listener); // Because it's a lazy link, it will never be called with null
  }

  /**
   * Removes a listener. If listener is not registered, this is a no-op.
   */
  unlink(listener) {
    this.removeListener(listener);
  }

  /**
   * Removes all listeners. If no listeners are registered, this is a no-op.
   */
  unlinkAll() {
    this.removeAllListeners();
  }

  /**
   * Links an object's named attribute to this TinyProperty.  Returns a handle so it can be removed using
   * TinyProperty.unlink();
   * Example: modelVisibleProperty.linkAttribute(view, 'visible');
   *
   * NOTE: Duplicated with Property.linkAttribute
   */
  linkAttribute(object, attributeName) {
    const handle = value => {
      object[attributeName] = value;
    };
    this.link(handle);
    return handle;
  }

  /**
   * Returns true if the value can be set externally, using .value= or set()
   */
  isSettable() {
    return true;
  }

  /**
   * Releases references.
   */
  dispose() {
    // Remove any listeners that are still attached (note that the emitter dispose would do this also, but without the
    // potentially-needed extra logic of changeCount, etc.)
    this.unlinkAll();
    super.dispose();
  }
}
axon.register('TinyProperty', TinyProperty);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJheG9uIiwiVGlueUVtaXR0ZXIiLCJUaW55UHJvcGVydHkiLCJjb25zdHJ1Y3RvciIsInZhbHVlIiwib25CZWZvcmVOb3RpZnkiLCJoYXNMaXN0ZW5lck9yZGVyRGVwZW5kZW5jaWVzIiwiX3ZhbHVlIiwiZ2V0IiwibmV3VmFsdWUiLCJzZXQiLCJlcXVhbHNWYWx1ZSIsIm9sZFZhbHVlIiwic2V0UHJvcGVydHlWYWx1ZSIsIm5vdGlmeUxpc3RlbmVycyIsImFyZVZhbHVlc0VxdWFsIiwiYSIsImIiLCJ1c2VEZWVwRXF1YWxpdHkiLCJhT2JqZWN0IiwiYk9iamVjdCIsImFzc2VydCIsImVxdWFscyIsImVtaXQiLCJsaW5rIiwibGlzdGVuZXIiLCJhZGRMaXN0ZW5lciIsImxhenlMaW5rIiwidW5saW5rIiwicmVtb3ZlTGlzdGVuZXIiLCJ1bmxpbmtBbGwiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJsaW5rQXR0cmlidXRlIiwib2JqZWN0IiwiYXR0cmlidXRlTmFtZSIsImhhbmRsZSIsImlzU2V0dGFibGUiLCJkaXNwb3NlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJUaW55UHJvcGVydHkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSBsaWdodHdlaWdodCB2ZXJzaW9uIG9mIFByb3BlcnR5ICh0aGF0IHNhdGlzZmllcyBzb21lIG9mIHRoZSBpbnRlcmZhY2UpLCBtZWFudCBmb3IgaGlnaC1wZXJmb3JtYW5jZSBhcHBsaWNhdGlvbnNcclxuICogd2hlcmUgdmFsaWRhdGlvbiwgcGhldC1pbyBzdXBwb3J0IGFuZCBvdGhlciB0aGluZ3MgYXJlIG5vdCBuZWVkZWQuXHJcbiAqXHJcbiAqIFRoaXMgZGlyZWN0bHkgZXh0ZW5kcyBUaW55RW1pdHRlciBpbiBvcmRlciB0byBzYXZlIG1lbW9yeS5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBheG9uIGZyb20gJy4vYXhvbi5qcyc7XHJcbmltcG9ydCBUaW55RW1pdHRlciBmcm9tICcuL1RpbnlFbWl0dGVyLmpzJztcclxuaW1wb3J0IFRQcm9wZXJ0eSBmcm9tICcuL1RQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBUUmVhZE9ubHlQcm9wZXJ0eSwgeyBQcm9wZXJ0eUxhenlMaW5rTGlzdGVuZXIsIFByb3BlcnR5TGlua0xpc3RlbmVyLCBQcm9wZXJ0eUxpc3RlbmVyIH0gZnJvbSAnLi9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcblxyXG5leHBvcnQgdHlwZSBDb21wYXJhYmxlT2JqZWN0ID0ge1xyXG4gIGVxdWFsczogKCBhOiB1bmtub3duICkgPT4gYm9vbGVhbjtcclxufTtcclxuZXhwb3J0IHR5cGUgVGlueVByb3BlcnR5RW1pdHRlclBhcmFtZXRlcnM8VD4gPSBbIFQsIFQgfCBudWxsLCBUUmVhZE9ubHlQcm9wZXJ0eTxUPiBdO1xyXG5leHBvcnQgdHlwZSBUaW55UHJvcGVydHlPbkJlZm9yZU5vdGlmeTxUPiA9ICggLi4uYXJnczogVGlueVByb3BlcnR5RW1pdHRlclBhcmFtZXRlcnM8VD4gKSA9PiB2b2lkO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlueVByb3BlcnR5PFQ+IGV4dGVuZHMgVGlueUVtaXR0ZXI8VGlueVByb3BlcnR5RW1pdHRlclBhcmFtZXRlcnM8VD4+IGltcGxlbWVudHMgVFByb3BlcnR5PFQ+IHtcclxuXHJcbiAgcHVibGljIF92YWx1ZTogVDsgLy8gU3RvcmUgdGhlIGludGVybmFsIHZhbHVlIC0tIE5PVCBmb3IgZ2VuZXJhbCB1c2UgKGJ1dCB1c2VkIGluIFNjZW5lcnkgZm9yIHBlcmZvcm1hbmNlKVxyXG5cclxuICAvLyBGb3JjZXMgdXNlIG9mIHRoZSBkZWVwIGVxdWFsaXR5IGNoZWNrcy4gS2VlcHMgc29tZSBjb21wYXRpYmlsaXR5IHdpdGggdGhlIFByb3BlcnR5IGludGVyZmFjZSB0byBoYXZlIHRoZSBlcXVhbGl0eVxyXG4gIC8vIGNoZWNrIGluIHRoaXMgdHlwZSB0b28uIE5vdCBkZWZpbmluZyBpbiB0aGUgZ2VuZXJhbCBjYXNlIGZvciBtZW1vcnkgdXNhZ2UsIG9ubHkgdXNpbmcgaWYgd2Ugbm90aWNlIHRoaXMgZmxhZyBzZXQuXHJcbiAgcHJvdGVjdGVkIHVzZURlZXBFcXVhbGl0eT86IGJvb2xlYW47XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdmFsdWU6IFQsIG9uQmVmb3JlTm90aWZ5PzogVGlueVByb3BlcnR5T25CZWZvcmVOb3RpZnk8VD4gfCBudWxsLCBoYXNMaXN0ZW5lck9yZGVyRGVwZW5kZW5jaWVzPzogYm9vbGVhbiApIHtcclxuICAgIHN1cGVyKCBvbkJlZm9yZU5vdGlmeSwgaGFzTGlzdGVuZXJPcmRlckRlcGVuZGVuY2llcyApO1xyXG5cclxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZS5cclxuICAgKlxyXG4gICAqIFlvdSBjYW4gYWxzbyB1c2UgdGhlIGVzNSBnZXR0ZXIgKHByb3BlcnR5LnZhbHVlKSBidXQgdGhpcyBtZWFucyBpcyBwcm92aWRlZCBmb3IgaW5uZXIgbG9vcHNcclxuICAgKiBvciBpbnRlcm5hbCBjb2RlIHRoYXQgbXVzdCBiZSBmYXN0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXQoKTogVCB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZS5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0IHZhbHVlKCk6IFQge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2YWx1ZS5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0IHZhbHVlKCBuZXdWYWx1ZTogVCApIHtcclxuICAgIHRoaXMuc2V0KCBuZXdWYWx1ZSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgdmFsdWUgYW5kIG5vdGlmaWVzIGxpc3RlbmVycywgdW5sZXNzIGRlZmVycmVkIG9yIGRpc3Bvc2VkLiBZb3UgY2FuIGFsc28gdXNlIHRoZSBlczUgZ2V0dGVyXHJcbiAgICogKHByb3BlcnR5LnZhbHVlKSBidXQgdGhpcyBtZWFucyBpcyBwcm92aWRlZCBmb3IgaW5uZXIgbG9vcHMgb3IgaW50ZXJuYWwgY29kZSB0aGF0IG11c3QgYmUgZmFzdC4gSWYgdGhlIHZhbHVlXHJcbiAgICogaGFzbid0IGNoYW5nZWQsIHRoaXMgaXMgYSBuby1vcC5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0KCB2YWx1ZTogVCApOiB2b2lkIHtcclxuICAgIGlmICggIXRoaXMuZXF1YWxzVmFsdWUoIHZhbHVlICkgKSB7XHJcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fdmFsdWU7XHJcblxyXG4gICAgICB0aGlzLnNldFByb3BlcnR5VmFsdWUoIHZhbHVlICk7XHJcblxyXG4gICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyggb2xkVmFsdWUgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHZhbHVlIHdpdGhvdXQgbm90aWZ5aW5nIGFueSBsaXN0ZW5lcnMuIFRoaXMgaXMgYSBwbGFjZSB0byBvdmVycmlkZSBpZiBhIHN1YnR5cGUgcGVyZm9ybXMgYWRkaXRpb25hbCB3b3JrXHJcbiAgICogd2hlbiBzZXR0aW5nIHRoZSB2YWx1ZS5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0UHJvcGVydHlWYWx1ZSggdmFsdWU6IFQgKTogdm9pZCB7XHJcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgZXF1YWxzIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5XHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGVxdWFsc1ZhbHVlKCB2YWx1ZTogVCApOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmFyZVZhbHVlc0VxdWFsKCB2YWx1ZSwgdGhpcy5fdmFsdWUgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgZXF1YWxpdHkgc2VtYW50aWNzIGZvciB0aGUgd3JhcHBlZCB0eXBlLCBpbmNsdWRpbmcgd2hldGhlciBub3RpZmljYXRpb25zIGFyZSBzZW50IG91dCB3aGVuIHRoZVxyXG4gICAqIHdyYXBwZWQgdmFsdWUgY2hhbmdlcywgYW5kIHdoZXRoZXIgb25WYWx1ZSBpcyB0cmlnZ2VyZWQuXHJcbiAgICogKFByb3BlcnR5KVxyXG4gICAqXHJcbiAgICogdXNlRGVlcEVxdWFsaXR5OiB0cnVlID0+IFVzZSB0aGUgYGVxdWFsc2AgbWV0aG9kIG9uIHRoZSB2YWx1ZXNcclxuICAgKiB1c2VEZWVwRXF1YWxpdHk6IGZhbHNlID0+IFVzZSA9PT0gZm9yIGVxdWFsaXR5IHRlc3RcclxuICAgKlxyXG4gICAqIEFsdGVybmF0aXZlbHkgZGlmZmVyZW50IGltcGxlbWVudGF0aW9uIGNhbiBiZSBwcm92aWRlZCBieSBzdWJjbGFzc2VzIG9yIGluc3RhbmNlcyB0byBjaGFuZ2UgdGhlIGVxdWFsc1xyXG4gICAqIGRlZmluaXRpb24uIFNlZSAjMTAgYW5kICM3MyBhbmQgIzExNVxyXG4gICAqL1xyXG4gIHB1YmxpYyBhcmVWYWx1ZXNFcXVhbCggYTogVCwgYjogVCApOiBib29sZWFuIHtcclxuICAgIGlmICggdGhpcy51c2VEZWVwRXF1YWxpdHkgKSB7XHJcbiAgICAgIGNvbnN0IGFPYmplY3QgPSBhIGFzIHVua25vd24gYXMgQ29tcGFyYWJsZU9iamVjdDtcclxuICAgICAgY29uc3QgYk9iamVjdCA9IGIgYXMgdW5rbm93biBhcyBDb21wYXJhYmxlT2JqZWN0O1xyXG5cclxuICAgICAgaWYgKCBhT2JqZWN0ICYmIGJPYmplY3QgJiYgYU9iamVjdC5jb25zdHJ1Y3RvciA9PT0gYk9iamVjdC5jb25zdHJ1Y3RvciApIHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhIWFPYmplY3QuZXF1YWxzLCAnbm8gZXF1YWxzIGZ1bmN0aW9uIGZvciAxc3QgYXJnJyApO1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoICEhYk9iamVjdC5lcXVhbHMsICdubyBlcXVhbHMgZnVuY3Rpb24gZm9yIDJuZCBhcmcnICk7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggYU9iamVjdC5lcXVhbHMoIGJPYmplY3QgKSA9PT0gYk9iamVjdC5lcXVhbHMoIGFPYmplY3QgKSwgJ2luY29tcGF0aWJsZSBlcXVhbGl0eSBjaGVja3MnICk7XHJcbiAgICAgICAgcmV0dXJuIGFPYmplY3QuZXF1YWxzKCBiT2JqZWN0ICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWZlcmVuY2UgZXF1YWxpdHkgZm9yIG9iamVjdHMsIHZhbHVlIGVxdWFsaXR5IGZvciBwcmltaXRpdmVzXHJcbiAgICByZXR1cm4gYSA9PT0gYjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpcmVjdGx5IG5vdGlmaWVzIGxpc3RlbmVycyBvZiBjaGFuZ2VzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBub3RpZnlMaXN0ZW5lcnMoIG9sZFZhbHVlOiBUICk6IHZvaWQge1xyXG4gICAgLy8gV2UgdXNlIHRoaXMuX3ZhbHVlIGhlcmUgZm9yIHBlcmZvcm1hbmNlLCBBTkQgdG8gYXZvaWQgY2FsbGluZyBvbkFjY2Vzc0F0dGVtcHQgdW5uZWNlc3NhcmlseS5cclxuICAgIHRoaXMuZW1pdCggdGhpcy5fdmFsdWUsIG9sZFZhbHVlLCB0aGlzICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGxpc3RlbmVyIGFuZCBjYWxscyBpdCBpbW1lZGlhdGVseS4gSWYgbGlzdGVuZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkLCB0aGlzIGlzIGEgbm8tb3AuIFRoZSBpbml0aWFsXHJcbiAgICogbm90aWZpY2F0aW9uIHByb3ZpZGVzIHRoZSBjdXJyZW50IHZhbHVlIGZvciBuZXdWYWx1ZSBhbmQgbnVsbCBmb3Igb2xkVmFsdWUuXHJcbiAgICovXHJcbiAgcHVibGljIGxpbmsoIGxpc3RlbmVyOiBQcm9wZXJ0eUxpbmtMaXN0ZW5lcjxUPiApOiB2b2lkIHtcclxuICAgIHRoaXMuYWRkTGlzdGVuZXIoIGxpc3RlbmVyICk7XHJcblxyXG4gICAgbGlzdGVuZXIoIHRoaXMuX3ZhbHVlLCBudWxsLCB0aGlzICk7IC8vIG51bGwgc2hvdWxkIGJlIHVzZWQgd2hlbiBhbiBvYmplY3QgaXMgZXhwZWN0ZWQgYnV0IHVuYXZhaWxhYmxlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYW4gbGlzdGVuZXIgdG8gdGhlIFRpbnlQcm9wZXJ0eSwgd2l0aG91dCBjYWxsaW5nIGl0IGJhY2sgcmlnaHQgYXdheS4gVGhpcyBpcyB1c2VkIHdoZW4geW91IG5lZWQgdG8gcmVnaXN0ZXIgYVxyXG4gICAqIGxpc3RlbmVyIHdpdGhvdXQgYW4gaW1tZWRpYXRlIGNhbGxiYWNrLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBsYXp5TGluayggbGlzdGVuZXI6IFByb3BlcnR5TGF6eUxpbmtMaXN0ZW5lcjxUPiApOiB2b2lkIHtcclxuICAgIHRoaXMuYWRkTGlzdGVuZXIoIGxpc3RlbmVyIGFzIFByb3BlcnR5TGlua0xpc3RlbmVyPFQ+ICk7IC8vIEJlY2F1c2UgaXQncyBhIGxhenkgbGluaywgaXQgd2lsbCBuZXZlciBiZSBjYWxsZWQgd2l0aCBudWxsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGEgbGlzdGVuZXIuIElmIGxpc3RlbmVyIGlzIG5vdCByZWdpc3RlcmVkLCB0aGlzIGlzIGEgbm8tb3AuXHJcbiAgICovXHJcbiAgcHVibGljIHVubGluayggbGlzdGVuZXI6IFByb3BlcnR5TGlzdGVuZXI8VD4gKTogdm9pZCB7XHJcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCBsaXN0ZW5lciBhcyBQcm9wZXJ0eUxpbmtMaXN0ZW5lcjxUPiApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBJZiBubyBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQsIHRoaXMgaXMgYSBuby1vcC5cclxuICAgKi9cclxuICBwdWJsaWMgdW5saW5rQWxsKCk6IHZvaWQge1xyXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpbmtzIGFuIG9iamVjdCdzIG5hbWVkIGF0dHJpYnV0ZSB0byB0aGlzIFRpbnlQcm9wZXJ0eS4gIFJldHVybnMgYSBoYW5kbGUgc28gaXQgY2FuIGJlIHJlbW92ZWQgdXNpbmdcclxuICAgKiBUaW55UHJvcGVydHkudW5saW5rKCk7XHJcbiAgICogRXhhbXBsZTogbW9kZWxWaXNpYmxlUHJvcGVydHkubGlua0F0dHJpYnV0ZSh2aWV3LCAndmlzaWJsZScpO1xyXG4gICAqXHJcbiAgICogTk9URTogRHVwbGljYXRlZCB3aXRoIFByb3BlcnR5LmxpbmtBdHRyaWJ1dGVcclxuICAgKi9cclxuICBwdWJsaWMgbGlua0F0dHJpYnV0ZTxBdHRyIGV4dGVuZHMgc3RyaW5nPiggb2JqZWN0OiB7IFtrZXkgaW4gQXR0cl06IFQgfSwgYXR0cmlidXRlTmFtZTogQXR0ciApOiAoIHZhbHVlOiBUICkgPT4gdm9pZCB7XHJcbiAgICBjb25zdCBoYW5kbGUgPSAoIHZhbHVlOiBUICkgPT4geyBvYmplY3RbIGF0dHJpYnV0ZU5hbWUgXSA9IHZhbHVlOyB9O1xyXG4gICAgdGhpcy5saW5rKCBoYW5kbGUgKTtcclxuICAgIHJldHVybiBoYW5kbGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGNhbiBiZSBzZXQgZXh0ZXJuYWxseSwgdXNpbmcgLnZhbHVlPSBvciBzZXQoKVxyXG4gICAqL1xyXG4gIHB1YmxpYyBpc1NldHRhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWxlYXNlcyByZWZlcmVuY2VzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgLy8gUmVtb3ZlIGFueSBsaXN0ZW5lcnMgdGhhdCBhcmUgc3RpbGwgYXR0YWNoZWQgKG5vdGUgdGhhdCB0aGUgZW1pdHRlciBkaXNwb3NlIHdvdWxkIGRvIHRoaXMgYWxzbywgYnV0IHdpdGhvdXQgdGhlXHJcbiAgICAvLyBwb3RlbnRpYWxseS1uZWVkZWQgZXh0cmEgbG9naWMgb2YgY2hhbmdlQ291bnQsIGV0Yy4pXHJcbiAgICB0aGlzLnVubGlua0FsbCgpO1xyXG5cclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbmF4b24ucmVnaXN0ZXIoICdUaW55UHJvcGVydHknLCBUaW55UHJvcGVydHkgKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsSUFBSSxNQUFNLFdBQVc7QUFDNUIsT0FBT0MsV0FBVyxNQUFNLGtCQUFrQjtBQVUxQyxlQUFlLE1BQU1DLFlBQVksU0FBWUQsV0FBVyxDQUEyRDtFQUUvRjs7RUFFbEI7RUFDQTtFQUdPRSxXQUFXQSxDQUFFQyxLQUFRLEVBQUVDLGNBQXFELEVBQUVDLDRCQUFzQyxFQUFHO0lBQzVILEtBQUssQ0FBRUQsY0FBYyxFQUFFQyw0QkFBNkIsQ0FBQztJQUVyRCxJQUFJLENBQUNDLE1BQU0sR0FBR0gsS0FBSztFQUNyQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDU0ksR0FBR0EsQ0FBQSxFQUFNO0lBQ2QsT0FBTyxJQUFJLENBQUNELE1BQU07RUFDcEI7O0VB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