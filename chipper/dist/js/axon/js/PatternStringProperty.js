// Copyright 2022-2023, University of Colorado Boulder

/**
 * A DerivedProperty that applies a string pattern (like StringUtils.fillIn). It has options for mapping values,
 * either with decimalPlaces or an arbitrary function so that there is just one Property set up for disposal.
 *
 * PatternStringPropertyTests.ts has many examples that may be useful!
 *
 * Basic usage can involve values as Properties or directly as values (both work):
 *
 * | const patternStringProperty = new TinyProperty( '{{valueA}} + {{valueB}}' );
 * | const property = new PatternStringProperty( patternStringProperty, {
 * |   valueA: 5,
 * |   valueB: new TinyProperty( 7 )
 * | } );
 * | property.value; // '5 + 7'
 *
 * Did your string use StringUtils.format? formatNames can be used to be compatible:
 *
 * | const property = new PatternStringProperty( new TinyProperty( '{0} + {1}' ), {
 * |   valueA: 5,
 * |   valueB: new TinyProperty( 7 )
 * | }, {
 * |   formatNames: [ 'valueA', 'valueB' ]
 * | } );
 * | property.value; // '5 + 7'
 *
 * Want to apply unit conversions or other formulas? Use maps
 *
 * | const gramsProperty = new TinyProperty( 2000 );
 * | new PatternStringProperty( new TinyProperty( '{{kilograms}} kg' ), {
 * |   kilograms: gramsProperty
 * | }, {
 * |   maps: {
 * |     kilograms: ( grams: number ) => grams / 1000
 * |   }
 * | } );
 * | property.value; // '2 kg'
 *
 * Using a numeric value, and want to show a certain number of decimal places? Use decimalPlaces!
 *
 * | const gramsProperty = new TinyProperty( 2143 );
 * | new PatternStringProperty( new TinyProperty( '{{kilograms}} kg' ), {
 * |   kilograms: gramsProperty
 * | }, {
 * |   maps: {
 * |     kilograms: ( grams: number ) => grams / 1000
 * |   },
 * |   decimalPlaces: 2
 * | } );
 * | property.value; // '2.14 kg'
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import DerivedProperty from './DerivedProperty.js';
import ReadOnlyProperty from './ReadOnlyProperty.js';
import TinyProperty from './TinyProperty.js';
import Utils from '../../dot/js/Utils.js';
import optionize from '../../phet-core/js/optionize.js';
import StringIO from '../../tandem/js/types/StringIO.js';
import axon from './axon.js';
import Tandem from '../../tandem/js/Tandem.js';

// The type of allowed values for a PatternStringProperty

// The types of values that we won't require maps for

// We'll require maps for things that aren't string | number, or Property types with only those values

// Shared here, since it will always be the same function
const stringify = value => `${value}`;
export default class PatternStringProperty extends DerivedProperty {
  constructor(patternProperty, values, providedOptions) {
    assert && assert(!(values.tandem instanceof Tandem), 'Did you intend to put tandem in providedOptions?');
    const options = optionize()({
      formatNames: [],
      decimalPlaces: null,
      phetioValueType: StringIO
    }, providedOptions);
    const dependencies = [patternProperty];
    const maps = {};
    const keys = Object.keys(values);
    keys.forEach(key => {
      const value = values[key]; // This is the declared type anyway, TypeScript is needing the cast
      if (value instanceof ReadOnlyProperty || value instanceof TinyProperty) {
        dependencies.push(value);
      }
      let stringNumberMap = stringify;

      // If we are applying decimal places, "prepend" that map before the others
      if (options.decimalPlaces !== null && (typeof options.decimalPlaces === 'number' || options.decimalPlaces[key] !== null)) {
        // It won't be null (we checked above for hasDecimalPlaces), asserted below
        const decimalPlaces = typeof options.decimalPlaces === 'number' || options.decimalPlaces === null ? options.decimalPlaces : options.decimalPlaces[key];
        assert && assert(decimalPlaces !== null);
        stringNumberMap = value => stringify(typeof value === 'number' ? Utils.toFixed(value, decimalPlaces) : value);
      }

      // If we are applying a map, "prepend" that map before the others, so that if it returns a number, we can
      // apply decimal places to it.
      if (options.maps && options.maps.hasOwnProperty(key)) {
        maps[key] = value => stringNumberMap(options.maps[key](value));
      } else {
        maps[key] = stringNumberMap;
      }
    });

    // @ts-expect-error We can't get our dependencies to dynamically type here fully
    super(dependencies, (...propertyValues) => {
      const getValue = value => {
        const index = dependencies.indexOf(value);

        // If it's a Property, it will be in our dependencies, and we'll look up the value from our DerivedProperty
        return index >= 0 ? propertyValues[index] : value;
      };
      let result = `${getValue(patternProperty)}`; // String cast (it won't be a number, due to TypeScript)

      // Handle StringUtils.format compatibility, turning {0} => formatName[ 0 ], {1} => formatName[ 1 ], etc.
      options.formatNames.forEach((formatName, index) => {
        result = result.replace(new RegExp(`\\{${index}\\}`, 'g'), `{{${formatName}}}`);
      });

      // {string[]} parse out the set of placeholders
      const placeholders = result.match(/\{\{[^{}]+\}\}/g) || [];

      // replace each placeholder with its corresponding value
      for (let i = 0; i < placeholders.length; i++) {
        const placeholder = placeholders[i];

        // key is the portion of the placeholder between the curly braces
        const key = placeholder.replace('{{', '').replace('}}', '');
        if (keys.includes(key)) {
          let value = getValue(values[key]);
          if (maps[key]) {
            value = maps[key](value);
          }
          result = result.replace(placeholder, `${value}`);
        }
      }
      return result;
    }, options);
  }
}
axon.register('PatternStringProperty', PatternStringProperty);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEZXJpdmVkUHJvcGVydHkiLCJSZWFkT25seVByb3BlcnR5IiwiVGlueVByb3BlcnR5IiwiVXRpbHMiLCJvcHRpb25pemUiLCJTdHJpbmdJTyIsImF4b24iLCJUYW5kZW0iLCJzdHJpbmdpZnkiLCJ2YWx1ZSIsIlBhdHRlcm5TdHJpbmdQcm9wZXJ0eSIsImNvbnN0cnVjdG9yIiwicGF0dGVyblByb3BlcnR5IiwidmFsdWVzIiwicHJvdmlkZWRPcHRpb25zIiwiYXNzZXJ0IiwidGFuZGVtIiwib3B0aW9ucyIsImZvcm1hdE5hbWVzIiwiZGVjaW1hbFBsYWNlcyIsInBoZXRpb1ZhbHVlVHlwZSIsImRlcGVuZGVuY2llcyIsIm1hcHMiLCJrZXlzIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsInB1c2giLCJzdHJpbmdOdW1iZXJNYXAiLCJ0b0ZpeGVkIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wZXJ0eVZhbHVlcyIsImdldFZhbHVlIiwiaW5kZXgiLCJpbmRleE9mIiwicmVzdWx0IiwiZm9ybWF0TmFtZSIsInJlcGxhY2UiLCJSZWdFeHAiLCJwbGFjZWhvbGRlcnMiLCJtYXRjaCIsImkiLCJsZW5ndGgiLCJwbGFjZWhvbGRlciIsImluY2x1ZGVzIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJQYXR0ZXJuU3RyaW5nUHJvcGVydHkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjItMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSBEZXJpdmVkUHJvcGVydHkgdGhhdCBhcHBsaWVzIGEgc3RyaW5nIHBhdHRlcm4gKGxpa2UgU3RyaW5nVXRpbHMuZmlsbEluKS4gSXQgaGFzIG9wdGlvbnMgZm9yIG1hcHBpbmcgdmFsdWVzLFxyXG4gKiBlaXRoZXIgd2l0aCBkZWNpbWFsUGxhY2VzIG9yIGFuIGFyYml0cmFyeSBmdW5jdGlvbiBzbyB0aGF0IHRoZXJlIGlzIGp1c3Qgb25lIFByb3BlcnR5IHNldCB1cCBmb3IgZGlzcG9zYWwuXHJcbiAqXHJcbiAqIFBhdHRlcm5TdHJpbmdQcm9wZXJ0eVRlc3RzLnRzIGhhcyBtYW55IGV4YW1wbGVzIHRoYXQgbWF5IGJlIHVzZWZ1bCFcclxuICpcclxuICogQmFzaWMgdXNhZ2UgY2FuIGludm9sdmUgdmFsdWVzIGFzIFByb3BlcnRpZXMgb3IgZGlyZWN0bHkgYXMgdmFsdWVzIChib3RoIHdvcmspOlxyXG4gKlxyXG4gKiB8IGNvbnN0IHBhdHRlcm5TdHJpbmdQcm9wZXJ0eSA9IG5ldyBUaW55UHJvcGVydHkoICd7e3ZhbHVlQX19ICsge3t2YWx1ZUJ9fScgKTtcclxuICogfCBjb25zdCBwcm9wZXJ0eSA9IG5ldyBQYXR0ZXJuU3RyaW5nUHJvcGVydHkoIHBhdHRlcm5TdHJpbmdQcm9wZXJ0eSwge1xyXG4gKiB8ICAgdmFsdWVBOiA1LFxyXG4gKiB8ICAgdmFsdWVCOiBuZXcgVGlueVByb3BlcnR5KCA3IClcclxuICogfCB9ICk7XHJcbiAqIHwgcHJvcGVydHkudmFsdWU7IC8vICc1ICsgNydcclxuICpcclxuICogRGlkIHlvdXIgc3RyaW5nIHVzZSBTdHJpbmdVdGlscy5mb3JtYXQ/IGZvcm1hdE5hbWVzIGNhbiBiZSB1c2VkIHRvIGJlIGNvbXBhdGlibGU6XHJcbiAqXHJcbiAqIHwgY29uc3QgcHJvcGVydHkgPSBuZXcgUGF0dGVyblN0cmluZ1Byb3BlcnR5KCBuZXcgVGlueVByb3BlcnR5KCAnezB9ICsgezF9JyApLCB7XHJcbiAqIHwgICB2YWx1ZUE6IDUsXHJcbiAqIHwgICB2YWx1ZUI6IG5ldyBUaW55UHJvcGVydHkoIDcgKVxyXG4gKiB8IH0sIHtcclxuICogfCAgIGZvcm1hdE5hbWVzOiBbICd2YWx1ZUEnLCAndmFsdWVCJyBdXHJcbiAqIHwgfSApO1xyXG4gKiB8IHByb3BlcnR5LnZhbHVlOyAvLyAnNSArIDcnXHJcbiAqXHJcbiAqIFdhbnQgdG8gYXBwbHkgdW5pdCBjb252ZXJzaW9ucyBvciBvdGhlciBmb3JtdWxhcz8gVXNlIG1hcHNcclxuICpcclxuICogfCBjb25zdCBncmFtc1Byb3BlcnR5ID0gbmV3IFRpbnlQcm9wZXJ0eSggMjAwMCApO1xyXG4gKiB8IG5ldyBQYXR0ZXJuU3RyaW5nUHJvcGVydHkoIG5ldyBUaW55UHJvcGVydHkoICd7e2tpbG9ncmFtc319IGtnJyApLCB7XHJcbiAqIHwgICBraWxvZ3JhbXM6IGdyYW1zUHJvcGVydHlcclxuICogfCB9LCB7XHJcbiAqIHwgICBtYXBzOiB7XHJcbiAqIHwgICAgIGtpbG9ncmFtczogKCBncmFtczogbnVtYmVyICkgPT4gZ3JhbXMgLyAxMDAwXHJcbiAqIHwgICB9XHJcbiAqIHwgfSApO1xyXG4gKiB8IHByb3BlcnR5LnZhbHVlOyAvLyAnMiBrZydcclxuICpcclxuICogVXNpbmcgYSBudW1lcmljIHZhbHVlLCBhbmQgd2FudCB0byBzaG93IGEgY2VydGFpbiBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXM/IFVzZSBkZWNpbWFsUGxhY2VzIVxyXG4gKlxyXG4gKiB8IGNvbnN0IGdyYW1zUHJvcGVydHkgPSBuZXcgVGlueVByb3BlcnR5KCAyMTQzICk7XHJcbiAqIHwgbmV3IFBhdHRlcm5TdHJpbmdQcm9wZXJ0eSggbmV3IFRpbnlQcm9wZXJ0eSggJ3t7a2lsb2dyYW1zfX0ga2cnICksIHtcclxuICogfCAgIGtpbG9ncmFtczogZ3JhbXNQcm9wZXJ0eVxyXG4gKiB8IH0sIHtcclxuICogfCAgIG1hcHM6IHtcclxuICogfCAgICAga2lsb2dyYW1zOiAoIGdyYW1zOiBudW1iZXIgKSA9PiBncmFtcyAvIDEwMDBcclxuICogfCAgIH0sXHJcbiAqIHwgICBkZWNpbWFsUGxhY2VzOiAyXHJcbiAqIHwgfSApO1xyXG4gKiB8IHByb3BlcnR5LnZhbHVlOyAvLyAnMi4xNCBrZydcclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBEZXJpdmVkUHJvcGVydHksIHsgRGVyaXZlZFByb3BlcnR5T3B0aW9ucyB9IGZyb20gJy4vRGVyaXZlZFByb3BlcnR5LmpzJztcclxuaW1wb3J0IFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi9SZWFkT25seVByb3BlcnR5LmpzJztcclxuaW1wb3J0IFRpbnlQcm9wZXJ0eSBmcm9tICcuL1RpbnlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBUUmVhZE9ubHlQcm9wZXJ0eSBmcm9tICcuL1RSZWFkT25seVByb3BlcnR5LmpzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xyXG5pbXBvcnQgQ29sbGFwc2VQcm9wZXJ0eVZhbHVlIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9Db2xsYXBzZVByb3BlcnR5VmFsdWUuanMnO1xyXG5pbXBvcnQgS2V5c01hdGNoaW5nIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9LZXlzTWF0Y2hpbmcuanMnO1xyXG5pbXBvcnQgS2V5c05vdE1hdGNoaW5nIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9LZXlzTm90TWF0Y2hpbmcuanMnO1xyXG5pbXBvcnQgU3RyaW5nSU8gZnJvbSAnLi4vLi4vdGFuZGVtL2pzL3R5cGVzL1N0cmluZ0lPLmpzJztcclxuaW1wb3J0IGF4b24gZnJvbSAnLi9heG9uLmpzJztcclxuaW1wb3J0IFRhbmRlbSBmcm9tICcuLi8uLi90YW5kZW0vanMvVGFuZGVtLmpzJztcclxuXHJcbi8vIFRoZSB0eXBlIG9mIGFsbG93ZWQgdmFsdWVzIGZvciBhIFBhdHRlcm5TdHJpbmdQcm9wZXJ0eVxyXG50eXBlIFZhbHVlc1R5cGUgPSBSZWNvcmQ8c3RyaW5nLCBJbnRlbnRpb25hbEFueT47XHJcblxyXG4vLyBUaGUgdHlwZXMgb2YgdmFsdWVzIHRoYXQgd2Ugd29uJ3QgcmVxdWlyZSBtYXBzIGZvclxyXG50eXBlIFN0cmluZ051bWJlck9yUHJvcGVydHkgPSBzdHJpbmcgfCBudW1iZXIgfCBUUmVhZE9ubHlQcm9wZXJ0eTxzdHJpbmc+IHwgVFJlYWRPbmx5UHJvcGVydHk8bnVtYmVyPiB8IFRSZWFkT25seVByb3BlcnR5PHN0cmluZyB8IG51bWJlcj47XHJcblxyXG4vLyBXZSdsbCByZXF1aXJlIG1hcHMgZm9yIHRoaW5ncyB0aGF0IGFyZW4ndCBzdHJpbmcgfCBudW1iZXIsIG9yIFByb3BlcnR5IHR5cGVzIHdpdGggb25seSB0aG9zZSB2YWx1ZXNcclxudHlwZSBNYXBzVHlwZTxWYWx1ZXMgZXh0ZW5kcyBWYWx1ZXNUeXBlPiA9IHtcclxuICBbS2V5IGluIEtleXNNYXRjaGluZzxWYWx1ZXMsIFN0cmluZ051bWJlck9yUHJvcGVydHk+XT86ICggdmFsdWU6IENvbGxhcHNlUHJvcGVydHlWYWx1ZTxWYWx1ZXNbS2V5XT4gKSA9PiBzdHJpbmcgfCBudW1iZXI7XHJcbn0gJiB7XHJcbiAgW0tleSBpbiBLZXlzTm90TWF0Y2hpbmc8VmFsdWVzLCBTdHJpbmdOdW1iZXJPclByb3BlcnR5Pl06ICggdmFsdWU6IENvbGxhcHNlUHJvcGVydHlWYWx1ZTxWYWx1ZXNbS2V5XT4gKSA9PiBzdHJpbmcgfCBudW1iZXI7XHJcbn07XHJcblxyXG50eXBlIE9wdGlvbmFsU2VsZk9wdGlvbnM8VmFsdWVzIGV4dGVuZHMgVmFsdWVzVHlwZT4gPSB7XHJcbiAgLy8gRm9yIGhhbmRsaW5nIHBhdHRlcm4gc3RyaW5ncyBmcm9tIFN0cmluZ1V0aWxzLmZvcm1hdCwgd2hpY2ggd2lsbCB0dXJuIHswfSA9PiB7e2Zvcm1hdE5hbWVbIDAgXX19LFxyXG4gIC8vIHsxfSA9PiB7e2Zvcm1hdE5hbWVbIDEgXX19LCBldGMuXHJcbiAgLy9cclxuICAvLyBGb3IgZXhhbXBsZTpcclxuICAvLyB8IGNvbnN0IHN0cmluZ1Byb3BlcnR5ID0gbmV3IFRpbnlQcm9wZXJ0eSggJ1Rlc3Q6IHswfScgKTtcclxuICAvLyB8IGNvbnN0IHZhbHVlUHJvcGVydHkgPSBuZXcgVGlueVByb3BlcnR5KCA1ICk7XHJcbiAgLy8gfCBuZXcgUGF0dGVyblN0cmluZ1Byb3BlcnR5KCBzdHJpbmdQcm9wZXJ0eSwgeyB2YWx1ZTogdmFsdWVQcm9wZXJ0eSB9LCB7IGZvcm1hdE5hbWVzOiBbICd2YWx1ZScgXSB9ICk7XHJcbiAgLy8gV2lsbCBlZmZlY3RpdmVseSByZXBsYWNlIHswfSBpbiB0aGUgcGF0dGVybiB0byB7e3ZhbHVlfX0sIHdoaWNoIHdpbGwgdGhlbiBiZSB1c2VkIGFzIG5vcm1hbFxyXG4gIGZvcm1hdE5hbWVzPzogc3RyaW5nW107XHJcblxyXG4gIC8vIFJvdW5kcyBudW1lcmljIHZhbHVlcyB0byBhIGdpdmVuIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpZiBwcm92aWRlZC4gSWYgYSBudW1iZXIgaXMgZ2l2ZW4sIGl0IHdpbGwgYXBwbHkgdG9cclxuICAvLyBBTEwgbnVtZXJpYyB2YWx1ZXMgKG9mIHR5cGUgJ251bWJlcicpLiBBIHJlY29yZCBjYW4gYWxzbyBiZSBwcm92aWRlZCB0aGF0IHByb3ZpZGVzIGRlY2ltYWxQbGFjZXMgZm9yIHNwZWNpZmljXHJcbiAgLy8gdmFsdWVzLlxyXG4gIC8vXHJcbiAgLy8gRm9yIGV4YW1wbGU6XHJcbiAgLy8gfCBjb25zdCBzdHJpbmdQcm9wZXJ0eSA9IG5ldyBUaW55UHJvcGVydHkoICdUZXN0OiB7e3ZhbHVlfX0nICk7XHJcbiAgLy8gfCBjb25zdCB2YWx1ZVByb3BlcnR5ID0gbmV3IFRpbnlQcm9wZXJ0eSggNS4xMjM0NSApO1xyXG4gIC8vIHwgbmV3IFBhdHRlcm5TdHJpbmdQcm9wZXJ0eSggc3RyaW5nUHJvcGVydHksIHsgdmFsdWU6IHZhbHVlUHJvcGVydHkgfSwgeyBkZWNpbWFsUGxhY2VzOiAyIH0gKVxyXG4gIC8vIHdpbGwgdGFrZSB0aGUgdmFsdWUgJ1Rlc3Q6IDUuMTInLlxyXG4gIC8vXHJcbiAgLy8gTXVsdGlwbGUgZGVjaW1hbCBwbGFjZXMgZXhhbXBsZTpcclxuICAvLyB8IGNvbnN0IHN0cmluZ1Byb3BlcnR5ID0gbmV3IFRpbnlQcm9wZXJ0eSggJ1RoZXJlIGFyZSB7e3NxdWlycmVsc319IG1pbGxpb24gc3F1aXJyZWxzIHdobyBlYXQgbW9yZSB0aGFuIHt7YWNvcm5zfX0gYWNvcm5zIGEgZGF5JyApO1xyXG4gIC8vIHwgY29uc3Qgc3F1aXJyZWxzUHJvcGVydHkgPSBuZXcgVGlueVByb3BlcnR5KCA1LjEyMzQ1ICk7XHJcbiAgLy8gfCBjb25zdCBhY29ybnNQcm9wZXJ0eSA9IG5ldyBUaW55UHJvcGVydHkoIDIwLjI1NCApO1xyXG4gIC8vIHwgbmV3IFBhdHRlcm5TdHJpbmdQcm9wZXJ0eSggc3RyaW5nUHJvcGVydHksIHtcclxuICAvLyB8ICAgc3F1aXJyZWxzOiBzcXVpcnJlbHNQcm9wZXJ0eSxcclxuICAvLyB8ICAgYWNvcm5zOiBhY29ybnNQcm9wZXJ0eVxyXG4gIC8vIHwgfSwge1xyXG4gIC8vIHwgICBkZWNpbWFsUGxhY2VzOiB7XHJcbiAgLy8gfCAgICAgc3F1aXJyZWxzOiAwLFxyXG4gIC8vIHwgICAgIGFjb3JuczogMlxyXG4gIC8vIHwgICB9XHJcbiAgLy8gfCB9IClcclxuICAvL1xyXG4gIC8vIE5PVEU6IFByb3ZpZGUgbnVsbCBpZiBkZWNpbWFsIHBsYWNlcyBzaG91bGQgbm90IGJlIHVzZWQgZm9yIGEgZ2l2ZW4gdmFsdWVcclxuICBkZWNpbWFsUGxhY2VzPzogbnVtYmVyIHwgbnVsbCB8IFJlY29yZDxrZXlvZiBWYWx1ZXMsIG51bWJlciB8IG51bGw+O1xyXG59O1xyXG5cclxudHlwZSBTZWxmT3B0aW9uczxWYWx1ZXMgZXh0ZW5kcyBWYWx1ZXNUeXBlPiA9IE9wdGlvbmFsU2VsZk9wdGlvbnM8VmFsdWVzPiAmXHJcbiAgKCBLZXlzTm90TWF0Y2hpbmc8VmFsdWVzLCBTdHJpbmdOdW1iZXJPclByb3BlcnR5PiBleHRlbmRzIG5ldmVyID8ge1xyXG4gICAgLy8gTWFwcyB0aGUgaW5wdXQgc3RyaW5nL251bWVyaWMgdmFsdWVzIChkZXBlbmRpbmcgb24gdGhlIFByb3BlcnR5IHR5cGUpIHRvIGEgc3RyaW5nIG9yIG51bWJlci4gRGVjaW1hbCBwbGFjZXMgd2lsbCBiZVxyXG4gICAgLy8gYXBwbGllZCBhZnRlciB0aGlzIHN0ZXAgKGlmIGl0IHJldHVybnMgYSBudW1iZXIpLlxyXG4gICAgLy9cclxuICAgIC8vIEZvciBleGFtcGxlOlxyXG4gICAgLy8gfCBjb25zdCBzdHJpbmdQcm9wZXJ0eSA9IG5ldyBUaW55UHJvcGVydHkoICd7e2dyYW1zfX0gZ3JhbXMnICk7XHJcbiAgICAvLyB8IGNvbnN0IGtpbG9ncmFtc1Byb3BlcnR5ID0gbmV3IFRpbnlQcm9wZXJ0eSggNS4xMiApO1xyXG4gICAgLy8gfCBuZXcgUGF0dGVyblN0cmluZ1Byb3BlcnR5KCBzdHJpbmdQcm9wZXJ0eSwgeyBwcmVwb3NpdGlvbjoga2lsb2dyYW1zUHJvcGVydHkgfSwge1xyXG4gICAgLy8gfCAgIG1hcHM6IHsgcHJlcG9zaXRpb246IGtpbG9ncmFtcyA9PiBraWxvZ3JhbXMgLyAxMDAwIH1cclxuICAgIC8vIHwgfSApO1xyXG4gICAgbWFwcz86IE1hcHNUeXBlPFZhbHVlcz47XHJcbiAgfSA6IHtcclxuICAgICAgLy8gTWFrZSB0aGlzIHJlcXVpcmVkIGlmIHNvbWVvbmUncyBwYXNzaW5nIGluIHNvbWV0aGluZyB0aGF0IGlzIG9mIGEgbm9uLXN0cmluZy9udW1iZXIgdHlwZVxyXG4gICAgICBtYXBzOiBNYXBzVHlwZTxWYWx1ZXM+O1xyXG4gICAgfSApO1xyXG5cclxudHlwZSBTdXBlck9wdGlvbnMgPSBEZXJpdmVkUHJvcGVydHlPcHRpb25zPHN0cmluZz47XHJcbmV4cG9ydCB0eXBlIFBhdHRlcm5TdHJpbmdQcm9wZXJ0eU9wdGlvbnM8VmFsdWVzIGV4dGVuZHMgVmFsdWVzVHlwZT4gPSBTZWxmT3B0aW9uczxWYWx1ZXM+ICYgU3VwZXJPcHRpb25zO1xyXG5cclxuLy8gU2hhcmVkIGhlcmUsIHNpbmNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGZ1bmN0aW9uXHJcbmNvbnN0IHN0cmluZ2lmeSA9ICggdmFsdWU6IHN0cmluZyB8IG51bWJlciApOiBzdHJpbmcgPT4gYCR7dmFsdWV9YDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdHRlcm5TdHJpbmdQcm9wZXJ0eTxWYWx1ZXMgZXh0ZW5kcyBWYWx1ZXNUeXBlPiBleHRlbmRzIERlcml2ZWRQcm9wZXJ0eTxzdHJpbmcsXHJcbiAgdW5rbm93bixcclxuICB1bmtub3duLFxyXG4gIHVua25vd24sXHJcbiAgdW5rbm93bixcclxuICB1bmtub3duLFxyXG4gIHVua25vd24sXHJcbiAgdW5rbm93bixcclxuICB1bmtub3duLFxyXG4gIHVua25vd24sXHJcbiAgdW5rbm93bixcclxuICB1bmtub3duLFxyXG4gIHVua25vd24sXHJcbiAgdW5rbm93bixcclxuICB1bmtub3duLFxyXG4gIHVua25vd24+IHtcclxuICBwdWJsaWMgY29uc3RydWN0b3IoIHBhdHRlcm5Qcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8c3RyaW5nPiwgdmFsdWVzOiBWYWx1ZXMsIHByb3ZpZGVkT3B0aW9ucz86IFBhdHRlcm5TdHJpbmdQcm9wZXJ0eU9wdGlvbnM8VmFsdWVzPiApIHtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhKCB2YWx1ZXMudGFuZGVtIGluc3RhbmNlb2YgVGFuZGVtICksICdEaWQgeW91IGludGVuZCB0byBwdXQgdGFuZGVtIGluIHByb3ZpZGVkT3B0aW9ucz8nICk7XHJcblxyXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxPcHRpb25hbFNlbGZPcHRpb25zPFZhbHVlcz4gJiB7IG1hcHM/OiBNYXBzVHlwZTxWYWx1ZXM+IH0sIE9wdGlvbmFsU2VsZk9wdGlvbnM8VmFsdWVzPiwgU3VwZXJPcHRpb25zPigpKCB7XHJcbiAgICAgIGZvcm1hdE5hbWVzOiBbXSxcclxuXHJcbiAgICAgIGRlY2ltYWxQbGFjZXM6IG51bGwsXHJcblxyXG4gICAgICBwaGV0aW9WYWx1ZVR5cGU6IFN0cmluZ0lPXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICBjb25zdCBkZXBlbmRlbmNpZXM6IFRSZWFkT25seVByb3BlcnR5PEludGVudGlvbmFsQW55PltdID0gWyBwYXR0ZXJuUHJvcGVydHkgXTtcclxuICAgIGNvbnN0IG1hcHM6IFJlY29yZDxrZXlvZiBWYWx1ZXMsICggdmFsdWU6IEludGVudGlvbmFsQW55ICkgPT4gc3RyaW5nPiA9IHt9IGFzIEludGVudGlvbmFsQW55O1xyXG5cclxuICAgIGNvbnN0IGtleXM6ICgga2V5b2YgVmFsdWVzIClbXSA9IE9iamVjdC5rZXlzKCB2YWx1ZXMgKTtcclxuICAgIGtleXMuZm9yRWFjaCgga2V5ID0+IHtcclxuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbIGtleSBdIGFzIEludGVudGlvbmFsQW55OyAvLyBUaGlzIGlzIHRoZSBkZWNsYXJlZCB0eXBlIGFueXdheSwgVHlwZVNjcmlwdCBpcyBuZWVkaW5nIHRoZSBjYXN0XHJcbiAgICAgIGlmICggdmFsdWUgaW5zdGFuY2VvZiBSZWFkT25seVByb3BlcnR5IHx8IHZhbHVlIGluc3RhbmNlb2YgVGlueVByb3BlcnR5ICkge1xyXG4gICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKCB2YWx1ZSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgc3RyaW5nTnVtYmVyTWFwOiAoIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgKSA9PiBzdHJpbmcgPSBzdHJpbmdpZnk7XHJcblxyXG4gICAgICAvLyBJZiB3ZSBhcmUgYXBwbHlpbmcgZGVjaW1hbCBwbGFjZXMsIFwicHJlcGVuZFwiIHRoYXQgbWFwIGJlZm9yZSB0aGUgb3RoZXJzXHJcbiAgICAgIGlmICggb3B0aW9ucy5kZWNpbWFsUGxhY2VzICE9PSBudWxsICYmICggdHlwZW9mIG9wdGlvbnMuZGVjaW1hbFBsYWNlcyA9PT0gJ251bWJlcicgfHwgb3B0aW9ucy5kZWNpbWFsUGxhY2VzWyBrZXkgXSAhPT0gbnVsbCApICkge1xyXG4gICAgICAgIC8vIEl0IHdvbid0IGJlIG51bGwgKHdlIGNoZWNrZWQgYWJvdmUgZm9yIGhhc0RlY2ltYWxQbGFjZXMpLCBhc3NlcnRlZCBiZWxvd1xyXG4gICAgICAgIGNvbnN0IGRlY2ltYWxQbGFjZXM6IG51bWJlciA9ICggdHlwZW9mIG9wdGlvbnMuZGVjaW1hbFBsYWNlcyA9PT0gJ251bWJlcicgfHwgb3B0aW9ucy5kZWNpbWFsUGxhY2VzID09PSBudWxsIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZGVjaW1hbFBsYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9ucy5kZWNpbWFsUGxhY2VzWyBrZXkgXSE7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggZGVjaW1hbFBsYWNlcyAhPT0gbnVsbCApO1xyXG5cclxuICAgICAgICBzdHJpbmdOdW1iZXJNYXAgPSAoIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgKSA9PiBzdHJpbmdpZnkoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBVdGlscy50b0ZpeGVkKCB2YWx1ZSwgZGVjaW1hbFBsYWNlcyApIDogdmFsdWUgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgd2UgYXJlIGFwcGx5aW5nIGEgbWFwLCBcInByZXBlbmRcIiB0aGF0IG1hcCBiZWZvcmUgdGhlIG90aGVycywgc28gdGhhdCBpZiBpdCByZXR1cm5zIGEgbnVtYmVyLCB3ZSBjYW5cclxuICAgICAgLy8gYXBwbHkgZGVjaW1hbCBwbGFjZXMgdG8gaXQuXHJcbiAgICAgIGlmICggb3B0aW9ucy5tYXBzICYmIG9wdGlvbnMubWFwcy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XHJcbiAgICAgICAgbWFwc1sga2V5IF0gPSB2YWx1ZSA9PiBzdHJpbmdOdW1iZXJNYXAoIG9wdGlvbnMubWFwcyFbIGtleSBdKCB2YWx1ZSApICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbWFwc1sga2V5IF0gPSBzdHJpbmdOdW1iZXJNYXA7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGNhbid0IGdldCBvdXIgZGVwZW5kZW5jaWVzIHRvIGR5bmFtaWNhbGx5IHR5cGUgaGVyZSBmdWxseVxyXG4gICAgc3VwZXIoIGRlcGVuZGVuY2llcywgKCAuLi5wcm9wZXJ0eVZhbHVlczogdW5rbm93bltdICkgPT4ge1xyXG5cclxuICAgICAgY29uc3QgZ2V0VmFsdWUgPSAoIHZhbHVlOiB1bmtub3duICk6IHVua25vd24gPT4ge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGVwZW5kZW5jaWVzLmluZGV4T2YoIHZhbHVlIGFzIEludGVudGlvbmFsQW55ICk7XHJcblxyXG4gICAgICAgIC8vIElmIGl0J3MgYSBQcm9wZXJ0eSwgaXQgd2lsbCBiZSBpbiBvdXIgZGVwZW5kZW5jaWVzLCBhbmQgd2UnbGwgbG9vayB1cCB0aGUgdmFsdWUgZnJvbSBvdXIgRGVyaXZlZFByb3BlcnR5XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyBwcm9wZXJ0eVZhbHVlc1sgaW5kZXggXSA6IHZhbHVlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgbGV0IHJlc3VsdCA9IGAke2dldFZhbHVlKCBwYXR0ZXJuUHJvcGVydHkgKX1gOyAvLyBTdHJpbmcgY2FzdCAoaXQgd29uJ3QgYmUgYSBudW1iZXIsIGR1ZSB0byBUeXBlU2NyaXB0KVxyXG5cclxuICAgICAgLy8gSGFuZGxlIFN0cmluZ1V0aWxzLmZvcm1hdCBjb21wYXRpYmlsaXR5LCB0dXJuaW5nIHswfSA9PiBmb3JtYXROYW1lWyAwIF0sIHsxfSA9PiBmb3JtYXROYW1lWyAxIF0sIGV0Yy5cclxuICAgICAgb3B0aW9ucy5mb3JtYXROYW1lcy5mb3JFYWNoKCAoIGZvcm1hdE5hbWU6IHN0cmluZywgaW5kZXg6IG51bWJlciApID0+IHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSggbmV3IFJlZ0V4cCggYFxcXFx7JHtpbmRleH1cXFxcfWAsICdnJyApLCBge3ske2Zvcm1hdE5hbWV9fX1gICk7XHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICAgIC8vIHtzdHJpbmdbXX0gcGFyc2Ugb3V0IHRoZSBzZXQgb2YgcGxhY2Vob2xkZXJzXHJcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVycyA9IHJlc3VsdC5tYXRjaCggL1xce1xce1tee31dK1xcfVxcfS9nICkgfHwgW107XHJcblxyXG4gICAgICAvLyByZXBsYWNlIGVhY2ggcGxhY2Vob2xkZXIgd2l0aCBpdHMgY29ycmVzcG9uZGluZyB2YWx1ZVxyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBwbGFjZWhvbGRlcnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcnNbIGkgXTtcclxuXHJcbiAgICAgICAgLy8ga2V5IGlzIHRoZSBwb3J0aW9uIG9mIHRoZSBwbGFjZWhvbGRlciBiZXR3ZWVuIHRoZSBjdXJseSBicmFjZXNcclxuICAgICAgICBjb25zdCBrZXkgPSBwbGFjZWhvbGRlci5yZXBsYWNlKCAne3snLCAnJyApLnJlcGxhY2UoICd9fScsICcnICk7XHJcbiAgICAgICAgaWYgKCBrZXlzLmluY2x1ZGVzKCBrZXkgKSApIHtcclxuICAgICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKCB2YWx1ZXNbIGtleSBdICk7XHJcbiAgICAgICAgICBpZiAoIG1hcHNbIGtleSBdICkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG1hcHNbIGtleSBdKCB2YWx1ZSApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoIHBsYWNlaG9sZGVyLCBgJHt2YWx1ZX1gICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSwgb3B0aW9ucyApO1xyXG4gIH1cclxufVxyXG5cclxuYXhvbi5yZWdpc3RlciggJ1BhdHRlcm5TdHJpbmdQcm9wZXJ0eScsIFBhdHRlcm5TdHJpbmdQcm9wZXJ0eSApO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGVBQWUsTUFBa0Msc0JBQXNCO0FBQzlFLE9BQU9DLGdCQUFnQixNQUFNLHVCQUF1QjtBQUNwRCxPQUFPQyxZQUFZLE1BQU0sbUJBQW1CO0FBRTVDLE9BQU9DLEtBQUssTUFBTSx1QkFBdUI7QUFDekMsT0FBT0MsU0FBUyxNQUFNLGlDQUFpQztBQUt2RCxPQUFPQyxRQUFRLE1BQU0sbUNBQW1DO0FBQ3hELE9BQU9DLElBQUksTUFBTSxXQUFXO0FBQzVCLE9BQU9DLE1BQU0sTUFBTSwyQkFBMkI7O0FBRTlDOztBQUdBOztBQUdBOztBQWtFQTtBQUNBLE1BQU1DLFNBQVMsR0FBS0MsS0FBc0IsSUFBZSxHQUFFQSxLQUFNLEVBQUM7QUFFbEUsZUFBZSxNQUFNQyxxQkFBcUIsU0FBb0NWLGVBQWUsQ0FlbEY7RUFDRlcsV0FBV0EsQ0FBRUMsZUFBMEMsRUFBRUMsTUFBYyxFQUFFQyxlQUFzRCxFQUFHO0lBRXZJQyxNQUFNLElBQUlBLE1BQU0sQ0FBRSxFQUFHRixNQUFNLENBQUNHLE1BQU0sWUFBWVQsTUFBTSxDQUFFLEVBQUUsa0RBQW1ELENBQUM7SUFFNUcsTUFBTVUsT0FBTyxHQUFHYixTQUFTLENBQXVHLENB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