// Copyright 2015-2023, University of Colorado Boulder

/**
 * Lightweight event & listener abstraction for a single event type.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */

import axon from './axon.js';
import Random from '../../dot/js/Random.js';
import dotRandom from '../../dot/js/dotRandom.js';

// constants
const listenerOrder = _.hasIn(window, 'phet.chipper.queryParameters') && phet.chipper.queryParameters.listenerOrder;
const listenerLimit = _.hasIn(window, 'phet.chipper.queryParameters') && phet.chipper.queryParameters.listenerLimit;
let random = null;
if (listenerOrder && listenerOrder.startsWith('random')) {
  // NOTE: this regular expression must be maintained in initialize-globals as well.
  const match = listenerOrder.match(/random(?:%28|\()(\d+)(?:%29|\))/);
  const seed = match ? Number(match[1]) : dotRandom.nextInt(1000000);
  random = new Random({
    seed: seed
  });
  console.log('listenerOrder random seed: ' + random.seed);
}
// Store the number of listeners from the single TinyEmitter instance that has the most listeners in the whole runtime.
let maxListenerCount = 0;
export default class TinyEmitter {
  // Not defined usually because of memory usage. If defined, this will be called when the listener count changes,
  // e.g. changeCount( {number} listenersAddedQuantity ), with the number being negative for listeners removed.

  // Only defined when assertions are enabled - to keep track if it has been disposed or not

  // If specified, this will be called before listeners are notified.

  // If specified as true, this flag will ensure that listener order never changes (like via ?listenerOrder=random)

  // The listeners that will be called on emit

  // During emit() keep track of iteration progress and guard listeners if mutated during emit()

  constructor(onBeforeNotify, hasListenerOrderDependencies) {
    if (onBeforeNotify) {
      this.onBeforeNotify = onBeforeNotify;
    }
    if (hasListenerOrderDependencies) {
      this.hasListenerOrderDependencies = hasListenerOrderDependencies;
    }
    this.listeners = new Set();
    this.emitContexts = [];

    // for production memory concerns; no need to keep this around.
    if (assert) {
      this.isDisposed = false;
    }
  }

  /**
   * Disposes an Emitter. All listeners are removed.
   */
  dispose() {
    this.removeAllListeners();
    if (assert) {
      this.isDisposed = true;
    }
  }

  /**
   * Notify listeners
   */
  emit(...args) {
    assert && assert(!this.isDisposed, 'should not be called if disposed');

    // optional callback, before notifying listeners
    this.onBeforeNotify && this.onBeforeNotify.apply(null, args);

    // Support for a query parameter that shuffles listeners, but bury behind assert so it will be stripped out on build
    // so it won't impact production performance.
    if (assert && listenerOrder && listenerOrder !== 'default' && !this.hasListenerOrderDependencies) {
      const asArray = Array.from(this.listeners);
      const reorderedListeners = listenerOrder.startsWith('random') ? random.shuffle(asArray) : asArray.reverse();
      this.listeners = new Set(reorderedListeners);
    }

    // Notify wired-up listeners, if any
    if (this.listeners.size > 0) {
      const emitContext = {
        index: 0
        // listenerArray: [] // {Array.<function>|undefined} assigned if a mutation is made during emit
      };

      this.emitContexts.push(emitContext);
      for (const listener of this.listeners) {
        listener(...args);
        emitContext.index++;

        // If a listener was added or removed, we cannot continue processing the mutated Set, we must switch to
        // iterate over the guarded array
        if (emitContext.listenerArray) {
          break;
        }
      }

      // If the listeners were guarded during emit, we bailed out on the for..of and continue iterating over the original
      // listeners in order from where we left off.
      if (emitContext.listenerArray) {
        for (let i = emitContext.index; i < emitContext.listenerArray.length; i++) {
          emitContext.listenerArray[i](...args);
        }
      }
      this.emitContexts.pop();
    }
  }

  /**
   * Adds a listener which will be called during emit.
   */
  addListener(listener) {
    assert && assert(!this.isDisposed, 'Cannot add a listener to a disposed TinyEmitter');
    assert && assert(!this.hasListener(listener), 'Cannot add the same listener twice');

    // If a listener is added during an emit(), we must make a copy of the current list of listeners--the newly added
    // listener will be available for the next emit() but not the one in progress.  This is to match behavior with
    // removeListener.
    this.guardListeners();
    this.listeners.add(listener);
    this.changeCount && this.changeCount(1);
    if (assert && listenerLimit && isFinite(listenerLimit) && maxListenerCount < this.listeners.size) {
      maxListenerCount = this.listeners.size;
      console.log(`Max TinyEmitter listeners: ${maxListenerCount}`);
      assert(maxListenerCount <= listenerLimit, `listener count of ${maxListenerCount} above ?listenerLimit=${listenerLimit}`);
    }
  }

  /**
   * Removes a listener
   */
  removeListener(listener) {
    // Throw an error when removing a non-listener (except when the Emitter has already been disposed, see
    // https://github.com/phetsims/sun/issues/394#issuecomment-419998231
    if (assert && !this.isDisposed) {
      assert(this.listeners.has(listener), 'tried to removeListener on something that wasn\'t a listener');
    }
    this.guardListeners();
    this.listeners.delete(listener);
    this.changeCount && this.changeCount(-1);
  }

  /**
   * Removes all the listeners
   */
  removeAllListeners() {
    const size = this.listeners.size;
    this.guardListeners();
    this.listeners.clear();
    this.changeCount && this.changeCount(-size);
  }

  /**
   * If listeners are added/removed while emit() is in progress, we must make a defensive copy of the array of listeners
   * before changing the array, and use it for the rest of the notifications until the emit call has completed.
   */
  guardListeners() {
    for (let i = this.emitContexts.length - 1; i >= 0; i--) {
      // Once we meet a level that was already guarded, we can stop, since all previous levels were already guarded
      if (this.emitContexts[i].listenerArray) {
        break;
      } else {
        // Mark copies as 'guarded' so that it will use the original listeners when emit started and not the modified
        // list.
        this.emitContexts[i].listenerArray = Array.from(this.listeners);
      }
    }
  }

  /**
   * Checks whether a listener is registered with this Emitter
   */
  hasListener(listener) {
    assert && assert(arguments.length === 1, 'Emitter.hasListener should be called with 1 argument');
    return this.listeners.has(listener);
  }

  /**
   * Returns true if there are any listeners.
   */
  hasListeners() {
    assert && assert(arguments.length === 0, 'Emitter.hasListeners should be called without arguments');
    return this.listeners.size > 0;
  }

  /**
   * Returns the number of listeners.
   */
  getListenerCount() {
    return this.listeners.size;
  }

  /**
   * Invokes a callback once for each listener - meant for Property's use
   */
  forEachListener(callback) {
    this.listeners.forEach(callback);
  }
}
axon.register('TinyEmitter', TinyEmitter);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJheG9uIiwiUmFuZG9tIiwiZG90UmFuZG9tIiwibGlzdGVuZXJPcmRlciIsIl8iLCJoYXNJbiIsIndpbmRvdyIsInBoZXQiLCJjaGlwcGVyIiwicXVlcnlQYXJhbWV0ZXJzIiwibGlzdGVuZXJMaW1pdCIsInJhbmRvbSIsInN0YXJ0c1dpdGgiLCJtYXRjaCIsInNlZWQiLCJOdW1iZXIiLCJuZXh0SW50IiwiY29uc29sZSIsImxvZyIsIm1heExpc3RlbmVyQ291bnQiLCJUaW55RW1pdHRlciIsImNvbnN0cnVjdG9yIiwib25CZWZvcmVOb3RpZnkiLCJoYXNMaXN0ZW5lck9yZGVyRGVwZW5kZW5jaWVzIiwibGlzdGVuZXJzIiwiU2V0IiwiZW1pdENvbnRleHRzIiwiYXNzZXJ0IiwiaXNEaXNwb3NlZCIsImRpc3Bvc2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwiYXJncyIsImFwcGx5IiwiYXNBcnJheSIsIkFycmF5IiwiZnJvbSIsInJlb3JkZXJlZExpc3RlbmVycyIsInNodWZmbGUiLCJyZXZlcnNlIiwic2l6ZSIsImVtaXRDb250ZXh0IiwiaW5kZXgiLCJwdXNoIiwibGlzdGVuZXIiLCJsaXN0ZW5lckFycmF5IiwiaSIsImxlbmd0aCIsInBvcCIsImFkZExpc3RlbmVyIiwiaGFzTGlzdGVuZXIiLCJndWFyZExpc3RlbmVycyIsImFkZCIsImNoYW5nZUNvdW50IiwiaXNGaW5pdGUiLCJyZW1vdmVMaXN0ZW5lciIsImhhcyIsImRlbGV0ZSIsImNsZWFyIiwiYXJndW1lbnRzIiwiaGFzTGlzdGVuZXJzIiwiZ2V0TGlzdGVuZXJDb3VudCIsImZvckVhY2hMaXN0ZW5lciIsImNhbGxiYWNrIiwiZm9yRWFjaCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiVGlueUVtaXR0ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogTGlnaHR3ZWlnaHQgZXZlbnQgJiBsaXN0ZW5lciBhYnN0cmFjdGlvbiBmb3IgYSBzaW5nbGUgZXZlbnQgdHlwZS5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBNaWNoYWVsIEthdXptYW5uIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xyXG5pbXBvcnQgYXhvbiBmcm9tICcuL2F4b24uanMnO1xyXG5pbXBvcnQgVEVtaXR0ZXIsIHsgVEVtaXR0ZXJMaXN0ZW5lciwgVEVtaXR0ZXJQYXJhbWV0ZXIgfSBmcm9tICcuL1RFbWl0dGVyLmpzJztcclxuaW1wb3J0IFJhbmRvbSBmcm9tICcuLi8uLi9kb3QvanMvUmFuZG9tLmpzJztcclxuaW1wb3J0IGRvdFJhbmRvbSBmcm9tICcuLi8uLi9kb3QvanMvZG90UmFuZG9tLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBsaXN0ZW5lck9yZGVyID0gXy5oYXNJbiggd2luZG93LCAncGhldC5jaGlwcGVyLnF1ZXJ5UGFyYW1ldGVycycgKSAmJiBwaGV0LmNoaXBwZXIucXVlcnlQYXJhbWV0ZXJzLmxpc3RlbmVyT3JkZXI7XHJcbmNvbnN0IGxpc3RlbmVyTGltaXQgPSBfLmhhc0luKCB3aW5kb3csICdwaGV0LmNoaXBwZXIucXVlcnlQYXJhbWV0ZXJzJyApICYmIHBoZXQuY2hpcHBlci5xdWVyeVBhcmFtZXRlcnMubGlzdGVuZXJMaW1pdDtcclxuXHJcbmxldCByYW5kb206IFJhbmRvbSB8IG51bGwgPSBudWxsO1xyXG5pZiAoIGxpc3RlbmVyT3JkZXIgJiYgbGlzdGVuZXJPcmRlci5zdGFydHNXaXRoKCAncmFuZG9tJyApICkge1xyXG5cclxuICAvLyBOT1RFOiB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBtdXN0IGJlIG1haW50YWluZWQgaW4gaW5pdGlhbGl6ZS1nbG9iYWxzIGFzIHdlbGwuXHJcbiAgY29uc3QgbWF0Y2ggPSBsaXN0ZW5lck9yZGVyLm1hdGNoKCAvcmFuZG9tKD86JTI4fFxcKCkoXFxkKykoPzolMjl8XFwpKS8gKTtcclxuICBjb25zdCBzZWVkID0gbWF0Y2ggPyBOdW1iZXIoIG1hdGNoWyAxIF0gKSA6IGRvdFJhbmRvbS5uZXh0SW50KCAxMDAwMDAwICk7XHJcbiAgcmFuZG9tID0gbmV3IFJhbmRvbSggeyBzZWVkOiBzZWVkIH0gKTtcclxuICBjb25zb2xlLmxvZyggJ2xpc3RlbmVyT3JkZXIgcmFuZG9tIHNlZWQ6ICcgKyByYW5kb20uc2VlZCApO1xyXG59XHJcblxyXG5cclxudHlwZSBFbWl0Q29udGV4dDxUIGV4dGVuZHMgSW50ZW50aW9uYWxBbnlbXT4gPSB7XHJcbiAgaW5kZXg6IG51bWJlcjtcclxuICBsaXN0ZW5lckFycmF5PzogVEVtaXR0ZXJMaXN0ZW5lcjxUPltdO1xyXG59O1xyXG5cclxuLy8gU3RvcmUgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgZnJvbSB0aGUgc2luZ2xlIFRpbnlFbWl0dGVyIGluc3RhbmNlIHRoYXQgaGFzIHRoZSBtb3N0IGxpc3RlbmVycyBpbiB0aGUgd2hvbGUgcnVudGltZS5cclxubGV0IG1heExpc3RlbmVyQ291bnQgPSAwO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlueUVtaXR0ZXI8VCBleHRlbmRzIFRFbWl0dGVyUGFyYW1ldGVyW10gPSBbXT4gaW1wbGVtZW50cyBURW1pdHRlcjxUPiB7XHJcblxyXG4gIC8vIE5vdCBkZWZpbmVkIHVzdWFsbHkgYmVjYXVzZSBvZiBtZW1vcnkgdXNhZ2UuIElmIGRlZmluZWQsIHRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgbGlzdGVuZXIgY291bnQgY2hhbmdlcyxcclxuICAvLyBlLmcuIGNoYW5nZUNvdW50KCB7bnVtYmVyfSBsaXN0ZW5lcnNBZGRlZFF1YW50aXR5ICksIHdpdGggdGhlIG51bWJlciBiZWluZyBuZWdhdGl2ZSBmb3IgbGlzdGVuZXJzIHJlbW92ZWQuXHJcbiAgcHVibGljIGNoYW5nZUNvdW50PzogKCBjb3VudDogbnVtYmVyICkgPT4gdm9pZDtcclxuXHJcbiAgLy8gT25seSBkZWZpbmVkIHdoZW4gYXNzZXJ0aW9ucyBhcmUgZW5hYmxlZCAtIHRvIGtlZXAgdHJhY2sgaWYgaXQgaGFzIGJlZW4gZGlzcG9zZWQgb3Igbm90XHJcbiAgcHVibGljIGlzRGlzcG9zZWQ/OiBib29sZWFuO1xyXG5cclxuICAvLyBJZiBzcGVjaWZpZWQsIHRoaXMgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGxpc3RlbmVycyBhcmUgbm90aWZpZWQuXHJcbiAgcHJpdmF0ZSByZWFkb25seSBvbkJlZm9yZU5vdGlmeT86IFRFbWl0dGVyTGlzdGVuZXI8VD4gfCBudWxsO1xyXG5cclxuICAvLyBJZiBzcGVjaWZpZWQgYXMgdHJ1ZSwgdGhpcyBmbGFnIHdpbGwgZW5zdXJlIHRoYXQgbGlzdGVuZXIgb3JkZXIgbmV2ZXIgY2hhbmdlcyAobGlrZSB2aWEgP2xpc3RlbmVyT3JkZXI9cmFuZG9tKVxyXG4gIHByaXZhdGUgcmVhZG9ubHkgaGFzTGlzdGVuZXJPcmRlckRlcGVuZGVuY2llcz86IGJvb2xlYW4gfCBudWxsO1xyXG5cclxuICAvLyBUaGUgbGlzdGVuZXJzIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZW1pdFxyXG4gIHByaXZhdGUgbGlzdGVuZXJzOiBTZXQ8VEVtaXR0ZXJMaXN0ZW5lcjxUPj47XHJcblxyXG4gIC8vIER1cmluZyBlbWl0KCkga2VlcCB0cmFjayBvZiBpdGVyYXRpb24gcHJvZ3Jlc3MgYW5kIGd1YXJkIGxpc3RlbmVycyBpZiBtdXRhdGVkIGR1cmluZyBlbWl0KClcclxuICBwcml2YXRlIGVtaXRDb250ZXh0czogRW1pdENvbnRleHQ8VD5bXTtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBvbkJlZm9yZU5vdGlmeT86IFRFbWl0dGVyTGlzdGVuZXI8VD4gfCBudWxsLCBoYXNMaXN0ZW5lck9yZGVyRGVwZW5kZW5jaWVzPzogYm9vbGVhbiB8IG51bGwgKSB7XHJcblxyXG4gICAgaWYgKCBvbkJlZm9yZU5vdGlmeSApIHtcclxuICAgICAgdGhpcy5vbkJlZm9yZU5vdGlmeSA9IG9uQmVmb3JlTm90aWZ5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICggaGFzTGlzdGVuZXJPcmRlckRlcGVuZGVuY2llcyApIHtcclxuICAgICAgdGhpcy5oYXNMaXN0ZW5lck9yZGVyRGVwZW5kZW5jaWVzID0gaGFzTGlzdGVuZXJPcmRlckRlcGVuZGVuY2llcztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICB0aGlzLmVtaXRDb250ZXh0cyA9IFtdO1xyXG5cclxuICAgIC8vIGZvciBwcm9kdWN0aW9uIG1lbW9yeSBjb25jZXJuczsgbm8gbmVlZCB0byBrZWVwIHRoaXMgYXJvdW5kLlxyXG4gICAgaWYgKCBhc3NlcnQgKSB7XHJcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcG9zZXMgYW4gRW1pdHRlci4gQWxsIGxpc3RlbmVycyBhcmUgcmVtb3ZlZC5cclxuICAgKi9cclxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcblxyXG4gICAgaWYgKCBhc3NlcnQgKSB7XHJcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3RpZnkgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgcHVibGljIGVtaXQoIC4uLmFyZ3M6IFQgKTogdm9pZCB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhdGhpcy5pc0Rpc3Bvc2VkLCAnc2hvdWxkIG5vdCBiZSBjYWxsZWQgaWYgZGlzcG9zZWQnICk7XHJcblxyXG4gICAgLy8gb3B0aW9uYWwgY2FsbGJhY2ssIGJlZm9yZSBub3RpZnlpbmcgbGlzdGVuZXJzXHJcbiAgICB0aGlzLm9uQmVmb3JlTm90aWZ5ICYmIHRoaXMub25CZWZvcmVOb3RpZnkuYXBwbHkoIG51bGwsIGFyZ3MgKTtcclxuXHJcbiAgICAvLyBTdXBwb3J0IGZvciBhIHF1ZXJ5IHBhcmFtZXRlciB0aGF0IHNodWZmbGVzIGxpc3RlbmVycywgYnV0IGJ1cnkgYmVoaW5kIGFzc2VydCBzbyBpdCB3aWxsIGJlIHN0cmlwcGVkIG91dCBvbiBidWlsZFxyXG4gICAgLy8gc28gaXQgd29uJ3QgaW1wYWN0IHByb2R1Y3Rpb24gcGVyZm9ybWFuY2UuXHJcbiAgICBpZiAoIGFzc2VydCAmJiBsaXN0ZW5lck9yZGVyICYmICggbGlzdGVuZXJPcmRlciAhPT0gJ2RlZmF1bHQnICkgJiYgIXRoaXMuaGFzTGlzdGVuZXJPcmRlckRlcGVuZGVuY2llcyApIHtcclxuICAgICAgY29uc3QgYXNBcnJheSA9IEFycmF5LmZyb20oIHRoaXMubGlzdGVuZXJzICk7XHJcblxyXG4gICAgICBjb25zdCByZW9yZGVyZWRMaXN0ZW5lcnMgPSBsaXN0ZW5lck9yZGVyLnN0YXJ0c1dpdGgoICdyYW5kb20nICkgPyByYW5kb20hLnNodWZmbGUoIGFzQXJyYXkgKSA6IGFzQXJyYXkucmV2ZXJzZSgpO1xyXG4gICAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBTZXQoIHJlb3JkZXJlZExpc3RlbmVycyApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdGlmeSB3aXJlZC11cCBsaXN0ZW5lcnMsIGlmIGFueVxyXG4gICAgaWYgKCB0aGlzLmxpc3RlbmVycy5zaXplID4gMCApIHtcclxuXHJcbiAgICAgIGNvbnN0IGVtaXRDb250ZXh0OiBFbWl0Q29udGV4dDxUPiA9IHtcclxuICAgICAgICBpbmRleDogMFxyXG4gICAgICAgIC8vIGxpc3RlbmVyQXJyYXk6IFtdIC8vIHtBcnJheS48ZnVuY3Rpb24+fHVuZGVmaW5lZH0gYXNzaWduZWQgaWYgYSBtdXRhdGlvbiBpcyBtYWRlIGR1cmluZyBlbWl0XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZW1pdENvbnRleHRzLnB1c2goIGVtaXRDb250ZXh0ICk7XHJcblxyXG4gICAgICBmb3IgKCBjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyApIHtcclxuICAgICAgICBsaXN0ZW5lciggLi4uYXJncyApO1xyXG4gICAgICAgIGVtaXRDb250ZXh0LmluZGV4Kys7XHJcblxyXG4gICAgICAgIC8vIElmIGEgbGlzdGVuZXIgd2FzIGFkZGVkIG9yIHJlbW92ZWQsIHdlIGNhbm5vdCBjb250aW51ZSBwcm9jZXNzaW5nIHRoZSBtdXRhdGVkIFNldCwgd2UgbXVzdCBzd2l0Y2ggdG9cclxuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGd1YXJkZWQgYXJyYXlcclxuICAgICAgICBpZiAoIGVtaXRDb250ZXh0Lmxpc3RlbmVyQXJyYXkgKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHRoZSBsaXN0ZW5lcnMgd2VyZSBndWFyZGVkIGR1cmluZyBlbWl0LCB3ZSBiYWlsZWQgb3V0IG9uIHRoZSBmb3IuLm9mIGFuZCBjb250aW51ZSBpdGVyYXRpbmcgb3ZlciB0aGUgb3JpZ2luYWxcclxuICAgICAgLy8gbGlzdGVuZXJzIGluIG9yZGVyIGZyb20gd2hlcmUgd2UgbGVmdCBvZmYuXHJcbiAgICAgIGlmICggZW1pdENvbnRleHQubGlzdGVuZXJBcnJheSApIHtcclxuICAgICAgICBmb3IgKCBsZXQgaSA9IGVtaXRDb250ZXh0LmluZGV4OyBpIDwgZW1pdENvbnRleHQubGlzdGVuZXJBcnJheS5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgIGVtaXRDb250ZXh0Lmxpc3RlbmVyQXJyYXlbIGkgXSggLi4uYXJncyApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLmVtaXRDb250ZXh0cy5wb3AoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBsaXN0ZW5lciB3aGljaCB3aWxsIGJlIGNhbGxlZCBkdXJpbmcgZW1pdC5cclxuICAgKi9cclxuICBwdWJsaWMgYWRkTGlzdGVuZXIoIGxpc3RlbmVyOiBURW1pdHRlckxpc3RlbmVyPFQ+ICk6IHZvaWQge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIXRoaXMuaXNEaXNwb3NlZCwgJ0Nhbm5vdCBhZGQgYSBsaXN0ZW5lciB0byBhIGRpc3Bvc2VkIFRpbnlFbWl0dGVyJyApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIXRoaXMuaGFzTGlzdGVuZXIoIGxpc3RlbmVyICksICdDYW5ub3QgYWRkIHRoZSBzYW1lIGxpc3RlbmVyIHR3aWNlJyApO1xyXG5cclxuICAgIC8vIElmIGEgbGlzdGVuZXIgaXMgYWRkZWQgZHVyaW5nIGFuIGVtaXQoKSwgd2UgbXVzdCBtYWtlIGEgY29weSBvZiB0aGUgY3VycmVudCBsaXN0IG9mIGxpc3RlbmVycy0tdGhlIG5ld2x5IGFkZGVkXHJcbiAgICAvLyBsaXN0ZW5lciB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgdGhlIG5leHQgZW1pdCgpIGJ1dCBub3QgdGhlIG9uZSBpbiBwcm9ncmVzcy4gIFRoaXMgaXMgdG8gbWF0Y2ggYmVoYXZpb3Igd2l0aFxyXG4gICAgLy8gcmVtb3ZlTGlzdGVuZXIuXHJcbiAgICB0aGlzLmd1YXJkTGlzdGVuZXJzKCk7XHJcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQoIGxpc3RlbmVyICk7XHJcblxyXG4gICAgdGhpcy5jaGFuZ2VDb3VudCAmJiB0aGlzLmNoYW5nZUNvdW50KCAxICk7XHJcblxyXG4gICAgaWYgKCBhc3NlcnQgJiYgbGlzdGVuZXJMaW1pdCAmJiBpc0Zpbml0ZSggbGlzdGVuZXJMaW1pdCApICYmIG1heExpc3RlbmVyQ291bnQgPCB0aGlzLmxpc3RlbmVycy5zaXplICkge1xyXG4gICAgICBtYXhMaXN0ZW5lckNvdW50ID0gdGhpcy5saXN0ZW5lcnMuc2l6ZTtcclxuICAgICAgY29uc29sZS5sb2coIGBNYXggVGlueUVtaXR0ZXIgbGlzdGVuZXJzOiAke21heExpc3RlbmVyQ291bnR9YCApO1xyXG4gICAgICBhc3NlcnQoIG1heExpc3RlbmVyQ291bnQgPD0gbGlzdGVuZXJMaW1pdCwgYGxpc3RlbmVyIGNvdW50IG9mICR7bWF4TGlzdGVuZXJDb3VudH0gYWJvdmUgP2xpc3RlbmVyTGltaXQ9JHtsaXN0ZW5lckxpbWl0fWAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYSBsaXN0ZW5lclxyXG4gICAqL1xyXG4gIHB1YmxpYyByZW1vdmVMaXN0ZW5lciggbGlzdGVuZXI6IFRFbWl0dGVyTGlzdGVuZXI8VD4gKTogdm9pZCB7XHJcblxyXG4gICAgLy8gVGhyb3cgYW4gZXJyb3Igd2hlbiByZW1vdmluZyBhIG5vbi1saXN0ZW5lciAoZXhjZXB0IHdoZW4gdGhlIEVtaXR0ZXIgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCwgc2VlXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc3VuL2lzc3Vlcy8zOTQjaXNzdWVjb21tZW50LTQxOTk5ODIzMVxyXG4gICAgaWYgKCBhc3NlcnQgJiYgIXRoaXMuaXNEaXNwb3NlZCApIHtcclxuICAgICAgYXNzZXJ0KCB0aGlzLmxpc3RlbmVycy5oYXMoIGxpc3RlbmVyICksICd0cmllZCB0byByZW1vdmVMaXN0ZW5lciBvbiBzb21ldGhpbmcgdGhhdCB3YXNuXFwndCBhIGxpc3RlbmVyJyApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ndWFyZExpc3RlbmVycygpO1xyXG4gICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKCBsaXN0ZW5lciApO1xyXG5cclxuICAgIHRoaXMuY2hhbmdlQ291bnQgJiYgdGhpcy5jaGFuZ2VDb3VudCggLTEgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYWxsIHRoZSBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBwdWJsaWMgcmVtb3ZlQWxsTGlzdGVuZXJzKCk6IHZvaWQge1xyXG5cclxuICAgIGNvbnN0IHNpemUgPSB0aGlzLmxpc3RlbmVycy5zaXplO1xyXG5cclxuICAgIHRoaXMuZ3VhcmRMaXN0ZW5lcnMoKTtcclxuICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XHJcblxyXG4gICAgdGhpcy5jaGFuZ2VDb3VudCAmJiB0aGlzLmNoYW5nZUNvdW50KCAtc2l6ZSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgbGlzdGVuZXJzIGFyZSBhZGRlZC9yZW1vdmVkIHdoaWxlIGVtaXQoKSBpcyBpbiBwcm9ncmVzcywgd2UgbXVzdCBtYWtlIGEgZGVmZW5zaXZlIGNvcHkgb2YgdGhlIGFycmF5IG9mIGxpc3RlbmVyc1xyXG4gICAqIGJlZm9yZSBjaGFuZ2luZyB0aGUgYXJyYXksIGFuZCB1c2UgaXQgZm9yIHRoZSByZXN0IG9mIHRoZSBub3RpZmljYXRpb25zIHVudGlsIHRoZSBlbWl0IGNhbGwgaGFzIGNvbXBsZXRlZC5cclxuICAgKi9cclxuICBwcml2YXRlIGd1YXJkTGlzdGVuZXJzKCk6IHZvaWQge1xyXG5cclxuICAgIGZvciAoIGxldCBpID0gdGhpcy5lbWl0Q29udGV4dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XHJcblxyXG4gICAgICAvLyBPbmNlIHdlIG1lZXQgYSBsZXZlbCB0aGF0IHdhcyBhbHJlYWR5IGd1YXJkZWQsIHdlIGNhbiBzdG9wLCBzaW5jZSBhbGwgcHJldmlvdXMgbGV2ZWxzIHdlcmUgYWxyZWFkeSBndWFyZGVkXHJcbiAgICAgIGlmICggdGhpcy5lbWl0Q29udGV4dHNbIGkgXS5saXN0ZW5lckFycmF5ICkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBNYXJrIGNvcGllcyBhcyAnZ3VhcmRlZCcgc28gdGhhdCBpdCB3aWxsIHVzZSB0aGUgb3JpZ2luYWwgbGlzdGVuZXJzIHdoZW4gZW1pdCBzdGFydGVkIGFuZCBub3QgdGhlIG1vZGlmaWVkXHJcbiAgICAgICAgLy8gbGlzdC5cclxuICAgICAgICB0aGlzLmVtaXRDb250ZXh0c1sgaSBdLmxpc3RlbmVyQXJyYXkgPSBBcnJheS5mcm9tKCB0aGlzLmxpc3RlbmVycyApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3Mgd2hldGhlciBhIGxpc3RlbmVyIGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIEVtaXR0ZXJcclxuICAgKi9cclxuICBwdWJsaWMgaGFzTGlzdGVuZXIoIGxpc3RlbmVyOiBURW1pdHRlckxpc3RlbmVyPFQ+ICk6IGJvb2xlYW4ge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSwgJ0VtaXR0ZXIuaGFzTGlzdGVuZXIgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIDEgYXJndW1lbnQnICk7XHJcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuaGFzKCBsaXN0ZW5lciApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBhbnkgbGlzdGVuZXJzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBoYXNMaXN0ZW5lcnMoKTogYm9vbGVhbiB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBhcmd1bWVudHMubGVuZ3RoID09PSAwLCAnRW1pdHRlci5oYXNMaXN0ZW5lcnMgc2hvdWxkIGJlIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cycgKTtcclxuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zaXplID4gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXHJcbiAgICovXHJcbiAgcHVibGljIGdldExpc3RlbmVyQ291bnQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zaXplO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlcyBhIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggbGlzdGVuZXIgLSBtZWFudCBmb3IgUHJvcGVydHkncyB1c2VcclxuICAgKi9cclxuICBwdWJsaWMgZm9yRWFjaExpc3RlbmVyKCBjYWxsYmFjazogKCBsaXN0ZW5lcjogVEVtaXR0ZXJMaXN0ZW5lcjxUPiApID0+IHZvaWQgKTogdm9pZCB7XHJcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKCBjYWxsYmFjayApO1xyXG4gIH1cclxufVxyXG5cclxuYXhvbi5yZWdpc3RlciggJ1RpbnlFbWl0dGVyJywgVGlueUVtaXR0ZXIgKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0EsT0FBT0EsSUFBSSxNQUFNLFdBQVc7QUFFNUIsT0FBT0MsTUFBTSxNQUFNLHdCQUF3QjtBQUMzQyxPQUFPQyxTQUFTLE1BQU0sMkJBQTJCOztBQUVqRDtBQUNBLE1BQU1DLGFBQWEsR0FBR0MsQ0FBQyxDQUFDQyxLQUFLLENBQUVDLE1BQU0sRUFBRSw4QkFBK0IsQ0FBQyxJQUFJQyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsZUFBZSxDQUFDTixhQUFhO0FBQ3JILE1BQU1PLGFBQWEsR0FBR04sQ0FBQyxDQUFDQyxLQUFLLENBQUVDLE1BQU0sRUFBRSw4QkFBK0IsQ0FBQyxJQUFJQyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsZUFBZSxDQUFDQyxhQUFhO0FBRXJILElBQUlDLE1BQXFCLEdBQUcsSUFBSTtBQUNoQyxJQUFLUixhQUFhLElBQUlBLGFBQWEsQ0FBQ1MsVUFBVSxDQUFFLFFBQVMsQ0FBQyxFQUFHO0VBRTNEO0VBQ0EsTUFBTUMsS0FBSyxHQUFHVixhQUFhLENBQUNVLEtBQUssQ0FBRSxpQ0FBa0MsQ0FBQztFQUN0RSxNQUFNQyxJQUFJLEdBQUdELEtBQUssR0FBR0UsTUFBTSxDQUFFRixLQUFLLENBQUUsQ0FBQyxDQUFHLENBQUMsR0FBR1gsU0FBUyxDQUFDYyxPQUFPLENBQUUsT0FBUSxDQUFDO0VBQ3hFTCxNQUFNLEdB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