// Copyright 2019-2023, University of Colorado Boulder

/**
 * PopulationGraphNode displays the population graph. This graph is a performance concern, so plots are updated
 * only when they are visible, see PopulationPlotNode.updatePlot.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Bounds2 from '../../../../../dot/js/Bounds2.js';
import Vector2 from '../../../../../dot/js/Vector2.js';
import optionize from '../../../../../phet-core/js/optionize.js';
import PlusMinusZoomButtonGroup from '../../../../../scenery-phet/js/PlusMinusZoomButtonGroup.js';
import { Node, Rectangle, Text } from '../../../../../scenery/js/imports.js';
import naturalSelection from '../../../naturalSelection.js';
import NaturalSelectionStrings from '../../../NaturalSelectionStrings.js';
import NaturalSelectionConstants from '../../NaturalSelectionConstants.js';
import DataProbeNode from './DataProbeNode.js';
import PopulationGenerationScroller from './PopulationGenerationScroller.js';
import PopulationGridNode from './PopulationGridNode.js';
import PopulationPlotsNode from './PopulationPlotsNode.js';

// const
const X_TICK_MARKS_HEIGHT = 20; // height of x-axis tick marks, determined empirically
const X_AXIS_LABEL_SPACING = 7; // space between x-axis 'Generation' label/control and x-axis tick marks)
const Y_AXIS_LABEL_SPACING = 40; // space between y zoom control and y-axis (not y tick marks)

export default class PopulationGraphNode extends Node {
  constructor(populationModel, providedOptions) {
    const options = optionize()({
      // SelfOptions
      graphWidth: 100,
      graphHeight: 100,
      // NodeOptions
      phetioVisiblePropertyInstrumented: false
    }, providedOptions);

    // invisible rectangle that defines the bounds of this Node
    const boundsRectangle = new Rectangle(0, 0, options.graphWidth, options.graphHeight);

    // Generation (x-axis) scroll control
    const generationScroller = new PopulationGenerationScroller(populationModel.xRangeProperty, populationModel.timeInGenerationsProperty, populationModel.isPlayingProperty, {
      tandem: options.tandem.createTandem('generationScroller')
    });

    // y-axis (Population) label
    const yAxisLabelText = new Text(NaturalSelectionStrings.populationStringProperty, {
      font: NaturalSelectionConstants.POPULATION_AXIS_FONT,
      rotation: -Math.PI / 2,
      maxWidth: 90,
      // determined empirically
      tandem: options.tandem.createTandem('yAxisLabelText')
    });

    // Wrap yAxisLabelText because we'll be observing its boundsProperty.
    const yAxisLabelTextWrapper = new Node({
      children: [yAxisLabelText]
    });

    // Population (y-axis) zoom buttons
    const yZoomButtonGroup = new PlusMinusZoomButtonGroup(populationModel.yZoomLevelProperty, {
      orientation: 'vertical',
      touchAreaXDilation: 7,
      touchAreaYDilation: 4,
      left: boundsRectangle.left,
      top: boundsRectangle.top,
      tandem: options.tandem.createTandem('yZoomButtonGroup')
    });

    // Dimensions of the 2D grid (sans tick marks) in view coordinates
    const gridWidth = options.graphWidth - yZoomButtonGroup.width - Y_AXIS_LABEL_SPACING;
    const gridHeight = options.graphHeight - generationScroller.height - X_TICK_MARKS_HEIGHT - X_AXIS_LABEL_SPACING;

    // the 2D grid, including tick marks
    const gridNode = new PopulationGridNode(populationModel, {
      gridWidth: gridWidth,
      gridHeight: gridHeight,
      x: yZoomButtonGroup.right + Y_AXIS_LABEL_SPACING,
      y: boundsRectangle.top
    });

    // The complete set of plots
    const plotsNode = new PopulationPlotsNode(populationModel, {
      gridWidth: gridWidth,
      gridHeight: gridHeight,
      translation: gridNode.translation
    });
    const dataProbeNode = new DataProbeNode(populationModel, {
      gridWidth: gridWidth,
      gridHeight: gridHeight,
      offset: new Vector2(gridNode.x, 0),
      tandem: options.tandem.createTandem('dataProbeNode')
    });
    const zoomOutToSeeDataText = new Text(NaturalSelectionStrings.zoomOutToSeeDataStringProperty, {
      font: NaturalSelectionConstants.INSTRUCTIONS_FONT,
      maxWidth: 0.75 * gridWidth,
      centerX: gridNode.x + gridWidth / 2,
      centerY: gridNode.y + gridHeight / 2,
      tandem: options.tandem.createTandem('zoomOutToSeeDataText')
    });
    assert && assert(!options.children, 'PopulationGraphNode sets children');
    options.children = [boundsRectangle, gridNode, generationScroller, yZoomButtonGroup, yAxisLabelTextWrapper, plotsNode, zoomOutToSeeDataText, dataProbeNode];

    // Center x-axis control under the graph. unlink is not necessary.
    generationScroller.localBoundsProperty.link(() => {
      generationScroller.centerX = gridNode.x + gridWidth / 2;
      generationScroller.top = gridNode.bottom + X_AXIS_LABEL_SPACING;
    });

    // Center y-axis label to left of graph. unlink is not necessary.
    yAxisLabelText.localBoundsProperty.link(() => {
      yAxisLabelText.right = yZoomButtonGroup.right;
      yAxisLabelText.centerY = gridNode.y + gridHeight / 2;
    });

    // If the plot has data that is not visible, display 'Zoom out to see data.'
    // unlink is not necessary.
    const plotsNodeClipArea = plotsNode.clipArea;
    assert && assert(plotsNodeClipArea, 'plotsNode.clipArea is required');
    plotsNode.localBoundsProperty.link(localBounds => {
      zoomOutToSeeDataText.visible = !localBounds.equals(Bounds2.NOTHING) && !localBounds.intersectsBounds(plotsNodeClipArea.bounds);
    });
    super(options);
  }
  dispose() {
    assert && assert(false, 'dispose is not supported, exists for the lifetime of the sim');
    super.dispose();
  }
}
naturalSelection.register('PopulationGraphNode', PopulationGraphNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiVmVjdG9yMiIsIm9wdGlvbml6ZSIsIlBsdXNNaW51c1pvb21CdXR0b25Hcm91cCIsIk5vZGUiLCJSZWN0YW5nbGUiLCJUZXh0IiwibmF0dXJhbFNlbGVjdGlvbiIsIk5hdHVyYWxTZWxlY3Rpb25TdHJpbmdzIiwiTmF0dXJhbFNlbGVjdGlvbkNvbnN0YW50cyIsIkRhdGFQcm9iZU5vZGUiLCJQb3B1bGF0aW9uR2VuZXJhdGlvblNjcm9sbGVyIiwiUG9wdWxhdGlvbkdyaWROb2RlIiwiUG9wdWxhdGlvblBsb3RzTm9kZSIsIlhfVElDS19NQVJLU19IRUlHSFQiLCJYX0FYSVNfTEFCRUxfU1BBQ0lORyIsIllfQVhJU19MQUJFTF9TUEFDSU5HIiwiUG9wdWxhdGlvbkdyYXBoTm9kZSIsImNvbnN0cnVjdG9yIiwicG9wdWxhdGlvbk1vZGVsIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsImdyYXBoV2lkdGgiLCJncmFwaEhlaWdodCIsInBoZXRpb1Zpc2libGVQcm9wZXJ0eUluc3RydW1lbnRlZCIsImJvdW5kc1JlY3RhbmdsZSIsImdlbmVyYXRpb25TY3JvbGxlciIsInhSYW5nZVByb3BlcnR5IiwidGltZUluR2VuZXJhdGlvbnNQcm9wZXJ0eSIsImlzUGxheWluZ1Byb3BlcnR5IiwidGFuZGVtIiwiY3JlYXRlVGFuZGVtIiwieUF4aXNMYWJlbFRleHQiLCJwb3B1bGF0aW9uU3RyaW5nUHJvcGVydHkiLCJmb250IiwiUE9QVUxBVElPTl9BWElTX0ZPTlQiLCJyb3RhdGlvbiIsIk1hdGgiLCJQSSIsIm1heFdpZHRoIiwieUF4aXNMYWJlbFRleHRXcmFwcGVyIiwiY2hpbGRyZW4iLCJ5Wm9vbUJ1dHRvbkdyb3VwIiwieVpvb21MZXZlbFByb3BlcnR5Iiwib3JpZW50YXRpb24iLCJ0b3VjaEFyZWFYRGlsYXRpb24iLCJ0b3VjaEFyZWFZRGlsYXRpb24iLCJsZWZ0IiwidG9wIiwiZ3JpZFdpZHRoIiwid2lkdGgiLCJncmlkSGVpZ2h0IiwiaGVpZ2h0IiwiZ3JpZE5vZGUiLCJ4IiwicmlnaHQiLCJ5IiwicGxvdHNOb2RlIiwidHJhbnNsYXRpb24iLCJkYXRhUHJvYmVOb2RlIiwib2Zmc2V0Iiwiem9vbU91dFRvU2VlRGF0YVRleHQiLCJ6b29tT3V0VG9TZWVEYXRhU3RyaW5nUHJvcGVydHkiLCJJTlNUUlVDVElPTlNfRk9OVCIsImNlbnRlclgiLCJjZW50ZXJZIiwiYXNzZXJ0IiwibG9jYWxCb3VuZHNQcm9wZXJ0eSIsImxpbmsiLCJib3R0b20iLCJwbG90c05vZGVDbGlwQXJlYSIsImNsaXBBcmVhIiwibG9jYWxCb3VuZHMiLCJ2aXNpYmxlIiwiZXF1YWxzIiwiTk9USElORyIsImludGVyc2VjdHNCb3VuZHMiLCJib3VuZHMiLCJkaXNwb3NlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJQb3B1bGF0aW9uR3JhcGhOb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE5LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFBvcHVsYXRpb25HcmFwaE5vZGUgZGlzcGxheXMgdGhlIHBvcHVsYXRpb24gZ3JhcGguIFRoaXMgZ3JhcGggaXMgYSBwZXJmb3JtYW5jZSBjb25jZXJuLCBzbyBwbG90cyBhcmUgdXBkYXRlZFxyXG4gKiBvbmx5IHdoZW4gdGhleSBhcmUgdmlzaWJsZSwgc2VlIFBvcHVsYXRpb25QbG90Tm9kZS51cGRhdGVQbG90LlxyXG4gKlxyXG4gKiBAYXV0aG9yIENocmlzIE1hbGxleSAoUGl4ZWxab29tLCBJbmMuKVxyXG4gKi9cclxuXHJcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgUGlja1JlcXVpcmVkIGZyb20gJy4uLy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9QaWNrUmVxdWlyZWQuanMnO1xyXG5pbXBvcnQgUGx1c01pbnVzWm9vbUJ1dHRvbkdyb3VwIGZyb20gJy4uLy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9QbHVzTWludXNab29tQnV0dG9uR3JvdXAuanMnO1xyXG5pbXBvcnQgeyBOb2RlLCBOb2RlT3B0aW9ucywgTm9kZVRyYW5zbGF0aW9uT3B0aW9ucywgUmVjdGFuZ2xlLCBUZXh0IH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IG5hdHVyYWxTZWxlY3Rpb24gZnJvbSAnLi4vLi4vLi4vbmF0dXJhbFNlbGVjdGlvbi5qcyc7XHJcbmltcG9ydCBOYXR1cmFsU2VsZWN0aW9uU3RyaW5ncyBmcm9tICcuLi8uLi8uLi9OYXR1cmFsU2VsZWN0aW9uU3RyaW5ncy5qcyc7XHJcbmltcG9ydCBQb3B1bGF0aW9uTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvUG9wdWxhdGlvbk1vZGVsLmpzJztcclxuaW1wb3J0IE5hdHVyYWxTZWxlY3Rpb25Db25zdGFudHMgZnJvbSAnLi4vLi4vTmF0dXJhbFNlbGVjdGlvbkNvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBEYXRhUHJvYmVOb2RlIGZyb20gJy4vRGF0YVByb2JlTm9kZS5qcyc7XHJcbmltcG9ydCBQb3B1bGF0aW9uR2VuZXJhdGlvblNjcm9sbGVyIGZyb20gJy4vUG9wdWxhdGlvbkdlbmVyYXRpb25TY3JvbGxlci5qcyc7XHJcbmltcG9ydCBQb3B1bGF0aW9uR3JpZE5vZGUgZnJvbSAnLi9Qb3B1bGF0aW9uR3JpZE5vZGUuanMnO1xyXG5pbXBvcnQgUG9wdWxhdGlvblBsb3RzTm9kZSBmcm9tICcuL1BvcHVsYXRpb25QbG90c05vZGUuanMnO1xyXG5cclxuLy8gY29uc3RcclxuY29uc3QgWF9USUNLX01BUktTX0hFSUdIVCA9IDIwOyAvLyBoZWlnaHQgb2YgeC1heGlzIHRpY2sgbWFya3MsIGRldGVybWluZWQgZW1waXJpY2FsbHlcclxuY29uc3QgWF9BWElTX0xBQkVMX1NQQUNJTkcgPSA3OyAvLyBzcGFjZSBiZXR3ZWVuIHgtYXhpcyAnR2VuZXJhdGlvbicgbGFiZWwvY29udHJvbCBhbmQgeC1heGlzIHRpY2sgbWFya3MpXHJcbmNvbnN0IFlfQVhJU19MQUJFTF9TUEFDSU5HID0gNDA7IC8vIHNwYWNlIGJldHdlZW4geSB6b29tIGNvbnRyb2wgYW5kIHktYXhpcyAobm90IHkgdGljayBtYXJrcylcclxuXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSB7XHJcbiAgZ3JhcGhXaWR0aD86IG51bWJlcjtcclxuICBncmFwaEhlaWdodD86IG51bWJlcjtcclxufTtcclxuXHJcbnR5cGUgUG9wdWxhdGlvbkdyYXBoTm9kZU9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIE5vZGVUcmFuc2xhdGlvbk9wdGlvbnMgJiBQaWNrUmVxdWlyZWQ8Tm9kZU9wdGlvbnMsICd0YW5kZW0nPjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvcHVsYXRpb25HcmFwaE5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBwb3B1bGF0aW9uTW9kZWw6IFBvcHVsYXRpb25Nb2RlbCwgcHJvdmlkZWRPcHRpb25zOiBQb3B1bGF0aW9uR3JhcGhOb2RlT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPFBvcHVsYXRpb25HcmFwaE5vZGVPcHRpb25zLCBTZWxmT3B0aW9ucywgTm9kZU9wdGlvbnM+KCkoIHtcclxuXHJcbiAgICAgIC8vIFNlbGZPcHRpb25zXHJcbiAgICAgIGdyYXBoV2lkdGg6IDEwMCxcclxuICAgICAgZ3JhcGhIZWlnaHQ6IDEwMCxcclxuXHJcbiAgICAgIC8vIE5vZGVPcHRpb25zXHJcbiAgICAgIHBoZXRpb1Zpc2libGVQcm9wZXJ0eUluc3RydW1lbnRlZDogZmFsc2VcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIC8vIGludmlzaWJsZSByZWN0YW5nbGUgdGhhdCBkZWZpbmVzIHRoZSBib3VuZHMgb2YgdGhpcyBOb2RlXHJcbiAgICBjb25zdCBib3VuZHNSZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKCAwLCAwLCBvcHRpb25zLmdyYXBoV2lkdGgsIG9wdGlvbnMuZ3JhcGhIZWlnaHQgKTtcclxuXHJcbiAgICAvLyBHZW5lcmF0aW9uICh4LWF4aXMpIHNjcm9sbCBjb250cm9sXHJcbiAgICBjb25zdCBnZW5lcmF0aW9uU2Nyb2xsZXIgPSBuZXcgUG9wdWxhdGlvbkdlbmVyYXRpb25TY3JvbGxlcihcclxuICAgICAgcG9wdWxhdGlvbk1vZGVsLnhSYW5nZVByb3BlcnR5LCBwb3B1bGF0aW9uTW9kZWwudGltZUluR2VuZXJhdGlvbnNQcm9wZXJ0eSwgcG9wdWxhdGlvbk1vZGVsLmlzUGxheWluZ1Byb3BlcnR5LCB7XHJcbiAgICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICdnZW5lcmF0aW9uU2Nyb2xsZXInIClcclxuICAgICAgfSApO1xyXG5cclxuICAgIC8vIHktYXhpcyAoUG9wdWxhdGlvbikgbGFiZWxcclxuICAgIGNvbnN0IHlBeGlzTGFiZWxUZXh0ID0gbmV3IFRleHQoIE5hdHVyYWxTZWxlY3Rpb25TdHJpbmdzLnBvcHVsYXRpb25TdHJpbmdQcm9wZXJ0eSwge1xyXG4gICAgICBmb250OiBOYXR1cmFsU2VsZWN0aW9uQ29uc3RhbnRzLlBPUFVMQVRJT05fQVhJU19GT05ULFxyXG4gICAgICByb3RhdGlvbjogLU1hdGguUEkgLyAyLFxyXG4gICAgICBtYXhXaWR0aDogOTAsIC8vIGRldGVybWluZWQgZW1waXJpY2FsbHlcclxuICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICd5QXhpc0xhYmVsVGV4dCcgKVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFdyYXAgeUF4aXNMYWJlbFRleHQgYmVjYXVzZSB3ZSdsbCBiZSBvYnNlcnZpbmcgaXRzIGJvdW5kc1Byb3BlcnR5LlxyXG4gICAgY29uc3QgeUF4aXNMYWJlbFRleHRXcmFwcGVyID0gbmV3IE5vZGUoIHtcclxuICAgICAgY2hpbGRyZW46IFsgeUF4aXNMYWJlbFRleHQgXVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFBvcHVsYXRpb24gKHktYXhpcykgem9vbSBidXR0b25zXHJcbiAgICBjb25zdCB5Wm9vbUJ1dHRvbkdyb3VwID0gbmV3IFBsdXNNaW51c1pvb21CdXR0b25Hcm91cCggcG9wdWxhdGlvbk1vZGVsLnlab29tTGV2ZWxQcm9wZXJ0eSwge1xyXG4gICAgICBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcclxuICAgICAgdG91Y2hBcmVhWERpbGF0aW9uOiA3LFxyXG4gICAgICB0b3VjaEFyZWFZRGlsYXRpb246IDQsXHJcbiAgICAgIGxlZnQ6IGJvdW5kc1JlY3RhbmdsZS5sZWZ0LFxyXG4gICAgICB0b3A6IGJvdW5kc1JlY3RhbmdsZS50b3AsXHJcbiAgICAgIHRhbmRlbTogb3B0aW9ucy50YW5kZW0uY3JlYXRlVGFuZGVtKCAneVpvb21CdXR0b25Hcm91cCcgKVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIERpbWVuc2lvbnMgb2YgdGhlIDJEIGdyaWQgKHNhbnMgdGljayBtYXJrcykgaW4gdmlldyBjb29yZGluYXRlc1xyXG4gICAgY29uc3QgZ3JpZFdpZHRoID0gb3B0aW9ucy5ncmFwaFdpZHRoIC0geVpvb21CdXR0b25Hcm91cC53aWR0aCAtIFlfQVhJU19MQUJFTF9TUEFDSU5HO1xyXG4gICAgY29uc3QgZ3JpZEhlaWdodCA9IG9wdGlvbnMuZ3JhcGhIZWlnaHQgLSBnZW5lcmF0aW9uU2Nyb2xsZXIuaGVpZ2h0IC0gWF9USUNLX01BUktTX0hFSUdIVCAtIFhfQVhJU19MQUJFTF9TUEFDSU5HO1xyXG5cclxuICAgIC8vIHRoZSAyRCBncmlkLCBpbmNsdWRpbmcgdGljayBtYXJrc1xyXG4gICAgY29uc3QgZ3JpZE5vZGUgPSBuZXcgUG9wdWxhdGlvbkdyaWROb2RlKCBwb3B1bGF0aW9uTW9kZWwsIHtcclxuICAgICAgZ3JpZFdpZHRoOiBncmlkV2lkdGgsXHJcbiAgICAgIGdyaWRIZWlnaHQ6IGdyaWRIZWlnaHQsXHJcbiAgICAgIHg6IHlab29tQnV0dG9uR3JvdXAucmlnaHQgKyBZX0FYSVNfTEFCRUxfU1BBQ0lORyxcclxuICAgICAgeTogYm91bmRzUmVjdGFuZ2xlLnRvcFxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFRoZSBjb21wbGV0ZSBzZXQgb2YgcGxvdHNcclxuICAgIGNvbnN0IHBsb3RzTm9kZSA9IG5ldyBQb3B1bGF0aW9uUGxvdHNOb2RlKCBwb3B1bGF0aW9uTW9kZWwsIHtcclxuICAgICAgZ3JpZFdpZHRoOiBncmlkV2lkdGgsXHJcbiAgICAgIGdyaWRIZWlnaHQ6IGdyaWRIZWlnaHQsXHJcbiAgICAgIHRyYW5zbGF0aW9uOiBncmlkTm9kZS50cmFuc2xhdGlvblxyXG4gICAgfSApO1xyXG5cclxuICAgIGNvbnN0IGRhdGFQcm9iZU5vZGUgPSBuZXcgRGF0YVByb2JlTm9kZSggcG9wdWxhdGlvbk1vZGVsLCB7XHJcbiAgICAgIGdyaWRXaWR0aDogZ3JpZFdpZHRoLFxyXG4gICAgICBncmlkSGVpZ2h0OiBncmlkSGVpZ2h0LFxyXG4gICAgICBvZmZzZXQ6IG5ldyBWZWN0b3IyKCBncmlkTm9kZS54LCAwICksXHJcbiAgICAgIHRhbmRlbTogb3B0aW9ucy50YW5kZW0uY3JlYXRlVGFuZGVtKCAnZGF0YVByb2JlTm9kZScgKVxyXG4gICAgfSApO1xyXG5cclxuICAgIGNvbnN0IHpvb21PdXRUb1NlZURhdGFUZXh0ID0gbmV3IFRleHQoIE5hdHVyYWxTZWxlY3Rpb25TdHJpbmdzLnpvb21PdXRUb1NlZURhdGFTdHJpbmdQcm9wZXJ0eSwge1xyXG4gICAgICBmb250OiBOYXR1cmFsU2VsZWN0aW9uQ29uc3RhbnRzLklOU1RSVUNUSU9OU19GT05ULFxyXG4gICAgICBtYXhXaWR0aDogMC43NSAqIGdyaWRXaWR0aCxcclxuICAgICAgY2VudGVyWDogZ3JpZE5vZGUueCArIGdyaWRXaWR0aCAvIDIsXHJcbiAgICAgIGNlbnRlclk6IGdyaWROb2RlLnkgKyBncmlkSGVpZ2h0IC8gMixcclxuICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICd6b29tT3V0VG9TZWVEYXRhVGV4dCcgKVxyXG4gICAgfSApO1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICFvcHRpb25zLmNoaWxkcmVuLCAnUG9wdWxhdGlvbkdyYXBoTm9kZSBzZXRzIGNoaWxkcmVuJyApO1xyXG4gICAgb3B0aW9ucy5jaGlsZHJlbiA9IFtcclxuICAgICAgYm91bmRzUmVjdGFuZ2xlLCBncmlkTm9kZSxcclxuICAgICAgZ2VuZXJhdGlvblNjcm9sbGVyLFxyXG4gICAgICB5Wm9vbUJ1dHRvbkdyb3VwLCB5QXhpc0xhYmVsVGV4dFdyYXBwZXIsXHJcbiAgICAgIHBsb3RzTm9kZSxcclxuICAgICAgem9vbU91dFRvU2VlRGF0YVRleHQsXHJcbiAgICAgIGRhdGFQcm9iZU5vZGVcclxuICAgIF07XHJcblxyXG4gICAgLy8gQ2VudGVyIHgtYXhpcyBjb250cm9sIHVuZGVyIHRoZSBncmFwaC4gdW5saW5rIGlzIG5vdCBuZWNlc3NhcnkuXHJcbiAgICBnZW5lcmF0aW9uU2Nyb2xsZXIubG9jYWxCb3VuZHNQcm9wZXJ0eS5saW5rKCAoKSA9PiB7XHJcbiAgICAgIGdlbmVyYXRpb25TY3JvbGxlci5jZW50ZXJYID0gZ3JpZE5vZGUueCArICggZ3JpZFdpZHRoIC8gMiApO1xyXG4gICAgICBnZW5lcmF0aW9uU2Nyb2xsZXIudG9wID0gZ3JpZE5vZGUuYm90dG9tICsgWF9BWElTX0xBQkVMX1NQQUNJTkc7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gQ2VudGVyIHktYXhpcyBsYWJlbCB0byBsZWZ0IG9mIGdyYXBoLiB1bmxpbmsgaXMgbm90IG5lY2Vzc2FyeS5cclxuICAgIHlBeGlzTGFiZWxUZXh0LmxvY2FsQm91bmRzUHJvcGVydHkubGluayggKCkgPT4ge1xyXG4gICAgICB5QXhpc0xhYmVsVGV4dC5yaWdodCA9IHlab29tQnV0dG9uR3JvdXAucmlnaHQ7XHJcbiAgICAgIHlBeGlzTGFiZWxUZXh0LmNlbnRlclkgPSBncmlkTm9kZS55ICsgKCBncmlkSGVpZ2h0IC8gMiApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIElmIHRoZSBwbG90IGhhcyBkYXRhIHRoYXQgaXMgbm90IHZpc2libGUsIGRpc3BsYXkgJ1pvb20gb3V0IHRvIHNlZSBkYXRhLidcclxuICAgIC8vIHVubGluayBpcyBub3QgbmVjZXNzYXJ5LlxyXG4gICAgY29uc3QgcGxvdHNOb2RlQ2xpcEFyZWEgPSBwbG90c05vZGUuY2xpcEFyZWEhO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggcGxvdHNOb2RlQ2xpcEFyZWEsICdwbG90c05vZGUuY2xpcEFyZWEgaXMgcmVxdWlyZWQnICk7XHJcbiAgICBwbG90c05vZGUubG9jYWxCb3VuZHNQcm9wZXJ0eS5saW5rKCBsb2NhbEJvdW5kcyA9PiB7XHJcbiAgICAgIHpvb21PdXRUb1NlZURhdGFUZXh0LnZpc2libGUgPSAhbG9jYWxCb3VuZHMuZXF1YWxzKCBCb3VuZHMyLk5PVEhJTkcgKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWxvY2FsQm91bmRzLmludGVyc2VjdHNCb3VuZHMoIHBsb3RzTm9kZUNsaXBBcmVhLmJvdW5kcyApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCAnZGlzcG9zZSBpcyBub3Qgc3VwcG9ydGVkLCBleGlzdHMgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgc2ltJyApO1xyXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gIH1cclxufVxyXG5cclxubmF0dXJhbFNlbGVjdGlvbi5yZWdpc3RlciggJ1BvcHVsYXRpb25HcmFwaE5vZGUnLCBQb3B1bGF0aW9uR3JhcGhOb2RlICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFNLGtDQUFrQztBQUN0RCxPQUFPQyxPQUFPLE1BQU0sa0NBQWtDO0FBQ3RELE9BQU9DLFNBQVMsTUFBTSwwQ0FBMEM7QUFFaEUsT0FBT0Msd0JBQXdCLE1BQU0sNERBQTREO0FBQ2pHLFNBQVNDLElBQUksRUFBdUNDLFNBQVMsRUFBRUMsSUFBSSxRQUFRLHNDQUFzQztBQUNqSCxPQUFPQyxnQkFBZ0IsTUFBTSw4QkFBOEI7QUFDM0QsT0FBT0MsdUJBQXVCLE1BQU0scUNBQXFDO0FBRXpFLE9BQU9DLHlCQUF5QixNQUFNLG9DQUFvQztBQUMxRSxPQUFPQyxhQUFhLE1BQU0sb0JBQW9CO0FBQzlDLE9BQU9DLDRCQUE0QixNQUFNLG1DQUFtQztBQUM1RSxPQUFPQyxrQkFBa0IsTUFBTSx5QkFBeUI7QUFDeEQsT0FBT0MsbUJBQW1CLE1BQU0sMEJBQTBCOztBQUUxRDtBQUNBLE1BQU1DLG1CQUFtQixHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQ2hDLE1BQU1DLG9CQUFvQixHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2hDLE1BQU1DLG9CQUFvQixHQUFHLEVBQUUsQ0FBQyxDQUFDOztBQVNqQyxlQUFlLE1BQU1DLG1CQUFtQixTQUFTYixJQUFJLENBQUM7RUFFN0NjLFdBQVdBLENBQUVDLGVBQWdDLEVBQUVDLGVBQTJDLEVBQUc7SUFFbEcsTUFBTUMsT0FBTyxHQUFHbkIsU0FBUyxDQUF1RCxDQUFDLENBQUU7TUFFakY7TUFDQW9CLFVBQVUsRUFBRSxHQUFHO01BQ2ZDLFdBQVcsRUFBRSxHQUFHO01BRWhCO01BQ0FDLGlDQUFpQyxFQUFFO0lBQ3JDLENBQUMsRUFBRUosZUFBZ0IsQ0FBQzs7SUFFcEI7SUFDQSxNQUFNSyxlQUFlLEdBQUcsSUFBSXBCLFNBQVMsQ0FBRSxDQUFDLEVB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