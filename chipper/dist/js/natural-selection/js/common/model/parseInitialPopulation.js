// Copyright 2020-2022, University of Colorado Boulder

/**
 * Parses and validates the values of query parameters that describe the mutations, genotypes, and distribution
 * of the initial population.
 *
 * See NaturalSelectionQueryParameters (labMutations, labPopulation) for examples and details about the values that
 * are being parsed.
 *
 * See https://github.com/phetsims/natural-selection/issues/9 for design history.
 *
 * Responsibilities:
 * - Parses and validates the query-parameter values
 * - Reports problems via QueryStringMachine.addWarning and to console.error
 * - Sets the dominantAlleleProperty for genes that are represented in the mutations value. See Gene.js.
 * - Builds a data structure that is used to initialize and reset the population. See typedef BunnyVariety
 *   and NaturalSelectionModel.js
 * - Reverts to defaults if there is a problem with query-parameter values
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import naturalSelection from '../../naturalSelection.js';
import NaturalSelectionQueryParameters, { SCHEMA_MAP } from '../NaturalSelectionQueryParameters.js';
import NaturalSelectionUtils from '../NaturalSelectionUtils.js';
import BunnyVariety from './BunnyVariety.js';

// Identifies which screen we're creating the population for.

/**
 * Parses query parameters that describe the initial population. Because these query parameters are dependent on
 * each other, if an error is encountered in either value, a warning is added to QueryStringMachine for both query
 * parameters, and they revert to default values. We do not attempt to infer which query parameter is in error,
 * and leave it up to the user to decide.
 */
export default function parseInitialPopulation(screenKey, genePool) {
  const mutationsQueryParameterName = `${screenKey}Mutations`;
  const populationQueryParameterName = `${screenKey}Population`;

  // Get the query parameter values
  const mutationsValue = screenKey === 'intro' ? NaturalSelectionQueryParameters.introMutations : NaturalSelectionQueryParameters.labMutations;
  assert && assert(mutationsValue !== null, `expected ${mutationsQueryParameterName} to have a non-null default value`);
  const populationValue = screenKey === 'intro' ? NaturalSelectionQueryParameters.introPopulation : NaturalSelectionQueryParameters.labPopulation;
  assert && assert(populationValue !== null, `expected ${populationQueryParameterName} to have a non-null default value`);
  let initialBunnyVarieties;
  try {
    // Attempt to parse what the user provided, or the defaults (we don't know which).
    const mutationChars = parseMutations(genePool, mutationsQueryParameterName, mutationsValue);
    initialBunnyVarieties = parsePopulation(genePool, populationQueryParameterName, populationValue, mutationChars);
  } catch (error) {
    // Something went wrong, so fallback to default population.

    // Add warnings that QueryStringMachine will display after the sim has fully started.
    QueryStringMachine.addWarning(mutationsQueryParameterName, mutationsValue, error.message);
    QueryStringMachine.addWarning(populationQueryParameterName, populationValue, error.message);

    // Print an error to the console, since QueryStringMachine doesn't currently show the error message.
    console.error(`Query parameter error: ${error.message}\n` + `${mutationsQueryParameterName}=${mutationsValue}\n` + `${populationQueryParameterName}=${populationValue}`);

    // Revert mutations that may have been configured by parseMutations.
    genePool.genes.forEach(gene => {
      gene.dominantAlleleProperty.setInitialValue(null);
      gene.dominantAlleleProperty.reset();
    });

    // Built the data structure for the default initial population.
    const defaultMutationsValue = screenKey === 'intro' ? SCHEMA_MAP.introMutations.defaultValue : SCHEMA_MAP.labMutations.defaultValue;
    const mutationChars = parseMutations(genePool, mutationsQueryParameterName, defaultMutationsValue);
    const defaultPopulationValue = screenKey === 'intro' ? SCHEMA_MAP.introPopulation.defaultValue : SCHEMA_MAP.labPopulation.defaultValue;
    initialBunnyVarieties = parsePopulation(genePool, populationQueryParameterName, defaultPopulationValue, mutationChars);
  }
  return initialBunnyVarieties;
}

/**
 * Parses the query-parameter value that describes mutations. Sets the dominantAlleleProperty for any genes that are
 * present. See NaturalSelectionQueryParameters.labMutations for details on the format of this value.
 *
 * @param genePool
 * @param queryParameterName - name of the mutations query parameter, used in error messages
 * @param mutationsValue - value of the mutations query parameter
 * @returns array of allele abbreviations
 * @throws {Error}
 */
function parseMutations(genePool, queryParameterName, mutationsValue) {
  // Split mutations into individual characters, e.g. 'FeT' -> [ 'F', 'e', 'T' ]
  const mutationChars = mutationsValue.split('');

  // Compile a list of all allele abbreviations
  const alleleAbbreviations = [];
  genePool.genes.forEach(gene => {
    const dominantAbbreviation = gene.dominantAbbreviationEnglish;
    const recessiveAbbreviation = gene.recessiveAbbreviationEnglish;
    alleleAbbreviations.push(dominantAbbreviation);
    alleleAbbreviations.push(recessiveAbbreviation);

    // Dominant and recessive abbreviations for the same gene are mutually exclusive
    verify(!(mutationChars.includes(dominantAbbreviation) && mutationChars.includes(recessiveAbbreviation)), `${queryParameterName}: ${dominantAbbreviation} and ${recessiveAbbreviation} are mutually exclusive`);

    // If one of the abbreviations is specified, then make the mutant gene dominant or recessive.
    // This changes both the value and initialValue of dominantAlleleProperty, because this is the initial population,
    // and we want dominantAlleleProperty.reset to behave correctly.
    if (mutationChars.includes(dominantAbbreviation)) {
      gene.dominantAlleleProperty.value = gene.mutantAllele;
      gene.dominantAlleleProperty.setInitialValue(gene.mutantAllele);
    } else if (mutationChars.includes(recessiveAbbreviation)) {
      gene.dominantAlleleProperty.value = gene.normalAllele;
      gene.dominantAlleleProperty.setInitialValue(gene.normalAllele);
    }
  });

  // Check for non-allele characters
  verify(_.every(mutationChars, char => alleleAbbreviations.includes(char)), `${queryParameterName}: ${mutationsValue} contains an invalid character`);
  return mutationChars;
}

/**
 * Parses the query-parameter value that describes genotypes and distribution of those genotypes in the initial
 * population. Builds a data structure used to initialize and reset the population.
 * See NaturalSelectionQueryParameters.labPopulation for details on the format of this value.
 *
 * @param genePool
 * @param queryParameterName - name of the population query parameter, used in error messages
 * @param populationValue - value of the population query parameter
 * @param mutationChars - array of allele abbreviations
 * @returns a description of the bunnies to create
 * @throws {Error}
 */
function parsePopulation(genePool, queryParameterName, populationValue, mutationChars) {
  const initialPopulation = [];
  if (mutationChars.length === 0) {
    // If there are no mutations, then population must be a positive integer
    const countErrorMessage = `${queryParameterName} must be a positive integer`;
    verify(populationValue.length === 1, countErrorMessage);
    const countString = populationValue[0];
    verify(!isNaN(Number(countString)), countErrorMessage);
    const count = parseFloat(countString);
    verify(NaturalSelectionUtils.isPositiveInteger(count), countErrorMessage);
    const genotypeString = '';
    initialPopulation.push(createBunnyVariety(genePool, count, genotypeString));
  } else {
    // The total number of bunnies to be created
    let totalCount = 0;

    // The population is described as expressions that indicate the number of bunnies per genotype, e.g. '35FeT'.
    verify(populationValue.length > 0, `${queryParameterName} value is required`);
    for (let i = 0; i < populationValue.length; i++) {
      // Get an expression from the array, e.g. '35FFeEtt'
      const expression = populationValue[i];

      // Split the expression into 2 tokens (count and genotype) e.g. '35FFeEtt' -> '35' and 'FFeEtt'
      const firstLetterIndex = expression.search(/[a-zA-Z]/);
      verify(firstLetterIndex !== -1, `${queryParameterName}: ${expression} is missing a genotype`);
      const countString = expression.substring(0, firstLetterIndex);
      const genotypeString = expression.substring(firstLetterIndex);

      // Count must be a positive integer
      const countErrorMessage = `${queryParameterName}: ${expression} must start with a positive integer`;
      verify(!isNaN(Number(countString)), countErrorMessage);
      const count = parseFloat(countString);
      verify(NaturalSelectionUtils.isPositiveInteger(count), countErrorMessage);

      // Total of all counts must be < maximum population
      totalCount += count;
      verify(totalCount < NaturalSelectionQueryParameters.maxPopulation, `${queryParameterName}: the total population must be < ${NaturalSelectionQueryParameters.maxPopulation}`);

      // Genotype must contain 2 alleles for each gene represented in mutations
      const genotypeErrorMessage = `${queryParameterName}: ${genotypeString} is an invalid genotype`;
      verify(genotypeString.length === 2 * mutationChars.length, genotypeErrorMessage);
      assert && genePool.genes.forEach(gene => {
        const dominantAbbreviation = gene.dominantAbbreviationEnglish;
        const recessiveAbbreviation = gene.recessiveAbbreviationEnglish;

        // If the gene is represented in mutations...
        if (mutationChars.includes(dominantAbbreviation) || mutationChars.includes(recessiveAbbreviation)) {
          const genotypeChars = genotypeString.split('');

          // The expression must contain exactly 2 alleles for each gene.
          const countDominant = _.filter(genotypeChars, char => char === dominantAbbreviation).length;
          const countRecessive = _.filter(genotypeChars, char => char === recessiveAbbreviation).length;
          verify(countDominant + countRecessive === 2, genotypeErrorMessage);

          // The alleles must be paired (adjacent) in the expression.
          const dominantIndex = genotypeChars.indexOf(dominantAbbreviation);
          const recessiveIndex = genotypeChars.indexOf(recessiveAbbreviation);
          const maxIndex = Math.max(dominantIndex, recessiveIndex);
          const minIndex = Math.min(dominantIndex, recessiveIndex);
          const firstIndex = minIndex !== -1 ? minIndex : maxIndex;
          verify(genotypeChars[firstIndex + 1] === dominantAbbreviation || genotypeChars[firstIndex + 1] === recessiveAbbreviation, genotypeErrorMessage);
        }
      });
      initialPopulation.push(createBunnyVariety(genePool, count, genotypeString));
    }
    verify(totalCount > 0, `${queryParameterName}: the total population must be > 0`);
  }
  return initialPopulation;
}

/**
 * Converts a genotype expression to a data structure that describes the count and genotype for a bunny variety.
 * Alleles not present in the string default to the normal allele for their associated gene.
 */
function createBunnyVariety(genePool, count, genotypeString) {
  assert && assert(NaturalSelectionUtils.isPositiveInteger(count), 'invalid count');

  // To make this code easier to read
  const furGene = genePool.furGene;
  const earsGene = genePool.earsGene;
  const teethGene = genePool.teethGene;

  // Start with no alleles, populate these data structures in the forEach loop.
  const furPair = {
    fatherAllele: null,
    motherAllele: null
  };
  const earsPair = {
    fatherAllele: null,
    motherAllele: null
  };
  const teethPair = {
    fatherAllele: null,
    motherAllele: null
  };

  // For each character in the genotype abbreviation...
  const alleleAbbreviations = genotypeString.split('');
  alleleAbbreviations.forEach(alleleAbbreviation => {
    abbreviationToAllele(alleleAbbreviation, furGene, furPair);
    abbreviationToAllele(alleleAbbreviation, earsGene, earsPair);
    abbreviationToAllele(alleleAbbreviation, teethGene, teethPair);
  });
  return new BunnyVariety(count, genotypeString,
  // Default to the normal allele for any allele that was not specified
  furPair.fatherAllele || furGene.normalAllele, furPair.motherAllele || furGene.normalAllele, earsPair.fatherAllele || earsGene.normalAllele, earsPair.motherAllele || earsGene.normalAllele, teethPair.fatherAllele || teethGene.normalAllele, teethPair.motherAllele || teethGene.normalAllele);
}

/**
 * Converts an allele abbreviation to an allele, and puts it in allelesPair.
 */
function abbreviationToAllele(alleleAbbreviation, gene, allelesPair) {
  if (alleleAbbreviation === gene.dominantAbbreviationEnglish || alleleAbbreviation === gene.recessiveAbbreviationEnglish) {
    assert && assert(gene.dominantAlleleProperty.value, `expected a value for ${gene.nameProperty.value} dominantAlleleProperty`);
    const isMutantDominant = gene.dominantAlleleProperty.value === gene.mutantAllele;
    const isAbbreviationDominant = alleleAbbreviation === gene.dominantAbbreviationEnglish;
    const allele = isMutantDominant && isAbbreviationDominant || !isMutantDominant && !isAbbreviationDominant ? gene.mutantAllele : gene.normalAllele;

    // Populate fatherAllele first, motherAllele second
    if (!allelesPair.fatherAllele) {
      allelesPair.fatherAllele = allele;
    } else {
      assert && assert(!allelesPair.motherAllele, 'motherAllele should be null');
      allelesPair.motherAllele = allele;
    }
  }
}

/**
 * Verifies that a predicate is true. If it's not true, throw an Error that includes the specified message.
 */
function verify(predicate, message) {
  if (!predicate) {
    throw new Error(message);
  }
}
naturalSelection.register('parseInitialPopulation', parseInitialPopulation);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJuYXR1cmFsU2VsZWN0aW9uIiwiTmF0dXJhbFNlbGVjdGlvblF1ZXJ5UGFyYW1ldGVycyIsIlNDSEVNQV9NQVAiLCJOYXR1cmFsU2VsZWN0aW9uVXRpbHMiLCJCdW5ueVZhcmlldHkiLCJwYXJzZUluaXRpYWxQb3B1bGF0aW9uIiwic2NyZWVuS2V5IiwiZ2VuZVBvb2wiLCJtdXRhdGlvbnNRdWVyeVBhcmFtZXRlck5hbWUiLCJwb3B1bGF0aW9uUXVlcnlQYXJhbWV0ZXJOYW1lIiwibXV0YXRpb25zVmFsdWUiLCJpbnRyb011dGF0aW9ucyIsImxhYk11dGF0aW9ucyIsImFzc2VydCIsInBvcHVsYXRpb25WYWx1ZSIsImludHJvUG9wdWxhdGlvbiIsImxhYlBvcHVsYXRpb24iLCJpbml0aWFsQnVubnlWYXJpZXRpZXMiLCJtdXRhdGlvbkNoYXJzIiwicGFyc2VNdXRhdGlvbnMiLCJwYXJzZVBvcHVsYXRpb24iLCJlcnJvciIsIlF1ZXJ5U3RyaW5nTWFjaGluZSIsImFkZFdhcm5pbmciLCJtZXNzYWdlIiwiY29uc29sZSIsImdlbmVzIiwiZm9yRWFjaCIsImdlbmUiLCJkb21pbmFudEFsbGVsZVByb3BlcnR5Iiwic2V0SW5pdGlhbFZhbHVlIiwicmVzZXQiLCJkZWZhdWx0TXV0YXRpb25zVmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJkZWZhdWx0UG9wdWxhdGlvblZhbHVlIiwicXVlcnlQYXJhbWV0ZXJOYW1lIiwic3BsaXQiLCJhbGxlbGVBYmJyZXZpYXRpb25zIiwiZG9taW5hbnRBYmJyZXZpYXRpb24iLCJkb21pbmFudEFiYnJldmlhdGlvbkVuZ2xpc2giLCJyZWNlc3NpdmVBYmJyZXZpYXRpb24iLCJyZWNlc3NpdmVBYmJyZXZpYXRpb25FbmdsaXNoIiwicHVzaCIsInZlcmlmeSIsImluY2x1ZGVzIiwidmFsdWUiLCJtdXRhbnRBbGxlbGUiLCJub3JtYWxBbGxlbGUiLCJfIiwiZXZlcnkiLCJjaGFyIiwiaW5pdGlhbFBvcHVsYXRpb24iLCJsZW5ndGgiLCJjb3VudEVycm9yTWVzc2FnZSIsImNvdW50U3RyaW5nIiwiaXNOYU4iLCJOdW1iZXIiLCJjb3VudCIsInBhcnNlRmxvYXQiLCJpc1Bvc2l0aXZlSW50ZWdlciIsImdlbm90eXBlU3RyaW5nIiwiY3JlYXRlQnVubnlWYXJpZXR5IiwidG90YWxDb3VudCIsImkiLCJleHByZXNzaW9uIiwiZmlyc3RMZXR0ZXJJbmRleCIsInNlYXJjaCIsInN1YnN0cmluZyIsIm1heFBvcHVsYXRpb24iLCJnZW5vdHlwZUVycm9yTWVzc2FnZSIsImdlbm90eXBlQ2hhcnMiLCJjb3VudERvbWluYW50IiwiZmlsdGVyIiwiY291bnRSZWNlc3NpdmUiLCJkb21pbmFudEluZGV4IiwiaW5kZXhPZiIsInJlY2Vzc2l2ZUluZGV4IiwibWF4SW5kZXgiLCJNYXRoIiwibWF4IiwibWluSW5kZXgiLCJtaW4iLCJmaXJzdEluZGV4IiwiZnVyR2VuZSIsImVhcnNHZW5lIiwidGVldGhHZW5lIiwiZnVyUGFpciIsImZhdGhlckFsbGVsZSIsIm1vdGhlckFsbGVsZSIsImVhcnNQYWlyIiwidGVldGhQYWlyIiwiYWxsZWxlQWJicmV2aWF0aW9uIiwiYWJicmV2aWF0aW9uVG9BbGxlbGUiLCJhbGxlbGVzUGFpciIsIm5hbWVQcm9wZXJ0eSIsImlzTXV0YW50RG9taW5hbnQiLCJpc0FiYnJldmlhdGlvbkRvbWluYW50IiwiYWxsZWxlIiwicHJlZGljYXRlIiwiRXJyb3IiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbInBhcnNlSW5pdGlhbFBvcHVsYXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogUGFyc2VzIGFuZCB2YWxpZGF0ZXMgdGhlIHZhbHVlcyBvZiBxdWVyeSBwYXJhbWV0ZXJzIHRoYXQgZGVzY3JpYmUgdGhlIG11dGF0aW9ucywgZ2Vub3R5cGVzLCBhbmQgZGlzdHJpYnV0aW9uXHJcbiAqIG9mIHRoZSBpbml0aWFsIHBvcHVsYXRpb24uXHJcbiAqXHJcbiAqIFNlZSBOYXR1cmFsU2VsZWN0aW9uUXVlcnlQYXJhbWV0ZXJzIChsYWJNdXRhdGlvbnMsIGxhYlBvcHVsYXRpb24pIGZvciBleGFtcGxlcyBhbmQgZGV0YWlscyBhYm91dCB0aGUgdmFsdWVzIHRoYXRcclxuICogYXJlIGJlaW5nIHBhcnNlZC5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9uYXR1cmFsLXNlbGVjdGlvbi9pc3N1ZXMvOSBmb3IgZGVzaWduIGhpc3RvcnkuXHJcbiAqXHJcbiAqIFJlc3BvbnNpYmlsaXRpZXM6XHJcbiAqIC0gUGFyc2VzIGFuZCB2YWxpZGF0ZXMgdGhlIHF1ZXJ5LXBhcmFtZXRlciB2YWx1ZXNcclxuICogLSBSZXBvcnRzIHByb2JsZW1zIHZpYSBRdWVyeVN0cmluZ01hY2hpbmUuYWRkV2FybmluZyBhbmQgdG8gY29uc29sZS5lcnJvclxyXG4gKiAtIFNldHMgdGhlIGRvbWluYW50QWxsZWxlUHJvcGVydHkgZm9yIGdlbmVzIHRoYXQgYXJlIHJlcHJlc2VudGVkIGluIHRoZSBtdXRhdGlvbnMgdmFsdWUuIFNlZSBHZW5lLmpzLlxyXG4gKiAtIEJ1aWxkcyBhIGRhdGEgc3RydWN0dXJlIHRoYXQgaXMgdXNlZCB0byBpbml0aWFsaXplIGFuZCByZXNldCB0aGUgcG9wdWxhdGlvbi4gU2VlIHR5cGVkZWYgQnVubnlWYXJpZXR5XHJcbiAqICAgYW5kIE5hdHVyYWxTZWxlY3Rpb25Nb2RlbC5qc1xyXG4gKiAtIFJldmVydHMgdG8gZGVmYXVsdHMgaWYgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggcXVlcnktcGFyYW1ldGVyIHZhbHVlc1xyXG4gKlxyXG4gKiBAYXV0aG9yIENocmlzIE1hbGxleSAoUGl4ZWxab29tLCBJbmMuKVxyXG4gKi9cclxuXHJcbmltcG9ydCBuYXR1cmFsU2VsZWN0aW9uIGZyb20gJy4uLy4uL25hdHVyYWxTZWxlY3Rpb24uanMnO1xyXG5pbXBvcnQgTmF0dXJhbFNlbGVjdGlvblF1ZXJ5UGFyYW1ldGVycywgeyBTQ0hFTUFfTUFQIH0gZnJvbSAnLi4vTmF0dXJhbFNlbGVjdGlvblF1ZXJ5UGFyYW1ldGVycy5qcyc7XHJcbmltcG9ydCBOYXR1cmFsU2VsZWN0aW9uVXRpbHMgZnJvbSAnLi4vTmF0dXJhbFNlbGVjdGlvblV0aWxzLmpzJztcclxuaW1wb3J0IEFsbGVsZSBmcm9tICcuL0FsbGVsZS5qcyc7XHJcbmltcG9ydCBCdW5ueVZhcmlldHkgZnJvbSAnLi9CdW5ueVZhcmlldHkuanMnO1xyXG5pbXBvcnQgR2VuZSBmcm9tICcuL0dlbmUuanMnO1xyXG5pbXBvcnQgR2VuZVBvb2wgZnJvbSAnLi9HZW5lUG9vbC5qcyc7XHJcblxyXG50eXBlIEFsbGVsZXNQYWlyID0ge1xyXG4gIGZhdGhlckFsbGVsZTogQWxsZWxlIHwgbnVsbDtcclxuICBtb3RoZXJBbGxlbGU6IEFsbGVsZSB8IG51bGw7XHJcbn07XHJcblxyXG4vLyBJZGVudGlmaWVzIHdoaWNoIHNjcmVlbiB3ZSdyZSBjcmVhdGluZyB0aGUgcG9wdWxhdGlvbiBmb3IuXHJcbmV4cG9ydCB0eXBlIFNjcmVlbktleSA9ICdpbnRybycgfCAnbGFiJztcclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgcXVlcnkgcGFyYW1ldGVycyB0aGF0IGRlc2NyaWJlIHRoZSBpbml0aWFsIHBvcHVsYXRpb24uIEJlY2F1c2UgdGhlc2UgcXVlcnkgcGFyYW1ldGVycyBhcmUgZGVwZW5kZW50IG9uXHJcbiAqIGVhY2ggb3RoZXIsIGlmIGFuIGVycm9yIGlzIGVuY291bnRlcmVkIGluIGVpdGhlciB2YWx1ZSwgYSB3YXJuaW5nIGlzIGFkZGVkIHRvIFF1ZXJ5U3RyaW5nTWFjaGluZSBmb3IgYm90aCBxdWVyeVxyXG4gKiBwYXJhbWV0ZXJzLCBhbmQgdGhleSByZXZlcnQgdG8gZGVmYXVsdCB2YWx1ZXMuIFdlIGRvIG5vdCBhdHRlbXB0IHRvIGluZmVyIHdoaWNoIHF1ZXJ5IHBhcmFtZXRlciBpcyBpbiBlcnJvcixcclxuICogYW5kIGxlYXZlIGl0IHVwIHRvIHRoZSB1c2VyIHRvIGRlY2lkZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlSW5pdGlhbFBvcHVsYXRpb24oIHNjcmVlbktleTogU2NyZWVuS2V5LCBnZW5lUG9vbDogR2VuZVBvb2wgKTogQnVubnlWYXJpZXR5W10ge1xyXG5cclxuICBjb25zdCBtdXRhdGlvbnNRdWVyeVBhcmFtZXRlck5hbWUgPSBgJHtzY3JlZW5LZXl9TXV0YXRpb25zYDtcclxuICBjb25zdCBwb3B1bGF0aW9uUXVlcnlQYXJhbWV0ZXJOYW1lID0gYCR7c2NyZWVuS2V5fVBvcHVsYXRpb25gO1xyXG5cclxuICAvLyBHZXQgdGhlIHF1ZXJ5IHBhcmFtZXRlciB2YWx1ZXNcclxuICBjb25zdCBtdXRhdGlvbnNWYWx1ZSA9ICggKCBzY3JlZW5LZXkgPT09ICdpbnRybycgKSA/IE5hdHVyYWxTZWxlY3Rpb25RdWVyeVBhcmFtZXRlcnMuaW50cm9NdXRhdGlvbnMgOiBOYXR1cmFsU2VsZWN0aW9uUXVlcnlQYXJhbWV0ZXJzLmxhYk11dGF0aW9ucyApITtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBtdXRhdGlvbnNWYWx1ZSAhPT0gbnVsbCwgYGV4cGVjdGVkICR7bXV0YXRpb25zUXVlcnlQYXJhbWV0ZXJOYW1lfSB0byBoYXZlIGEgbm9uLW51bGwgZGVmYXVsdCB2YWx1ZWAgKTtcclxuICBjb25zdCBwb3B1bGF0aW9uVmFsdWUgPSAoICggc2NyZWVuS2V5ID09PSAnaW50cm8nICkgPyBOYXR1cmFsU2VsZWN0aW9uUXVlcnlQYXJhbWV0ZXJzLmludHJvUG9wdWxhdGlvbiA6IE5hdHVyYWxTZWxlY3Rpb25RdWVyeVBhcmFtZXRlcnMubGFiUG9wdWxhdGlvbiApITtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBwb3B1bGF0aW9uVmFsdWUgIT09IG51bGwsIGBleHBlY3RlZCAke3BvcHVsYXRpb25RdWVyeVBhcmFtZXRlck5hbWV9IHRvIGhhdmUgYSBub24tbnVsbCBkZWZhdWx0IHZhbHVlYCApO1xyXG5cclxuICBsZXQgaW5pdGlhbEJ1bm55VmFyaWV0aWVzOiBCdW5ueVZhcmlldHlbXTtcclxuICB0cnkge1xyXG5cclxuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2Ugd2hhdCB0aGUgdXNlciBwcm92aWRlZCwgb3IgdGhlIGRlZmF1bHRzICh3ZSBkb24ndCBrbm93IHdoaWNoKS5cclxuICAgIGNvbnN0IG11dGF0aW9uQ2hhcnMgPSBwYXJzZU11dGF0aW9ucyggZ2VuZVBvb2wsIG11dGF0aW9uc1F1ZXJ5UGFyYW1ldGVyTmFtZSwgbXV0YXRpb25zVmFsdWUgKTtcclxuICAgIGluaXRpYWxCdW5ueVZhcmlldGllcyA9IHBhcnNlUG9wdWxhdGlvbiggZ2VuZVBvb2wsIHBvcHVsYXRpb25RdWVyeVBhcmFtZXRlck5hbWUsIHBvcHVsYXRpb25WYWx1ZSwgbXV0YXRpb25DaGFycyApO1xyXG4gIH1cclxuICBjYXRjaCggZXJyb3I6IEludGVudGlvbmFsQW55ICkge1xyXG5cclxuICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nLCBzbyBmYWxsYmFjayB0byBkZWZhdWx0IHBvcHVsYXRpb24uXHJcblxyXG4gICAgLy8gQWRkIHdhcm5pbmdzIHRoYXQgUXVlcnlTdHJpbmdNYWNoaW5lIHdpbGwgZGlzcGxheSBhZnRlciB0aGUgc2ltIGhhcyBmdWxseSBzdGFydGVkLlxyXG4gICAgUXVlcnlTdHJpbmdNYWNoaW5lLmFkZFdhcm5pbmcoIG11dGF0aW9uc1F1ZXJ5UGFyYW1ldGVyTmFtZSwgbXV0YXRpb25zVmFsdWUsIGVycm9yLm1lc3NhZ2UgKTtcclxuICAgIFF1ZXJ5U3RyaW5nTWFjaGluZS5hZGRXYXJuaW5nKCBwb3B1bGF0aW9uUXVlcnlQYXJhbWV0ZXJOYW1lLCBwb3B1bGF0aW9uVmFsdWUsIGVycm9yLm1lc3NhZ2UgKTtcclxuXHJcbiAgICAvLyBQcmludCBhbiBlcnJvciB0byB0aGUgY29uc29sZSwgc2luY2UgUXVlcnlTdHJpbmdNYWNoaW5lIGRvZXNuJ3QgY3VycmVudGx5IHNob3cgdGhlIGVycm9yIG1lc3NhZ2UuXHJcbiAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICBgUXVlcnkgcGFyYW1ldGVyIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9XFxuYCArXHJcbiAgICAgIGAke211dGF0aW9uc1F1ZXJ5UGFyYW1ldGVyTmFtZX09JHttdXRhdGlvbnNWYWx1ZX1cXG5gICtcclxuICAgICAgYCR7cG9wdWxhdGlvblF1ZXJ5UGFyYW1ldGVyTmFtZX09JHtwb3B1bGF0aW9uVmFsdWV9YFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBSZXZlcnQgbXV0YXRpb25zIHRoYXQgbWF5IGhhdmUgYmVlbiBjb25maWd1cmVkIGJ5IHBhcnNlTXV0YXRpb25zLlxyXG4gICAgZ2VuZVBvb2wuZ2VuZXMuZm9yRWFjaCggZ2VuZSA9PiB7XHJcbiAgICAgIGdlbmUuZG9taW5hbnRBbGxlbGVQcm9wZXJ0eS5zZXRJbml0aWFsVmFsdWUoIG51bGwgKTtcclxuICAgICAgZ2VuZS5kb21pbmFudEFsbGVsZVByb3BlcnR5LnJlc2V0KCk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gQnVpbHQgdGhlIGRhdGEgc3RydWN0dXJlIGZvciB0aGUgZGVmYXVsdCBpbml0aWFsIHBvcHVsYXRpb24uXHJcbiAgICBjb25zdCBkZWZhdWx0TXV0YXRpb25zVmFsdWUgPSAoIHNjcmVlbktleSA9PT0gJ2ludHJvJyApID8gU0NIRU1BX01BUC5pbnRyb011dGF0aW9ucy5kZWZhdWx0VmFsdWUgOiBTQ0hFTUFfTUFQLmxhYk11dGF0aW9ucy5kZWZhdWx0VmFsdWU7XHJcbiAgICBjb25zdCBtdXRhdGlvbkNoYXJzID0gcGFyc2VNdXRhdGlvbnMoIGdlbmVQb29sLCBtdXRhdGlvbnNRdWVyeVBhcmFtZXRlck5hbWUsIGRlZmF1bHRNdXRhdGlvbnNWYWx1ZSApO1xyXG4gICAgY29uc3QgZGVmYXVsdFBvcHVsYXRpb25WYWx1ZSA9ICggc2NyZWVuS2V5ID09PSAnaW50cm8nICkgPyBTQ0hFTUFfTUFQLmludHJvUG9wdWxhdGlvbi5kZWZhdWx0VmFsdWUgOiBTQ0hFTUFfTUFQLmxhYlBvcHVsYXRpb24uZGVmYXVsdFZhbHVlO1xyXG4gICAgaW5pdGlhbEJ1bm55VmFyaWV0aWVzID0gcGFyc2VQb3B1bGF0aW9uKCBnZW5lUG9vbCwgcG9wdWxhdGlvblF1ZXJ5UGFyYW1ldGVyTmFtZSwgZGVmYXVsdFBvcHVsYXRpb25WYWx1ZSwgbXV0YXRpb25DaGFycyApO1xyXG4gIH1cclxuICByZXR1cm4gaW5pdGlhbEJ1bm55VmFyaWV0aWVzO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2VzIHRoZSBxdWVyeS1wYXJhbWV0ZXIgdmFsdWUgdGhhdCBkZXNjcmliZXMgbXV0YXRpb25zLiBTZXRzIHRoZSBkb21pbmFudEFsbGVsZVByb3BlcnR5IGZvciBhbnkgZ2VuZXMgdGhhdCBhcmVcclxuICogcHJlc2VudC4gU2VlIE5hdHVyYWxTZWxlY3Rpb25RdWVyeVBhcmFtZXRlcnMubGFiTXV0YXRpb25zIGZvciBkZXRhaWxzIG9uIHRoZSBmb3JtYXQgb2YgdGhpcyB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIGdlbmVQb29sXHJcbiAqIEBwYXJhbSBxdWVyeVBhcmFtZXRlck5hbWUgLSBuYW1lIG9mIHRoZSBtdXRhdGlvbnMgcXVlcnkgcGFyYW1ldGVyLCB1c2VkIGluIGVycm9yIG1lc3NhZ2VzXHJcbiAqIEBwYXJhbSBtdXRhdGlvbnNWYWx1ZSAtIHZhbHVlIG9mIHRoZSBtdXRhdGlvbnMgcXVlcnkgcGFyYW1ldGVyXHJcbiAqIEByZXR1cm5zIGFycmF5IG9mIGFsbGVsZSBhYmJyZXZpYXRpb25zXHJcbiAqIEB0aHJvd3Mge0Vycm9yfVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VNdXRhdGlvbnMoIGdlbmVQb29sOiBHZW5lUG9vbCwgcXVlcnlQYXJhbWV0ZXJOYW1lOiBzdHJpbmcsIG11dGF0aW9uc1ZhbHVlOiBzdHJpbmcgKTogc3RyaW5nW10ge1xyXG5cclxuICAvLyBTcGxpdCBtdXRhdGlvbnMgaW50byBpbmRpdmlkdWFsIGNoYXJhY3RlcnMsIGUuZy4gJ0ZlVCcgLT4gWyAnRicsICdlJywgJ1QnIF1cclxuICBjb25zdCBtdXRhdGlvbkNoYXJzID0gbXV0YXRpb25zVmFsdWUuc3BsaXQoICcnICk7XHJcblxyXG4gIC8vIENvbXBpbGUgYSBsaXN0IG9mIGFsbCBhbGxlbGUgYWJicmV2aWF0aW9uc1xyXG4gIGNvbnN0IGFsbGVsZUFiYnJldmlhdGlvbnM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gIGdlbmVQb29sLmdlbmVzLmZvckVhY2goIGdlbmUgPT4ge1xyXG5cclxuICAgIGNvbnN0IGRvbWluYW50QWJicmV2aWF0aW9uID0gZ2VuZS5kb21pbmFudEFiYnJldmlhdGlvbkVuZ2xpc2g7XHJcbiAgICBjb25zdCByZWNlc3NpdmVBYmJyZXZpYXRpb24gPSBnZW5lLnJlY2Vzc2l2ZUFiYnJldmlhdGlvbkVuZ2xpc2g7XHJcbiAgICBhbGxlbGVBYmJyZXZpYXRpb25zLnB1c2goIGRvbWluYW50QWJicmV2aWF0aW9uICk7XHJcbiAgICBhbGxlbGVBYmJyZXZpYXRpb25zLnB1c2goIHJlY2Vzc2l2ZUFiYnJldmlhdGlvbiApO1xyXG5cclxuICAgIC8vIERvbWluYW50IGFuZCByZWNlc3NpdmUgYWJicmV2aWF0aW9ucyBmb3IgdGhlIHNhbWUgZ2VuZSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlXHJcbiAgICB2ZXJpZnkoICEoIG11dGF0aW9uQ2hhcnMuaW5jbHVkZXMoIGRvbWluYW50QWJicmV2aWF0aW9uICkgJiYgbXV0YXRpb25DaGFycy5pbmNsdWRlcyggcmVjZXNzaXZlQWJicmV2aWF0aW9uICkgKSxcclxuICAgICAgYCR7cXVlcnlQYXJhbWV0ZXJOYW1lfTogJHtkb21pbmFudEFiYnJldmlhdGlvbn0gYW5kICR7cmVjZXNzaXZlQWJicmV2aWF0aW9ufSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlYCApO1xyXG5cclxuICAgIC8vIElmIG9uZSBvZiB0aGUgYWJicmV2aWF0aW9ucyBpcyBzcGVjaWZpZWQsIHRoZW4gbWFrZSB0aGUgbXV0YW50IGdlbmUgZG9taW5hbnQgb3IgcmVjZXNzaXZlLlxyXG4gICAgLy8gVGhpcyBjaGFuZ2VzIGJvdGggdGhlIHZhbHVlIGFuZCBpbml0aWFsVmFsdWUgb2YgZG9taW5hbnRBbGxlbGVQcm9wZXJ0eSwgYmVjYXVzZSB0aGlzIGlzIHRoZSBpbml0aWFsIHBvcHVsYXRpb24sXHJcbiAgICAvLyBhbmQgd2Ugd2FudCBkb21pbmFudEFsbGVsZVByb3BlcnR5LnJlc2V0IHRvIGJlaGF2ZSBjb3JyZWN0bHkuXHJcbiAgICBpZiAoIG11dGF0aW9uQ2hhcnMuaW5jbHVkZXMoIGRvbWluYW50QWJicmV2aWF0aW9uICkgKSB7XHJcbiAgICAgIGdlbmUuZG9taW5hbnRBbGxlbGVQcm9wZXJ0eS52YWx1ZSA9IGdlbmUubXV0YW50QWxsZWxlO1xyXG4gICAgICBnZW5lLmRvbWluYW50QWxsZWxlUHJvcGVydHkuc2V0SW5pdGlhbFZhbHVlKCBnZW5lLm11dGFudEFsbGVsZSApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIG11dGF0aW9uQ2hhcnMuaW5jbHVkZXMoIHJlY2Vzc2l2ZUFiYnJldmlhdGlvbiApICkge1xyXG4gICAgICBnZW5lLmRvbWluYW50QWxsZWxlUHJvcGVydHkudmFsdWUgPSBnZW5lLm5vcm1hbEFsbGVsZTtcclxuICAgICAgZ2VuZS5kb21pbmFudEFsbGVsZVByb3BlcnR5LnNldEluaXRpYWxWYWx1ZSggZ2VuZS5ub3JtYWxBbGxlbGUgKTtcclxuICAgIH1cclxuICB9ICk7XHJcblxyXG4gIC8vIENoZWNrIGZvciBub24tYWxsZWxlIGNoYXJhY3RlcnNcclxuICB2ZXJpZnkoIF8uZXZlcnkoIG11dGF0aW9uQ2hhcnMsIGNoYXIgPT4gYWxsZWxlQWJicmV2aWF0aW9ucy5pbmNsdWRlcyggY2hhciApICksXHJcbiAgICBgJHtxdWVyeVBhcmFtZXRlck5hbWV9OiAke211dGF0aW9uc1ZhbHVlfSBjb250YWlucyBhbiBpbnZhbGlkIGNoYXJhY3RlcmAgKTtcclxuXHJcbiAgcmV0dXJuIG11dGF0aW9uQ2hhcnM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIHF1ZXJ5LXBhcmFtZXRlciB2YWx1ZSB0aGF0IGRlc2NyaWJlcyBnZW5vdHlwZXMgYW5kIGRpc3RyaWJ1dGlvbiBvZiB0aG9zZSBnZW5vdHlwZXMgaW4gdGhlIGluaXRpYWxcclxuICogcG9wdWxhdGlvbi4gQnVpbGRzIGEgZGF0YSBzdHJ1Y3R1cmUgdXNlZCB0byBpbml0aWFsaXplIGFuZCByZXNldCB0aGUgcG9wdWxhdGlvbi5cclxuICogU2VlIE5hdHVyYWxTZWxlY3Rpb25RdWVyeVBhcmFtZXRlcnMubGFiUG9wdWxhdGlvbiBmb3IgZGV0YWlscyBvbiB0aGUgZm9ybWF0IG9mIHRoaXMgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBnZW5lUG9vbFxyXG4gKiBAcGFyYW0gcXVlcnlQYXJhbWV0ZXJOYW1lIC0gbmFtZSBvZiB0aGUgcG9wdWxhdGlvbiBxdWVyeSBwYXJhbWV0ZXIsIHVzZWQgaW4gZXJyb3IgbWVzc2FnZXNcclxuICogQHBhcmFtIHBvcHVsYXRpb25WYWx1ZSAtIHZhbHVlIG9mIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5IHBhcmFtZXRlclxyXG4gKiBAcGFyYW0gbXV0YXRpb25DaGFycyAtIGFycmF5IG9mIGFsbGVsZSBhYmJyZXZpYXRpb25zXHJcbiAqIEByZXR1cm5zIGEgZGVzY3JpcHRpb24gb2YgdGhlIGJ1bm5pZXMgdG8gY3JlYXRlXHJcbiAqIEB0aHJvd3Mge0Vycm9yfVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VQb3B1bGF0aW9uKCBnZW5lUG9vbDogR2VuZVBvb2wsIHF1ZXJ5UGFyYW1ldGVyTmFtZTogc3RyaW5nLCBwb3B1bGF0aW9uVmFsdWU6IHJlYWRvbmx5IHN0cmluZ1tdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uQ2hhcnM6IHJlYWRvbmx5IHN0cmluZ1tdICk6IEJ1bm55VmFyaWV0eVtdIHtcclxuXHJcbiAgY29uc3QgaW5pdGlhbFBvcHVsYXRpb246IEJ1bm55VmFyaWV0eVtdID0gW107XHJcblxyXG4gIGlmICggbXV0YXRpb25DaGFycy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIG11dGF0aW9ucywgdGhlbiBwb3B1bGF0aW9uIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXHJcbiAgICBjb25zdCBjb3VudEVycm9yTWVzc2FnZSA9IGAke3F1ZXJ5UGFyYW1ldGVyTmFtZX0gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgO1xyXG4gICAgdmVyaWZ5KCBwb3B1bGF0aW9uVmFsdWUubGVuZ3RoID09PSAxLCBjb3VudEVycm9yTWVzc2FnZSApO1xyXG4gICAgY29uc3QgY291bnRTdHJpbmcgPSBwb3B1bGF0aW9uVmFsdWVbIDAgXTtcclxuICAgIHZlcmlmeSggIWlzTmFOKCBOdW1iZXIoIGNvdW50U3RyaW5nICkgKSwgY291bnRFcnJvck1lc3NhZ2UgKTtcclxuICAgIGNvbnN0IGNvdW50ID0gcGFyc2VGbG9hdCggY291bnRTdHJpbmcgKTtcclxuICAgIHZlcmlmeSggTmF0dXJhbFNlbGVjdGlvblV0aWxzLmlzUG9zaXRpdmVJbnRlZ2VyKCBjb3VudCApLCBjb3VudEVycm9yTWVzc2FnZSApO1xyXG4gICAgY29uc3QgZ2Vub3R5cGVTdHJpbmcgPSAnJztcclxuXHJcbiAgICBpbml0aWFsUG9wdWxhdGlvbi5wdXNoKCBjcmVhdGVCdW5ueVZhcmlldHkoIGdlbmVQb29sLCBjb3VudCwgZ2Vub3R5cGVTdHJpbmcgKSApO1xyXG4gIH1cclxuICBlbHNlIHtcclxuXHJcbiAgICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIGJ1bm5pZXMgdG8gYmUgY3JlYXRlZFxyXG4gICAgbGV0IHRvdGFsQ291bnQgPSAwO1xyXG5cclxuICAgIC8vIFRoZSBwb3B1bGF0aW9uIGlzIGRlc2NyaWJlZCBhcyBleHByZXNzaW9ucyB0aGF0IGluZGljYXRlIHRoZSBudW1iZXIgb2YgYnVubmllcyBwZXIgZ2Vub3R5cGUsIGUuZy4gJzM1RmVUJy5cclxuICAgIHZlcmlmeSggcG9wdWxhdGlvblZhbHVlLmxlbmd0aCA+IDAsIGAke3F1ZXJ5UGFyYW1ldGVyTmFtZX0gdmFsdWUgaXMgcmVxdWlyZWRgICk7XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBwb3B1bGF0aW9uVmFsdWUubGVuZ3RoOyBpKysgKSB7XHJcblxyXG4gICAgICAvLyBHZXQgYW4gZXhwcmVzc2lvbiBmcm9tIHRoZSBhcnJheSwgZS5nLiAnMzVGRmVFdHQnXHJcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwb3B1bGF0aW9uVmFsdWVbIGkgXTtcclxuXHJcbiAgICAgIC8vIFNwbGl0IHRoZSBleHByZXNzaW9uIGludG8gMiB0b2tlbnMgKGNvdW50IGFuZCBnZW5vdHlwZSkgZS5nLiAnMzVGRmVFdHQnIC0+ICczNScgYW5kICdGRmVFdHQnXHJcbiAgICAgIGNvbnN0IGZpcnN0TGV0dGVySW5kZXggPSBleHByZXNzaW9uLnNlYXJjaCggL1thLXpBLVpdLyApO1xyXG4gICAgICB2ZXJpZnkoIGZpcnN0TGV0dGVySW5kZXggIT09IC0xLCBgJHtxdWVyeVBhcmFtZXRlck5hbWV9OiAke2V4cHJlc3Npb259IGlzIG1pc3NpbmcgYSBnZW5vdHlwZWAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGNvdW50U3RyaW5nID0gZXhwcmVzc2lvbi5zdWJzdHJpbmcoIDAsIGZpcnN0TGV0dGVySW5kZXggKTtcclxuICAgICAgY29uc3QgZ2Vub3R5cGVTdHJpbmcgPSBleHByZXNzaW9uLnN1YnN0cmluZyggZmlyc3RMZXR0ZXJJbmRleCApO1xyXG5cclxuICAgICAgLy8gQ291bnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcclxuICAgICAgY29uc3QgY291bnRFcnJvck1lc3NhZ2UgPSBgJHtxdWVyeVBhcmFtZXRlck5hbWV9OiAke2V4cHJlc3Npb259IG11c3Qgc3RhcnQgd2l0aCBhIHBvc2l0aXZlIGludGVnZXJgO1xyXG4gICAgICB2ZXJpZnkoICFpc05hTiggTnVtYmVyKCBjb3VudFN0cmluZyApICksIGNvdW50RXJyb3JNZXNzYWdlICk7XHJcbiAgICAgIGNvbnN0IGNvdW50ID0gcGFyc2VGbG9hdCggY291bnRTdHJpbmcgKTtcclxuICAgICAgdmVyaWZ5KCBOYXR1cmFsU2VsZWN0aW9uVXRpbHMuaXNQb3NpdGl2ZUludGVnZXIoIGNvdW50ICksIGNvdW50RXJyb3JNZXNzYWdlICk7XHJcblxyXG4gICAgICAvLyBUb3RhbCBvZiBhbGwgY291bnRzIG11c3QgYmUgPCBtYXhpbXVtIHBvcHVsYXRpb25cclxuICAgICAgdG90YWxDb3VudCArPSBjb3VudDtcclxuICAgICAgdmVyaWZ5KCB0b3RhbENvdW50IDwgTmF0dXJhbFNlbGVjdGlvblF1ZXJ5UGFyYW1ldGVycy5tYXhQb3B1bGF0aW9uLFxyXG4gICAgICAgIGAke3F1ZXJ5UGFyYW1ldGVyTmFtZX06IHRoZSB0b3RhbCBwb3B1bGF0aW9uIG11c3QgYmUgPCAke05hdHVyYWxTZWxlY3Rpb25RdWVyeVBhcmFtZXRlcnMubWF4UG9wdWxhdGlvbn1gICk7XHJcblxyXG4gICAgICAvLyBHZW5vdHlwZSBtdXN0IGNvbnRhaW4gMiBhbGxlbGVzIGZvciBlYWNoIGdlbmUgcmVwcmVzZW50ZWQgaW4gbXV0YXRpb25zXHJcbiAgICAgIGNvbnN0IGdlbm90eXBlRXJyb3JNZXNzYWdlID0gYCR7cXVlcnlQYXJhbWV0ZXJOYW1lfTogJHtnZW5vdHlwZVN0cmluZ30gaXMgYW4gaW52YWxpZCBnZW5vdHlwZWA7XHJcbiAgICAgIHZlcmlmeSggZ2Vub3R5cGVTdHJpbmcubGVuZ3RoID09PSAyICogbXV0YXRpb25DaGFycy5sZW5ndGgsIGdlbm90eXBlRXJyb3JNZXNzYWdlICk7XHJcbiAgICAgIGFzc2VydCAmJiBnZW5lUG9vbC5nZW5lcy5mb3JFYWNoKCBnZW5lID0+IHtcclxuXHJcbiAgICAgICAgY29uc3QgZG9taW5hbnRBYmJyZXZpYXRpb24gPSBnZW5lLmRvbWluYW50QWJicmV2aWF0aW9uRW5nbGlzaDtcclxuICAgICAgICBjb25zdCByZWNlc3NpdmVBYmJyZXZpYXRpb24gPSBnZW5lLnJlY2Vzc2l2ZUFiYnJldmlhdGlvbkVuZ2xpc2g7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBnZW5lIGlzIHJlcHJlc2VudGVkIGluIG11dGF0aW9ucy4uLlxyXG4gICAgICAgIGlmICggbXV0YXRpb25DaGFycy5pbmNsdWRlcyggZG9taW5hbnRBYmJyZXZpYXRpb24gKSB8fCBtdXRhdGlvbkNoYXJzLmluY2x1ZGVzKCByZWNlc3NpdmVBYmJyZXZpYXRpb24gKSApIHtcclxuXHJcbiAgICAgICAgICBjb25zdCBnZW5vdHlwZUNoYXJzID0gZ2Vub3R5cGVTdHJpbmcuc3BsaXQoICcnICk7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gbXVzdCBjb250YWluIGV4YWN0bHkgMiBhbGxlbGVzIGZvciBlYWNoIGdlbmUuXHJcbiAgICAgICAgICBjb25zdCBjb3VudERvbWluYW50ID0gXy5maWx0ZXIoIGdlbm90eXBlQ2hhcnMsIGNoYXIgPT4gY2hhciA9PT0gZG9taW5hbnRBYmJyZXZpYXRpb24gKS5sZW5ndGg7XHJcbiAgICAgICAgICBjb25zdCBjb3VudFJlY2Vzc2l2ZSA9IF8uZmlsdGVyKCBnZW5vdHlwZUNoYXJzLCBjaGFyID0+IGNoYXIgPT09IHJlY2Vzc2l2ZUFiYnJldmlhdGlvbiApLmxlbmd0aDtcclxuICAgICAgICAgIHZlcmlmeSggY291bnREb21pbmFudCArIGNvdW50UmVjZXNzaXZlID09PSAyLCBnZW5vdHlwZUVycm9yTWVzc2FnZSApO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBhbGxlbGVzIG11c3QgYmUgcGFpcmVkIChhZGphY2VudCkgaW4gdGhlIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICBjb25zdCBkb21pbmFudEluZGV4ID0gZ2Vub3R5cGVDaGFycy5pbmRleE9mKCBkb21pbmFudEFiYnJldmlhdGlvbiApO1xyXG4gICAgICAgICAgY29uc3QgcmVjZXNzaXZlSW5kZXggPSBnZW5vdHlwZUNoYXJzLmluZGV4T2YoIHJlY2Vzc2l2ZUFiYnJldmlhdGlvbiApO1xyXG4gICAgICAgICAgY29uc3QgbWF4SW5kZXggPSBNYXRoLm1heCggZG9taW5hbnRJbmRleCwgcmVjZXNzaXZlSW5kZXggKTtcclxuICAgICAgICAgIGNvbnN0IG1pbkluZGV4ID0gTWF0aC5taW4oIGRvbWluYW50SW5kZXgsIHJlY2Vzc2l2ZUluZGV4ICk7XHJcbiAgICAgICAgICBjb25zdCBmaXJzdEluZGV4ID0gKCBtaW5JbmRleCAhPT0gLTEgKSA/IG1pbkluZGV4IDogbWF4SW5kZXg7XHJcbiAgICAgICAgICB2ZXJpZnkoIGdlbm90eXBlQ2hhcnNbIGZpcnN0SW5kZXggKyAxIF0gPT09IGRvbWluYW50QWJicmV2aWF0aW9uIHx8XHJcbiAgICAgICAgICAgICAgICAgIGdlbm90eXBlQ2hhcnNbIGZpcnN0SW5kZXggKyAxIF0gPT09IHJlY2Vzc2l2ZUFiYnJldmlhdGlvbixcclxuICAgICAgICAgICAgZ2Vub3R5cGVFcnJvck1lc3NhZ2UgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICAgIGluaXRpYWxQb3B1bGF0aW9uLnB1c2goIGNyZWF0ZUJ1bm55VmFyaWV0eSggZ2VuZVBvb2wsIGNvdW50LCBnZW5vdHlwZVN0cmluZyApICk7XHJcbiAgICB9XHJcbiAgICB2ZXJpZnkoIHRvdGFsQ291bnQgPiAwLCBgJHtxdWVyeVBhcmFtZXRlck5hbWV9OiB0aGUgdG90YWwgcG9wdWxhdGlvbiBtdXN0IGJlID4gMGAgKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpbml0aWFsUG9wdWxhdGlvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgZ2Vub3R5cGUgZXhwcmVzc2lvbiB0byBhIGRhdGEgc3RydWN0dXJlIHRoYXQgZGVzY3JpYmVzIHRoZSBjb3VudCBhbmQgZ2Vub3R5cGUgZm9yIGEgYnVubnkgdmFyaWV0eS5cclxuICogQWxsZWxlcyBub3QgcHJlc2VudCBpbiB0aGUgc3RyaW5nIGRlZmF1bHQgdG8gdGhlIG5vcm1hbCBhbGxlbGUgZm9yIHRoZWlyIGFzc29jaWF0ZWQgZ2VuZS5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUJ1bm55VmFyaWV0eSggZ2VuZVBvb2w6IEdlbmVQb29sLCBjb3VudDogbnVtYmVyLCBnZW5vdHlwZVN0cmluZzogc3RyaW5nICk6IEJ1bm55VmFyaWV0eSB7XHJcblxyXG4gIGFzc2VydCAmJiBhc3NlcnQoIE5hdHVyYWxTZWxlY3Rpb25VdGlscy5pc1Bvc2l0aXZlSW50ZWdlciggY291bnQgKSwgJ2ludmFsaWQgY291bnQnICk7XHJcblxyXG4gIC8vIFRvIG1ha2UgdGhpcyBjb2RlIGVhc2llciB0byByZWFkXHJcbiAgY29uc3QgZnVyR2VuZSA9IGdlbmVQb29sLmZ1ckdlbmU7XHJcbiAgY29uc3QgZWFyc0dlbmUgPSBnZW5lUG9vbC5lYXJzR2VuZTtcclxuICBjb25zdCB0ZWV0aEdlbmUgPSBnZW5lUG9vbC50ZWV0aEdlbmU7XHJcblxyXG4gIC8vIFN0YXJ0IHdpdGggbm8gYWxsZWxlcywgcG9wdWxhdGUgdGhlc2UgZGF0YSBzdHJ1Y3R1cmVzIGluIHRoZSBmb3JFYWNoIGxvb3AuXHJcbiAgY29uc3QgZnVyUGFpcjogQWxsZWxlc1BhaXIgPSB7IGZhdGhlckFsbGVsZTogbnVsbCwgbW90aGVyQWxsZWxlOiBudWxsIH07XHJcbiAgY29uc3QgZWFyc1BhaXI6IEFsbGVsZXNQYWlyID0geyBmYXRoZXJBbGxlbGU6IG51bGwsIG1vdGhlckFsbGVsZTogbnVsbCB9O1xyXG4gIGNvbnN0IHRlZXRoUGFpcjogQWxsZWxlc1BhaXIgPSB7IGZhdGhlckFsbGVsZTogbnVsbCwgbW90aGVyQWxsZWxlOiBudWxsIH07XHJcblxyXG4gIC8vIEZvciBlYWNoIGNoYXJhY3RlciBpbiB0aGUgZ2Vub3R5cGUgYWJicmV2aWF0aW9uLi4uXHJcbiAgY29uc3QgYWxsZWxlQWJicmV2aWF0aW9ucyA9IGdlbm90eXBlU3RyaW5nLnNwbGl0KCAnJyApO1xyXG4gIGFsbGVsZUFiYnJldmlhdGlvbnMuZm9yRWFjaCggYWxsZWxlQWJicmV2aWF0aW9uID0+IHtcclxuICAgIGFiYnJldmlhdGlvblRvQWxsZWxlKCBhbGxlbGVBYmJyZXZpYXRpb24sIGZ1ckdlbmUsIGZ1clBhaXIgKTtcclxuICAgIGFiYnJldmlhdGlvblRvQWxsZWxlKCBhbGxlbGVBYmJyZXZpYXRpb24sIGVhcnNHZW5lLCBlYXJzUGFpciApO1xyXG4gICAgYWJicmV2aWF0aW9uVG9BbGxlbGUoIGFsbGVsZUFiYnJldmlhdGlvbiwgdGVldGhHZW5lLCB0ZWV0aFBhaXIgKTtcclxuICB9ICk7XHJcblxyXG4gIHJldHVybiBuZXcgQnVubnlWYXJpZXR5KCBjb3VudCwgZ2Vub3R5cGVTdHJpbmcsXHJcblxyXG4gICAgLy8gRGVmYXVsdCB0byB0aGUgbm9ybWFsIGFsbGVsZSBmb3IgYW55IGFsbGVsZSB0aGF0IHdhcyBub3Qgc3BlY2lmaWVkXHJcbiAgICBmdXJQYWlyLmZhdGhlckFsbGVsZSB8fCBmdXJHZW5lLm5vcm1hbEFsbGVsZSxcclxuICAgIGZ1clBhaXIubW90aGVyQWxsZWxlIHx8IGZ1ckdlbmUubm9ybWFsQWxsZWxlLFxyXG4gICAgZWFyc1BhaXIuZmF0aGVyQWxsZWxlIHx8IGVhcnNHZW5lLm5vcm1hbEFsbGVsZSxcclxuICAgIGVhcnNQYWlyLm1vdGhlckFsbGVsZSB8fCBlYXJzR2VuZS5ub3JtYWxBbGxlbGUsXHJcbiAgICB0ZWV0aFBhaXIuZmF0aGVyQWxsZWxlIHx8IHRlZXRoR2VuZS5ub3JtYWxBbGxlbGUsXHJcbiAgICB0ZWV0aFBhaXIubW90aGVyQWxsZWxlIHx8IHRlZXRoR2VuZS5ub3JtYWxBbGxlbGVcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYW4gYWxsZWxlIGFiYnJldmlhdGlvbiB0byBhbiBhbGxlbGUsIGFuZCBwdXRzIGl0IGluIGFsbGVsZXNQYWlyLlxyXG4gKi9cclxuZnVuY3Rpb24gYWJicmV2aWF0aW9uVG9BbGxlbGUoIGFsbGVsZUFiYnJldmlhdGlvbjogc3RyaW5nLCBnZW5lOiBHZW5lLCBhbGxlbGVzUGFpcjogQWxsZWxlc1BhaXIgKTogdm9pZCB7XHJcbiAgaWYgKCBhbGxlbGVBYmJyZXZpYXRpb24gPT09IGdlbmUuZG9taW5hbnRBYmJyZXZpYXRpb25FbmdsaXNoIHx8IGFsbGVsZUFiYnJldmlhdGlvbiA9PT0gZ2VuZS5yZWNlc3NpdmVBYmJyZXZpYXRpb25FbmdsaXNoICkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZ2VuZS5kb21pbmFudEFsbGVsZVByb3BlcnR5LnZhbHVlLCBgZXhwZWN0ZWQgYSB2YWx1ZSBmb3IgJHtnZW5lLm5hbWVQcm9wZXJ0eS52YWx1ZX0gZG9taW5hbnRBbGxlbGVQcm9wZXJ0eWAgKTtcclxuXHJcbiAgICBjb25zdCBpc011dGFudERvbWluYW50ID0gKCBnZW5lLmRvbWluYW50QWxsZWxlUHJvcGVydHkudmFsdWUgPT09IGdlbmUubXV0YW50QWxsZWxlICk7XHJcbiAgICBjb25zdCBpc0FiYnJldmlhdGlvbkRvbWluYW50ID0gKCBhbGxlbGVBYmJyZXZpYXRpb24gPT09IGdlbmUuZG9taW5hbnRBYmJyZXZpYXRpb25FbmdsaXNoICk7XHJcblxyXG4gICAgY29uc3QgYWxsZWxlID0gKCAoIGlzTXV0YW50RG9taW5hbnQgJiYgaXNBYmJyZXZpYXRpb25Eb21pbmFudCApIHx8ICggIWlzTXV0YW50RG9taW5hbnQgJiYgIWlzQWJicmV2aWF0aW9uRG9taW5hbnQgKSApID9cclxuICAgICAgICAgICAgICAgICAgIGdlbmUubXV0YW50QWxsZWxlIDogZ2VuZS5ub3JtYWxBbGxlbGU7XHJcblxyXG4gICAgLy8gUG9wdWxhdGUgZmF0aGVyQWxsZWxlIGZpcnN0LCBtb3RoZXJBbGxlbGUgc2Vjb25kXHJcbiAgICBpZiAoICFhbGxlbGVzUGFpci5mYXRoZXJBbGxlbGUgKSB7XHJcbiAgICAgIGFsbGVsZXNQYWlyLmZhdGhlckFsbGVsZSA9IGFsbGVsZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhYWxsZWxlc1BhaXIubW90aGVyQWxsZWxlLCAnbW90aGVyQWxsZWxlIHNob3VsZCBiZSBudWxsJyApO1xyXG4gICAgICBhbGxlbGVzUGFpci5tb3RoZXJBbGxlbGUgPSBhbGxlbGU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVmVyaWZpZXMgdGhhdCBhIHByZWRpY2F0ZSBpcyB0cnVlLiBJZiBpdCdzIG5vdCB0cnVlLCB0aHJvdyBhbiBFcnJvciB0aGF0IGluY2x1ZGVzIHRoZSBzcGVjaWZpZWQgbWVzc2FnZS5cclxuICovXHJcbmZ1bmN0aW9uIHZlcmlmeSggcHJlZGljYXRlOiBib29sZWFuLCBtZXNzYWdlOiBzdHJpbmcgKTogdm9pZCB7XHJcbiAgaWYgKCAhcHJlZGljYXRlICkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7XHJcbiAgfVxyXG59XHJcblxyXG5uYXR1cmFsU2VsZWN0aW9uLnJlZ2lzdGVyKCAncGFyc2VJbml0aWFsUG9wdWxhdGlvbicsIHBhcnNlSW5pdGlhbFBvcHVsYXRpb24gKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGdCQUFnQixNQUFNLDJCQUEyQjtBQUN4RCxPQUFPQywrQkFBK0IsSUFBSUMsVUFBVSxRQUFRLHVDQUF1QztBQUNuRyxPQUFPQyxxQkFBcUIsTUFBTSw2QkFBNkI7QUFFL0QsT0FBT0MsWUFBWSxNQUFNLG1CQUFtQjs7QUFTNUM7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTQyxzQkFBc0JBLENBQUVDLFNBQW9CLEVBQUVDLFFBQWtCLEVBQW1CO0VBRXpHLE1BQU1DLDJCQUEyQixHQUFJLEdBQUVGLFNBQVUsV0FBVTtFQUMzRCxNQUFNRyw0QkFBNEIsR0FBSSxHQUFFSCxTQUFVLFlBQVc7O0VBRTdEO0VBQ0EsTUFBTUksY0FBYyxHQUFPSixTQUFTLEtBQUssT0FBTyxHQUFLTCwrQkFB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