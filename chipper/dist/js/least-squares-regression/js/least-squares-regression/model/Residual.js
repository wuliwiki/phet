// Copyright 2014-2020, University of Colorado Boulder

/**
 * Type that defines a residual and a square residual.
 *
 * @author John Blanco
 * @author Martin Veillette (Berea College)
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import leastSquaresRegression from '../../leastSquaresRegression.js';
class Residual {
  /**
   * @param {DataPoint} dataPoint
   * @param {number} slope
   * @param {number} intercept
   */
  constructor(dataPoint, slope, intercept) {
    // store the dataPoint to be able to identify residual node
    this.dataPoint = dataPoint;

    // find the vertical position of the line following y = slope* x + intercept;
    const yValue = slope * dataPoint.positionProperty.value.x + intercept;

    // The vertical displacement is positive if the datePoint is above the line and negative if below
    const verticalDisplacement = dataPoint.positionProperty.value.y - yValue;

    // @public read-only
    this.point1 = new Vector2(dataPoint.positionProperty.value.x, dataPoint.positionProperty.value.y); // position of dataPoint
    this.point2 = new Vector2(dataPoint.positionProperty.value.x, yValue); // position of the point on the line

    // the square residual should not overlap the line
    // @public read-only
    this.isSquaredResidualToTheLeft = slope * verticalDisplacement > 0;
  }
}
leastSquaresRegression.register('Residual', Residual);
export default Residual;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwibGVhc3RTcXVhcmVzUmVncmVzc2lvbiIsIlJlc2lkdWFsIiwiY29uc3RydWN0b3IiLCJkYXRhUG9pbnQiLCJzbG9wZSIsImludGVyY2VwdCIsInlWYWx1ZSIsInBvc2l0aW9uUHJvcGVydHkiLCJ2YWx1ZSIsIngiLCJ2ZXJ0aWNhbERpc3BsYWNlbWVudCIsInkiLCJwb2ludDEiLCJwb2ludDIiLCJpc1NxdWFyZWRSZXNpZHVhbFRvVGhlTGVmdCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiUmVzaWR1YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTQtMjAyMCwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVHlwZSB0aGF0IGRlZmluZXMgYSByZXNpZHVhbCBhbmQgYSBzcXVhcmUgcmVzaWR1YWwuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICogQGF1dGhvciBNYXJ0aW4gVmVpbGxldHRlIChCZXJlYSBDb2xsZWdlKVxyXG4gKi9cclxuXHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IGxlYXN0U3F1YXJlc1JlZ3Jlc3Npb24gZnJvbSAnLi4vLi4vbGVhc3RTcXVhcmVzUmVncmVzc2lvbi5qcyc7XHJcblxyXG5jbGFzcyBSZXNpZHVhbCB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtEYXRhUG9pbnR9IGRhdGFQb2ludFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzbG9wZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcmNlcHRcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggZGF0YVBvaW50LCBzbG9wZSwgaW50ZXJjZXB0ICkge1xyXG5cclxuICAgIC8vIHN0b3JlIHRoZSBkYXRhUG9pbnQgdG8gYmUgYWJsZSB0byBpZGVudGlmeSByZXNpZHVhbCBub2RlXHJcbiAgICB0aGlzLmRhdGFQb2ludCA9IGRhdGFQb2ludDtcclxuXHJcbiAgICAvLyBmaW5kIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgbGluZSBmb2xsb3dpbmcgeSA9IHNsb3BlKiB4ICsgaW50ZXJjZXB0O1xyXG4gICAgY29uc3QgeVZhbHVlID0gc2xvcGUgKiBkYXRhUG9pbnQucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS54ICsgaW50ZXJjZXB0O1xyXG5cclxuICAgIC8vIFRoZSB2ZXJ0aWNhbCBkaXNwbGFjZW1lbnQgaXMgcG9zaXRpdmUgaWYgdGhlIGRhdGVQb2ludCBpcyBhYm92ZSB0aGUgbGluZSBhbmQgbmVnYXRpdmUgaWYgYmVsb3dcclxuICAgIGNvbnN0IHZlcnRpY2FsRGlzcGxhY2VtZW50ID0gZGF0YVBvaW50LnBvc2l0aW9uUHJvcGVydHkudmFsdWUueSAtIHlWYWx1ZTtcclxuXHJcbiAgICAvLyBAcHVibGljIHJlYWQtb25seVxyXG4gICAgdGhpcy5wb2ludDEgPSBuZXcgVmVjdG9yMiggZGF0YVBvaW50LnBvc2l0aW9uUHJvcGVydHkudmFsdWUueCwgZGF0YVBvaW50LnBvc2l0aW9uUHJvcGVydHkudmFsdWUueSApOyAgLy8gcG9zaXRpb24gb2YgZGF0YVBvaW50XHJcbiAgICB0aGlzLnBvaW50MiA9IG5ldyBWZWN0b3IyKCBkYXRhUG9pbnQucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS54LCB5VmFsdWUgKTsgICAvLyBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIGxpbmVcclxuXHJcbiAgICAvLyB0aGUgc3F1YXJlIHJlc2lkdWFsIHNob3VsZCBub3Qgb3ZlcmxhcCB0aGUgbGluZVxyXG4gICAgLy8gQHB1YmxpYyByZWFkLW9ubHlcclxuICAgIHRoaXMuaXNTcXVhcmVkUmVzaWR1YWxUb1RoZUxlZnQgPSAoIHNsb3BlICogdmVydGljYWxEaXNwbGFjZW1lbnQgPiAwICk7XHJcbiAgfVxyXG59XHJcblxyXG5sZWFzdFNxdWFyZXNSZWdyZXNzaW9uLnJlZ2lzdGVyKCAnUmVzaWR1YWwnLCBSZXNpZHVhbCApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVzaWR1YWw7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxPQUFPQyxzQkFBc0IsTUFBTSxpQ0FBaUM7QUFFcEUsTUFBTUMsUUFBUSxDQUFDO0VBQ2I7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxXQUFXQSxDQUFFQyxTQUFTLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFHO0lBRXpDO0lBQ0EsSUFBSSxDQUFDRixTQUFTLEdBQUdBLFNBQVM7O0lBRTFCO0lBQ0EsTUFBTUcsTUFBTSxHQUFHRixLQUFLLEdBQUdELFNBQVMsQ0FBQ0ksZ0JBQWdCLENBQUNDLEtBQUssQ0FBQ0MsQ0FBQyxHQUFHSixTQUFTOztJQUVyRTtJQUNBLE1BQU1LLG9CQUFvQixHQUFHUCxTQUFTLENBQUNJLGdCQUFnQixDQUFDQyxLQUFLLENBQUNHLENBQUMsR0FBR0wsTUFBTTs7SUFFeEU7SUFDQSxJQUFJLENBQUNNLE1BQU0sR0FBRyxJQUFJYixPQUFPLENBQUVJLFNBQVMsQ0FBQ0ksZ0JBQWdCLENBQUNDLEtBQUssQ0FBQ0MsQ0FBQyxFQUFFTixTQUFTLENBQUNJLGdCQUFnQixDQUFDQyxLQUFLLENBQUNHLENBQUUsQ0FBQyxDQUFDLENBQUU7SUFDdEcsSUFBSSxDQUFDRSxNQUFNLEdBQUcsSUFBSWQsT0FBTyxDQUFFSSxTQUFTLENBQUNJLGdCQUFnQixDQUFDQyxLQUFLLENBQUNDLENBQUMsRUFBRUgsTUFBTyxDQUFDLENBQUMsQ0FBRzs7SUFFM0U7SUFDQTtJQUNBLElBQUksQ0FBQ1EsMEJBQTBCLEdBQUtWLEtBQUssR0FBR00sb0JBQW9CLEdBQUcsQ0FBRztFQUN4RTtBQUNGO0FBRUFWLHNCQUFzQixDQUFDZSxRQUFRLENBQUUsVUFBVSxFQUFFZCxRQUFTLENBQUM7QUFFdkQsZUFBZUEsUUFBUSJ9