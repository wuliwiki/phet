// Copyright 2014-2022, University of Colorado Boulder

/**
 * Type that represents a movable dataPoint in the view.
 *
 * @author Martin Veillette (Berea College)
 */

import { Circle, SimpleDragHandler } from '../../../../scenery/js/imports.js';
import leastSquaresRegression from '../../leastSquaresRegression.js';
import LeastSquaresRegressionConstants from '../LeastSquaresRegressionConstants.js';
import DataPointNode from './DataPointNode.js';
class DynamicDataPointNode extends DataPointNode {
  /**
   * @param {DataPoint} dataPoint
   * @param {ModelViewTransform2} modelViewTransform
   */
  constructor(dataPoint, modelViewTransform) {
    // Create the visual representation of the DynamicDataPoint
    const representation = new Circle(LeastSquaresRegressionConstants.DYNAMIC_DATA_POINT_RADIUS, {
      fill: LeastSquaresRegressionConstants.DYNAMIC_DATA_POINT_FILL,
      stroke: LeastSquaresRegressionConstants.DYNAMIC_DATA_POINT_STROKE,
      lineWidth: LeastSquaresRegressionConstants.DYNAMIC_DATA_POINT_LINE_WIDTH
    });
    super(dataPoint, representation, modelViewTransform);

    // Expand the touch area
    this.touchArea = this.localBounds.dilatedXY(15, 15);

    // Add the listener that will allow the user to drag the dataPoint around.
    this.addInputListener(new SimpleDragHandler({
      // Allow moving a finger (touch) across a node to pick it up.
      allowTouchSnag: true,
      // Handler that moves the dataPoint in model space.
      start: (event, trail) => {
        dataPoint.userControlledProperty.set(true);
      },
      translate: args => {
        dataPoint.positionProperty.value = modelViewTransform.viewToModelPosition(args.position);
      },
      end: () => {
        dataPoint.userControlledProperty.set(false);
      }
    }));
  }
}
leastSquaresRegression.register('DynamicDataPointNode', DynamicDataPointNode);
export default DynamicDataPointNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJDaXJjbGUiLCJTaW1wbGVEcmFnSGFuZGxlciIsImxlYXN0U3F1YXJlc1JlZ3Jlc3Npb24iLCJMZWFzdFNxdWFyZXNSZWdyZXNzaW9uQ29uc3RhbnRzIiwiRGF0YVBvaW50Tm9kZSIsIkR5bmFtaWNEYXRhUG9pbnROb2RlIiwiY29uc3RydWN0b3IiLCJkYXRhUG9pbnQiLCJtb2RlbFZpZXdUcmFuc2Zvcm0iLCJyZXByZXNlbnRhdGlvbiIsIkRZTkFNSUNfREFUQV9QT0lOVF9SQURJVVMiLCJmaWxsIiwiRFlOQU1JQ19EQVRBX1BPSU5UX0ZJTEwiLCJzdHJva2UiLCJEWU5BTUlDX0RBVEFfUE9JTlRfU1RST0tFIiwibGluZVdpZHRoIiwiRFlOQU1JQ19EQVRBX1BPSU5UX0xJTkVfV0lEVEgiLCJ0b3VjaEFyZWEiLCJsb2NhbEJvdW5kcyIsImRpbGF0ZWRYWSIsImFkZElucHV0TGlzdGVuZXIiLCJhbGxvd1RvdWNoU25hZyIsInN0YXJ0IiwiZXZlbnQiLCJ0cmFpbCIsInVzZXJDb250cm9sbGVkUHJvcGVydHkiLCJzZXQiLCJ0cmFuc2xhdGUiLCJhcmdzIiwicG9zaXRpb25Qcm9wZXJ0eSIsInZhbHVlIiwidmlld1RvTW9kZWxQb3NpdGlvbiIsInBvc2l0aW9uIiwiZW5kIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJEeW5hbWljRGF0YVBvaW50Tm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNC0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBUeXBlIHRoYXQgcmVwcmVzZW50cyBhIG1vdmFibGUgZGF0YVBvaW50IGluIHRoZSB2aWV3LlxyXG4gKlxyXG4gKiBAYXV0aG9yIE1hcnRpbiBWZWlsbGV0dGUgKEJlcmVhIENvbGxlZ2UpXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQ2lyY2xlLCBTaW1wbGVEcmFnSGFuZGxlciB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBsZWFzdFNxdWFyZXNSZWdyZXNzaW9uIGZyb20gJy4uLy4uL2xlYXN0U3F1YXJlc1JlZ3Jlc3Npb24uanMnO1xyXG5pbXBvcnQgTGVhc3RTcXVhcmVzUmVncmVzc2lvbkNvbnN0YW50cyBmcm9tICcuLi9MZWFzdFNxdWFyZXNSZWdyZXNzaW9uQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IERhdGFQb2ludE5vZGUgZnJvbSAnLi9EYXRhUG9pbnROb2RlLmpzJztcclxuXHJcbmNsYXNzIER5bmFtaWNEYXRhUG9pbnROb2RlIGV4dGVuZHMgRGF0YVBvaW50Tm9kZSB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtEYXRhUG9pbnR9IGRhdGFQb2ludFxyXG4gICAqIEBwYXJhbSB7TW9kZWxWaWV3VHJhbnNmb3JtMn0gbW9kZWxWaWV3VHJhbnNmb3JtXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGRhdGFQb2ludCwgbW9kZWxWaWV3VHJhbnNmb3JtICkge1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBEeW5hbWljRGF0YVBvaW50XHJcbiAgICBjb25zdCByZXByZXNlbnRhdGlvbiA9IG5ldyBDaXJjbGUoIExlYXN0U3F1YXJlc1JlZ3Jlc3Npb25Db25zdGFudHMuRFlOQU1JQ19EQVRBX1BPSU5UX1JBRElVUywge1xyXG4gICAgICBmaWxsOiBMZWFzdFNxdWFyZXNSZWdyZXNzaW9uQ29uc3RhbnRzLkRZTkFNSUNfREFUQV9QT0lOVF9GSUxMLFxyXG4gICAgICBzdHJva2U6IExlYXN0U3F1YXJlc1JlZ3Jlc3Npb25Db25zdGFudHMuRFlOQU1JQ19EQVRBX1BPSU5UX1NUUk9LRSxcclxuICAgICAgbGluZVdpZHRoOiBMZWFzdFNxdWFyZXNSZWdyZXNzaW9uQ29uc3RhbnRzLkRZTkFNSUNfREFUQV9QT0lOVF9MSU5FX1dJRFRIXHJcbiAgICB9ICk7XHJcblxyXG4gICAgc3VwZXIoIGRhdGFQb2ludCwgcmVwcmVzZW50YXRpb24sIG1vZGVsVmlld1RyYW5zZm9ybSApO1xyXG5cclxuICAgIC8vIEV4cGFuZCB0aGUgdG91Y2ggYXJlYVxyXG4gICAgdGhpcy50b3VjaEFyZWEgPSB0aGlzLmxvY2FsQm91bmRzLmRpbGF0ZWRYWSggMTUsIDE1ICk7XHJcblxyXG4gICAgLy8gQWRkIHRoZSBsaXN0ZW5lciB0aGF0IHdpbGwgYWxsb3cgdGhlIHVzZXIgdG8gZHJhZyB0aGUgZGF0YVBvaW50IGFyb3VuZC5cclxuICAgIHRoaXMuYWRkSW5wdXRMaXN0ZW5lciggbmV3IFNpbXBsZURyYWdIYW5kbGVyKCB7XHJcbiAgICAgIC8vIEFsbG93IG1vdmluZyBhIGZpbmdlciAodG91Y2gpIGFjcm9zcyBhIG5vZGUgdG8gcGljayBpdCB1cC5cclxuICAgICAgYWxsb3dUb3VjaFNuYWc6IHRydWUsXHJcblxyXG4gICAgICAvLyBIYW5kbGVyIHRoYXQgbW92ZXMgdGhlIGRhdGFQb2ludCBpbiBtb2RlbCBzcGFjZS5cclxuICAgICAgc3RhcnQ6ICggZXZlbnQsIHRyYWlsICkgPT4ge1xyXG4gICAgICAgIGRhdGFQb2ludC51c2VyQ29udHJvbGxlZFByb3BlcnR5LnNldCggdHJ1ZSApO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgdHJhbnNsYXRlOiBhcmdzID0+IHtcclxuICAgICAgICBkYXRhUG9pbnQucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZSA9IG1vZGVsVmlld1RyYW5zZm9ybS52aWV3VG9Nb2RlbFBvc2l0aW9uKCBhcmdzLnBvc2l0aW9uICk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBlbmQ6ICgpID0+IHtcclxuICAgICAgICBkYXRhUG9pbnQudXNlckNvbnRyb2xsZWRQcm9wZXJ0eS5zZXQoIGZhbHNlICk7XHJcbiAgICAgIH1cclxuICAgIH0gKSApO1xyXG4gIH1cclxufVxyXG5cclxubGVhc3RTcXVhcmVzUmVncmVzc2lvbi5yZWdpc3RlciggJ0R5bmFtaWNEYXRhUG9pbnROb2RlJywgRHluYW1pY0RhdGFQb2ludE5vZGUgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IER5bmFtaWNEYXRhUG9pbnROb2RlOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTQSxNQUFNLEVBQUVDLGlCQUFpQixRQUFRLG1DQUFtQztBQUM3RSxPQUFPQyxzQkFBc0IsTUFBTSxpQ0FBaUM7QUFDcEUsT0FBT0MsK0JBQStCLE1BQU0sdUNBQXVDO0FBQ25GLE9BQU9DLGFBQWEsTUFBTSxvQkFBb0I7QUFFOUMsTUFBTUMsb0JBQW9CLFNBQVNELGFBQWEsQ0FBQztFQUMvQztBQUNGO0FBQ0E7QUFDQTtFQUNFRSxXQUFXQSxDQUFFQyxTQUFTLEVBQUVDLGtCQUFrQixFQUFHO0lBRTNDO0lBQ0EsTUFBTUMsY0FBYyxHQUFHLElBQUlULE1BQU0sQ0FBRUcsK0JBQStCLENBQUNPLHlCQUF5QixFQUFFO01BQzVGQyxJQUFJLEVBQUVSLCtCQUErQixDQUFDUyx1QkFBdUI7TUFDN0RDLE1BQU0sRUFBRVYsK0JBQStCLENBQUNXLHlCQUF5QjtNQUNqRUMsU0FBUyxFQUFFWiwrQkFBK0IsQ0FBQ2E7SUFDN0MsQ0FBRSxDQUFDO0lBRUgsS0FBSyxDQUFFVCxTQUFTLEVBQUVFLGNBQWMsRUFBRUQsa0JBQW1CLENBQUM7O0lBRXREO0lBQ0EsSUFBSSxDQUFDUyxTQUFTLEdBQUcsSUFBSSxDQUFDQyxXQUFXLENBQUNDLFNBQVMsQ0FBRSxFQUFFLEVBQUUsRUFBRyxDQUFDOztJQUVyRDtJQUNBLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUUsSUFBSW5CLGlCQUFpQixDQUFFO01BQzVDO01BQ0FvQixjQUFjLEVBQUUsSUFBSTtNQUVwQjtNQUNBQyxLQUFLLEVBQUVBLENBQUVDLEtBQUssRUFBRUMsS0FBSyxLQUFNO1FBQ3pCakIsU0FBUyxDQUFDa0Isc0JBQXNCLENBQUNDLEdBQUcsQ0FBRSxJQUFLLENBQUM7TUFDOUMsQ0FBQztNQUVEQyxTQUFTLEVBQUVDLElBQUksSUFBSTtRQUNqQnJCLFNBQVMsQ0FBQ3NCLGdCQUFnQixDQUFDQyxLQUFLLEdBQUd0QixrQkFBa0IsQ0FBQ3VCLG1CQUFtQixDQUFFSCxJQUFJLENBQUNJLFFBQVMsQ0FBQztNQUM1RixDQUFDO01BRURDLEdBQUcsRUFBRUEsQ0FBQSxLQUFNO1FBQ1QxQixTQUFTLENBQUNrQixzQkFBc0IsQ0FBQ0MsR0FBRyxDQUFFLEtBQU0sQ0FBQztNQUMvQztJQUNGLENBQUUsQ0FBRSxDQUFDO0VBQ1A7QUFDRjtBQUVBeEIsc0JBQXNCLENBQUNnQyxRQUFRLENBQUUsc0JBQXNCLEVBQUU3QixvQkFBcUIsQ0FBQztBQUUvRSxlQUFlQSxvQkFBb0IifQ==