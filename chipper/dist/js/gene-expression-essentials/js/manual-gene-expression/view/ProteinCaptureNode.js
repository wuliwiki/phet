// Copyright 2015-2023, University of Colorado Boulder

/**
 * Class that represents a node for collecting a single protein and a counter of the number of the protein type collected.
 *
 * @author Sharfudeen Ashraf
 * @author John Blanco
 * @author Aadish Gupta
 */

import Matrix3 from '../../../../dot/js/Matrix3.js';
import { Shape } from '../../../../kite/js/imports.js';
import PhetFont from '../../../../scenery-phet/js/PhetFont.js';
import { Color, Node, Path, Text } from '../../../../scenery/js/imports.js';
import GradientUtils from '../../common/util/GradientUtils.js';
import geneExpressionEssentials from '../../geneExpressionEssentials.js';
import ProteinA from '../model/ProteinA.js';
import ProteinB from '../model/ProteinB.js';
import ProteinC from '../model/ProteinC.js';
import FlashingShapeNode from './FlashingShapeNode.js';

// constants
const FLASH_COLOR = new Color(173, 255, 47);
const SCALE_FOR_FLASH_NODE = 1.5;

// Tweak warning: This is used to make sure that the counters on the various protein nodes end up horizontally
// aligned.  This will need to be adjust if the protein shapes change a lot.
const VERTICAL_DISTANCE_TO_COUNT_NODE = 40;
const proteinStringConstructorMap = {
  ProteinA: ProteinA,
  ProteinB: ProteinB,
  ProteinC: ProteinC
};
class ProteinCaptureNode extends Node {
  /**
   * @param {ManualGeneExpressionModel} model
   * @param {string} proteinClassName
   * @param {Matrix3} transform
   * @param {Dimension2} size
   */
  constructor(model, proteinClassName, transform, size) {
    super();

    // Get the shape of the protein.
    const protein = new proteinStringConstructorMap[proteinClassName]();
    const proteinShape = protein.getFullyGrownShape().transformed(transform);
    const fullBaseColor = protein.colorProperty.get();

    // Add the background node. This is invisible, and exists only to make the node a specific size.
    this.addChild(new Path(Shape.rectangle(-size.width / 2, -size.height / 2, size.width, size.height), {
      fill: new Color(0, 0, 0, 0)
    }));

    // Add the node that will flash when a protein is created, stay lit until the protein is captured, and turn off once
    // it is captured.
    const flashingCaptureNodeShape = proteinShape.transformed(Matrix3.scaling(SCALE_FOR_FLASH_NODE, SCALE_FOR_FLASH_NODE));
    const flashingCaptureNode = new FlashingShapeNode(flashingCaptureNodeShape, FLASH_COLOR);
    this.addChild(flashingCaptureNode);

    // Add the node that will represent the spot where the protein can be captured, which is a black shape (signifying
    // emptiness) until a protein is captured, then it changes to look filled in.
    const captureAreaNode = new Path(proteinShape, {
      stroke: 'black'
    });
    this.addChild(captureAreaNode);
    const gradientPaint = GradientUtils.createGradientPaint(proteinShape, fullBaseColor);

    // Add the node that represents a count of the collected type.
    const countNode = new Text('', {
      font: new PhetFont({
        size: 18,
        weight: 'bold'
      })
    });
    this.addChild(countNode);
    model.getCollectedCounterForProteinType(proteinClassName).link(proteinCaptureCount => {
      countNode.string = proteinCaptureCount;
      countNode.x = captureAreaNode.bounds.getCenterX() - countNode.bounds.width / 2;
      countNode.y = captureAreaNode.bounds.getCenterY() + VERTICAL_DISTANCE_TO_COUNT_NODE;
    });

    // Watch for a protein node of the appropriate type to become fully grown and, when it does, flash a node in order
    // to signal the user that the protein should be placed here.
    model.mobileBiomoleculeList.addItemAddedListener(biomolecule => {
      if (biomolecule instanceof proteinStringConstructorMap[proteinClassName]) {
        biomolecule.fullGrownProperty.link((isFullyFormed, wasFullyFormed) => {
          if (isFullyFormed && !wasFullyFormed) {
            flashingCaptureNode.startFlashing();
          }
        });
      }
    });

    // Get the capture count property for this protein.
    const captureCountProperty = model.getCollectedCounterForProteinType(proteinClassName);

    // Observe the capture indicator and set the state of the nodes appropriately.
    captureCountProperty.link(captureCount => {
      if (captureCount > 0) {
        captureAreaNode.fill = gradientPaint;
      } else {
        // No proteins capture, so set to black to appear empty.
        captureAreaNode.fill = Color.BLACK;
      }
    });

    // Observe the biomolecules and make sure that if none of the protein that this collects is in the model, the
    // highlight is off.
    model.mobileBiomoleculeList.addItemRemovedListener(biomolecule => {
      if (biomolecule instanceof proteinStringConstructorMap[proteinClassName] && model.getProteinCount(proteinStringConstructorMap[proteinClassName]) === 0) {
        // Make sure highlight is off.
        flashingCaptureNode.forceFlashOff();
      }
    });
  }
}
ProteinCaptureNode.SCALE_FOR_FLASH_NODE = SCALE_FOR_FLASH_NODE;
geneExpressionEssentials.register('ProteinCaptureNode', ProteinCaptureNode);
export default ProteinCaptureNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNYXRyaXgzIiwiU2hhcGUiLCJQaGV0Rm9udCIsIkNvbG9yIiwiTm9kZSIsIlBhdGgiLCJUZXh0IiwiR3JhZGllbnRVdGlscyIsImdlbmVFeHByZXNzaW9uRXNzZW50aWFscyIsIlByb3RlaW5BIiwiUHJvdGVpbkIiLCJQcm90ZWluQyIsIkZsYXNoaW5nU2hhcGVOb2RlIiwiRkxBU0hfQ09MT1IiLCJTQ0FMRV9GT1JfRkxBU0hfTk9ERSIsIlZFUlRJQ0FMX0RJU1RBTkNFX1RPX0NPVU5UX05PREUiLCJwcm90ZWluU3RyaW5nQ29uc3RydWN0b3JNYXAiLCJQcm90ZWluQ2FwdHVyZU5vZGUiLCJjb25zdHJ1Y3RvciIsIm1vZGVsIiwicHJvdGVpbkNsYXNzTmFtZSIsInRyYW5zZm9ybSIsInNpemUiLCJwcm90ZWluIiwicHJvdGVpblNoYXBlIiwiZ2V0RnVsbHlHcm93blNoYXBlIiwidHJhbnNmb3JtZWQiLCJmdWxsQmFzZUNvbG9yIiwiY29sb3JQcm9wZXJ0eSIsImdldCIsImFkZENoaWxkIiwicmVjdGFuZ2xlIiwid2lkdGgiLCJoZWlnaHQiLCJmaWxsIiwiZmxhc2hpbmdDYXB0dXJlTm9kZVNoYXBlIiwic2NhbGluZyIsImZsYXNoaW5nQ2FwdHVyZU5vZGUiLCJjYXB0dXJlQXJlYU5vZGUiLCJzdHJva2UiLCJncmFkaWVudFBhaW50IiwiY3JlYXRlR3JhZGllbnRQYWludCIsImNvdW50Tm9kZSIsImZvbnQiLCJ3ZWlnaHQiLCJnZXRDb2xsZWN0ZWRDb3VudGVyRm9yUHJvdGVpblR5cGUiLCJsaW5rIiwicHJvdGVpbkNhcHR1cmVDb3VudCIsInN0cmluZyIsIngiLCJib3VuZHMiLCJnZXRDZW50ZXJYIiwieSIsImdldENlbnRlclkiLCJtb2JpbGVCaW9tb2xlY3VsZUxpc3QiLCJhZGRJdGVtQWRkZWRMaXN0ZW5lciIsImJpb21vbGVjdWxlIiwiZnVsbEdyb3duUHJvcGVydHkiLCJpc0Z1bGx5Rm9ybWVkIiwid2FzRnVsbHlGb3JtZWQiLCJzdGFydEZsYXNoaW5nIiwiY2FwdHVyZUNvdW50UHJvcGVydHkiLCJjYXB0dXJlQ291bnQiLCJCTEFDSyIsImFkZEl0ZW1SZW1vdmVkTGlzdGVuZXIiLCJnZXRQcm90ZWluQ291bnQiLCJmb3JjZUZsYXNoT2ZmIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJQcm90ZWluQ2FwdHVyZU5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgbm9kZSBmb3IgY29sbGVjdGluZyBhIHNpbmdsZSBwcm90ZWluIGFuZCBhIGNvdW50ZXIgb2YgdGhlIG51bWJlciBvZiB0aGUgcHJvdGVpbiB0eXBlIGNvbGxlY3RlZC5cclxuICpcclxuICogQGF1dGhvciBTaGFyZnVkZWVuIEFzaHJhZlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvXHJcbiAqIEBhdXRob3IgQWFkaXNoIEd1cHRhXHJcbiAqL1xyXG5cclxuaW1wb3J0IE1hdHJpeDMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL01hdHJpeDMuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBQaGV0Rm9udCBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvUGhldEZvbnQuanMnO1xyXG5pbXBvcnQgeyBDb2xvciwgTm9kZSwgUGF0aCwgVGV4dCB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBHcmFkaWVudFV0aWxzIGZyb20gJy4uLy4uL2NvbW1vbi91dGlsL0dyYWRpZW50VXRpbHMuanMnO1xyXG5pbXBvcnQgZ2VuZUV4cHJlc3Npb25Fc3NlbnRpYWxzIGZyb20gJy4uLy4uL2dlbmVFeHByZXNzaW9uRXNzZW50aWFscy5qcyc7XHJcbmltcG9ydCBQcm90ZWluQSBmcm9tICcuLi9tb2RlbC9Qcm90ZWluQS5qcyc7XHJcbmltcG9ydCBQcm90ZWluQiBmcm9tICcuLi9tb2RlbC9Qcm90ZWluQi5qcyc7XHJcbmltcG9ydCBQcm90ZWluQyBmcm9tICcuLi9tb2RlbC9Qcm90ZWluQy5qcyc7XHJcbmltcG9ydCBGbGFzaGluZ1NoYXBlTm9kZSBmcm9tICcuL0ZsYXNoaW5nU2hhcGVOb2RlLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBGTEFTSF9DT0xPUiA9IG5ldyBDb2xvciggMTczLCAyNTUsIDQ3ICk7XHJcbmNvbnN0IFNDQUxFX0ZPUl9GTEFTSF9OT0RFID0gMS41O1xyXG5cclxuLy8gVHdlYWsgd2FybmluZzogVGhpcyBpcyB1c2VkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBjb3VudGVycyBvbiB0aGUgdmFyaW91cyBwcm90ZWluIG5vZGVzIGVuZCB1cCBob3Jpem9udGFsbHlcclxuLy8gYWxpZ25lZC4gIFRoaXMgd2lsbCBuZWVkIHRvIGJlIGFkanVzdCBpZiB0aGUgcHJvdGVpbiBzaGFwZXMgY2hhbmdlIGEgbG90LlxyXG5jb25zdCBWRVJUSUNBTF9ESVNUQU5DRV9UT19DT1VOVF9OT0RFID0gNDA7XHJcblxyXG5jb25zdCBwcm90ZWluU3RyaW5nQ29uc3RydWN0b3JNYXAgPSB7XHJcbiAgUHJvdGVpbkE6IFByb3RlaW5BLFxyXG4gIFByb3RlaW5COiBQcm90ZWluQixcclxuICBQcm90ZWluQzogUHJvdGVpbkNcclxufTtcclxuXHJcbmNsYXNzIFByb3RlaW5DYXB0dXJlTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge01hbnVhbEdlbmVFeHByZXNzaW9uTW9kZWx9IG1vZGVsXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RlaW5DbGFzc05hbWVcclxuICAgKiBAcGFyYW0ge01hdHJpeDN9IHRyYW5zZm9ybVxyXG4gICAqIEBwYXJhbSB7RGltZW5zaW9uMn0gc2l6ZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBtb2RlbCwgcHJvdGVpbkNsYXNzTmFtZSwgdHJhbnNmb3JtLCBzaXplICkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIHNoYXBlIG9mIHRoZSBwcm90ZWluLlxyXG4gICAgY29uc3QgcHJvdGVpbiA9IG5ldyBwcm90ZWluU3RyaW5nQ29uc3RydWN0b3JNYXBbIHByb3RlaW5DbGFzc05hbWUgXSgpO1xyXG4gICAgY29uc3QgcHJvdGVpblNoYXBlID0gcHJvdGVpbi5nZXRGdWxseUdyb3duU2hhcGUoKS50cmFuc2Zvcm1lZCggdHJhbnNmb3JtICk7XHJcbiAgICBjb25zdCBmdWxsQmFzZUNvbG9yID0gcHJvdGVpbi5jb2xvclByb3BlcnR5LmdldCgpO1xyXG5cclxuICAgIC8vIEFkZCB0aGUgYmFja2dyb3VuZCBub2RlLiBUaGlzIGlzIGludmlzaWJsZSwgYW5kIGV4aXN0cyBvbmx5IHRvIG1ha2UgdGhlIG5vZGUgYSBzcGVjaWZpYyBzaXplLlxyXG4gICAgdGhpcy5hZGRDaGlsZCggbmV3IFBhdGgoIFNoYXBlLnJlY3RhbmdsZSggLXNpemUud2lkdGggLyAyLCAtc2l6ZS5oZWlnaHQgLyAyLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCApLCB7XHJcbiAgICAgIGZpbGw6IG5ldyBDb2xvciggMCwgMCwgMCwgMCApXHJcbiAgICB9ICkgKTtcclxuXHJcbiAgICAvLyBBZGQgdGhlIG5vZGUgdGhhdCB3aWxsIGZsYXNoIHdoZW4gYSBwcm90ZWluIGlzIGNyZWF0ZWQsIHN0YXkgbGl0IHVudGlsIHRoZSBwcm90ZWluIGlzIGNhcHR1cmVkLCBhbmQgdHVybiBvZmYgb25jZVxyXG4gICAgLy8gaXQgaXMgY2FwdHVyZWQuXHJcbiAgICBjb25zdCBmbGFzaGluZ0NhcHR1cmVOb2RlU2hhcGUgPSBwcm90ZWluU2hhcGUudHJhbnNmb3JtZWQoIE1hdHJpeDMuc2NhbGluZyggU0NBTEVfRk9SX0ZMQVNIX05PREUsIFNDQUxFX0ZPUl9GTEFTSF9OT0RFICkgKTtcclxuICAgIGNvbnN0IGZsYXNoaW5nQ2FwdHVyZU5vZGUgPSBuZXcgRmxhc2hpbmdTaGFwZU5vZGUoIGZsYXNoaW5nQ2FwdHVyZU5vZGVTaGFwZSwgRkxBU0hfQ09MT1IgKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIGZsYXNoaW5nQ2FwdHVyZU5vZGUgKTtcclxuXHJcbiAgICAvLyBBZGQgdGhlIG5vZGUgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgc3BvdCB3aGVyZSB0aGUgcHJvdGVpbiBjYW4gYmUgY2FwdHVyZWQsIHdoaWNoIGlzIGEgYmxhY2sgc2hhcGUgKHNpZ25pZnlpbmdcclxuICAgIC8vIGVtcHRpbmVzcykgdW50aWwgYSBwcm90ZWluIGlzIGNhcHR1cmVkLCB0aGVuIGl0IGNoYW5nZXMgdG8gbG9vayBmaWxsZWQgaW4uXHJcbiAgICBjb25zdCBjYXB0dXJlQXJlYU5vZGUgPSBuZXcgUGF0aCggcHJvdGVpblNoYXBlLCB7IHN0cm9rZTogJ2JsYWNrJyB9ICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCBjYXB0dXJlQXJlYU5vZGUgKTtcclxuICAgIGNvbnN0IGdyYWRpZW50UGFpbnQgPSBHcmFkaWVudFV0aWxzLmNyZWF0ZUdyYWRpZW50UGFpbnQoIHByb3RlaW5TaGFwZSwgZnVsbEJhc2VDb2xvciApO1xyXG5cclxuICAgIC8vIEFkZCB0aGUgbm9kZSB0aGF0IHJlcHJlc2VudHMgYSBjb3VudCBvZiB0aGUgY29sbGVjdGVkIHR5cGUuXHJcbiAgICBjb25zdCBjb3VudE5vZGUgPSBuZXcgVGV4dCggJycsIHsgZm9udDogbmV3IFBoZXRGb250KCB7IHNpemU6IDE4LCB3ZWlnaHQ6ICdib2xkJyB9ICkgfSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggY291bnROb2RlICk7XHJcbiAgICBtb2RlbC5nZXRDb2xsZWN0ZWRDb3VudGVyRm9yUHJvdGVpblR5cGUoIHByb3RlaW5DbGFzc05hbWUgKS5saW5rKCBwcm90ZWluQ2FwdHVyZUNvdW50ID0+IHtcclxuICAgICAgY291bnROb2RlLnN0cmluZyA9IHByb3RlaW5DYXB0dXJlQ291bnQ7XHJcbiAgICAgIGNvdW50Tm9kZS54ID0gKCBjYXB0dXJlQXJlYU5vZGUuYm91bmRzLmdldENlbnRlclgoKSAtIGNvdW50Tm9kZS5ib3VuZHMud2lkdGggLyAyICk7XHJcbiAgICAgIGNvdW50Tm9kZS55ID0gY2FwdHVyZUFyZWFOb2RlLmJvdW5kcy5nZXRDZW50ZXJZKCkgKyBWRVJUSUNBTF9ESVNUQU5DRV9UT19DT1VOVF9OT0RFO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFdhdGNoIGZvciBhIHByb3RlaW4gbm9kZSBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZSB0byBiZWNvbWUgZnVsbHkgZ3Jvd24gYW5kLCB3aGVuIGl0IGRvZXMsIGZsYXNoIGEgbm9kZSBpbiBvcmRlclxyXG4gICAgLy8gdG8gc2lnbmFsIHRoZSB1c2VyIHRoYXQgdGhlIHByb3RlaW4gc2hvdWxkIGJlIHBsYWNlZCBoZXJlLlxyXG4gICAgbW9kZWwubW9iaWxlQmlvbW9sZWN1bGVMaXN0LmFkZEl0ZW1BZGRlZExpc3RlbmVyKCBiaW9tb2xlY3VsZSA9PiB7XHJcbiAgICAgIGlmICggYmlvbW9sZWN1bGUgaW5zdGFuY2VvZiBwcm90ZWluU3RyaW5nQ29uc3RydWN0b3JNYXBbIHByb3RlaW5DbGFzc05hbWUgXSApIHtcclxuICAgICAgICBiaW9tb2xlY3VsZS5mdWxsR3Jvd25Qcm9wZXJ0eS5saW5rKCAoIGlzRnVsbHlGb3JtZWQsIHdhc0Z1bGx5Rm9ybWVkICkgPT4ge1xyXG4gICAgICAgICAgaWYgKCBpc0Z1bGx5Rm9ybWVkICYmICF3YXNGdWxseUZvcm1lZCApIHtcclxuICAgICAgICAgICAgZmxhc2hpbmdDYXB0dXJlTm9kZS5zdGFydEZsYXNoaW5nKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gR2V0IHRoZSBjYXB0dXJlIGNvdW50IHByb3BlcnR5IGZvciB0aGlzIHByb3RlaW4uXHJcbiAgICBjb25zdCBjYXB0dXJlQ291bnRQcm9wZXJ0eSA9IG1vZGVsLmdldENvbGxlY3RlZENvdW50ZXJGb3JQcm90ZWluVHlwZSggcHJvdGVpbkNsYXNzTmFtZSApO1xyXG5cclxuICAgIC8vIE9ic2VydmUgdGhlIGNhcHR1cmUgaW5kaWNhdG9yIGFuZCBzZXQgdGhlIHN0YXRlIG9mIHRoZSBub2RlcyBhcHByb3ByaWF0ZWx5LlxyXG4gICAgY2FwdHVyZUNvdW50UHJvcGVydHkubGluayggY2FwdHVyZUNvdW50ID0+IHtcclxuICAgICAgaWYgKCBjYXB0dXJlQ291bnQgPiAwICkge1xyXG4gICAgICAgIGNhcHR1cmVBcmVhTm9kZS5maWxsID0gZ3JhZGllbnRQYWludDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyBObyBwcm90ZWlucyBjYXB0dXJlLCBzbyBzZXQgdG8gYmxhY2sgdG8gYXBwZWFyIGVtcHR5LlxyXG4gICAgICAgIGNhcHR1cmVBcmVhTm9kZS5maWxsID0gQ29sb3IuQkxBQ0s7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBPYnNlcnZlIHRoZSBiaW9tb2xlY3VsZXMgYW5kIG1ha2Ugc3VyZSB0aGF0IGlmIG5vbmUgb2YgdGhlIHByb3RlaW4gdGhhdCB0aGlzIGNvbGxlY3RzIGlzIGluIHRoZSBtb2RlbCwgdGhlXHJcbiAgICAvLyBoaWdobGlnaHQgaXMgb2ZmLlxyXG4gICAgbW9kZWwubW9iaWxlQmlvbW9sZWN1bGVMaXN0LmFkZEl0ZW1SZW1vdmVkTGlzdGVuZXIoIGJpb21vbGVjdWxlID0+IHtcclxuICAgICAgaWYgKCBiaW9tb2xlY3VsZSBpbnN0YW5jZW9mIHByb3RlaW5TdHJpbmdDb25zdHJ1Y3Rvck1hcFsgcHJvdGVpbkNsYXNzTmFtZSBdICYmXHJcbiAgICAgICAgICAgbW9kZWwuZ2V0UHJvdGVpbkNvdW50KCBwcm90ZWluU3RyaW5nQ29uc3RydWN0b3JNYXBbIHByb3RlaW5DbGFzc05hbWUgXSApID09PSAwICkge1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgaGlnaGxpZ2h0IGlzIG9mZi5cclxuICAgICAgICBmbGFzaGluZ0NhcHR1cmVOb2RlLmZvcmNlRmxhc2hPZmYoKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG4gIH1cclxufVxyXG5cclxuUHJvdGVpbkNhcHR1cmVOb2RlLlNDQUxFX0ZPUl9GTEFTSF9OT0RFID0gU0NBTEVfRk9SX0ZMQVNIX05PREU7XHJcblxyXG5nZW5lRXhwcmVzc2lvbkVzc2VudGlhbHMucmVnaXN0ZXIoICdQcm90ZWluQ2FwdHVyZU5vZGUnLCBQcm90ZWluQ2FwdHVyZU5vZGUgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFByb3RlaW5DYXB0dXJlTm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsU0FBU0MsS0FBSyxRQUFRLGdDQUFnQztBQUN0RCxPQUFPQyxRQUFRLE1BQU0seUNBQXlDO0FBQzlELFNBQVNDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUksUUFBUSxtQ0FBbUM7QUFDM0UsT0FBT0MsYUFBYSxNQUFNLG9DQUFvQztBQUM5RCxPQUFPQyx3QkFBd0IsTUFBTSxtQ0FBbUM7QUFDeEUsT0FBT0MsUUFBUSxNQUFNLHNCQUFzQjtBQUMzQyxPQUFPQyxRQUFRLE1BQU0sc0JBQXNCO0FBQzNDLE9BQU9DLFFBQVEsTUFBTSxzQkFBc0I7QUFDM0MsT0FBT0MsaUJBQWlCLE1BQU0sd0JBQXdCOztBQUV0RDtBQUNBLE1BQU1DLFdBQVcsR0FBRyxJQUFJVixLQUFLLENBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFHLENBQUM7QUFDN0MsTUFBTVcsb0JBQW9CLEdBQUcsR0FBRzs7QUFFaEM7QUFDQTtBQUNBLE1BQU1DLCtCQUErQixHQUFHLEVBQUU7QUFFMUMsTUFBTUMsMkJBQTJCLEdBQUc7RUFDbENQLFFBQVEsRUFBRUEsUUFBUTtFQUNsQkMsUUFBUSxFQUFFQSxRQUFRO0VBQ2xCQyxR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