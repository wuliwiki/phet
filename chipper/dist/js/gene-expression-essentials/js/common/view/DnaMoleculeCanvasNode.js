// Copyright 2017-2022, University of Colorado Boulder

/**
 * A DNA Backbone Layer rendered on canvas. This exists for performance reasons.
 *
 * @author Aadish Gupta
 */

import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import { CanvasNode, Color } from '../../../../scenery/js/imports.js';
import geneExpressionEssentials from '../../geneExpressionEssentials.js';
import ShapeUtils from '../model/ShapeUtils.js';

// constants
const STRAND_1_COLOR = new Color(31, 163, 223);
const STRAND_2_COLOR = new Color(214, 87, 107);
const BASE_PAIR_COLOR = Color.DARK_GRAY.computeCSS();
class DnaMoleculeCanvasNode extends CanvasNode {
  /**
   * @param {DnaMolecule} model
   * @param {ModelViewTransform2} modelViewTransform
   * @param {number} backboneStrokeWidth
   * @param {Object} [options]
   */
  constructor(model, modelViewTransform, backboneStrokeWidth, options) {
    super(options);
    this.model = model; // @private
    this.modelViewTransform = modelViewTransform; // @private
    this.backboneStrokeWidth = modelViewTransform.viewToModelDeltaX(backboneStrokeWidth); // @private

    // @private - pre-allocated reusable vectors, used to reduce garbage collection
    this.cp1ResuableVector = new Vector2(0, 0);
    this.cp2ResuableVector = new Vector2(0, 0);

    // @private - four arrays for the DNA backbone representation
    const longerArrayLength = Utils.roundSymmetric(this.model.strand1Segments.length / 2);
    const shorterArrayLength = Math.floor(this.model.strand1Segments.length / 2);
    this.strand1ArrayBehind = new Array(shorterArrayLength);
    this.strand2ArrayBehind = new Array(longerArrayLength);
    this.strand1ArrayFront = new Array(longerArrayLength);
    this.strand2ArrayFront = new Array(shorterArrayLength);
    this.invalidatePaint();
  }

  /**
   * Draws the base pairs - this normally just draws a single line the connects between the two strands, but if the
   * strands are split it draws the base pairs in two pieces.
   * @param {CanvasRenderingContext2D} context
   * @param {BasePair}basePair
   * @private
   */
  drawBasePair(context, basePair) {
    const endOffset = basePair.width / 2;
    if (basePair.topYPosition - basePair.bottomYPosition <= this.model.maxBasePairHeight) {
      // draw the base pair as a single line between the top and bottom positions
      context.moveTo(basePair.x, basePair.topYPosition + endOffset);
      context.lineTo(basePair.x, basePair.bottomYPosition - endOffset);
    } else {
      // the strands are separated, draw two separate base pairs, one at the top and one at the bottom
      const dividedBasePairHeight = this.model.maxBasePairHeight / 2;
      context.moveTo(basePair.x, basePair.topYPosition + endOffset);
      context.lineTo(basePair.x, basePair.topYPosition - dividedBasePairHeight);
      context.moveTo(basePair.x, basePair.bottomYPosition - endOffset);
      context.lineTo(basePair.x, basePair.bottomYPosition + dividedBasePairHeight);
    }
    context.lineWidth = basePair.width;
  }

  /**
   * Draws the strand segments
   * @param {CanvasRenderingContext2D} context
   * @param {Array} strandSegmentArray
   * @param {Color} strokeColor
   * @private
   */
  drawStrandSegments(context, strandSegmentArray, strokeColor) {
    context.beginPath();

    // allocate reusable vectors for optimal performance
    let cp1 = this.cp1ResuableVector;
    let cp2 = this.cp2ResuableVector;

    // loop, drawing each strand segment
    for (let i = 0; i < strandSegmentArray.length; i++) {
      const strandSegment = strandSegmentArray[i];
      const strandSegmentLength = strandSegment.length;
      context.moveTo(strandSegment[0].x, strandSegment[0].y);
      if (strandSegmentLength === 1 || strandSegmentLength === 2) {
        // can't really create a curve from this, so draw a straight line to the end point and call it good
        context.lineTo(strandSegment[strandSegmentLength - 1].x, strandSegment[strandSegmentLength - 1].y);
        break;
      }

      // create the first curved segment
      cp1 = ShapeUtils.extrapolateControlPoint(strandSegment[2], strandSegment[1], strandSegment[0], cp1);
      context.quadraticCurveTo(cp1.x, cp1.y, strandSegment[1].x, strandSegment[1].y);

      // create the middle segments
      for (let j = 1; j < strandSegmentLength - 2; j++) {
        const segmentStartPoint = strandSegment[j];
        const segmentEndPoint = strandSegment[j + 1];
        const previousPoint = strandSegment[j - 1];
        const nextPoint = strandSegment[j + 2];
        cp1 = ShapeUtils.extrapolateControlPoint(previousPoint, segmentStartPoint, segmentEndPoint, cp1);
        cp2 = ShapeUtils.extrapolateControlPoint(nextPoint, segmentEndPoint, segmentStartPoint, cp2);
        context.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, segmentEndPoint.x, segmentEndPoint.y);
      }

      // create the final curved segment
      cp1 = ShapeUtils.extrapolateControlPoint(strandSegment[strandSegmentLength - 3], strandSegment[strandSegmentLength - 2], strandSegment[strandSegmentLength - 1], cp1);
      context.quadraticCurveTo(cp1.x, cp1.y, strandSegment[strandSegmentLength - 1].x, strandSegment[strandSegmentLength - 1].y);
    }
    context.strokeStyle = strokeColor.computeCSS();
    context.lineWidth = this.backboneStrokeWidth;
    context.stroke();
  }

  /**
   * @override
   * Draws the DNA Molecule on canvas which includes helix like strands and base pairs.
   * @param {CanvasRenderingContext2D} context
   * @public
   */
  paintCanvas(context) {
    // map the segments of the DNA in the model to the arrays used in rendering
    for (let i = 0; i < this.model.strand1Segments.length; i++) {
      const strand1Segment = this.model.strand1Segments[i];
      const strand2Segment = this.model.strand2Segments[i];
      const index = Math.floor(i / 2);
      if (i % 2 === 0) {
        this.strand2ArrayBehind[index] = strand2Segment;
        this.strand1ArrayFront[index] = strand1Segment;
      } else {
        this.strand1ArrayBehind[index] = strand1Segment;
        this.strand2ArrayFront[index] = strand2Segment;
      }
    }

    // draw the back portions of the DNA strand
    context.lineCap = 'round';
    this.drawStrandSegments(context, this.strand1ArrayBehind, STRAND_1_COLOR);
    this.drawStrandSegments(context, this.strand2ArrayBehind, STRAND_2_COLOR);

    // draw the base pairs
    context.lineCap = 'butt';
    context.beginPath();
    context.strokeStyle = BASE_PAIR_COLOR;
    for (let i = 0; i < this.model.basePairs.length; i++) {
      const basePair = this.model.basePairs[i];
      this.drawBasePair(context, basePair);
    }
    context.stroke();

    // draw the front portions of the DNA strand
    context.lineCap = 'round';
    this.drawStrandSegments(context, this.strand1ArrayFront, STRAND_1_COLOR);
    this.drawStrandSegments(context, this.strand2ArrayFront, STRAND_2_COLOR);
  }

  /**
   * Step Function which checks whether to redraw or not
   * @public
   */
  step() {
    if (this.model.redraw) {
      this.invalidatePaint();
    }
  }
}
geneExpressionEssentials.register('DnaMoleculeCanvasNode', DnaMoleculeCanvasNode);
export default DnaMoleculeCanvasNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJVdGlscyIsIlZlY3RvcjIiLCJDYW52YXNOb2RlIiwiQ29sb3IiLCJnZW5lRXhwcmVzc2lvbkVzc2VudGlhbHMiLCJTaGFwZVV0aWxzIiwiU1RSQU5EXzFfQ09MT1IiLCJTVFJBTkRfMl9DT0xPUiIsIkJBU0VfUEFJUl9DT0xPUiIsIkRBUktfR1JBWSIsImNvbXB1dGVDU1MiLCJEbmFNb2xlY3VsZUNhbnZhc05vZGUiLCJjb25zdHJ1Y3RvciIsIm1vZGVsIiwibW9kZWxWaWV3VHJhbnNmb3JtIiwiYmFja2JvbmVTdHJva2VXaWR0aCIsIm9wdGlvbnMiLCJ2aWV3VG9Nb2RlbERlbHRhWCIsImNwMVJlc3VhYmxlVmVjdG9yIiwiY3AyUmVzdWFibGVWZWN0b3IiLCJsb25nZXJBcnJheUxlbmd0aCIsInJvdW5kU3ltbWV0cmljIiwic3RyYW5kMVNlZ21lbnRzIiwibGVuZ3RoIiwic2hvcnRlckFycmF5TGVuZ3RoIiwiTWF0aCIsImZsb29yIiwic3RyYW5kMUFycmF5QmVoaW5kIiwiQXJyYXkiLCJzdHJhbmQyQXJyYXlCZWhpbmQiLCJzdHJhbmQxQXJyYXlGcm9udCIsInN0cmFuZDJBcnJheUZyb250IiwiaW52YWxpZGF0ZVBhaW50IiwiZHJhd0Jhc2VQYWlyIiwiY29udGV4dCIsImJhc2VQYWlyIiwiZW5kT2Zmc2V0Iiwid2lkdGgiLCJ0b3BZUG9zaXRpb24iLCJib3R0b21ZUG9zaXRpb24iLCJtYXhCYXNlUGFpckhlaWdodCIsIm1vdmVUbyIsIngiLCJsaW5lVG8iLCJkaXZpZGVkQmFzZVBhaXJIZWlnaHQiLCJsaW5lV2lkdGgiLCJkcmF3U3RyYW5kU2VnbWVudHMiLCJzdHJhbmRTZWdtZW50QXJyYXkiLCJzdHJva2VDb2xvciIsImJlZ2luUGF0aCIsImNwMSIsImNwMiIsImkiLCJzdHJhbmRTZWdtZW50Iiwic3RyYW5kU2VnbWVudExlbmd0aCIsInkiLCJleHRyYXBvbGF0ZUNvbnRyb2xQb2ludCIsInF1YWRyYXRpY0N1cnZlVG8iLCJqIiwic2VnbWVudFN0YXJ0UG9pbnQiLCJzZWdtZW50RW5kUG9pbnQiLCJwcmV2aW91c1BvaW50IiwibmV4dFBvaW50IiwiYmV6aWVyQ3VydmVUbyIsInN0cm9rZVN0eWxlIiwic3Ryb2tlIiwicGFpbnRDYW52YXMiLCJzdHJhbmQxU2VnbWVudCIsInN0cmFuZDJTZWdtZW50Iiwic3RyYW5kMlNlZ21lbnRzIiwiaW5kZXgiLCJsaW5lQ2FwIiwiYmFzZVBhaXJzIiwic3RlcCIsInJlZHJhdyIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRG5hTW9sZWN1bGVDYW52YXNOb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE3LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgRE5BIEJhY2tib25lIExheWVyIHJlbmRlcmVkIG9uIGNhbnZhcy4gVGhpcyBleGlzdHMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXHJcbiAqXHJcbiAqIEBhdXRob3IgQWFkaXNoIEd1cHRhXHJcbiAqL1xyXG5cclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgQ2FudmFzTm9kZSwgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgZ2VuZUV4cHJlc3Npb25Fc3NlbnRpYWxzIGZyb20gJy4uLy4uL2dlbmVFeHByZXNzaW9uRXNzZW50aWFscy5qcyc7XHJcbmltcG9ydCBTaGFwZVV0aWxzIGZyb20gJy4uL21vZGVsL1NoYXBlVXRpbHMuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IFNUUkFORF8xX0NPTE9SID0gbmV3IENvbG9yKCAzMSwgMTYzLCAyMjMgKTtcclxuY29uc3QgU1RSQU5EXzJfQ09MT1IgPSBuZXcgQ29sb3IoIDIxNCwgODcsIDEwNyApO1xyXG5jb25zdCBCQVNFX1BBSVJfQ09MT1IgPSBDb2xvci5EQVJLX0dSQVkuY29tcHV0ZUNTUygpO1xyXG5cclxuY2xhc3MgRG5hTW9sZWN1bGVDYW52YXNOb2RlIGV4dGVuZHMgQ2FudmFzTm9kZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7RG5hTW9sZWN1bGV9IG1vZGVsXHJcbiAgICogQHBhcmFtIHtNb2RlbFZpZXdUcmFuc2Zvcm0yfSBtb2RlbFZpZXdUcmFuc2Zvcm1cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYmFja2JvbmVTdHJva2VXaWR0aFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggbW9kZWwsIG1vZGVsVmlld1RyYW5zZm9ybSwgYmFja2JvbmVTdHJva2VXaWR0aCwgb3B0aW9ucyApIHtcclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7IC8vIEBwcml2YXRlXHJcbiAgICB0aGlzLm1vZGVsVmlld1RyYW5zZm9ybSA9IG1vZGVsVmlld1RyYW5zZm9ybTsgLy8gQHByaXZhdGVcclxuICAgIHRoaXMuYmFja2JvbmVTdHJva2VXaWR0aCA9IG1vZGVsVmlld1RyYW5zZm9ybS52aWV3VG9Nb2RlbERlbHRhWCggYmFja2JvbmVTdHJva2VXaWR0aCApOyAvLyBAcHJpdmF0ZVxyXG5cclxuICAgIC8vIEBwcml2YXRlIC0gcHJlLWFsbG9jYXRlZCByZXVzYWJsZSB2ZWN0b3JzLCB1c2VkIHRvIHJlZHVjZSBnYXJiYWdlIGNvbGxlY3Rpb25cclxuICAgIHRoaXMuY3AxUmVzdWFibGVWZWN0b3IgPSBuZXcgVmVjdG9yMiggMCwgMCApO1xyXG4gICAgdGhpcy5jcDJSZXN1YWJsZVZlY3RvciA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XHJcblxyXG4gICAgLy8gQHByaXZhdGUgLSBmb3VyIGFycmF5cyBmb3IgdGhlIEROQSBiYWNrYm9uZSByZXByZXNlbnRhdGlvblxyXG4gICAgY29uc3QgbG9uZ2VyQXJyYXlMZW5ndGggPSBVdGlscy5yb3VuZFN5bW1ldHJpYyggdGhpcy5tb2RlbC5zdHJhbmQxU2VnbWVudHMubGVuZ3RoIC8gMiApO1xyXG4gICAgY29uc3Qgc2hvcnRlckFycmF5TGVuZ3RoID0gTWF0aC5mbG9vciggdGhpcy5tb2RlbC5zdHJhbmQxU2VnbWVudHMubGVuZ3RoIC8gMiApO1xyXG4gICAgdGhpcy5zdHJhbmQxQXJyYXlCZWhpbmQgPSBuZXcgQXJyYXkoIHNob3J0ZXJBcnJheUxlbmd0aCApO1xyXG4gICAgdGhpcy5zdHJhbmQyQXJyYXlCZWhpbmQgPSBuZXcgQXJyYXkoIGxvbmdlckFycmF5TGVuZ3RoICk7XHJcbiAgICB0aGlzLnN0cmFuZDFBcnJheUZyb250ID0gbmV3IEFycmF5KCBsb25nZXJBcnJheUxlbmd0aCApO1xyXG4gICAgdGhpcy5zdHJhbmQyQXJyYXlGcm9udCA9IG5ldyBBcnJheSggc2hvcnRlckFycmF5TGVuZ3RoICk7XHJcblxyXG4gICAgdGhpcy5pbnZhbGlkYXRlUGFpbnQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYXdzIHRoZSBiYXNlIHBhaXJzIC0gdGhpcyBub3JtYWxseSBqdXN0IGRyYXdzIGEgc2luZ2xlIGxpbmUgdGhlIGNvbm5lY3RzIGJldHdlZW4gdGhlIHR3byBzdHJhbmRzLCBidXQgaWYgdGhlXHJcbiAgICogc3RyYW5kcyBhcmUgc3BsaXQgaXQgZHJhd3MgdGhlIGJhc2UgcGFpcnMgaW4gdHdvIHBpZWNlcy5cclxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxyXG4gICAqIEBwYXJhbSB7QmFzZVBhaXJ9YmFzZVBhaXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGRyYXdCYXNlUGFpciggY29udGV4dCwgYmFzZVBhaXIgKSB7XHJcblxyXG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gYmFzZVBhaXIud2lkdGggLyAyO1xyXG5cclxuICAgIGlmICggYmFzZVBhaXIudG9wWVBvc2l0aW9uIC0gYmFzZVBhaXIuYm90dG9tWVBvc2l0aW9uIDw9IHRoaXMubW9kZWwubWF4QmFzZVBhaXJIZWlnaHQgKSB7XHJcblxyXG4gICAgICAvLyBkcmF3IHRoZSBiYXNlIHBhaXIgYXMgYSBzaW5nbGUgbGluZSBiZXR3ZWVuIHRoZSB0b3AgYW5kIGJvdHRvbSBwb3NpdGlvbnNcclxuICAgICAgY29udGV4dC5tb3ZlVG8oIGJhc2VQYWlyLngsIGJhc2VQYWlyLnRvcFlQb3NpdGlvbiArIGVuZE9mZnNldCApO1xyXG4gICAgICBjb250ZXh0LmxpbmVUbyggYmFzZVBhaXIueCwgYmFzZVBhaXIuYm90dG9tWVBvc2l0aW9uIC0gZW5kT2Zmc2V0ICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuXHJcbiAgICAgIC8vIHRoZSBzdHJhbmRzIGFyZSBzZXBhcmF0ZWQsIGRyYXcgdHdvIHNlcGFyYXRlIGJhc2UgcGFpcnMsIG9uZSBhdCB0aGUgdG9wIGFuZCBvbmUgYXQgdGhlIGJvdHRvbVxyXG4gICAgICBjb25zdCBkaXZpZGVkQmFzZVBhaXJIZWlnaHQgPSB0aGlzLm1vZGVsLm1heEJhc2VQYWlySGVpZ2h0IC8gMjtcclxuICAgICAgY29udGV4dC5tb3ZlVG8oIGJhc2VQYWlyLngsIGJhc2VQYWlyLnRvcFlQb3NpdGlvbiArIGVuZE9mZnNldCApO1xyXG4gICAgICBjb250ZXh0LmxpbmVUbyggYmFzZVBhaXIueCwgYmFzZVBhaXIudG9wWVBvc2l0aW9uIC0gZGl2aWRlZEJhc2VQYWlySGVpZ2h0ICk7XHJcbiAgICAgIGNvbnRleHQubW92ZVRvKCBiYXNlUGFpci54LCBiYXNlUGFpci5ib3R0b21ZUG9zaXRpb24gLSBlbmRPZmZzZXQgKTtcclxuICAgICAgY29udGV4dC5saW5lVG8oIGJhc2VQYWlyLngsIGJhc2VQYWlyLmJvdHRvbVlQb3NpdGlvbiArIGRpdmlkZWRCYXNlUGFpckhlaWdodCApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRleHQubGluZVdpZHRoID0gYmFzZVBhaXIud2lkdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmF3cyB0aGUgc3RyYW5kIHNlZ21lbnRzXHJcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHRcclxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJhbmRTZWdtZW50QXJyYXlcclxuICAgKiBAcGFyYW0ge0NvbG9yfSBzdHJva2VDb2xvclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZHJhd1N0cmFuZFNlZ21lbnRzKCBjb250ZXh0LCBzdHJhbmRTZWdtZW50QXJyYXksIHN0cm9rZUNvbG9yICkge1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuXHJcbiAgICAvLyBhbGxvY2F0ZSByZXVzYWJsZSB2ZWN0b3JzIGZvciBvcHRpbWFsIHBlcmZvcm1hbmNlXHJcbiAgICBsZXQgY3AxID0gdGhpcy5jcDFSZXN1YWJsZVZlY3RvcjtcclxuICAgIGxldCBjcDIgPSB0aGlzLmNwMlJlc3VhYmxlVmVjdG9yO1xyXG5cclxuICAgIC8vIGxvb3AsIGRyYXdpbmcgZWFjaCBzdHJhbmQgc2VnbWVudFxyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgc3RyYW5kU2VnbWVudEFycmF5Lmxlbmd0aDsgaSsrICkge1xyXG4gICAgICBjb25zdCBzdHJhbmRTZWdtZW50ID0gc3RyYW5kU2VnbWVudEFycmF5WyBpIF07XHJcbiAgICAgIGNvbnN0IHN0cmFuZFNlZ21lbnRMZW5ndGggPSBzdHJhbmRTZWdtZW50Lmxlbmd0aDtcclxuICAgICAgY29udGV4dC5tb3ZlVG8oIHN0cmFuZFNlZ21lbnRbIDAgXS54LCBzdHJhbmRTZWdtZW50WyAwIF0ueSApO1xyXG4gICAgICBpZiAoIHN0cmFuZFNlZ21lbnRMZW5ndGggPT09IDEgfHwgc3RyYW5kU2VnbWVudExlbmd0aCA9PT0gMiApIHtcclxuXHJcbiAgICAgICAgLy8gY2FuJ3QgcmVhbGx5IGNyZWF0ZSBhIGN1cnZlIGZyb20gdGhpcywgc28gZHJhdyBhIHN0cmFpZ2h0IGxpbmUgdG8gdGhlIGVuZCBwb2ludCBhbmQgY2FsbCBpdCBnb29kXHJcbiAgICAgICAgY29udGV4dC5saW5lVG8oXHJcbiAgICAgICAgICBzdHJhbmRTZWdtZW50WyBzdHJhbmRTZWdtZW50TGVuZ3RoIC0gMSBdLngsXHJcbiAgICAgICAgICBzdHJhbmRTZWdtZW50WyBzdHJhbmRTZWdtZW50TGVuZ3RoIC0gMSBdLnlcclxuICAgICAgICApO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjcmVhdGUgdGhlIGZpcnN0IGN1cnZlZCBzZWdtZW50XHJcbiAgICAgIGNwMSA9IFNoYXBlVXRpbHMuZXh0cmFwb2xhdGVDb250cm9sUG9pbnQoIHN0cmFuZFNlZ21lbnRbIDIgXSwgc3RyYW5kU2VnbWVudFsgMSBdLCBzdHJhbmRTZWdtZW50WyAwIF0sIGNwMSApO1xyXG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oIGNwMS54LCBjcDEueSwgc3RyYW5kU2VnbWVudFsgMSBdLngsIHN0cmFuZFNlZ21lbnRbIDEgXS55ICk7XHJcblxyXG4gICAgICAvLyBjcmVhdGUgdGhlIG1pZGRsZSBzZWdtZW50c1xyXG4gICAgICBmb3IgKCBsZXQgaiA9IDE7IGogPCBzdHJhbmRTZWdtZW50TGVuZ3RoIC0gMjsgaisrICkge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRTdGFydFBvaW50ID0gc3RyYW5kU2VnbWVudFsgaiBdO1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRFbmRQb2ludCA9IHN0cmFuZFNlZ21lbnRbIGogKyAxIF07XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNQb2ludCA9IHN0cmFuZFNlZ21lbnRbIGogLSAxIF07XHJcbiAgICAgICAgY29uc3QgbmV4dFBvaW50ID0gc3RyYW5kU2VnbWVudFsgKCBqICsgMiApIF07XHJcbiAgICAgICAgY3AxID0gU2hhcGVVdGlscy5leHRyYXBvbGF0ZUNvbnRyb2xQb2ludCggcHJldmlvdXNQb2ludCwgc2VnbWVudFN0YXJ0UG9pbnQsIHNlZ21lbnRFbmRQb2ludCwgY3AxICk7XHJcbiAgICAgICAgY3AyID0gU2hhcGVVdGlscy5leHRyYXBvbGF0ZUNvbnRyb2xQb2ludCggbmV4dFBvaW50LCBzZWdtZW50RW5kUG9pbnQsIHNlZ21lbnRTdGFydFBvaW50LCBjcDIgKTtcclxuICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oIGNwMS54LCBjcDEueSwgY3AyLngsIGNwMi55LCBzZWdtZW50RW5kUG9pbnQueCwgc2VnbWVudEVuZFBvaW50LnkgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY3JlYXRlIHRoZSBmaW5hbCBjdXJ2ZWQgc2VnbWVudFxyXG4gICAgICBjcDEgPSBTaGFwZVV0aWxzLmV4dHJhcG9sYXRlQ29udHJvbFBvaW50KFxyXG4gICAgICAgIHN0cmFuZFNlZ21lbnRbIHN0cmFuZFNlZ21lbnRMZW5ndGggLSAzIF0sXHJcbiAgICAgICAgc3RyYW5kU2VnbWVudFsgc3RyYW5kU2VnbWVudExlbmd0aCAtIDIgXSxcclxuICAgICAgICBzdHJhbmRTZWdtZW50WyBzdHJhbmRTZWdtZW50TGVuZ3RoIC0gMSBdLFxyXG4gICAgICAgIGNwMVxyXG4gICAgICApO1xyXG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oXHJcbiAgICAgICAgY3AxLngsXHJcbiAgICAgICAgY3AxLnksXHJcbiAgICAgICAgc3RyYW5kU2VnbWVudFsgc3RyYW5kU2VnbWVudExlbmd0aCAtIDEgXS54LFxyXG4gICAgICAgIHN0cmFuZFNlZ21lbnRbIHN0cmFuZFNlZ21lbnRMZW5ndGggLSAxIF0ueVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLmNvbXB1dGVDU1MoKTtcclxuICAgIGNvbnRleHQubGluZVdpZHRoID0gdGhpcy5iYWNrYm9uZVN0cm9rZVdpZHRoO1xyXG4gICAgY29udGV4dC5zdHJva2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIERyYXdzIHRoZSBETkEgTW9sZWN1bGUgb24gY2FudmFzIHdoaWNoIGluY2x1ZGVzIGhlbGl4IGxpa2Ugc3RyYW5kcyBhbmQgYmFzZSBwYWlycy5cclxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBwYWludENhbnZhcyggY29udGV4dCApIHtcclxuXHJcbiAgICAvLyBtYXAgdGhlIHNlZ21lbnRzIG9mIHRoZSBETkEgaW4gdGhlIG1vZGVsIHRvIHRoZSBhcnJheXMgdXNlZCBpbiByZW5kZXJpbmdcclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMubW9kZWwuc3RyYW5kMVNlZ21lbnRzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICBjb25zdCBzdHJhbmQxU2VnbWVudCA9IHRoaXMubW9kZWwuc3RyYW5kMVNlZ21lbnRzWyBpIF07XHJcbiAgICAgIGNvbnN0IHN0cmFuZDJTZWdtZW50ID0gdGhpcy5tb2RlbC5zdHJhbmQyU2VnbWVudHNbIGkgXTtcclxuXHJcbiAgICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vciggaSAvIDIgKTtcclxuICAgICAgaWYgKCBpICUgMiA9PT0gMCApIHtcclxuICAgICAgICB0aGlzLnN0cmFuZDJBcnJheUJlaGluZFsgaW5kZXggXSA9IHN0cmFuZDJTZWdtZW50O1xyXG4gICAgICAgIHRoaXMuc3RyYW5kMUFycmF5RnJvbnRbIGluZGV4IF0gPSBzdHJhbmQxU2VnbWVudDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLnN0cmFuZDFBcnJheUJlaGluZFsgaW5kZXggXSA9IHN0cmFuZDFTZWdtZW50O1xyXG4gICAgICAgIHRoaXMuc3RyYW5kMkFycmF5RnJvbnRbIGluZGV4IF0gPSBzdHJhbmQyU2VnbWVudDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGRyYXcgdGhlIGJhY2sgcG9ydGlvbnMgb2YgdGhlIEROQSBzdHJhbmRcclxuICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XHJcbiAgICB0aGlzLmRyYXdTdHJhbmRTZWdtZW50cyggY29udGV4dCwgdGhpcy5zdHJhbmQxQXJyYXlCZWhpbmQsIFNUUkFORF8xX0NPTE9SICk7XHJcbiAgICB0aGlzLmRyYXdTdHJhbmRTZWdtZW50cyggY29udGV4dCwgdGhpcy5zdHJhbmQyQXJyYXlCZWhpbmQsIFNUUkFORF8yX0NPTE9SICk7XHJcblxyXG4gICAgLy8gZHJhdyB0aGUgYmFzZSBwYWlyc1xyXG4gICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBCQVNFX1BBSVJfQ09MT1I7XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLm1vZGVsLmJhc2VQYWlycy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgY29uc3QgYmFzZVBhaXIgPSB0aGlzLm1vZGVsLmJhc2VQYWlyc1sgaSBdO1xyXG4gICAgICB0aGlzLmRyYXdCYXNlUGFpciggY29udGV4dCwgYmFzZVBhaXIgKTtcclxuICAgIH1cclxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcblxyXG4gICAgLy8gZHJhdyB0aGUgZnJvbnQgcG9ydGlvbnMgb2YgdGhlIEROQSBzdHJhbmRcclxuICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XHJcbiAgICB0aGlzLmRyYXdTdHJhbmRTZWdtZW50cyggY29udGV4dCwgdGhpcy5zdHJhbmQxQXJyYXlGcm9udCwgU1RSQU5EXzFfQ09MT1IgKTtcclxuICAgIHRoaXMuZHJhd1N0cmFuZFNlZ21lbnRzKCBjb250ZXh0LCB0aGlzLnN0cmFuZDJBcnJheUZyb250LCBTVFJBTkRfMl9DT0xPUiApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RlcCBGdW5jdGlvbiB3aGljaCBjaGVja3Mgd2hldGhlciB0byByZWRyYXcgb3Igbm90XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHN0ZXAoKSB7XHJcbiAgICBpZiAoIHRoaXMubW9kZWwucmVkcmF3ICkge1xyXG4gICAgICB0aGlzLmludmFsaWRhdGVQYWludCgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZ2VuZUV4cHJlc3Npb25Fc3NlbnRpYWxzLnJlZ2lzdGVyKCAnRG5hTW9sZWN1bGVDYW52YXNOb2RlJywgRG5hTW9sZWN1bGVDYW52YXNOb2RlICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEbmFNb2xlY3VsZUNhbnZhc05vZGU7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxLQUFLLE1BQU0sNkJBQTZCO0FBQy9DLE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsU0FBU0MsVUFBVSxFQUFFQyxLQUFLLFFBQVEsbUNBQW1DO0FBQ3JFLE9BQU9DLHdCQUF3QixNQUFNLG1DQUFtQztBQUN4RSxPQUFPQyxVQUFVLE1BQU0sd0JBQXdCOztBQUUvQztBQUNBLE1BQU1DLGNBQWMsR0FBRyxJQUFJSCxLQUFLLENBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFJLENBQUM7QUFDaEQsTUFBTUksY0FBYyxHQUFHLElBQUlKLEtBQUssQ0FBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUksQ0FBQztBQUNoRCxNQUFNSyxlQUFlLEdBQUdMLEtBQUssQ0FBQ00sU0FBUyxDQUFDQyxVQUFVLENBQUMsQ0FBQztBQUVwRCxNQUFNQyxxQkFBcUIsU0FBU1QsVUFBVSxDQUFDO0VBRTdDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFVSxXQUFXQSxDQUFFQyxLQUFLLEVBQUVDLGtCQUFrQixFQUFFQyxtQkFBbUIsRUFBRUMsT0FBTyxFQUFHO0lBQ3JFLEtBQUssQ0FBRUEsT0FBUSxDQUFDO0lBQ2hCLElBQUksQ0FBQ0gsS0FBSyxHQUFHQSxLQUFLLENBQUMsQ0FBQztJQUNwQixJQUFJLENBQUNDLGtCQUFrQixHQUFH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