// Copyright 2015-2020, University of Colorado Boulder

/**
 * Class that defines a square segment, which is one in which the mRNA can be (and generally is) curled up.
 *
 * @author John Blanco
 * @author Mohamed Safi
 * @author Aadish Gupta
 */

//modules
import Bounds2 from '../../../../dot/js/Bounds2.js';
import geneExpressionEssentials from '../../geneExpressionEssentials.js';
import ShapeSegment from './ShapeSegment.js';
class SquareSegment extends ShapeSegment {
  /**
   * @param {Object} owner
   * @param {Vector2} origin
   */
  constructor(owner, origin) {
    super(owner);

    // Maintain an explicit value for the length of the mRNA contained within this segment even though the bounds
    // essentially define said length.  This helps to avoid floating point issues.
    this.containedLength = 0; // @private

    this.bounds.set(Bounds2.rect(origin.x, origin.y, 0, 0));
    this.updateAttachmentSitePosition();
  }

  /**
   * @override
   * @returns {number}
   * @public
   */
  getContainedLength() {
    return this.containedLength;
  }

  /**
   * @override
   * @param {number} length
   * @param {WindingBiomolecule} windingBiomolecule
   * @param {Array.<ShapeSegment>} shapeSegmentList
   * @public
   */
  add(length, windingBiomolecule, shapeSegmentList) {
    this.containedLength += length;

    // Grow the bounds up and to the left to accommodate the additional length.
    const sideGrowthAmount = this.calculateSideLength() - this.bounds.getWidth();
    assert && assert(length >= 0 && sideGrowthAmount >= 0); //
    this.bounds.set(Bounds2.rect(this.bounds.x - sideGrowthAmount, this.bounds.y, this.bounds.getWidth() + sideGrowthAmount, this.bounds.getHeight() + sideGrowthAmount));
    this.updateAttachmentSitePosition();
  }

  /**
   * @override
   * @param {number} length
   * @param {Array.<ShapeSegment>} shapeSegmentList
   * @public
   */
  remove(length, shapeSegmentList) {
    this.containedLength -= length;

    // Shrink by moving the lower right corner up and to the left.
    const sideShrinkageAmount = this.bounds.getWidth() - this.calculateSideLength();
    this.bounds.set(Bounds2.rect(this.bounds.x, this.bounds.y + sideShrinkageAmount, this.bounds.getWidth() - sideShrinkageAmount, this.bounds.getHeight() - sideShrinkageAmount));

    // If the length has gotten to zero, remove this segment from the list.
    if (this.getContainedLength() <= ShapeSegment.FLOATING_POINT_COMP_FACTOR) {
      const index = shapeSegmentList.indexOf(this);
      shapeSegmentList.splice(index, 1);
    }
    this.updateAttachmentSitePosition();
  }

  /**
   * @override
   * @param {number} length
   * @param {WindingBiomolecule} windingBiomolecule
   * @param {Array.<ShapeSegment>} shapeSegmentList
   * @public
   */
  advance(length, windingBiomolecule, shapeSegmentList) {
    // This should never be called for square shape segments, since translation should only occur based around flat
    // segments.
    assert && assert(false, 'This should never be called for square shape segments, since translation should only occur based around flat segments.');
  }

  /**
   * @override
   * @param {number} length
   * @param {WindingBiomolecule} windingBiomolecule
   * @param {Array.<ShapeSegment>} shapeSegmentList
   * @public
   */
  advanceAndRemove(length, windingBiomolecule, shapeSegmentList) {
    assert && assert(false, 'Unimplemented method called on square shape segment');
  }

  /**
   * Determine the length of a side as a function of the contained length of mRNA.
   * @returns {number}
   * @private
   */
  calculateSideLength() {
    const desiredDiagonalLength = Math.pow(this.containedLength, 0.7); // Power value was empirically determined.
    return Math.sqrt(2 * desiredDiagonalLength * desiredDiagonalLength);
  }
}
geneExpressionEssentials.register('SquareSegment', SquareSegment);
export default SquareSegment;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiZ2VuZUV4cHJlc3Npb25Fc3NlbnRpYWxzIiwiU2hhcGVTZWdtZW50IiwiU3F1YXJlU2VnbWVudCIsImNvbnN0cnVjdG9yIiwib3duZXIiLCJvcmlnaW4iLCJjb250YWluZWRMZW5ndGgiLCJib3VuZHMiLCJzZXQiLCJyZWN0IiwieCIsInkiLCJ1cGRhdGVBdHRhY2htZW50U2l0ZVBvc2l0aW9uIiwiZ2V0Q29udGFpbmVkTGVuZ3RoIiwiYWRkIiwibGVuZ3RoIiwid2luZGluZ0Jpb21vbGVjdWxlIiwic2hhcGVTZWdtZW50TGlzdCIsInNpZGVHcm93dGhBbW91bnQiLCJjYWxjdWxhdGVTaWRlTGVuZ3RoIiwiZ2V0V2lkdGgiLCJhc3NlcnQiLCJnZXRIZWlnaHQiLCJyZW1vdmUiLCJzaWRlU2hyaW5rYWdlQW1vdW50IiwiRkxPQVRJTkdfUE9JTlRfQ09NUF9GQUNUT1IiLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJhZHZhbmNlIiwiYWR2YW5jZUFuZFJlbW92ZSIsImRlc2lyZWREaWFnb25hbExlbmd0aCIsIk1hdGgiLCJwb3ciLCJzcXJ0IiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJTcXVhcmVTZWdtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1LTIwMjAsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIENsYXNzIHRoYXQgZGVmaW5lcyBhIHNxdWFyZSBzZWdtZW50LCB3aGljaCBpcyBvbmUgaW4gd2hpY2ggdGhlIG1STkEgY2FuIGJlIChhbmQgZ2VuZXJhbGx5IGlzKSBjdXJsZWQgdXAuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICogQGF1dGhvciBNb2hhbWVkIFNhZmlcclxuICogQGF1dGhvciBBYWRpc2ggR3VwdGFcclxuICovXHJcblxyXG5cclxuLy9tb2R1bGVzXHJcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcclxuaW1wb3J0IGdlbmVFeHByZXNzaW9uRXNzZW50aWFscyBmcm9tICcuLi8uLi9nZW5lRXhwcmVzc2lvbkVzc2VudGlhbHMuanMnO1xyXG5pbXBvcnQgU2hhcGVTZWdtZW50IGZyb20gJy4vU2hhcGVTZWdtZW50LmpzJztcclxuXHJcbmNsYXNzIFNxdWFyZVNlZ21lbnQgZXh0ZW5kcyBTaGFwZVNlZ21lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3duZXJcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG9yaWdpblxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBvd25lciwgb3JpZ2luICkge1xyXG5cclxuICAgIHN1cGVyKCBvd25lciApO1xyXG5cclxuICAgIC8vIE1haW50YWluIGFuIGV4cGxpY2l0IHZhbHVlIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBtUk5BIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBzZWdtZW50IGV2ZW4gdGhvdWdoIHRoZSBib3VuZHNcclxuICAgIC8vIGVzc2VudGlhbGx5IGRlZmluZSBzYWlkIGxlbmd0aC4gIFRoaXMgaGVscHMgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgaXNzdWVzLlxyXG4gICAgdGhpcy5jb250YWluZWRMZW5ndGggPSAwOyAvLyBAcHJpdmF0ZVxyXG5cclxuICAgIHRoaXMuYm91bmRzLnNldCggQm91bmRzMi5yZWN0KCBvcmlnaW4ueCwgb3JpZ2luLnksIDAsIDAgKSApO1xyXG4gICAgdGhpcy51cGRhdGVBdHRhY2htZW50U2l0ZVBvc2l0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBnZXRDb250YWluZWRMZW5ndGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb250YWluZWRMZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXHJcbiAgICogQHBhcmFtIHtXaW5kaW5nQmlvbW9sZWN1bGV9IHdpbmRpbmdCaW9tb2xlY3VsZVxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPFNoYXBlU2VnbWVudD59IHNoYXBlU2VnbWVudExpc3RcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgYWRkKCBsZW5ndGgsIHdpbmRpbmdCaW9tb2xlY3VsZSwgc2hhcGVTZWdtZW50TGlzdCApIHtcclxuICAgIHRoaXMuY29udGFpbmVkTGVuZ3RoICs9IGxlbmd0aDtcclxuXHJcbiAgICAvLyBHcm93IHRoZSBib3VuZHMgdXAgYW5kIHRvIHRoZSBsZWZ0IHRvIGFjY29tbW9kYXRlIHRoZSBhZGRpdGlvbmFsIGxlbmd0aC5cclxuICAgIGNvbnN0IHNpZGVHcm93dGhBbW91bnQgPSB0aGlzLmNhbGN1bGF0ZVNpZGVMZW5ndGgoKSAtIHRoaXMuYm91bmRzLmdldFdpZHRoKCk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBsZW5ndGggPj0gMCAmJiBzaWRlR3Jvd3RoQW1vdW50ID49IDAgKTsgLy9cclxuICAgIHRoaXMuYm91bmRzLnNldCggQm91bmRzMi5yZWN0KCB0aGlzLmJvdW5kcy54IC0gc2lkZUdyb3d0aEFtb3VudCxcclxuICAgICAgdGhpcy5ib3VuZHMueSxcclxuICAgICAgdGhpcy5ib3VuZHMuZ2V0V2lkdGgoKSArIHNpZGVHcm93dGhBbW91bnQsXHJcbiAgICAgIHRoaXMuYm91bmRzLmdldEhlaWdodCgpICsgc2lkZUdyb3d0aEFtb3VudCApICk7XHJcbiAgICB0aGlzLnVwZGF0ZUF0dGFjaG1lbnRTaXRlUG9zaXRpb24oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcclxuICAgKiBAcGFyYW0ge0FycmF5LjxTaGFwZVNlZ21lbnQ+fSBzaGFwZVNlZ21lbnRMaXN0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHJlbW92ZSggbGVuZ3RoLCBzaGFwZVNlZ21lbnRMaXN0ICkge1xyXG4gICAgdGhpcy5jb250YWluZWRMZW5ndGggLT0gbGVuZ3RoO1xyXG5cclxuICAgIC8vIFNocmluayBieSBtb3ZpbmcgdGhlIGxvd2VyIHJpZ2h0IGNvcm5lciB1cCBhbmQgdG8gdGhlIGxlZnQuXHJcbiAgICBjb25zdCBzaWRlU2hyaW5rYWdlQW1vdW50ID0gdGhpcy5ib3VuZHMuZ2V0V2lkdGgoKSAtIHRoaXMuY2FsY3VsYXRlU2lkZUxlbmd0aCgpO1xyXG5cclxuICAgIHRoaXMuYm91bmRzLnNldCggQm91bmRzMi5yZWN0KCB0aGlzLmJvdW5kcy54LFxyXG4gICAgICB0aGlzLmJvdW5kcy55ICsgc2lkZVNocmlua2FnZUFtb3VudCxcclxuICAgICAgdGhpcy5ib3VuZHMuZ2V0V2lkdGgoKSAtIHNpZGVTaHJpbmthZ2VBbW91bnQsXHJcbiAgICAgIHRoaXMuYm91bmRzLmdldEhlaWdodCgpIC0gc2lkZVNocmlua2FnZUFtb3VudCApICk7XHJcblxyXG4gICAgLy8gSWYgdGhlIGxlbmd0aCBoYXMgZ290dGVuIHRvIHplcm8sIHJlbW92ZSB0aGlzIHNlZ21lbnQgZnJvbSB0aGUgbGlzdC5cclxuICAgIGlmICggdGhpcy5nZXRDb250YWluZWRMZW5ndGgoKSA8PSBTaGFwZVNlZ21lbnQuRkxPQVRJTkdfUE9JTlRfQ09NUF9GQUNUT1IgKSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gc2hhcGVTZWdtZW50TGlzdC5pbmRleE9mKCB0aGlzICk7XHJcbiAgICAgIHNoYXBlU2VnbWVudExpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xyXG4gICAgfVxyXG4gICAgdGhpcy51cGRhdGVBdHRhY2htZW50U2l0ZVBvc2l0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXHJcbiAgICogQHBhcmFtIHtXaW5kaW5nQmlvbW9sZWN1bGV9IHdpbmRpbmdCaW9tb2xlY3VsZVxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPFNoYXBlU2VnbWVudD59IHNoYXBlU2VnbWVudExpc3RcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgYWR2YW5jZSggbGVuZ3RoLCB3aW5kaW5nQmlvbW9sZWN1bGUsIHNoYXBlU2VnbWVudExpc3QgKSB7XHJcblxyXG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGZvciBzcXVhcmUgc2hhcGUgc2VnbWVudHMsIHNpbmNlIHRyYW5zbGF0aW9uIHNob3VsZCBvbmx5IG9jY3VyIGJhc2VkIGFyb3VuZCBmbGF0XHJcbiAgICAvLyBzZWdtZW50cy5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGZhbHNlLFxyXG4gICAgICAnVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGZvciBzcXVhcmUgc2hhcGUgc2VnbWVudHMsIHNpbmNlIHRyYW5zbGF0aW9uIHNob3VsZCBvbmx5IG9jY3VyIGJhc2VkIGFyb3VuZCBmbGF0IHNlZ21lbnRzLicgKTtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXHJcbiAgICogQHBhcmFtIHtXaW5kaW5nQmlvbW9sZWN1bGV9IHdpbmRpbmdCaW9tb2xlY3VsZVxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPFNoYXBlU2VnbWVudD59IHNoYXBlU2VnbWVudExpc3RcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgYWR2YW5jZUFuZFJlbW92ZSggbGVuZ3RoLCB3aW5kaW5nQmlvbW9sZWN1bGUsIHNoYXBlU2VnbWVudExpc3QgKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ1VuaW1wbGVtZW50ZWQgbWV0aG9kIGNhbGxlZCBvbiBzcXVhcmUgc2hhcGUgc2VnbWVudCcgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZSB0aGUgbGVuZ3RoIG9mIGEgc2lkZSBhcyBhIGZ1bmN0aW9uIG9mIHRoZSBjb250YWluZWQgbGVuZ3RoIG9mIG1STkEuXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGNhbGN1bGF0ZVNpZGVMZW5ndGgoKSB7XHJcbiAgICBjb25zdCBkZXNpcmVkRGlhZ29uYWxMZW5ndGggPSBNYXRoLnBvdyggdGhpcy5jb250YWluZWRMZW5ndGgsIDAuNyApOyAvLyBQb3dlciB2YWx1ZSB3YXMgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZC5cclxuICAgIHJldHVybiBNYXRoLnNxcnQoIDIgKiBkZXNpcmVkRGlhZ29uYWxMZW5ndGggKiBkZXNpcmVkRGlhZ29uYWxMZW5ndGggKTtcclxuICB9XHJcbn1cclxuXHJcbmdlbmVFeHByZXNzaW9uRXNzZW50aWFscy5yZWdpc3RlciggJ1NxdWFyZVNlZ21lbnQnLCBTcXVhcmVTZWdtZW50ICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTcXVhcmVTZWdtZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQSxPQUFPQSxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLHdCQUF3QixNQUFNLG1DQUFtQztBQUN4RSxPQUFPQyxZQUFZLE1BQU0sbUJBQW1CO0FBRTVDLE1BQU1DLGFBQWEsU0FBU0QsWUFBWSxDQUFDO0VBRXZDO0FBQ0Y7QUFDQTtBQUNBO0VBQ0VFLFdBQVdBLENBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFHO0lBRTNCLEtBQUssQ0FBRUQsS0FBTSxDQUFDOztJQUVkO0lBQ0E7SUFDQSxJQUFJLENBQUNFLGVBQWUsR0FBRyxDQUFDLENBQUMsQ0FBQzs7SUFFMUIsSUFBSSxDQUFDQyxNQUFNLENBQUNDLEdBQUcsQ0FBRVQsT0FBTyxDQUFDVSxJQUFJLENBQUVKLE1BQU0sQ0FBQ0ssQ0FBQyxFQUFFTCxNQUFNLENBQUNNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBRSxDQUFFLENBQUM7SUFDM0QsSUFBSSxDQUFDQyw0QkFBNEIsQ0FBQyxDQUFDO0VBQ3JDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsa0JBQWtCQSxDQUFBLEVBQUc7SUFDbkIsT0FBTyxJQUFJLENBQUNQLGVBQWU7RUFDN0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRVEsR0FBR0EsQ0FBRUMsTUFBTSxFQUFFQyxrQkFBa0IsRUFBRUMsZ0JBQWdCLEVBQUc7SUFDbEQsSUFBSSxDQUFDWCxlQUFlLElBQUlTLE1BQU07O0lBRTlCO0lBQ0EsTUFBTUcsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDWixNQUFNLENBQUNhLFFBQVEsQ0FBQyxDQUFDO0lBQzVFQyxNQUFNLElBQUlBLE1BQU0sQ0FBRU4sTUFBTSxJQUFJLENBQUMsSUFBSUcsZ0JBQWdCLElBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQztJQUMxRCxJQUFJLENBQUNYLE1BQU0sQ0FBQ0MsR0FBRyxDQUFFVCxPQUFPLENBQUNVLElBQUksQ0FBRSxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csQ0FBQyxHQUFHUSxnQkFBZ0IsRUFDN0QsSUFBSSxDQUFDWCxNQUFNLENBQUNJLENBQUMsRUFDYixJQUFJLENBQUNKLE1BQU0sQ0FBQ2EsUUFBUSxDQUFDLENBQUMsR0FBR0YsZ0JBQWdCLEVBQ3pDLElBQUksQ0FBQ1gsTUFBTSxDQUFDZSxTQUFTLENBQUMsQ0FBQyxHQUFHSixnQkFBaUIsQ0FBRSxDQUFDO0lBQ2hELElBQUksQ0FBQ04sNEJBQTRCLENBQUMsQ0FBQztFQUNyQzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRVcsTUFBTUEsQ0FBRVIsTUFBTSxFQUFFRSxnQkFBZ0IsRUFBRztJQUNqQyxJQUFJLENBQUNYLGVBQWUsSUFBSVMsTUFBTTs7SUFFOUI7SUFDQSxNQUFNUyxtQkFBbUIsR0FBRyxJQUFJLENBQUNqQixNQUFNLENBQUNhLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDRCxtQkFBbUIsQ0FBQyxDQUFDO0lBRS9FLElBQUksQ0FBQ1osTUFBTSxDQUFDQyxHQUFHLENBQUVULE9BQU8sQ0FBQ1UsSUFBSSxDQUFFLElBQUksQ0FBQ0YsTUFBTSxDQUFDRyxDQUFDLEVBQzFDLElBQUksQ0FBQ0gsTUFBTSxDQUFDSSxDQUFDLEdBQUdhLG1CQUFtQixFQUNuQyxJQUFJLENBQUNqQixNQUFNLENBQUNhLFFBQVEsQ0FBQyxDQUFDLEdBQUdJLG1CQUFtQixFQUM1QyxJQUFJLENBQUNqQixNQUFNLENBQUNlLFNBQVMsQ0FBQyxDQUFDLEdBQUdFLG1CQUFvQixDQUFFLENBQUM7O0lBRW5EO0lBQ0EsSUFBSyxJQUFJLENBQUNYLGtCQUFrQixDQUFDLENBQUMsSUFBSVosWUFBWSxDQUFDd0IsMEJBQTBCLEVBQUc7TUFDMUUsTUFBTUMsS0FBSyxHQUFHVCxnQkFBZ0IsQ0FBQ1UsT0FBTyxDQUFFLElBQUssQ0FBQztNQUM5Q1YsZ0JBQWdCLENBQUNXLE1BQU0sQ0FBRUYsS0FBSyxFQUFFLENBQUUsQ0FBQztJQUNyQztJQUNBLElBQUksQ0FBQ2QsNEJBQTRCLENBQUMsQ0FBQztFQUNyQzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFaUIsT0FBT0EsQ0FBRWQsTUFBTSxFQUFFQyxrQkFBa0IsRUFBRUMsZ0JBQWdCLEVBQUc7SUFFdEQ7SUFDQTtJQUNBSSxNQUFNLElBQUlBLE1BQU0sQ0FBRSxLQUFLLEVBQ3JCLHdIQUF5SCxDQUFDO0VBRTlIOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VTLGdCQUFnQkEsQ0FBRWYsTUFBTSxFQUFFQyxrQkFBa0IsRUFBRUMsZ0JBQWdCLEVBQUc7SUFDL0RJLE1BQU0sSUFBSUEsTUFBTSxDQUFFLEtBQUssRUFBRSxxREFBc0QsQ0FBQztFQUNsRjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0VGLG1CQUFtQkEsQ0FBQSxFQUFHO0lBQ3BCLE1BQU1ZLHFCQUFxQixHQUFHQyxJQUFJLENBQUNDLEdBQUcsQ0FBRSxJQUFJLENBQUMzQixlQUFlLEVBQUUsR0FBSSxDQUFDLENBQUMsQ0FBQztJQUNyRSxPQUFPMEIsSUFBSSxDQUFDRSxJQUFJLENBQUUsQ0FBQyxHQUFHSCxxQkFBcUIsR0FBR0EscUJBQXNCLENBQUM7RUFDdkU7QUFDRjtBQUVBL0Isd0JBQXdCLENBQUNtQyxRQUFRLENBQUUsZUFBZSxFQUFFakMsYUFBYyxDQUFDO0FBRW5FLGVBQWVBLGFBQWEifQ==