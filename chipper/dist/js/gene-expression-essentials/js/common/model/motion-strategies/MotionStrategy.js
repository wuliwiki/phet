// Copyright 2015-2021, University of Colorado Boulder

/**
 * Base class for motion strategies that can be used to exhibit different sorts of motion. This class and its subclasses
 * have been written to be very general in order to enable reuse.
 *
 * @author John Blanco
 * @author Mohamed Safi
 * @author Aadish Gupta
 */

import Range from '../../../../../dot/js/Range.js';
import Vector2 from '../../../../../dot/js/Vector2.js';
import Vector3 from '../../../../../dot/js/Vector3.js';
import geneExpressionEssentials from '../../../geneExpressionEssentials.js';
import GEEConstants from '../../GEEConstants.js';
import MotionBounds from './MotionBounds.js';
class MotionStrategy {
  constructor() {
    this.motionBounds = new MotionBounds(); //@protected
  }

  /**
   * Clean up references so that this is elibible for garbage collection.  This does nothing in the base class,
   * override as needed in subclasses.
   * @public
   */
  dispose() {}

  /**
   * Get the next position given the current position. State information contained in the motion strategy instance,
   * such as the current motion vector, will determine the next position.
   *
   * @param {Vector2} currentPosition
   * @param {Bounds2} bounds   Bounds of the controlled item, used in detecting whether the item would go outside of
   *                           the motion bounds.
   * @param {number} dt
   * @public
   */
  getNextPosition(currentPosition, bounds, dt) {
    throw new Error('getNextPosition should be implemented in descendant classes of MotionStrategy .');
  }

  /**
   * Get the next position in three dimensions given the current position. State information contained in the motion
   * strategy instance, such as the current motion vector, will determine the next position.
   *
   * @param {Vector3} currentPosition
   * @param {Bounds2} bounds   Bounds of the controlled item, used in detecting
   *                           whether the item would go outside of the motion
   *                           bounds.
   * @param {number} dt
   * @returns {Vector3}
   * @public
   */
  getNextPosition3D(currentPosition, bounds, dt) {
    // Default version does not move in Z direction, override for true 3D motion.
    const nextPosition2D = this.getNextPosition(new Vector2(currentPosition.x, currentPosition.y), bounds, dt);
    return new Vector3(nextPosition2D.x, nextPosition2D.y, 0);
  }

  /**
   * This utility method will return a motion vector that reflects a "bounce" in the x, y, or both directions based on
   * which type of bounce will yield a next position for the shape that is within the motion bounds. If no such vector
   * can be found, a vector to the center of the motion bounds is returned.
   *
   * @param {Bounds2} bounds
   * @param {Vector2} originalMotionVector
   * @param {number} dt
   * @param {number} maxVelocity
   * @returns {Vector2}
   * @protected
   */
  getMotionVectorForBounce(bounds, originalMotionVector, dt, maxVelocity) {
    // Check that this isn't being called inappropriately
    assert && assert(!this.motionBounds.inBounds(bounds.shiftedXY(originalMotionVector.x * dt, originalMotionVector.y * dt)));

    // Try reversing X direction.
    const reversedXMotionVector = new Vector2(-originalMotionVector.x, originalMotionVector.y);
    if (this.motionBounds.inBounds(bounds.shiftedXY(reversedXMotionVector.x * dt, reversedXMotionVector.y * dt))) {
      return reversedXMotionVector;
    }

    // Try reversing Y direction.
    const reversedYMotionVector = new Vector2(originalMotionVector.x, -originalMotionVector.y);
    if (this.motionBounds.inBounds(bounds.shiftedXY(reversedYMotionVector.x * dt, reversedYMotionVector * dt))) {
      return reversedYMotionVector;
    }

    // Try reversing both X and Y directions.
    const reversedXYMotionVector = new Vector2(-originalMotionVector.x, -originalMotionVector.y);
    if (this.motionBounds.inBounds(bounds.shiftedXY(reversedXYMotionVector.x * dt, reversedXYMotionVector.x * dt))) {
      return reversedXYMotionVector;
    }

    // If we reach this point, there is no vector that can be found that will bounce the molecule back into the motion
    // bounds. This might be because the molecule was dropped somewhere out of bounds, or maybe just that it is stuck
    // to the DNA or something. So, just return a vector back to the center of the motion bounds.  That should be a
    // safe bet.
    const centerOfMotionBounds = this.motionBounds.getBounds().getCenter();
    const vectorToMotionBoundsCenter = new Vector2(centerOfMotionBounds.x - bounds.getCenterX(), centerOfMotionBounds.y - bounds.getCenterY());
    vectorToMotionBoundsCenter.multiplyScalar(maxVelocity / vectorToMotionBoundsCenter.magnitude);
    return vectorToMotionBoundsCenter;
  }

  /**
   * Utility function for determining the distance between two ranges.
   * @param {Range} r1
   * @param {Range} r2
   * @returns {number}
   * @private
   */
  calculateDistanceBetweenRanges(r1, r2) {
    let distance;
    if (r1.intersects(r2)) {
      // Ranges overlap, so there is no distance between them.
      distance = 0;
    } else if (r1.max < r2.min) {
      distance = r2.min - r1.max;
    } else {
      distance = r1.min - r2.max;
    }
    return distance;
  }

  /**
   * Limit the Z position so that biomolecules don't look transparent when on top of the DNA, and become less
   * transparent as they get close so that they don't appear to pop forward when connected to the DNA (or just
   * wandering above it).
   *
   * @param {Bounds2} bounds
   * @param {Vector2} positionXY
   * @returns {number}
   * @protected
   */
  getMinZ(bounds, positionXY) {
    const shapeYRange = new Range(positionXY.y - bounds.height / 2, positionXY.y + bounds.height / 2);
    const dnaYRange = new Range(GEEConstants.DNA_MOLECULE_Y_POS - GEEConstants.DNA_MOLECULE_DIAMETER / 2, GEEConstants.DNA_MOLECULE_Y_POS + GEEConstants.DNA_MOLECULE_DIAMETER / 2);
    let minZ = -1;
    const distanceToEdgeOfDna = this.calculateDistanceBetweenRanges(shapeYRange, dnaYRange);
    if (distanceToEdgeOfDna < shapeYRange.getLength() / 2) {
      // Limit the z-dimension so that the biomolecule is at the front when over the DNA and make a gradient as it
      // gets close to the DNA.
      minZ = -distanceToEdgeOfDna / (shapeYRange.getLength() / 2);
    }
    return minZ;
  }
}
geneExpressionEssentials.register('MotionStrategy', MotionStrategy);
export default MotionStrategy;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSYW5nZSIsIlZlY3RvcjIiLCJWZWN0b3IzIiwiZ2VuZUV4cHJlc3Npb25Fc3NlbnRpYWxzIiwiR0VFQ29uc3RhbnRzIiwiTW90aW9uQm91bmRzIiwiTW90aW9uU3RyYXRlZ3kiLCJjb25zdHJ1Y3RvciIsIm1vdGlvbkJvdW5kcyIsImRpc3Bvc2UiLCJnZXROZXh0UG9zaXRpb24iLCJjdXJyZW50UG9zaXRpb24iLCJib3VuZHMiLCJkdCIsIkVycm9yIiwiZ2V0TmV4dFBvc2l0aW9uM0QiLCJuZXh0UG9zaXRpb24yRCIsIngiLCJ5IiwiZ2V0TW90aW9uVmVjdG9yRm9yQm91bmNlIiwib3JpZ2luYWxNb3Rpb25WZWN0b3IiLCJtYXhWZWxvY2l0eSIsImFzc2VydCIsImluQm91bmRzIiwic2hpZnRlZFhZIiwicmV2ZXJzZWRYTW90aW9uVmVjdG9yIiwicmV2ZXJzZWRZTW90aW9uVmVjdG9yIiwicmV2ZXJzZWRYWU1vdGlvblZlY3RvciIsImNlbnRlck9mTW90aW9uQm91bmRzIiwiZ2V0Qm91bmRzIiwiZ2V0Q2VudGVyIiwidmVjdG9yVG9Nb3Rpb25Cb3VuZHNDZW50ZXIiLCJnZXRDZW50ZXJYIiwiZ2V0Q2VudGVyWSIsIm11bHRpcGx5U2NhbGFyIiwibWFnbml0dWRlIiwiY2FsY3VsYXRlRGlzdGFuY2VCZXR3ZWVuUmFuZ2VzIiwicjEiLCJyMiIsImRpc3RhbmNlIiwiaW50ZXJzZWN0cyIsIm1heCIsIm1pbiIsImdldE1pbloiLCJwb3NpdGlvblhZIiwic2hhcGVZUmFuZ2UiLCJoZWlnaHQiLCJkbmFZUmFuZ2UiLCJETkFfTU9MRUNVTEVfWV9QT1MiLCJETkFfTU9MRUNVTEVfRElBTUVURVIiLCJtaW5aIiwiZGlzdGFuY2VUb0VkZ2VPZkRuYSIsImdldExlbmd0aCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiTW90aW9uU3RyYXRlZ3kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUtMjAyMSwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgbW90aW9uIHN0cmF0ZWdpZXMgdGhhdCBjYW4gYmUgdXNlZCB0byBleGhpYml0IGRpZmZlcmVudCBzb3J0cyBvZiBtb3Rpb24uIFRoaXMgY2xhc3MgYW5kIGl0cyBzdWJjbGFzc2VzXHJcbiAqIGhhdmUgYmVlbiB3cml0dGVuIHRvIGJlIHZlcnkgZ2VuZXJhbCBpbiBvcmRlciB0byBlbmFibGUgcmV1c2UuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICogQGF1dGhvciBNb2hhbWVkIFNhZmlcclxuICogQGF1dGhvciBBYWRpc2ggR3VwdGFcclxuICovXHJcblxyXG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi4vLi4vLi4vLi4vLi4vZG90L2pzL1JhbmdlLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgVmVjdG9yMyBmcm9tICcuLi8uLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCBnZW5lRXhwcmVzc2lvbkVzc2VudGlhbHMgZnJvbSAnLi4vLi4vLi4vZ2VuZUV4cHJlc3Npb25Fc3NlbnRpYWxzLmpzJztcclxuaW1wb3J0IEdFRUNvbnN0YW50cyBmcm9tICcuLi8uLi9HRUVDb25zdGFudHMuanMnO1xyXG5pbXBvcnQgTW90aW9uQm91bmRzIGZyb20gJy4vTW90aW9uQm91bmRzLmpzJztcclxuXHJcbmNsYXNzIE1vdGlvblN0cmF0ZWd5IHtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLm1vdGlvbkJvdW5kcyA9IG5ldyBNb3Rpb25Cb3VuZHMoKTsgLy9AcHJvdGVjdGVkXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhbiB1cCByZWZlcmVuY2VzIHNvIHRoYXQgdGhpcyBpcyBlbGliaWJsZSBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLiAgVGhpcyBkb2VzIG5vdGhpbmcgaW4gdGhlIGJhc2UgY2xhc3MsXHJcbiAgICogb3ZlcnJpZGUgYXMgbmVlZGVkIGluIHN1YmNsYXNzZXMuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIG5leHQgcG9zaXRpb24gZ2l2ZW4gdGhlIGN1cnJlbnQgcG9zaXRpb24uIFN0YXRlIGluZm9ybWF0aW9uIGNvbnRhaW5lZCBpbiB0aGUgbW90aW9uIHN0cmF0ZWd5IGluc3RhbmNlLFxyXG4gICAqIHN1Y2ggYXMgdGhlIGN1cnJlbnQgbW90aW9uIHZlY3Rvciwgd2lsbCBkZXRlcm1pbmUgdGhlIG5leHQgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IGN1cnJlbnRQb3NpdGlvblxyXG4gICAqIEBwYXJhbSB7Qm91bmRzMn0gYm91bmRzICAgQm91bmRzIG9mIHRoZSBjb250cm9sbGVkIGl0ZW0sIHVzZWQgaW4gZGV0ZWN0aW5nIHdoZXRoZXIgdGhlIGl0ZW0gd291bGQgZ28gb3V0c2lkZSBvZlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG1vdGlvbiBib3VuZHMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGdldE5leHRQb3NpdGlvbiggY3VycmVudFBvc2l0aW9uLCBib3VuZHMsIGR0ICkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCAnZ2V0TmV4dFBvc2l0aW9uIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBkZXNjZW5kYW50IGNsYXNzZXMgb2YgTW90aW9uU3RyYXRlZ3kgLicgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbmV4dCBwb3NpdGlvbiBpbiB0aHJlZSBkaW1lbnNpb25zIGdpdmVuIHRoZSBjdXJyZW50IHBvc2l0aW9uLiBTdGF0ZSBpbmZvcm1hdGlvbiBjb250YWluZWQgaW4gdGhlIG1vdGlvblxyXG4gICAqIHN0cmF0ZWd5IGluc3RhbmNlLCBzdWNoIGFzIHRoZSBjdXJyZW50IG1vdGlvbiB2ZWN0b3IsIHdpbGwgZGV0ZXJtaW5lIHRoZSBuZXh0IHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBjdXJyZW50UG9zaXRpb25cclxuICAgKiBAcGFyYW0ge0JvdW5kczJ9IGJvdW5kcyAgIEJvdW5kcyBvZiB0aGUgY29udHJvbGxlZCBpdGVtLCB1c2VkIGluIGRldGVjdGluZ1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hldGhlciB0aGUgaXRlbSB3b3VsZCBnbyBvdXRzaWRlIG9mIHRoZSBtb3Rpb25cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHRcclxuICAgKiBAcmV0dXJucyB7VmVjdG9yM31cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgZ2V0TmV4dFBvc2l0aW9uM0QoIGN1cnJlbnRQb3NpdGlvbiwgYm91bmRzLCBkdCApIHtcclxuXHJcbiAgICAvLyBEZWZhdWx0IHZlcnNpb24gZG9lcyBub3QgbW92ZSBpbiBaIGRpcmVjdGlvbiwgb3ZlcnJpZGUgZm9yIHRydWUgM0QgbW90aW9uLlxyXG4gICAgY29uc3QgbmV4dFBvc2l0aW9uMkQgPSB0aGlzLmdldE5leHRQb3NpdGlvbiggbmV3IFZlY3RvcjIoIGN1cnJlbnRQb3NpdGlvbi54LCBjdXJyZW50UG9zaXRpb24ueSApLCBib3VuZHMsIGR0ICk7XHJcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoIG5leHRQb3NpdGlvbjJELngsIG5leHRQb3NpdGlvbjJELnksIDAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgdXRpbGl0eSBtZXRob2Qgd2lsbCByZXR1cm4gYSBtb3Rpb24gdmVjdG9yIHRoYXQgcmVmbGVjdHMgYSBcImJvdW5jZVwiIGluIHRoZSB4LCB5LCBvciBib3RoIGRpcmVjdGlvbnMgYmFzZWQgb25cclxuICAgKiB3aGljaCB0eXBlIG9mIGJvdW5jZSB3aWxsIHlpZWxkIGEgbmV4dCBwb3NpdGlvbiBmb3IgdGhlIHNoYXBlIHRoYXQgaXMgd2l0aGluIHRoZSBtb3Rpb24gYm91bmRzLiBJZiBubyBzdWNoIHZlY3RvclxyXG4gICAqIGNhbiBiZSBmb3VuZCwgYSB2ZWN0b3IgdG8gdGhlIGNlbnRlciBvZiB0aGUgbW90aW9uIGJvdW5kcyBpcyByZXR1cm5lZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Qm91bmRzMn0gYm91bmRzXHJcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBvcmlnaW5hbE1vdGlvblZlY3RvclxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhWZWxvY2l0eVxyXG4gICAqIEByZXR1cm5zIHtWZWN0b3IyfVxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBnZXRNb3Rpb25WZWN0b3JGb3JCb3VuY2UoIGJvdW5kcywgb3JpZ2luYWxNb3Rpb25WZWN0b3IsIGR0LCBtYXhWZWxvY2l0eSApIHtcclxuICAgIC8vIENoZWNrIHRoYXQgdGhpcyBpc24ndCBiZWluZyBjYWxsZWQgaW5hcHByb3ByaWF0ZWx5XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhdGhpcy5tb3Rpb25Cb3VuZHMuaW5Cb3VuZHMoIGJvdW5kcy5zaGlmdGVkWFkoIG9yaWdpbmFsTW90aW9uVmVjdG9yLnggKiBkdCwgb3JpZ2luYWxNb3Rpb25WZWN0b3IueSAqIGR0ICkgKSApO1xyXG5cclxuICAgIC8vIFRyeSByZXZlcnNpbmcgWCBkaXJlY3Rpb24uXHJcbiAgICBjb25zdCByZXZlcnNlZFhNb3Rpb25WZWN0b3IgPSBuZXcgVmVjdG9yMiggLW9yaWdpbmFsTW90aW9uVmVjdG9yLngsIG9yaWdpbmFsTW90aW9uVmVjdG9yLnkgKTtcclxuICAgIGlmICggdGhpcy5tb3Rpb25Cb3VuZHMuaW5Cb3VuZHMoIGJvdW5kcy5zaGlmdGVkWFkoIHJldmVyc2VkWE1vdGlvblZlY3Rvci54ICogZHQsIHJldmVyc2VkWE1vdGlvblZlY3Rvci55ICogZHQgKSApICkge1xyXG4gICAgICByZXR1cm4gcmV2ZXJzZWRYTW90aW9uVmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSByZXZlcnNpbmcgWSBkaXJlY3Rpb24uXHJcbiAgICBjb25zdCByZXZlcnNlZFlNb3Rpb25WZWN0b3IgPSBuZXcgVmVjdG9yMiggb3JpZ2luYWxNb3Rpb25WZWN0b3IueCwgLW9yaWdpbmFsTW90aW9uVmVjdG9yLnkgKTtcclxuICAgIGlmICggdGhpcy5tb3Rpb25Cb3VuZHMuaW5Cb3VuZHMoIGJvdW5kcy5zaGlmdGVkWFkoIHJldmVyc2VkWU1vdGlvblZlY3Rvci54ICogZHQsIHJldmVyc2VkWU1vdGlvblZlY3RvciAqIGR0ICkgKSApIHtcclxuICAgICAgcmV0dXJuIHJldmVyc2VkWU1vdGlvblZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnkgcmV2ZXJzaW5nIGJvdGggWCBhbmQgWSBkaXJlY3Rpb25zLlxyXG4gICAgY29uc3QgcmV2ZXJzZWRYWU1vdGlvblZlY3RvciA9IG5ldyBWZWN0b3IyKCAtb3JpZ2luYWxNb3Rpb25WZWN0b3IueCwgLW9yaWdpbmFsTW90aW9uVmVjdG9yLnkgKTtcclxuICAgIGlmICggdGhpcy5tb3Rpb25Cb3VuZHMuaW5Cb3VuZHMoIGJvdW5kcy5zaGlmdGVkWFkoIHJldmVyc2VkWFlNb3Rpb25WZWN0b3IueCAqIGR0LCByZXZlcnNlZFhZTW90aW9uVmVjdG9yLnggKiBkdCApICkgKSB7XHJcbiAgICAgIHJldHVybiByZXZlcnNlZFhZTW90aW9uVmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHdlIHJlYWNoIHRoaXMgcG9pbnQsIHRoZXJlIGlzIG5vIHZlY3RvciB0aGF0IGNhbiBiZSBmb3VuZCB0aGF0IHdpbGwgYm91bmNlIHRoZSBtb2xlY3VsZSBiYWNrIGludG8gdGhlIG1vdGlvblxyXG4gICAgLy8gYm91bmRzLiBUaGlzIG1pZ2h0IGJlIGJlY2F1c2UgdGhlIG1vbGVjdWxlIHdhcyBkcm9wcGVkIHNvbWV3aGVyZSBvdXQgb2YgYm91bmRzLCBvciBtYXliZSBqdXN0IHRoYXQgaXQgaXMgc3R1Y2tcclxuICAgIC8vIHRvIHRoZSBETkEgb3Igc29tZXRoaW5nLiBTbywganVzdCByZXR1cm4gYSB2ZWN0b3IgYmFjayB0byB0aGUgY2VudGVyIG9mIHRoZSBtb3Rpb24gYm91bmRzLiAgVGhhdCBzaG91bGQgYmUgYVxyXG4gICAgLy8gc2FmZSBiZXQuXHJcbiAgICBjb25zdCBjZW50ZXJPZk1vdGlvbkJvdW5kcyA9IHRoaXMubW90aW9uQm91bmRzLmdldEJvdW5kcygpLmdldENlbnRlcigpO1xyXG4gICAgY29uc3QgdmVjdG9yVG9Nb3Rpb25Cb3VuZHNDZW50ZXIgPSBuZXcgVmVjdG9yMiggY2VudGVyT2ZNb3Rpb25Cb3VuZHMueCAtIGJvdW5kcy5nZXRDZW50ZXJYKCksXHJcbiAgICAgIGNlbnRlck9mTW90aW9uQm91bmRzLnkgLSBib3VuZHMuZ2V0Q2VudGVyWSgpICk7XHJcbiAgICB2ZWN0b3JUb01vdGlvbkJvdW5kc0NlbnRlci5tdWx0aXBseVNjYWxhciggbWF4VmVsb2NpdHkgLyB2ZWN0b3JUb01vdGlvbkJvdW5kc0NlbnRlci5tYWduaXR1ZGUgKTtcclxuICAgIHJldHVybiB2ZWN0b3JUb01vdGlvbkJvdW5kc0NlbnRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byByYW5nZXMuXHJcbiAgICogQHBhcmFtIHtSYW5nZX0gcjFcclxuICAgKiBAcGFyYW0ge1JhbmdlfSByMlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBjYWxjdWxhdGVEaXN0YW5jZUJldHdlZW5SYW5nZXMoIHIxLCByMiApIHtcclxuICAgIGxldCBkaXN0YW5jZTtcclxuICAgIGlmICggcjEuaW50ZXJzZWN0cyggcjIgKSApIHtcclxuXHJcbiAgICAgIC8vIFJhbmdlcyBvdmVybGFwLCBzbyB0aGVyZSBpcyBubyBkaXN0YW5jZSBiZXR3ZWVuIHRoZW0uXHJcbiAgICAgIGRpc3RhbmNlID0gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCByMS5tYXggPCByMi5taW4gKSB7XHJcbiAgICAgIGRpc3RhbmNlID0gcjIubWluIC0gcjEubWF4O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGRpc3RhbmNlID0gcjEubWluIC0gcjIubWF4O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGltaXQgdGhlIFogcG9zaXRpb24gc28gdGhhdCBiaW9tb2xlY3VsZXMgZG9uJ3QgbG9vayB0cmFuc3BhcmVudCB3aGVuIG9uIHRvcCBvZiB0aGUgRE5BLCBhbmQgYmVjb21lIGxlc3NcclxuICAgKiB0cmFuc3BhcmVudCBhcyB0aGV5IGdldCBjbG9zZSBzbyB0aGF0IHRoZXkgZG9uJ3QgYXBwZWFyIHRvIHBvcCBmb3J3YXJkIHdoZW4gY29ubmVjdGVkIHRvIHRoZSBETkEgKG9yIGp1c3RcclxuICAgKiB3YW5kZXJpbmcgYWJvdmUgaXQpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCb3VuZHMyfSBib3VuZHNcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHBvc2l0aW9uWFlcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBnZXRNaW5aKCBib3VuZHMsIHBvc2l0aW9uWFkgKSB7XHJcbiAgICBjb25zdCBzaGFwZVlSYW5nZSA9IG5ldyBSYW5nZSggcG9zaXRpb25YWS55IC0gYm91bmRzLmhlaWdodCAvIDIsXHJcbiAgICAgIHBvc2l0aW9uWFkueSArIGJvdW5kcy5oZWlnaHQgLyAyICk7XHJcbiAgICBjb25zdCBkbmFZUmFuZ2UgPSBuZXcgUmFuZ2UoIEdFRUNvbnN0YW50cy5ETkFfTU9MRUNVTEVfWV9QT1MgLSBHRUVDb25zdGFudHMuRE5BX01PTEVDVUxFX0RJQU1FVEVSIC8gMixcclxuICAgICAgR0VFQ29uc3RhbnRzLkROQV9NT0xFQ1VMRV9ZX1BPUyArIEdFRUNvbnN0YW50cy5ETkFfTU9MRUNVTEVfRElBTUVURVIgLyAyICk7XHJcbiAgICBsZXQgbWluWiA9IC0xO1xyXG4gICAgY29uc3QgZGlzdGFuY2VUb0VkZ2VPZkRuYSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2VCZXR3ZWVuUmFuZ2VzKCBzaGFwZVlSYW5nZSwgZG5hWVJhbmdlICk7XHJcbiAgICBpZiAoIGRpc3RhbmNlVG9FZGdlT2ZEbmEgPCBzaGFwZVlSYW5nZS5nZXRMZW5ndGgoKSAvIDIgKSB7XHJcblxyXG4gICAgICAvLyBMaW1pdCB0aGUgei1kaW1lbnNpb24gc28gdGhhdCB0aGUgYmlvbW9sZWN1bGUgaXMgYXQgdGhlIGZyb250IHdoZW4gb3ZlciB0aGUgRE5BIGFuZCBtYWtlIGEgZ3JhZGllbnQgYXMgaXRcclxuICAgICAgLy8gZ2V0cyBjbG9zZSB0byB0aGUgRE5BLlxyXG4gICAgICBtaW5aID0gLWRpc3RhbmNlVG9FZGdlT2ZEbmEgLyAoIHNoYXBlWVJhbmdlLmdldExlbmd0aCgpIC8gMiApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1pblo7XHJcbiAgfVxyXG59XHJcblxyXG5nZW5lRXhwcmVzc2lvbkVzc2VudGlhbHMucmVnaXN0ZXIoICdNb3Rpb25TdHJhdGVneScsIE1vdGlvblN0cmF0ZWd5ICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNb3Rpb25TdHJhdGVneTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLEtBQUssTUFBTSxnQ0FBZ0M7QUFDbEQsT0FBT0MsT0FBTyxNQUFNLGtDQUFrQztBQUN0RCxPQUFPQyxPQUFPLE1BQU0sa0NBQWtDO0FBQ3RELE9BQU9DLHdCQUF3QixNQUFNLHNDQUFzQztBQUMzRSxPQUFP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