// Copyright 2015-2023, University of Colorado Boulder

/**
 * monitors the average atomic mass of a set of isotopes in a model and displays it.
 *
 * @author John Blanco
 * @author James Smith
 * @author Aadish Gupta
 *
 */

import Dimension2 from '../../../../dot/js/Dimension2.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import PhetFont from '../../../../scenery-phet/js/PhetFont.js';
import { Color, Line, Node, Path, RichText, Text } from '../../../../scenery/js/imports.js';
import AtomIdentifier from '../../../../shred/js/AtomIdentifier.js';
import Panel from '../../../../sun/js/Panel.js';
import isotopesAndAtomicMass from '../../isotopesAndAtomicMass.js';
import IsotopesAndAtomicMassStrings from '../../IsotopesAndAtomicMassStrings.js';

// constants
const INDICATOR_WIDTH = 200;
const TICK_MARK_LINE_HEIGHT = 15;
const TICK_MARK_LINE_WIDTH = 5;
const SIZE = new Dimension2(75, 25);
const TRIANGULAR_POINTER_HEIGHT = 15;
const TRIANGULAR_POINTER_WIDTH = 20;
const NUMBER_DECIMALS = 5;
const amuString = IsotopesAndAtomicMassStrings.amu;

/**
 * Convenience function for creating tick marks. This includes both the actual mark and the label.
 * @param {NumberAtom} isotopeConfig
 */
function IsotopeTickMark(isotopeConfig) {
  const node = new Node();

  // Create the tick mark itself.  It is positioned such that (0,0) is the center of the mark.
  const shape = new Line(0, -TICK_MARK_LINE_HEIGHT / 2, 0, TICK_MARK_LINE_HEIGHT / 2, {
    lineWidth: TICK_MARK_LINE_WIDTH,
    stroke: 'black'
  });
  node.addChild(shape);

  // Create the label that goes above the tick mark.
  const label = new RichText(` <sup>${isotopeConfig.massNumberProperty.get()}</sup>${AtomIdentifier.getSymbol(isotopeConfig.protonCountProperty.get())}`, {
    font: new PhetFont(12)
  });
  label.centerX = shape.centerX;
  label.bottom = shape.top;
  node.addChild(label);
  return node;
}

/**
 * This convenience define the "readout pointer", which is an indicator that contains a textual indication of the
 * average atomic mass and also has a pointer on the top that can be used to indicate the position on a linear scale.
 * This node is set up such that the (0,0) point is at the top center of the node, which is where the point of the
 * pointer exists. This is done to make it easy to position the node under the mass indication line.
 *
 * @param {MixIsotopeModel} model
 */
function ReadoutPointer(model) {
  const node = new Node();
  this.model = model;
  // Add the triangular pointer. This is created such that the point of the triangle is at (0,0) for this node.

  const vertices = [new Vector2(-TRIANGULAR_POINTER_WIDTH / 2, TRIANGULAR_POINTER_HEIGHT), new Vector2(TRIANGULAR_POINTER_WIDTH / 2, TRIANGULAR_POINTER_HEIGHT), new Vector2(0, 0)];
  const triangle = new Path(Shape.polygon(vertices), {
    fill: new Color(0, 143, 212),
    lineWidth: 1
  });
  node.addChild(triangle);
  const readoutText = new Text('', {
    font: new PhetFont(14),
    maxWidth: 0.9 * SIZE.width,
    maxHeight: 0.9 * SIZE.height
  });
  const readoutPanel = new Panel(readoutText, {
    minWidth: SIZE.width,
    minHeight: SIZE.height,
    resize: false,
    cornerRadius: 2,
    lineWidth: 1,
    align: 'center',
    fill: 'white'
  });
  readoutPanel.top = triangle.bottom;
  readoutPanel.centerX = triangle.centerX;
  node.addChild(readoutPanel);
  function updateReadout(averageAtomicMass) {
    let weight;
    if (model.showingNaturesMixProperty.get()) {
      weight = AtomIdentifier.getStandardAtomicMass(model.selectedAtomConfig.protonCount);
    } else {
      weight = averageAtomicMass;
    }
    readoutText.setString(`${Utils.toFixed(weight, NUMBER_DECIMALS)} ${amuString}`);
    readoutText.centerX = SIZE.width / 2;
  }

  // Observe the average atomic weight property in the model and update the textual readout whenever it changes.
  // Doesn't need unlink as it stays through out the sim life
  model.testChamber.averageAtomicMassProperty.link(averageAtomicMass => {
    updateReadout(averageAtomicMass);
  });
  return node;
}
class AverageAtomicMassIndicator extends Node {
  /**
   * @param {MixIsotopesModel} model
   */
  constructor(model) {
    super();

    // Root node onto which all other nodes are added.  This is done so that the root node can be offset at the end of
    // construction in such a way that the (0,0) position will be in the upper left corner.

    // Add the bar that makes up "spine" of the indicator.
    const barNode = new Line(0, 0, INDICATOR_WIDTH, 0, {
      lineWidth: 3,
      stroke: 'black'
    });
    this.addChild(barNode);

    // Add the layer where the tick marks will be maintained.
    const tickMarkLayer = new Node();
    this.addChild(tickMarkLayer);

    // Listen for changes to the list of possible isotopes and update the tick marks when changes occur.
    // Doesn't need unlink as it stays through out the sim life
    model.possibleIsotopesProperty.link(() => {
      tickMarkLayer.removeAllChildren();
      const possibleIsotopesList = model.possibleIsotopesProperty.get();
      let lightestIsotopeMass = Number.POSITIVE_INFINITY;
      let heaviestIsotopeMass = 0;
      this.minMass = Number.POSITIVE_INFINITY;
      possibleIsotopesList.forEach(isotope => {
        if (isotope.getIsotopeAtomicMass() > heaviestIsotopeMass) {
          heaviestIsotopeMass = isotope.getIsotopeAtomicMass();
        }
        if (isotope.getIsotopeAtomicMass() < lightestIsotopeMass) {
          lightestIsotopeMass = isotope.getIsotopeAtomicMass();
        }
      });
      this.massSpan = heaviestIsotopeMass - lightestIsotopeMass;
      if (this.massSpan < 2) {
        this.massSpan = 2; // Mass spa n must be at least 2 or the spacing doesn't look good.
      }
      // Adjust the span so that there is some space at the ends of the line.
      this.massSpan *= 1.2;
      // Set the low end of the mass range, needed for positioning on line.
      this.minMass = (heaviestIsotopeMass + lightestIsotopeMass) / 2 - this.massSpan / 2;

      // Add the new tick marks.
      model.possibleIsotopesProperty.get().forEach(isotope => {
        const tickMark = new IsotopeTickMark(isotope);
        tickMark.centerX = this.calcXOffsetFromAtomicMass(isotope.getIsotopeAtomicMass());
        tickMarkLayer.addChild(tickMark);
      });
    });

    // Add the moving readout.
    const readoutPointer = new ReadoutPointer(model);
    readoutPointer.top = barNode.bottom;
    readoutPointer.centerX = barNode.centerX;
    this.addChild(readoutPointer);

    // Doesn't need unlink as it stays through out the sim life
    model.testChamber.averageAtomicMassProperty.link(averageAtomicMass => {
      if (model.testChamber.isotopeCountProperty.get() > 0) {
        readoutPointer.centerX = this.calcXOffsetFromAtomicMass(averageAtomicMass);
        readoutPointer.setVisible(true);
      } else {
        readoutPointer.setVisible(false);
      }
    });
  }

  /**
   * Calculate the X offset on the bar given the atomic mass. This is clamped to never return a value less than 0.
   * @param {double} atomicMass
   * @returns {number}
   * @private
   */
  calcXOffsetFromAtomicMass(atomicMass) {
    return Math.max((atomicMass - this.minMass) / this.massSpan * INDICATOR_WIDTH, 0);
  }
}
isotopesAndAtomicMass.register('AverageAtomicMassIndicator', AverageAtomicMassIndicator);
export default AverageAtomicMassIndicator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEaW1lbnNpb24yIiwiVXRpbHMiLCJWZWN0b3IyIiwiU2hhcGUiLCJQaGV0Rm9udCIsIkNvbG9yIiwiTGluZSIsIk5vZGUiLCJQYXRoIiwiUmljaFRleHQiLCJUZXh0IiwiQXRvbUlkZW50aWZpZXIiLCJQYW5lbCIsImlzb3RvcGVzQW5kQXRvbWljTWFzcyIsIklzb3RvcGVzQW5kQXRvbWljTWFzc1N0cmluZ3MiLCJJTkRJQ0FUT1JfV0lEVEgiLCJUSUNLX01BUktfTElORV9IRUlHSFQiLCJUSUNLX01BUktfTElORV9XSURUSCIsIlNJWkUiLCJUUklBTkdVTEFSX1BPSU5URVJfSEVJR0hUIiwiVFJJQU5HVUxBUl9QT0lOVEVSX1dJRFRIIiwiTlVNQkVSX0RFQ0lNQUxTIiwiYW11U3RyaW5nIiwiYW11IiwiSXNvdG9wZVRpY2tNYXJrIiwiaXNvdG9wZUNvbmZpZyIsIm5vZGUiLCJzaGFwZSIsImxpbmVXaWR0aCIsInN0cm9rZSIsImFkZENoaWxkIiwibGFiZWwiLCJtYXNzTnVtYmVyUHJvcGVydHkiLCJnZXQiLCJnZXRTeW1ib2wiLCJwcm90b25Db3VudFByb3BlcnR5IiwiZm9udCIsImNlbnRlclgiLCJib3R0b20iLCJ0b3AiLCJSZWFkb3V0UG9pbnRlciIsIm1vZGVsIiwidmVydGljZXMiLCJ0cmlhbmdsZSIsInBvbHlnb24iLCJmaWxsIiwicmVhZG91dFRleHQiLCJtYXhXaWR0aCIsIndpZHRoIiwibWF4SGVpZ2h0IiwiaGVpZ2h0IiwicmVhZG91dFBhbmVsIiwibWluV2lkdGgiLCJtaW5IZWlnaHQiLCJyZXNpemUiLCJjb3JuZXJSYWRpdXMiLCJhbGlnbiIsInVwZGF0ZVJlYWRvdXQiLCJhdmVyYWdlQXRvbWljTWFzcyIsIndlaWdodCIsInNob3dpbmdOYXR1cmVzTWl4UHJvcGVydHkiLCJnZXRTdGFuZGFyZEF0b21pY01hc3MiLCJzZWxlY3RlZEF0b21Db25maWciLCJwcm90b25Db3VudCIsInNldFN0cmluZyIsInRvRml4ZWQiLCJ0ZXN0Q2hhbWJlciIsImF2ZXJhZ2VBdG9taWNNYXNzUHJvcGVydHkiLCJsaW5rIiwiQXZlcmFnZUF0b21pY01hc3NJbmRpY2F0b3IiLCJjb25zdHJ1Y3RvciIsImJhck5vZGUiLCJ0aWNrTWFya0xheWVyIiwicG9zc2libGVJc290b3Blc1Byb3BlcnR5IiwicmVtb3ZlQWxsQ2hpbGRyZW4iLCJwb3NzaWJsZUlzb3RvcGVzTGlzdCIsImxpZ2h0ZXN0SXNvdG9wZU1hc3MiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsImhlYXZpZXN0SXNvdG9wZU1hc3MiLCJtaW5NYXNzIiwiZm9yRWFjaCIsImlzb3RvcGUiLCJnZXRJc290b3BlQXRvbWljTWFzcyIsIm1hc3NTcGFuIiwidGlja01hcmsiLCJjYWxjWE9mZnNldEZyb21BdG9taWNNYXNzIiwicmVhZG91dFBvaW50ZXIiLCJpc290b3BlQ291bnRQcm9wZXJ0eSIsInNldFZpc2libGUiLCJhdG9taWNNYXNzIiwiTWF0aCIsIm1heCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQXZlcmFnZUF0b21pY01hc3NJbmRpY2F0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogbW9uaXRvcnMgdGhlIGF2ZXJhZ2UgYXRvbWljIG1hc3Mgb2YgYSBzZXQgb2YgaXNvdG9wZXMgaW4gYSBtb2RlbCBhbmQgZGlzcGxheXMgaXQuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICogQGF1dGhvciBKYW1lcyBTbWl0aFxyXG4gKiBAYXV0aG9yIEFhZGlzaCBHdXB0YVxyXG4gKlxyXG4gKi9cclxuXHJcbmltcG9ydCBEaW1lbnNpb24yIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9EaW1lbnNpb24yLmpzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi8uLi8uLi8uLi9raXRlL2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgUGhldEZvbnQgZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS1waGV0L2pzL1BoZXRGb250LmpzJztcclxuaW1wb3J0IHsgQ29sb3IsIExpbmUsIE5vZGUsIFBhdGgsIFJpY2hUZXh0LCBUZXh0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IEF0b21JZGVudGlmaWVyIGZyb20gJy4uLy4uLy4uLy4uL3NocmVkL2pzL0F0b21JZGVudGlmaWVyLmpzJztcclxuaW1wb3J0IFBhbmVsIGZyb20gJy4uLy4uLy4uLy4uL3N1bi9qcy9QYW5lbC5qcyc7XHJcbmltcG9ydCBpc290b3Blc0FuZEF0b21pY01hc3MgZnJvbSAnLi4vLi4vaXNvdG9wZXNBbmRBdG9taWNNYXNzLmpzJztcclxuaW1wb3J0IElzb3RvcGVzQW5kQXRvbWljTWFzc1N0cmluZ3MgZnJvbSAnLi4vLi4vSXNvdG9wZXNBbmRBdG9taWNNYXNzU3RyaW5ncy5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgSU5ESUNBVE9SX1dJRFRIID0gMjAwO1xyXG5jb25zdCBUSUNLX01BUktfTElORV9IRUlHSFQgPSAxNTtcclxuY29uc3QgVElDS19NQVJLX0xJTkVfV0lEVEggPSA1O1xyXG5jb25zdCBTSVpFID0gbmV3IERpbWVuc2lvbjIoIDc1LCAyNSApO1xyXG5jb25zdCBUUklBTkdVTEFSX1BPSU5URVJfSEVJR0hUID0gMTU7XHJcbmNvbnN0IFRSSUFOR1VMQVJfUE9JTlRFUl9XSURUSCA9IDIwO1xyXG5jb25zdCBOVU1CRVJfREVDSU1BTFMgPSA1O1xyXG5cclxuY29uc3QgYW11U3RyaW5nID0gSXNvdG9wZXNBbmRBdG9taWNNYXNzU3RyaW5ncy5hbXU7XHJcblxyXG4vKipcclxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIHRpY2sgbWFya3MuIFRoaXMgaW5jbHVkZXMgYm90aCB0aGUgYWN0dWFsIG1hcmsgYW5kIHRoZSBsYWJlbC5cclxuICogQHBhcmFtIHtOdW1iZXJBdG9tfSBpc290b3BlQ29uZmlnXHJcbiAqL1xyXG5mdW5jdGlvbiBJc290b3BlVGlja01hcmsoIGlzb3RvcGVDb25maWcgKSB7XHJcbiAgY29uc3Qgbm9kZSA9IG5ldyBOb2RlKCk7XHJcblxyXG4gIC8vIENyZWF0ZSB0aGUgdGljayBtYXJrIGl0c2VsZi4gIEl0IGlzIHBvc2l0aW9uZWQgc3VjaCB0aGF0ICgwLDApIGlzIHRoZSBjZW50ZXIgb2YgdGhlIG1hcmsuXHJcbiAgY29uc3Qgc2hhcGUgPSBuZXcgTGluZSggMCwgLVRJQ0tfTUFSS19MSU5FX0hFSUdIVCAvIDIsIDAsIFRJQ0tfTUFSS19MSU5FX0hFSUdIVCAvIDIsIHtcclxuICAgIGxpbmVXaWR0aDogVElDS19NQVJLX0xJTkVfV0lEVEgsXHJcbiAgICBzdHJva2U6ICdibGFjaydcclxuICB9ICk7XHJcbiAgbm9kZS5hZGRDaGlsZCggc2hhcGUgKTtcclxuXHJcbiAgLy8gQ3JlYXRlIHRoZSBsYWJlbCB0aGF0IGdvZXMgYWJvdmUgdGhlIHRpY2sgbWFyay5cclxuICBjb25zdCBsYWJlbCA9IG5ldyBSaWNoVGV4dCggYCA8c3VwPiR7aXNvdG9wZUNvbmZpZy5tYXNzTnVtYmVyUHJvcGVydHkuZ2V0KCl9PC9zdXA+JHtcclxuICAgIEF0b21JZGVudGlmaWVyLmdldFN5bWJvbCggaXNvdG9wZUNvbmZpZy5wcm90b25Db3VudFByb3BlcnR5LmdldCgpICl9YCwge1xyXG4gICAgZm9udDogbmV3IFBoZXRGb250KCAxMiApXHJcbiAgfSApO1xyXG4gIGxhYmVsLmNlbnRlclggPSBzaGFwZS5jZW50ZXJYO1xyXG4gIGxhYmVsLmJvdHRvbSA9IHNoYXBlLnRvcDtcclxuICBub2RlLmFkZENoaWxkKCBsYWJlbCApO1xyXG5cclxuICByZXR1cm4gbm9kZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgY29udmVuaWVuY2UgZGVmaW5lIHRoZSBcInJlYWRvdXQgcG9pbnRlclwiLCB3aGljaCBpcyBhbiBpbmRpY2F0b3IgdGhhdCBjb250YWlucyBhIHRleHR1YWwgaW5kaWNhdGlvbiBvZiB0aGVcclxuICogYXZlcmFnZSBhdG9taWMgbWFzcyBhbmQgYWxzbyBoYXMgYSBwb2ludGVyIG9uIHRoZSB0b3AgdGhhdCBjYW4gYmUgdXNlZCB0byBpbmRpY2F0ZSB0aGUgcG9zaXRpb24gb24gYSBsaW5lYXIgc2NhbGUuXHJcbiAqIFRoaXMgbm9kZSBpcyBzZXQgdXAgc3VjaCB0aGF0IHRoZSAoMCwwKSBwb2ludCBpcyBhdCB0aGUgdG9wIGNlbnRlciBvZiB0aGUgbm9kZSwgd2hpY2ggaXMgd2hlcmUgdGhlIHBvaW50IG9mIHRoZVxyXG4gKiBwb2ludGVyIGV4aXN0cy4gVGhpcyBpcyBkb25lIHRvIG1ha2UgaXQgZWFzeSB0byBwb3NpdGlvbiB0aGUgbm9kZSB1bmRlciB0aGUgbWFzcyBpbmRpY2F0aW9uIGxpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TWl4SXNvdG9wZU1vZGVsfSBtb2RlbFxyXG4gKi9cclxuZnVuY3Rpb24gUmVhZG91dFBvaW50ZXIoIG1vZGVsICkge1xyXG4gIGNvbnN0IG5vZGUgPSBuZXcgTm9kZSgpO1xyXG5cclxuICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgLy8gQWRkIHRoZSB0cmlhbmd1bGFyIHBvaW50ZXIuIFRoaXMgaXMgY3JlYXRlZCBzdWNoIHRoYXQgdGhlIHBvaW50IG9mIHRoZSB0cmlhbmdsZSBpcyBhdCAoMCwwKSBmb3IgdGhpcyBub2RlLlxyXG5cclxuICBjb25zdCB2ZXJ0aWNlcyA9IFsgbmV3IFZlY3RvcjIoIC1UUklBTkdVTEFSX1BPSU5URVJfV0lEVEggLyAyLCBUUklBTkdVTEFSX1BPSU5URVJfSEVJR0hUICksXHJcbiAgICBuZXcgVmVjdG9yMiggVFJJQU5HVUxBUl9QT0lOVEVSX1dJRFRIIC8gMiwgVFJJQU5HVUxBUl9QT0lOVEVSX0hFSUdIVCApLFxyXG4gICAgbmV3IFZlY3RvcjIoIDAsIDAgKVxyXG4gIF07XHJcblxyXG4gIGNvbnN0IHRyaWFuZ2xlID0gbmV3IFBhdGgoIFNoYXBlLnBvbHlnb24oIHZlcnRpY2VzICksIHtcclxuICAgIGZpbGw6IG5ldyBDb2xvciggMCwgMTQzLCAyMTIgKSxcclxuICAgIGxpbmVXaWR0aDogMVxyXG4gIH0gKTtcclxuICBub2RlLmFkZENoaWxkKCB0cmlhbmdsZSApO1xyXG5cclxuICBjb25zdCByZWFkb3V0VGV4dCA9IG5ldyBUZXh0KCAnJywge1xyXG4gICAgZm9udDogbmV3IFBoZXRGb250KCAxNCApLFxyXG4gICAgbWF4V2lkdGg6IDAuOSAqIFNJWkUud2lkdGgsXHJcbiAgICBtYXhIZWlnaHQ6IDAuOSAqIFNJWkUuaGVpZ2h0XHJcbiAgfSApO1xyXG5cclxuICBjb25zdCByZWFkb3V0UGFuZWwgPSBuZXcgUGFuZWwoIHJlYWRvdXRUZXh0LCB7XHJcbiAgICBtaW5XaWR0aDogU0laRS53aWR0aCxcclxuICAgIG1pbkhlaWdodDogU0laRS5oZWlnaHQsXHJcbiAgICByZXNpemU6IGZhbHNlLFxyXG4gICAgY29ybmVyUmFkaXVzOiAyLFxyXG4gICAgbGluZVdpZHRoOiAxLFxyXG4gICAgYWxpZ246ICdjZW50ZXInLFxyXG4gICAgZmlsbDogJ3doaXRlJ1xyXG4gIH0gKTtcclxuXHJcbiAgcmVhZG91dFBhbmVsLnRvcCA9IHRyaWFuZ2xlLmJvdHRvbTtcclxuICByZWFkb3V0UGFuZWwuY2VudGVyWCA9IHRyaWFuZ2xlLmNlbnRlclg7XHJcbiAgbm9kZS5hZGRDaGlsZCggcmVhZG91dFBhbmVsICk7XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZVJlYWRvdXQoIGF2ZXJhZ2VBdG9taWNNYXNzICkge1xyXG4gICAgbGV0IHdlaWdodDtcclxuICAgIGlmICggbW9kZWwuc2hvd2luZ05hdHVyZXNNaXhQcm9wZXJ0eS5nZXQoKSApIHtcclxuICAgICAgd2VpZ2h0ID0gQXRvbUlkZW50aWZpZXIuZ2V0U3RhbmRhcmRBdG9taWNNYXNzKCBtb2RlbC5zZWxlY3RlZEF0b21Db25maWcucHJvdG9uQ291bnQgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICB3ZWlnaHQgPSBhdmVyYWdlQXRvbWljTWFzcztcclxuICAgIH1cclxuICAgIHJlYWRvdXRUZXh0LnNldFN0cmluZyggYCR7VXRpbHMudG9GaXhlZCggd2VpZ2h0LCBOVU1CRVJfREVDSU1BTFMgKX0gJHthbXVTdHJpbmd9YCApO1xyXG4gICAgcmVhZG91dFRleHQuY2VudGVyWCA9IFNJWkUud2lkdGggLyAyO1xyXG4gIH1cclxuXHJcbiAgLy8gT2JzZXJ2ZSB0aGUgYXZlcmFnZSBhdG9taWMgd2VpZ2h0IHByb3BlcnR5IGluIHRoZSBtb2RlbCBhbmQgdXBkYXRlIHRoZSB0ZXh0dWFsIHJlYWRvdXQgd2hlbmV2ZXIgaXQgY2hhbmdlcy5cclxuICAvLyBEb2Vzbid0IG5lZWQgdW5saW5rIGFzIGl0IHN0YXlzIHRocm91Z2ggb3V0IHRoZSBzaW0gbGlmZVxyXG4gIG1vZGVsLnRlc3RDaGFtYmVyLmF2ZXJhZ2VBdG9taWNNYXNzUHJvcGVydHkubGluayggYXZlcmFnZUF0b21pY01hc3MgPT4ge1xyXG4gICAgdXBkYXRlUmVhZG91dCggYXZlcmFnZUF0b21pY01hc3MgKTtcclxuICB9ICk7XHJcblxyXG4gIHJldHVybiBub2RlO1xyXG59XHJcblxyXG5jbGFzcyBBdmVyYWdlQXRvbWljTWFzc0luZGljYXRvciBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge01peElzb3RvcGVzTW9kZWx9IG1vZGVsXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIG1vZGVsICkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvLyBSb290IG5vZGUgb250byB3aGljaCBhbGwgb3RoZXIgbm9kZXMgYXJlIGFkZGVkLiAgVGhpcyBpcyBkb25lIHNvIHRoYXQgdGhlIHJvb3Qgbm9kZSBjYW4gYmUgb2Zmc2V0IGF0IHRoZSBlbmQgb2ZcclxuICAgIC8vIGNvbnN0cnVjdGlvbiBpbiBzdWNoIGEgd2F5IHRoYXQgdGhlICgwLDApIHBvc2l0aW9uIHdpbGwgYmUgaW4gdGhlIHVwcGVyIGxlZnQgY29ybmVyLlxyXG5cclxuICAgIC8vIEFkZCB0aGUgYmFyIHRoYXQgbWFrZXMgdXAgXCJzcGluZVwiIG9mIHRoZSBpbmRpY2F0b3IuXHJcbiAgICBjb25zdCBiYXJOb2RlID0gbmV3IExpbmUoIDAsIDAsIElORElDQVRPUl9XSURUSCwgMCwge1xyXG4gICAgICBsaW5lV2lkdGg6IDMsXHJcbiAgICAgIHN0cm9rZTogJ2JsYWNrJ1xyXG4gICAgfSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggYmFyTm9kZSApO1xyXG5cclxuICAgIC8vIEFkZCB0aGUgbGF5ZXIgd2hlcmUgdGhlIHRpY2sgbWFya3Mgd2lsbCBiZSBtYWludGFpbmVkLlxyXG4gICAgY29uc3QgdGlja01hcmtMYXllciA9IG5ldyBOb2RlKCk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCB0aWNrTWFya0xheWVyICk7XHJcblxyXG4gICAgLy8gTGlzdGVuIGZvciBjaGFuZ2VzIHRvIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGlzb3RvcGVzIGFuZCB1cGRhdGUgdGhlIHRpY2sgbWFya3Mgd2hlbiBjaGFuZ2VzIG9jY3VyLlxyXG4gICAgLy8gRG9lc24ndCBuZWVkIHVubGluayBhcyBpdCBzdGF5cyB0aHJvdWdoIG91dCB0aGUgc2ltIGxpZmVcclxuICAgIG1vZGVsLnBvc3NpYmxlSXNvdG9wZXNQcm9wZXJ0eS5saW5rKCAoKSA9PiB7XHJcblxyXG4gICAgICB0aWNrTWFya0xheWVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XHJcbiAgICAgIGNvbnN0IHBvc3NpYmxlSXNvdG9wZXNMaXN0ID0gbW9kZWwucG9zc2libGVJc290b3Blc1Byb3BlcnR5LmdldCgpO1xyXG4gICAgICBsZXQgbGlnaHRlc3RJc290b3BlTWFzcyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgbGV0IGhlYXZpZXN0SXNvdG9wZU1hc3MgPSAwO1xyXG4gICAgICB0aGlzLm1pbk1hc3MgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgIHBvc3NpYmxlSXNvdG9wZXNMaXN0LmZvckVhY2goIGlzb3RvcGUgPT4ge1xyXG4gICAgICAgIGlmICggaXNvdG9wZS5nZXRJc290b3BlQXRvbWljTWFzcygpID4gaGVhdmllc3RJc290b3BlTWFzcyApIHtcclxuICAgICAgICAgIGhlYXZpZXN0SXNvdG9wZU1hc3MgPSBpc290b3BlLmdldElzb3RvcGVBdG9taWNNYXNzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggaXNvdG9wZS5nZXRJc290b3BlQXRvbWljTWFzcygpIDwgbGlnaHRlc3RJc290b3BlTWFzcyApIHtcclxuICAgICAgICAgIGxpZ2h0ZXN0SXNvdG9wZU1hc3MgPSBpc290b3BlLmdldElzb3RvcGVBdG9taWNNYXNzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICB0aGlzLm1hc3NTcGFuID0gaGVhdmllc3RJc290b3BlTWFzcyAtIGxpZ2h0ZXN0SXNvdG9wZU1hc3M7XHJcbiAgICAgIGlmICggdGhpcy5tYXNzU3BhbiA8IDIgKSB7XHJcbiAgICAgICAgdGhpcy5tYXNzU3BhbiA9IDI7IC8vIE1hc3Mgc3BhIG4gbXVzdCBiZSBhdCBsZWFzdCAyIG9yIHRoZSBzcGFjaW5nIGRvZXNuJ3QgbG9vayBnb29kLlxyXG4gICAgICB9XHJcbiAgICAgIC8vIEFkanVzdCB0aGUgc3BhbiBzbyB0aGF0IHRoZXJlIGlzIHNvbWUgc3BhY2UgYXQgdGhlIGVuZHMgb2YgdGhlIGxpbmUuXHJcbiAgICAgIHRoaXMubWFzc1NwYW4gKj0gMS4yO1xyXG4gICAgICAvLyBTZXQgdGhlIGxvdyBlbmQgb2YgdGhlIG1hc3MgcmFuZ2UsIG5lZWRlZCBmb3IgcG9zaXRpb25pbmcgb24gbGluZS5cclxuICAgICAgdGhpcy5taW5NYXNzID0gKCBoZWF2aWVzdElzb3RvcGVNYXNzICsgbGlnaHRlc3RJc290b3BlTWFzcyApIC8gMiAtIHRoaXMubWFzc1NwYW4gLyAyO1xyXG5cclxuICAgICAgLy8gQWRkIHRoZSBuZXcgdGljayBtYXJrcy5cclxuICAgICAgbW9kZWwucG9zc2libGVJc290b3Blc1Byb3BlcnR5LmdldCgpLmZvckVhY2goIGlzb3RvcGUgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRpY2tNYXJrID0gbmV3IElzb3RvcGVUaWNrTWFyayggaXNvdG9wZSApO1xyXG4gICAgICAgIHRpY2tNYXJrLmNlbnRlclggPSB0aGlzLmNhbGNYT2Zmc2V0RnJvbUF0b21pY01hc3MoIGlzb3RvcGUuZ2V0SXNvdG9wZUF0b21pY01hc3MoKSApO1xyXG4gICAgICAgIHRpY2tNYXJrTGF5ZXIuYWRkQ2hpbGQoIHRpY2tNYXJrICk7XHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gQWRkIHRoZSBtb3ZpbmcgcmVhZG91dC5cclxuICAgIGNvbnN0IHJlYWRvdXRQb2ludGVyID0gbmV3IFJlYWRvdXRQb2ludGVyKCBtb2RlbCApO1xyXG4gICAgcmVhZG91dFBvaW50ZXIudG9wID0gYmFyTm9kZS5ib3R0b207XHJcbiAgICByZWFkb3V0UG9pbnRlci5jZW50ZXJYID0gYmFyTm9kZS5jZW50ZXJYO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggcmVhZG91dFBvaW50ZXIgKTtcclxuXHJcbiAgICAvLyBEb2Vzbid0IG5lZWQgdW5saW5rIGFzIGl0IHN0YXlzIHRocm91Z2ggb3V0IHRoZSBzaW0gbGlmZVxyXG4gICAgbW9kZWwudGVzdENoYW1iZXIuYXZlcmFnZUF0b21pY01hc3NQcm9wZXJ0eS5saW5rKCBhdmVyYWdlQXRvbWljTWFzcyA9PiB7XHJcbiAgICAgIGlmICggbW9kZWwudGVzdENoYW1iZXIuaXNvdG9wZUNvdW50UHJvcGVydHkuZ2V0KCkgPiAwICkge1xyXG4gICAgICAgIHJlYWRvdXRQb2ludGVyLmNlbnRlclggPSB0aGlzLmNhbGNYT2Zmc2V0RnJvbUF0b21pY01hc3MoIGF2ZXJhZ2VBdG9taWNNYXNzICk7XHJcbiAgICAgICAgcmVhZG91dFBvaW50ZXIuc2V0VmlzaWJsZSggdHJ1ZSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJlYWRvdXRQb2ludGVyLnNldFZpc2libGUoIGZhbHNlICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgWCBvZmZzZXQgb24gdGhlIGJhciBnaXZlbiB0aGUgYXRvbWljIG1hc3MuIFRoaXMgaXMgY2xhbXBlZCB0byBuZXZlciByZXR1cm4gYSB2YWx1ZSBsZXNzIHRoYW4gMC5cclxuICAgKiBAcGFyYW0ge2RvdWJsZX0gYXRvbWljTWFzc1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBjYWxjWE9mZnNldEZyb21BdG9taWNNYXNzKCBhdG9taWNNYXNzICkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KCAoIGF0b21pY01hc3MgLSB0aGlzLm1pbk1hc3MgKSAvIHRoaXMubWFzc1NwYW4gKiBJTkRJQ0FUT1JfV0lEVEgsIDAgKTtcclxuICB9XHJcbn1cclxuXHJcbmlzb3RvcGVzQW5kQXRvbWljTWFzcy5yZWdpc3RlciggJ0F2ZXJhZ2VBdG9taWNNYXNzSW5kaWNhdG9yJywgQXZlcmFnZUF0b21pY01hc3NJbmRpY2F0b3IgKTtcclxuZXhwb3J0IGRlZmF1bHQgQXZlcmFnZUF0b21pY01hc3NJbmRpY2F0b3I7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxVQUFVLE1BQU0sa0NBQWtDO0FBQ3pELE9BQU9DLEtBQUssTUFBTSw2QkFBNkI7QUFDL0MsT0FBT0MsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxTQUFTQyxLQUFLLFFBQVEsZ0NBQWdDO0FBQ3RELE9BQU9DLFFBQVEsTUFBTSx5Q0FBeUM7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