// Copyright 2013-2022, University of Colorado Boulder

/**
 * A simple molecule configuration that doesn't discriminate between bond or atom types (only lone pairs vs bonds).
 *
 * Note that we use X and E for the radial atom and radial lone pair count (respectively) due to its usage in chemistry,
 * with the "AXE method" (see http://en.wikipedia.org/wiki/VSEPR_theory)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import Permutation from '../../../../dot/js/Permutation.js';
import moleculeShapes from '../../moleculeShapes.js';
import AttractorModel from './AttractorModel.js';
import ElectronGeometry from './ElectronGeometry.js';
import LocalShape from './LocalShape.js';
import MoleculeGeometry from './MoleculeGeometry.js';

// for looking up VSEPRConfiguration instances
const configurationMap = {}; // x+','+e => {VSEPRConfiguration}

class VSEPRConfiguration {
  /*
   * @param {number} x - Number of radial atoms connected to the central atom
   * @param {number} e - Number of radial lone pairs connected to the central atom
   */
  constructor(x, e) {
    this.x = x; // @public {number} - Number of radial atoms connected to the central atom
    this.e = e; // @public {number} - Number of radial lone pairs connected to the central atom

    // @public {MoleculeGeometry}
    this.moleculeGeometry = MoleculeGeometry.getConfiguration(x, e);

    // @public {ElectronGeometry}
    this.electronGeometry = ElectronGeometry.getConfiguration(x + e);
    this.bondOrientations = []; // @public {Array.<Vector3>}
    this.lonePairOrientations = []; // @public {Array.<Vector3>}
    this.allOrientations = this.electronGeometry.unitVectors; // @public {Array.<Vector3>}

    for (let i = 0; i < x + e; i++) {
      if (i < e) {
        // fill up the lone pair unit vectors first
        this.lonePairOrientations.push(this.electronGeometry.unitVectors[i]);
      } else {
        this.bondOrientations.push(this.electronGeometry.unitVectors[i]);
      }
    }
  }

  /**
   * For finding ideal rotations including matching for 'bond-vs-bond' and 'lone pair-vs-lone pair'.
   * @public
   *
   * @param {Array.<PairGroup>} groups
   * @returns {AttractorModel.ResultMapping}
   */
  getIdealGroupRotationToPositions(groups) {
    assert && assert(this.x + this.e === groups.length);

    // done currently only when the molecule is rebuilt, so we don't try to pass a lastPermutation in (not helpful)
    return AttractorModel.findClosestMatchingConfiguration(AttractorModel.getOrientationsFromOrigin(groups), this.electronGeometry.unitVectors, LocalShape.vseprPermutations(groups));
  }

  /**
   * For finding ideal rotations exclusively using the 'bonded' portions.
   * @public
   *
   * @param {Array.<PairGroup>} groups
   * @returns {AttractorModel.ResultMapping}
   */
  getIdealBondRotationToPositions(groups) {
    // ideal vectors excluding lone pairs (just for the bonds)
    assert && assert(this.x === groups.length);

    // currently only called when a real molecule is built, so we don't try to pass a lastPermutation in (not helpful)
    return AttractorModel.findClosestMatchingConfiguration(AttractorModel.getOrientationsFromOrigin(groups), this.bondOrientations, Permutation.permutations(this.bondOrientations.length));
  }

  /*
   * Returns cached VSEPRConfigurations based on radial atom/lone-pair counts.
   * @public
   *
   * @param {number} x - Number of radial atoms connected to the central atom
   * @param {number} e - Number of radial lone pairs connected to the central atom
   * @returns {VSEPRConfiguration} - Cached configuration
   */
  static getConfiguration(x, e) {
    const key = `${x},${e}`;
    if (key in configurationMap) {
      return configurationMap[key];
    } else {
      const configuration = new VSEPRConfiguration(x, e);
      configurationMap[key] = configuration;
      return configuration;
    }
  }
}
moleculeShapes.register('VSEPRConfiguration', VSEPRConfiguration);
export default VSEPRConfiguration;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQZXJtdXRhdGlvbiIsIm1vbGVjdWxlU2hhcGVzIiwiQXR0cmFjdG9yTW9kZWwiLCJFbGVjdHJvbkdlb21ldHJ5IiwiTG9jYWxTaGFwZSIsIk1vbGVjdWxlR2VvbWV0cnkiLCJjb25maWd1cmF0aW9uTWFwIiwiVlNFUFJDb25maWd1cmF0aW9uIiwiY29uc3RydWN0b3IiLCJ4IiwiZSIsIm1vbGVjdWxlR2VvbWV0cnkiLCJnZXRDb25maWd1cmF0aW9uIiwiZWxlY3Ryb25HZW9tZXRyeSIsImJvbmRPcmllbnRhdGlvbnMiLCJsb25lUGFpck9yaWVudGF0aW9ucyIsImFsbE9yaWVudGF0aW9ucyIsInVuaXRWZWN0b3JzIiwiaSIsInB1c2giLCJnZXRJZGVhbEdyb3VwUm90YXRpb25Ub1Bvc2l0aW9ucyIsImdyb3VwcyIsImFzc2VydCIsImxlbmd0aCIsImZpbmRDbG9zZXN0TWF0Y2hpbmdDb25maWd1cmF0aW9uIiwiZ2V0T3JpZW50YXRpb25zRnJvbU9yaWdpbiIsInZzZXByUGVybXV0YXRpb25zIiwiZ2V0SWRlYWxCb25kUm90YXRpb25Ub1Bvc2l0aW9ucyIsInBlcm11dGF0aW9ucyIsImtleSIsImNvbmZpZ3VyYXRpb24iLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlZTRVBSQ29uZmlndXJhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMy0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBBIHNpbXBsZSBtb2xlY3VsZSBjb25maWd1cmF0aW9uIHRoYXQgZG9lc24ndCBkaXNjcmltaW5hdGUgYmV0d2VlbiBib25kIG9yIGF0b20gdHlwZXMgKG9ubHkgbG9uZSBwYWlycyB2cyBib25kcykuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB3ZSB1c2UgWCBhbmQgRSBmb3IgdGhlIHJhZGlhbCBhdG9tIGFuZCByYWRpYWwgbG9uZSBwYWlyIGNvdW50IChyZXNwZWN0aXZlbHkpIGR1ZSB0byBpdHMgdXNhZ2UgaW4gY2hlbWlzdHJ5LFxyXG4gKiB3aXRoIHRoZSBcIkFYRSBtZXRob2RcIiAoc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVlNFUFJfdGhlb3J5KVxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XHJcbiAqL1xyXG5cclxuaW1wb3J0IFBlcm11dGF0aW9uIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9QZXJtdXRhdGlvbi5qcyc7XHJcbmltcG9ydCBtb2xlY3VsZVNoYXBlcyBmcm9tICcuLi8uLi9tb2xlY3VsZVNoYXBlcy5qcyc7XHJcbmltcG9ydCBBdHRyYWN0b3JNb2RlbCBmcm9tICcuL0F0dHJhY3Rvck1vZGVsLmpzJztcclxuaW1wb3J0IEVsZWN0cm9uR2VvbWV0cnkgZnJvbSAnLi9FbGVjdHJvbkdlb21ldHJ5LmpzJztcclxuaW1wb3J0IExvY2FsU2hhcGUgZnJvbSAnLi9Mb2NhbFNoYXBlLmpzJztcclxuaW1wb3J0IE1vbGVjdWxlR2VvbWV0cnkgZnJvbSAnLi9Nb2xlY3VsZUdlb21ldHJ5LmpzJztcclxuXHJcbi8vIGZvciBsb29raW5nIHVwIFZTRVBSQ29uZmlndXJhdGlvbiBpbnN0YW5jZXNcclxuY29uc3QgY29uZmlndXJhdGlvbk1hcCA9IHt9OyAvLyB4KycsJytlID0+IHtWU0VQUkNvbmZpZ3VyYXRpb259XHJcblxyXG5jbGFzcyBWU0VQUkNvbmZpZ3VyYXRpb24ge1xyXG4gIC8qXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBOdW1iZXIgb2YgcmFkaWFsIGF0b21zIGNvbm5lY3RlZCB0byB0aGUgY2VudHJhbCBhdG9tXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGUgLSBOdW1iZXIgb2YgcmFkaWFsIGxvbmUgcGFpcnMgY29ubmVjdGVkIHRvIHRoZSBjZW50cmFsIGF0b21cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggeCwgZSApIHtcclxuICAgIHRoaXMueCA9IHg7IC8vIEBwdWJsaWMge251bWJlcn0gLSBOdW1iZXIgb2YgcmFkaWFsIGF0b21zIGNvbm5lY3RlZCB0byB0aGUgY2VudHJhbCBhdG9tXHJcbiAgICB0aGlzLmUgPSBlOyAvLyBAcHVibGljIHtudW1iZXJ9IC0gTnVtYmVyIG9mIHJhZGlhbCBsb25lIHBhaXJzIGNvbm5lY3RlZCB0byB0aGUgY2VudHJhbCBhdG9tXHJcblxyXG4gICAgLy8gQHB1YmxpYyB7TW9sZWN1bGVHZW9tZXRyeX1cclxuICAgIHRoaXMubW9sZWN1bGVHZW9tZXRyeSA9IE1vbGVjdWxlR2VvbWV0cnkuZ2V0Q29uZmlndXJhdGlvbiggeCwgZSApO1xyXG5cclxuICAgIC8vIEBwdWJsaWMge0VsZWN0cm9uR2VvbWV0cnl9XHJcbiAgICB0aGlzLmVsZWN0cm9uR2VvbWV0cnkgPSBFbGVjdHJvbkdlb21ldHJ5LmdldENvbmZpZ3VyYXRpb24oIHggKyBlICk7XHJcblxyXG4gICAgdGhpcy5ib25kT3JpZW50YXRpb25zID0gW107IC8vIEBwdWJsaWMge0FycmF5LjxWZWN0b3IzPn1cclxuICAgIHRoaXMubG9uZVBhaXJPcmllbnRhdGlvbnMgPSBbXTsgLy8gQHB1YmxpYyB7QXJyYXkuPFZlY3RvcjM+fVxyXG4gICAgdGhpcy5hbGxPcmllbnRhdGlvbnMgPSB0aGlzLmVsZWN0cm9uR2VvbWV0cnkudW5pdFZlY3RvcnM7IC8vIEBwdWJsaWMge0FycmF5LjxWZWN0b3IzPn1cclxuXHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCB4ICsgZTsgaSsrICkge1xyXG4gICAgICBpZiAoIGkgPCBlICkge1xyXG4gICAgICAgIC8vIGZpbGwgdXAgdGhlIGxvbmUgcGFpciB1bml0IHZlY3RvcnMgZmlyc3RcclxuICAgICAgICB0aGlzLmxvbmVQYWlyT3JpZW50YXRpb25zLnB1c2goIHRoaXMuZWxlY3Ryb25HZW9tZXRyeS51bml0VmVjdG9yc1sgaSBdICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5ib25kT3JpZW50YXRpb25zLnB1c2goIHRoaXMuZWxlY3Ryb25HZW9tZXRyeS51bml0VmVjdG9yc1sgaSBdICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvciBmaW5kaW5nIGlkZWFsIHJvdGF0aW9ucyBpbmNsdWRpbmcgbWF0Y2hpbmcgZm9yICdib25kLXZzLWJvbmQnIGFuZCAnbG9uZSBwYWlyLXZzLWxvbmUgcGFpcicuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48UGFpckdyb3VwPn0gZ3JvdXBzXHJcbiAgICogQHJldHVybnMge0F0dHJhY3Rvck1vZGVsLlJlc3VsdE1hcHBpbmd9XHJcbiAgICovXHJcbiAgZ2V0SWRlYWxHcm91cFJvdGF0aW9uVG9Qb3NpdGlvbnMoIGdyb3VwcyApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICggdGhpcy54ICsgdGhpcy5lICkgPT09IGdyb3Vwcy5sZW5ndGggKTtcclxuXHJcbiAgICAvLyBkb25lIGN1cnJlbnRseSBvbmx5IHdoZW4gdGhlIG1vbGVjdWxlIGlzIHJlYnVpbHQsIHNvIHdlIGRvbid0IHRyeSB0byBwYXNzIGEgbGFzdFBlcm11dGF0aW9uIGluIChub3QgaGVscGZ1bClcclxuICAgIHJldHVybiBBdHRyYWN0b3JNb2RlbC5maW5kQ2xvc2VzdE1hdGNoaW5nQ29uZmlndXJhdGlvbiggQXR0cmFjdG9yTW9kZWwuZ2V0T3JpZW50YXRpb25zRnJvbU9yaWdpbiggZ3JvdXBzICksXHJcbiAgICAgIHRoaXMuZWxlY3Ryb25HZW9tZXRyeS51bml0VmVjdG9ycyxcclxuICAgICAgTG9jYWxTaGFwZS52c2VwclBlcm11dGF0aW9ucyggZ3JvdXBzICkgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvciBmaW5kaW5nIGlkZWFsIHJvdGF0aW9ucyBleGNsdXNpdmVseSB1c2luZyB0aGUgJ2JvbmRlZCcgcG9ydGlvbnMuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48UGFpckdyb3VwPn0gZ3JvdXBzXHJcbiAgICogQHJldHVybnMge0F0dHJhY3Rvck1vZGVsLlJlc3VsdE1hcHBpbmd9XHJcbiAgICovXHJcbiAgZ2V0SWRlYWxCb25kUm90YXRpb25Ub1Bvc2l0aW9ucyggZ3JvdXBzICkge1xyXG4gICAgLy8gaWRlYWwgdmVjdG9ycyBleGNsdWRpbmcgbG9uZSBwYWlycyAoanVzdCBmb3IgdGhlIGJvbmRzKVxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggKCB0aGlzLnggKSA9PT0gZ3JvdXBzLmxlbmd0aCApO1xyXG5cclxuICAgIC8vIGN1cnJlbnRseSBvbmx5IGNhbGxlZCB3aGVuIGEgcmVhbCBtb2xlY3VsZSBpcyBidWlsdCwgc28gd2UgZG9uJ3QgdHJ5IHRvIHBhc3MgYSBsYXN0UGVybXV0YXRpb24gaW4gKG5vdCBoZWxwZnVsKVxyXG4gICAgcmV0dXJuIEF0dHJhY3Rvck1vZGVsLmZpbmRDbG9zZXN0TWF0Y2hpbmdDb25maWd1cmF0aW9uKCBBdHRyYWN0b3JNb2RlbC5nZXRPcmllbnRhdGlvbnNGcm9tT3JpZ2luKCBncm91cHMgKSxcclxuICAgICAgdGhpcy5ib25kT3JpZW50YXRpb25zLFxyXG4gICAgICBQZXJtdXRhdGlvbi5wZXJtdXRhdGlvbnMoIHRoaXMuYm9uZE9yaWVudGF0aW9ucy5sZW5ndGggKSApO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm5zIGNhY2hlZCBWU0VQUkNvbmZpZ3VyYXRpb25zIGJhc2VkIG9uIHJhZGlhbCBhdG9tL2xvbmUtcGFpciBjb3VudHMuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBOdW1iZXIgb2YgcmFkaWFsIGF0b21zIGNvbm5lY3RlZCB0byB0aGUgY2VudHJhbCBhdG9tXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGUgLSBOdW1iZXIgb2YgcmFkaWFsIGxvbmUgcGFpcnMgY29ubmVjdGVkIHRvIHRoZSBjZW50cmFsIGF0b21cclxuICAgKiBAcmV0dXJucyB7VlNFUFJDb25maWd1cmF0aW9ufSAtIENhY2hlZCBjb25maWd1cmF0aW9uXHJcbiAgICovXHJcbiAgc3RhdGljIGdldENvbmZpZ3VyYXRpb24oIHgsIGUgKSB7XHJcbiAgICBjb25zdCBrZXkgPSBgJHt4fSwke2V9YDtcclxuICAgIGlmICgga2V5IGluIGNvbmZpZ3VyYXRpb25NYXAgKSB7XHJcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uTWFwWyBrZXkgXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gbmV3IFZTRVBSQ29uZmlndXJhdGlvbiggeCwgZSApO1xyXG4gICAgICBjb25maWd1cmF0aW9uTWFwWyBrZXkgXSA9IGNvbmZpZ3VyYXRpb247XHJcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9sZWN1bGVTaGFwZXMucmVnaXN0ZXIoICdWU0VQUkNvbmZpZ3VyYXRpb24nLCBWU0VQUkNvbmZpZ3VyYXRpb24gKTtcclxuZXhwb3J0IGRlZmF1bHQgVlNFUFJDb25maWd1cmF0aW9uOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxXQUFXLE1BQU0sbUNBQW1DO0FBQzNELE9BQU9DLGNBQWMsTUFBTSx5QkFBeUI7QUFDcEQsT0FBT0MsY0FBYyxNQUFNLHFCQUFxQjtBQUNoRCxPQUFPQyxnQkFBZ0IsTUFBTSx1QkFBdUI7QUFDcEQsT0FBT0MsVUFBVSxNQUFNLGlCQUFpQjtBQUN4QyxPQUFPQyxnQkFBZ0IsTUFBTSx1QkFBdUI7O0FBRXBEO0FBQ0EsTUFBTUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFN0IsTUFBTUMsa0JBQWtCLENBQUM7RUFDdkI7QUFDRjtBQUNBO0FBQ0E7RUFDRUMsV0FBV0EsQ0FBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUc7SUFDbEIsSUFBSSxD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