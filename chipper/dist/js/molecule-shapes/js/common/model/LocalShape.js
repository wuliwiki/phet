// Copyright 2013-2022, University of Colorado Boulder

/**
 * The ideal local shape for a certain central atom and its (local) neighbors.
 *
 * Also contains the ability to push the local atoms into place, along with many helper functions
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import Permutation from '../../../../dot/js/Permutation.js';
import partition from '../../../../phet-core/js/partition.js';
import moleculeShapes from '../../moleculeShapes.js';
import AttractorModel from './AttractorModel.js';
class LocalShape {
  /*
   * @param {Array.<Permutation>} allowedPermutations
   * @param {PairGroup} centralAtom
   * @param {Array.<PairGroup>} groups
   * @param {Array.<Vector3>} idealOrientations
   */
  constructor(allowedPermutations, centralAtom, groups, idealOrientations) {
    // @public {Array.<Permutation>} - Denotes how we can map the groups into the orientation vectors.
    // Some combinations may not be possible.
    this.allowedPermutations = allowedPermutations;

    // @public {PairGroup} - All of our pair groups should be connected to this atom.
    this.centralAtom = centralAtom;

    // @public {Array.<PairGroup>}
    this.groups = groups;

    // @public {Array.<Vector3>} - The ideal orientations (unit vectors) for the groups representing the
    // ideal local shape.
    this.idealOrientations = idealOrientations;
  }

  /**
   * Attracts the atoms to their ideal shape, and returns the current approximate "error" that they have at this state.
   * @public
   *
   * Attraction done by adding in velocity.
   *
   * @param {number} dt - Amount of time elapsed.
   * @returns {number} Amount of error (least squares-style)
   */
  applyAttraction(dt) {
    return AttractorModel.applyAttractorForces(this.groups, dt, this.idealOrientations, this.allowedPermutations, this.centralAtom.positionProperty.value, false).error;
  }

  /**
   * Forces pair-groups with similar angles away from each other.
   * @public
   *
   * @param {number} dt - Amount of time elapsed
   * @param {Permutation} [lastPermutation]
   * @returns {ResultMapping}
   */
  applyAngleAttractionRepulsion(dt, lastPermutation) {
    return AttractorModel.applyAttractorForces(this.groups, dt, this.idealOrientations, this.allowedPermutations, this.centralAtom.positionProperty.value, true, lastPermutation).mapping;
  }

  /**
   * Given a list of permutations, return all permutations that exist with the specified indices permuted in all different ways.
   * @private
   *
   * IE, if given the list of the single permutation (12), and specified indices {3,4,5}, the permutations returned will be
   * (12)(34),(12)(35),(12)(45),(12)(453),(12)(534),(12)
   */
  static permuteListWithIndices(permutations, indices) {
    if (indices.length < 2) {
      // no changes if we can't move more than 1 element (need somewhere to put it)
      return permutations;
    }
    const result = [];
    for (let i = 0; i < permutations.length; i++) {
      const permutation = permutations[i];
      const resultsToAdd = permutation.withIndicesPermuted(indices);
      for (let j = 0; j < resultsToAdd.length; j++) {
        result.push(resultsToAdd[j]);
      }
    }
    return result;
  }

  /**
   * Allow switching of lone pairs with each other, and all other types of bonds with each other.
   * @public
   *
   * NOTE: I recommended double or triple bonds being put in "higher repulsion" spots over single bonds,
   * but this was specifically rejected. -JO.
   *
   * @param {Array.<PairGroup>} neighbors
   * @param {Array.<Permutation>} permutations
   */
  static vseprPermutations(neighbors) {
    let permutations = [];
    permutations.push(Permutation.identity(neighbors.length));
    const indexOf = group => neighbors.indexOf(group);

    // partition the neighbors into lone pairs and atoms.
    const partitioned = partition(neighbors, group => group.isLonePair);
    // this separation looks better in languages where you say "(lonePairs, atoms) = partition(...)"
    const lonePairs = partitioned[0];
    const atoms = partitioned[1];

    // permute away the lone pairs
    permutations = LocalShape.permuteListWithIndices(permutations, _.map(lonePairs, indexOf));

    // permute away the bonded groups
    permutations = LocalShape.permuteListWithIndices(permutations, _.map(atoms, indexOf));
    return permutations;
  }

  /**
   * Allow switching of lone pairs with each other, and all other types of bonds with the same type of element.
   * @public
   *
   * @param {Array.<PairGroup>} neighbors
   * @param {Array.<Permutation>} permutations
   */
  static realPermutations(neighbors) {
    let permutations = [];
    permutations.push(Permutation.identity(neighbors.length));
    const indexOf = group => neighbors.indexOf(group);

    // allow interchanging of lone pairs
    const lonePairs = _.filter(neighbors, group => group.isLonePair);
    permutations = LocalShape.permuteListWithIndices(permutations, _.map(lonePairs, indexOf));

    // allow interchanging of pair groups when they have the same chemical element
    const atoms = _.filter(neighbors, group => !group.isLonePair);
    const usedElements = _.uniq(_.map(atoms, group => group.element));
    for (let i = 0; i < usedElements.length; i++) {
      const element = usedElements[i];

      // since the closure is being executed at this point, the warning in this line can be ignored
      const atomsWithElement = _.filter(atoms, group => group.element === element);
      permutations = LocalShape.permuteListWithIndices(permutations, _.map(atomsWithElement, indexOf));
    }
    return permutations;
  }
}
moleculeShapes.register('LocalShape', LocalShape);
export default LocalShape;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQZXJtdXRhdGlvbiIsInBhcnRpdGlvbiIsIm1vbGVjdWxlU2hhcGVzIiwiQXR0cmFjdG9yTW9kZWwiLCJMb2NhbFNoYXBlIiwiY29uc3RydWN0b3IiLCJhbGxvd2VkUGVybXV0YXRpb25zIiwiY2VudHJhbEF0b20iLCJncm91cHMiLCJpZGVhbE9yaWVudGF0aW9ucyIsImFwcGx5QXR0cmFjdGlvbiIsImR0IiwiYXBwbHlBdHRyYWN0b3JGb3JjZXMiLCJwb3NpdGlvblByb3BlcnR5IiwidmFsdWUiLCJlcnJvciIsImFwcGx5QW5nbGVBdHRyYWN0aW9uUmVwdWxzaW9uIiwibGFzdFBlcm11dGF0aW9uIiwibWFwcGluZyIsInBlcm11dGVMaXN0V2l0aEluZGljZXMiLCJwZXJtdXRhdGlvbnMiLCJpbmRpY2VzIiwibGVuZ3RoIiwicmVzdWx0IiwiaSIsInBlcm11dGF0aW9uIiwicmVzdWx0c1RvQWRkIiwid2l0aEluZGljZXNQZXJtdXRlZCIsImoiLCJwdXNoIiwidnNlcHJQZXJtdXRhdGlvbnMiLCJuZWlnaGJvcnMiLCJpZGVudGl0eSIsImluZGV4T2YiLCJncm91cCIsInBhcnRpdGlvbmVkIiwiaXNMb25lUGFpciIsImxvbmVQYWlycyIsImF0b21zIiwiXyIsIm1hcCIsInJlYWxQZXJtdXRhdGlvbnMiLCJmaWx0ZXIiLCJ1c2VkRWxlbWVudHMiLCJ1bmlxIiwiZWxlbWVudCIsImF0b21zV2l0aEVsZW1lbnQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkxvY2FsU2hhcGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVGhlIGlkZWFsIGxvY2FsIHNoYXBlIGZvciBhIGNlcnRhaW4gY2VudHJhbCBhdG9tIGFuZCBpdHMgKGxvY2FsKSBuZWlnaGJvcnMuXHJcbiAqXHJcbiAqIEFsc28gY29udGFpbnMgdGhlIGFiaWxpdHkgdG8gcHVzaCB0aGUgbG9jYWwgYXRvbXMgaW50byBwbGFjZSwgYWxvbmcgd2l0aCBtYW55IGhlbHBlciBmdW5jdGlvbnNcclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBQZXJtdXRhdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvUGVybXV0YXRpb24uanMnO1xyXG5pbXBvcnQgcGFydGl0aW9uIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9wYXJ0aXRpb24uanMnO1xyXG5pbXBvcnQgbW9sZWN1bGVTaGFwZXMgZnJvbSAnLi4vLi4vbW9sZWN1bGVTaGFwZXMuanMnO1xyXG5pbXBvcnQgQXR0cmFjdG9yTW9kZWwgZnJvbSAnLi9BdHRyYWN0b3JNb2RlbC5qcyc7XHJcblxyXG5jbGFzcyBMb2NhbFNoYXBlIHtcclxuICAvKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPFBlcm11dGF0aW9uPn0gYWxsb3dlZFBlcm11dGF0aW9uc1xyXG4gICAqIEBwYXJhbSB7UGFpckdyb3VwfSBjZW50cmFsQXRvbVxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPFBhaXJHcm91cD59IGdyb3Vwc1xyXG4gICAqIEBwYXJhbSB7QXJyYXkuPFZlY3RvcjM+fSBpZGVhbE9yaWVudGF0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBhbGxvd2VkUGVybXV0YXRpb25zLCBjZW50cmFsQXRvbSwgZ3JvdXBzLCBpZGVhbE9yaWVudGF0aW9ucyApIHtcclxuICAgIC8vIEBwdWJsaWMge0FycmF5LjxQZXJtdXRhdGlvbj59IC0gRGVub3RlcyBob3cgd2UgY2FuIG1hcCB0aGUgZ3JvdXBzIGludG8gdGhlIG9yaWVudGF0aW9uIHZlY3RvcnMuXHJcbiAgICAvLyBTb21lIGNvbWJpbmF0aW9ucyBtYXkgbm90IGJlIHBvc3NpYmxlLlxyXG4gICAgdGhpcy5hbGxvd2VkUGVybXV0YXRpb25zID0gYWxsb3dlZFBlcm11dGF0aW9ucztcclxuXHJcbiAgICAvLyBAcHVibGljIHtQYWlyR3JvdXB9IC0gQWxsIG9mIG91ciBwYWlyIGdyb3VwcyBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoaXMgYXRvbS5cclxuICAgIHRoaXMuY2VudHJhbEF0b20gPSBjZW50cmFsQXRvbTtcclxuXHJcbiAgICAvLyBAcHVibGljIHtBcnJheS48UGFpckdyb3VwPn1cclxuICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xyXG5cclxuICAgIC8vIEBwdWJsaWMge0FycmF5LjxWZWN0b3IzPn0gLSBUaGUgaWRlYWwgb3JpZW50YXRpb25zICh1bml0IHZlY3RvcnMpIGZvciB0aGUgZ3JvdXBzIHJlcHJlc2VudGluZyB0aGVcclxuICAgIC8vIGlkZWFsIGxvY2FsIHNoYXBlLlxyXG4gICAgdGhpcy5pZGVhbE9yaWVudGF0aW9ucyA9IGlkZWFsT3JpZW50YXRpb25zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0cmFjdHMgdGhlIGF0b21zIHRvIHRoZWlyIGlkZWFsIHNoYXBlLCBhbmQgcmV0dXJucyB0aGUgY3VycmVudCBhcHByb3hpbWF0ZSBcImVycm9yXCIgdGhhdCB0aGV5IGhhdmUgYXQgdGhpcyBzdGF0ZS5cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBBdHRyYWN0aW9uIGRvbmUgYnkgYWRkaW5nIGluIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR0IC0gQW1vdW50IG9mIHRpbWUgZWxhcHNlZC5cclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBBbW91bnQgb2YgZXJyb3IgKGxlYXN0IHNxdWFyZXMtc3R5bGUpXHJcbiAgICovXHJcbiAgYXBwbHlBdHRyYWN0aW9uKCBkdCApIHtcclxuICAgIHJldHVybiBBdHRyYWN0b3JNb2RlbC5hcHBseUF0dHJhY3RvckZvcmNlcyggdGhpcy5ncm91cHMsIGR0LCB0aGlzLmlkZWFsT3JpZW50YXRpb25zLCB0aGlzLmFsbG93ZWRQZXJtdXRhdGlvbnMsIHRoaXMuY2VudHJhbEF0b20ucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZSwgZmFsc2UgKS5lcnJvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvcmNlcyBwYWlyLWdyb3VwcyB3aXRoIHNpbWlsYXIgYW5nbGVzIGF3YXkgZnJvbSBlYWNoIG90aGVyLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdCAtIEFtb3VudCBvZiB0aW1lIGVsYXBzZWRcclxuICAgKiBAcGFyYW0ge1Blcm11dGF0aW9ufSBbbGFzdFBlcm11dGF0aW9uXVxyXG4gICAqIEByZXR1cm5zIHtSZXN1bHRNYXBwaW5nfVxyXG4gICAqL1xyXG4gIGFwcGx5QW5nbGVBdHRyYWN0aW9uUmVwdWxzaW9uKCBkdCwgbGFzdFBlcm11dGF0aW9uICkge1xyXG4gICAgcmV0dXJuIEF0dHJhY3Rvck1vZGVsLmFwcGx5QXR0cmFjdG9yRm9yY2VzKCB0aGlzLmdyb3VwcywgZHQsIHRoaXMuaWRlYWxPcmllbnRhdGlvbnMsIHRoaXMuYWxsb3dlZFBlcm11dGF0aW9ucywgdGhpcy5jZW50cmFsQXRvbS5wb3NpdGlvblByb3BlcnR5LnZhbHVlLCB0cnVlLCBsYXN0UGVybXV0YXRpb24gKS5tYXBwaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBsaXN0IG9mIHBlcm11dGF0aW9ucywgcmV0dXJuIGFsbCBwZXJtdXRhdGlvbnMgdGhhdCBleGlzdCB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kaWNlcyBwZXJtdXRlZCBpbiBhbGwgZGlmZmVyZW50IHdheXMuXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIElFLCBpZiBnaXZlbiB0aGUgbGlzdCBvZiB0aGUgc2luZ2xlIHBlcm11dGF0aW9uICgxMiksIGFuZCBzcGVjaWZpZWQgaW5kaWNlcyB7Myw0LDV9LCB0aGUgcGVybXV0YXRpb25zIHJldHVybmVkIHdpbGwgYmVcclxuICAgKiAoMTIpKDM0KSwoMTIpKDM1KSwoMTIpKDQ1KSwoMTIpKDQ1MyksKDEyKSg1MzQpLCgxMilcclxuICAgKi9cclxuICBzdGF0aWMgcGVybXV0ZUxpc3RXaXRoSW5kaWNlcyggcGVybXV0YXRpb25zLCBpbmRpY2VzICkge1xyXG4gICAgaWYgKCBpbmRpY2VzLmxlbmd0aCA8IDIgKSB7XHJcbiAgICAgIC8vIG5vIGNoYW5nZXMgaWYgd2UgY2FuJ3QgbW92ZSBtb3JlIHRoYW4gMSBlbGVtZW50IChuZWVkIHNvbWV3aGVyZSB0byBwdXQgaXQpXHJcbiAgICAgIHJldHVybiBwZXJtdXRhdGlvbnM7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHBlcm11dGF0aW9ucy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgY29uc3QgcGVybXV0YXRpb24gPSBwZXJtdXRhdGlvbnNbIGkgXTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdHNUb0FkZCA9IHBlcm11dGF0aW9uLndpdGhJbmRpY2VzUGVybXV0ZWQoIGluZGljZXMgKTtcclxuICAgICAgZm9yICggbGV0IGogPSAwOyBqIDwgcmVzdWx0c1RvQWRkLmxlbmd0aDsgaisrICkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKCByZXN1bHRzVG9BZGRbIGogXSApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3cgc3dpdGNoaW5nIG9mIGxvbmUgcGFpcnMgd2l0aCBlYWNoIG90aGVyLCBhbmQgYWxsIG90aGVyIHR5cGVzIG9mIGJvbmRzIHdpdGggZWFjaCBvdGhlci5cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBOT1RFOiBJIHJlY29tbWVuZGVkIGRvdWJsZSBvciB0cmlwbGUgYm9uZHMgYmVpbmcgcHV0IGluIFwiaGlnaGVyIHJlcHVsc2lvblwiIHNwb3RzIG92ZXIgc2luZ2xlIGJvbmRzLFxyXG4gICAqIGJ1dCB0aGlzIHdhcyBzcGVjaWZpY2FsbHkgcmVqZWN0ZWQuIC1KTy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPFBhaXJHcm91cD59IG5laWdoYm9yc1xyXG4gICAqIEBwYXJhbSB7QXJyYXkuPFBlcm11dGF0aW9uPn0gcGVybXV0YXRpb25zXHJcbiAgICovXHJcbiAgc3RhdGljIHZzZXByUGVybXV0YXRpb25zKCBuZWlnaGJvcnMgKSB7XHJcbiAgICBsZXQgcGVybXV0YXRpb25zID0gW107XHJcbiAgICBwZXJtdXRhdGlvbnMucHVzaCggUGVybXV0YXRpb24uaWRlbnRpdHkoIG5laWdoYm9ycy5sZW5ndGggKSApO1xyXG5cclxuICAgIGNvbnN0IGluZGV4T2YgPSBncm91cCA9PiBuZWlnaGJvcnMuaW5kZXhPZiggZ3JvdXAgKTtcclxuXHJcbiAgICAvLyBwYXJ0aXRpb24gdGhlIG5laWdoYm9ycyBpbnRvIGxvbmUgcGFpcnMgYW5kIGF0b21zLlxyXG4gICAgY29uc3QgcGFydGl0aW9uZWQgPSBwYXJ0aXRpb24oIG5laWdoYm9ycywgZ3JvdXAgPT4gZ3JvdXAuaXNMb25lUGFpciApO1xyXG4gICAgLy8gdGhpcyBzZXBhcmF0aW9uIGxvb2tzIGJldHRlciBpbiBsYW5ndWFnZXMgd2hlcmUgeW91IHNheSBcIihsb25lUGFpcnMsIGF0b21zKSA9IHBhcnRpdGlvbiguLi4pXCJcclxuICAgIGNvbnN0IGxvbmVQYWlycyA9IHBhcnRpdGlvbmVkWyAwIF07XHJcbiAgICBjb25zdCBhdG9tcyA9IHBhcnRpdGlvbmVkWyAxIF07XHJcblxyXG4gICAgLy8gcGVybXV0ZSBhd2F5IHRoZSBsb25lIHBhaXJzXHJcbiAgICBwZXJtdXRhdGlvbnMgPSBMb2NhbFNoYXBlLnBlcm11dGVMaXN0V2l0aEluZGljZXMoIHBlcm11dGF0aW9ucywgXy5tYXAoIGxvbmVQYWlycywgaW5kZXhPZiApICk7XHJcblxyXG4gICAgLy8gcGVybXV0ZSBhd2F5IHRoZSBib25kZWQgZ3JvdXBzXHJcbiAgICBwZXJtdXRhdGlvbnMgPSBMb2NhbFNoYXBlLnBlcm11dGVMaXN0V2l0aEluZGljZXMoIHBlcm11dGF0aW9ucywgXy5tYXAoIGF0b21zLCBpbmRleE9mICkgKTtcclxuICAgIHJldHVybiBwZXJtdXRhdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbGxvdyBzd2l0Y2hpbmcgb2YgbG9uZSBwYWlycyB3aXRoIGVhY2ggb3RoZXIsIGFuZCBhbGwgb3RoZXIgdHlwZXMgb2YgYm9uZHMgd2l0aCB0aGUgc2FtZSB0eXBlIG9mIGVsZW1lbnQuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48UGFpckdyb3VwPn0gbmVpZ2hib3JzXHJcbiAgICogQHBhcmFtIHtBcnJheS48UGVybXV0YXRpb24+fSBwZXJtdXRhdGlvbnNcclxuICAgKi9cclxuICBzdGF0aWMgcmVhbFBlcm11dGF0aW9ucyggbmVpZ2hib3JzICkge1xyXG4gICAgbGV0IHBlcm11dGF0aW9ucyA9IFtdO1xyXG4gICAgcGVybXV0YXRpb25zLnB1c2goIFBlcm11dGF0aW9uLmlkZW50aXR5KCBuZWlnaGJvcnMubGVuZ3RoICkgKTtcclxuXHJcbiAgICBjb25zdCBpbmRleE9mID0gZ3JvdXAgPT4gbmVpZ2hib3JzLmluZGV4T2YoIGdyb3VwICk7XHJcblxyXG4gICAgLy8gYWxsb3cgaW50ZXJjaGFuZ2luZyBvZiBsb25lIHBhaXJzXHJcbiAgICBjb25zdCBsb25lUGFpcnMgPSBfLmZpbHRlciggbmVpZ2hib3JzLCBncm91cCA9PiBncm91cC5pc0xvbmVQYWlyICk7XHJcbiAgICBwZXJtdXRhdGlvbnMgPSBMb2NhbFNoYXBlLnBlcm11dGVMaXN0V2l0aEluZGljZXMoIHBlcm11dGF0aW9ucywgXy5tYXAoIGxvbmVQYWlycywgaW5kZXhPZiApICk7XHJcblxyXG4gICAgLy8gYWxsb3cgaW50ZXJjaGFuZ2luZyBvZiBwYWlyIGdyb3VwcyB3aGVuIHRoZXkgaGF2ZSB0aGUgc2FtZSBjaGVtaWNhbCBlbGVtZW50XHJcbiAgICBjb25zdCBhdG9tcyA9IF8uZmlsdGVyKCBuZWlnaGJvcnMsIGdyb3VwID0+ICFncm91cC5pc0xvbmVQYWlyICk7XHJcblxyXG4gICAgY29uc3QgdXNlZEVsZW1lbnRzID0gXy51bmlxKCBfLm1hcCggYXRvbXMsIGdyb3VwID0+IGdyb3VwLmVsZW1lbnQgKSApO1xyXG5cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHVzZWRFbGVtZW50cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgY29uc3QgZWxlbWVudCA9IHVzZWRFbGVtZW50c1sgaSBdO1xyXG5cclxuICAgICAgLy8gc2luY2UgdGhlIGNsb3N1cmUgaXMgYmVpbmcgZXhlY3V0ZWQgYXQgdGhpcyBwb2ludCwgdGhlIHdhcm5pbmcgaW4gdGhpcyBsaW5lIGNhbiBiZSBpZ25vcmVkXHJcbiAgICAgIGNvbnN0IGF0b21zV2l0aEVsZW1lbnQgPSBfLmZpbHRlciggYXRvbXMsIGdyb3VwID0+IGdyb3VwLmVsZW1lbnQgPT09IGVsZW1lbnQgKTtcclxuICAgICAgcGVybXV0YXRpb25zID0gTG9jYWxTaGFwZS5wZXJtdXRlTGlzdFdpdGhJbmRpY2VzKCBwZXJtdXRhdGlvbnMsIF8ubWFwKCBhdG9tc1dpdGhFbGVtZW50LCBpbmRleE9mICkgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGVybXV0YXRpb25zO1xyXG4gIH1cclxufVxyXG5cclxubW9sZWN1bGVTaGFwZXMucmVnaXN0ZXIoICdMb2NhbFNoYXBlJywgTG9jYWxTaGFwZSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTG9jYWxTaGFwZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFdBQVcsTUFBTSxtQ0FBbUM7QUFDM0QsT0FBT0MsU0FBUyxNQUFNLHVDQUF1QztBQUM3RCxPQUFPQyxjQUFjLE1BQU0seUJBQXlCO0FBQ3BELE9BQU9DLGNBQWMsTUFBTSxxQkFBcUI7QUFFaEQsTUFBTUMsVUFBVSxDQUFDO0VBQ2Y7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VB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