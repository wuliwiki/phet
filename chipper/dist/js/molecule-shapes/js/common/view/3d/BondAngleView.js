// Copyright 2014-2022, University of Colorado Boulder

/**
 * Base type for views of the angle (sector and line) between two bonds (not including the displayed label)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import Bounds2 from '../../../../../dot/js/Bounds2.js';
import Utils from '../../../../../dot/js/Utils.js';
import Vector2 from '../../../../../dot/js/Vector2.js';
import Vector3 from '../../../../../dot/js/Vector3.js';
import { animatedPanZoomSingleton } from '../../../../../scenery/js/imports.js';
import moleculeShapes from '../../../moleculeShapes.js';
import PairGroup from '../../model/PairGroup.js';
class BondAngleView extends THREE.Object3D {
  /**
   * @public
   *
   * @param {MoleculeShapesScreenView} screenView - We do various screen-space computations for positioning the labels
   * @param {Property.<boolean>} showBondAnglesProperty
   * @param {Molecule} molecule
   * @param {PairGroup} aGroup - The atom on one end of the bond angle
   * @param {PairGroup} bGroup - The atom on the other end of the bond angle
   * @param {LabelWebGLView|LabelFallbackNode} label - Supports label.setLabel( ... ) and label.unsetLabel(), see docs
   */
  initialize(screenView, showBondAnglesProperty, molecule, aGroup, bGroup, label) {
    assert && assert(aGroup instanceof PairGroup);
    assert && assert(bGroup instanceof PairGroup);
    this.aGroup = aGroup; // @public {PairGroup|null} - Atom on one end of the bond angle
    this.bGroup = bGroup; // @public {PairGroup|null} - Atom on the other end of the bond angle
    this.label = label; // @public {LabelWebGLView|LabelFallbackNode}
    this.midpoint = null; // @public {Vector3} - Updated in updateView
    this.radius = 5; // @public {number}

    this.screenView = screenView; // @protected {MoleculeShapesScreenView}
    this.showBondAnglesProperty = showBondAnglesProperty; // @protected {Property.<boolean>}
    this.molecule = molecule; // @protected {Molecule}

    this.viewOpacity = 0; // @protected {number} - Updated in updateView super call
    this.viewAngle = 0; // @protected {number} - Updated in updateView super call
    this.midpointUnit = null; // @protected {Vector3} - Updated in updateView super call
    this.planarUnit = null; // @protected {Vector3} - Updated in updateView super call
  }

  /**
   * Disposes the view, so that it can be reinitialized (pooling).
   * @public
   */
  dispose() {
    this.aGroup = null;
    this.bGroup = null;

    // overridden in sub-types
  }

  /**
   * Updates the bond-angle view based on previous information.
   * @public
   *
   * @param {Vector3|null} lastMidpoint - The midpoint of the last frame's bond angle arc, used to stabilize bond angles
   *                                      that are around ~180 degrees.
   * @param {Vector3} localCameraOrientation - A unit vector in the molecule's local coordiante space pointing
   *                                           to the camera.
   */
  updateView(lastMidpoint, localCameraOrientation) {
    const aDir = this.aGroup.orientation;
    const bDir = this.bGroup.orientation;
    this.viewOpacity = this.showBondAnglesProperty.value ? BondAngleView.calculateBrightness(aDir, bDir, localCameraOrientation, this.molecule.radialAtoms.length) : 0;

    // angle in radians between the two orientations, clamped to avoid Math.acos of something slightly greater than 1
    this.viewAngle = Math.acos(Utils.clamp(aDir.dot(bDir), -1, 1));

    // If we have an approximate semicircle, we'll need to use the last midpoint to provide a stable position to
    // display the 180-degree semicircle. Otherwise, it would be unstable and wildly vary.
    const isApproximateSemicircle = BondAngleView.isApproximateSemicircle(aDir, bDir);
    if (isApproximateSemicircle) {
      if (!lastMidpoint) {
        lastMidpoint = Vector3.Y_UNIT.times(BondAngleView.radius);
      }
      const lastMidpointDir = lastMidpoint.normalized();

      // find a vector that is as orthogonal to both directions as possible
      const badCross = aDir.cross(lastMidpointDir).plus(lastMidpointDir.cross(bDir));
      const averageCross = badCross.magnitude > 0 ? badCross.normalized() : new Vector3(0, 0, 1);

      // find a vector that gives us a balance between aDir and bDir (so our semicircle will balance out at the endpoints)
      const averagePointDir = aDir.minus(bDir).normalized();

      // (basis vector 1) make that average point planar to our arc surface
      this.planarUnit = averagePointDir.minus(averageCross.times(averageCross.dot(averagePointDir))).normalized();

      // (basis vector 2) find a new midpoint direction that is planar to our arc surface
      this.midpointUnit = averageCross.cross(this.planarUnit).normalized();
    } else {
      this.midpointUnit = aDir.plus(bDir).normalized();
      this.planarUnit = aDir.minus(this.midpointUnit.times(aDir.dot(this.midpointUnit)));
      // guard for zero-length bond case, see https://github.com/phetsims/molecule-shapes/issues/101
      if (this.planarUnit.magnitude > 0) {
        this.planarUnit.normalize();
      }
    }
    this.midpoint = this.midpointUnit.times(BondAngleView.radius);

    // label handling
    if (this.viewOpacity !== 0) {
      const centerDevicePoint = new THREE.Vector3(); // e.g. zero
      const midDevicePoint = new THREE.Vector3().copy(this.midpoint);

      // transform to world coordinates
      this.parent.localToWorld(centerDevicePoint);
      this.parent.localToWorld(midDevicePoint);

      // TODO: failure of encapsulation here!
      // inverse projection into normalized device coordinates
      this.screenView.convertScreenPointFromGlobalPoint(centerDevicePoint);
      this.screenView.convertScreenPointFromGlobalPoint(midDevicePoint);
      const layoutScale = this.screenView.getLayoutScale(new Bounds2(0, 0, this.screenView.screenWidth, this.screenView.screenHeight)) * animatedPanZoomSingleton.listener.matrixProperty.value.getScaleVector().x;
      const angle = aDir.angleBetween(bDir) * 180 / Math.PI;

      // Potential fix for https://github.com/phetsims/molecule-shapes/issues/145.
      // The THREE.Vector3.project( THREE.Camera ) is giving is nonsense near startup. Longer-term could identify, but
      // switching bonds to true very quickly might cause this.
      if (isFinite(centerDevicePoint.x) && isFinite(centerDevicePoint.y)) {
        // screen coordinates
        const screenCenterPoint = new Vector2((centerDevicePoint.x + 1) * this.screenView.screenWidth / 2, (-centerDevicePoint.y + 1) * this.screenView.screenHeight / 2);
        const screenMidPoint = new Vector2((midDevicePoint.x + 1) * this.screenView.screenWidth / 2, (-midDevicePoint.y + 1) * this.screenView.screenHeight / 2);
        let labelString = `${Utils.toFixed(angle, 1)}Â°`;
        while (labelString.length < 5) {
          // handle single-digit labels by padding them
          labelString = `0${labelString}`;
        }
        this.label.setLabel(labelString, this.viewOpacity, screenCenterPoint, screenMidPoint, layoutScale);
      } else {
        this.label.unsetLabel();
      }
    } else {
      this.label.unsetLabel();
    }
  }

  // @public

  /**
   * Determines the brightness (alpha) of a bond angle based on the orientations of the two radial atoms, the camera,
   * and the total number of bonds around our central atom.
   * @public
   *
   * @param {Vector3} aDir - The unit vector pointing towards the first radial atom
   * @param {Vector3} bDir - The unit vector pointing towards the second radial atom
   * @param {Vector3} localCameraOrientation - A unit vector in the molecule's local coordiante space pointing
   *                                           to the camera.
   * @param {number} bondQuantity - The total number of bonds around the central atom
   */
  static calculateBrightness(aDir, bDir, localCameraOrientation, bondQuantity) {
    // if there are less than 3 bonds, always show the bond angle.
    if (bondQuantity <= 2) {
      return 1;
    }

    // a combined measure of how close the angles are AND how orthogonal they are to the camera
    const brightness = Math.abs(aDir.cross(bDir).dot(localCameraOrientation));
    const lowThreshold = BondAngleView.LOW_THRESHOLDS[bondQuantity];
    const highThreshold = BondAngleView.HIGH_THRESHOLDS[bondQuantity];
    const interpolatedValue = brightness / (highThreshold - lowThreshold) - lowThreshold / (highThreshold - lowThreshold);
    return Utils.clamp(interpolatedValue, 0, 1);
  }

  /**
   * Whether our condition for semicircle (almost 180-degree bond angle) is met, as we need to stabilize the
   * positioning in this case.
   * @private
   *
   * @param {Vector3} startDir
   * @param {Vector3} endDir
   * @returns {boolean}
   */
  static isApproximateSemicircle(startDir, endDir) {
    return Math.acos(Utils.clamp(startDir.dot(endDir), -1, 1)) >= 3.12414;
  }
}

// dot product between the camera direction and bond angle normal is below LOW_THRESHOLDS[bondOrder] => alpha = 0
// dot product between the camera direction and bond angle normal is above LOW_THRESHOLDS[HIGH_THRESHOLDS] => alpha = 1
BondAngleView.LOW_THRESHOLDS = [0, 0, 0, 0.1, 0.35, 0.45, 0.5]; // @public
BondAngleView.HIGH_THRESHOLDS = [0, 0, 0, 0.5, 0.55, 0.65, 0.75];

// @public {number} - radius, in view units
BondAngleView.radius = 5;
moleculeShapes.register('BondAngleView', BondAngleView);
export default BondAngleView;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiVXRpbHMiLCJWZWN0b3IyIiwiVmVjdG9yMyIsImFuaW1hdGVkUGFuWm9vbVNpbmdsZXRvbiIsIm1vbGVjdWxlU2hhcGVzIiwiUGFpckdyb3VwIiwiQm9uZEFuZ2xlVmlldyIsIlRIUkVFIiwiT2JqZWN0M0QiLCJpbml0aWFsaXplIiwic2NyZWVuVmlldyIsInNob3dCb25kQW5nbGVzUHJvcGVydHkiLCJtb2xlY3VsZSIsImFHcm91cCIsImJHcm91cCIsImxhYmVsIiwiYXNzZXJ0IiwibWlkcG9pbnQiLCJyYWRpdXMiLCJ2aWV3T3BhY2l0eSIsInZpZXdBbmdsZSIsIm1pZHBvaW50VW5pdCIsInBsYW5hclVuaXQiLCJkaXNwb3NlIiwidXBkYXRlVmlldyIsImxhc3RNaWRwb2ludCIsImxvY2FsQ2FtZXJhT3JpZW50YXRpb24iLCJhRGlyIiwib3JpZW50YXRpb24iLCJiRGlyIiwidmFsdWUiLCJjYWxjdWxhdGVCcmlnaHRuZXNzIiwicmFkaWFsQXRvbXMiLCJsZW5ndGgiLCJNYXRoIiwiYWNvcyIsImNsYW1wIiwiZG90IiwiaXNBcHByb3hpbWF0ZVNlbWljaXJjbGUiLCJZX1VOSVQiLCJ0aW1lcyIsImxhc3RNaWRwb2ludERpciIsIm5vcm1hbGl6ZWQiLCJiYWRDcm9zcyIsImNyb3NzIiwicGx1cyIsImF2ZXJhZ2VDcm9zcyIsIm1hZ25pdHVkZSIsImF2ZXJhZ2VQb2ludERpciIsIm1pbnVzIiwibm9ybWFsaXplIiwiY2VudGVyRGV2aWNlUG9pbnQiLCJtaWREZXZpY2VQb2ludCIsImNvcHkiLCJwYXJlbnQiLCJsb2NhbFRvV29ybGQiLCJjb252ZXJ0U2NyZWVuUG9pbnRGcm9tR2xvYmFsUG9pbnQiLCJsYXlvdXRTY2FsZSIsImdldExheW91dFNjYWxlIiwic2NyZWVuV2lkdGgiLCJzY3JlZW5IZWlnaHQiLCJsaXN0ZW5lciIsIm1hdHJpeFByb3BlcnR5IiwiZ2V0U2NhbGVWZWN0b3IiLCJ4IiwiYW5nbGUiLCJhbmdsZUJldHdlZW4iLCJQSSIsImlzRmluaXRlIiwieSIsInNjcmVlbkNlbnRlclBvaW50Iiwic2NyZWVuTWlkUG9pbnQiLCJsYWJlbFN0cmluZyIsInRvRml4ZWQiLCJzZXRMYWJlbCIsInVuc2V0TGFiZWwiLCJib25kUXVhbnRpdHkiLCJicmlnaHRuZXNzIiwiYWJzIiwibG93VGhyZXNob2xkIiwiTE9XX1RIUkVTSE9MRFMiLCJoaWdoVGhyZXNob2xkIiwiSElHSF9USFJFU0hPTERTIiwiaW50ZXJwb2xhdGVkVmFsdWUiLCJzdGFydERpciIsImVuZERpciIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQm9uZEFuZ2xlVmlldy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNC0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBCYXNlIHR5cGUgZm9yIHZpZXdzIG9mIHRoZSBhbmdsZSAoc2VjdG9yIGFuZCBsaW5lKSBiZXR3ZWVuIHR3byBib25kcyAobm90IGluY2x1ZGluZyB0aGUgZGlzcGxheWVkIGxhYmVsKVxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XHJcbiAqL1xyXG5cclxuaW1wb3J0IEJvdW5kczIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vZG90L2pzL0JvdW5kczIuanMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgVmVjdG9yMyBmcm9tICcuLi8uLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IGFuaW1hdGVkUGFuWm9vbVNpbmdsZXRvbiB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBtb2xlY3VsZVNoYXBlcyBmcm9tICcuLi8uLi8uLi9tb2xlY3VsZVNoYXBlcy5qcyc7XHJcbmltcG9ydCBQYWlyR3JvdXAgZnJvbSAnLi4vLi4vbW9kZWwvUGFpckdyb3VwLmpzJztcclxuXHJcbmNsYXNzIEJvbmRBbmdsZVZpZXcgZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNb2xlY3VsZVNoYXBlc1NjcmVlblZpZXd9IHNjcmVlblZpZXcgLSBXZSBkbyB2YXJpb3VzIHNjcmVlbi1zcGFjZSBjb21wdXRhdGlvbnMgZm9yIHBvc2l0aW9uaW5nIHRoZSBsYWJlbHNcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5Ljxib29sZWFuPn0gc2hvd0JvbmRBbmdsZXNQcm9wZXJ0eVxyXG4gICAqIEBwYXJhbSB7TW9sZWN1bGV9IG1vbGVjdWxlXHJcbiAgICogQHBhcmFtIHtQYWlyR3JvdXB9IGFHcm91cCAtIFRoZSBhdG9tIG9uIG9uZSBlbmQgb2YgdGhlIGJvbmQgYW5nbGVcclxuICAgKiBAcGFyYW0ge1BhaXJHcm91cH0gYkdyb3VwIC0gVGhlIGF0b20gb24gdGhlIG90aGVyIGVuZCBvZiB0aGUgYm9uZCBhbmdsZVxyXG4gICAqIEBwYXJhbSB7TGFiZWxXZWJHTFZpZXd8TGFiZWxGYWxsYmFja05vZGV9IGxhYmVsIC0gU3VwcG9ydHMgbGFiZWwuc2V0TGFiZWwoIC4uLiApIGFuZCBsYWJlbC51bnNldExhYmVsKCksIHNlZSBkb2NzXHJcbiAgICovXHJcbiAgaW5pdGlhbGl6ZSggc2NyZWVuVmlldywgc2hvd0JvbmRBbmdsZXNQcm9wZXJ0eSwgbW9sZWN1bGUsIGFHcm91cCwgYkdyb3VwLCBsYWJlbCApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGFHcm91cCBpbnN0YW5jZW9mIFBhaXJHcm91cCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggYkdyb3VwIGluc3RhbmNlb2YgUGFpckdyb3VwICk7XHJcblxyXG4gICAgdGhpcy5hR3JvdXAgPSBhR3JvdXA7IC8vIEBwdWJsaWMge1BhaXJHcm91cHxudWxsfSAtIEF0b20gb24gb25lIGVuZCBvZiB0aGUgYm9uZCBhbmdsZVxyXG4gICAgdGhpcy5iR3JvdXAgPSBiR3JvdXA7IC8vIEBwdWJsaWMge1BhaXJHcm91cHxudWxsfSAtIEF0b20gb24gdGhlIG90aGVyIGVuZCBvZiB0aGUgYm9uZCBhbmdsZVxyXG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsOyAvLyBAcHVibGljIHtMYWJlbFdlYkdMVmlld3xMYWJlbEZhbGxiYWNrTm9kZX1cclxuICAgIHRoaXMubWlkcG9pbnQgPSBudWxsOyAvLyBAcHVibGljIHtWZWN0b3IzfSAtIFVwZGF0ZWQgaW4gdXBkYXRlVmlld1xyXG4gICAgdGhpcy5yYWRpdXMgPSA1OyAvLyBAcHVibGljIHtudW1iZXJ9XHJcblxyXG4gICAgdGhpcy5zY3JlZW5WaWV3ID0gc2NyZWVuVmlldzsgLy8gQHByb3RlY3RlZCB7TW9sZWN1bGVTaGFwZXNTY3JlZW5WaWV3fVxyXG4gICAgdGhpcy5zaG93Qm9uZEFuZ2xlc1Byb3BlcnR5ID0gc2hvd0JvbmRBbmdsZXNQcm9wZXJ0eTsgLy8gQHByb3RlY3RlZCB7UHJvcGVydHkuPGJvb2xlYW4+fVxyXG4gICAgdGhpcy5tb2xlY3VsZSA9IG1vbGVjdWxlOyAvLyBAcHJvdGVjdGVkIHtNb2xlY3VsZX1cclxuXHJcbiAgICB0aGlzLnZpZXdPcGFjaXR5ID0gMDsgLy8gQHByb3RlY3RlZCB7bnVtYmVyfSAtIFVwZGF0ZWQgaW4gdXBkYXRlVmlldyBzdXBlciBjYWxsXHJcbiAgICB0aGlzLnZpZXdBbmdsZSA9IDA7IC8vIEBwcm90ZWN0ZWQge251bWJlcn0gLSBVcGRhdGVkIGluIHVwZGF0ZVZpZXcgc3VwZXIgY2FsbFxyXG4gICAgdGhpcy5taWRwb2ludFVuaXQgPSBudWxsOyAvLyBAcHJvdGVjdGVkIHtWZWN0b3IzfSAtIFVwZGF0ZWQgaW4gdXBkYXRlVmlldyBzdXBlciBjYWxsXHJcbiAgICB0aGlzLnBsYW5hclVuaXQgPSBudWxsOyAvLyBAcHJvdGVjdGVkIHtWZWN0b3IzfSAtIFVwZGF0ZWQgaW4gdXBkYXRlVmlldyBzdXBlciBjYWxsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwb3NlcyB0aGUgdmlldywgc28gdGhhdCBpdCBjYW4gYmUgcmVpbml0aWFsaXplZCAocG9vbGluZykuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLmFHcm91cCA9IG51bGw7XHJcbiAgICB0aGlzLmJHcm91cCA9IG51bGw7XHJcblxyXG4gICAgLy8gb3ZlcnJpZGRlbiBpbiBzdWItdHlwZXNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIGJvbmQtYW5nbGUgdmlldyBiYXNlZCBvbiBwcmV2aW91cyBpbmZvcm1hdGlvbi5cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjN8bnVsbH0gbGFzdE1pZHBvaW50IC0gVGhlIG1pZHBvaW50IG9mIHRoZSBsYXN0IGZyYW1lJ3MgYm9uZCBhbmdsZSBhcmMsIHVzZWQgdG8gc3RhYmlsaXplIGJvbmQgYW5nbGVzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgYXJlIGFyb3VuZCB+MTgwIGRlZ3JlZXMuXHJcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBsb2NhbENhbWVyYU9yaWVudGF0aW9uIC0gQSB1bml0IHZlY3RvciBpbiB0aGUgbW9sZWN1bGUncyBsb2NhbCBjb29yZGlhbnRlIHNwYWNlIHBvaW50aW5nXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGNhbWVyYS5cclxuICAgKi9cclxuICB1cGRhdGVWaWV3KCBsYXN0TWlkcG9pbnQsIGxvY2FsQ2FtZXJhT3JpZW50YXRpb24gKSB7XHJcbiAgICBjb25zdCBhRGlyID0gdGhpcy5hR3JvdXAub3JpZW50YXRpb247XHJcbiAgICBjb25zdCBiRGlyID0gdGhpcy5iR3JvdXAub3JpZW50YXRpb247XHJcblxyXG4gICAgdGhpcy52aWV3T3BhY2l0eSA9IHRoaXMuc2hvd0JvbmRBbmdsZXNQcm9wZXJ0eS52YWx1ZSA/IEJvbmRBbmdsZVZpZXcuY2FsY3VsYXRlQnJpZ2h0bmVzcyggYURpciwgYkRpciwgbG9jYWxDYW1lcmFPcmllbnRhdGlvbiwgdGhpcy5tb2xlY3VsZS5yYWRpYWxBdG9tcy5sZW5ndGggKSA6IDA7XHJcblxyXG4gICAgLy8gYW5nbGUgaW4gcmFkaWFucyBiZXR3ZWVuIHRoZSB0d28gb3JpZW50YXRpb25zLCBjbGFtcGVkIHRvIGF2b2lkIE1hdGguYWNvcyBvZiBzb21ldGhpbmcgc2xpZ2h0bHkgZ3JlYXRlciB0aGFuIDFcclxuICAgIHRoaXMudmlld0FuZ2xlID0gTWF0aC5hY29zKCBVdGlscy5jbGFtcCggYURpci5kb3QoIGJEaXIgKSwgLTEsIDEgKSApO1xyXG5cclxuICAgIC8vIElmIHdlIGhhdmUgYW4gYXBwcm94aW1hdGUgc2VtaWNpcmNsZSwgd2UnbGwgbmVlZCB0byB1c2UgdGhlIGxhc3QgbWlkcG9pbnQgdG8gcHJvdmlkZSBhIHN0YWJsZSBwb3NpdGlvbiB0b1xyXG4gICAgLy8gZGlzcGxheSB0aGUgMTgwLWRlZ3JlZSBzZW1pY2lyY2xlLiBPdGhlcndpc2UsIGl0IHdvdWxkIGJlIHVuc3RhYmxlIGFuZCB3aWxkbHkgdmFyeS5cclxuICAgIGNvbnN0IGlzQXBwcm94aW1hdGVTZW1pY2lyY2xlID0gQm9uZEFuZ2xlVmlldy5pc0FwcHJveGltYXRlU2VtaWNpcmNsZSggYURpciwgYkRpciApO1xyXG4gICAgaWYgKCBpc0FwcHJveGltYXRlU2VtaWNpcmNsZSApIHtcclxuICAgICAgaWYgKCAhbGFzdE1pZHBvaW50ICkge1xyXG4gICAgICAgIGxhc3RNaWRwb2ludCA9IFZlY3RvcjMuWV9VTklULnRpbWVzKCBCb25kQW5nbGVWaWV3LnJhZGl1cyApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGxhc3RNaWRwb2ludERpciA9IGxhc3RNaWRwb2ludC5ub3JtYWxpemVkKCk7XHJcblxyXG4gICAgICAvLyBmaW5kIGEgdmVjdG9yIHRoYXQgaXMgYXMgb3J0aG9nb25hbCB0byBib3RoIGRpcmVjdGlvbnMgYXMgcG9zc2libGVcclxuICAgICAgY29uc3QgYmFkQ3Jvc3MgPSBhRGlyLmNyb3NzKCBsYXN0TWlkcG9pbnREaXIgKS5wbHVzKCBsYXN0TWlkcG9pbnREaXIuY3Jvc3MoIGJEaXIgKSApO1xyXG4gICAgICBjb25zdCBhdmVyYWdlQ3Jvc3MgPSBiYWRDcm9zcy5tYWduaXR1ZGUgPiAwID8gYmFkQ3Jvc3Mubm9ybWFsaXplZCgpIDogbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcclxuXHJcbiAgICAgIC8vIGZpbmQgYSB2ZWN0b3IgdGhhdCBnaXZlcyB1cyBhIGJhbGFuY2UgYmV0d2VlbiBhRGlyIGFuZCBiRGlyIChzbyBvdXIgc2VtaWNpcmNsZSB3aWxsIGJhbGFuY2Ugb3V0IGF0IHRoZSBlbmRwb2ludHMpXHJcbiAgICAgIGNvbnN0IGF2ZXJhZ2VQb2ludERpciA9IGFEaXIubWludXMoIGJEaXIgKS5ub3JtYWxpemVkKCk7XHJcblxyXG4gICAgICAvLyAoYmFzaXMgdmVjdG9yIDEpIG1ha2UgdGhhdCBhdmVyYWdlIHBvaW50IHBsYW5hciB0byBvdXIgYXJjIHN1cmZhY2VcclxuICAgICAgdGhpcy5wbGFuYXJVbml0ID0gYXZlcmFnZVBvaW50RGlyLm1pbnVzKCBhdmVyYWdlQ3Jvc3MudGltZXMoIGF2ZXJhZ2VDcm9zcy5kb3QoIGF2ZXJhZ2VQb2ludERpciApICkgKS5ub3JtYWxpemVkKCk7XHJcblxyXG4gICAgICAvLyAoYmFzaXMgdmVjdG9yIDIpIGZpbmQgYSBuZXcgbWlkcG9pbnQgZGlyZWN0aW9uIHRoYXQgaXMgcGxhbmFyIHRvIG91ciBhcmMgc3VyZmFjZVxyXG4gICAgICB0aGlzLm1pZHBvaW50VW5pdCA9IGF2ZXJhZ2VDcm9zcy5jcm9zcyggdGhpcy5wbGFuYXJVbml0ICkubm9ybWFsaXplZCgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRoaXMubWlkcG9pbnRVbml0ID0gYURpci5wbHVzKCBiRGlyICkubm9ybWFsaXplZCgpO1xyXG4gICAgICB0aGlzLnBsYW5hclVuaXQgPSBhRGlyLm1pbnVzKCB0aGlzLm1pZHBvaW50VW5pdC50aW1lcyggYURpci5kb3QoIHRoaXMubWlkcG9pbnRVbml0ICkgKSApO1xyXG4gICAgICAvLyBndWFyZCBmb3IgemVyby1sZW5ndGggYm9uZCBjYXNlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL21vbGVjdWxlLXNoYXBlcy9pc3N1ZXMvMTAxXHJcbiAgICAgIGlmICggdGhpcy5wbGFuYXJVbml0Lm1hZ25pdHVkZSA+IDAgKSB7XHJcbiAgICAgICAgdGhpcy5wbGFuYXJVbml0Lm5vcm1hbGl6ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5taWRwb2ludCA9IHRoaXMubWlkcG9pbnRVbml0LnRpbWVzKCBCb25kQW5nbGVWaWV3LnJhZGl1cyApO1xyXG5cclxuICAgIC8vIGxhYmVsIGhhbmRsaW5nXHJcbiAgICBpZiAoIHRoaXMudmlld09wYWNpdHkgIT09IDAgKSB7XHJcbiAgICAgIGNvbnN0IGNlbnRlckRldmljZVBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTsgLy8gZS5nLiB6ZXJvXHJcbiAgICAgIGNvbnN0IG1pZERldmljZVBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5jb3B5KCB0aGlzLm1pZHBvaW50ICk7XHJcblxyXG4gICAgICAvLyB0cmFuc2Zvcm0gdG8gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAgdGhpcy5wYXJlbnQubG9jYWxUb1dvcmxkKCBjZW50ZXJEZXZpY2VQb2ludCApO1xyXG4gICAgICB0aGlzLnBhcmVudC5sb2NhbFRvV29ybGQoIG1pZERldmljZVBvaW50ICk7XHJcblxyXG4gICAgICAvLyBUT0RPOiBmYWlsdXJlIG9mIGVuY2Fwc3VsYXRpb24gaGVyZSFcclxuICAgICAgLy8gaW52ZXJzZSBwcm9qZWN0aW9uIGludG8gbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXNcclxuICAgICAgdGhpcy5zY3JlZW5WaWV3LmNvbnZlcnRTY3JlZW5Qb2ludEZyb21HbG9iYWxQb2ludCggY2VudGVyRGV2aWNlUG9pbnQgKTtcclxuICAgICAgdGhpcy5zY3JlZW5WaWV3LmNvbnZlcnRTY3JlZW5Qb2ludEZyb21HbG9iYWxQb2ludCggbWlkRGV2aWNlUG9pbnQgKTtcclxuICAgICAgY29uc3QgbGF5b3V0U2NhbGUgPSB0aGlzLnNjcmVlblZpZXcuZ2V0TGF5b3V0U2NhbGUoIG5ldyBCb3VuZHMyKCAwLCAwLCB0aGlzLnNjcmVlblZpZXcuc2NyZWVuV2lkdGgsIHRoaXMuc2NyZWVuVmlldy5zY3JlZW5IZWlnaHQgKSApICogYW5pbWF0ZWRQYW5ab29tU2luZ2xldG9uLmxpc3RlbmVyLm1hdHJpeFByb3BlcnR5LnZhbHVlLmdldFNjYWxlVmVjdG9yKCkueDtcclxuXHJcbiAgICAgIGNvbnN0IGFuZ2xlID0gYURpci5hbmdsZUJldHdlZW4oIGJEaXIgKSAqIDE4MCAvIE1hdGguUEk7XHJcblxyXG4gICAgICAvLyBQb3RlbnRpYWwgZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvbW9sZWN1bGUtc2hhcGVzL2lzc3Vlcy8xNDUuXHJcbiAgICAgIC8vIFRoZSBUSFJFRS5WZWN0b3IzLnByb2plY3QoIFRIUkVFLkNhbWVyYSApIGlzIGdpdmluZyBpcyBub25zZW5zZSBuZWFyIHN0YXJ0dXAuIExvbmdlci10ZXJtIGNvdWxkIGlkZW50aWZ5LCBidXRcclxuICAgICAgLy8gc3dpdGNoaW5nIGJvbmRzIHRvIHRydWUgdmVyeSBxdWlja2x5IG1pZ2h0IGNhdXNlIHRoaXMuXHJcbiAgICAgIGlmICggaXNGaW5pdGUoIGNlbnRlckRldmljZVBvaW50LnggKSAmJiBpc0Zpbml0ZSggY2VudGVyRGV2aWNlUG9pbnQueSApICkge1xyXG4gICAgICAgIC8vIHNjcmVlbiBjb29yZGluYXRlc1xyXG4gICAgICAgIGNvbnN0IHNjcmVlbkNlbnRlclBvaW50ID0gbmV3IFZlY3RvcjIoICggY2VudGVyRGV2aWNlUG9pbnQueCArIDEgKSAqIHRoaXMuc2NyZWVuVmlldy5zY3JlZW5XaWR0aCAvIDIsXHJcbiAgICAgICAgICAoIC1jZW50ZXJEZXZpY2VQb2ludC55ICsgMSApICogdGhpcy5zY3JlZW5WaWV3LnNjcmVlbkhlaWdodCAvIDIgKTtcclxuICAgICAgICBjb25zdCBzY3JlZW5NaWRQb2ludCA9IG5ldyBWZWN0b3IyKCAoIG1pZERldmljZVBvaW50LnggKyAxICkgKiB0aGlzLnNjcmVlblZpZXcuc2NyZWVuV2lkdGggLyAyLFxyXG4gICAgICAgICAgKCAtbWlkRGV2aWNlUG9pbnQueSArIDEgKSAqIHRoaXMuc2NyZWVuVmlldy5zY3JlZW5IZWlnaHQgLyAyICk7XHJcblxyXG4gICAgICAgIGxldCBsYWJlbFN0cmluZyA9IGAke1V0aWxzLnRvRml4ZWQoIGFuZ2xlLCAxICl9wrBgO1xyXG4gICAgICAgIHdoaWxlICggbGFiZWxTdHJpbmcubGVuZ3RoIDwgNSApIHtcclxuICAgICAgICAgIC8vIGhhbmRsZSBzaW5nbGUtZGlnaXQgbGFiZWxzIGJ5IHBhZGRpbmcgdGhlbVxyXG4gICAgICAgICAgbGFiZWxTdHJpbmcgPSBgMCR7bGFiZWxTdHJpbmd9YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubGFiZWwuc2V0TGFiZWwoIGxhYmVsU3RyaW5nLCB0aGlzLnZpZXdPcGFjaXR5LCBzY3JlZW5DZW50ZXJQb2ludCwgc2NyZWVuTWlkUG9pbnQsIGxheW91dFNjYWxlICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sYWJlbC51bnNldExhYmVsKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5sYWJlbC51bnNldExhYmVsKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBAcHVibGljXHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgdGhlIGJyaWdodG5lc3MgKGFscGhhKSBvZiBhIGJvbmQgYW5nbGUgYmFzZWQgb24gdGhlIG9yaWVudGF0aW9ucyBvZiB0aGUgdHdvIHJhZGlhbCBhdG9tcywgdGhlIGNhbWVyYSxcclxuICAgKiBhbmQgdGhlIHRvdGFsIG51bWJlciBvZiBib25kcyBhcm91bmQgb3VyIGNlbnRyYWwgYXRvbS5cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IGFEaXIgLSBUaGUgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgdG93YXJkcyB0aGUgZmlyc3QgcmFkaWFsIGF0b21cclxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IGJEaXIgLSBUaGUgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgdG93YXJkcyB0aGUgc2Vjb25kIHJhZGlhbCBhdG9tXHJcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBsb2NhbENhbWVyYU9yaWVudGF0aW9uIC0gQSB1bml0IHZlY3RvciBpbiB0aGUgbW9sZWN1bGUncyBsb2NhbCBjb29yZGlhbnRlIHNwYWNlIHBvaW50aW5nXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGNhbWVyYS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYm9uZFF1YW50aXR5IC0gVGhlIHRvdGFsIG51bWJlciBvZiBib25kcyBhcm91bmQgdGhlIGNlbnRyYWwgYXRvbVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjYWxjdWxhdGVCcmlnaHRuZXNzKCBhRGlyLCBiRGlyLCBsb2NhbENhbWVyYU9yaWVudGF0aW9uLCBib25kUXVhbnRpdHkgKSB7XHJcbiAgICAvLyBpZiB0aGVyZSBhcmUgbGVzcyB0aGFuIDMgYm9uZHMsIGFsd2F5cyBzaG93IHRoZSBib25kIGFuZ2xlLlxyXG4gICAgaWYgKCBib25kUXVhbnRpdHkgPD0gMiApIHtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYSBjb21iaW5lZCBtZWFzdXJlIG9mIGhvdyBjbG9zZSB0aGUgYW5nbGVzIGFyZSBBTkQgaG93IG9ydGhvZ29uYWwgdGhleSBhcmUgdG8gdGhlIGNhbWVyYVxyXG4gICAgY29uc3QgYnJpZ2h0bmVzcyA9IE1hdGguYWJzKCBhRGlyLmNyb3NzKCBiRGlyICkuZG90KCBsb2NhbENhbWVyYU9yaWVudGF0aW9uICkgKTtcclxuXHJcbiAgICBjb25zdCBsb3dUaHJlc2hvbGQgPSBCb25kQW5nbGVWaWV3LkxPV19USFJFU0hPTERTWyBib25kUXVhbnRpdHkgXTtcclxuICAgIGNvbnN0IGhpZ2hUaHJlc2hvbGQgPSBCb25kQW5nbGVWaWV3LkhJR0hfVEhSRVNIT0xEU1sgYm9uZFF1YW50aXR5IF07XHJcblxyXG4gICAgY29uc3QgaW50ZXJwb2xhdGVkVmFsdWUgPSBicmlnaHRuZXNzIC8gKCBoaWdoVGhyZXNob2xkIC0gbG93VGhyZXNob2xkICkgLSBsb3dUaHJlc2hvbGQgLyAoIGhpZ2hUaHJlc2hvbGQgLSBsb3dUaHJlc2hvbGQgKTtcclxuXHJcbiAgICByZXR1cm4gVXRpbHMuY2xhbXAoIGludGVycG9sYXRlZFZhbHVlLCAwLCAxICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaGV0aGVyIG91ciBjb25kaXRpb24gZm9yIHNlbWljaXJjbGUgKGFsbW9zdCAxODAtZGVncmVlIGJvbmQgYW5nbGUpIGlzIG1ldCwgYXMgd2UgbmVlZCB0byBzdGFiaWxpemUgdGhlXHJcbiAgICogcG9zaXRpb25pbmcgaW4gdGhpcyBjYXNlLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHN0YXJ0RGlyXHJcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBlbmREaXJcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBzdGF0aWMgaXNBcHByb3hpbWF0ZVNlbWljaXJjbGUoIHN0YXJ0RGlyLCBlbmREaXIgKSB7XHJcbiAgICByZXR1cm4gTWF0aC5hY29zKCBVdGlscy5jbGFtcCggc3RhcnREaXIuZG90KCBlbmREaXIgKSwgLTEsIDEgKSApID49IDMuMTI0MTQ7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBkb3QgcHJvZHVjdCBiZXR3ZWVuIHRoZSBjYW1lcmEgZGlyZWN0aW9uIGFuZCBib25kIGFuZ2xlIG5vcm1hbCBpcyBiZWxvdyBMT1dfVEhSRVNIT0xEU1tib25kT3JkZXJdID0+IGFscGhhID0gMFxyXG4vLyBkb3QgcHJvZHVjdCBiZXR3ZWVuIHRoZSBjYW1lcmEgZGlyZWN0aW9uIGFuZCBib25kIGFuZ2xlIG5vcm1hbCBpcyBhYm92ZSBMT1dfVEhSRVNIT0xEU1tISUdIX1RIUkVTSE9MRFNdID0+IGFscGhhID0gMVxyXG5Cb25kQW5nbGVWaWV3LkxPV19USFJFU0hPTERTID0gWyAwLCAwLCAwLCAwLjEsIDAuMzUsIDAuNDUsIDAuNSBdOyAvLyBAcHVibGljXHJcbkJvbmRBbmdsZVZpZXcuSElHSF9USFJFU0hPTERTID0gWyAwLCAwLCAwLCAwLjUsIDAuNTUsIDAuNjUsIDAuNzUgXTtcclxuXHJcbi8vIEBwdWJsaWMge251bWJlcn0gLSByYWRpdXMsIGluIHZpZXcgdW5pdHNcclxuQm9uZEFuZ2xlVmlldy5yYWRpdXMgPSA1O1xyXG5cclxubW9sZWN1bGVTaGFwZXMucmVnaXN0ZXIoICdCb25kQW5nbGVWaWV3JywgQm9uZEFuZ2xlVmlldyApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQm9uZEFuZ2xlVmlldzsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFNLGtDQUFrQztBQUN0RCxPQUFPQyxLQUFLLE1BQU0sZ0NBQWdDO0FBQ2xELE9BQU9DLE9BQU8sTUFBTSxrQ0FBa0M7QUFDdEQsT0FBT0MsT0FBTyxNQUFNLGtDQUFrQztBQUN0RCxTQUFTQyx3QkFBd0IsUUFBUSxzQ0FBc0M7QUFDL0UsT0FBT0MsY0FBYyxNQUFNLDRCQUE0QjtBQUN2RCxPQUFPQyxTQUFTLE1BQU0sMEJBQTBCO0FBRWhELE1BQU1DLGFBQWEsU0FBU0MsS0FBSyxDQUFDQyxRQUFRLENBQUM7RUFDekM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsVUFBVUEsQ0FBRUMsVUFBVSxFQUFFQyxzQkFBc0IsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFHO0lBQ2hGQyxNQUFNLElBQUlBLE1BQU0sQ0FBRUgsTUFBTSxZQUFZUixTQUFVLENBQUM7SUFDL0NXLE1BQU0sSUFBSUEsTUFBTSxDQUFFRixNQUFNLFlBQVlULFNBQVUsQ0FBQztJQUUvQyxJQUFJLENBQUNRLE1BQU0sR0FBR0EsTUFBTSxDQUFDLENBQUM7SUFDdEIsSUFBSSxDQUFDQyxNQUFNLEdBQUdBLE1BQU0sQ0FBQyxDQUFDO0lBQ3RCLElBQUksQ0FBQ0MsS0FBSyxHQUFHQSxLQUFLLENBQUMsQ0FBQztJQUNwQixJQUFJLENBQUNFLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUN0QixJQUFJLENBQUNDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQzs7SUFFakIsSUFBSSxDQUFDUixVQUFVLEdBQUdBLFVBQVUsQ0FBQyxDQUFDO0lBQzlCLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUdBLHNCQUFzQixDQUFDLENBQUM7SUFDdEQsSUFBSSxDQUFDQyxRQUFRLEdBQUdBLFFBQVEsQ0FBQyxDQUFDOztJQUUxQixJQUFJLENBQUNPLFdBQVcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN0QixJQUFJLENBQUNDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNwQixJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJLENBQUMsQ0FBQztJQUMxQixJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJLENBQUMsQ0FBQztFQUMxQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFQyxPQUFPQSxDQUFBLEVBQUc7SUFDUixJQUFJLENBQUNWLE1BQU0sR0FBRyxJQUFJO0lBQ2xCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUk7O0lBRWxCO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VVLFVBQVVBLENBQUVDLFlBQVksRUFBRUMsc0JBQXNCLEVBQUc7SUFDakQsTUFBTUMsSUFBSSxHQUFHLElBQUksQ0FBQ2QsTUFBTSxDQUFDZSxXQUFXO0lBQ3BDLE1BQU1DLElBQUksR0FBRyxJQUFJLENBQUNmLE1BQU0sQ0FBQ2MsV0FBVztJQUVwQyxJQUFJLENBQUNULFdBQVcsR0FBRyxJQUFJLENBQUNSLHNCQUFzQixDQUFDbUIsS0FBSyxHQUFHeEIsYUFBYSxDQUFDeUIsbUJBQW1CLENBQUVKLElBQUksRUFBRUUsSUFBSSxFQUFFSCxzQkFBc0IsRUFBRSxJQUFJLENBQUNkLFFBQVEsQ0FBQ29CLFdBQVcsQ0FBQ0MsTUFBTyxDQUFDLEdBQUcsQ0FBQzs7SUFFcEs7SUFDQSxJQUFJLENBQUNiLFNBQVMsR0FBR2MsSUFBSSxDQUFDQyxJQUFJLENBQUVuQyxLQUFLLENBQUNvQyxLQUFLLENBQUVULElBQUksQ0FBQ1UsR0FBRyxDQUFFUixJQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFFLENBQUUsQ0FBQzs7SUFFcEU7SUFDQTtJQUNBLE1BQU1TLHVCQUF1QixHQUFHaEMsYUFBYSxDQUFDZ0MsdUJBQXVCLENBQUVYLElBQUksRUFBRUUsSUFBSyxDQUFDO0lBQ25GLElBQUtTLHVCQUF1QixFQUFHO01BQzdCLElBQUssQ0FBQ2IsWUFBWSxFQUFHO1FBQ25CQSxZQUFZLEdBQUd2QixPQUFPLENBQUNxQyxNQUFNLENBQUNDLEtBQUssQ0FBRWxDLGFBQWEsQ0FBQ1ksTUFBTyxDQUFDO01BQzdEO01BQ0EsTUFBTXVCLGVBQWUsR0FBR2hCLFlBQVksQ0FBQ2lCLFVBQVUsQ0FBQyxDQUFDOztNQUVqRDtNQUNBLE1BQU1DLFFBQVEsR0FBR2hCLElBQUksQ0FBQ2lCLEtBQUssQ0FBRUgsZUFBZ0IsQ0FBQyxDQUFDSSxJQUFJLENBQUVKLGVBQWUsQ0FBQ0csS0FBSyxDQUFFZixJQUFLLENBQUUsQ0FBQztNQUNwRixNQUFNaUIsWUFBWSxHQUFHSCxRQUFRLENBQUNJLFNBQVMsR0FBRyxDQUFDLEdBQUdKLFFBQVEsQ0FBQ0QsVUFBVSxDQUFDLENBQUMsR0FBRyxJQUFJeEMsT0FBTyxDQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBRSxDQUFDOztNQUU1RjtNQUNBLE1BQU04QyxlQUFlLEdBQUdyQixJQUFJLENBQUNzQixLQUFLLENBQUVwQixJQUFLLENBQUMsQ0FBQ2EsVUFBVSxDQUFDLENBQUM7O01BRXZEO01BQ0EsSUFBSSxDQUFDcEIsVUFBVSxHQUFHMEIsZUFBZSxDQUFDQyxLQUFLLENBQUVILFlBQVksQ0FBQ04sS0FBSyxDQUFFTSxZQUFZLENBQUNULEdBQUcsQ0FBRVcsZUFBZ0IsQ0FBRSxDQUFFLENBQUMsQ0FBQ04sVUFBVSxDQUFDLENBQUM7O01BRWpIO01BQ0EsSUFBSSxDQUFDckIsWUFBWSxHQUFHeUIsWUFBWSxDQUFDRixLQUFLLENBQUUsSUFBSSxDQUFDdEIsVUFBVyxDQUFDLENBQUNvQixVQUFVLENBQUMsQ0FBQztJQUN4RSxDQUFDLE1BQ0k7TUFDSCxJQUFJLENBQUNyQixZQUFZLEdBQUdNLElBQUksQ0FBQ2tCLElBQUksQ0FBRWhCLElBQUssQ0FBQyxDQUFDYSxVQUFVLENBQUMsQ0FBQztNQUNsRCxJQUFJLENBQUNwQixVQUFVLEdBQUdLLElBQUksQ0FBQ3NCLEtBQUssQ0FBRSxJQUFJLENBQUM1QixZQUFZLENBQUNtQixLQUFLLENBQUViLElBQUksQ0FBQ1UsR0FBRyxDQUFFLElBQUksQ0FBQ2hCLFlBQWEsQ0FBRSxDQUFFLENBQUM7TUFDeEY7TUFDQSxJQUFLLElBQUksQ0FBQ0MsVUFBVSxDQUFDeUIsU0FBUyxHQUFHLENBQUMsRUFBRztRQUNuQyxJQUFJLENBQUN6QixVQUFVLENBQUM0QixTQUFTLENBQUMsQ0FBQztNQUM3QjtJQUNGO0lBRUEsSUFBSSxDQUFDakMsUUFBUSxHQUFHLElBQUksQ0FBQ0ksWUFBWSxDQUFDbUIsS0FBSyxDQUFFbEMsYUFBYSxDQUFDWSxNQUFPLENBQUM7O0lBRS9EO0lBQ0EsSUFBSyxJQUFJLENBQUNDLFdBQVcsS0FBSyxDQUFDLEVBQUc7TUFDNUIsTUFBTWdDLGlCQUFpQixHQUFHLElBQUk1QyxLQUFLLENBQUNMLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUMvQyxNQUFNa0QsY0FBYyxHQUFHLElBQUk3QyxLQUFLLENBQUNMLE9BQU8sQ0FBQyxDQUFDLENBQUNtRCxJQUFJLENBQUUsSUFBSSxDQUFDcEMsUUFBUyxDQUFDOztNQUVoRTtNQUNBLElBQUksQ0FBQ3FDLE1BQU0sQ0FBQ0MsWUFBWSxDQUFFSixpQkFBa0IsQ0FBQztNQUM3QyxJQUFJLENBQUNHLE1BQU0sQ0FBQ0MsWUFBWSxDQUFFSCxjQUFlLENBQUM7O01BRTFDO01BQ0E7TUFDQSxJQUFJLENBQUMxQyxVQUFVLENBQUM4QyxpQ0FBaUMsQ0FBRUwsaUJBQWtCLENBQUM7TUFDdEUsSUFBSSxDQUFDekMsVUFBVSxDQUFDOEMsaUNBQWlDLENBQUVKLGNBQWUsQ0FBQztNQUNuRSxNQUFNSyxXQUFXLEdBQUcsSUFBSSxDQUFDL0MsVUFBVSxDQUFDZ0QsY0FBYyxDQUFFLElBQUkzRCxPQUFPLENBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUNXLFVBQVUsQ0FBQ2lELFdBQVcsRUFBRSxJQUFJLENBQUNqRCxVQUFVLENBQUNrRCxZQUFhLENBQUUsQ0FBQyxHQUFHekQsd0JBQXdCLENBQUMwRCxRQUFRLENBQUNDLGNBQWMsQ0FBQ2hDLEtBQUssQ0FBQ2lDLGNBQWMsQ0FBQyxDQUFDLENBQUNDLENBQUM7TUFFaE4sTUFBTUMsS0FBSyxHQUFHdEMsSUFBSSxDQUFDdUMsWUFBWSxDQUFFckMsSUFBSyxDQUFDLEdBQUcsR0FBRyxHQUFHSyxJQUFJLENBQUNpQyxFQUFFOztNQUV2RDtNQUNBO01BQ0E7TUFDQSxJQUFLQyxRQUFRLENBQUVqQixpQkFBaUIsQ0FBQ2EsQ0FBRSxDQUFDLElBQUlJLFFBQVEsQ0FBRWpCLGlCQUFpQixDQUFDa0IsQ0FBRSxDQUFDLEVBQUc7UUFDeEU7UUFDQSxNQUFNQyxpQkFBaUIsR0FBRyxJQUFJckUsT0FBTyxDQUFFLENBQUVrRCxpQkFBaUIsQ0FBQ2EsQ0FBQyxHQUFHLENBQUMsSUFBSyxJQUFJLENBQUN0RCxVQUFVLENBQUNpRCxXQUFXLEdBQUcsQ0FBQyxFQUNsRyxDQUFFLENBQUNSLGlCQUFpQixDQUFDa0IsQ0FBQyxHQUFHLENBQUMsSUFBSyxJQUFJLENBQUMzRCxVQUFVLENBQUNrRCxZQUFZLEdBQUcsQ0FBRSxDQUFDO1FBQ25FLE1BQU1XLGNBQWMsR0FBRyxJQUFJdEUsT0FBTyxDQUFFLENBQUVtRCxjQUFjLENBQUNZLENBQUMsR0FBRyxDQUFDLElBQUssSUFBSSxDQUFDdEQsVUFBVSxDQUFDaUQsV0FBVyxHQUFHLENBQUMsRUFDNUYsQ0FBRSxDQUFDUCxjQUFjLENBQUNpQixDQUFDLEdBQUcsQ0FBQyxJQUFLLElBQUksQ0FBQzNELFVBQVUsQ0FBQ2tELFlBQVksR0FBRyxDQUFFLENBQUM7UUFFaEUsSUFBSVksV0FBVyxHQUFJLEdBQUV4RSxLQUFLLENBQUN5RSxPQUFPLENBQUVSLEtBQUssRUFBRSxDQUFFLENBQUUsR0FBRTtRQUNqRCxPQUFRTyxXQUFXLENBQUN2QyxNQUFNLEdBQUcsQ0FBQyxFQUFHO1VBQy9CO1VBQ0F1QyxXQUFXLEdBQUksSUFBR0EsV0FBWSxFQUFDO1FBQ2pDO1FBRUEsSUFBSSxDQUFDekQsS0FBSyxDQUFDMkQsUUFBUSxDQUFFRixXQUFXLEVBQUUsSUFBSSxDQUFDckQsV0FBVyxFQUFFbUQsaUJBQWlCLEVBQUVDLGNBQWMsRUFBRWQsV0FBWSxDQUFDO01BQ3RHLENBQUMsTUFDSTtRQUNILElBQUksQ0FBQzFDLEtBQUssQ0FBQzRELFVBQVUsQ0FBQyxDQUFDO01BQ3pCO0lBRUYsQ0FBQyxNQUNJO01BQ0gsSUFBSSxDQUFDNUQsS0FBSyxDQUFDNEQsVUFBVSxDQUFDLENBQUM7SUFDekI7RUFDRjs7RUFFQTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBTzVDLG1CQUFtQkEsQ0FBRUosSUFBSSxFQUFFRSxJQUFJLEVBQUVILHNCQUFzQixFQUFFa0QsWUFBWSxFQUFHO0lBQzdFO0lBQ0EsSUFBS0EsWUFBWSxJQUFJLENBQUMsRUFBRztNQUN2QixPQUFPLENBQUM7SUFDVjs7SUFFQTtJQUNBLE1BQU1DLFVBQVUsR0FBRzNDLElBQUksQ0FBQzRDLEdBQUcsQ0FBRW5ELElBQUksQ0FBQ2lCLEtBQUssQ0FBRWYsSUFBSyxDQUFDLENBQUNRLEdBQUcsQ0FBRVgsc0JBQXVCLENBQUUsQ0FBQztJQUUvRSxNQUFNcUQsWUFBWSxHQUFHekUsYUFBYSxDQUFDMEUsY0FBYyxDQUFFSixZQUFZLENBQUU7SUFDakUsTUFBTUssYUFBYSxHQUFHM0UsYUFBYSxDQUFDNEUsZUFBZSxDQUFFTixZQUFZLENBQUU7SUFFbkUsTUFBTU8saUJBQWlCLEdBQUdOLFVBQVUsSUFBS0ksYUFBYSxHQUFHRixZQUFZLENBQUUsR0FBR0EsWUFBWSxJQUFLRSxhQUFhLEdBQUdGLFlBQVksQ0FBRTtJQUV6SCxPQUFPL0UsS0FBSyxDQUFDb0MsS0FBSyxDQUFFK0MsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLENBQUUsQ0FBQztFQUMvQzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxPQUFPN0MsdUJBQXVCQSxDQUFFOEMsUUFBUSxFQUFFQyxNQUFNLEVBQUc7SUFDakQsT0FBT25ELElBQUksQ0FBQ0MsSUFBSSxDQUFFbkMsS0FBSyxDQUFDb0MsS0FBSyxDQUFFZ0QsUUFBUSxDQUFDL0MsR0FBRyxDQUFFZ0QsTUFBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBRSxDQUFFLENBQUMsSUFBSSxPQUFPO0VBQzdFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBL0UsYUFBYSxDQUFDMEUsY0FBYyxHQUFHLENBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFFLENBQUMsQ0FBQztBQUNsRTFFLGFBQWEsQ0FBQzRFLGVBQWUsR0FBRyxDQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBRTs7QUFFbEU7QUFDQTVFLGFBQWEsQ0FBQ1ksTUFBTSxHQUFHLENBQUM7QUFFeEJkLGNBQWMsQ0FBQ2tGLFFBQVEsQ0FBRSxlQUFlLEVBQUVoRixhQUFjLENBQUM7QUFFekQsZUFBZUEsYUFBYSJ9