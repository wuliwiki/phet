// Copyright 2022, University of Colorado Boulder

/**
 * Describes a 1d complete (fully defined for any number) function, where values are extrapolated given the final end
 * points.
 *
 * E.g. if the points (0,0) and (1,1) are provided, it represents the function f(x) = x for ALL values, especially
 * values outside of the range [0,1]. For example, f(6) = 6.
 *
 * If a single point is provided, it represents a constant function.
 *
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import dot from './dot.js';
import Utils from './Utils.js';
import Vector2 from './Vector2.js';
class CompletePiecewiseLinearFunction {
  // Assumed to be sorted by x value, and continuous
  constructor(points) {
    assert && assert(points.length > 0);
    assert && points.forEach((point, i) => {
      if (i < points.length - 1) {
        assert && assert(point.x < points[i + 1].x, 'Points should be strictly increasing in x value (ordered by their x value)');
      }
    });

    // We're going to remove collinear points, so we create an extra copy
    this.points = points.slice();

    // NOTE: The removal of collinear points helps improve performance, since we sometimes need to "expand" the number
    // of points. Repeated minimums/maximums for many inputs could otherwise become quite slow.
    for (let i = 0; i < this.points.length - 2; i++) {
      const a = this.points[i];
      const b = this.points[i + 1];
      const c = this.points[i + 2];
      if (Utils.arePointsCollinear(a, b, c)) {
        this.points.splice(i + 1, 1);
        i--;
      }
    }
  }

  /**
   * Returns the pair of points that the x value is defined by.
   *
   * NOTE: x may NOT be contained in these points, if it's either less than or greater than any points in the points
   * list.
   */
  findMatchingPair(x) {
    assert && assert(this.points.length > 1);
    let i = 0;
    while (i < this.points.length - 2 && this.points[i + 1].x < x) {
      i++;
    }
    return [this.points[i], this.points[i + 1]];
  }

  /**
   * Evaluates the function at the given x value, e.g. returns f(x).
   */
  evaluate(x) {
    if (this.points.length === 1) {
      return this.points[0].y;
    } else {
      const [leftPoint, rightPoint] = this.findMatchingPair(x);
      if (leftPoint.x === x) {
        return leftPoint.y;
      } else if (rightPoint.x === x) {
        return rightPoint.y;
      } else {
        return Utils.linear(leftPoint.x, rightPoint.x, leftPoint.y, rightPoint.y, x);
      }
    }
  }

  /**
   * Returns an array that combines sorted unique x-values provided by this function and/or the other function.
   */
  getCombinedXValues(linearFunction) {
    return CompletePiecewiseLinearFunction.sortedUniqueEpsilon(this.points.map(point => point.x).concat(linearFunction.points.map(point => point.x)));
  }

  /**
   * Returns an array that combines the sorted unique x-values included in this function and/or the other function, OR the unique x-values
   * that result from the intersection of the two functions.
   */
  getIntersectedXValues(linearFunction) {
    const xValues = this.getCombinedXValues(linearFunction);
    const newXValues = [];
    for (let i = 0; i < xValues.length - 1; i++) {
      const leftX = xValues[i];
      const rightX = xValues[i + 1];
      const intersectionPoint = Utils.lineLineIntersection(
      // The linear function defined in this
      new Vector2(leftX, this.evaluate(leftX)), new Vector2(rightX, this.evaluate(rightX)),
      // The passed in argument linear function
      new Vector2(leftX, linearFunction.evaluate(leftX)), new Vector2(rightX, linearFunction.evaluate(rightX)));
      if (intersectionPoint && (
      // If it's our first pair of points, don't filter out points that are on the left side of the left point
      i === 0 || intersectionPoint.x > leftX) && (
      // If it's our last pair of points, don't filter out points that are on the right side of the right point
      i === xValues.length - 2 || intersectionPoint.x < rightX)) {
        newXValues.push(intersectionPoint.x);
      }
    }

    // Remove duplicate values above and sort them
    const criticalXValues = CompletePiecewiseLinearFunction.sortedUniqueEpsilon([...xValues, ...newXValues]);

    // To capture the slope at the start/end, we'll add extra points to guarantee this. If they're duplicated, they'll
    // be removed during the collinear check on construction.
    return [criticalXValues[0] - 1, ...criticalXValues, criticalXValues[criticalXValues.length - 1] + 1];
  }

  /**
   * Returns a new function that's the result of applying the binary operation at the given x values.
   */
  binaryXOperation(linearFunction, operation, xValues) {
    return new CompletePiecewiseLinearFunction(xValues.map(x => {
      return new Vector2(x, operation(this.evaluate(x), linearFunction.evaluate(x)));
    }));
  }

  /**
   * Returns a new function that's the result of applying the binary operation at the x values that already occur
   * in each function.
   */
  binaryPointwiseOperation(linearFunction, operation) {
    return this.binaryXOperation(linearFunction, operation, this.getCombinedXValues(linearFunction));
  }

  /**
   * Returns a new function that's the result of applying the binary operation at the x values that either occur in
   * each function OR at the intersection of the two functions.
   */
  binaryIntersectingOperation(linearFunction, operation) {
    return this.binaryXOperation(linearFunction, operation, this.getIntersectedXValues(linearFunction));
  }

  /**
   * Returns a CompletePiecewiseLinearFunction that's the result of adding the two functions.
   */
  plus(linearFunction) {
    return this.binaryPointwiseOperation(linearFunction, (a, b) => a + b);
  }

  /**
   * Returns a CompletePiecewiseLinearFunction that's the result of subtracting the two functions.
   */
  minus(linearFunction) {
    return this.binaryPointwiseOperation(linearFunction, (a, b) => a - b);
  }

  /**
   * Returns a CompletePiecewiseLinearFunction that's the result of taking the minimum of the two functions
   */
  min(linearFunction) {
    return this.binaryIntersectingOperation(linearFunction, Math.min);
  }

  /**
   * Returns a CompletePiecewiseLinearFunction that's the result of taking the maximum of the two functions
   */
  max(linearFunction) {
    return this.binaryIntersectingOperation(linearFunction, Math.max);
  }

  /**
   * Allows redefining or clamping/truncating the function by only representing it from the given x values
   */
  withXValues(xValues) {
    return new CompletePiecewiseLinearFunction(xValues.map(x => new Vector2(x, this.evaluate(x))));
  }

  /**
   * Returns an inverted form of the function (assuming it is monotonically increasing or monotonically decreasing)
   */
  inverted() {
    const points = this.points.map(point => new Vector2(point.y, point.x));

    // NOTE: We'll rely on the constructor to make sure that the inverse is valid. Here we'll handle the monotonically
    // decreasing case (which is invertible, just needs a reversal of points)
    if (points.length > 1 && points[0].x > points[1].x) {
      points.reverse();
    }
    return new CompletePiecewiseLinearFunction(points);
  }
  static sum(...functions) {
    return functions.reduce((a, b) => a.plus(b));
  }
  static min(...functions) {
    return functions.reduce((a, b) => a.min(b));
  }
  static max(...functions) {
    return functions.reduce((a, b) => a.max(b));
  }
  static constant(y) {
    return new CompletePiecewiseLinearFunction([new Vector2(0, y)]);
  }

  // Represents the function ax+b
  static linear(a, b) {
    return new CompletePiecewiseLinearFunction([new Vector2(0, b), new Vector2(1, a + b)]);
  }

  /**
   * Returns a sorted list of the input numbers, ensuring no duplicates within a specified epsilon value
   */
  static sortedUniqueEpsilon(numbers, epsilon = 1e-10) {
    numbers = _.sortBy(numbers);
    for (let i = 0; i < numbers.length - 1; i++) {
      if (Math.abs(numbers[i] - numbers[i + 1]) < epsilon) {
        numbers.splice(i, 1);
        i--;
      }
    }
    return numbers;
  }
}
dot.register('CompletePiecewiseLinearFunction', CompletePiecewiseLinearFunction);
export default CompletePiecewiseLinearFunction;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3QiLCJVdGlscyIsIlZlY3RvcjIiLCJDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uIiwiY29uc3RydWN0b3IiLCJwb2ludHMiLCJhc3NlcnQiLCJsZW5ndGgiLCJmb3JFYWNoIiwicG9pbnQiLCJpIiwieCIsInNsaWNlIiwiYSIsImIiLCJjIiwiYXJlUG9pbnRzQ29sbGluZWFyIiwic3BsaWNlIiwiZmluZE1hdGNoaW5nUGFpciIsImV2YWx1YXRlIiwieSIsImxlZnRQb2ludCIsInJpZ2h0UG9pbnQiLCJsaW5lYXIiLCJnZXRDb21iaW5lZFhWYWx1ZXMiLCJsaW5lYXJGdW5jdGlvbiIsInNvcnRlZFVuaXF1ZUVwc2lsb24iLCJtYXAiLCJjb25jYXQiLCJnZXRJbnRlcnNlY3RlZFhWYWx1ZXMiLCJ4VmFsdWVzIiwibmV3WFZhbHVlcyIsImxlZnRYIiwicmlnaHRYIiwiaW50ZXJzZWN0aW9uUG9pbnQiLCJsaW5lTGluZUludGVyc2VjdGlvbiIsInB1c2giLCJjcml0aWNhbFhWYWx1ZXMiLCJiaW5hcnlYT3BlcmF0aW9uIiwib3BlcmF0aW9uIiwiYmluYXJ5UG9pbnR3aXNlT3BlcmF0aW9uIiwiYmluYXJ5SW50ZXJzZWN0aW5nT3BlcmF0aW9uIiwicGx1cyIsIm1pbnVzIiwibWluIiwiTWF0aCIsIm1heCIsIndpdGhYVmFsdWVzIiwiaW52ZXJ0ZWQiLCJyZXZlcnNlIiwic3VtIiwiZnVuY3Rpb25zIiwicmVkdWNlIiwiY29uc3RhbnQiLCJudW1iZXJzIiwiZXBzaWxvbiIsIl8iLCJzb3J0QnkiLCJhYnMiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkNvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIDFkIGNvbXBsZXRlIChmdWxseSBkZWZpbmVkIGZvciBhbnkgbnVtYmVyKSBmdW5jdGlvbiwgd2hlcmUgdmFsdWVzIGFyZSBleHRyYXBvbGF0ZWQgZ2l2ZW4gdGhlIGZpbmFsIGVuZFxyXG4gKiBwb2ludHMuXHJcbiAqXHJcbiAqIEUuZy4gaWYgdGhlIHBvaW50cyAoMCwwKSBhbmQgKDEsMSkgYXJlIHByb3ZpZGVkLCBpdCByZXByZXNlbnRzIHRoZSBmdW5jdGlvbiBmKHgpID0geCBmb3IgQUxMIHZhbHVlcywgZXNwZWNpYWxseVxyXG4gKiB2YWx1ZXMgb3V0c2lkZSBvZiB0aGUgcmFuZ2UgWzAsMV0uIEZvciBleGFtcGxlLCBmKDYpID0gNi5cclxuICpcclxuICogSWYgYSBzaW5nbGUgcG9pbnQgaXMgcHJvdmlkZWQsIGl0IHJlcHJlc2VudHMgYSBjb25zdGFudCBmdW5jdGlvbi5cclxuICpcclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBkb3QgZnJvbSAnLi9kb3QuanMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9VdGlscy5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4vVmVjdG9yMi5qcyc7XHJcblxyXG5jbGFzcyBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uIHtcclxuXHJcbiAgcHVibGljIHBvaW50czogVmVjdG9yMltdO1xyXG5cclxuICAvLyBBc3N1bWVkIHRvIGJlIHNvcnRlZCBieSB4IHZhbHVlLCBhbmQgY29udGludW91c1xyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcG9pbnRzOiBWZWN0b3IyW10gKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwb2ludHMubGVuZ3RoID4gMCApO1xyXG4gICAgYXNzZXJ0ICYmIHBvaW50cy5mb3JFYWNoKCAoIHBvaW50LCBpICkgPT4ge1xyXG4gICAgICBpZiAoIGkgPCBwb2ludHMubGVuZ3RoIC0gMSApIHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwb2ludC54IDwgcG9pbnRzWyBpICsgMSBdLngsXHJcbiAgICAgICAgICAnUG9pbnRzIHNob3VsZCBiZSBzdHJpY3RseSBpbmNyZWFzaW5nIGluIHggdmFsdWUgKG9yZGVyZWQgYnkgdGhlaXIgeCB2YWx1ZSknICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBXZSdyZSBnb2luZyB0byByZW1vdmUgY29sbGluZWFyIHBvaW50cywgc28gd2UgY3JlYXRlIGFuIGV4dHJhIGNvcHlcclxuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzLnNsaWNlKCk7XHJcblxyXG4gICAgLy8gTk9URTogVGhlIHJlbW92YWwgb2YgY29sbGluZWFyIHBvaW50cyBoZWxwcyBpbXByb3ZlIHBlcmZvcm1hbmNlLCBzaW5jZSB3ZSBzb21ldGltZXMgbmVlZCB0byBcImV4cGFuZFwiIHRoZSBudW1iZXJcclxuICAgIC8vIG9mIHBvaW50cy4gUmVwZWF0ZWQgbWluaW11bXMvbWF4aW11bXMgZm9yIG1hbnkgaW5wdXRzIGNvdWxkIG90aGVyd2lzZSBiZWNvbWUgcXVpdGUgc2xvdy5cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aCAtIDI7IGkrKyApIHtcclxuICAgICAgY29uc3QgYSA9IHRoaXMucG9pbnRzWyBpIF07XHJcbiAgICAgIGNvbnN0IGIgPSB0aGlzLnBvaW50c1sgaSArIDEgXTtcclxuICAgICAgY29uc3QgYyA9IHRoaXMucG9pbnRzWyBpICsgMiBdO1xyXG5cclxuICAgICAgaWYgKCBVdGlscy5hcmVQb2ludHNDb2xsaW5lYXIoIGEsIGIsIGMgKSApIHtcclxuICAgICAgICB0aGlzLnBvaW50cy5zcGxpY2UoIGkgKyAxLCAxICk7XHJcbiAgICAgICAgaS0tO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBwYWlyIG9mIHBvaW50cyB0aGF0IHRoZSB4IHZhbHVlIGlzIGRlZmluZWQgYnkuXHJcbiAgICpcclxuICAgKiBOT1RFOiB4IG1heSBOT1QgYmUgY29udGFpbmVkIGluIHRoZXNlIHBvaW50cywgaWYgaXQncyBlaXRoZXIgbGVzcyB0aGFuIG9yIGdyZWF0ZXIgdGhhbiBhbnkgcG9pbnRzIGluIHRoZSBwb2ludHNcclxuICAgKiBsaXN0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBmaW5kTWF0Y2hpbmdQYWlyKCB4OiBudW1iZXIgKTogWyBWZWN0b3IyLCBWZWN0b3IyIF0ge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5wb2ludHMubGVuZ3RoID4gMSApO1xyXG5cclxuICAgIGxldCBpID0gMDtcclxuICAgIHdoaWxlICggaSA8IHRoaXMucG9pbnRzLmxlbmd0aCAtIDIgJiYgdGhpcy5wb2ludHNbIGkgKyAxIF0ueCA8IHggKSB7XHJcbiAgICAgIGkrKztcclxuICAgIH1cclxuICAgIHJldHVybiBbIHRoaXMucG9pbnRzWyBpIF0sIHRoaXMucG9pbnRzWyBpICsgMSBdIF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFdmFsdWF0ZXMgdGhlIGZ1bmN0aW9uIGF0IHRoZSBnaXZlbiB4IHZhbHVlLCBlLmcuIHJldHVybnMgZih4KS5cclxuICAgKi9cclxuICBwdWJsaWMgZXZhbHVhdGUoIHg6IG51bWJlciApOiBudW1iZXIge1xyXG4gICAgaWYgKCB0aGlzLnBvaW50cy5sZW5ndGggPT09IDEgKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBvaW50c1sgMCBdLnk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgY29uc3QgWyBsZWZ0UG9pbnQsIHJpZ2h0UG9pbnQgXSA9IHRoaXMuZmluZE1hdGNoaW5nUGFpciggeCApO1xyXG5cclxuICAgICAgaWYgKCBsZWZ0UG9pbnQueCA9PT0geCApIHtcclxuICAgICAgICByZXR1cm4gbGVmdFBvaW50Lnk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoIHJpZ2h0UG9pbnQueCA9PT0geCApIHtcclxuICAgICAgICByZXR1cm4gcmlnaHRQb2ludC55O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBVdGlscy5saW5lYXIoIGxlZnRQb2ludC54LCByaWdodFBvaW50LngsIGxlZnRQb2ludC55LCByaWdodFBvaW50LnksIHggKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBhcnJheSB0aGF0IGNvbWJpbmVzIHNvcnRlZCB1bmlxdWUgeC12YWx1ZXMgcHJvdmlkZWQgYnkgdGhpcyBmdW5jdGlvbiBhbmQvb3IgdGhlIG90aGVyIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0Q29tYmluZWRYVmFsdWVzKCBsaW5lYXJGdW5jdGlvbjogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiApOiBudW1iZXJbXSB7XHJcbiAgICByZXR1cm4gQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbi5zb3J0ZWRVbmlxdWVFcHNpbG9uKFxyXG4gICAgICB0aGlzLnBvaW50cy5tYXAoIHBvaW50ID0+IHBvaW50LnggKS5jb25jYXQoIGxpbmVhckZ1bmN0aW9uLnBvaW50cy5tYXAoIHBvaW50ID0+IHBvaW50LnggKSApXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBhcnJheSB0aGF0IGNvbWJpbmVzIHRoZSBzb3J0ZWQgdW5pcXVlIHgtdmFsdWVzIGluY2x1ZGVkIGluIHRoaXMgZnVuY3Rpb24gYW5kL29yIHRoZSBvdGhlciBmdW5jdGlvbiwgT1IgdGhlIHVuaXF1ZSB4LXZhbHVlc1xyXG4gICAqIHRoYXQgcmVzdWx0IGZyb20gdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGZ1bmN0aW9ucy5cclxuICAgKi9cclxuICBwcml2YXRlIGdldEludGVyc2VjdGVkWFZhbHVlcyggbGluZWFyRnVuY3Rpb246IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24gKTogbnVtYmVyW10ge1xyXG4gICAgY29uc3QgeFZhbHVlcyA9IHRoaXMuZ2V0Q29tYmluZWRYVmFsdWVzKCBsaW5lYXJGdW5jdGlvbiApO1xyXG4gICAgY29uc3QgbmV3WFZhbHVlczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCB4VmFsdWVzLmxlbmd0aCAtIDE7IGkrKyApIHtcclxuICAgICAgY29uc3QgbGVmdFggPSB4VmFsdWVzWyBpIF07XHJcbiAgICAgIGNvbnN0IHJpZ2h0WCA9IHhWYWx1ZXNbIGkgKyAxIF07XHJcbiAgICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50ID0gVXRpbHMubGluZUxpbmVJbnRlcnNlY3Rpb24oXHJcblxyXG4gICAgICAgIC8vIFRoZSBsaW5lYXIgZnVuY3Rpb24gZGVmaW5lZCBpbiB0aGlzXHJcbiAgICAgICAgbmV3IFZlY3RvcjIoIGxlZnRYLCB0aGlzLmV2YWx1YXRlKCBsZWZ0WCApICksXHJcbiAgICAgICAgbmV3IFZlY3RvcjIoIHJpZ2h0WCwgdGhpcy5ldmFsdWF0ZSggcmlnaHRYICkgKSxcclxuXHJcbiAgICAgICAgLy8gVGhlIHBhc3NlZCBpbiBhcmd1bWVudCBsaW5lYXIgZnVuY3Rpb25cclxuICAgICAgICBuZXcgVmVjdG9yMiggbGVmdFgsIGxpbmVhckZ1bmN0aW9uLmV2YWx1YXRlKCBsZWZ0WCApICksXHJcbiAgICAgICAgbmV3IFZlY3RvcjIoIHJpZ2h0WCwgbGluZWFyRnVuY3Rpb24uZXZhbHVhdGUoIHJpZ2h0WCApIClcclxuICAgICAgKTtcclxuICAgICAgaWYgKCBpbnRlcnNlY3Rpb25Qb2ludCAmJlxyXG4gICAgICAgICAgIC8vIElmIGl0J3Mgb3VyIGZpcnN0IHBhaXIgb2YgcG9pbnRzLCBkb24ndCBmaWx0ZXIgb3V0IHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBsZWZ0IHBvaW50XHJcbiAgICAgICAgICAgKCBpID09PSAwIHx8IGludGVyc2VjdGlvblBvaW50LnggPiBsZWZ0WCApICYmXHJcbiAgICAgICAgICAgLy8gSWYgaXQncyBvdXIgbGFzdCBwYWlyIG9mIHBvaW50cywgZG9uJ3QgZmlsdGVyIG91dCBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHJpZ2h0IHBvaW50XHJcbiAgICAgICAgICAgKCBpID09PSB4VmFsdWVzLmxlbmd0aCAtIDIgfHwgaW50ZXJzZWN0aW9uUG9pbnQueCA8IHJpZ2h0WCApXHJcbiAgICAgICkge1xyXG4gICAgICAgIG5ld1hWYWx1ZXMucHVzaCggaW50ZXJzZWN0aW9uUG9pbnQueCApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSB2YWx1ZXMgYWJvdmUgYW5kIHNvcnQgdGhlbVxyXG4gICAgY29uc3QgY3JpdGljYWxYVmFsdWVzID0gQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbi5zb3J0ZWRVbmlxdWVFcHNpbG9uKCBbXHJcbiAgICAgIC4uLnhWYWx1ZXMsXHJcbiAgICAgIC4uLm5ld1hWYWx1ZXNcclxuICAgIF0gKTtcclxuXHJcbiAgICAvLyBUbyBjYXB0dXJlIHRoZSBzbG9wZSBhdCB0aGUgc3RhcnQvZW5kLCB3ZSdsbCBhZGQgZXh0cmEgcG9pbnRzIHRvIGd1YXJhbnRlZSB0aGlzLiBJZiB0aGV5J3JlIGR1cGxpY2F0ZWQsIHRoZXknbGxcclxuICAgIC8vIGJlIHJlbW92ZWQgZHVyaW5nIHRoZSBjb2xsaW5lYXIgY2hlY2sgb24gY29uc3RydWN0aW9uLlxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgY3JpdGljYWxYVmFsdWVzWyAwIF0gLSAxLFxyXG4gICAgICAuLi5jcml0aWNhbFhWYWx1ZXMsXHJcbiAgICAgIGNyaXRpY2FsWFZhbHVlc1sgY3JpdGljYWxYVmFsdWVzLmxlbmd0aCAtIDEgXSArIDFcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQncyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBiaW5hcnkgb3BlcmF0aW9uIGF0IHRoZSBnaXZlbiB4IHZhbHVlcy5cclxuICAgKi9cclxuICBwcml2YXRlIGJpbmFyeVhPcGVyYXRpb24oIGxpbmVhckZ1bmN0aW9uOiBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uLCBvcGVyYXRpb246ICggYTogbnVtYmVyLCBiOiBudW1iZXIgKSA9PiBudW1iZXIsIHhWYWx1ZXM6IG51bWJlcltdICk6IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24ge1xyXG4gICAgcmV0dXJuIG5ldyBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uKCB4VmFsdWVzLm1hcCggeCA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMiggeCwgb3BlcmF0aW9uKCB0aGlzLmV2YWx1YXRlKCB4ICksIGxpbmVhckZ1bmN0aW9uLmV2YWx1YXRlKCB4ICkgKSApO1xyXG4gICAgfSApICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQncyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBiaW5hcnkgb3BlcmF0aW9uIGF0IHRoZSB4IHZhbHVlcyB0aGF0IGFscmVhZHkgb2NjdXJcclxuICAgKiBpbiBlYWNoIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYmluYXJ5UG9pbnR3aXNlT3BlcmF0aW9uKCBsaW5lYXJGdW5jdGlvbjogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiwgb3BlcmF0aW9uOiAoIGE6IG51bWJlciwgYjogbnVtYmVyICkgPT4gbnVtYmVyICk6IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24ge1xyXG4gICAgcmV0dXJuIHRoaXMuYmluYXJ5WE9wZXJhdGlvbiggbGluZWFyRnVuY3Rpb24sIG9wZXJhdGlvbiwgdGhpcy5nZXRDb21iaW5lZFhWYWx1ZXMoIGxpbmVhckZ1bmN0aW9uICkgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCdzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGJpbmFyeSBvcGVyYXRpb24gYXQgdGhlIHggdmFsdWVzIHRoYXQgZWl0aGVyIG9jY3VyIGluXHJcbiAgICogZWFjaCBmdW5jdGlvbiBPUiBhdCB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gZnVuY3Rpb25zLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYmluYXJ5SW50ZXJzZWN0aW5nT3BlcmF0aW9uKCBsaW5lYXJGdW5jdGlvbjogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiwgb3BlcmF0aW9uOiAoIGE6IG51bWJlciwgYjogbnVtYmVyICkgPT4gbnVtYmVyICk6IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24ge1xyXG4gICAgcmV0dXJuIHRoaXMuYmluYXJ5WE9wZXJhdGlvbiggbGluZWFyRnVuY3Rpb24sIG9wZXJhdGlvbiwgdGhpcy5nZXRJbnRlcnNlY3RlZFhWYWx1ZXMoIGxpbmVhckZ1bmN0aW9uICkgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uIHRoYXQncyB0aGUgcmVzdWx0IG9mIGFkZGluZyB0aGUgdHdvIGZ1bmN0aW9ucy5cclxuICAgKi9cclxuICBwdWJsaWMgcGx1cyggbGluZWFyRnVuY3Rpb246IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24gKTogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiB7XHJcbiAgICByZXR1cm4gdGhpcy5iaW5hcnlQb2ludHdpc2VPcGVyYXRpb24oIGxpbmVhckZ1bmN0aW9uLCAoIGEsIGIgKSA9PiBhICsgYiApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24gdGhhdCdzIHRoZSByZXN1bHQgb2Ygc3VidHJhY3RpbmcgdGhlIHR3byBmdW5jdGlvbnMuXHJcbiAgICovXHJcbiAgcHVibGljIG1pbnVzKCBsaW5lYXJGdW5jdGlvbjogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiApOiBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uIHtcclxuICAgIHJldHVybiB0aGlzLmJpbmFyeVBvaW50d2lzZU9wZXJhdGlvbiggbGluZWFyRnVuY3Rpb24sICggYSwgYiApID0+IGEgLSBiICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiB0aGF0J3MgdGhlIHJlc3VsdCBvZiB0YWtpbmcgdGhlIG1pbmltdW0gb2YgdGhlIHR3byBmdW5jdGlvbnNcclxuICAgKi9cclxuICBwdWJsaWMgbWluKCBsaW5lYXJGdW5jdGlvbjogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiApOiBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uIHtcclxuICAgIHJldHVybiB0aGlzLmJpbmFyeUludGVyc2VjdGluZ09wZXJhdGlvbiggbGluZWFyRnVuY3Rpb24sIE1hdGgubWluICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiB0aGF0J3MgdGhlIHJlc3VsdCBvZiB0YWtpbmcgdGhlIG1heGltdW0gb2YgdGhlIHR3byBmdW5jdGlvbnNcclxuICAgKi9cclxuICBwdWJsaWMgbWF4KCBsaW5lYXJGdW5jdGlvbjogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiApOiBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uIHtcclxuICAgIHJldHVybiB0aGlzLmJpbmFyeUludGVyc2VjdGluZ09wZXJhdGlvbiggbGluZWFyRnVuY3Rpb24sIE1hdGgubWF4ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbGxvd3MgcmVkZWZpbmluZyBvciBjbGFtcGluZy90cnVuY2F0aW5nIHRoZSBmdW5jdGlvbiBieSBvbmx5IHJlcHJlc2VudGluZyBpdCBmcm9tIHRoZSBnaXZlbiB4IHZhbHVlc1xyXG4gICAqL1xyXG4gIHB1YmxpYyB3aXRoWFZhbHVlcyggeFZhbHVlczogbnVtYmVyW10gKTogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiB7XHJcbiAgICByZXR1cm4gbmV3IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24oIHhWYWx1ZXMubWFwKCB4ID0+IG5ldyBWZWN0b3IyKCB4LCB0aGlzLmV2YWx1YXRlKCB4ICkgKSApICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGludmVydGVkIGZvcm0gb2YgdGhlIGZ1bmN0aW9uIChhc3N1bWluZyBpdCBpcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgb3IgbW9ub3RvbmljYWxseSBkZWNyZWFzaW5nKVxyXG4gICAqL1xyXG4gIHB1YmxpYyBpbnZlcnRlZCgpOiBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uIHtcclxuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzLm1hcCggcG9pbnQgPT4gbmV3IFZlY3RvcjIoIHBvaW50LnksIHBvaW50LnggKSApO1xyXG5cclxuICAgIC8vIE5PVEU6IFdlJ2xsIHJlbHkgb24gdGhlIGNvbnN0cnVjdG9yIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBpbnZlcnNlIGlzIHZhbGlkLiBIZXJlIHdlJ2xsIGhhbmRsZSB0aGUgbW9ub3RvbmljYWxseVxyXG4gICAgLy8gZGVjcmVhc2luZyBjYXNlICh3aGljaCBpcyBpbnZlcnRpYmxlLCBqdXN0IG5lZWRzIGEgcmV2ZXJzYWwgb2YgcG9pbnRzKVxyXG4gICAgaWYgKCBwb2ludHMubGVuZ3RoID4gMSAmJiBwb2ludHNbIDAgXS54ID4gcG9pbnRzWyAxIF0ueCApIHtcclxuICAgICAgcG9pbnRzLnJldmVyc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24oIHBvaW50cyApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0YXRpYyBzdW0oIC4uLmZ1bmN0aW9uczogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbltdICk6IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24ge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9ucy5yZWR1Y2UoICggYSwgYiApID0+IGEucGx1cyggYiApICk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhdGljIG1pbiggLi4uZnVuY3Rpb25zOiBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uW10gKTogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb25zLnJlZHVjZSggKCBhLCBiICkgPT4gYS5taW4oIGIgKSApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0YXRpYyBtYXgoIC4uLmZ1bmN0aW9uczogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbltdICk6IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24ge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9ucy5yZWR1Y2UoICggYSwgYiApID0+IGEubWF4KCBiICkgKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzdGF0aWMgY29uc3RhbnQoIHk6IG51bWJlciApOiBDb21wbGV0ZVBpZWNld2lzZUxpbmVhckZ1bmN0aW9uIHtcclxuICAgIHJldHVybiBuZXcgQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiggWyBuZXcgVmVjdG9yMiggMCwgeSApIF0gKTtcclxuICB9XHJcblxyXG4gIC8vIFJlcHJlc2VudHMgdGhlIGZ1bmN0aW9uIGF4K2JcclxuICBwdWJsaWMgc3RhdGljIGxpbmVhciggYTogbnVtYmVyLCBiOiBudW1iZXIgKTogQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbiB7XHJcbiAgICByZXR1cm4gbmV3IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24oIFsgbmV3IFZlY3RvcjIoIDAsIGIgKSwgbmV3IFZlY3RvcjIoIDEsIGEgKyBiICkgXSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHNvcnRlZCBsaXN0IG9mIHRoZSBpbnB1dCBudW1iZXJzLCBlbnN1cmluZyBubyBkdXBsaWNhdGVzIHdpdGhpbiBhIHNwZWNpZmllZCBlcHNpbG9uIHZhbHVlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgc29ydGVkVW5pcXVlRXBzaWxvbiggbnVtYmVyczogbnVtYmVyW10sIGVwc2lsb24gPSAxZS0xMCApOiBudW1iZXJbXSB7XHJcbiAgICBudW1iZXJzID0gXy5zb3J0QnkoIG51bWJlcnMgKTtcclxuXHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBudW1iZXJzLmxlbmd0aCAtIDE7IGkrKyApIHtcclxuICAgICAgaWYgKCBNYXRoLmFicyggbnVtYmVyc1sgaSBdIC0gbnVtYmVyc1sgaSArIDEgXSApIDwgZXBzaWxvbiApIHtcclxuICAgICAgICBudW1iZXJzLnNwbGljZSggaSwgMSApO1xyXG4gICAgICAgIGktLTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudW1iZXJzO1xyXG4gIH1cclxufVxyXG5cclxuZG90LnJlZ2lzdGVyKCAnQ29tcGxldGVQaWVjZXdpc2VMaW5lYXJGdW5jdGlvbicsIENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb24gKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvbXBsZXRlUGllY2V3aXNlTGluZWFyRnVuY3Rpb247Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsR0FBRyxNQUFNLFVBQVU7QUFDMUIsT0FBT0MsS0FBSyxNQUFNLFlBQVk7QUFDOUIsT0FBT0MsT0FBTyxNQUFNLGNBQWM7QUFFbEMsTUFBTUMsK0JBQStCLENBQUM7RUFJcEM7RUFDT0Ms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