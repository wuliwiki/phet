// Copyright 2021-2022, University of Colorado Boulder

/**
 * One dimensional (scalar) transforms, which are invertible. Unlike Transform3 and Transform4, Transform1
 * may be nonlinear.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import merge from '../../phet-core/js/merge.js';
import dot from './dot.js';
import Range from './Range.js';

// For assertions that the inverse is correct.
const TOLERANCE = 1E-6;
const approxEquals = (a, b) => Math.abs(a - b) <= TOLERANCE;
class Transform1 {
  /**
   * @param {function(number):number} evaluationFunction
   * @param {function(number):number} inverseFunction
   * @param {Object} [options]
   */
  constructor(evaluationFunction, inverseFunction, options) {
    options = merge({
      // Used for asserting the inverse is correct, and that inputs are valid
      domain: new Range(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY),
      range: new Range(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY)
    }, options);

    // @private
    this.evaluationFunction = evaluationFunction;
    this.inverseFunction = inverseFunction;
    this.domain = options.domain;
    this.range = options.range;
  }

  /**
   * Evaluate the transform at the specified scalar.
   * @param {number} x
   * @returns {number}
   * @public
   */
  evaluate(x) {
    assert && assert(this.domain.contains(x), 'Value out of domain');
    const result = this.evaluationFunction(x);
    assert && assert(approxEquals(this.inverseFunction(result), x));
    return result;
  }

  /**
   * Evaluate the inverse at the specified scalar.
   * @param {number} x
   * @returns {number}
   * @public
   */
  inverse(x) {
    assert && assert(this.range.contains(x), 'Value out of range');
    const result = this.inverseFunction(x);
    assert && assert(approxEquals(this.evaluationFunction(result), x));
    return result;
  }
}
dot.register('Transform1', Transform1);
export default Transform1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtZXJnZSIsImRvdCIsIlJhbmdlIiwiVE9MRVJBTkNFIiwiYXBwcm94RXF1YWxzIiwiYSIsImIiLCJNYXRoIiwiYWJzIiwiVHJhbnNmb3JtMSIsImNvbnN0cnVjdG9yIiwiZXZhbHVhdGlvbkZ1bmN0aW9uIiwiaW52ZXJzZUZ1bmN0aW9uIiwib3B0aW9ucyIsImRvbWFpbiIsIk51bWJlciIsIk5FR0FUSVZFX0lORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJyYW5nZSIsImV2YWx1YXRlIiwieCIsImFzc2VydCIsImNvbnRhaW5zIiwicmVzdWx0IiwiaW52ZXJzZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiVHJhbnNmb3JtMS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBPbmUgZGltZW5zaW9uYWwgKHNjYWxhcikgdHJhbnNmb3Jtcywgd2hpY2ggYXJlIGludmVydGlibGUuIFVubGlrZSBUcmFuc2Zvcm0zIGFuZCBUcmFuc2Zvcm00LCBUcmFuc2Zvcm0xXHJcbiAqIG1heSBiZSBub25saW5lYXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIFJlaWQgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCBkb3QgZnJvbSAnLi9kb3QuanMnO1xyXG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi9SYW5nZS5qcyc7XHJcblxyXG4vLyBGb3IgYXNzZXJ0aW9ucyB0aGF0IHRoZSBpbnZlcnNlIGlzIGNvcnJlY3QuXHJcbmNvbnN0IFRPTEVSQU5DRSA9IDFFLTY7XHJcbmNvbnN0IGFwcHJveEVxdWFscyA9ICggYSwgYiApID0+IE1hdGguYWJzKCBhIC0gYiApIDw9IFRPTEVSQU5DRTtcclxuXHJcbmNsYXNzIFRyYW5zZm9ybTEge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBldmFsdWF0aW9uRnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBpbnZlcnNlRnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGV2YWx1YXRpb25GdW5jdGlvbiwgaW52ZXJzZUZ1bmN0aW9uLCBvcHRpb25zICkge1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG5cclxuICAgICAgLy8gVXNlZCBmb3IgYXNzZXJ0aW5nIHRoZSBpbnZlcnNlIGlzIGNvcnJlY3QsIGFuZCB0aGF0IGlucHV0cyBhcmUgdmFsaWRcclxuICAgICAgZG9tYWluOiBuZXcgUmFuZ2UoIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICksXHJcbiAgICAgIHJhbmdlOiBuZXcgUmFuZ2UoIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIClcclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy5ldmFsdWF0aW9uRnVuY3Rpb24gPSBldmFsdWF0aW9uRnVuY3Rpb247XHJcbiAgICB0aGlzLmludmVyc2VGdW5jdGlvbiA9IGludmVyc2VGdW5jdGlvbjtcclxuICAgIHRoaXMuZG9tYWluID0gb3B0aW9ucy5kb21haW47XHJcbiAgICB0aGlzLnJhbmdlID0gb3B0aW9ucy5yYW5nZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV2YWx1YXRlIHRoZSB0cmFuc2Zvcm0gYXQgdGhlIHNwZWNpZmllZCBzY2FsYXIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBldmFsdWF0ZSggeCApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuZG9tYWluLmNvbnRhaW5zKCB4ICksICdWYWx1ZSBvdXQgb2YgZG9tYWluJyApO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5ldmFsdWF0aW9uRnVuY3Rpb24oIHggKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGFwcHJveEVxdWFscyggdGhpcy5pbnZlcnNlRnVuY3Rpb24oIHJlc3VsdCApLCB4ICkgKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFdmFsdWF0ZSB0aGUgaW52ZXJzZSBhdCB0aGUgc3BlY2lmaWVkIHNjYWxhci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGludmVyc2UoIHggKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLnJhbmdlLmNvbnRhaW5zKCB4ICksICdWYWx1ZSBvdXQgb2YgcmFuZ2UnICk7XHJcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmludmVyc2VGdW5jdGlvbiggeCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggYXBwcm94RXF1YWxzKCB0aGlzLmV2YWx1YXRpb25GdW5jdGlvbiggcmVzdWx0ICksIHggKSApO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbn1cclxuXHJcbmRvdC5yZWdpc3RlciggJ1RyYW5zZm9ybTEnLCBUcmFuc2Zvcm0xICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUcmFuc2Zvcm0xOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLEtBQUssTUFBTSw2QkFBNkI7QUFDL0MsT0FBT0MsR0FBRyxNQUFNLFVBQVU7QUFDMUIsT0FBT0MsS0FBSyxNQUFNLFlBQVk7O0FBRTlCO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLElBQUk7QUFDdEIsTUFBTUMsWUFBWSxHQUFHQSxDQUFFQyxDQUFDLEVBQUVDLENBQUMsS0FBTUMsSUFBSSxDQUFDQyxHQUFHLENBQUVILENBQUMsR0FBR0MsQ0FBRSxDQUFDLElBQUlILFNBQVM7QUFFL0QsTUFBTU0sVUFBVSxDQUFDO0VBRWY7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxXQUFXQSxDQUFFQyxrQkFBa0IsRUFBRUMsZUFBZSxFQUFFQyxPQUFPLEVBQUc7SUFFMURBLE9BQU8sR0FBR2IsS0FBSyxDQUFFO01BRWY7TUFDQWMsTUFBTSxFQUFFLElBQUlaLEtBQUssQ0FBRWEsTUFBTSxDQUFDQyxpQkFBaUIsRUFBRUQsTUFBTSxDQUFDRSxpQkFBa0IsQ0FBQztNQUN2RUMsS0FBSyxFQUFFLElBQUloQixLQUFLLENBQUVhLE1BQU0sQ0FBQ0MsaUJBQWlCLEVBQUVELE1BQU0sQ0FBQ0UsaUJBQWtCO0lBQ3ZFLENBQUMsRUFBRUosT0FBUSxDQUFDOztJQUVaO0lBQ0EsSUFBSSxDQUFDRixrQkFBa0IsR0FBR0Esa0JBQWtCO0lBQzVDLElBQUksQ0FBQ0MsZUFBZSxHQUFHQSxlQUFlO0lBQ3RDLElBQUksQ0FBQ0UsTUFBTSxHQUFHRCxPQUFPLENBQUNDLE1BQU07SUFDNUIsSUFBSSxDQUFDSSxLQUFLLEdBQUdMLE9BQU8sQ0FBQ0ssS0FBSztFQUM1Qjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsUUFBUUEsQ0FBRUMsQ0FBQyxFQUFHO0lBQ1pDLE1BQU0sSUFBSUEsTUFBTSxDQUFFLElBQUksQ0FBQ1AsTUFBTSxDQUFDUSxRQUFRLENBQUVGLENBQUUsQ0FBQyxFQUFFLHFCQUFzQixDQUFDO0lBQ3BFLE1BQU1HLE1BQU0sR0FBRyxJQUFJLENBQUNaLGtCQUFrQixDQUFFUyxDQUFFLENBQUM7SUFDM0NDLE1BQU0sSUFBSUEsTUFBTSxDQUFFakIsWUFBWSxDQUFFLElBQUksQ0FBQ1EsZUFBZSxDQUFFVyxNQUFPLENBQUMsRUFBRUgsQ0FBRSxDQUFFLENBQUM7SUFDckUsT0FBT0csTUFBTTtFQUNmOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxPQUFPQSxDQUFFSixDQUFDLEVBQUc7SUFDWEMsTUFBTSxJQUFJQSxNQUFNLENBQUUsSUFBSSxDQUFDSCxLQUFLLENBQUNJLFFBQVEsQ0FBRUYsQ0FBRSxDQUFDLEVBQUUsb0JBQXFCLENBQUM7SUFDbEUsTUFBTUcsTUFBTSxHQUFHLElBQUksQ0FBQ1gsZUFBZSxDQUFFUSxDQUFFLENBQUM7SUFDeENDLE1BQU0sSUFBSUEsTUFBTSxDQUFFakIsWUFBWSxDQUFFLElBQUksQ0FBQ08sa0JBQWtCLENBQUVZLE1BQU8sQ0FBQyxFQUFFSCxDQUFFLENBQUUsQ0FBQztJQUN4RSxPQUFPRyxNQUFNO0VBQ2Y7QUFDRjtBQUVBdEIsR0FBRyxDQUFDd0IsUUFBUSxDQUFFLFlBQVksRUFBRWhCLFVBQVcsQ0FBQztBQUV4QyxlQUFlQSxVQUFVIn0=