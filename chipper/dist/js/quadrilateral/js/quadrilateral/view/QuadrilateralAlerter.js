// Copyright 2021-2023, University of Colorado Boulder

/**
 * Responsible for generating the real-time feedback alerts for the simulation and actually voicing them at the right
 * time.
 *
 * This Alerter mostly generates strings by comparing the state of the quadrilateral to a snapshot of
 * the geometric properties that were saved the last time the quadrilateral was described (making heavy use of
 * QuadrilateralShapeSnapshot).
 *
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import quadrilateral from '../../quadrilateral.js';
import Utterance from '../../../../utterance-queue/js/Utterance.js';
import Alerter from '../../../../scenery-phet/js/accessibility/describers/Alerter.js';
import { Voicing } from '../../../../scenery/js/imports.js';
import ResponsePacket from '../../../../utterance-queue/js/ResponsePacket.js';
import QuadrilateralStrings from '../../QuadrilateralStrings.js';
import QuadrilateralShapeSnapshot from '../model/QuadrilateralShapeSnapshot.js';
import QuadrilateralSide from '../model/QuadrilateralSide.js';
import StringUtils from '../../../../phetcommon/js/util/StringUtils.js';
import MovementAlerter from '../../../../scenery-phet/js/accessibility/describers/MovementAlerter.js';
import Utils from '../../../../dot/js/Utils.js';
import NamedQuadrilateral from '../model/NamedQuadrilateral.js';
import QuadrilateralDescriber from './QuadrilateralDescriber.js';
import QuadrilateralVertexDescriber from './QuadrilateralVertexDescriber.js';

// constants - Voicing strings are not translatable so we just use the StringProperty initial value
const foundShapePatternString = QuadrilateralStrings.a11y.voicing.foundShapePatternStringProperty.value;
const aBString = QuadrilateralStrings.a11y.aBStringProperty.value;
const bCString = QuadrilateralStrings.a11y.bCStringProperty.value;
const cDString = QuadrilateralStrings.a11y.cDStringProperty.value;
const dAString = QuadrilateralStrings.a11y.dAStringProperty.value;
const oppositeSidesTiltPatternString = QuadrilateralStrings.a11y.voicing.oppositeSidesTiltPatternStringProperty.value;
const oppositeSidesInParallelPatternString = QuadrilateralStrings.a11y.voicing.oppositeSidesInParallelPatternStringProperty.value;
const oppositeSidesInParallelAsCornersChangeEquallyPatternString = QuadrilateralStrings.a11y.voicing.oppositeSidesInParallelAsCornersChangeEquallyPatternStringProperty.value;
const oppositeSidesTiltAsShapeChangesPatternString = QuadrilateralStrings.a11y.voicing.oppositeSidesTiltAsShapeChangesPatternStringProperty.value;
const oppositeSidesEqualAsShapeChangesPatternString = QuadrilateralStrings.a11y.voicing.oppositeSidesEqualAsShapeChangesPatternStringProperty.value;
const maintainingAParallelogramAngleResponseString = QuadrilateralStrings.a11y.voicing.maintainingAParallelogramAngleResponseStringProperty.value;
const maintainingAParallelogramLengthResponsePatternString = QuadrilateralStrings.a11y.voicing.maintainingAParallelogramLengthResponsePatternStringProperty.value;
const maintainingATrapezoidAsShapeChangesPatternString = QuadrilateralStrings.a11y.voicing.maintainingATrapezoidAsShapeChangesPatternStringProperty.value;
const allRightAnglesAsShapeChangesPatternString = QuadrilateralStrings.a11y.voicing.allRightAnglesAsShapeChangesPatternStringProperty.value;
const maintainingARhombusString = QuadrilateralStrings.a11y.voicing.maintainingARhombusStringProperty.value;
const allSidesEqualAsShapeChangesPatternString = QuadrilateralStrings.a11y.voicing.allSidesEqualAsShapeChangesPatternStringProperty.value;
const cornerFlatAsShapeChangesPatternString = QuadrilateralStrings.a11y.voicing.cornerFlatAsShapeChangesPatternStringProperty.value;
const adjacentSidesChangeEquallyAsShapeChangesPatternString = QuadrilateralStrings.a11y.voicing.adjacentSidesChangeEquallyAsShapeChangesPatternStringProperty.value;
const allSidesTiltAwayFromParallelString = QuadrilateralStrings.a11y.voicing.allSidesTiltAwayFromParallelStringProperty.value;
const allSidesTiltAwayFromParallelAsShapeChangesPatternString = QuadrilateralStrings.a11y.voicing.allSidesTiltAwayFromParallelAsShapeChangesPatternStringProperty.value;
const tiltString = QuadrilateralStrings.a11y.voicing.tiltStringProperty.value;
const straightenString = QuadrilateralStrings.a11y.voicing.straightenStringProperty.value;
const biggerString = QuadrilateralStrings.a11y.voicing.biggerStringProperty.value;
const smallerString = QuadrilateralStrings.a11y.voicing.smallerStringProperty.value;
const vertexAString = QuadrilateralStrings.vertexAStringProperty.value;
const vertexBString = QuadrilateralStrings.vertexBStringProperty.value;
const vertexCString = QuadrilateralStrings.vertexCStringProperty.value;
const vertexDString = QuadrilateralStrings.vertexDStringProperty.value;
const backString = QuadrilateralStrings.a11y.voicing.backStringProperty.value;
const goneString = QuadrilateralStrings.a11y.voicing.goneStringProperty.value;
const cornersBackString = QuadrilateralStrings.a11y.voicing.cornersBackStringProperty.value;
const cornersGoneString = QuadrilateralStrings.a11y.voicing.cornersGoneStringProperty.value;
const cornerDetectedPatternString = QuadrilateralStrings.a11y.voicing.cornerDetectedPatternStringProperty.value;
const shorterString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.shorterStringProperty.value;
const longerString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.longerStringProperty.value;
const widerString = QuadrilateralStrings.a11y.voicing.vertexDragObjectResponse.widerStringProperty.value;
const vertexDragSmallerString = QuadrilateralStrings.a11y.voicing.vertexDragObjectResponse.smallerStringProperty.value;
const vertexDragObjectResponsePatternString = QuadrilateralStrings.a11y.voicing.vertexDragObjectResponse.vertexDragObjectResponsePatternStringProperty.value;
const adjacentSidesChangePatternString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.adjacentSidesChangePatternStringProperty.value;
const rightAngleString = QuadrilateralStrings.a11y.voicing.rightAngleStringProperty.value;
const angleFlatString = QuadrilateralStrings.a11y.voicing.angleFlatStringProperty.value;
const angleComparisonPatternString = QuadrilateralStrings.a11y.voicing.angleComparisonPatternStringProperty.value;
const oppositeCornerString = QuadrilateralStrings.a11y.voicing.oppositeCornerStringProperty.value;
const adjacentCornersEqualString = QuadrilateralStrings.a11y.voicing.adjacentCornersEqualStringProperty.value;
const adjacentCornersRightAnglesString = QuadrilateralStrings.a11y.voicing.adjacentCornersRightAnglesStringProperty.value;
const progressStatePatternString = QuadrilateralStrings.a11y.voicing.progressStatePatternStringProperty.value;
const equalToOppositeCornerEqualToAdjacentCornersString = QuadrilateralStrings.a11y.voicing.equalToOppositeCornerEqualToAdjacentCornersStringProperty.value;
const adjacentSidesInLinePatternString = QuadrilateralStrings.a11y.voicing.adjacentSidesInLinePatternStringProperty.value;
const equalToAdjacentCornersString = QuadrilateralStrings.a11y.voicing.equalToAdjacentCornersStringProperty.value;
const adjacentSidesChangeInLengthString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.adjacentSidesChangeInLengthStringProperty.value;
const parallelAdjacentSidesChangePatternString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.parallelAdjacentSidesChangePatternStringProperty.value;
const equalAdjacentSidesChangePatternString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.equalAdjacentSidesChangePatternStringProperty.value;
const equalToAdjacentSidesString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.equalToAdjacentSidesStringProperty.value;
const adjacentSidesEqualString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.adjacentSidesEqualStringProperty.value;
const adjacentSidesParallelString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.adjacentSidesParallelStringProperty.value;
const equalToOneAdjacentSideString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.equalToOneAdjacentSideStringProperty.value;
const twoSidesEqualString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.twoSidesEqualStringProperty.value;
const threeSidesEqualString = QuadrilateralStrings.a11y.voicing.sideDragObjectResponse.threeSidesEqualStringProperty.value;

// A response may trigger because there is a large enough change in angle or length. The reason for the response
// will have an impact on what information is described.
// constants
// If any angle changes this much since the last time a context response was generated, it is time to alert a
// new context response.
const ANGLE_RESPONSE_THRESHOLD = Math.PI / 12;

// If any of the angles have changed this much since the last time a context response was generated, angles have
// changed sufficiently to describe changes in angles over other information.
const ANGLE_DIFFERENCES_LARGE_THRESHOLD = Math.PI / 24;
export default class QuadrilateralAlerter extends Alerter {
  // Tracks whether the side pairs were parallel since the last time a description was generated because of a change
  // to the shape.
  // Indicates when it is time to announce an angle/length response because that aspect of the quadrilateral shape
  // has changed enough to describe it.
  angleResponseReady = false;
  lengthResponseReady = false;

  // A snapshot of state variables since the last time a response was generated. When a response is generated we need
  // create strings that describe the change to the shape *since the last description*, instead of every Property
  // change.
  constructor(model, screenView, modelViewTransform, describer) {
    super();
    this.quadrilateralShapeModel = model.quadrilateralShapeModel;
    this.model = model;
    this.modelViewTransform = modelViewTransform;
    this.describer = describer;
    this.previousContextResponseShapeSnapshot = new QuadrilateralShapeSnapshot(this.quadrilateralShapeModel);
    this.previousObjectResponseShapeSnapshot = new QuadrilateralShapeSnapshot(this.quadrilateralShapeModel);
    this.wasSideABSideCDParallel = model.quadrilateralShapeModel.sideABSideCDParallelSideChecker.areSidesParallel();
    this.wasSideBCSideDAParallel = model.quadrilateralShapeModel.sideBCSideDAParallelSideChecker.areSidesParallel();

    // The least pedagogically relevant content will alert through this Utterance and will often be interrupted.
    const lowPriorityUtterance = new Utterance({
      priority: Utterance.LOW_PRIORITY
    });

    // Alert content that should usually be heard, but should be interrupted by critical information about the shape
    const mediumPriorityUtterance = new Utterance({
      priority: Utterance.MEDIUM_PRIORITY
    });

    // Most important information about the shape that should interrupt all other alerts and never be interrupted.
    const highPriorityUtterance = new Utterance({
      priority: Utterance.HIGH_PRIORITY
    });

    // Upon simulation reset, reset certain state for description so that next descriptions after reset are correct
    model.resetNotInProgressProperty.link(resetNotInProgress => {
      this.previousContextResponseShapeSnapshot = new QuadrilateralShapeSnapshot(this.quadrilateralShapeModel);
      this.previousObjectResponseShapeSnapshot = new QuadrilateralShapeSnapshot(this.quadrilateralShapeModel);
    });

    //-----------------------------------------------------------------------------------------
    // Potentially generate and alert new responses when the shape changes.
    //-----------------------------------------------------------------------------------------
    model.quadrilateralShapeModel.shapeChangedEmitter.addListener(() => {
      // Nothing about these should be heard while resetting
      if (model.resetNotInProgressProperty.value) {
        const responsePacket = new ResponsePacket();

        // By default, we use the lower priority Utterance that won't interrupt responses that are currently being
        // announced. If we detect a critical state change, we will use a higher priority Utterance for interruption.
        let utterance = lowPriorityUtterance;
        const previousAAngle = this.previousContextResponseShapeSnapshot.vertexAAngle;
        const previousBAngle = this.previousContextResponseShapeSnapshot.vertexBAngle;
        const previousCAngle = this.previousContextResponseShapeSnapshot.vertexCAngle;
        const previousDAngle = this.previousContextResponseShapeSnapshot.vertexDAngle;
        const aAngleDifference = previousAAngle - this.quadrilateralShapeModel.vertexA.angleProperty.value;
        const bAngleDifference = previousBAngle - this.quadrilateralShapeModel.vertexB.angleProperty.value;
        const cAngleDifference = previousCAngle - this.quadrilateralShapeModel.vertexC.angleProperty.value;
        const dAngleDifference = previousDAngle - this.quadrilateralShapeModel.vertexD.angleProperty.value;
        const angleDifferences = [aAngleDifference, bAngleDifference, cAngleDifference, dAngleDifference];

        // Have the angles changed enough to trigger a context response?
        this.angleResponseReady = _.some(angleDifferences, angleDifference => Math.abs(angleDifference) > ANGLE_RESPONSE_THRESHOLD);
        const previousABLength = this.previousContextResponseShapeSnapshot.sideABLength;
        const previousBCLength = this.previousContextResponseShapeSnapshot.sideBCLength;
        const previousCDLength = this.previousContextResponseShapeSnapshot.sideCDLength;
        const previousDALength = this.previousContextResponseShapeSnapshot.sideDALength;
        const abLengthDifference = previousABLength - this.quadrilateralShapeModel.sideAB.lengthProperty.value;
        const bcLengthDifference = previousBCLength - this.quadrilateralShapeModel.sideBC.lengthProperty.value;
        const cdLengthDifference = previousCDLength - this.quadrilateralShapeModel.sideCD.lengthProperty.value;
        const daLengthDifference = previousDALength - this.quadrilateralShapeModel.sideDA.lengthProperty.value;
        const lengthDifferences = [abLengthDifference, bcLengthDifference, cdLengthDifference, daLengthDifference];

        // If angles have changed enough, the response information will describe the changing angles instead
        // of other information (like changing length).
        const angleDifferencesLarge = _.some(angleDifferences, angleDifference => angleDifference > ANGLE_DIFFERENCES_LARGE_THRESHOLD);

        // Have the lengths changed enough to trigger a context response?
        this.lengthResponseReady = _.some(lengthDifferences, lengthDifference => Math.abs(lengthDifference) > QuadrilateralSide.SIDE_SEGMENT_LENGTH) && !angleDifferencesLarge;
        const sideABSideCDParallelAfter = this.quadrilateralShapeModel.sideABSideCDParallelSideChecker.areSidesParallel();
        const sideBCSideDAParallelAfter = this.quadrilateralShapeModel.sideBCSideDAParallelSideChecker.areSidesParallel();

        // If we go from zero parallel side pairs to at least one pair, trigger a new context response so that we hear
        // when sides become parallel. These checks have to be relative to every shape change, so state variables are
        // set immediately instead of in a QuadrilateralShapeSnapshot.
        const parallelSideResponseReady = !this.wasSideABSideCDParallel && !this.wasSideBCSideDAParallel && (sideABSideCDParallelAfter || sideBCSideDAParallelAfter);
        this.wasSideABSideCDParallel = sideABSideCDParallelAfter;
        this.wasSideBCSideDAParallel = sideBCSideDAParallelAfter;

        //-----------------------------------------------------------------------------------------
        // First, create the context response - the description of the overall shape
        //-----------------------------------------------------------------------------------------
        const shapeNameChangeResponse = this.getShapeNameChangeResponse();
        if (shapeNameChangeResponse) {
          // Shape name changed, this is the most important information.
          responsePacket.contextResponse = shapeNameChangeResponse;
          utterance = highPriorityUtterance;
        } else if (this.angleResponseReady || this.lengthResponseReady || parallelSideResponseReady) {
          // Shape attributes changed sufficiently to describe changes
          const thisResponseReason = angleDifferencesLarge ? 'angle' : 'length';
          if (this.previousContextResponseShapeSnapshot.namedQuadrilateral === this.quadrilateralShapeModel.shapeNameProperty.value) {
            // the shape has changed enough to provide a context response, but the named quadrilateral has not
            // changed, so we provide a unique alert specific to the shape maintenance
            const shapeMaintenanceResponse = this.getShapeMaintenanceContextResponse(this.quadrilateralShapeModel.shapeNameProperty.value, this.previousContextResponseShapeSnapshot, thisResponseReason);
            responsePacket.contextResponse = shapeMaintenanceResponse;
          } else {
            const tiltChangeResponse = this.getShapeChangeResponse(this.quadrilateralShapeModel, this.previousContextResponseShapeSnapshot, thisResponseReason);
            responsePacket.contextResponse = tiltChangeResponse;
          }
          utterance = mediumPriorityUtterance;
        }

        //-----------------------------------------------------------------------------------------
        // Next, create the object response - the description of the particular QuadrilateralVertex or QuadrilateralSide as
        // it is moved by the user.
        //-----------------------------------------------------------------------------------------
        model.quadrilateralShapeModel.sides.forEach(side => {
          if (side.voicingObjectResponseDirty) {
            responsePacket.objectResponse = this.getSideChangeObjectResponse(side);
            side.voicingObjectResponseDirty = false;
          }
        });
        model.quadrilateralShapeModel.vertices.forEach(vertex => {
          if (vertex.voicingObjectResponseDirty) {
            responsePacket.objectResponse = this.getVertexChangeObjectResponse(vertex);
            vertex.voicingObjectResponseDirty = false;
          }
        });

        //-----------------------------------------------------------------------------------------
        // Announce responses if we have generated any content.
        //-----------------------------------------------------------------------------------------
        if (responsePacket.contextResponse || responsePacket.objectResponse) {
          utterance.alert = responsePacket;
          this.alert(utterance);

          // save snapshots for next descriptions
          if (responsePacket.contextResponse) {
            this.previousContextResponseShapeSnapshot = new QuadrilateralShapeSnapshot(this.quadrilateralShapeModel);
          }
          if (responsePacket.objectResponse) {
            this.previousObjectResponseShapeSnapshot = new QuadrilateralShapeSnapshot(this.quadrilateralShapeModel);
          }
        }
      }
    });

    //-----------------------------------------------------------------------------------------
    // (Prototype) Responses specific to OpenCV - letting the user know when markers become
    // detected or obscured from the camera.
    //-----------------------------------------------------------------------------------------
    const markerResponsePacket = new ResponsePacket();
    const markerUtterance = new Utterance({
      alert: markerResponsePacket,
      priority: Utterance.LOW_PRIORITY
    });
    const markerDetectionModel = model.tangibleConnectionModel.markerDetectionModel;
    markerDetectionModel.allVertexMarkersDetectedProperty.link(allVertexMarkersDetected => {
      if (markerDetectionModel.markerResponsesEnabledProperty.value) {
        markerResponsePacket.contextResponse = allVertexMarkersDetected ? cornersBackString : cornersGoneString;
        this.alert(markerUtterance);
      }
    });
    const vertexDetectionResponseListener = (labelString, detected) => {
      if (markerDetectionModel.markerResponsesEnabledProperty.value) {
        const stateString = detected ? backString : goneString;
        markerResponsePacket.contextResponse = StringUtils.fillIn(cornerDetectedPatternString, {
          label: labelString,
          state: stateString
        });
        this.alert(markerUtterance);
      }
    };
    markerDetectionModel.vertexAMarkerDetectedProperty.link(detected => {
      vertexDetectionResponseListener(vertexAString, detected);
    });
    markerDetectionModel.vertexBMarkerDetectedProperty.link(detected => {
      vertexDetectionResponseListener(vertexBString, detected);
    });
    markerDetectionModel.vertexCMarkerDetectedProperty.link(detected => {
      vertexDetectionResponseListener(vertexCString, detected);
    });
    markerDetectionModel.vertexDMarkerDetectedProperty.link(detected => {
      vertexDetectionResponseListener(vertexDString, detected);
    });

    //-----------------------------------------------------------------------------------------
    // Register Utterances to the ScreenView so that they respect visible and voicingVisible
    //-----------------------------------------------------------------------------------------
    Voicing.registerUtteranceToNode(lowPriorityUtterance, screenView);
    Voicing.registerUtteranceToNode(mediumPriorityUtterance, screenView);
    Voicing.registerUtteranceToNode(highPriorityUtterance, screenView);
    Voicing.registerUtteranceToNode(markerUtterance, screenView);
  }

  /**
   * Returns the object response for the side as it changes from user input like dragging. Describes the change in
   * length of adjacent side. Amount of content in the response depends on whether the adjacent sides change the same
   * amount, and how much the length of adjacent sides changed. Will return something like
   *
   * "adjacent sides equal" or
   * "equal to one adjacent side" or
   * "parallel adjacent sides longer" or
   * "equal adjacent sides shorter" or
   * "adjacent sides longer" or
   * "left" or
   * "up"
   *
   * The design for this function is outlined in https://github.com/phetsims/quadrilateral/issues/253
   */
  getSideChangeObjectResponse(side) {
    let response = '';
    const lengthTolerance = this.model.quadrilateralShapeModel.interLengthToleranceInterval;
    const shapeModel = this.model.quadrilateralShapeModel;
    const toleranceForDescribingLengthChange = lengthTolerance / 3;
    const currentShapeSnapshot = new QuadrilateralShapeSnapshot(this.model.quadrilateralShapeModel);

    // previous snapshot variables
    const previousAdjacentLengths = this.previousObjectResponseShapeSnapshot.getAdjacentSideLengthsFromSideLabel(side.sideLabel);
    const firstPreviousAdjacentSideLength = previousAdjacentLengths[0];
    const secondPreviousAdjacentSideLength = previousAdjacentLengths[1];
    const previousAdjacentSidesEqual = Utils.equalsEpsilon(firstPreviousAdjacentSideLength, secondPreviousAdjacentSideLength, lengthTolerance);
    const previousAdjacentSidesParallel = this.previousObjectResponseShapeSnapshot.getAdjacentSidesParallelFromSideLabel(side.sideLabel);
    const previousLength = this.previousObjectResponseShapeSnapshot.getLengthFromSideLabel(side.sideLabel);
    const previousEqualToFirstAdjacent = shapeModel.isInterLengthEqualToOther(previousLength, firstPreviousAdjacentSideLength);
    const previousEqualToSecondAdjacent = shapeModel.isInterLengthEqualToOther(previousLength, secondPreviousAdjacentSideLength);
    const previousEqualToOneAdjacent = previousEqualToFirstAdjacent !== previousEqualToSecondAdjacent;
    const previousNumberOfEqualSides = this.previousObjectResponseShapeSnapshot.countNumberOfEqualSides();

    // current shape variables
    const adjacentSides = currentShapeSnapshot.getAdjacentSideLengthsFromSideLabel(side.sideLabel);
    const firstAdjacentSideLength = adjacentSides[0];
    const secondAdjacentSideLength = adjacentSides[1];
    const adjacentSidesEqual = Utils.equalsEpsilon(firstAdjacentSideLength, secondAdjacentSideLength, lengthTolerance);
    const adjacentSidesParallel = currentShapeSnapshot.getAdjacentSidesParallelFromSideLabel(side.sideLabel);
    const sideLength = currentShapeSnapshot.getLengthFromSideLabel(side.sideLabel);
    const equalToFirstAdjacent = shapeModel.isInterLengthEqualToOther(sideLength, firstAdjacentSideLength);
    const equalToSecondAdjacent = shapeModel.isInterLengthEqualToOther(sideLength, secondAdjacentSideLength);
    const equalToOneAdjacent = equalToFirstAdjacent !== equalToSecondAdjacent;
    const numberOfEqualSides = currentShapeSnapshot.countNumberOfEqualSides();
    const firstAdjacentSideLengthDifference = firstAdjacentSideLength - firstPreviousAdjacentSideLength;
    const secondAdjacentSideLengthDifference = secondAdjacentSideLength - secondPreviousAdjacentSideLength;
    const firstSideAbsoluteDifference = Math.abs(firstAdjacentSideLengthDifference);
    const secondSideAbsoluteDifference = Math.abs(secondAdjacentSideLengthDifference);

    // Flow of this logic and priority of the content determined by design team
    if (adjacentSidesEqual && (equalToFirstAdjacent && !previousEqualToFirstAdjacent || equalToSecondAdjacent && !previousEqualToSecondAdjacent)) {
      // side just became equal to both adjacent sides
      response = equalToAdjacentSidesString;
    } else if (adjacentSidesEqual && !previousAdjacentSidesEqual) {
      // adjacent sides just became equal
      response = adjacentSidesEqualString;
    } else if (adjacentSidesParallel && !previousAdjacentSidesParallel) {
      // adjacent sides just became parallel, describe that next
      response = adjacentSidesParallelString;
    } else if (equalToOneAdjacent && !previousEqualToOneAdjacent) {
      // the moving side just became equal to ONE of its adjacent sides, call that out
      response = equalToOneAdjacentSideString;
    } else if (numberOfEqualSides === 3 && previousNumberOfEqualSides < 3) {
      // we just found a shape with three equal sides (moving from two equal sides)
      response = threeSidesEqualString;
    } else if (numberOfEqualSides === 2 && previousNumberOfEqualSides < 2) {
      // we just found a shape with two equal sides (moving from no equal sides)
      response = twoSidesEqualString;
    } else if (firstSideAbsoluteDifference > toleranceForDescribingLengthChange || secondSideAbsoluteDifference > toleranceForDescribingLengthChange) {
      if (Math.sign(firstAdjacentSideLengthDifference) === Math.sign(secondAdjacentSideLengthDifference)) {
        const adjacentSidesLonger = firstAdjacentSideLengthDifference > 0;
        const changeString = adjacentSidesLonger ? longerString : shorterString;

        // adjacent sides have changed in the same way as the side moves, this is a class of important things to
        // describe
        if (adjacentSidesParallel) {
          response = StringUtils.fillIn(parallelAdjacentSidesChangePatternString, {
            lengthChange: changeString
          });
        } else if (adjacentSidesEqual) {
          response = StringUtils.fillIn(equalAdjacentSidesChangePatternString, {
            lengthChange: changeString
          });
        } else {
          response = StringUtils.fillIn(adjacentSidesChangePatternString, {
            lengthChange: changeString
          });
        }
      } else {
        // they are changing by a large amount, but in different ways so describe them generally
        response = adjacentSidesChangeInLengthString;
      }
    } else {
      // adjacent sides did not change enough, just include a direction description
      const currentVertex1Position = side.vertex1.positionProperty.value;
      const previousVertex1Position = this.previousObjectResponseShapeSnapshot.getVertexPositionsFromSideLabel(side.sideLabel)[0];
      response = QuadrilateralAlerter.getDirectionDescription(previousVertex1Position, currentVertex1Position, this.modelViewTransform);
    }
    return response;
  }

  /**
   * Returns the Object Response that is announced every movement with keyboard dragging. This
   * is unique to keyboard input. With mouse/touch input, the less frequent rate of context responses
   * are sufficient for the Voicing output to describe the changing shape. With keyboard, the user
   * needs a response every key press to know that changes are happening.
   *
   * This function is absurdly complicated, see https://github.com/phetsims/quadrilateral/issues/237 for
   * the request.
   *
   * Note that since this is dependent on angles and not just position Properties, this must be called after
   * shapeChangedEmitter emits when we know that all angle and shape Properties have been updated. See
   * QuadrilateralShapeModel.updateOrderDependentProperties for more information.
   */
  getVertexChangeObjectResponse(vertex) {
    let response;

    // The phrase like the direction change, how the vertex angle changes, or whether the vertex angle is at
    // a critical value like 90/180 degrees
    let progressResponse = null;

    // Additional state information about other vertices, or how wide the moving vertex is relative to others in the
    // shape.
    let stateResponse = null;
    const shapeModel = this.quadrilateralShapeModel;
    const vertexDescriber = this.describer.getVertexDescriberForLabel(vertex.vertexLabel);
    const currentAngle = vertex.angleProperty.value;
    const previousAngle = this.previousObjectResponseShapeSnapshot.getAngleFromVertexLabel(vertex.vertexLabel);
    const oppositeVertex = shapeModel.oppositeVertexMap.get(vertex);
    const oppositeVertexAngle = oppositeVertex.angleProperty.value;
    const adjacentVertices = shapeModel.adjacentVertexMap.get(vertex);
    const firstAdjacentVertex = adjacentVertices[0];
    const firstAdjacentAngle = firstAdjacentVertex.angleProperty.value;
    const secondAdjacentVertex = adjacentVertices[1];
    const secondAdjacentAngle = secondAdjacentVertex.angleProperty.value;

    // whether the moving vertex angle becomes equal to any of the other vertices (within interAngleToleranceInterval)
    const angleEqualToFirstAdjacent = shapeModel.isInterAngleEqualToOther(currentAngle, firstAdjacentAngle);
    const angleEqualToSecondAdjacent = shapeModel.isInterAngleEqualToOther(currentAngle, secondAdjacentAngle);
    const angleEqualToOpposite = shapeModel.isInterAngleEqualToOther(currentAngle, oppositeVertexAngle);

    // Get the "progress" portion of the object response, describing how this vertex has changed or if it has
    // reached some critical angle. This portion of the description is always included.
    if (previousAngle === currentAngle) {
      // Moving around symmetric shapes, it is possible to move the vertex into a new position where the angle
      // stayed the same. In this case, only describe the direction of movement.
      const currentPosition = vertex.positionProperty.value;
      const previousPosition = this.previousObjectResponseShapeSnapshot.getPositionFromVertexLabel(vertex.vertexLabel);
      progressResponse = QuadrilateralAlerter.getDirectionDescription(previousPosition, currentPosition, this.modelViewTransform);
    } else if (shapeModel.isRightAngle(currentAngle)) {
      progressResponse = rightAngleString;
    } else if (shapeModel.isFlatAngle(currentAngle)) {
      progressResponse = angleFlatString;
    } else if (!angleEqualToFirstAdjacent && !angleEqualToSecondAdjacent && !angleEqualToOpposite) {
      // fallback case, just 'angle wider' or 'angle smaller' - but only if the angle is not equal to any other
      // to prevent the alert from getting too long
      const angleChangeString = currentAngle > previousAngle ? widerString : vertexDragSmallerString;
      progressResponse = StringUtils.fillIn(vertexDragObjectResponsePatternString, {
        angleChange: angleChangeString
      });
    }
    const shapeName = shapeModel.shapeNameProperty.value;

    // get the "state" portion of the object response, which describes important state information about the
    // quadrilateral like when a pair of adjacent angles are equal, or when the moving angle is twice/half of another
    // angle in the shape. There may not always be important state information.
    if (previousAngle !== currentAngle) {
      if (shapeModel.getAreAllAnglesRight()) {
        // important state described when a square
        stateResponse = equalToOppositeCornerEqualToAdjacentCornersString;
      } else if (angleEqualToFirstAdjacent && angleEqualToSecondAdjacent) {
        // the moving angle just became equal to its two adjacent corners
        stateResponse = equalToAdjacentCornersString;
      } else if (angleEqualToFirstAdjacent || angleEqualToOpposite || angleEqualToSecondAdjacent) {
        // If vertex the angle just became equal to another, that is the most important information and should be
        // described
        const otherVertex = angleEqualToFirstAdjacent ? firstAdjacentVertex : angleEqualToOpposite ? oppositeVertex : secondAdjacentVertex;

        // if equal to the opposite corner, just say "opposite corner" instead of the corner label
        const otherCornerLabelString = angleEqualToOpposite ? oppositeCornerString : QuadrilateralVertexDescriber.VERTEX_CORNER_LABEL_MAP.get(otherVertex.vertexLabel);
        const comparisonDescription = vertexDescriber.getAngleComparisonDescription(otherVertex, shapeName);
        stateResponse = StringUtils.fillIn(angleComparisonPatternString, {
          comparison: comparisonDescription,
          cornerLabel: otherCornerLabelString
        });
      } else if (this.shouldUseAngleComparisonDescription(currentAngle, oppositeVertexAngle)) {
        // describe relative size to opposite vertex
        const comparisonDescription = vertexDescriber.getAngleComparisonDescription(oppositeVertex, shapeName);
        stateResponse = StringUtils.fillIn(angleComparisonPatternString, {
          comparison: comparisonDescription,
          cornerLabel: oppositeCornerString
        });
      } else if (shapeModel.isInterAngleEqualToOther(firstAdjacentAngle, secondAdjacentAngle)) {
        // The adjacent angles just became equal to eachother, describe that next (after opposite in priority)
        if (shapeModel.isRightAngle(firstAdjacentAngle)) {
          stateResponse = adjacentCornersRightAnglesString;
        } else {
          stateResponse = adjacentCornersEqualString;
        }
      } else if (this.shouldUseAngleComparisonDescription(currentAngle, firstAdjacentAngle)) {
        // decribe relative size (half or twice as large as) to the first adjacent vertex
        const comparisonDescription = vertexDescriber.getAngleComparisonDescription(firstAdjacentVertex, shapeName);
        stateResponse = StringUtils.fillIn(angleComparisonPatternString, {
          comparison: comparisonDescription,
          cornerLabel: QuadrilateralVertexDescriber.VERTEX_CORNER_LABEL_MAP.get(firstAdjacentVertex.vertexLabel)
        });
      } else if (this.shouldUseAngleComparisonDescription(currentAngle, secondAdjacentAngle)) {
        // decribe relative size (half or twice as large as) to the second adjacent vertex
        const comparisonDescription = vertexDescriber.getAngleComparisonDescription(secondAdjacentVertex, shapeName);
        stateResponse = StringUtils.fillIn(angleComparisonPatternString, {
          comparison: comparisonDescription,
          cornerLabel: QuadrilateralVertexDescriber.VERTEX_CORNER_LABEL_MAP.get(secondAdjacentVertex.vertexLabel)
        });
      }
    }
    assert && assert(progressResponse || stateResponse, 'There needs to be a response, we have a case that is not described.');
    if (progressResponse && stateResponse) {
      response = StringUtils.fillIn(progressStatePatternString, {
        progress: progressResponse,
        state: stateResponse
      });
    } else if (stateResponse) {
      response = stateResponse;
    } else {
      response = progressResponse;
    }
    return response;
  }

  /**
   * Returns whether the changing vertex object response should include a description of the angle compared to another.
   * This is only included if the changingVertexAngle is around half, twice, or equal to the other angle. The other
   * angle might be an opposite or adjacent angle.
   */
  shouldUseAngleComparisonDescription(changingVertexAngle, otherVertexAngle) {
    return QuadrilateralVertexDescriber.isAngleAboutHalfOther(changingVertexAngle, otherVertexAngle) || QuadrilateralVertexDescriber.isAngleAboutTwiceOther(changingVertexAngle, otherVertexAngle) || this.quadrilateralShapeModel.isInterAngleEqualToOther(changingVertexAngle, otherVertexAngle);
  }

  /**
   * Get a response description for the shape change from previous state to current. Will describe parallel sides,
   * shape area, and side tilt during changes and interaction. The logic of this function is as described in the
   * design doc, see
   * https://docs.google.com/document/d/1jXayebAWnnNzsT3l6o72YPw4-YtiQaHQNuAi64eiguc/edit#heading=h.ap2d0jqvt5et
   *
   * Will return something like
   * "Opposite sides AB and CD tilt in parallel as shape gets bigger." or
   * "All sides tilt away from parallel as opposite corners change unequally." or
   * "Opposite sides straighten in parallel as opposite corners change equally." or
   *
   * @param shapeModel
   * @param previousShapeSnapshot - Object holding shape fields from the previous time this function was used
   * @param responseReason - This response happens when angles or lengths change enough to trigger a new description,
   *                         the triggering case will determine parts of the response string.
   */
  getShapeChangeResponse(shapeModel, previousShapeSnapshot, responseReason) {
    let response = null;
    const areaDifference = shapeModel.areaProperty.value - previousShapeSnapshot.area;
    const areaChangeString = areaDifference > 0 ? biggerString : smallerString;
    if (shapeModel.isParallelogram() && previousShapeSnapshot.isParallelogram) {
      // remained a parallelogram through changes
      if (responseReason === 'angle') {
        // angle is the dominant response and caused the change, we are describing change in side tilt
        const tiltChangeString = this.getTiltOrStraightenDescription(previousShapeSnapshot);
        response = StringUtils.fillIn(oppositeSidesTiltPatternString, {
          tiltChange: tiltChangeString
        });
      } else if (responseReason === 'length') {
        // lengths changed enough while in parallel to describe length without describing tilt
        const patternString = oppositeSidesInParallelPatternString;
        response = StringUtils.fillIn(patternString, {
          areaChange: areaChangeString
        });
      }
    } else {
      const sideABsideCDParallelBefore = previousShapeSnapshot.sideABsideCDParallel;
      const sideBCSideDAParallelBefore = previousShapeSnapshot.sideBCsideDAParallel;
      const sideABSideCDParallelAfter = shapeModel.sideABSideCDParallelSideChecker.areSidesParallel();
      const sideBCSideDAParallelAfter = shapeModel.sideBCSideDAParallelSideChecker.areSidesParallel();

      // for readability, cases are determined by current and change in side parallel state of sides
      const onlyOneParallelAfter = sideABSideCDParallelAfter !== sideBCSideDAParallelAfter;
      const neitherParallelBefore = !sideABsideCDParallelBefore && !sideBCSideDAParallelBefore;
      const neitherParallelAfter = !sideABSideCDParallelAfter && !sideBCSideDAParallelAfter;
      const atLeastOneParallelBefore = sideABsideCDParallelBefore || sideBCSideDAParallelBefore;

      // Any remaining parallel sides are described, determine which opposite sides to use
      let firstSideString;
      let secondSideString;
      if (sideABSideCDParallelAfter) {
        firstSideString = aBString;
        secondSideString = cDString;
      } else {
        firstSideString = bCString;
        secondSideString = dAString;
      }
      if (neitherParallelBefore && onlyOneParallelAfter) {
        const patternString = oppositeSidesInParallelAsCornersChangeEquallyPatternString;
        response = StringUtils.fillIn(patternString, {
          firstSide: firstSideString,
          secondSide: secondSideString
        });
      } else if (onlyOneParallelAfter) {
        // if one pair of sides remains in parallel after the change, and it is the same side pair
        const patternString = oppositeSidesTiltAsShapeChangesPatternString;
        response = StringUtils.fillIn(patternString, {
          firstSide: firstSideString,
          secondSide: secondSideString,
          areaChange: areaChangeString
        });
      } else if (atLeastOneParallelBefore && neitherParallelAfter) {
        // at least one to zero parallel side pairs
        response = allSidesTiltAwayFromParallelString;
      } else if (neitherParallelBefore && neitherParallelAfter) {
        // no parallel side pairs before and after
        const patternString = allSidesTiltAwayFromParallelAsShapeChangesPatternString;
        response = StringUtils.fillIn(patternString, {
          areaChange: areaChangeString
        });
      }
    }
    return response;
  }

  /**
   * Returns a description of the shape for a context response as movements occur that maintain the same
   * named shape. For example, moving one side to make a longer rectangle. See
   * https://github.com/phetsims/quadrilateral/issues/198 for more information about the design for this function.
   *
   * Will return something like:
   * "All right angles as shape gets bigger." or
   * "Opposite sides BC and DA equal as shape gets bigger." or
   * "Opposite sides in parallel as opposite corners change equally."
   */
  getShapeMaintenanceContextResponse(shapeName, previousShapeSnapshot, thisResponseReason) {
    let response = null;
    const areaDifference = this.quadrilateralShapeModel.areaProperty.value - previousShapeSnapshot.area;
    const areaChangeString = areaDifference > 0 ? biggerString : smallerString;
    if (shapeName === NamedQuadrilateral.CONVEX_QUADRILATERAL || shapeName === NamedQuadrilateral.CONCAVE_QUADRILATERAL) {
      response = StringUtils.fillIn(allSidesTiltAwayFromParallelAsShapeChangesPatternString, {
        areaChange: areaChangeString
      });
    } else if (shapeName === NamedQuadrilateral.TRIANGLE) {
      const flatVertex = _.find(this.quadrilateralShapeModel.vertices, vertex => this.quadrilateralShapeModel.isStaticAngleEqualToOther(vertex.angleProperty.value, Math.PI));

      // consider small enough values as 'constant area' because the area might change by negligible values within
      // precision error
      if (areaDifference < 1e-5) {
        // We have a triangle one vertex is 180 degrees and the shape is moving such that the area
        // is not changing. Describe the "flat" vertex and how its adjacent sides get longer or shorter
        response = StringUtils.fillIn(cornerFlatAsShapeChangesPatternString, {
          cornerLabel: QuadrilateralVertexDescriber.VERTEX_CORNER_LABEL_MAP.get(flatVertex.vertexLabel)
        });
      } else {
        // We have a triangle being maintained but the area is changing, so we describe how it the adjacent
        // sides remain in line as the shape gets bigger or smaller

        // find the sides that are connected to the flat vertex
        const flatSides = _.filter(this.quadrilateralShapeModel.sides, side => side.vertex1 === flatVertex || side.vertex2 === flatVertex);
        assert && assert(flatSides.length === 2, 'We should have found two sides connected to the flat vertex');
        response = StringUtils.fillIn(adjacentSidesInLinePatternString, {
          firstSide: QuadrilateralDescriber.getSideLabelString(flatSides[0].sideLabel),
          secondSide: QuadrilateralDescriber.getSideLabelString(flatSides[1].sideLabel),
          areaChange: areaChangeString
        });
      }
    } else if (shapeName === NamedQuadrilateral.DART || shapeName === NamedQuadrilateral.KITE) {
      response = StringUtils.fillIn(adjacentSidesChangeEquallyAsShapeChangesPatternString, {
        areaChange: areaChangeString
      });
    } else if (shapeName === NamedQuadrilateral.TRAPEZOID) {
      const sideABSideCDParallel = previousShapeSnapshot.sideABsideCDParallel;
      let firstSideString;
      let secondSideString;
      if (sideABSideCDParallel) {
        firstSideString = aBString;
        secondSideString = cDString;
      } else {
        firstSideString = bCString;
        secondSideString = dAString;
      }
      response = StringUtils.fillIn(maintainingATrapezoidAsShapeChangesPatternString, {
        firstSide: firstSideString,
        secondSide: secondSideString,
        areaChange: areaChangeString
      });
    } else if (shapeName === NamedQuadrilateral.ISOSCELES_TRAPEZOID) {
      // For an isosceles trapezoid, describe the sides that remain equal in length
      const sideABSideCDParallel = previousShapeSnapshot.sideABsideCDParallel;

      // For an isosceles trapezoid, the non-parallel sides are the equal ones in length - we can use that without
      // searching through model Properties
      let firstSideString;
      let secondSideString;
      if (sideABSideCDParallel) {
        firstSideString = bCString;
        secondSideString = dAString;
      } else {
        firstSideString = aBString;
        secondSideString = cDString;
      }
      response = StringUtils.fillIn(oppositeSidesEqualAsShapeChangesPatternString, {
        firstSide: firstSideString,
        secondSide: secondSideString,
        areaChange: areaChangeString
      });
    } else if (shapeName === NamedQuadrilateral.PARALLELOGRAM) {
      if (thisResponseReason === 'angle') {
        response = StringUtils.fillIn(maintainingAParallelogramAngleResponseString, {
          areaChange: areaChangeString
        });
      } else {
        response = StringUtils.fillIn(maintainingAParallelogramLengthResponsePatternString, {
          areaChange: areaChangeString
        });
      }
    } else if (shapeName === NamedQuadrilateral.RECTANGLE) {
      response = StringUtils.fillIn(allRightAnglesAsShapeChangesPatternString, {
        areaChange: areaChangeString
      });
    } else if (shapeName === NamedQuadrilateral.RHOMBUS) {
      response = maintainingARhombusString;
    } else if (shapeName === NamedQuadrilateral.SQUARE) {
      response = StringUtils.fillIn(allSidesEqualAsShapeChangesPatternString, {
        areaChange: areaChangeString
      });
    }
    return response;
  }

  /**
   * Returns a description about whether the shape is "tilting" or "straightening" based on how the angles at each
   * vertex changed from the previous snapshot.
   */
  getTiltOrStraightenDescription(previousShapeSnapshot) {
    // angle is the dominant response and caused the change, we are describing change in side tilt
    const currentDistancesToRight = [this.quadrilateralShapeModel.vertexA.angleProperty.value, this.quadrilateralShapeModel.vertexB.angleProperty.value, this.quadrilateralShapeModel.vertexC.angleProperty.value, this.quadrilateralShapeModel.vertexD.angleProperty.value].map(QuadrilateralAlerter.distanceFromRightAngle);
    const previousDistancesToRight = [previousShapeSnapshot.vertexAAngle, previousShapeSnapshot.vertexBAngle, previousShapeSnapshot.vertexCAngle, previousShapeSnapshot.vertexDAngle].map(QuadrilateralAlerter.distanceFromRightAngle);
    const differences = [];
    for (let i = 0; i < currentDistancesToRight.length; i++) {
      differences.push(currentDistancesToRight[i] - previousDistancesToRight[i]);
    }

    // If the distances to pi for every angle have gotten smaller, we are getting closer to right angles, that is
    // described as "straighten"
    return _.every(differences, difference => difference > 0) ? tiltString : straightenString;
  }

  /**
   * Return distance (absolute value) of an angle against a right angle (pi/2).
   */
  static distanceFromRightAngle(angle) {
    return Math.abs(Math.PI / 2 - angle);
  }

  /**
   * Returns a direction description for the change in position as an object moves from position1 to position2.
   * Positions in model coordinates.
   */
  static getDirectionDescription(previousPosition, currentPosition, modelViewTransform) {
    const translationVector = currentPosition.minus(previousPosition);
    const movementAngle = translationVector.angle;
    return MovementAlerter.getDirectionDescriptionFromAngle(movementAngle, {
      modelViewTransform: modelViewTransform
    });
  }

  /**
   * Get a response that describes changes to the detected shape name. As decided by design/pedagogy, this is the most
   * important information to describe as things change.
   */
  getShapeNameChangeResponse() {
    const currentShapeName = this.model.quadrilateralShapeModel.shapeNameProperty.value;
    let contextResponse = null;
    if (currentShapeName !== this.previousContextResponseShapeSnapshot.namedQuadrilateral) {
      if (this.model.visibilityModel.shapeNameVisibleProperty.value) {
        contextResponse = this.getFoundShapeResponse(currentShapeName);
      } else {
        contextResponse = this.describer.getShapePropertiesDescription();
      }
    }
    return contextResponse;
  }

  /**
   * Returns a string describing a newly found shape. Returns something like
   * "Found a square." or
   * "Found an isosceles trapezoid."
   */
  getFoundShapeResponse(namedQuadrilateral) {
    return StringUtils.fillIn(foundShapePatternString, {
      shapeName: QuadrilateralDescriber.getShapeNameWithArticlesDescription(namedQuadrilateral)
    });
  }
}
quadrilateral.register('QuadrilateralAlerter', QuadrilateralAlerter);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJxdWFkcmlsYXRlcmFsIiwiVXR0ZXJhbmNlIiwiQWxlcnRlciIsIlZvaWNpbmciLCJSZXNwb25zZVBhY2tldCIsIlF1YWRyaWxhdGVyYWxTdHJpbmdzIiwiUXVhZHJpbGF0ZXJhbFNoYXBlU25hcHNob3QiLCJRdWFkcmlsYXRlcmFsU2lkZSIsIlN0cmluZ1V0aWxzIiwiTW92ZW1lbnRBbGVydGVyIiwiVXRpbHMiLCJOYW1lZFF1YWRyaWxhdGVyYWwiLCJRdWFkcmlsYXRlcmFsRGVzY3JpYmVyIiwiUXVhZHJpbGF0ZXJhbFZlcnRleERlc2NyaWJlciIsImZvdW5kU2hhcGVQYXR0ZXJuU3RyaW5nIiwiYTExeSIsInZvaWNpbmciLCJmb3VuZFNoYXBlUGF0dGVyblN0cmluZ1Byb3BlcnR5IiwidmFsdWUiLCJhQlN0cmluZyIsImFCU3RyaW5nUHJvcGVydHkiLCJiQ1N0cmluZyIsImJDU3RyaW5nUHJvcGVydHkiLCJjRFN0cmluZyIsImNEU3RyaW5nUHJvcGVydHkiLCJkQVN0cmluZyIsImRBU3RyaW5nUHJvcGVydHkiLCJvcHBvc2l0ZVNpZGVzVGlsdFBhdHRlcm5TdHJpbmciLCJvcHBvc2l0ZVNpZGVzVGlsdFBhdHRlcm5TdHJpbmdQcm9wZXJ0eSIsIm9wcG9zaXRlU2lkZXNJblBhcmFsbGVsUGF0dGVyblN0cmluZyIsIm9wcG9zaXRlU2lkZXNJblBhcmFsbGVsUGF0dGVyblN0cmluZ1Byb3BlcnR5Iiwib3Bwb3NpdGVTaWRlc0luUGFyYWxsZWxBc0Nvcm5lcnNDaGFuZ2VFcXVhbGx5UGF0dGVyblN0cmluZyIsIm9wcG9zaXRlU2lkZXNJblBhcmFsbGVsQXNDb3JuZXJzQ2hhbmdlRXF1YWxseVBhdHRlcm5TdHJpbmdQcm9wZXJ0eSIsIm9wcG9zaXRlU2lkZXNUaWx0QXNTaGFwZUNoYW5nZXNQYXR0ZXJuU3RyaW5nIiwib3Bwb3NpdGVTaWRlc1RpbHRBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmdQcm9wZXJ0eSIsIm9wcG9zaXRlU2lkZXNFcXVhbEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZyIsIm9wcG9zaXRlU2lkZXNFcXVhbEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZ1Byb3BlcnR5IiwibWFpbnRhaW5pbmdBUGFyYWxsZWxvZ3JhbUFuZ2xlUmVzcG9uc2VTdHJpbmciLCJtYWludGFpbmluZ0FQYXJhbGxlbG9ncmFtQW5nbGVSZXNwb25zZVN0cmluZ1Byb3BlcnR5IiwibWFpbnRhaW5pbmdBUGFyYWxsZWxvZ3JhbUxlbmd0aFJlc3BvbnNlUGF0dGVyblN0cmluZyIsIm1haW50YWluaW5nQVBhcmFsbGVsb2dyYW1MZW5ndGhSZXNwb25zZVBhdHRlcm5TdHJpbmdQcm9wZXJ0eSIsIm1haW50YWluaW5nQVRyYXBlem9pZEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZyIsIm1haW50YWluaW5nQVRyYXBlem9pZEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZ1Byb3BlcnR5IiwiYWxsUmlnaHRBbmdsZXNBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmciLCJhbGxSaWdodEFuZ2xlc0FzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZ1Byb3BlcnR5IiwibWFpbnRhaW5pbmdBUmhvbWJ1c1N0cmluZyIsIm1haW50YWluaW5nQVJob21idXNTdHJpbmdQcm9wZXJ0eSIsImFsbFNpZGVzRXF1YWxBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmciLCJhbGxTaWRlc0VxdWFsQXNTaGFwZUNoYW5nZXNQYXR0ZXJuU3RyaW5nUHJvcGVydHkiLCJjb3JuZXJGbGF0QXNTaGFwZUNoYW5nZXNQYXR0ZXJuU3RyaW5nIiwiY29ybmVyRmxhdEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZ1Byb3BlcnR5IiwiYWRqYWNlbnRTaWRlc0NoYW5nZUVxdWFsbHlBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmciLCJhZGphY2VudFNpZGVzQ2hhbmdlRXF1YWxseUFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZ1Byb3BlcnR5IiwiYWxsU2lkZXNUaWx0QXdheUZyb21QYXJhbGxlbFN0cmluZyIsImFsbFNpZGVzVGlsdEF3YXlGcm9tUGFyYWxsZWxTdHJpbmdQcm9wZXJ0eSIsImFsbFNpZGVzVGlsdEF3YXlGcm9tUGFyYWxsZWxBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmciLCJhbGxTaWRlc1RpbHRBd2F5RnJvbVBhcmFsbGVsQXNTaGFwZUNoYW5nZXNQYXR0ZXJuU3RyaW5nUHJvcGVydHkiLCJ0aWx0U3RyaW5nIiwidGlsdFN0cmluZ1Byb3BlcnR5Iiwic3RyYWlnaHRlblN0cmluZyIsInN0cmFpZ2h0ZW5TdHJpbmdQcm9wZXJ0eSIsImJpZ2dlclN0cmluZyIsImJpZ2dlclN0cmluZ1Byb3BlcnR5Iiwic21hbGxlclN0cmluZyIsInNtYWxsZXJTdHJpbmdQcm9wZXJ0eSIsInZlcnRleEFTdHJpbmciLCJ2ZXJ0ZXhBU3RyaW5nUHJvcGVydHkiLCJ2ZXJ0ZXhCU3RyaW5nIiwidmVydGV4QlN0cmluZ1Byb3BlcnR5IiwidmVydGV4Q1N0cmluZyIsInZlcnRleENTdHJpbmdQcm9wZXJ0eSIsInZlcnRleERTdHJpbmciLCJ2ZXJ0ZXhEU3RyaW5nUHJvcGVydHkiLCJiYWNrU3RyaW5nIiwiYmFja1N0cmluZ1Byb3BlcnR5IiwiZ29uZVN0cmluZyIsImdvbmVTdHJpbmdQcm9wZXJ0eSIsImNvcm5lcnNCYWNrU3RyaW5nIiwiY29ybmVyc0JhY2tTdHJpbmdQcm9wZXJ0eSIsImNvcm5lcnNHb25lU3RyaW5nIiwiY29ybmVyc0dvbmVTdHJpbmdQcm9wZXJ0eSIsImNvcm5lckRldGVjdGVkUGF0dGVyblN0cmluZyIsImNvcm5lckRldGVjdGVkUGF0dGVyblN0cmluZ1Byb3BlcnR5Iiwic2hvcnRlclN0cmluZyIsInNpZGVEcmFnT2JqZWN0UmVzcG9uc2UiLCJzaG9ydGVyU3RyaW5nUHJvcGVydHkiLCJsb25nZXJTdHJpbmciLCJsb25nZXJTdHJpbmdQcm9wZXJ0eSIsIndpZGVyU3RyaW5nIiwidmVydGV4RHJhZ09iamVjdFJlc3BvbnNlIiwid2lkZXJTdHJpbmdQcm9wZXJ0eSIsInZlcnRleERyYWdTbWFsbGVyU3RyaW5nIiwidmVydGV4RHJhZ09iamVjdFJlc3BvbnNlUGF0dGVyblN0cmluZyIsInZlcnRleERyYWdPYmplY3RSZXNwb25zZVBhdHRlcm5TdHJpbmdQcm9wZXJ0eSIsImFkamFjZW50U2lkZXNDaGFuZ2VQYXR0ZXJuU3RyaW5nIiwiYWRqYWNlbnRTaWRlc0NoYW5nZVBhdHRlcm5TdHJpbmdQcm9wZXJ0eSIsInJpZ2h0QW5nbGVTdHJpbmciLCJyaWdodEFuZ2xlU3RyaW5nUHJvcGVydHkiLCJhbmdsZUZsYXRTdHJpbmciLCJhbmdsZUZsYXRTdHJpbmdQcm9wZXJ0eSIsImFuZ2xlQ29tcGFyaXNvblBhdHRlcm5TdHJpbmciLCJhbmdsZUNvbXBhcmlzb25QYXR0ZXJuU3RyaW5nUHJvcGVydHkiLCJvcHBvc2l0ZUNvcm5lclN0cmluZyIsIm9wcG9zaXRlQ29ybmVyU3RyaW5nUHJvcGVydHkiLCJhZGphY2VudENvcm5lcnNFcXVhbFN0cmluZyIsImFkamFjZW50Q29ybmVyc0VxdWFsU3RyaW5nUHJvcGVydHkiLCJhZGphY2VudENvcm5lcnNSaWdodEFuZ2xlc1N0cmluZyIsImFkamFjZW50Q29ybmVyc1JpZ2h0QW5nbGVzU3RyaW5nUHJvcGVydHkiLCJwcm9ncmVzc1N0YXRlUGF0dGVyblN0cmluZyIsInByb2dyZXNzU3RhdGVQYXR0ZXJuU3RyaW5nUHJvcGVydHkiLCJlcXVhbFRvT3Bwb3NpdGVDb3JuZXJFcXVhbFRvQWRqYWNlbnRDb3JuZXJzU3RyaW5nIiwiZXF1YWxUb09wcG9zaXRlQ29ybmVyRXF1YWxUb0FkamFjZW50Q29ybmVyc1N0cmluZ1Byb3BlcnR5IiwiYWRqYWNlbnRTaWRlc0luTGluZVBhdHRlcm5TdHJpbmciLCJhZGphY2VudFNpZGVzSW5MaW5lUGF0dGVyblN0cmluZ1Byb3BlcnR5IiwiZXF1YWxUb0FkamFjZW50Q29ybmVyc1N0cmluZyIsImVxdWFsVG9BZGphY2VudENvcm5lcnNTdHJpbmdQcm9wZXJ0eSIsImFkamFjZW50U2lkZXNDaGFuZ2VJbkxlbmd0aFN0cmluZyIsImFkamFjZW50U2lkZXNDaGFuZ2VJbkxlbmd0aFN0cmluZ1Byb3BlcnR5IiwicGFyYWxsZWxBZGphY2VudFNpZGVzQ2hhbmdlUGF0dGVyblN0cmluZyIsInBhcmFsbGVsQWRqYWNlbnRTaWRlc0NoYW5nZVBhdHRlcm5TdHJpbmdQcm9wZXJ0eSIsImVxdWFsQWRqYWNlbnRTaWRlc0NoYW5nZVBhdHRlcm5TdHJpbmciLCJlcXVhbEFkamFjZW50U2lkZXNDaGFuZ2VQYXR0ZXJuU3RyaW5nUHJvcGVydHkiLCJlcXVhbFRvQWRqYWNlbnRTaWRlc1N0cmluZyIsImVxdWFsVG9BZGphY2VudFNpZGVzU3RyaW5nUHJvcGVydHkiLCJhZGphY2VudFNpZGVzRXF1YWxTdHJpbmciLCJhZGphY2VudFNpZGVzRXF1YWxTdHJpbmdQcm9wZXJ0eSIsImFkamFjZW50U2lkZXNQYXJhbGxlbFN0cmluZyIsImFkamFjZW50U2lkZXNQYXJhbGxlbFN0cmluZ1Byb3BlcnR5IiwiZXF1YWxUb09uZUFkamFjZW50U2lkZVN0cmluZyIsImVxdWFsVG9PbmVBZGphY2VudFNpZGVTdHJpbmdQcm9wZXJ0eSIsInR3b1NpZGVzRXF1YWxTdHJpbmciLCJ0d29TaWRlc0VxdWFsU3RyaW5nUHJvcGVydHkiLCJ0aHJlZVNpZGVzRXF1YWxTdHJpbmciLCJ0aHJlZVNpZGVzRXF1YWxTdHJpbmdQcm9wZXJ0eSIsIkFOR0xFX1JFU1BPTlNFX1RIUkVTSE9MRCIsIk1hdGgiLCJQSSIsIkFOR0xFX0RJRkZFUkVOQ0VTX0xBUkdFX1RIUkVTSE9MRCIsIlF1YWRyaWxhdGVyYWxBbGVydGVyIiwiYW5nbGVSZXNwb25zZVJlYWR5IiwibGVuZ3RoUmVzcG9uc2VSZWFkeSIsImNvbnN0cnVjdG9yIiwibW9kZWwiLCJzY3JlZW5WaWV3IiwibW9kZWxWaWV3VHJhbnNmb3JtIiwiZGVzY3JpYmVyIiwicXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwiLCJwcmV2aW91c0NvbnRleHRSZXNwb25zZVNoYXBlU25hcHNob3QiLCJwcmV2aW91c09iamVjdFJlc3BvbnNlU2hhcGVTbmFwc2hvdCIsIndhc1NpZGVBQlNpZGVDRFBhcmFsbGVsIiwic2lkZUFCU2lkZUNEUGFyYWxsZWxTaWRlQ2hlY2tlciIsImFyZVNpZGVzUGFyYWxsZWwiLCJ3YXNTaWRlQkNTaWRlREFQYXJhbGxlbCIsInNpZGVCQ1NpZGVEQVBhcmFsbGVsU2lkZUNoZWNrZXIiLCJsb3dQcmlvcml0eVV0dGVyYW5jZSIsInByaW9yaXR5IiwiTE9XX1BSSU9SSVRZIiwibWVkaXVtUHJpb3JpdHlVdHRlcmFuY2UiLCJNRURJVU1fUFJJT1JJVFkiLCJoaWdoUHJpb3JpdHlVdHRlcmFuY2UiLCJISUdIX1BSSU9SSVRZIiwicmVzZXROb3RJblByb2dyZXNzUHJvcGVydHkiLCJsaW5rIiwicmVzZXROb3RJblByb2dyZXNzIiwic2hhcGVDaGFuZ2VkRW1pdHRlciIsImFkZExpc3RlbmVyIiwicmVzcG9uc2VQYWNrZXQiLCJ1dHRlcmFuY2UiLCJwcmV2aW91c0FBbmdsZSIsInZlcnRleEFBbmdsZSIsInByZXZpb3VzQkFuZ2xlIiwidmVydGV4QkFuZ2xlIiwicHJldmlvdXNDQW5nbGUiLCJ2ZXJ0ZXhDQW5nbGUiLCJwcmV2aW91c0RBbmdsZSIsInZlcnRleERBbmdsZSIsImFBbmdsZURpZmZlcmVuY2UiLCJ2ZXJ0ZXhBIiwiYW5nbGVQcm9wZXJ0eSIsImJBbmdsZURpZmZlcmVuY2UiLCJ2ZXJ0ZXhCIiwiY0FuZ2xlRGlmZmVyZW5jZSIsInZlcnRleEMiLCJkQW5nbGVEaWZmZXJlbmNlIiwidmVydGV4RCIsImFuZ2xlRGlmZmVyZW5jZXMiLCJfIiwic29tZSIsImFuZ2xlRGlmZmVyZW5jZSIsImFicyIsInByZXZpb3VzQUJMZW5ndGgiLCJzaWRlQUJMZW5ndGgiLCJwcmV2aW91c0JDTGVuZ3RoIiwic2lkZUJDTGVuZ3RoIiwicHJldmlvdXNDRExlbmd0aCIsInNpZGVDRExlbmd0aCIsInByZXZpb3VzREFMZW5ndGgiLCJzaWRlREFMZW5ndGgiLCJhYkxlbmd0aERpZmZlcmVuY2UiLCJzaWRlQUIiLCJsZW5ndGhQcm9wZXJ0eSIsImJjTGVuZ3RoRGlmZmVyZW5jZSIsInNpZGVCQyIsImNkTGVuZ3RoRGlmZmVyZW5jZSIsInNpZGVDRCIsImRhTGVuZ3RoRGlmZmVyZW5jZSIsInNpZGVEQSIsImxlbmd0aERpZmZlcmVuY2VzIiwiYW5nbGVEaWZmZXJlbmNlc0xhcmdlIiwibGVuZ3RoRGlmZmVyZW5jZSIsIlNJREVfU0VHTUVOVF9MRU5HVEgiLCJzaWRlQUJTaWRlQ0RQYXJhbGxlbEFmdGVyIiwic2lkZUJDU2lkZURBUGFyYWxsZWxBZnRlciIsInBhcmFsbGVsU2lkZVJlc3BvbnNlUmVhZHkiLCJzaGFwZU5hbWVDaGFuZ2VSZXNwb25zZSIsImdldFNoYXBlTmFtZUNoYW5nZVJlc3BvbnNlIiwiY29udGV4dFJlc3BvbnNlIiwidGhpc1Jlc3BvbnNlUmVhc29uIiwibmFtZWRRdWFkcmlsYXRlcmFsIiwic2hhcGVOYW1lUHJvcGVydHkiLCJzaGFwZU1haW50ZW5hbmNlUmVzcG9uc2UiLCJnZXRTaGFwZU1haW50ZW5hbmNlQ29udGV4dFJlc3BvbnNlIiwidGlsdENoYW5nZVJlc3BvbnNlIiwiZ2V0U2hhcGVDaGFuZ2VSZXNwb25zZSIsInNpZGVzIiwiZm9yRWFjaCIsInNpZGUiLCJ2b2ljaW5nT2JqZWN0UmVzcG9uc2VEaXJ0eSIsIm9iamVjdFJlc3BvbnNlIiwiZ2V0U2lkZUNoYW5nZU9iamVjdFJlc3BvbnNlIiwidmVydGljZXMiLCJ2ZXJ0ZXgiLCJnZXRWZXJ0ZXhDaGFuZ2VPYmplY3RSZXNwb25zZSIsImFsZXJ0IiwibWFya2VyUmVzcG9uc2VQYWNrZXQiLCJtYXJrZXJVdHRlcmFuY2UiLCJtYXJrZXJEZXRlY3Rpb25Nb2RlbCIsInRhbmdpYmxlQ29ubmVjdGlvbk1vZGVsIiwiYWxsVmVydGV4TWFya2Vyc0RldGVjdGVkUHJvcGVydHkiLCJhbGxWZXJ0ZXhNYXJrZXJzRGV0ZWN0ZWQiLCJtYXJrZXJSZXNwb25zZXNFbmFibGVkUHJvcGVydHkiLCJ2ZXJ0ZXhEZXRlY3Rpb25SZXNwb25zZUxpc3RlbmVyIiwibGFiZWxTdHJpbmciLCJkZXRlY3RlZCIsInN0YXRlU3RyaW5nIiwiZmlsbEluIiwibGFiZWwiLCJzdGF0ZSIsInZlcnRleEFNYXJrZXJEZXRlY3RlZFByb3BlcnR5IiwidmVydGV4Qk1hcmtlckRldGVjdGVkUHJvcGVydHkiLCJ2ZXJ0ZXhDTWFya2VyRGV0ZWN0ZWRQcm9wZXJ0eSIsInZlcnRleERNYXJrZXJEZXRlY3RlZFByb3BlcnR5IiwicmVnaXN0ZXJVdHRlcmFuY2VUb05vZGUiLCJyZXNwb25zZSIsImxlbmd0aFRvbGVyYW5jZSIsImludGVyTGVuZ3RoVG9sZXJhbmNlSW50ZXJ2YWwiLCJzaGFwZU1vZGVsIiwidG9sZXJhbmNlRm9yRGVzY3JpYmluZ0xlbmd0aENoYW5nZSIsImN1cnJlbnRTaGFwZVNuYXBzaG90IiwicHJldmlvdXNBZGphY2VudExlbmd0aHMiLCJnZXRBZGphY2VudFNpZGVMZW5ndGhzRnJvbVNpZGVMYWJlbCIsInNpZGVMYWJlbCIsImZpcnN0UHJldmlvdXNBZGphY2VudFNpZGVMZW5ndGgiLCJzZWNvbmRQcmV2aW91c0FkamFjZW50U2lkZUxlbmd0aCIsInByZXZpb3VzQWRqYWNlbnRTaWRlc0VxdWFsIiwiZXF1YWxzRXBzaWxvbiIsInByZXZpb3VzQWRqYWNlbnRTaWRlc1BhcmFsbGVsIiwiZ2V0QWRqYWNlbnRTaWRlc1BhcmFsbGVsRnJvbVNpZGVMYWJlbCIsInByZXZpb3VzTGVuZ3RoIiwiZ2V0TGVuZ3RoRnJvbVNpZGVMYWJlbCIsInByZXZpb3VzRXF1YWxUb0ZpcnN0QWRqYWNlbnQiLCJpc0ludGVyTGVuZ3RoRXF1YWxUb090aGVyIiwicHJldmlvdXNFcXVhbFRvU2Vjb25kQWRqYWNlbnQiLCJwcmV2aW91c0VxdWFsVG9PbmVBZGphY2VudCIsInByZXZpb3VzTnVtYmVyT2ZFcXVhbFNpZGVzIiwiY291bnROdW1iZXJPZkVxdWFsU2lkZXMiLCJhZGphY2VudFNpZGVzIiwiZmlyc3RBZGphY2VudFNpZGVMZW5ndGgiLCJzZWNvbmRBZGphY2VudFNpZGVMZW5ndGgiLCJhZGphY2VudFNpZGVzRXF1YWwiLCJhZGphY2VudFNpZGVzUGFyYWxsZWwiLCJzaWRlTGVuZ3RoIiwiZXF1YWxUb0ZpcnN0QWRqYWNlbnQiLCJlcXVhbFRvU2Vjb25kQWRqYWNlbnQiLCJlcXVhbFRvT25lQWRqYWNlbnQiLCJudW1iZXJPZkVxdWFsU2lkZXMiLCJmaXJzdEFkamFjZW50U2lkZUxlbmd0aERpZmZlcmVuY2UiLCJzZWNvbmRBZGphY2VudFNpZGVMZW5ndGhEaWZmZXJlbmNlIiwiZmlyc3RTaWRlQWJzb2x1dGVEaWZmZXJlbmNlIiwic2Vjb25kU2lkZUFic29sdXRlRGlmZmVyZW5jZSIsInNpZ24iLCJhZGphY2VudFNpZGVzTG9uZ2VyIiwiY2hhbmdlU3RyaW5nIiwibGVuZ3RoQ2hhbmdlIiwiY3VycmVudFZlcnRleDFQb3NpdGlvbiIsInZlcnRleDEiLCJwb3NpdGlvblByb3BlcnR5IiwicHJldmlvdXNWZXJ0ZXgxUG9zaXRpb24iLCJnZXRWZXJ0ZXhQb3NpdGlvbnNGcm9tU2lkZUxhYmVsIiwiZ2V0RGlyZWN0aW9uRGVzY3JpcHRpb24iLCJwcm9ncmVzc1Jlc3BvbnNlIiwic3RhdGVSZXNwb25zZSIsInZlcnRleERlc2NyaWJlciIsImdldFZlcnRleERlc2NyaWJlckZvckxhYmVsIiwidmVydGV4TGFiZWwiLCJjdXJyZW50QW5nbGUiLCJwcmV2aW91c0FuZ2xlIiwiZ2V0QW5nbGVGcm9tVmVydGV4TGFiZWwiLCJvcHBvc2l0ZVZlcnRleCIsIm9wcG9zaXRlVmVydGV4TWFwIiwiZ2V0Iiwib3Bwb3NpdGVWZXJ0ZXhBbmdsZSIsImFkamFjZW50VmVydGljZXMiLCJhZGphY2VudFZlcnRleE1hcCIsImZpcnN0QWRqYWNlbnRWZXJ0ZXgiLCJmaXJzdEFkamFjZW50QW5nbGUiLCJzZWNvbmRBZGphY2VudFZlcnRleCIsInNlY29uZEFkamFjZW50QW5nbGUiLCJhbmdsZUVxdWFsVG9GaXJzdEFkamFjZW50IiwiaXNJbnRlckFuZ2xlRXF1YWxUb090aGVyIiwiYW5nbGVFcXVhbFRvU2Vjb25kQWRqYWNlbnQiLCJhbmdsZUVxdWFsVG9PcHBvc2l0ZSIsImN1cnJlbnRQb3NpdGlvbiIsInByZXZpb3VzUG9zaXRpb24iLCJnZXRQb3NpdGlvbkZyb21WZXJ0ZXhMYWJlbCIsImlzUmlnaHRBbmdsZSIsImlzRmxhdEFuZ2xlIiwiYW5nbGVDaGFuZ2VTdHJpbmciLCJhbmdsZUNoYW5nZSIsInNoYXBlTmFtZSIsImdldEFyZUFsbEFuZ2xlc1JpZ2h0Iiwib3RoZXJWZXJ0ZXgiLCJvdGhlckNvcm5lckxhYmVsU3RyaW5nIiwiVkVSVEVYX0NPUk5FUl9MQUJFTF9NQVAiLCJjb21wYXJpc29uRGVzY3JpcHRpb24iLCJnZXRBbmdsZUNvbXBhcmlzb25EZXNjcmlwdGlvbiIsImNvbXBhcmlzb24iLCJjb3JuZXJMYWJlbCIsInNob3VsZFVzZUFuZ2xlQ29tcGFyaXNvbkRlc2NyaXB0aW9uIiwiYXNzZXJ0IiwicHJvZ3Jlc3MiLCJjaGFuZ2luZ1ZlcnRleEFuZ2xlIiwib3RoZXJWZXJ0ZXhBbmdsZSIsImlzQW5nbGVBYm91dEhhbGZPdGhlciIsImlzQW5nbGVBYm91dFR3aWNlT3RoZXIiLCJwcmV2aW91c1NoYXBlU25hcHNob3QiLCJyZXNwb25zZVJlYXNvbiIsImFyZWFEaWZmZXJlbmNlIiwiYXJlYVByb3BlcnR5IiwiYXJlYSIsImFyZWFDaGFuZ2VTdHJpbmciLCJpc1BhcmFsbGVsb2dyYW0iLCJ0aWx0Q2hhbmdlU3RyaW5nIiwiZ2V0VGlsdE9yU3RyYWlnaHRlbkRlc2NyaXB0aW9uIiwidGlsdENoYW5nZSIsInBhdHRlcm5TdHJpbmciLCJhcmVhQ2hhbmdlIiwic2lkZUFCc2lkZUNEUGFyYWxsZWxCZWZvcmUiLCJzaWRlQUJzaWRlQ0RQYXJhbGxlbCIsInNpZGVCQ1NpZGVEQVBhcmFsbGVsQmVmb3JlIiwic2lkZUJDc2lkZURBUGFyYWxsZWwiLCJvbmx5T25lUGFyYWxsZWxBZnRlciIsIm5laXRoZXJQYXJhbGxlbEJlZm9yZSIsIm5laXRoZXJQYXJhbGxlbEFmdGVyIiwiYXRMZWFzdE9uZVBhcmFsbGVsQmVmb3JlIiwiZmlyc3RTaWRlU3RyaW5nIiwic2Vjb25kU2lkZVN0cmluZyIsImZpcnN0U2lkZSIsInNlY29uZFNpZGUiLCJDT05WRVhfUVVBRFJJTEFURVJBTCIsIkNPTkNBVkVfUVVBRFJJTEFURVJBTCIsIlRSSUFOR0xFIiwiZmxhdFZlcnRleCIsImZpbmQiLCJpc1N0YXRpY0FuZ2xlRXF1YWxUb090aGVyIiwiZmxhdFNpZGVzIiwiZmlsdGVyIiwidmVydGV4MiIsImxlbmd0aCIsImdldFNpZGVMYWJlbFN0cmluZyIsIkRBUlQiLCJLSVRFIiwiVFJBUEVaT0lEIiwic2lkZUFCU2lkZUNEUGFyYWxsZWwiLCJJU09TQ0VMRVNfVFJBUEVaT0lEIiwiUEFSQUxMRUxPR1JBTSIsIlJFQ1RBTkdMRSIsIlJIT01CVVMiLCJTUVVBUkUiLCJjdXJyZW50RGlzdGFuY2VzVG9SaWdodCIsIm1hcCIsImRpc3RhbmNlRnJvbVJpZ2h0QW5nbGUiLCJwcmV2aW91c0Rpc3RhbmNlc1RvUmlnaHQiLCJkaWZmZXJlbmNlcyIsImkiLCJwdXNoIiwiZXZlcnkiLCJkaWZmZXJlbmNlIiwiYW5nbGUiLCJ0cmFuc2xhdGlvblZlY3RvciIsIm1pbnVzIiwibW92ZW1lbnRBbmdsZSIsImdldERpcmVjdGlvbkRlc2NyaXB0aW9uRnJvbUFuZ2xlIiwiY3VycmVudFNoYXBlTmFtZSIsInZpc2liaWxpdHlNb2RlbCIsInNoYXBlTmFtZVZpc2libGVQcm9wZXJ0eSIsImdldEZvdW5kU2hhcGVSZXNwb25zZSIsImdldFNoYXBlUHJvcGVydGllc0Rlc2NyaXB0aW9uIiwiZ2V0U2hhcGVOYW1lV2l0aEFydGljbGVzRGVzY3JpcHRpb24iLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlF1YWRyaWxhdGVyYWxBbGVydGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSByZWFsLXRpbWUgZmVlZGJhY2sgYWxlcnRzIGZvciB0aGUgc2ltdWxhdGlvbiBhbmQgYWN0dWFsbHkgdm9pY2luZyB0aGVtIGF0IHRoZSByaWdodFxyXG4gKiB0aW1lLlxyXG4gKlxyXG4gKiBUaGlzIEFsZXJ0ZXIgbW9zdGx5IGdlbmVyYXRlcyBzdHJpbmdzIGJ5IGNvbXBhcmluZyB0aGUgc3RhdGUgb2YgdGhlIHF1YWRyaWxhdGVyYWwgdG8gYSBzbmFwc2hvdCBvZlxyXG4gKiB0aGUgZ2VvbWV0cmljIHByb3BlcnRpZXMgdGhhdCB3ZXJlIHNhdmVkIHRoZSBsYXN0IHRpbWUgdGhlIHF1YWRyaWxhdGVyYWwgd2FzIGRlc2NyaWJlZCAobWFraW5nIGhlYXZ5IHVzZSBvZlxyXG4gKiBRdWFkcmlsYXRlcmFsU2hhcGVTbmFwc2hvdCkuXHJcbiAqXHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBxdWFkcmlsYXRlcmFsIGZyb20gJy4uLy4uL3F1YWRyaWxhdGVyYWwuanMnO1xyXG5pbXBvcnQgUXVhZHJpbGF0ZXJhbE1vZGVsIGZyb20gJy4uL21vZGVsL1F1YWRyaWxhdGVyYWxNb2RlbC5qcyc7XHJcbmltcG9ydCBVdHRlcmFuY2UgZnJvbSAnLi4vLi4vLi4vLi4vdXR0ZXJhbmNlLXF1ZXVlL2pzL1V0dGVyYW5jZS5qcyc7XHJcbmltcG9ydCBBbGVydGVyIGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9hY2Nlc3NpYmlsaXR5L2Rlc2NyaWJlcnMvQWxlcnRlci5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsU2NyZWVuVmlldyBmcm9tICcuL1F1YWRyaWxhdGVyYWxTY3JlZW5WaWV3LmpzJztcclxuaW1wb3J0IHsgVm9pY2luZyB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBSZXNwb25zZVBhY2tldCBmcm9tICcuLi8uLi8uLi8uLi91dHRlcmFuY2UtcXVldWUvanMvUmVzcG9uc2VQYWNrZXQuanMnO1xyXG5pbXBvcnQgUXVhZHJpbGF0ZXJhbFN0cmluZ3MgZnJvbSAnLi4vLi4vUXVhZHJpbGF0ZXJhbFN0cmluZ3MuanMnO1xyXG5pbXBvcnQgUXVhZHJpbGF0ZXJhbFNoYXBlU25hcHNob3QgZnJvbSAnLi4vbW9kZWwvUXVhZHJpbGF0ZXJhbFNoYXBlU25hcHNob3QuanMnO1xyXG5pbXBvcnQgUXVhZHJpbGF0ZXJhbFNpZGUgZnJvbSAnLi4vbW9kZWwvUXVhZHJpbGF0ZXJhbFNpZGUuanMnO1xyXG5pbXBvcnQgUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwgZnJvbSAnLi4vbW9kZWwvUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwuanMnO1xyXG5pbXBvcnQgU3RyaW5nVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vcGhldGNvbW1vbi9qcy91dGlsL1N0cmluZ1V0aWxzLmpzJztcclxuaW1wb3J0IE1vdmVtZW50QWxlcnRlciBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvYWNjZXNzaWJpbGl0eS9kZXNjcmliZXJzL01vdmVtZW50QWxlcnRlci5qcyc7XHJcbmltcG9ydCBNb2RlbFZpZXdUcmFuc2Zvcm0yIGZyb20gJy4uLy4uLy4uLy4uL3BoZXRjb21tb24vanMvdmlldy9Nb2RlbFZpZXdUcmFuc2Zvcm0yLmpzJztcclxuaW1wb3J0IFF1YWRyaWxhdGVyYWxWZXJ0ZXggZnJvbSAnLi4vbW9kZWwvUXVhZHJpbGF0ZXJhbFZlcnRleC5qcyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVXRpbHMuanMnO1xyXG5pbXBvcnQgTmFtZWRRdWFkcmlsYXRlcmFsIGZyb20gJy4uL21vZGVsL05hbWVkUXVhZHJpbGF0ZXJhbC5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsRGVzY3JpYmVyLCB7IE51bGxhYmxlUXVhZHJpbGF0ZXJhbFN0cmluZ1R5cGUgfSBmcm9tICcuL1F1YWRyaWxhdGVyYWxEZXNjcmliZXIuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsVmVydGV4RGVzY3JpYmVyIGZyb20gJy4vUXVhZHJpbGF0ZXJhbFZlcnRleERlc2NyaWJlci5qcyc7XHJcblxyXG4vLyBjb25zdGFudHMgLSBWb2ljaW5nIHN0cmluZ3MgYXJlIG5vdCB0cmFuc2xhdGFibGUgc28gd2UganVzdCB1c2UgdGhlIFN0cmluZ1Byb3BlcnR5IGluaXRpYWwgdmFsdWVcclxuY29uc3QgZm91bmRTaGFwZVBhdHRlcm5TdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcuZm91bmRTaGFwZVBhdHRlcm5TdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgYUJTdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LmFCU3RyaW5nUHJvcGVydHkudmFsdWU7XHJcbmNvbnN0IGJDU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS5iQ1N0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBjRFN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkuY0RTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgZEFTdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LmRBU3RyaW5nUHJvcGVydHkudmFsdWU7XHJcbmNvbnN0IG9wcG9zaXRlU2lkZXNUaWx0UGF0dGVyblN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5vcHBvc2l0ZVNpZGVzVGlsdFBhdHRlcm5TdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3Qgb3Bwb3NpdGVTaWRlc0luUGFyYWxsZWxQYXR0ZXJuU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLm9wcG9zaXRlU2lkZXNJblBhcmFsbGVsUGF0dGVyblN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBvcHBvc2l0ZVNpZGVzSW5QYXJhbGxlbEFzQ29ybmVyc0NoYW5nZUVxdWFsbHlQYXR0ZXJuU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLm9wcG9zaXRlU2lkZXNJblBhcmFsbGVsQXNDb3JuZXJzQ2hhbmdlRXF1YWxseVBhdHRlcm5TdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3Qgb3Bwb3NpdGVTaWRlc1RpbHRBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcub3Bwb3NpdGVTaWRlc1RpbHRBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3Qgb3Bwb3NpdGVTaWRlc0VxdWFsQXNTaGFwZUNoYW5nZXNQYXR0ZXJuU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLm9wcG9zaXRlU2lkZXNFcXVhbEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBtYWludGFpbmluZ0FQYXJhbGxlbG9ncmFtQW5nbGVSZXNwb25zZVN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5tYWludGFpbmluZ0FQYXJhbGxlbG9ncmFtQW5nbGVSZXNwb25zZVN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBtYWludGFpbmluZ0FQYXJhbGxlbG9ncmFtTGVuZ3RoUmVzcG9uc2VQYXR0ZXJuU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLm1haW50YWluaW5nQVBhcmFsbGVsb2dyYW1MZW5ndGhSZXNwb25zZVBhdHRlcm5TdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgbWFpbnRhaW5pbmdBVHJhcGV6b2lkQXNTaGFwZUNoYW5nZXNQYXR0ZXJuU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLm1haW50YWluaW5nQVRyYXBlem9pZEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBhbGxSaWdodEFuZ2xlc0FzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5hbGxSaWdodEFuZ2xlc0FzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBtYWludGFpbmluZ0FSaG9tYnVzU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLm1haW50YWluaW5nQVJob21idXNTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgYWxsU2lkZXNFcXVhbEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5hbGxTaWRlc0VxdWFsQXNTaGFwZUNoYW5nZXNQYXR0ZXJuU3RyaW5nUHJvcGVydHkudmFsdWU7XHJcbmNvbnN0IGNvcm5lckZsYXRBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcuY29ybmVyRmxhdEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBhZGphY2VudFNpZGVzQ2hhbmdlRXF1YWxseUFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5hZGphY2VudFNpZGVzQ2hhbmdlRXF1YWxseUFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBhbGxTaWRlc1RpbHRBd2F5RnJvbVBhcmFsbGVsU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLmFsbFNpZGVzVGlsdEF3YXlGcm9tUGFyYWxsZWxTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgYWxsU2lkZXNUaWx0QXdheUZyb21QYXJhbGxlbEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5hbGxTaWRlc1RpbHRBd2F5RnJvbVBhcmFsbGVsQXNTaGFwZUNoYW5nZXNQYXR0ZXJuU3RyaW5nUHJvcGVydHkudmFsdWU7XHJcbmNvbnN0IHRpbHRTdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcudGlsdFN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBzdHJhaWdodGVuU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLnN0cmFpZ2h0ZW5TdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgYmlnZ2VyU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLmJpZ2dlclN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBzbWFsbGVyU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLnNtYWxsZXJTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgdmVydGV4QVN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLnZlcnRleEFTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgdmVydGV4QlN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLnZlcnRleEJTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgdmVydGV4Q1N0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLnZlcnRleENTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgdmVydGV4RFN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLnZlcnRleERTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgYmFja1N0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5iYWNrU3RyaW5nUHJvcGVydHkudmFsdWU7XHJcbmNvbnN0IGdvbmVTdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcuZ29uZVN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBjb3JuZXJzQmFja1N0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5jb3JuZXJzQmFja1N0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBjb3JuZXJzR29uZVN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5jb3JuZXJzR29uZVN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBjb3JuZXJEZXRlY3RlZFBhdHRlcm5TdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcuY29ybmVyRGV0ZWN0ZWRQYXR0ZXJuU3RyaW5nUHJvcGVydHkudmFsdWU7XHJcbmNvbnN0IHNob3J0ZXJTdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcuc2lkZURyYWdPYmplY3RSZXNwb25zZS5zaG9ydGVyU3RyaW5nUHJvcGVydHkudmFsdWU7XHJcbmNvbnN0IGxvbmdlclN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5zaWRlRHJhZ09iamVjdFJlc3BvbnNlLmxvbmdlclN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCB3aWRlclN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy52ZXJ0ZXhEcmFnT2JqZWN0UmVzcG9uc2Uud2lkZXJTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgdmVydGV4RHJhZ1NtYWxsZXJTdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcudmVydGV4RHJhZ09iamVjdFJlc3BvbnNlLnNtYWxsZXJTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgdmVydGV4RHJhZ09iamVjdFJlc3BvbnNlUGF0dGVyblN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy52ZXJ0ZXhEcmFnT2JqZWN0UmVzcG9uc2UudmVydGV4RHJhZ09iamVjdFJlc3BvbnNlUGF0dGVyblN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBhZGphY2VudFNpZGVzQ2hhbmdlUGF0dGVyblN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5zaWRlRHJhZ09iamVjdFJlc3BvbnNlLmFkamFjZW50U2lkZXNDaGFuZ2VQYXR0ZXJuU3RyaW5nUHJvcGVydHkudmFsdWU7XHJcbmNvbnN0IHJpZ2h0QW5nbGVTdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcucmlnaHRBbmdsZVN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBhbmdsZUZsYXRTdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcuYW5nbGVGbGF0U3RyaW5nUHJvcGVydHkudmFsdWU7XHJcbmNvbnN0IGFuZ2xlQ29tcGFyaXNvblBhdHRlcm5TdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcuYW5nbGVDb21wYXJpc29uUGF0dGVyblN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBvcHBvc2l0ZUNvcm5lclN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5vcHBvc2l0ZUNvcm5lclN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBhZGphY2VudENvcm5lcnNFcXVhbFN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5hZGphY2VudENvcm5lcnNFcXVhbFN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBhZGphY2VudENvcm5lcnNSaWdodEFuZ2xlc1N0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5hZGphY2VudENvcm5lcnNSaWdodEFuZ2xlc1N0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBwcm9ncmVzc1N0YXRlUGF0dGVyblN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5wcm9ncmVzc1N0YXRlUGF0dGVyblN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBlcXVhbFRvT3Bwb3NpdGVDb3JuZXJFcXVhbFRvQWRqYWNlbnRDb3JuZXJzU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLmVxdWFsVG9PcHBvc2l0ZUNvcm5lckVxdWFsVG9BZGphY2VudENvcm5lcnNTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgYWRqYWNlbnRTaWRlc0luTGluZVBhdHRlcm5TdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcuYWRqYWNlbnRTaWRlc0luTGluZVBhdHRlcm5TdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgZXF1YWxUb0FkamFjZW50Q29ybmVyc1N0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5lcXVhbFRvQWRqYWNlbnRDb3JuZXJzU3RyaW5nUHJvcGVydHkudmFsdWU7XHJcbmNvbnN0IGFkamFjZW50U2lkZXNDaGFuZ2VJbkxlbmd0aFN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5zaWRlRHJhZ09iamVjdFJlc3BvbnNlLmFkamFjZW50U2lkZXNDaGFuZ2VJbkxlbmd0aFN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBwYXJhbGxlbEFkamFjZW50U2lkZXNDaGFuZ2VQYXR0ZXJuU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLnNpZGVEcmFnT2JqZWN0UmVzcG9uc2UucGFyYWxsZWxBZGphY2VudFNpZGVzQ2hhbmdlUGF0dGVyblN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBlcXVhbEFkamFjZW50U2lkZXNDaGFuZ2VQYXR0ZXJuU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLnNpZGVEcmFnT2JqZWN0UmVzcG9uc2UuZXF1YWxBZGphY2VudFNpZGVzQ2hhbmdlUGF0dGVyblN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBlcXVhbFRvQWRqYWNlbnRTaWRlc1N0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5zaWRlRHJhZ09iamVjdFJlc3BvbnNlLmVxdWFsVG9BZGphY2VudFNpZGVzU3RyaW5nUHJvcGVydHkudmFsdWU7XHJcbmNvbnN0IGFkamFjZW50U2lkZXNFcXVhbFN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5zaWRlRHJhZ09iamVjdFJlc3BvbnNlLmFkamFjZW50U2lkZXNFcXVhbFN0cmluZ1Byb3BlcnR5LnZhbHVlO1xyXG5jb25zdCBhZGphY2VudFNpZGVzUGFyYWxsZWxTdHJpbmcgPSBRdWFkcmlsYXRlcmFsU3RyaW5ncy5hMTF5LnZvaWNpbmcuc2lkZURyYWdPYmplY3RSZXNwb25zZS5hZGphY2VudFNpZGVzUGFyYWxsZWxTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgZXF1YWxUb09uZUFkamFjZW50U2lkZVN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5zaWRlRHJhZ09iamVjdFJlc3BvbnNlLmVxdWFsVG9PbmVBZGphY2VudFNpZGVTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgdHdvU2lkZXNFcXVhbFN0cmluZyA9IFF1YWRyaWxhdGVyYWxTdHJpbmdzLmExMXkudm9pY2luZy5zaWRlRHJhZ09iamVjdFJlc3BvbnNlLnR3b1NpZGVzRXF1YWxTdHJpbmdQcm9wZXJ0eS52YWx1ZTtcclxuY29uc3QgdGhyZWVTaWRlc0VxdWFsU3RyaW5nID0gUXVhZHJpbGF0ZXJhbFN0cmluZ3MuYTExeS52b2ljaW5nLnNpZGVEcmFnT2JqZWN0UmVzcG9uc2UudGhyZWVTaWRlc0VxdWFsU3RyaW5nUHJvcGVydHkudmFsdWU7XHJcblxyXG4vLyBBIHJlc3BvbnNlIG1heSB0cmlnZ2VyIGJlY2F1c2UgdGhlcmUgaXMgYSBsYXJnZSBlbm91Z2ggY2hhbmdlIGluIGFuZ2xlIG9yIGxlbmd0aC4gVGhlIHJlYXNvbiBmb3IgdGhlIHJlc3BvbnNlXHJcbi8vIHdpbGwgaGF2ZSBhbiBpbXBhY3Qgb24gd2hhdCBpbmZvcm1hdGlvbiBpcyBkZXNjcmliZWQuXHJcbnR5cGUgUmVzcG9uc2VSZWFzb24gPSAnYW5nbGUnIHwgJ2xlbmd0aCc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuLy8gSWYgYW55IGFuZ2xlIGNoYW5nZXMgdGhpcyBtdWNoIHNpbmNlIHRoZSBsYXN0IHRpbWUgYSBjb250ZXh0IHJlc3BvbnNlIHdhcyBnZW5lcmF0ZWQsIGl0IGlzIHRpbWUgdG8gYWxlcnQgYVxyXG4vLyBuZXcgY29udGV4dCByZXNwb25zZS5cclxuY29uc3QgQU5HTEVfUkVTUE9OU0VfVEhSRVNIT0xEID0gTWF0aC5QSSAvIDEyO1xyXG5cclxuLy8gSWYgYW55IG9mIHRoZSBhbmdsZXMgaGF2ZSBjaGFuZ2VkIHRoaXMgbXVjaCBzaW5jZSB0aGUgbGFzdCB0aW1lIGEgY29udGV4dCByZXNwb25zZSB3YXMgZ2VuZXJhdGVkLCBhbmdsZXMgaGF2ZVxyXG4vLyBjaGFuZ2VkIHN1ZmZpY2llbnRseSB0byBkZXNjcmliZSBjaGFuZ2VzIGluIGFuZ2xlcyBvdmVyIG90aGVyIGluZm9ybWF0aW9uLlxyXG5jb25zdCBBTkdMRV9ESUZGRVJFTkNFU19MQVJHRV9USFJFU0hPTEQgPSBNYXRoLlBJIC8gMjQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWFkcmlsYXRlcmFsQWxlcnRlciBleHRlbmRzIEFsZXJ0ZXIge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgbW9kZWw6IFF1YWRyaWxhdGVyYWxNb2RlbDtcclxuICBwcml2YXRlIHJlYWRvbmx5IHF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsOiBRdWFkcmlsYXRlcmFsU2hhcGVNb2RlbDtcclxuICBwcml2YXRlIHJlYWRvbmx5IG1vZGVsVmlld1RyYW5zZm9ybTogTW9kZWxWaWV3VHJhbnNmb3JtMjtcclxuICBwcml2YXRlIHJlYWRvbmx5IGRlc2NyaWJlcjogUXVhZHJpbGF0ZXJhbERlc2NyaWJlcjtcclxuXHJcbiAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlIHNpZGUgcGFpcnMgd2VyZSBwYXJhbGxlbCBzaW5jZSB0aGUgbGFzdCB0aW1lIGEgZGVzY3JpcHRpb24gd2FzIGdlbmVyYXRlZCBiZWNhdXNlIG9mIGEgY2hhbmdlXHJcbiAgLy8gdG8gdGhlIHNoYXBlLlxyXG4gIHByaXZhdGUgd2FzU2lkZUFCU2lkZUNEUGFyYWxsZWw6IGJvb2xlYW47XHJcbiAgcHJpdmF0ZSB3YXNTaWRlQkNTaWRlREFQYXJhbGxlbDogYm9vbGVhbjtcclxuXHJcbiAgLy8gSW5kaWNhdGVzIHdoZW4gaXQgaXMgdGltZSB0byBhbm5vdW5jZSBhbiBhbmdsZS9sZW5ndGggcmVzcG9uc2UgYmVjYXVzZSB0aGF0IGFzcGVjdCBvZiB0aGUgcXVhZHJpbGF0ZXJhbCBzaGFwZVxyXG4gIC8vIGhhcyBjaGFuZ2VkIGVub3VnaCB0byBkZXNjcmliZSBpdC5cclxuICBwcml2YXRlIGFuZ2xlUmVzcG9uc2VSZWFkeSA9IGZhbHNlO1xyXG4gIHByaXZhdGUgbGVuZ3RoUmVzcG9uc2VSZWFkeSA9IGZhbHNlO1xyXG5cclxuICAvLyBBIHNuYXBzaG90IG9mIHN0YXRlIHZhcmlhYmxlcyBzaW5jZSB0aGUgbGFzdCB0aW1lIGEgcmVzcG9uc2Ugd2FzIGdlbmVyYXRlZC4gV2hlbiBhIHJlc3BvbnNlIGlzIGdlbmVyYXRlZCB3ZSBuZWVkXHJcbiAgLy8gY3JlYXRlIHN0cmluZ3MgdGhhdCBkZXNjcmliZSB0aGUgY2hhbmdlIHRvIHRoZSBzaGFwZSAqc2luY2UgdGhlIGxhc3QgZGVzY3JpcHRpb24qLCBpbnN0ZWFkIG9mIGV2ZXJ5IFByb3BlcnR5XHJcbiAgLy8gY2hhbmdlLlxyXG4gIHByaXZhdGUgcHJldmlvdXNDb250ZXh0UmVzcG9uc2VTaGFwZVNuYXBzaG90OiBRdWFkcmlsYXRlcmFsU2hhcGVTbmFwc2hvdDtcclxuICBwcml2YXRlIHByZXZpb3VzT2JqZWN0UmVzcG9uc2VTaGFwZVNuYXBzaG90OiBRdWFkcmlsYXRlcmFsU2hhcGVTbmFwc2hvdDtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBtb2RlbDogUXVhZHJpbGF0ZXJhbE1vZGVsLCBzY3JlZW5WaWV3OiBRdWFkcmlsYXRlcmFsU2NyZWVuVmlldywgbW9kZWxWaWV3VHJhbnNmb3JtOiBNb2RlbFZpZXdUcmFuc2Zvcm0yLCBkZXNjcmliZXI6IFF1YWRyaWxhdGVyYWxEZXNjcmliZXIgKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwgPSBtb2RlbC5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbDtcclxuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgIHRoaXMubW9kZWxWaWV3VHJhbnNmb3JtID0gbW9kZWxWaWV3VHJhbnNmb3JtO1xyXG4gICAgdGhpcy5kZXNjcmliZXIgPSBkZXNjcmliZXI7XHJcbiAgICB0aGlzLnByZXZpb3VzQ29udGV4dFJlc3BvbnNlU2hhcGVTbmFwc2hvdCA9IG5ldyBRdWFkcmlsYXRlcmFsU2hhcGVTbmFwc2hvdCggdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbCApO1xyXG4gICAgdGhpcy5wcmV2aW91c09iamVjdFJlc3BvbnNlU2hhcGVTbmFwc2hvdCA9IG5ldyBRdWFkcmlsYXRlcmFsU2hhcGVTbmFwc2hvdCggdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbCApO1xyXG4gICAgdGhpcy53YXNTaWRlQUJTaWRlQ0RQYXJhbGxlbCA9IG1vZGVsLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLnNpZGVBQlNpZGVDRFBhcmFsbGVsU2lkZUNoZWNrZXIuYXJlU2lkZXNQYXJhbGxlbCgpO1xyXG4gICAgdGhpcy53YXNTaWRlQkNTaWRlREFQYXJhbGxlbCA9IG1vZGVsLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLnNpZGVCQ1NpZGVEQVBhcmFsbGVsU2lkZUNoZWNrZXIuYXJlU2lkZXNQYXJhbGxlbCgpO1xyXG5cclxuICAgIC8vIFRoZSBsZWFzdCBwZWRhZ29naWNhbGx5IHJlbGV2YW50IGNvbnRlbnQgd2lsbCBhbGVydCB0aHJvdWdoIHRoaXMgVXR0ZXJhbmNlIGFuZCB3aWxsIG9mdGVuIGJlIGludGVycnVwdGVkLlxyXG4gICAgY29uc3QgbG93UHJpb3JpdHlVdHRlcmFuY2UgPSBuZXcgVXR0ZXJhbmNlKCB7XHJcbiAgICAgIHByaW9yaXR5OiBVdHRlcmFuY2UuTE9XX1BSSU9SSVRZXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gQWxlcnQgY29udGVudCB0aGF0IHNob3VsZCB1c3VhbGx5IGJlIGhlYXJkLCBidXQgc2hvdWxkIGJlIGludGVycnVwdGVkIGJ5IGNyaXRpY2FsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzaGFwZVxyXG4gICAgY29uc3QgbWVkaXVtUHJpb3JpdHlVdHRlcmFuY2UgPSBuZXcgVXR0ZXJhbmNlKCB7XHJcbiAgICAgIHByaW9yaXR5OiBVdHRlcmFuY2UuTUVESVVNX1BSSU9SSVRZXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gTW9zdCBpbXBvcnRhbnQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNoYXBlIHRoYXQgc2hvdWxkIGludGVycnVwdCBhbGwgb3RoZXIgYWxlcnRzIGFuZCBuZXZlciBiZSBpbnRlcnJ1cHRlZC5cclxuICAgIGNvbnN0IGhpZ2hQcmlvcml0eVV0dGVyYW5jZSA9IG5ldyBVdHRlcmFuY2UoIHtcclxuICAgICAgcHJpb3JpdHk6IFV0dGVyYW5jZS5ISUdIX1BSSU9SSVRZXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gVXBvbiBzaW11bGF0aW9uIHJlc2V0LCByZXNldCBjZXJ0YWluIHN0YXRlIGZvciBkZXNjcmlwdGlvbiBzbyB0aGF0IG5leHQgZGVzY3JpcHRpb25zIGFmdGVyIHJlc2V0IGFyZSBjb3JyZWN0XHJcbiAgICBtb2RlbC5yZXNldE5vdEluUHJvZ3Jlc3NQcm9wZXJ0eS5saW5rKCByZXNldE5vdEluUHJvZ3Jlc3MgPT4ge1xyXG4gICAgICB0aGlzLnByZXZpb3VzQ29udGV4dFJlc3BvbnNlU2hhcGVTbmFwc2hvdCA9IG5ldyBRdWFkcmlsYXRlcmFsU2hhcGVTbmFwc2hvdCggdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbCApO1xyXG4gICAgICB0aGlzLnByZXZpb3VzT2JqZWN0UmVzcG9uc2VTaGFwZVNuYXBzaG90ID0gbmV3IFF1YWRyaWxhdGVyYWxTaGFwZVNuYXBzaG90KCB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsICk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUG90ZW50aWFsbHkgZ2VuZXJhdGUgYW5kIGFsZXJ0IG5ldyByZXNwb25zZXMgd2hlbiB0aGUgc2hhcGUgY2hhbmdlcy5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIG1vZGVsLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLnNoYXBlQ2hhbmdlZEVtaXR0ZXIuYWRkTGlzdGVuZXIoICgpID0+IHtcclxuXHJcbiAgICAgIC8vIE5vdGhpbmcgYWJvdXQgdGhlc2Ugc2hvdWxkIGJlIGhlYXJkIHdoaWxlIHJlc2V0dGluZ1xyXG4gICAgICBpZiAoIG1vZGVsLnJlc2V0Tm90SW5Qcm9ncmVzc1Byb3BlcnR5LnZhbHVlICkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlUGFja2V0ID0gbmV3IFJlc3BvbnNlUGFja2V0KCk7XHJcblxyXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSB0aGUgbG93ZXIgcHJpb3JpdHkgVXR0ZXJhbmNlIHRoYXQgd29uJ3QgaW50ZXJydXB0IHJlc3BvbnNlcyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmdcclxuICAgICAgICAvLyBhbm5vdW5jZWQuIElmIHdlIGRldGVjdCBhIGNyaXRpY2FsIHN0YXRlIGNoYW5nZSwgd2Ugd2lsbCB1c2UgYSBoaWdoZXIgcHJpb3JpdHkgVXR0ZXJhbmNlIGZvciBpbnRlcnJ1cHRpb24uXHJcbiAgICAgICAgbGV0IHV0dGVyYW5jZSA9IGxvd1ByaW9yaXR5VXR0ZXJhbmNlO1xyXG5cclxuICAgICAgICBjb25zdCBwcmV2aW91c0FBbmdsZSA9IHRoaXMucHJldmlvdXNDb250ZXh0UmVzcG9uc2VTaGFwZVNuYXBzaG90LnZlcnRleEFBbmdsZTtcclxuICAgICAgICBjb25zdCBwcmV2aW91c0JBbmdsZSA9IHRoaXMucHJldmlvdXNDb250ZXh0UmVzcG9uc2VTaGFwZVNuYXBzaG90LnZlcnRleEJBbmdsZTtcclxuICAgICAgICBjb25zdCBwcmV2aW91c0NBbmdsZSA9IHRoaXMucHJldmlvdXNDb250ZXh0UmVzcG9uc2VTaGFwZVNuYXBzaG90LnZlcnRleENBbmdsZTtcclxuICAgICAgICBjb25zdCBwcmV2aW91c0RBbmdsZSA9IHRoaXMucHJldmlvdXNDb250ZXh0UmVzcG9uc2VTaGFwZVNuYXBzaG90LnZlcnRleERBbmdsZTtcclxuXHJcbiAgICAgICAgY29uc3QgYUFuZ2xlRGlmZmVyZW5jZSA9IHByZXZpb3VzQUFuZ2xlIC0gdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC52ZXJ0ZXhBLmFuZ2xlUHJvcGVydHkudmFsdWUhO1xyXG4gICAgICAgIGNvbnN0IGJBbmdsZURpZmZlcmVuY2UgPSBwcmV2aW91c0JBbmdsZSAtIHRoaXMucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwudmVydGV4Qi5hbmdsZVByb3BlcnR5LnZhbHVlITtcclxuICAgICAgICBjb25zdCBjQW5nbGVEaWZmZXJlbmNlID0gcHJldmlvdXNDQW5nbGUgLSB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLnZlcnRleEMuYW5nbGVQcm9wZXJ0eS52YWx1ZSE7XHJcbiAgICAgICAgY29uc3QgZEFuZ2xlRGlmZmVyZW5jZSA9IHByZXZpb3VzREFuZ2xlIC0gdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC52ZXJ0ZXhELmFuZ2xlUHJvcGVydHkudmFsdWUhO1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlRGlmZmVyZW5jZXMgPSBbIGFBbmdsZURpZmZlcmVuY2UsIGJBbmdsZURpZmZlcmVuY2UsIGNBbmdsZURpZmZlcmVuY2UsIGRBbmdsZURpZmZlcmVuY2UgXTtcclxuXHJcbiAgICAgICAgLy8gSGF2ZSB0aGUgYW5nbGVzIGNoYW5nZWQgZW5vdWdoIHRvIHRyaWdnZXIgYSBjb250ZXh0IHJlc3BvbnNlP1xyXG4gICAgICAgIHRoaXMuYW5nbGVSZXNwb25zZVJlYWR5ID0gXy5zb21lKCBhbmdsZURpZmZlcmVuY2VzLCBhbmdsZURpZmZlcmVuY2UgPT4gTWF0aC5hYnMoIGFuZ2xlRGlmZmVyZW5jZSApID4gQU5HTEVfUkVTUE9OU0VfVEhSRVNIT0xEICk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzQUJMZW5ndGggPSB0aGlzLnByZXZpb3VzQ29udGV4dFJlc3BvbnNlU2hhcGVTbmFwc2hvdC5zaWRlQUJMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNCQ0xlbmd0aCA9IHRoaXMucHJldmlvdXNDb250ZXh0UmVzcG9uc2VTaGFwZVNuYXBzaG90LnNpZGVCQ0xlbmd0aDtcclxuICAgICAgICBjb25zdCBwcmV2aW91c0NETGVuZ3RoID0gdGhpcy5wcmV2aW91c0NvbnRleHRSZXNwb25zZVNoYXBlU25hcHNob3Quc2lkZUNETGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzREFMZW5ndGggPSB0aGlzLnByZXZpb3VzQ29udGV4dFJlc3BvbnNlU2hhcGVTbmFwc2hvdC5zaWRlREFMZW5ndGg7XHJcblxyXG4gICAgICAgIGNvbnN0IGFiTGVuZ3RoRGlmZmVyZW5jZSA9IHByZXZpb3VzQUJMZW5ndGggLSB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLnNpZGVBQi5sZW5ndGhQcm9wZXJ0eS52YWx1ZTtcclxuICAgICAgICBjb25zdCBiY0xlbmd0aERpZmZlcmVuY2UgPSBwcmV2aW91c0JDTGVuZ3RoIC0gdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC5zaWRlQkMubGVuZ3RoUHJvcGVydHkudmFsdWU7XHJcbiAgICAgICAgY29uc3QgY2RMZW5ndGhEaWZmZXJlbmNlID0gcHJldmlvdXNDRExlbmd0aCAtIHRoaXMucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwuc2lkZUNELmxlbmd0aFByb3BlcnR5LnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGRhTGVuZ3RoRGlmZmVyZW5jZSA9IHByZXZpb3VzREFMZW5ndGggLSB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLnNpZGVEQS5sZW5ndGhQcm9wZXJ0eS52YWx1ZTtcclxuICAgICAgICBjb25zdCBsZW5ndGhEaWZmZXJlbmNlcyA9IFsgYWJMZW5ndGhEaWZmZXJlbmNlLCBiY0xlbmd0aERpZmZlcmVuY2UsIGNkTGVuZ3RoRGlmZmVyZW5jZSwgZGFMZW5ndGhEaWZmZXJlbmNlIF07XHJcblxyXG4gICAgICAgIC8vIElmIGFuZ2xlcyBoYXZlIGNoYW5nZWQgZW5vdWdoLCB0aGUgcmVzcG9uc2UgaW5mb3JtYXRpb24gd2lsbCBkZXNjcmliZSB0aGUgY2hhbmdpbmcgYW5nbGVzIGluc3RlYWRcclxuICAgICAgICAvLyBvZiBvdGhlciBpbmZvcm1hdGlvbiAobGlrZSBjaGFuZ2luZyBsZW5ndGgpLlxyXG4gICAgICAgIGNvbnN0IGFuZ2xlRGlmZmVyZW5jZXNMYXJnZSA9IF8uc29tZSggYW5nbGVEaWZmZXJlbmNlcywgYW5nbGVEaWZmZXJlbmNlID0+IGFuZ2xlRGlmZmVyZW5jZSA+IEFOR0xFX0RJRkZFUkVOQ0VTX0xBUkdFX1RIUkVTSE9MRCApO1xyXG5cclxuICAgICAgICAvLyBIYXZlIHRoZSBsZW5ndGhzIGNoYW5nZWQgZW5vdWdoIHRvIHRyaWdnZXIgYSBjb250ZXh0IHJlc3BvbnNlP1xyXG4gICAgICAgIHRoaXMubGVuZ3RoUmVzcG9uc2VSZWFkeSA9IF8uc29tZSggbGVuZ3RoRGlmZmVyZW5jZXMsIGxlbmd0aERpZmZlcmVuY2UgPT4gTWF0aC5hYnMoIGxlbmd0aERpZmZlcmVuY2UgKSA+IFF1YWRyaWxhdGVyYWxTaWRlLlNJREVfU0VHTUVOVF9MRU5HVEggKSAmJiAhYW5nbGVEaWZmZXJlbmNlc0xhcmdlO1xyXG5cclxuICAgICAgICBjb25zdCBzaWRlQUJTaWRlQ0RQYXJhbGxlbEFmdGVyID0gdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC5zaWRlQUJTaWRlQ0RQYXJhbGxlbFNpZGVDaGVja2VyLmFyZVNpZGVzUGFyYWxsZWwoKTtcclxuICAgICAgICBjb25zdCBzaWRlQkNTaWRlREFQYXJhbGxlbEFmdGVyID0gdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC5zaWRlQkNTaWRlREFQYXJhbGxlbFNpZGVDaGVja2VyLmFyZVNpZGVzUGFyYWxsZWwoKTtcclxuXHJcbiAgICAgICAgLy8gSWYgd2UgZ28gZnJvbSB6ZXJvIHBhcmFsbGVsIHNpZGUgcGFpcnMgdG8gYXQgbGVhc3Qgb25lIHBhaXIsIHRyaWdnZXIgYSBuZXcgY29udGV4dCByZXNwb25zZSBzbyB0aGF0IHdlIGhlYXJcclxuICAgICAgICAvLyB3aGVuIHNpZGVzIGJlY29tZSBwYXJhbGxlbC4gVGhlc2UgY2hlY2tzIGhhdmUgdG8gYmUgcmVsYXRpdmUgdG8gZXZlcnkgc2hhcGUgY2hhbmdlLCBzbyBzdGF0ZSB2YXJpYWJsZXMgYXJlXHJcbiAgICAgICAgLy8gc2V0IGltbWVkaWF0ZWx5IGluc3RlYWQgb2YgaW4gYSBRdWFkcmlsYXRlcmFsU2hhcGVTbmFwc2hvdC5cclxuICAgICAgICBjb25zdCBwYXJhbGxlbFNpZGVSZXNwb25zZVJlYWR5ID0gKCAhdGhpcy53YXNTaWRlQUJTaWRlQ0RQYXJhbGxlbCAmJiAhdGhpcy53YXNTaWRlQkNTaWRlREFQYXJhbGxlbCApICYmICggc2lkZUFCU2lkZUNEUGFyYWxsZWxBZnRlciB8fCBzaWRlQkNTaWRlREFQYXJhbGxlbEFmdGVyICk7XHJcbiAgICAgICAgdGhpcy53YXNTaWRlQUJTaWRlQ0RQYXJhbGxlbCA9IHNpZGVBQlNpZGVDRFBhcmFsbGVsQWZ0ZXI7XHJcbiAgICAgICAgdGhpcy53YXNTaWRlQkNTaWRlREFQYXJhbGxlbCA9IHNpZGVCQ1NpZGVEQVBhcmFsbGVsQWZ0ZXI7XHJcblxyXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAvLyBGaXJzdCwgY3JlYXRlIHRoZSBjb250ZXh0IHJlc3BvbnNlIC0gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBvdmVyYWxsIHNoYXBlXHJcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIGNvbnN0IHNoYXBlTmFtZUNoYW5nZVJlc3BvbnNlID0gdGhpcy5nZXRTaGFwZU5hbWVDaGFuZ2VSZXNwb25zZSgpO1xyXG4gICAgICAgIGlmICggc2hhcGVOYW1lQ2hhbmdlUmVzcG9uc2UgKSB7XHJcblxyXG4gICAgICAgICAgLy8gU2hhcGUgbmFtZSBjaGFuZ2VkLCB0aGlzIGlzIHRoZSBtb3N0IGltcG9ydGFudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgIHJlc3BvbnNlUGFja2V0LmNvbnRleHRSZXNwb25zZSA9IHNoYXBlTmFtZUNoYW5nZVJlc3BvbnNlITtcclxuICAgICAgICAgIHV0dGVyYW5jZSA9IGhpZ2hQcmlvcml0eVV0dGVyYW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIHRoaXMuYW5nbGVSZXNwb25zZVJlYWR5IHx8IHRoaXMubGVuZ3RoUmVzcG9uc2VSZWFkeSB8fCBwYXJhbGxlbFNpZGVSZXNwb25zZVJlYWR5ICkge1xyXG5cclxuICAgICAgICAgIC8vIFNoYXBlIGF0dHJpYnV0ZXMgY2hhbmdlZCBzdWZmaWNpZW50bHkgdG8gZGVzY3JpYmUgY2hhbmdlc1xyXG4gICAgICAgICAgY29uc3QgdGhpc1Jlc3BvbnNlUmVhc29uID0gYW5nbGVEaWZmZXJlbmNlc0xhcmdlID8gJ2FuZ2xlJyA6ICdsZW5ndGgnO1xyXG5cclxuICAgICAgICAgIGlmICggdGhpcy5wcmV2aW91c0NvbnRleHRSZXNwb25zZVNoYXBlU25hcHNob3QubmFtZWRRdWFkcmlsYXRlcmFsID09PSB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLnNoYXBlTmFtZVByb3BlcnR5LnZhbHVlICkge1xyXG5cclxuICAgICAgICAgICAgLy8gdGhlIHNoYXBlIGhhcyBjaGFuZ2VkIGVub3VnaCB0byBwcm92aWRlIGEgY29udGV4dCByZXNwb25zZSwgYnV0IHRoZSBuYW1lZCBxdWFkcmlsYXRlcmFsIGhhcyBub3RcclxuICAgICAgICAgICAgLy8gY2hhbmdlZCwgc28gd2UgcHJvdmlkZSBhIHVuaXF1ZSBhbGVydCBzcGVjaWZpYyB0byB0aGUgc2hhcGUgbWFpbnRlbmFuY2VcclxuICAgICAgICAgICAgY29uc3Qgc2hhcGVNYWludGVuYW5jZVJlc3BvbnNlID0gdGhpcy5nZXRTaGFwZU1haW50ZW5hbmNlQ29udGV4dFJlc3BvbnNlKCB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLnNoYXBlTmFtZVByb3BlcnR5LnZhbHVlLCB0aGlzLnByZXZpb3VzQ29udGV4dFJlc3BvbnNlU2hhcGVTbmFwc2hvdCwgdGhpc1Jlc3BvbnNlUmVhc29uICk7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlUGFja2V0LmNvbnRleHRSZXNwb25zZSA9IHNoYXBlTWFpbnRlbmFuY2VSZXNwb25zZTtcclxuXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdGlsdENoYW5nZVJlc3BvbnNlID0gdGhpcy5nZXRTaGFwZUNoYW5nZVJlc3BvbnNlKCB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLCB0aGlzLnByZXZpb3VzQ29udGV4dFJlc3BvbnNlU2hhcGVTbmFwc2hvdCwgdGhpc1Jlc3BvbnNlUmVhc29uICk7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlUGFja2V0LmNvbnRleHRSZXNwb25zZSA9IHRpbHRDaGFuZ2VSZXNwb25zZSE7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdXR0ZXJhbmNlID0gbWVkaXVtUHJpb3JpdHlVdHRlcmFuY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy8gTmV4dCwgY3JlYXRlIHRoZSBvYmplY3QgcmVzcG9uc2UgLSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHBhcnRpY3VsYXIgUXVhZHJpbGF0ZXJhbFZlcnRleCBvciBRdWFkcmlsYXRlcmFsU2lkZSBhc1xyXG4gICAgICAgIC8vIGl0IGlzIG1vdmVkIGJ5IHRoZSB1c2VyLlxyXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBtb2RlbC5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC5zaWRlcy5mb3JFYWNoKCBzaWRlID0+IHtcclxuICAgICAgICAgIGlmICggc2lkZS52b2ljaW5nT2JqZWN0UmVzcG9uc2VEaXJ0eSApIHtcclxuICAgICAgICAgICAgcmVzcG9uc2VQYWNrZXQub2JqZWN0UmVzcG9uc2UgPSB0aGlzLmdldFNpZGVDaGFuZ2VPYmplY3RSZXNwb25zZSggc2lkZSApO1xyXG4gICAgICAgICAgICBzaWRlLnZvaWNpbmdPYmplY3RSZXNwb25zZURpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgICAgICBtb2RlbC5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC52ZXJ0aWNlcy5mb3JFYWNoKCB2ZXJ0ZXggPT4ge1xyXG4gICAgICAgICAgaWYgKCB2ZXJ0ZXgudm9pY2luZ09iamVjdFJlc3BvbnNlRGlydHkgKSB7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlUGFja2V0Lm9iamVjdFJlc3BvbnNlID0gdGhpcy5nZXRWZXJ0ZXhDaGFuZ2VPYmplY3RSZXNwb25zZSggdmVydGV4ICk7XHJcbiAgICAgICAgICAgIHZlcnRleC52b2ljaW5nT2JqZWN0UmVzcG9uc2VEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIC8vIEFubm91bmNlIHJlc3BvbnNlcyBpZiB3ZSBoYXZlIGdlbmVyYXRlZCBhbnkgY29udGVudC5cclxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgaWYgKCByZXNwb25zZVBhY2tldC5jb250ZXh0UmVzcG9uc2UgfHwgcmVzcG9uc2VQYWNrZXQub2JqZWN0UmVzcG9uc2UgKSB7XHJcbiAgICAgICAgICB1dHRlcmFuY2UuYWxlcnQgPSByZXNwb25zZVBhY2tldDtcclxuICAgICAgICAgIHRoaXMuYWxlcnQoIHV0dGVyYW5jZSApO1xyXG5cclxuICAgICAgICAgIC8vIHNhdmUgc25hcHNob3RzIGZvciBuZXh0IGRlc2NyaXB0aW9uc1xyXG4gICAgICAgICAgaWYgKCByZXNwb25zZVBhY2tldC5jb250ZXh0UmVzcG9uc2UgKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNDb250ZXh0UmVzcG9uc2VTaGFwZVNuYXBzaG90ID0gbmV3IFF1YWRyaWxhdGVyYWxTaGFwZVNuYXBzaG90KCB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIHJlc3BvbnNlUGFja2V0Lm9iamVjdFJlc3BvbnNlICkge1xyXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzT2JqZWN0UmVzcG9uc2VTaGFwZVNuYXBzaG90ID0gbmV3IFF1YWRyaWxhdGVyYWxTaGFwZVNuYXBzaG90KCB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gKFByb3RvdHlwZSkgUmVzcG9uc2VzIHNwZWNpZmljIHRvIE9wZW5DViAtIGxldHRpbmcgdGhlIHVzZXIga25vdyB3aGVuIG1hcmtlcnMgYmVjb21lXHJcbiAgICAvLyBkZXRlY3RlZCBvciBvYnNjdXJlZCBmcm9tIHRoZSBjYW1lcmEuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBjb25zdCBtYXJrZXJSZXNwb25zZVBhY2tldCA9IG5ldyBSZXNwb25zZVBhY2tldCgpO1xyXG4gICAgY29uc3QgbWFya2VyVXR0ZXJhbmNlID0gbmV3IFV0dGVyYW5jZSgge1xyXG4gICAgICBhbGVydDogbWFya2VyUmVzcG9uc2VQYWNrZXQsXHJcbiAgICAgIHByaW9yaXR5OiBVdHRlcmFuY2UuTE9XX1BSSU9SSVRZXHJcbiAgICB9ICk7XHJcblxyXG4gICAgY29uc3QgbWFya2VyRGV0ZWN0aW9uTW9kZWwgPSBtb2RlbC50YW5naWJsZUNvbm5lY3Rpb25Nb2RlbC5tYXJrZXJEZXRlY3Rpb25Nb2RlbDtcclxuICAgIG1hcmtlckRldGVjdGlvbk1vZGVsLmFsbFZlcnRleE1hcmtlcnNEZXRlY3RlZFByb3BlcnR5LmxpbmsoIGFsbFZlcnRleE1hcmtlcnNEZXRlY3RlZCA9PiB7XHJcbiAgICAgIGlmICggbWFya2VyRGV0ZWN0aW9uTW9kZWwubWFya2VyUmVzcG9uc2VzRW5hYmxlZFByb3BlcnR5LnZhbHVlICkge1xyXG4gICAgICAgIG1hcmtlclJlc3BvbnNlUGFja2V0LmNvbnRleHRSZXNwb25zZSA9IGFsbFZlcnRleE1hcmtlcnNEZXRlY3RlZCA/IGNvcm5lcnNCYWNrU3RyaW5nIDogY29ybmVyc0dvbmVTdHJpbmc7XHJcbiAgICAgICAgdGhpcy5hbGVydCggbWFya2VyVXR0ZXJhbmNlICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICBjb25zdCB2ZXJ0ZXhEZXRlY3Rpb25SZXNwb25zZUxpc3RlbmVyID0gKCBsYWJlbFN0cmluZzogc3RyaW5nLCBkZXRlY3RlZDogYm9vbGVhbiApID0+IHtcclxuICAgICAgaWYgKCBtYXJrZXJEZXRlY3Rpb25Nb2RlbC5tYXJrZXJSZXNwb25zZXNFbmFibGVkUHJvcGVydHkudmFsdWUgKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGVTdHJpbmcgPSBkZXRlY3RlZCA/IGJhY2tTdHJpbmcgOiBnb25lU3RyaW5nO1xyXG4gICAgICAgIG1hcmtlclJlc3BvbnNlUGFja2V0LmNvbnRleHRSZXNwb25zZSA9IFN0cmluZ1V0aWxzLmZpbGxJbiggY29ybmVyRGV0ZWN0ZWRQYXR0ZXJuU3RyaW5nLCB7XHJcbiAgICAgICAgICBsYWJlbDogbGFiZWxTdHJpbmcsXHJcbiAgICAgICAgICBzdGF0ZTogc3RhdGVTdHJpbmdcclxuICAgICAgICB9ICk7XHJcbiAgICAgICAgdGhpcy5hbGVydCggbWFya2VyVXR0ZXJhbmNlICk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbWFya2VyRGV0ZWN0aW9uTW9kZWwudmVydGV4QU1hcmtlckRldGVjdGVkUHJvcGVydHkubGluayggZGV0ZWN0ZWQgPT4geyB2ZXJ0ZXhEZXRlY3Rpb25SZXNwb25zZUxpc3RlbmVyKCB2ZXJ0ZXhBU3RyaW5nLCBkZXRlY3RlZCApOyB9ICk7XHJcbiAgICBtYXJrZXJEZXRlY3Rpb25Nb2RlbC52ZXJ0ZXhCTWFya2VyRGV0ZWN0ZWRQcm9wZXJ0eS5saW5rKCBkZXRlY3RlZCA9PiB7IHZlcnRleERldGVjdGlvblJlc3BvbnNlTGlzdGVuZXIoIHZlcnRleEJTdHJpbmcsIGRldGVjdGVkICk7IH0gKTtcclxuICAgIG1hcmtlckRldGVjdGlvbk1vZGVsLnZlcnRleENNYXJrZXJEZXRlY3RlZFByb3BlcnR5LmxpbmsoIGRldGVjdGVkID0+IHsgdmVydGV4RGV0ZWN0aW9uUmVzcG9uc2VMaXN0ZW5lciggdmVydGV4Q1N0cmluZywgZGV0ZWN0ZWQgKTsgfSApO1xyXG4gICAgbWFya2VyRGV0ZWN0aW9uTW9kZWwudmVydGV4RE1hcmtlckRldGVjdGVkUHJvcGVydHkubGluayggZGV0ZWN0ZWQgPT4geyB2ZXJ0ZXhEZXRlY3Rpb25SZXNwb25zZUxpc3RlbmVyKCB2ZXJ0ZXhEU3RyaW5nLCBkZXRlY3RlZCApOyB9ICk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmVnaXN0ZXIgVXR0ZXJhbmNlcyB0byB0aGUgU2NyZWVuVmlldyBzbyB0aGF0IHRoZXkgcmVzcGVjdCB2aXNpYmxlIGFuZCB2b2ljaW5nVmlzaWJsZVxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVm9pY2luZy5yZWdpc3RlclV0dGVyYW5jZVRvTm9kZSggbG93UHJpb3JpdHlVdHRlcmFuY2UsIHNjcmVlblZpZXcgKTtcclxuICAgIFZvaWNpbmcucmVnaXN0ZXJVdHRlcmFuY2VUb05vZGUoIG1lZGl1bVByaW9yaXR5VXR0ZXJhbmNlLCBzY3JlZW5WaWV3ICk7XHJcbiAgICBWb2ljaW5nLnJlZ2lzdGVyVXR0ZXJhbmNlVG9Ob2RlKCBoaWdoUHJpb3JpdHlVdHRlcmFuY2UsIHNjcmVlblZpZXcgKTtcclxuICAgIFZvaWNpbmcucmVnaXN0ZXJVdHRlcmFuY2VUb05vZGUoIG1hcmtlclV0dGVyYW5jZSwgc2NyZWVuVmlldyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgb2JqZWN0IHJlc3BvbnNlIGZvciB0aGUgc2lkZSBhcyBpdCBjaGFuZ2VzIGZyb20gdXNlciBpbnB1dCBsaWtlIGRyYWdnaW5nLiBEZXNjcmliZXMgdGhlIGNoYW5nZSBpblxyXG4gICAqIGxlbmd0aCBvZiBhZGphY2VudCBzaWRlLiBBbW91bnQgb2YgY29udGVudCBpbiB0aGUgcmVzcG9uc2UgZGVwZW5kcyBvbiB3aGV0aGVyIHRoZSBhZGphY2VudCBzaWRlcyBjaGFuZ2UgdGhlIHNhbWVcclxuICAgKiBhbW91bnQsIGFuZCBob3cgbXVjaCB0aGUgbGVuZ3RoIG9mIGFkamFjZW50IHNpZGVzIGNoYW5nZWQuIFdpbGwgcmV0dXJuIHNvbWV0aGluZyBsaWtlXHJcbiAgICpcclxuICAgKiBcImFkamFjZW50IHNpZGVzIGVxdWFsXCIgb3JcclxuICAgKiBcImVxdWFsIHRvIG9uZSBhZGphY2VudCBzaWRlXCIgb3JcclxuICAgKiBcInBhcmFsbGVsIGFkamFjZW50IHNpZGVzIGxvbmdlclwiIG9yXHJcbiAgICogXCJlcXVhbCBhZGphY2VudCBzaWRlcyBzaG9ydGVyXCIgb3JcclxuICAgKiBcImFkamFjZW50IHNpZGVzIGxvbmdlclwiIG9yXHJcbiAgICogXCJsZWZ0XCIgb3JcclxuICAgKiBcInVwXCJcclxuICAgKlxyXG4gICAqIFRoZSBkZXNpZ24gZm9yIHRoaXMgZnVuY3Rpb24gaXMgb3V0bGluZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3F1YWRyaWxhdGVyYWwvaXNzdWVzLzI1M1xyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0U2lkZUNoYW5nZU9iamVjdFJlc3BvbnNlKCBzaWRlOiBRdWFkcmlsYXRlcmFsU2lkZSApOiBzdHJpbmcge1xyXG4gICAgbGV0IHJlc3BvbnNlID0gJyc7XHJcblxyXG4gICAgY29uc3QgbGVuZ3RoVG9sZXJhbmNlID0gdGhpcy5tb2RlbC5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC5pbnRlckxlbmd0aFRvbGVyYW5jZUludGVydmFsO1xyXG4gICAgY29uc3Qgc2hhcGVNb2RlbCA9IHRoaXMubW9kZWwucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWw7XHJcblxyXG4gICAgY29uc3QgdG9sZXJhbmNlRm9yRGVzY3JpYmluZ0xlbmd0aENoYW5nZSA9IGxlbmd0aFRvbGVyYW5jZSAvIDM7XHJcblxyXG4gICAgY29uc3QgY3VycmVudFNoYXBlU25hcHNob3QgPSBuZXcgUXVhZHJpbGF0ZXJhbFNoYXBlU25hcHNob3QoIHRoaXMubW9kZWwucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwgKTtcclxuXHJcbiAgICAvLyBwcmV2aW91cyBzbmFwc2hvdCB2YXJpYWJsZXNcclxuICAgIGNvbnN0IHByZXZpb3VzQWRqYWNlbnRMZW5ndGhzID0gdGhpcy5wcmV2aW91c09iamVjdFJlc3BvbnNlU2hhcGVTbmFwc2hvdC5nZXRBZGphY2VudFNpZGVMZW5ndGhzRnJvbVNpZGVMYWJlbCggc2lkZS5zaWRlTGFiZWwgKTtcclxuICAgIGNvbnN0IGZpcnN0UHJldmlvdXNBZGphY2VudFNpZGVMZW5ndGggPSBwcmV2aW91c0FkamFjZW50TGVuZ3Roc1sgMCBdO1xyXG4gICAgY29uc3Qgc2Vjb25kUHJldmlvdXNBZGphY2VudFNpZGVMZW5ndGggPSBwcmV2aW91c0FkamFjZW50TGVuZ3Roc1sgMSBdO1xyXG4gICAgY29uc3QgcHJldmlvdXNBZGphY2VudFNpZGVzRXF1YWwgPSBVdGlscy5lcXVhbHNFcHNpbG9uKCBmaXJzdFByZXZpb3VzQWRqYWNlbnRTaWRlTGVuZ3RoLCBzZWNvbmRQcmV2aW91c0FkamFjZW50U2lkZUxlbmd0aCwgbGVuZ3RoVG9sZXJhbmNlICk7XHJcbiAgICBjb25zdCBwcmV2aW91c0FkamFjZW50U2lkZXNQYXJhbGxlbCA9IHRoaXMucHJldmlvdXNPYmplY3RSZXNwb25zZVNoYXBlU25hcHNob3QuZ2V0QWRqYWNlbnRTaWRlc1BhcmFsbGVsRnJvbVNpZGVMYWJlbCggc2lkZS5zaWRlTGFiZWwgKTtcclxuICAgIGNvbnN0IHByZXZpb3VzTGVuZ3RoID0gdGhpcy5wcmV2aW91c09iamVjdFJlc3BvbnNlU2hhcGVTbmFwc2hvdC5nZXRMZW5ndGhGcm9tU2lkZUxhYmVsKCBzaWRlLnNpZGVMYWJlbCApO1xyXG4gICAgY29uc3QgcHJldmlvdXNFcXVhbFRvRmlyc3RBZGphY2VudCA9IHNoYXBlTW9kZWwuaXNJbnRlckxlbmd0aEVxdWFsVG9PdGhlciggcHJldmlvdXNMZW5ndGgsIGZpcnN0UHJldmlvdXNBZGphY2VudFNpZGVMZW5ndGggKTtcclxuICAgIGNvbnN0IHByZXZpb3VzRXF1YWxUb1NlY29uZEFkamFjZW50ID0gc2hhcGVNb2RlbC5pc0ludGVyTGVuZ3RoRXF1YWxUb090aGVyKCBwcmV2aW91c0xlbmd0aCwgc2Vjb25kUHJldmlvdXNBZGphY2VudFNpZGVMZW5ndGggKTtcclxuICAgIGNvbnN0IHByZXZpb3VzRXF1YWxUb09uZUFkamFjZW50ID0gcHJldmlvdXNFcXVhbFRvRmlyc3RBZGphY2VudCAhPT0gcHJldmlvdXNFcXVhbFRvU2Vjb25kQWRqYWNlbnQ7XHJcbiAgICBjb25zdCBwcmV2aW91c051bWJlck9mRXF1YWxTaWRlcyA9IHRoaXMucHJldmlvdXNPYmplY3RSZXNwb25zZVNoYXBlU25hcHNob3QuY291bnROdW1iZXJPZkVxdWFsU2lkZXMoKTtcclxuXHJcbiAgICAvLyBjdXJyZW50IHNoYXBlIHZhcmlhYmxlc1xyXG4gICAgY29uc3QgYWRqYWNlbnRTaWRlcyA9IGN1cnJlbnRTaGFwZVNuYXBzaG90LmdldEFkamFjZW50U2lkZUxlbmd0aHNGcm9tU2lkZUxhYmVsKCBzaWRlLnNpZGVMYWJlbCApO1xyXG4gICAgY29uc3QgZmlyc3RBZGphY2VudFNpZGVMZW5ndGggPSBhZGphY2VudFNpZGVzWyAwIF07XHJcbiAgICBjb25zdCBzZWNvbmRBZGphY2VudFNpZGVMZW5ndGggPSBhZGphY2VudFNpZGVzWyAxIF07XHJcbiAgICBjb25zdCBhZGphY2VudFNpZGVzRXF1YWwgPSBVdGlscy5lcXVhbHNFcHNpbG9uKCBmaXJzdEFkamFjZW50U2lkZUxlbmd0aCwgc2Vjb25kQWRqYWNlbnRTaWRlTGVuZ3RoLCBsZW5ndGhUb2xlcmFuY2UgKTtcclxuICAgIGNvbnN0IGFkamFjZW50U2lkZXNQYXJhbGxlbCA9IGN1cnJlbnRTaGFwZVNuYXBzaG90LmdldEFkamFjZW50U2lkZXNQYXJhbGxlbEZyb21TaWRlTGFiZWwoIHNpZGUuc2lkZUxhYmVsICk7XHJcbiAgICBjb25zdCBzaWRlTGVuZ3RoID0gY3VycmVudFNoYXBlU25hcHNob3QuZ2V0TGVuZ3RoRnJvbVNpZGVMYWJlbCggc2lkZS5zaWRlTGFiZWwgKTtcclxuICAgIGNvbnN0IGVxdWFsVG9GaXJzdEFkamFjZW50ID0gc2hhcGVNb2RlbC5pc0ludGVyTGVuZ3RoRXF1YWxUb090aGVyKCBzaWRlTGVuZ3RoLCBmaXJzdEFkamFjZW50U2lkZUxlbmd0aCApO1xyXG4gICAgY29uc3QgZXF1YWxUb1NlY29uZEFkamFjZW50ID0gc2hhcGVNb2RlbC5pc0ludGVyTGVuZ3RoRXF1YWxUb090aGVyKCBzaWRlTGVuZ3RoLCBzZWNvbmRBZGphY2VudFNpZGVMZW5ndGggKTtcclxuICAgIGNvbnN0IGVxdWFsVG9PbmVBZGphY2VudCA9IGVxdWFsVG9GaXJzdEFkamFjZW50ICE9PSBlcXVhbFRvU2Vjb25kQWRqYWNlbnQ7XHJcbiAgICBjb25zdCBudW1iZXJPZkVxdWFsU2lkZXMgPSBjdXJyZW50U2hhcGVTbmFwc2hvdC5jb3VudE51bWJlck9mRXF1YWxTaWRlcygpO1xyXG5cclxuICAgIGNvbnN0IGZpcnN0QWRqYWNlbnRTaWRlTGVuZ3RoRGlmZmVyZW5jZSA9IGZpcnN0QWRqYWNlbnRTaWRlTGVuZ3RoIC0gZmlyc3RQcmV2aW91c0FkamFjZW50U2lkZUxlbmd0aDtcclxuICAgIGNvbnN0IHNlY29uZEFkamFjZW50U2lkZUxlbmd0aERpZmZlcmVuY2UgPSBzZWNvbmRBZGphY2VudFNpZGVMZW5ndGggLSBzZWNvbmRQcmV2aW91c0FkamFjZW50U2lkZUxlbmd0aDtcclxuXHJcbiAgICBjb25zdCBmaXJzdFNpZGVBYnNvbHV0ZURpZmZlcmVuY2UgPSBNYXRoLmFicyggZmlyc3RBZGphY2VudFNpZGVMZW5ndGhEaWZmZXJlbmNlICk7XHJcbiAgICBjb25zdCBzZWNvbmRTaWRlQWJzb2x1dGVEaWZmZXJlbmNlID0gTWF0aC5hYnMoIHNlY29uZEFkamFjZW50U2lkZUxlbmd0aERpZmZlcmVuY2UgKTtcclxuXHJcbiAgICAvLyBGbG93IG9mIHRoaXMgbG9naWMgYW5kIHByaW9yaXR5IG9mIHRoZSBjb250ZW50IGRldGVybWluZWQgYnkgZGVzaWduIHRlYW1cclxuICAgIGlmICggYWRqYWNlbnRTaWRlc0VxdWFsICYmICggKCBlcXVhbFRvRmlyc3RBZGphY2VudCAmJiAhcHJldmlvdXNFcXVhbFRvRmlyc3RBZGphY2VudCApIHx8ICggZXF1YWxUb1NlY29uZEFkamFjZW50ICYmICFwcmV2aW91c0VxdWFsVG9TZWNvbmRBZGphY2VudCApICkgKSB7XHJcblxyXG4gICAgICAvLyBzaWRlIGp1c3QgYmVjYW1lIGVxdWFsIHRvIGJvdGggYWRqYWNlbnQgc2lkZXNcclxuICAgICAgcmVzcG9uc2UgPSBlcXVhbFRvQWRqYWNlbnRTaWRlc1N0cmluZztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCBhZGphY2VudFNpZGVzRXF1YWwgJiYgIXByZXZpb3VzQWRqYWNlbnRTaWRlc0VxdWFsICkge1xyXG5cclxuICAgICAgLy8gYWRqYWNlbnQgc2lkZXMganVzdCBiZWNhbWUgZXF1YWxcclxuICAgICAgcmVzcG9uc2UgPSBhZGphY2VudFNpZGVzRXF1YWxTdHJpbmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggYWRqYWNlbnRTaWRlc1BhcmFsbGVsICYmICFwcmV2aW91c0FkamFjZW50U2lkZXNQYXJhbGxlbCApIHtcclxuXHJcbiAgICAgIC8vIGFkamFjZW50IHNpZGVzIGp1c3QgYmVjYW1lIHBhcmFsbGVsLCBkZXNjcmliZSB0aGF0IG5leHRcclxuICAgICAgcmVzcG9uc2UgPSBhZGphY2VudFNpZGVzUGFyYWxsZWxTdHJpbmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggZXF1YWxUb09uZUFkamFjZW50ICYmICFwcmV2aW91c0VxdWFsVG9PbmVBZGphY2VudCApIHtcclxuXHJcbiAgICAgIC8vIHRoZSBtb3Zpbmcgc2lkZSBqdXN0IGJlY2FtZSBlcXVhbCB0byBPTkUgb2YgaXRzIGFkamFjZW50IHNpZGVzLCBjYWxsIHRoYXQgb3V0XHJcbiAgICAgIHJlc3BvbnNlID0gZXF1YWxUb09uZUFkamFjZW50U2lkZVN0cmluZztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCBudW1iZXJPZkVxdWFsU2lkZXMgPT09IDMgJiYgcHJldmlvdXNOdW1iZXJPZkVxdWFsU2lkZXMgPCAzICkge1xyXG5cclxuICAgICAgLy8gd2UganVzdCBmb3VuZCBhIHNoYXBlIHdpdGggdGhyZWUgZXF1YWwgc2lkZXMgKG1vdmluZyBmcm9tIHR3byBlcXVhbCBzaWRlcylcclxuICAgICAgcmVzcG9uc2UgPSB0aHJlZVNpZGVzRXF1YWxTdHJpbmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggbnVtYmVyT2ZFcXVhbFNpZGVzID09PSAyICYmIHByZXZpb3VzTnVtYmVyT2ZFcXVhbFNpZGVzIDwgMiApIHtcclxuXHJcbiAgICAgIC8vIHdlIGp1c3QgZm91bmQgYSBzaGFwZSB3aXRoIHR3byBlcXVhbCBzaWRlcyAobW92aW5nIGZyb20gbm8gZXF1YWwgc2lkZXMpXHJcbiAgICAgIHJlc3BvbnNlID0gdHdvU2lkZXNFcXVhbFN0cmluZztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCBmaXJzdFNpZGVBYnNvbHV0ZURpZmZlcmVuY2UgPiB0b2xlcmFuY2VGb3JEZXNjcmliaW5nTGVuZ3RoQ2hhbmdlIHx8IHNlY29uZFNpZGVBYnNvbHV0ZURpZmZlcmVuY2UgPiB0b2xlcmFuY2VGb3JEZXNjcmliaW5nTGVuZ3RoQ2hhbmdlICkge1xyXG4gICAgICBpZiAoIE1hdGguc2lnbiggZmlyc3RBZGphY2VudFNpZGVMZW5ndGhEaWZmZXJlbmNlICkgPT09IE1hdGguc2lnbiggc2Vjb25kQWRqYWNlbnRTaWRlTGVuZ3RoRGlmZmVyZW5jZSApICkge1xyXG5cclxuICAgICAgICBjb25zdCBhZGphY2VudFNpZGVzTG9uZ2VyID0gZmlyc3RBZGphY2VudFNpZGVMZW5ndGhEaWZmZXJlbmNlID4gMDtcclxuICAgICAgICBjb25zdCBjaGFuZ2VTdHJpbmcgPSBhZGphY2VudFNpZGVzTG9uZ2VyID8gbG9uZ2VyU3RyaW5nIDogc2hvcnRlclN0cmluZztcclxuXHJcbiAgICAgICAgLy8gYWRqYWNlbnQgc2lkZXMgaGF2ZSBjaGFuZ2VkIGluIHRoZSBzYW1lIHdheSBhcyB0aGUgc2lkZSBtb3ZlcywgdGhpcyBpcyBhIGNsYXNzIG9mIGltcG9ydGFudCB0aGluZ3MgdG9cclxuICAgICAgICAvLyBkZXNjcmliZVxyXG4gICAgICAgIGlmICggYWRqYWNlbnRTaWRlc1BhcmFsbGVsICkge1xyXG4gICAgICAgICAgcmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIHBhcmFsbGVsQWRqYWNlbnRTaWRlc0NoYW5nZVBhdHRlcm5TdHJpbmcsIHtcclxuICAgICAgICAgICAgbGVuZ3RoQ2hhbmdlOiBjaGFuZ2VTdHJpbmdcclxuICAgICAgICAgIH0gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIGFkamFjZW50U2lkZXNFcXVhbCApIHtcclxuICAgICAgICAgIHJlc3BvbnNlID0gU3RyaW5nVXRpbHMuZmlsbEluKCBlcXVhbEFkamFjZW50U2lkZXNDaGFuZ2VQYXR0ZXJuU3RyaW5nLCB7XHJcbiAgICAgICAgICAgIGxlbmd0aENoYW5nZTogY2hhbmdlU3RyaW5nXHJcbiAgICAgICAgICB9ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIGFkamFjZW50U2lkZXNDaGFuZ2VQYXR0ZXJuU3RyaW5nLCB7XHJcbiAgICAgICAgICAgIGxlbmd0aENoYW5nZTogY2hhbmdlU3RyaW5nXHJcbiAgICAgICAgICB9ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAvLyB0aGV5IGFyZSBjaGFuZ2luZyBieSBhIGxhcmdlIGFtb3VudCwgYnV0IGluIGRpZmZlcmVudCB3YXlzIHNvIGRlc2NyaWJlIHRoZW0gZ2VuZXJhbGx5XHJcbiAgICAgICAgcmVzcG9uc2UgPSBhZGphY2VudFNpZGVzQ2hhbmdlSW5MZW5ndGhTdHJpbmc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgLy8gYWRqYWNlbnQgc2lkZXMgZGlkIG5vdCBjaGFuZ2UgZW5vdWdoLCBqdXN0IGluY2x1ZGUgYSBkaXJlY3Rpb24gZGVzY3JpcHRpb25cclxuICAgICAgY29uc3QgY3VycmVudFZlcnRleDFQb3NpdGlvbiA9IHNpZGUudmVydGV4MS5wb3NpdGlvblByb3BlcnR5LnZhbHVlO1xyXG4gICAgICBjb25zdCBwcmV2aW91c1ZlcnRleDFQb3NpdGlvbiA9IHRoaXMucHJldmlvdXNPYmplY3RSZXNwb25zZVNoYXBlU25hcHNob3QuZ2V0VmVydGV4UG9zaXRpb25zRnJvbVNpZGVMYWJlbCggc2lkZS5zaWRlTGFiZWwgKVsgMCBdO1xyXG4gICAgICByZXNwb25zZSA9IFF1YWRyaWxhdGVyYWxBbGVydGVyLmdldERpcmVjdGlvbkRlc2NyaXB0aW9uKCBwcmV2aW91c1ZlcnRleDFQb3NpdGlvbiwgY3VycmVudFZlcnRleDFQb3NpdGlvbiwgdGhpcy5tb2RlbFZpZXdUcmFuc2Zvcm0gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBPYmplY3QgUmVzcG9uc2UgdGhhdCBpcyBhbm5vdW5jZWQgZXZlcnkgbW92ZW1lbnQgd2l0aCBrZXlib2FyZCBkcmFnZ2luZy4gVGhpc1xyXG4gICAqIGlzIHVuaXF1ZSB0byBrZXlib2FyZCBpbnB1dC4gV2l0aCBtb3VzZS90b3VjaCBpbnB1dCwgdGhlIGxlc3MgZnJlcXVlbnQgcmF0ZSBvZiBjb250ZXh0IHJlc3BvbnNlc1xyXG4gICAqIGFyZSBzdWZmaWNpZW50IGZvciB0aGUgVm9pY2luZyBvdXRwdXQgdG8gZGVzY3JpYmUgdGhlIGNoYW5naW5nIHNoYXBlLiBXaXRoIGtleWJvYXJkLCB0aGUgdXNlclxyXG4gICAqIG5lZWRzIGEgcmVzcG9uc2UgZXZlcnkga2V5IHByZXNzIHRvIGtub3cgdGhhdCBjaGFuZ2VzIGFyZSBoYXBwZW5pbmcuXHJcbiAgICpcclxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFic3VyZGx5IGNvbXBsaWNhdGVkLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3F1YWRyaWxhdGVyYWwvaXNzdWVzLzIzNyBmb3JcclxuICAgKiB0aGUgcmVxdWVzdC5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBzaW5jZSB0aGlzIGlzIGRlcGVuZGVudCBvbiBhbmdsZXMgYW5kIG5vdCBqdXN0IHBvc2l0aW9uIFByb3BlcnRpZXMsIHRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXJcclxuICAgKiBzaGFwZUNoYW5nZWRFbWl0dGVyIGVtaXRzIHdoZW4gd2Uga25vdyB0aGF0IGFsbCBhbmdsZSBhbmQgc2hhcGUgUHJvcGVydGllcyBoYXZlIGJlZW4gdXBkYXRlZC4gU2VlXHJcbiAgICogUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwudXBkYXRlT3JkZXJEZXBlbmRlbnRQcm9wZXJ0aWVzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0VmVydGV4Q2hhbmdlT2JqZWN0UmVzcG9uc2UoIHZlcnRleDogUXVhZHJpbGF0ZXJhbFZlcnRleCApOiBzdHJpbmcge1xyXG4gICAgbGV0IHJlc3BvbnNlO1xyXG5cclxuICAgIC8vIFRoZSBwaHJhc2UgbGlrZSB0aGUgZGlyZWN0aW9uIGNoYW5nZSwgaG93IHRoZSB2ZXJ0ZXggYW5nbGUgY2hhbmdlcywgb3Igd2hldGhlciB0aGUgdmVydGV4IGFuZ2xlIGlzIGF0XHJcbiAgICAvLyBhIGNyaXRpY2FsIHZhbHVlIGxpa2UgOTAvMTgwIGRlZ3JlZXNcclxuICAgIGxldCBwcm9ncmVzc1Jlc3BvbnNlOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAvLyBBZGRpdGlvbmFsIHN0YXRlIGluZm9ybWF0aW9uIGFib3V0IG90aGVyIHZlcnRpY2VzLCBvciBob3cgd2lkZSB0aGUgbW92aW5nIHZlcnRleCBpcyByZWxhdGl2ZSB0byBvdGhlcnMgaW4gdGhlXHJcbiAgICAvLyBzaGFwZS5cclxuICAgIGxldCBzdGF0ZVJlc3BvbnNlOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBjb25zdCBzaGFwZU1vZGVsID0gdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbDtcclxuICAgIGNvbnN0IHZlcnRleERlc2NyaWJlciA9IHRoaXMuZGVzY3JpYmVyLmdldFZlcnRleERlc2NyaWJlckZvckxhYmVsKCB2ZXJ0ZXgudmVydGV4TGFiZWwgKTtcclxuXHJcbiAgICBjb25zdCBjdXJyZW50QW5nbGUgPSB2ZXJ0ZXguYW5nbGVQcm9wZXJ0eS52YWx1ZSE7XHJcbiAgICBjb25zdCBwcmV2aW91c0FuZ2xlID0gdGhpcy5wcmV2aW91c09iamVjdFJlc3BvbnNlU2hhcGVTbmFwc2hvdC5nZXRBbmdsZUZyb21WZXJ0ZXhMYWJlbCggdmVydGV4LnZlcnRleExhYmVsICk7XHJcblxyXG4gICAgY29uc3Qgb3Bwb3NpdGVWZXJ0ZXggPSBzaGFwZU1vZGVsLm9wcG9zaXRlVmVydGV4TWFwLmdldCggdmVydGV4ICkhO1xyXG4gICAgY29uc3Qgb3Bwb3NpdGVWZXJ0ZXhBbmdsZSA9IG9wcG9zaXRlVmVydGV4LmFuZ2xlUHJvcGVydHkudmFsdWUhO1xyXG5cclxuICAgIGNvbnN0IGFkamFjZW50VmVydGljZXMgPSBzaGFwZU1vZGVsLmFkamFjZW50VmVydGV4TWFwLmdldCggdmVydGV4ICkhO1xyXG4gICAgY29uc3QgZmlyc3RBZGphY2VudFZlcnRleCA9IGFkamFjZW50VmVydGljZXNbIDAgXTtcclxuICAgIGNvbnN0IGZpcnN0QWRqYWNlbnRBbmdsZSA9IGZpcnN0QWRqYWNlbnRWZXJ0ZXguYW5nbGVQcm9wZXJ0eS52YWx1ZSE7XHJcbiAgICBjb25zdCBzZWNvbmRBZGphY2VudFZlcnRleCA9IGFkamFjZW50VmVydGljZXNbIDEgXTtcclxuICAgIGNvbnN0IHNlY29uZEFkamFjZW50QW5nbGUgPSBzZWNvbmRBZGphY2VudFZlcnRleC5hbmdsZVByb3BlcnR5LnZhbHVlITtcclxuXHJcbiAgICAvLyB3aGV0aGVyIHRoZSBtb3ZpbmcgdmVydGV4IGFuZ2xlIGJlY29tZXMgZXF1YWwgdG8gYW55IG9mIHRoZSBvdGhlciB2ZXJ0aWNlcyAod2l0aGluIGludGVyQW5nbGVUb2xlcmFuY2VJbnRlcnZhbClcclxuICAgIGNvbnN0IGFuZ2xlRXF1YWxUb0ZpcnN0QWRqYWNlbnQgPSBzaGFwZU1vZGVsLmlzSW50ZXJBbmdsZUVxdWFsVG9PdGhlciggY3VycmVudEFuZ2xlLCBmaXJzdEFkamFjZW50QW5nbGUgKTtcclxuICAgIGNvbnN0IGFuZ2xlRXF1YWxUb1NlY29uZEFkamFjZW50ID0gc2hhcGVNb2RlbC5pc0ludGVyQW5nbGVFcXVhbFRvT3RoZXIoIGN1cnJlbnRBbmdsZSwgc2Vjb25kQWRqYWNlbnRBbmdsZSApO1xyXG4gICAgY29uc3QgYW5nbGVFcXVhbFRvT3Bwb3NpdGUgPSBzaGFwZU1vZGVsLmlzSW50ZXJBbmdsZUVxdWFsVG9PdGhlciggY3VycmVudEFuZ2xlLCBvcHBvc2l0ZVZlcnRleEFuZ2xlICk7XHJcblxyXG4gICAgLy8gR2V0IHRoZSBcInByb2dyZXNzXCIgcG9ydGlvbiBvZiB0aGUgb2JqZWN0IHJlc3BvbnNlLCBkZXNjcmliaW5nIGhvdyB0aGlzIHZlcnRleCBoYXMgY2hhbmdlZCBvciBpZiBpdCBoYXNcclxuICAgIC8vIHJlYWNoZWQgc29tZSBjcml0aWNhbCBhbmdsZS4gVGhpcyBwb3J0aW9uIG9mIHRoZSBkZXNjcmlwdGlvbiBpcyBhbHdheXMgaW5jbHVkZWQuXHJcbiAgICBpZiAoIHByZXZpb3VzQW5nbGUgPT09IGN1cnJlbnRBbmdsZSApIHtcclxuXHJcbiAgICAgIC8vIE1vdmluZyBhcm91bmQgc3ltbWV0cmljIHNoYXBlcywgaXQgaXMgcG9zc2libGUgdG8gbW92ZSB0aGUgdmVydGV4IGludG8gYSBuZXcgcG9zaXRpb24gd2hlcmUgdGhlIGFuZ2xlXHJcbiAgICAgIC8vIHN0YXllZCB0aGUgc2FtZS4gSW4gdGhpcyBjYXNlLCBvbmx5IGRlc2NyaWJlIHRoZSBkaXJlY3Rpb24gb2YgbW92ZW1lbnQuXHJcbiAgICAgIGNvbnN0IGN1cnJlbnRQb3NpdGlvbiA9IHZlcnRleC5wb3NpdGlvblByb3BlcnR5LnZhbHVlO1xyXG4gICAgICBjb25zdCBwcmV2aW91c1Bvc2l0aW9uID0gdGhpcy5wcmV2aW91c09iamVjdFJlc3BvbnNlU2hhcGVTbmFwc2hvdC5nZXRQb3NpdGlvbkZyb21WZXJ0ZXhMYWJlbCggdmVydGV4LnZlcnRleExhYmVsICk7XHJcbiAgICAgIHByb2dyZXNzUmVzcG9uc2UgPSBRdWFkcmlsYXRlcmFsQWxlcnRlci5nZXREaXJlY3Rpb25EZXNjcmlwdGlvbiggcHJldmlvdXNQb3NpdGlvbiwgY3VycmVudFBvc2l0aW9uLCB0aGlzLm1vZGVsVmlld1RyYW5zZm9ybSApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIHNoYXBlTW9kZWwuaXNSaWdodEFuZ2xlKCBjdXJyZW50QW5nbGUgKSApIHtcclxuICAgICAgcHJvZ3Jlc3NSZXNwb25zZSA9IHJpZ2h0QW5nbGVTdHJpbmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggc2hhcGVNb2RlbC5pc0ZsYXRBbmdsZSggY3VycmVudEFuZ2xlICkgKSB7XHJcbiAgICAgIHByb2dyZXNzUmVzcG9uc2UgPSBhbmdsZUZsYXRTdHJpbmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggIWFuZ2xlRXF1YWxUb0ZpcnN0QWRqYWNlbnQgJiYgIWFuZ2xlRXF1YWxUb1NlY29uZEFkamFjZW50ICYmICFhbmdsZUVxdWFsVG9PcHBvc2l0ZSApIHtcclxuXHJcbiAgICAgIC8vIGZhbGxiYWNrIGNhc2UsIGp1c3QgJ2FuZ2xlIHdpZGVyJyBvciAnYW5nbGUgc21hbGxlcicgLSBidXQgb25seSBpZiB0aGUgYW5nbGUgaXMgbm90IGVxdWFsIHRvIGFueSBvdGhlclxyXG4gICAgICAvLyB0byBwcmV2ZW50IHRoZSBhbGVydCBmcm9tIGdldHRpbmcgdG9vIGxvbmdcclxuICAgICAgY29uc3QgYW5nbGVDaGFuZ2VTdHJpbmcgPSBjdXJyZW50QW5nbGUgPiBwcmV2aW91c0FuZ2xlID8gd2lkZXJTdHJpbmcgOiB2ZXJ0ZXhEcmFnU21hbGxlclN0cmluZztcclxuICAgICAgcHJvZ3Jlc3NSZXNwb25zZSA9IFN0cmluZ1V0aWxzLmZpbGxJbiggdmVydGV4RHJhZ09iamVjdFJlc3BvbnNlUGF0dGVyblN0cmluZywge1xyXG4gICAgICAgIGFuZ2xlQ2hhbmdlOiBhbmdsZUNoYW5nZVN0cmluZ1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2hhcGVOYW1lID0gc2hhcGVNb2RlbC5zaGFwZU5hbWVQcm9wZXJ0eS52YWx1ZTtcclxuXHJcbiAgICAvLyBnZXQgdGhlIFwic3RhdGVcIiBwb3J0aW9uIG9mIHRoZSBvYmplY3QgcmVzcG9uc2UsIHdoaWNoIGRlc2NyaWJlcyBpbXBvcnRhbnQgc3RhdGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlXHJcbiAgICAvLyBxdWFkcmlsYXRlcmFsIGxpa2Ugd2hlbiBhIHBhaXIgb2YgYWRqYWNlbnQgYW5nbGVzIGFyZSBlcXVhbCwgb3Igd2hlbiB0aGUgbW92aW5nIGFuZ2xlIGlzIHR3aWNlL2hhbGYgb2YgYW5vdGhlclxyXG4gICAgLy8gYW5nbGUgaW4gdGhlIHNoYXBlLiBUaGVyZSBtYXkgbm90IGFsd2F5cyBiZSBpbXBvcnRhbnQgc3RhdGUgaW5mb3JtYXRpb24uXHJcbiAgICBpZiAoIHByZXZpb3VzQW5nbGUgIT09IGN1cnJlbnRBbmdsZSApIHtcclxuICAgICAgaWYgKCBzaGFwZU1vZGVsLmdldEFyZUFsbEFuZ2xlc1JpZ2h0KCkgKSB7XHJcblxyXG4gICAgICAgIC8vIGltcG9ydGFudCBzdGF0ZSBkZXNjcmliZWQgd2hlbiBhIHNxdWFyZVxyXG4gICAgICAgIHN0YXRlUmVzcG9uc2UgPSBlcXVhbFRvT3Bwb3NpdGVDb3JuZXJFcXVhbFRvQWRqYWNlbnRDb3JuZXJzU3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCBhbmdsZUVxdWFsVG9GaXJzdEFkamFjZW50ICYmIGFuZ2xlRXF1YWxUb1NlY29uZEFkamFjZW50ICkge1xyXG5cclxuICAgICAgICAvLyB0aGUgbW92aW5nIGFuZ2xlIGp1c3QgYmVjYW1lIGVxdWFsIHRvIGl0cyB0d28gYWRqYWNlbnQgY29ybmVyc1xyXG4gICAgICAgIHN0YXRlUmVzcG9uc2UgPSBlcXVhbFRvQWRqYWNlbnRDb3JuZXJzU3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCBhbmdsZUVxdWFsVG9GaXJzdEFkamFjZW50IHx8IGFuZ2xlRXF1YWxUb09wcG9zaXRlIHx8IGFuZ2xlRXF1YWxUb1NlY29uZEFkamFjZW50ICkge1xyXG5cclxuICAgICAgICAvLyBJZiB2ZXJ0ZXggdGhlIGFuZ2xlIGp1c3QgYmVjYW1lIGVxdWFsIHRvIGFub3RoZXIsIHRoYXQgaXMgdGhlIG1vc3QgaW1wb3J0YW50IGluZm9ybWF0aW9uIGFuZCBzaG91bGQgYmVcclxuICAgICAgICAvLyBkZXNjcmliZWRcclxuICAgICAgICBjb25zdCBvdGhlclZlcnRleCA9IGFuZ2xlRXF1YWxUb0ZpcnN0QWRqYWNlbnQgPyBmaXJzdEFkamFjZW50VmVydGV4IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlRXF1YWxUb09wcG9zaXRlID8gb3Bwb3NpdGVWZXJ0ZXggOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kQWRqYWNlbnRWZXJ0ZXg7XHJcblxyXG4gICAgICAgIC8vIGlmIGVxdWFsIHRvIHRoZSBvcHBvc2l0ZSBjb3JuZXIsIGp1c3Qgc2F5IFwib3Bwb3NpdGUgY29ybmVyXCIgaW5zdGVhZCBvZiB0aGUgY29ybmVyIGxhYmVsXHJcbiAgICAgICAgY29uc3Qgb3RoZXJDb3JuZXJMYWJlbFN0cmluZyA9IGFuZ2xlRXF1YWxUb09wcG9zaXRlID8gb3Bwb3NpdGVDb3JuZXJTdHJpbmcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWFkcmlsYXRlcmFsVmVydGV4RGVzY3JpYmVyLlZFUlRFWF9DT1JORVJfTEFCRUxfTUFQLmdldCggb3RoZXJWZXJ0ZXgudmVydGV4TGFiZWwgKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29tcGFyaXNvbkRlc2NyaXB0aW9uID0gdmVydGV4RGVzY3JpYmVyLmdldEFuZ2xlQ29tcGFyaXNvbkRlc2NyaXB0aW9uKCBvdGhlclZlcnRleCwgc2hhcGVOYW1lICk7XHJcbiAgICAgICAgc3RhdGVSZXNwb25zZSA9IFN0cmluZ1V0aWxzLmZpbGxJbiggYW5nbGVDb21wYXJpc29uUGF0dGVyblN0cmluZywge1xyXG4gICAgICAgICAgY29tcGFyaXNvbjogY29tcGFyaXNvbkRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgY29ybmVyTGFiZWw6IG90aGVyQ29ybmVyTGFiZWxTdHJpbmdcclxuICAgICAgICB9ICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoIHRoaXMuc2hvdWxkVXNlQW5nbGVDb21wYXJpc29uRGVzY3JpcHRpb24oIGN1cnJlbnRBbmdsZSwgb3Bwb3NpdGVWZXJ0ZXhBbmdsZSApICkge1xyXG5cclxuICAgICAgICAvLyBkZXNjcmliZSByZWxhdGl2ZSBzaXplIHRvIG9wcG9zaXRlIHZlcnRleFxyXG4gICAgICAgIGNvbnN0IGNvbXBhcmlzb25EZXNjcmlwdGlvbiA9IHZlcnRleERlc2NyaWJlci5nZXRBbmdsZUNvbXBhcmlzb25EZXNjcmlwdGlvbiggb3Bwb3NpdGVWZXJ0ZXgsIHNoYXBlTmFtZSApO1xyXG4gICAgICAgIHN0YXRlUmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIGFuZ2xlQ29tcGFyaXNvblBhdHRlcm5TdHJpbmcsIHtcclxuICAgICAgICAgIGNvbXBhcmlzb246IGNvbXBhcmlzb25EZXNjcmlwdGlvbixcclxuICAgICAgICAgIGNvcm5lckxhYmVsOiBvcHBvc2l0ZUNvcm5lclN0cmluZ1xyXG4gICAgICAgIH0gKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICggc2hhcGVNb2RlbC5pc0ludGVyQW5nbGVFcXVhbFRvT3RoZXIoIGZpcnN0QWRqYWNlbnRBbmdsZSwgc2Vjb25kQWRqYWNlbnRBbmdsZSApICkge1xyXG5cclxuICAgICAgICAvLyBUaGUgYWRqYWNlbnQgYW5nbGVzIGp1c3QgYmVjYW1lIGVxdWFsIHRvIGVhY2hvdGhlciwgZGVzY3JpYmUgdGhhdCBuZXh0IChhZnRlciBvcHBvc2l0ZSBpbiBwcmlvcml0eSlcclxuICAgICAgICBpZiAoIHNoYXBlTW9kZWwuaXNSaWdodEFuZ2xlKCBmaXJzdEFkamFjZW50QW5nbGUgKSApIHtcclxuICAgICAgICAgIHN0YXRlUmVzcG9uc2UgPSBhZGphY2VudENvcm5lcnNSaWdodEFuZ2xlc1N0cmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBzdGF0ZVJlc3BvbnNlID0gYWRqYWNlbnRDb3JuZXJzRXF1YWxTdHJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCB0aGlzLnNob3VsZFVzZUFuZ2xlQ29tcGFyaXNvbkRlc2NyaXB0aW9uKCBjdXJyZW50QW5nbGUsIGZpcnN0QWRqYWNlbnRBbmdsZSApICkge1xyXG5cclxuICAgICAgICAvLyBkZWNyaWJlIHJlbGF0aXZlIHNpemUgKGhhbGYgb3IgdHdpY2UgYXMgbGFyZ2UgYXMpIHRvIHRoZSBmaXJzdCBhZGphY2VudCB2ZXJ0ZXhcclxuICAgICAgICBjb25zdCBjb21wYXJpc29uRGVzY3JpcHRpb24gPSB2ZXJ0ZXhEZXNjcmliZXIuZ2V0QW5nbGVDb21wYXJpc29uRGVzY3JpcHRpb24oIGZpcnN0QWRqYWNlbnRWZXJ0ZXgsIHNoYXBlTmFtZSApO1xyXG4gICAgICAgIHN0YXRlUmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIGFuZ2xlQ29tcGFyaXNvblBhdHRlcm5TdHJpbmcsIHtcclxuICAgICAgICAgIGNvbXBhcmlzb246IGNvbXBhcmlzb25EZXNjcmlwdGlvbixcclxuICAgICAgICAgIGNvcm5lckxhYmVsOiBRdWFkcmlsYXRlcmFsVmVydGV4RGVzY3JpYmVyLlZFUlRFWF9DT1JORVJfTEFCRUxfTUFQLmdldCggZmlyc3RBZGphY2VudFZlcnRleC52ZXJ0ZXhMYWJlbCApXHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCB0aGlzLnNob3VsZFVzZUFuZ2xlQ29tcGFyaXNvbkRlc2NyaXB0aW9uKCBjdXJyZW50QW5nbGUsIHNlY29uZEFkamFjZW50QW5nbGUgKSApIHtcclxuXHJcbiAgICAgICAgLy8gZGVjcmliZSByZWxhdGl2ZSBzaXplIChoYWxmIG9yIHR3aWNlIGFzIGxhcmdlIGFzKSB0byB0aGUgc2Vjb25kIGFkamFjZW50IHZlcnRleFxyXG4gICAgICAgIGNvbnN0IGNvbXBhcmlzb25EZXNjcmlwdGlvbiA9IHZlcnRleERlc2NyaWJlci5nZXRBbmdsZUNvbXBhcmlzb25EZXNjcmlwdGlvbiggc2Vjb25kQWRqYWNlbnRWZXJ0ZXgsIHNoYXBlTmFtZSApO1xyXG4gICAgICAgIHN0YXRlUmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIGFuZ2xlQ29tcGFyaXNvblBhdHRlcm5TdHJpbmcsIHtcclxuICAgICAgICAgIGNvbXBhcmlzb246IGNvbXBhcmlzb25EZXNjcmlwdGlvbixcclxuICAgICAgICAgIGNvcm5lckxhYmVsOiBRdWFkcmlsYXRlcmFsVmVydGV4RGVzY3JpYmVyLlZFUlRFWF9DT1JORVJfTEFCRUxfTUFQLmdldCggc2Vjb25kQWRqYWNlbnRWZXJ0ZXgudmVydGV4TGFiZWwgKVxyXG4gICAgICAgIH0gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHByb2dyZXNzUmVzcG9uc2UgfHwgc3RhdGVSZXNwb25zZSwgJ1RoZXJlIG5lZWRzIHRvIGJlIGEgcmVzcG9uc2UsIHdlIGhhdmUgYSBjYXNlIHRoYXQgaXMgbm90IGRlc2NyaWJlZC4nICk7XHJcbiAgICBpZiAoIHByb2dyZXNzUmVzcG9uc2UgJiYgc3RhdGVSZXNwb25zZSApIHtcclxuXHJcbiAgICAgIHJlc3BvbnNlID0gU3RyaW5nVXRpbHMuZmlsbEluKCBwcm9ncmVzc1N0YXRlUGF0dGVyblN0cmluZywge1xyXG4gICAgICAgIHByb2dyZXNzOiBwcm9ncmVzc1Jlc3BvbnNlLFxyXG4gICAgICAgIHN0YXRlOiBzdGF0ZVJlc3BvbnNlXHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCBzdGF0ZVJlc3BvbnNlICkge1xyXG4gICAgICByZXNwb25zZSA9IHN0YXRlUmVzcG9uc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmVzcG9uc2UgPSBwcm9ncmVzc1Jlc3BvbnNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXNwb25zZSE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGNoYW5naW5nIHZlcnRleCBvYmplY3QgcmVzcG9uc2Ugc2hvdWxkIGluY2x1ZGUgYSBkZXNjcmlwdGlvbiBvZiB0aGUgYW5nbGUgY29tcGFyZWQgdG8gYW5vdGhlci5cclxuICAgKiBUaGlzIGlzIG9ubHkgaW5jbHVkZWQgaWYgdGhlIGNoYW5naW5nVmVydGV4QW5nbGUgaXMgYXJvdW5kIGhhbGYsIHR3aWNlLCBvciBlcXVhbCB0byB0aGUgb3RoZXIgYW5nbGUuIFRoZSBvdGhlclxyXG4gICAqIGFuZ2xlIG1pZ2h0IGJlIGFuIG9wcG9zaXRlIG9yIGFkamFjZW50IGFuZ2xlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgc2hvdWxkVXNlQW5nbGVDb21wYXJpc29uRGVzY3JpcHRpb24oIGNoYW5naW5nVmVydGV4QW5nbGU6IG51bWJlciwgb3RoZXJWZXJ0ZXhBbmdsZTogbnVtYmVyICk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIFF1YWRyaWxhdGVyYWxWZXJ0ZXhEZXNjcmliZXIuaXNBbmdsZUFib3V0SGFsZk90aGVyKCBjaGFuZ2luZ1ZlcnRleEFuZ2xlLCBvdGhlclZlcnRleEFuZ2xlICkgfHxcclxuICAgICAgICAgICBRdWFkcmlsYXRlcmFsVmVydGV4RGVzY3JpYmVyLmlzQW5nbGVBYm91dFR3aWNlT3RoZXIoIGNoYW5naW5nVmVydGV4QW5nbGUsIG90aGVyVmVydGV4QW5nbGUgKSB8fFxyXG4gICAgICAgICAgIHRoaXMucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwuaXNJbnRlckFuZ2xlRXF1YWxUb090aGVyKCBjaGFuZ2luZ1ZlcnRleEFuZ2xlLCBvdGhlclZlcnRleEFuZ2xlICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYSByZXNwb25zZSBkZXNjcmlwdGlvbiBmb3IgdGhlIHNoYXBlIGNoYW5nZSBmcm9tIHByZXZpb3VzIHN0YXRlIHRvIGN1cnJlbnQuIFdpbGwgZGVzY3JpYmUgcGFyYWxsZWwgc2lkZXMsXHJcbiAgICogc2hhcGUgYXJlYSwgYW5kIHNpZGUgdGlsdCBkdXJpbmcgY2hhbmdlcyBhbmQgaW50ZXJhY3Rpb24uIFRoZSBsb2dpYyBvZiB0aGlzIGZ1bmN0aW9uIGlzIGFzIGRlc2NyaWJlZCBpbiB0aGVcclxuICAgKiBkZXNpZ24gZG9jLCBzZWVcclxuICAgKiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFqWGF5ZWJBV25uTnpzVDNsNm83MllQdzQtWXRpUWFIUU51QWk2NGVpZ3VjL2VkaXQjaGVhZGluZz1oLmFwMmQwanF2dDVldFxyXG4gICAqXHJcbiAgICogV2lsbCByZXR1cm4gc29tZXRoaW5nIGxpa2VcclxuICAgKiBcIk9wcG9zaXRlIHNpZGVzIEFCIGFuZCBDRCB0aWx0IGluIHBhcmFsbGVsIGFzIHNoYXBlIGdldHMgYmlnZ2VyLlwiIG9yXHJcbiAgICogXCJBbGwgc2lkZXMgdGlsdCBhd2F5IGZyb20gcGFyYWxsZWwgYXMgb3Bwb3NpdGUgY29ybmVycyBjaGFuZ2UgdW5lcXVhbGx5LlwiIG9yXHJcbiAgICogXCJPcHBvc2l0ZSBzaWRlcyBzdHJhaWdodGVuIGluIHBhcmFsbGVsIGFzIG9wcG9zaXRlIGNvcm5lcnMgY2hhbmdlIGVxdWFsbHkuXCIgb3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSBzaGFwZU1vZGVsXHJcbiAgICogQHBhcmFtIHByZXZpb3VzU2hhcGVTbmFwc2hvdCAtIE9iamVjdCBob2xkaW5nIHNoYXBlIGZpZWxkcyBmcm9tIHRoZSBwcmV2aW91cyB0aW1lIHRoaXMgZnVuY3Rpb24gd2FzIHVzZWRcclxuICAgKiBAcGFyYW0gcmVzcG9uc2VSZWFzb24gLSBUaGlzIHJlc3BvbnNlIGhhcHBlbnMgd2hlbiBhbmdsZXMgb3IgbGVuZ3RocyBjaGFuZ2UgZW5vdWdoIHRvIHRyaWdnZXIgYSBuZXcgZGVzY3JpcHRpb24sXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHRyaWdnZXJpbmcgY2FzZSB3aWxsIGRldGVybWluZSBwYXJ0cyBvZiB0aGUgcmVzcG9uc2Ugc3RyaW5nLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0U2hhcGVDaGFuZ2VSZXNwb25zZSggc2hhcGVNb2RlbDogUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwsIHByZXZpb3VzU2hhcGVTbmFwc2hvdDogUXVhZHJpbGF0ZXJhbFNoYXBlU25hcHNob3QsIHJlc3BvbnNlUmVhc29uOiBSZXNwb25zZVJlYXNvbiApOiBzdHJpbmcgfCBudWxsIHtcclxuICAgIGxldCByZXNwb25zZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgY29uc3QgYXJlYURpZmZlcmVuY2UgPSBzaGFwZU1vZGVsLmFyZWFQcm9wZXJ0eS52YWx1ZSAtIHByZXZpb3VzU2hhcGVTbmFwc2hvdC5hcmVhO1xyXG4gICAgY29uc3QgYXJlYUNoYW5nZVN0cmluZyA9IGFyZWFEaWZmZXJlbmNlID4gMCA/IGJpZ2dlclN0cmluZyA6IHNtYWxsZXJTdHJpbmc7XHJcblxyXG4gICAgaWYgKCBzaGFwZU1vZGVsLmlzUGFyYWxsZWxvZ3JhbSgpICYmIHByZXZpb3VzU2hhcGVTbmFwc2hvdC5pc1BhcmFsbGVsb2dyYW0gKSB7XHJcblxyXG4gICAgICAvLyByZW1haW5lZCBhIHBhcmFsbGVsb2dyYW0gdGhyb3VnaCBjaGFuZ2VzXHJcbiAgICAgIGlmICggcmVzcG9uc2VSZWFzb24gPT09ICdhbmdsZScgKSB7XHJcblxyXG4gICAgICAgIC8vIGFuZ2xlIGlzIHRoZSBkb21pbmFudCByZXNwb25zZSBhbmQgY2F1c2VkIHRoZSBjaGFuZ2UsIHdlIGFyZSBkZXNjcmliaW5nIGNoYW5nZSBpbiBzaWRlIHRpbHRcclxuICAgICAgICBjb25zdCB0aWx0Q2hhbmdlU3RyaW5nID0gdGhpcy5nZXRUaWx0T3JTdHJhaWdodGVuRGVzY3JpcHRpb24oIHByZXZpb3VzU2hhcGVTbmFwc2hvdCApO1xyXG4gICAgICAgIHJlc3BvbnNlID0gU3RyaW5nVXRpbHMuZmlsbEluKCBvcHBvc2l0ZVNpZGVzVGlsdFBhdHRlcm5TdHJpbmcsIHtcclxuICAgICAgICAgIHRpbHRDaGFuZ2U6IHRpbHRDaGFuZ2VTdHJpbmdcclxuICAgICAgICB9ICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoIHJlc3BvbnNlUmVhc29uID09PSAnbGVuZ3RoJyApIHtcclxuXHJcbiAgICAgICAgLy8gbGVuZ3RocyBjaGFuZ2VkIGVub3VnaCB3aGlsZSBpbiBwYXJhbGxlbCB0byBkZXNjcmliZSBsZW5ndGggd2l0aG91dCBkZXNjcmliaW5nIHRpbHRcclxuICAgICAgICBjb25zdCBwYXR0ZXJuU3RyaW5nID0gb3Bwb3NpdGVTaWRlc0luUGFyYWxsZWxQYXR0ZXJuU3RyaW5nO1xyXG4gICAgICAgIHJlc3BvbnNlID0gU3RyaW5nVXRpbHMuZmlsbEluKCBwYXR0ZXJuU3RyaW5nLCB7XHJcbiAgICAgICAgICBhcmVhQ2hhbmdlOiBhcmVhQ2hhbmdlU3RyaW5nXHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuXHJcbiAgICAgIGNvbnN0IHNpZGVBQnNpZGVDRFBhcmFsbGVsQmVmb3JlID0gcHJldmlvdXNTaGFwZVNuYXBzaG90LnNpZGVBQnNpZGVDRFBhcmFsbGVsO1xyXG4gICAgICBjb25zdCBzaWRlQkNTaWRlREFQYXJhbGxlbEJlZm9yZSA9IHByZXZpb3VzU2hhcGVTbmFwc2hvdC5zaWRlQkNzaWRlREFQYXJhbGxlbDtcclxuXHJcbiAgICAgIGNvbnN0IHNpZGVBQlNpZGVDRFBhcmFsbGVsQWZ0ZXIgPSBzaGFwZU1vZGVsLnNpZGVBQlNpZGVDRFBhcmFsbGVsU2lkZUNoZWNrZXIuYXJlU2lkZXNQYXJhbGxlbCgpO1xyXG4gICAgICBjb25zdCBzaWRlQkNTaWRlREFQYXJhbGxlbEFmdGVyID0gc2hhcGVNb2RlbC5zaWRlQkNTaWRlREFQYXJhbGxlbFNpZGVDaGVja2VyLmFyZVNpZGVzUGFyYWxsZWwoKTtcclxuXHJcbiAgICAgIC8vIGZvciByZWFkYWJpbGl0eSwgY2FzZXMgYXJlIGRldGVybWluZWQgYnkgY3VycmVudCBhbmQgY2hhbmdlIGluIHNpZGUgcGFyYWxsZWwgc3RhdGUgb2Ygc2lkZXNcclxuICAgICAgY29uc3Qgb25seU9uZVBhcmFsbGVsQWZ0ZXIgPSBzaWRlQUJTaWRlQ0RQYXJhbGxlbEFmdGVyICE9PSBzaWRlQkNTaWRlREFQYXJhbGxlbEFmdGVyO1xyXG4gICAgICBjb25zdCBuZWl0aGVyUGFyYWxsZWxCZWZvcmUgPSAhc2lkZUFCc2lkZUNEUGFyYWxsZWxCZWZvcmUgJiYgIXNpZGVCQ1NpZGVEQVBhcmFsbGVsQmVmb3JlO1xyXG4gICAgICBjb25zdCBuZWl0aGVyUGFyYWxsZWxBZnRlciA9ICFzaWRlQUJTaWRlQ0RQYXJhbGxlbEFmdGVyICYmICFzaWRlQkNTaWRlREFQYXJhbGxlbEFmdGVyO1xyXG4gICAgICBjb25zdCBhdExlYXN0T25lUGFyYWxsZWxCZWZvcmUgPSBzaWRlQUJzaWRlQ0RQYXJhbGxlbEJlZm9yZSB8fCBzaWRlQkNTaWRlREFQYXJhbGxlbEJlZm9yZTtcclxuXHJcbiAgICAgIC8vIEFueSByZW1haW5pbmcgcGFyYWxsZWwgc2lkZXMgYXJlIGRlc2NyaWJlZCwgZGV0ZXJtaW5lIHdoaWNoIG9wcG9zaXRlIHNpZGVzIHRvIHVzZVxyXG4gICAgICBsZXQgZmlyc3RTaWRlU3RyaW5nO1xyXG4gICAgICBsZXQgc2Vjb25kU2lkZVN0cmluZztcclxuICAgICAgaWYgKCBzaWRlQUJTaWRlQ0RQYXJhbGxlbEFmdGVyICkge1xyXG4gICAgICAgIGZpcnN0U2lkZVN0cmluZyA9IGFCU3RyaW5nO1xyXG4gICAgICAgIHNlY29uZFNpZGVTdHJpbmcgPSBjRFN0cmluZztcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBmaXJzdFNpZGVTdHJpbmcgPSBiQ1N0cmluZztcclxuICAgICAgICBzZWNvbmRTaWRlU3RyaW5nID0gZEFTdHJpbmc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICggbmVpdGhlclBhcmFsbGVsQmVmb3JlICYmIG9ubHlPbmVQYXJhbGxlbEFmdGVyICkge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm5TdHJpbmcgPSBvcHBvc2l0ZVNpZGVzSW5QYXJhbGxlbEFzQ29ybmVyc0NoYW5nZUVxdWFsbHlQYXR0ZXJuU3RyaW5nO1xyXG5cclxuICAgICAgICByZXNwb25zZSA9IFN0cmluZ1V0aWxzLmZpbGxJbiggcGF0dGVyblN0cmluZywge1xyXG4gICAgICAgICAgZmlyc3RTaWRlOiBmaXJzdFNpZGVTdHJpbmcsXHJcbiAgICAgICAgICBzZWNvbmRTaWRlOiBzZWNvbmRTaWRlU3RyaW5nXHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCBvbmx5T25lUGFyYWxsZWxBZnRlciApIHtcclxuXHJcbiAgICAgICAgLy8gaWYgb25lIHBhaXIgb2Ygc2lkZXMgcmVtYWlucyBpbiBwYXJhbGxlbCBhZnRlciB0aGUgY2hhbmdlLCBhbmQgaXQgaXMgdGhlIHNhbWUgc2lkZSBwYWlyXHJcbiAgICAgICAgY29uc3QgcGF0dGVyblN0cmluZyA9IG9wcG9zaXRlU2lkZXNUaWx0QXNTaGFwZUNoYW5nZXNQYXR0ZXJuU3RyaW5nO1xyXG4gICAgICAgIHJlc3BvbnNlID0gU3RyaW5nVXRpbHMuZmlsbEluKCBwYXR0ZXJuU3RyaW5nLCB7XHJcbiAgICAgICAgICBmaXJzdFNpZGU6IGZpcnN0U2lkZVN0cmluZyxcclxuICAgICAgICAgIHNlY29uZFNpZGU6IHNlY29uZFNpZGVTdHJpbmcsXHJcbiAgICAgICAgICBhcmVhQ2hhbmdlOiBhcmVhQ2hhbmdlU3RyaW5nXHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCBhdExlYXN0T25lUGFyYWxsZWxCZWZvcmUgJiYgbmVpdGhlclBhcmFsbGVsQWZ0ZXIgKSB7XHJcblxyXG4gICAgICAgIC8vIGF0IGxlYXN0IG9uZSB0byB6ZXJvIHBhcmFsbGVsIHNpZGUgcGFpcnNcclxuICAgICAgICByZXNwb25zZSA9IGFsbFNpZGVzVGlsdEF3YXlGcm9tUGFyYWxsZWxTdHJpbmc7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoIG5laXRoZXJQYXJhbGxlbEJlZm9yZSAmJiBuZWl0aGVyUGFyYWxsZWxBZnRlciApIHtcclxuXHJcbiAgICAgICAgLy8gbm8gcGFyYWxsZWwgc2lkZSBwYWlycyBiZWZvcmUgYW5kIGFmdGVyXHJcbiAgICAgICAgY29uc3QgcGF0dGVyblN0cmluZyA9IGFsbFNpZGVzVGlsdEF3YXlGcm9tUGFyYWxsZWxBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmc7XHJcbiAgICAgICAgcmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIHBhdHRlcm5TdHJpbmcsIHtcclxuICAgICAgICAgIGFyZWFDaGFuZ2U6IGFyZWFDaGFuZ2VTdHJpbmdcclxuICAgICAgICB9ICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgZGVzY3JpcHRpb24gb2YgdGhlIHNoYXBlIGZvciBhIGNvbnRleHQgcmVzcG9uc2UgYXMgbW92ZW1lbnRzIG9jY3VyIHRoYXQgbWFpbnRhaW4gdGhlIHNhbWVcclxuICAgKiBuYW1lZCBzaGFwZS4gRm9yIGV4YW1wbGUsIG1vdmluZyBvbmUgc2lkZSB0byBtYWtlIGEgbG9uZ2VyIHJlY3RhbmdsZS4gU2VlXHJcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3F1YWRyaWxhdGVyYWwvaXNzdWVzLzE5OCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZGVzaWduIGZvciB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogV2lsbCByZXR1cm4gc29tZXRoaW5nIGxpa2U6XHJcbiAgICogXCJBbGwgcmlnaHQgYW5nbGVzIGFzIHNoYXBlIGdldHMgYmlnZ2VyLlwiIG9yXHJcbiAgICogXCJPcHBvc2l0ZSBzaWRlcyBCQyBhbmQgREEgZXF1YWwgYXMgc2hhcGUgZ2V0cyBiaWdnZXIuXCIgb3JcclxuICAgKiBcIk9wcG9zaXRlIHNpZGVzIGluIHBhcmFsbGVsIGFzIG9wcG9zaXRlIGNvcm5lcnMgY2hhbmdlIGVxdWFsbHkuXCJcclxuICAgKi9cclxuICBwcml2YXRlIGdldFNoYXBlTWFpbnRlbmFuY2VDb250ZXh0UmVzcG9uc2UoIHNoYXBlTmFtZTogTmFtZWRRdWFkcmlsYXRlcmFsLCBwcmV2aW91c1NoYXBlU25hcHNob3Q6IFF1YWRyaWxhdGVyYWxTaGFwZVNuYXBzaG90LCB0aGlzUmVzcG9uc2VSZWFzb246IFJlc3BvbnNlUmVhc29uICk6IHN0cmluZyB8IG51bGwge1xyXG4gICAgbGV0IHJlc3BvbnNlOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBjb25zdCBhcmVhRGlmZmVyZW5jZSA9IHRoaXMucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwuYXJlYVByb3BlcnR5LnZhbHVlIC0gcHJldmlvdXNTaGFwZVNuYXBzaG90LmFyZWE7XHJcbiAgICBjb25zdCBhcmVhQ2hhbmdlU3RyaW5nID0gYXJlYURpZmZlcmVuY2UgPiAwID8gYmlnZ2VyU3RyaW5nIDogc21hbGxlclN0cmluZztcclxuXHJcbiAgICBpZiAoIHNoYXBlTmFtZSA9PT0gTmFtZWRRdWFkcmlsYXRlcmFsLkNPTlZFWF9RVUFEUklMQVRFUkFMIHx8IHNoYXBlTmFtZSA9PT0gTmFtZWRRdWFkcmlsYXRlcmFsLkNPTkNBVkVfUVVBRFJJTEFURVJBTCApIHtcclxuICAgICAgcmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIGFsbFNpZGVzVGlsdEF3YXlGcm9tUGFyYWxsZWxBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmcsIHtcclxuICAgICAgICBhcmVhQ2hhbmdlOiBhcmVhQ2hhbmdlU3RyaW5nXHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCBzaGFwZU5hbWUgPT09IE5hbWVkUXVhZHJpbGF0ZXJhbC5UUklBTkdMRSApIHtcclxuICAgICAgY29uc3QgZmxhdFZlcnRleCA9IF8uZmluZChcclxuICAgICAgICB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLnZlcnRpY2VzLFxyXG4gICAgICAgIHZlcnRleCA9PiB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLmlzU3RhdGljQW5nbGVFcXVhbFRvT3RoZXIoIHZlcnRleC5hbmdsZVByb3BlcnR5LnZhbHVlISwgTWF0aC5QSSApXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBjb25zaWRlciBzbWFsbCBlbm91Z2ggdmFsdWVzIGFzICdjb25zdGFudCBhcmVhJyBiZWNhdXNlIHRoZSBhcmVhIG1pZ2h0IGNoYW5nZSBieSBuZWdsaWdpYmxlIHZhbHVlcyB3aXRoaW5cclxuICAgICAgLy8gcHJlY2lzaW9uIGVycm9yXHJcbiAgICAgIGlmICggYXJlYURpZmZlcmVuY2UgPCAxZS01ICkge1xyXG5cclxuICAgICAgICAvLyBXZSBoYXZlIGEgdHJpYW5nbGUgb25lIHZlcnRleCBpcyAxODAgZGVncmVlcyBhbmQgdGhlIHNoYXBlIGlzIG1vdmluZyBzdWNoIHRoYXQgdGhlIGFyZWFcclxuICAgICAgICAvLyBpcyBub3QgY2hhbmdpbmcuIERlc2NyaWJlIHRoZSBcImZsYXRcIiB2ZXJ0ZXggYW5kIGhvdyBpdHMgYWRqYWNlbnQgc2lkZXMgZ2V0IGxvbmdlciBvciBzaG9ydGVyXHJcbiAgICAgICAgcmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIGNvcm5lckZsYXRBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmcsIHtcclxuICAgICAgICAgIGNvcm5lckxhYmVsOiBRdWFkcmlsYXRlcmFsVmVydGV4RGVzY3JpYmVyLlZFUlRFWF9DT1JORVJfTEFCRUxfTUFQLmdldCggZmxhdFZlcnRleCEudmVydGV4TGFiZWwgKVxyXG4gICAgICAgIH0gKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gV2UgaGF2ZSBhIHRyaWFuZ2xlIGJlaW5nIG1haW50YWluZWQgYnV0IHRoZSBhcmVhIGlzIGNoYW5naW5nLCBzbyB3ZSBkZXNjcmliZSBob3cgaXQgdGhlIGFkamFjZW50XHJcbiAgICAgICAgLy8gc2lkZXMgcmVtYWluIGluIGxpbmUgYXMgdGhlIHNoYXBlIGdldHMgYmlnZ2VyIG9yIHNtYWxsZXJcclxuXHJcbiAgICAgICAgLy8gZmluZCB0aGUgc2lkZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoZSBmbGF0IHZlcnRleFxyXG4gICAgICAgIGNvbnN0IGZsYXRTaWRlcyA9IF8uZmlsdGVyKCB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLnNpZGVzLCBzaWRlID0+IHNpZGUudmVydGV4MSA9PT0gZmxhdFZlcnRleCB8fCBzaWRlLnZlcnRleDIgPT09IGZsYXRWZXJ0ZXggKTtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmbGF0U2lkZXMubGVuZ3RoID09PSAyLCAnV2Ugc2hvdWxkIGhhdmUgZm91bmQgdHdvIHNpZGVzIGNvbm5lY3RlZCB0byB0aGUgZmxhdCB2ZXJ0ZXgnICk7XHJcblxyXG4gICAgICAgIHJlc3BvbnNlID0gU3RyaW5nVXRpbHMuZmlsbEluKCBhZGphY2VudFNpZGVzSW5MaW5lUGF0dGVyblN0cmluZywge1xyXG4gICAgICAgICAgZmlyc3RTaWRlOiBRdWFkcmlsYXRlcmFsRGVzY3JpYmVyLmdldFNpZGVMYWJlbFN0cmluZyggZmxhdFNpZGVzWyAwIF0uc2lkZUxhYmVsICksXHJcbiAgICAgICAgICBzZWNvbmRTaWRlOiBRdWFkcmlsYXRlcmFsRGVzY3JpYmVyLmdldFNpZGVMYWJlbFN0cmluZyggZmxhdFNpZGVzWyAxIF0uc2lkZUxhYmVsICksXHJcbiAgICAgICAgICBhcmVhQ2hhbmdlOiBhcmVhQ2hhbmdlU3RyaW5nXHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggc2hhcGVOYW1lID09PSBOYW1lZFF1YWRyaWxhdGVyYWwuREFSVCB8fCBzaGFwZU5hbWUgPT09IE5hbWVkUXVhZHJpbGF0ZXJhbC5LSVRFICkge1xyXG4gICAgICByZXNwb25zZSA9IFN0cmluZ1V0aWxzLmZpbGxJbiggYWRqYWNlbnRTaWRlc0NoYW5nZUVxdWFsbHlBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmcsIHtcclxuICAgICAgICBhcmVhQ2hhbmdlOiBhcmVhQ2hhbmdlU3RyaW5nXHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCBzaGFwZU5hbWUgPT09IE5hbWVkUXVhZHJpbGF0ZXJhbC5UUkFQRVpPSUQgKSB7XHJcbiAgICAgIGNvbnN0IHNpZGVBQlNpZGVDRFBhcmFsbGVsID0gcHJldmlvdXNTaGFwZVNuYXBzaG90LnNpZGVBQnNpZGVDRFBhcmFsbGVsO1xyXG5cclxuICAgICAgbGV0IGZpcnN0U2lkZVN0cmluZztcclxuICAgICAgbGV0IHNlY29uZFNpZGVTdHJpbmc7XHJcbiAgICAgIGlmICggc2lkZUFCU2lkZUNEUGFyYWxsZWwgKSB7XHJcbiAgICAgICAgZmlyc3RTaWRlU3RyaW5nID0gYUJTdHJpbmc7XHJcbiAgICAgICAgc2Vjb25kU2lkZVN0cmluZyA9IGNEU3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGZpcnN0U2lkZVN0cmluZyA9IGJDU3RyaW5nO1xyXG4gICAgICAgIHNlY29uZFNpZGVTdHJpbmcgPSBkQVN0cmluZztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIG1haW50YWluaW5nQVRyYXBlem9pZEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZywge1xyXG4gICAgICAgIGZpcnN0U2lkZTogZmlyc3RTaWRlU3RyaW5nLFxyXG4gICAgICAgIHNlY29uZFNpZGU6IHNlY29uZFNpZGVTdHJpbmcsXHJcbiAgICAgICAgYXJlYUNoYW5nZTogYXJlYUNoYW5nZVN0cmluZ1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggc2hhcGVOYW1lID09PSBOYW1lZFF1YWRyaWxhdGVyYWwuSVNPU0NFTEVTX1RSQVBFWk9JRCApIHtcclxuXHJcbiAgICAgIC8vIEZvciBhbiBpc29zY2VsZXMgdHJhcGV6b2lkLCBkZXNjcmliZSB0aGUgc2lkZXMgdGhhdCByZW1haW4gZXF1YWwgaW4gbGVuZ3RoXHJcbiAgICAgIGNvbnN0IHNpZGVBQlNpZGVDRFBhcmFsbGVsID0gcHJldmlvdXNTaGFwZVNuYXBzaG90LnNpZGVBQnNpZGVDRFBhcmFsbGVsO1xyXG5cclxuICAgICAgLy8gRm9yIGFuIGlzb3NjZWxlcyB0cmFwZXpvaWQsIHRoZSBub24tcGFyYWxsZWwgc2lkZXMgYXJlIHRoZSBlcXVhbCBvbmVzIGluIGxlbmd0aCAtIHdlIGNhbiB1c2UgdGhhdCB3aXRob3V0XHJcbiAgICAgIC8vIHNlYXJjaGluZyB0aHJvdWdoIG1vZGVsIFByb3BlcnRpZXNcclxuICAgICAgbGV0IGZpcnN0U2lkZVN0cmluZztcclxuICAgICAgbGV0IHNlY29uZFNpZGVTdHJpbmc7XHJcbiAgICAgIGlmICggc2lkZUFCU2lkZUNEUGFyYWxsZWwgKSB7XHJcbiAgICAgICAgZmlyc3RTaWRlU3RyaW5nID0gYkNTdHJpbmc7XHJcbiAgICAgICAgc2Vjb25kU2lkZVN0cmluZyA9IGRBU3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGZpcnN0U2lkZVN0cmluZyA9IGFCU3RyaW5nO1xyXG4gICAgICAgIHNlY29uZFNpZGVTdHJpbmcgPSBjRFN0cmluZztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIG9wcG9zaXRlU2lkZXNFcXVhbEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZywge1xyXG4gICAgICAgIGZpcnN0U2lkZTogZmlyc3RTaWRlU3RyaW5nLFxyXG4gICAgICAgIHNlY29uZFNpZGU6IHNlY29uZFNpZGVTdHJpbmcsXHJcbiAgICAgICAgYXJlYUNoYW5nZTogYXJlYUNoYW5nZVN0cmluZ1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggc2hhcGVOYW1lID09PSBOYW1lZFF1YWRyaWxhdGVyYWwuUEFSQUxMRUxPR1JBTSApIHtcclxuICAgICAgaWYgKCB0aGlzUmVzcG9uc2VSZWFzb24gPT09ICdhbmdsZScgKSB7XHJcbiAgICAgICAgcmVzcG9uc2UgPSBTdHJpbmdVdGlscy5maWxsSW4oIG1haW50YWluaW5nQVBhcmFsbGVsb2dyYW1BbmdsZVJlc3BvbnNlU3RyaW5nLCB7XHJcbiAgICAgICAgICBhcmVhQ2hhbmdlOiBhcmVhQ2hhbmdlU3RyaW5nXHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3BvbnNlID0gU3RyaW5nVXRpbHMuZmlsbEluKCBtYWludGFpbmluZ0FQYXJhbGxlbG9ncmFtTGVuZ3RoUmVzcG9uc2VQYXR0ZXJuU3RyaW5nLCB7XHJcbiAgICAgICAgICBhcmVhQ2hhbmdlOiBhcmVhQ2hhbmdlU3RyaW5nXHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggc2hhcGVOYW1lID09PSBOYW1lZFF1YWRyaWxhdGVyYWwuUkVDVEFOR0xFICkge1xyXG4gICAgICByZXNwb25zZSA9IFN0cmluZ1V0aWxzLmZpbGxJbiggYWxsUmlnaHRBbmdsZXNBc1NoYXBlQ2hhbmdlc1BhdHRlcm5TdHJpbmcsIHtcclxuICAgICAgICBhcmVhQ2hhbmdlOiBhcmVhQ2hhbmdlU3RyaW5nXHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCBzaGFwZU5hbWUgPT09IE5hbWVkUXVhZHJpbGF0ZXJhbC5SSE9NQlVTICkge1xyXG4gICAgICByZXNwb25zZSA9IG1haW50YWluaW5nQVJob21idXNTdHJpbmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggc2hhcGVOYW1lID09PSBOYW1lZFF1YWRyaWxhdGVyYWwuU1FVQVJFICkge1xyXG4gICAgICByZXNwb25zZSA9IFN0cmluZ1V0aWxzLmZpbGxJbiggYWxsU2lkZXNFcXVhbEFzU2hhcGVDaGFuZ2VzUGF0dGVyblN0cmluZywge1xyXG4gICAgICAgIGFyZWFDaGFuZ2U6IGFyZWFDaGFuZ2VTdHJpbmdcclxuICAgICAgfSApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXNwb25zZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBkZXNjcmlwdGlvbiBhYm91dCB3aGV0aGVyIHRoZSBzaGFwZSBpcyBcInRpbHRpbmdcIiBvciBcInN0cmFpZ2h0ZW5pbmdcIiBiYXNlZCBvbiBob3cgdGhlIGFuZ2xlcyBhdCBlYWNoXHJcbiAgICogdmVydGV4IGNoYW5nZWQgZnJvbSB0aGUgcHJldmlvdXMgc25hcHNob3QuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRUaWx0T3JTdHJhaWdodGVuRGVzY3JpcHRpb24oIHByZXZpb3VzU2hhcGVTbmFwc2hvdDogUXVhZHJpbGF0ZXJhbFNoYXBlU25hcHNob3QgKTogc3RyaW5nIHtcclxuXHJcbiAgICAvLyBhbmdsZSBpcyB0aGUgZG9taW5hbnQgcmVzcG9uc2UgYW5kIGNhdXNlZCB0aGUgY2hhbmdlLCB3ZSBhcmUgZGVzY3JpYmluZyBjaGFuZ2UgaW4gc2lkZSB0aWx0XHJcbiAgICBjb25zdCBjdXJyZW50RGlzdGFuY2VzVG9SaWdodCA9IFtcclxuICAgICAgdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC52ZXJ0ZXhBLmFuZ2xlUHJvcGVydHkudmFsdWUhLFxyXG4gICAgICB0aGlzLnF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLnZlcnRleEIuYW5nbGVQcm9wZXJ0eS52YWx1ZSEsXHJcbiAgICAgIHRoaXMucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwudmVydGV4Qy5hbmdsZVByb3BlcnR5LnZhbHVlISxcclxuICAgICAgdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC52ZXJ0ZXhELmFuZ2xlUHJvcGVydHkudmFsdWUhXHJcbiAgICBdLm1hcCggUXVhZHJpbGF0ZXJhbEFsZXJ0ZXIuZGlzdGFuY2VGcm9tUmlnaHRBbmdsZSApO1xyXG5cclxuICAgIGNvbnN0IHByZXZpb3VzRGlzdGFuY2VzVG9SaWdodCA9IFtcclxuICAgICAgcHJldmlvdXNTaGFwZVNuYXBzaG90LnZlcnRleEFBbmdsZSxcclxuICAgICAgcHJldmlvdXNTaGFwZVNuYXBzaG90LnZlcnRleEJBbmdsZSxcclxuICAgICAgcHJldmlvdXNTaGFwZVNuYXBzaG90LnZlcnRleENBbmdsZSxcclxuICAgICAgcHJldmlvdXNTaGFwZVNuYXBzaG90LnZlcnRleERBbmdsZVxyXG4gICAgXS5tYXAoIFF1YWRyaWxhdGVyYWxBbGVydGVyLmRpc3RhbmNlRnJvbVJpZ2h0QW5nbGUgKTtcclxuXHJcbiAgICBjb25zdCBkaWZmZXJlbmNlcyA9IFtdO1xyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgY3VycmVudERpc3RhbmNlc1RvUmlnaHQubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgIGRpZmZlcmVuY2VzLnB1c2goIGN1cnJlbnREaXN0YW5jZXNUb1JpZ2h0WyBpIF0hIC0gcHJldmlvdXNEaXN0YW5jZXNUb1JpZ2h0WyBpIF0gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGUgZGlzdGFuY2VzIHRvIHBpIGZvciBldmVyeSBhbmdsZSBoYXZlIGdvdHRlbiBzbWFsbGVyLCB3ZSBhcmUgZ2V0dGluZyBjbG9zZXIgdG8gcmlnaHQgYW5nbGVzLCB0aGF0IGlzXHJcbiAgICAvLyBkZXNjcmliZWQgYXMgXCJzdHJhaWdodGVuXCJcclxuICAgIHJldHVybiBfLmV2ZXJ5KCBkaWZmZXJlbmNlcywgZGlmZmVyZW5jZSA9PiBkaWZmZXJlbmNlID4gMCApID8gdGlsdFN0cmluZyA6IHN0cmFpZ2h0ZW5TdHJpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gZGlzdGFuY2UgKGFic29sdXRlIHZhbHVlKSBvZiBhbiBhbmdsZSBhZ2FpbnN0IGEgcmlnaHQgYW5nbGUgKHBpLzIpLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgc3RhdGljIGRpc3RhbmNlRnJvbVJpZ2h0QW5nbGUoIGFuZ2xlOiBudW1iZXIgKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBNYXRoLmFicyggTWF0aC5QSSAvIDIgLSBhbmdsZSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIGRpcmVjdGlvbiBkZXNjcmlwdGlvbiBmb3IgdGhlIGNoYW5nZSBpbiBwb3NpdGlvbiBhcyBhbiBvYmplY3QgbW92ZXMgZnJvbSBwb3NpdGlvbjEgdG8gcG9zaXRpb24yLlxyXG4gICAqIFBvc2l0aW9ucyBpbiBtb2RlbCBjb29yZGluYXRlcy5cclxuICAgKi9cclxuICBwcml2YXRlIHN0YXRpYyBnZXREaXJlY3Rpb25EZXNjcmlwdGlvbiggcHJldmlvdXNQb3NpdGlvbjogVmVjdG9yMiwgY3VycmVudFBvc2l0aW9uOiBWZWN0b3IyLCBtb2RlbFZpZXdUcmFuc2Zvcm06IE1vZGVsVmlld1RyYW5zZm9ybTIgKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHRyYW5zbGF0aW9uVmVjdG9yID0gY3VycmVudFBvc2l0aW9uLm1pbnVzKCBwcmV2aW91c1Bvc2l0aW9uICk7XHJcbiAgICBjb25zdCBtb3ZlbWVudEFuZ2xlID0gdHJhbnNsYXRpb25WZWN0b3IuYW5nbGU7XHJcbiAgICByZXR1cm4gTW92ZW1lbnRBbGVydGVyLmdldERpcmVjdGlvbkRlc2NyaXB0aW9uRnJvbUFuZ2xlKCBtb3ZlbWVudEFuZ2xlLCB7XHJcbiAgICAgIG1vZGVsVmlld1RyYW5zZm9ybTogbW9kZWxWaWV3VHJhbnNmb3JtXHJcbiAgICB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYSByZXNwb25zZSB0aGF0IGRlc2NyaWJlcyBjaGFuZ2VzIHRvIHRoZSBkZXRlY3RlZCBzaGFwZSBuYW1lLiBBcyBkZWNpZGVkIGJ5IGRlc2lnbi9wZWRhZ29neSwgdGhpcyBpcyB0aGUgbW9zdFxyXG4gICAqIGltcG9ydGFudCBpbmZvcm1hdGlvbiB0byBkZXNjcmliZSBhcyB0aGluZ3MgY2hhbmdlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0U2hhcGVOYW1lQ2hhbmdlUmVzcG9uc2UoKTogTnVsbGFibGVRdWFkcmlsYXRlcmFsU3RyaW5nVHlwZSB7XHJcbiAgICBjb25zdCBjdXJyZW50U2hhcGVOYW1lID0gdGhpcy5tb2RlbC5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC5zaGFwZU5hbWVQcm9wZXJ0eS52YWx1ZTtcclxuXHJcbiAgICBsZXQgY29udGV4dFJlc3BvbnNlOiBOdWxsYWJsZVF1YWRyaWxhdGVyYWxTdHJpbmdUeXBlID0gbnVsbDtcclxuICAgIGlmICggY3VycmVudFNoYXBlTmFtZSAhPT0gdGhpcy5wcmV2aW91c0NvbnRleHRSZXNwb25zZVNoYXBlU25hcHNob3QubmFtZWRRdWFkcmlsYXRlcmFsICkge1xyXG4gICAgICBpZiAoIHRoaXMubW9kZWwudmlzaWJpbGl0eU1vZGVsLnNoYXBlTmFtZVZpc2libGVQcm9wZXJ0eS52YWx1ZSApIHtcclxuICAgICAgICBjb250ZXh0UmVzcG9uc2UgPSB0aGlzLmdldEZvdW5kU2hhcGVSZXNwb25zZSggY3VycmVudFNoYXBlTmFtZSApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRleHRSZXNwb25zZSA9IHRoaXMuZGVzY3JpYmVyLmdldFNoYXBlUHJvcGVydGllc0Rlc2NyaXB0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGV4dFJlc3BvbnNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHN0cmluZyBkZXNjcmliaW5nIGEgbmV3bHkgZm91bmQgc2hhcGUuIFJldHVybnMgc29tZXRoaW5nIGxpa2VcclxuICAgKiBcIkZvdW5kIGEgc3F1YXJlLlwiIG9yXHJcbiAgICogXCJGb3VuZCBhbiBpc29zY2VsZXMgdHJhcGV6b2lkLlwiXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRGb3VuZFNoYXBlUmVzcG9uc2UoIG5hbWVkUXVhZHJpbGF0ZXJhbDogTmFtZWRRdWFkcmlsYXRlcmFsICk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gU3RyaW5nVXRpbHMuZmlsbEluKCBmb3VuZFNoYXBlUGF0dGVyblN0cmluZywge1xyXG4gICAgICBzaGFwZU5hbWU6IFF1YWRyaWxhdGVyYWxEZXNjcmliZXIuZ2V0U2hhcGVOYW1lV2l0aEFydGljbGVzRGVzY3JpcHRpb24oIG5hbWVkUXVhZHJpbGF0ZXJhbCApXHJcbiAgICB9ICk7XHJcbiAgfVxyXG59XHJcblxyXG5xdWFkcmlsYXRlcmFsLnJlZ2lzdGVyKCAnUXVhZHJpbGF0ZXJhbEFsZXJ0ZXInLCBRdWFkcmlsYXRlcmFsQWxlcnRlciApO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGFBQWEsTUFBTSx3QkFBd0I7QUFFbEQsT0FBT0MsU0FBUyxNQUFNLDZDQUE2QztBQUNuRSxPQUFPQyxPQUFPLE1BQU0saUVBQWlFO0FBRXJGLFNBQVNDLE9BQU8sUUFBUSxtQ0FBbUM7QUFDM0QsT0FBT0MsY0FBYyxNQUFNLGtEQUFrRDtBQUM3RSxPQUFPQyxvQkFBb0IsTUFBTSwrQkFBK0I7QUFDaEUsT0FBT0MsMEJBQTBCLE1BQU0sd0NBQXdDO0FBQy9FLE9BQU9DLGlCQUFpQixNQUFNLCtCQUErQjtBQUU3RCxPQUFPQyxXQUFXLE1BQU0sK0NBQStDO0FBQ3ZFLE9BQU9DLGVBQWUsTUFBTSx5RUFBeUU7QUFHckcsT0FBT0MsS0FBSyxNQUFNLDZCQUE2QjtBQUMvQyxPQUFPQyxrQkFBa0IsTUFBTSxnQ0FBZ0M7QUFDL0QsT0FBT0Msc0JBQXNCLE1BQTJDLDZCQUE2QjtBQUVyRyxPQUFPQyw0QkFBNEIsTUFBTSxtQ0FBbUM7O0FBRTVFO0FBQ0EsTUFBTUMsdUJBQXVCLEdBQUdULG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsK0JBQStCLENBQUNDLEtBQUs7QUFDdkcsTUFBTUMsUUFBUSxHQUFHZCxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDSyxnQkFBZ0IsQ0FBQ0YsS0FBSztBQUNqRSxNQUFNRyxRQUFRLEdBQUdoQixvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDTyxnQkFBZ0IsQ0FBQ0osS0FBSztBQUNqRSxNQUFNSyxRQUFRLEdBQUdsQixvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDUyxnQkFBZ0IsQ0FBQ04sS0FBSztBQUNqRSxNQUFNTyxRQUFRLEdBQUdwQixvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDVyxnQkFBZ0IsQ0FBQ1IsS0FBSztBQUNqRSxNQUFNUyw4QkFBOEIsR0FBR3RCLG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQ1ksc0NBQXNDLENBQUNWLEtBQUs7QUFDckgsTUFBTVcsb0NBQW9DLEdBQUd4QixvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNjLDRDQUE0QyxDQUFDWixLQUFLO0FBQ2pJLE1BQU1hLDBEQUEwRCxHQUFHMUIsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDZ0Isa0VBQWtFLENBQUNkLEtBQUs7QUFDN0ssTUFBTWUsNENBQTRDLEdBQUc1QixvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNrQixvREFBb0QsQ0FBQ2hCLEtBQUs7QUFDakosTUFBTWlCLDZDQUE2QyxHQUFHOUIsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDb0IscURBQXFELENBQUNsQixLQUFLO0FBQ25KLE1BQU1tQiw0Q0FBNEMsR0FBR2hDLG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQ3NCLG9EQUFvRCxDQUFDcEIsS0FBSztBQUNqSixNQUFNcUIsb0RBQW9ELEdBQUdsQyxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUN3Qiw0REFBNEQsQ0FBQ3RCLEtBQUs7QUFDakssTUFBTXVCLGdEQUFnRCxHQUFHcEMsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDMEIsd0RBQXdELENBQUN4QixLQUFLO0FBQ3pKLE1BQU15Qix5Q0FBeUMsR0FBR3RDLG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQzRCLGlEQUFpRCxDQUFDMUIsS0FBSztBQUMzSSxNQUFNMkIseUJBQXlCLEdBQUd4QyxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUM4QixpQ0FBaUMsQ0FBQzVCLEtBQUs7QUFDM0csTUFBTTZCLHdDQUF3QyxHQUFHMUMsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDZ0MsZ0RBQWdELENBQUM5QixLQUFLO0FBQ3pJLE1BQU0rQixxQ0FBcUMsR0FBRzVDLG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQ2tDLDZDQUE2QyxDQUFDaEMsS0FBSztBQUNuSSxNQUFNaUMscURBQXFELEdBQUc5QyxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNvQyw2REFBNkQsQ0FBQ2xDLEtBQUs7QUFDbkssTUFBTW1DLGtDQUFrQyxHQUFHaEQsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDc0MsMENBQTBDLENBQUNwQyxLQUFLO0FBQzdILE1BQU1xQyx1REFBdUQsR0FBR2xELG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQ3dDLCtEQUErRCxDQUFDdEMsS0FBSztBQUN2SyxNQUFNdUMsVUFBVSxHQUFHcEQsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDMEMsa0JBQWtCLENBQUN4QyxLQUFLO0FBQzdFLE1BQU15QyxnQkFBZ0IsR0FBR3RELG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQzRDLHdCQUF3QixDQUFDMUMsS0FBSztBQUN6RixNQUFNMkMsWUFBWSxHQUFHeEQsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDOEMsb0JBQW9CLENBQUM1QyxLQUFLO0FBQ2pGLE1BQU02QyxhQUFhLEdBQUcxRCxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNnRCxxQkFBcUIsQ0FBQzlDLEtBQUs7QUFDbkYsTUFBTStDLGFBQWEsR0FBRzVELG9CQUFvQixDQUFDNkQscUJBQXFCLENBQUNoRCxLQUFLO0FBQ3RFLE1BQU1pRCxhQUFhLEdBQUc5RCxvQkFBb0IsQ0FBQytELHFCQUFxQixDQUFDbEQsS0FBSztBQUN0RSxNQUFNbUQsYUFBYSxHQUFHaEUsb0JBQW9CLENBQUNpRSxxQkFBcUIsQ0FBQ3BELEtBQUs7QUFDdEUsTUFBTXFELGFBQWEsR0FBR2xFLG9CQUFvQixDQUFDbUUscUJBQXFCLENBQUN0RCxLQUFLO0FBQ3RFLE1BQU11RCxVQUFVLEdBQUdwRSxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUMwRCxrQkFBa0IsQ0FBQ3hELEtBQUs7QUFDN0UsTUFBTXlELFVBQVUsR0FBR3RFLG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQzRELGtCQUFrQixDQUFDMUQsS0FBSztBQUM3RSxNQUFNMkQsaUJBQWlCLEdBQUd4RSxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUM4RCx5QkFBeUIsQ0FBQzVELEtBQUs7QUFDM0YsTUFBTTZELGlCQUFpQixHQUFHMUUsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDZ0UseUJBQXlCLENBQUM5RCxLQUFLO0FBQzNGLE1BQU0rRCwyQkFBMkIsR0FBRzVFLG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQ2tFLG1DQUFtQyxDQUFDaEUsS0FBSztBQUMvRyxNQUFNaUUsYUFBYSxHQUFHOUUsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDb0Usc0JBQXNCLENBQUNDLHFCQUFxQixDQUFDbkUsS0FBSztBQUMxRyxNQUFNb0UsWUFBWSxHQUFHakYsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDb0Usc0JBQXNCLENBQUNHLG9CQUFvQixDQUFDckUsS0FBSztBQUN4RyxNQUFNc0UsV0FBVyxHQUFHbkYsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDeUUsd0JBQXdCLENBQUNDLG1CQUFtQixDQUFDeEUsS0FBSztBQUN4RyxNQUFNeUUsdUJBQXVCLEdBQUd0RixvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUN5RSx3QkFBd0IsQ0FBQ3pCLHFCQUFxQixDQUFDOUMsS0FBSztBQUN0SCxNQUFNMEUscUNBQXFDLEdBQUd2RixvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUN5RSx3QkFBd0IsQ0FBQ0ksNkNBQTZDLENBQUMzRSxLQUFLO0FBQzVKLE1BQU00RSxnQ0FBZ0MsR0FBR3pGLG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQ29FLHNCQUFzQixDQUFDVyx3Q0FBd0MsQ0FBQzdFLEtBQUs7QUFDaEosTUFBTThFLGdCQUFnQixHQUFHM0Ysb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDaUYsd0JBQXdCLENBQUMvRSxLQUFLO0FBQ3pGLE1BQU1nRixlQUFlLEdBQUc3RixvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNtRix1QkFBdUIsQ0FBQ2pGLEtBQUs7QUFDdkYsTUFBTWtGLDRCQUE0QixHQUFHL0Ysb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDcUYsb0NBQW9DLENBQUNuRixLQUFLO0FBQ2pILE1BQU1vRixvQkFBb0IsR0FBR2pHLG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQ3VGLDRCQUE0QixDQUFDckYsS0FBSztBQUNqRyxNQUFNc0YsMEJBQTBCLEdBQUduRyxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUN5RixrQ0FBa0MsQ0FBQ3ZGLEtBQUs7QUFDN0csTUFBTXdGLGdDQUFnQyxHQUFHckcsb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDMkYsd0NBQXdDLENBQUN6RixLQUFLO0FBQ3pILE1BQU0wRiwwQkFBMEIsR0FBR3ZHLG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQzZGLGtDQUFrQyxDQUFDM0YsS0FBSztBQUM3RyxNQUFNNEYsaURBQWlELEdBQUd6RyxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUMrRix5REFBeUQsQ0FBQzdGLEtBQUs7QUFDM0osTUFBTThGLGdDQUFnQyxHQUFHM0csb0JBQW9CLENBQUNVLElBQUksQ0FBQ0MsT0FBTyxDQUFDaUcsd0NBQXdDLENBQUMvRixLQUFLO0FBQ3pILE1BQU1nRyw0QkFBNEIsR0FBRzdHLG9CQUFvQixDQUFDVSxJQUFJLENBQUNDLE9BQU8sQ0FBQ21HLG9DQUFvQyxDQUFDakcsS0FBSztBQUNqSCxNQUFNa0csaUNBQWlDLEdBQUcvRyxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNvRSxzQkFBc0IsQ0FBQ2lDLHlDQUF5QyxDQUFDbkcsS0FBSztBQUNsSixNQUFNb0csd0NBQXdDLEdBQUdqSCxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNvRSxzQkFBc0IsQ0FBQ21DLGdEQUFnRCxDQUFDckcsS0FBSztBQUNoSyxNQUFNc0cscUNBQXFDLEdBQUduSCxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNvRSxzQkFBc0IsQ0FBQ3FDLDZDQUE2QyxDQUFDdkcsS0FBSztBQUMxSixNQUFNd0csMEJBQTBCLEdBQUdySCxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNvRSxzQkFBc0IsQ0FBQ3VDLGtDQUFrQyxDQUFDekcsS0FBSztBQUNwSSxNQUFNMEcsd0JBQXdCLEdBQUd2SCxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNvRSxzQkFBc0IsQ0FBQ3lDLGdDQUFnQyxDQUFDM0csS0FBSztBQUNoSSxNQUFNNEcsMkJBQTJCLEdBQUd6SCxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNvRSxzQkFBc0IsQ0FBQzJDLG1DQUFtQyxDQUFDN0csS0FBSztBQUN0SSxNQUFNOEcsNEJBQTRCLEdBQUczSCxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNvRSxzQkFBc0IsQ0FBQzZDLG9DQUFvQyxDQUFDL0csS0FBSztBQUN4SSxNQUFNZ0gsbUJBQW1CLEdBQUc3SCxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNvRSxzQkFBc0IsQ0FBQytDLDJCQUEyQixDQUFDakgsS0FBSztBQUN0SCxNQUFNa0gscUJBQXFCLEdBQUcvSCxvQkFBb0IsQ0FBQ1UsSUFBSSxDQUFDQyxPQUFPLENBQUNvRSxzQkFBc0IsQ0FBQ2lELDZCQUE2QixDQUFDbkgsS0FBSzs7QUFFMUg7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU1vSCx3QkFBd0IsR0FBR0MsSUFBSSxDQUFDQyxFQUFFLEdBQUcsRUFBRTs7QUFFN0M7QUFDQTtBQUNBLE1BQU1DLGlDQUFpQyxHQUFHRixJQUFJLENBQUNDLEVBQUUsR0FBRyxFQUFFO0FBRXRELGVBQWUsTUFBTUUsb0JBQW9CLFNBQVN4SSxPQUFPLENBQUM7RUFNeEQ7RUFDQTtFQUlBO0VBQ0E7RUFDUXlJLGtCQUFrQixHQUFHLEtBQUs7RUFDMUJDLG1CQUFtQixHQUFHLEtBQUs7O0VBRW5DO0VBQ0E7RUFDQTtFQUlPQyxXQUFXQSxDQUFFQyxLQUF5QixFQUFFQyxVQUFtQyxFQUFFQyxrQkFBdUMsRUFBRUMsU0FBaUMsRUFBRztJQUMvSixLQUFLLENBQUMsQ0FBQztJQUVQLElBQUksQ0FBQ0MsdUJBQXVCLEdBQUdKLEtBQUssQ0FBQ0ksdUJBQXVCO0lBQzVELElBQUksQ0FBQ0osS0FBSyxHQUFHQSxLQUFLO0lBQ2xCLElBQUksQ0FBQ0Usa0JBQWtCLEdBQUdBLGtCQUFrQjtJQUM1QyxJQUFJLENBQUNDLFNBQVMsR0FBR0EsU0FBUztJQUMxQixJQUFJLENBQUNFLG9DQUFvQyxHQUFHLElBQUk3SSwwQkFBMEIsQ0FBRSxJQUFJLENBQUM0SSx1QkFBd0IsQ0FBQztJQUMxRyxJQUFJLENBQUNFLG1DQUFtQyxHQUFHLElBQUk5SSwwQkFBMEIsQ0FBRSxJQUFJLENBQUM0SSx1QkFBd0IsQ0FBQztJQUN6RyxJQUFJLENBQUNHLHVCQUF1QixHQUFHUCxLQUFLLENBQUNJLHVCQUF1QixDQUFDSSwrQkFBK0IsQ0FBQ0MsZ0JBQWdCLENBQUMsQ0FBQztJQUMvRyxJQUFJLENBQUNDLHVCQUF1QixHQUFHVixLQUFLLENBQUNJLHVCQUF1QixDQUFDTywrQkFBK0IsQ0FBQ0YsZ0JBQWdCLENBQUMsQ0FBQzs7SUFFL0c7SUFDQSxNQUFNRyxvQkFBb0IsR0FBRyxJQUFJekosU0FBUyxDQUFFO01BQzFDMEosUUFBUSxFQUFFMUosU0FBUyxDQUFDMko7SUFDdEIsQ0FBRSxDQUFDOztJQUVIO0lBQ0EsTUFBTUMsdUJBQXVCLEdBQUcsSUFBSTVKLFNBQVMsQ0FBRTtNQUM3QzBKLFFBQVEsRUFBRTFKLFNBQVMsQ0FBQzZKO0lBQ3RCLENBQUUsQ0FBQzs7SUFFSDtJQUNBLE1BQU1DLHFCQUFxQixHQUFHLElBQUk5SixTQUFTLENBQUU7TUFDM0MwSixRQUFRLEVBQUUxSixTQUFTLENBQUMrSjtJQUN0QixDQUFFLENBQUM7O0lBRUg7SUFDQWxCLEtBQUssQ0FBQ21CLDBCQUEwQixDQUFDQyxJQUFJLENBQUVDLGtCQUFrQixJQUFJO01BQzNELElBQUksQ0FBQ2hCLG9DQUFvQyxHQUFHLElBQUk3SSwwQkFBMEIsQ0FBRSxJQUFJLENBQUM0SSx1QkFBd0IsQ0FBQztNQUMxRyxJQUFJLENBQUNFLG1DQUFtQyxHQUFHLElBQUk5SSwwQkFBMEIsQ0FBRSxJQUFJLENBQUM0SSx1QkFBd0IsQ0FBQztJQUMzRyxDQUFFLENBQUM7O0lBRUg7SUFDQTtJQUNBO0lBQ0FKLEtBQUssQ0FBQ0ksdUJBQXVCLENBQUNrQixtQkFBbUIsQ0FBQ0MsV0FBVyxDQUFFLE1BQU07TUFFbkU7TUFDQSxJQUFLdkIsS0FBSyxDQUFDbUIsMEJBQTBCLENBQUMvSSxLQUFLLEVBQUc7UUFDNUMsTUFBTW9KLGNBQWMsR0FBRyxJQUFJbEssY0FBYyxDQUFDLENBQUM7O1FBRTNDO1FBQ0E7UUFDQSxJQUFJbUssU0FBUyxHQUFHYixvQkFBb0I7UUFFcEMsTUFBTWMsY0FBYyxHQUFHLElBQUksQ0FBQ3JCLG9DQUFvQyxDQUFDc0IsWUFBWTtRQUM3RSxNQUFNQyxjQUFjLEdBQUcsSUFBSSxDQUFDdkIsb0NBQW9DLENBQUN3QixZQUFZO1FBQzdFLE1BQU1DLGNBQWMsR0FBRyxJQUFJLENBQUN6QixvQ0FBb0MsQ0FBQzBCLFlBQVk7UUFDN0UsTUFBTUMsY0FBYyxHQUFHLElBQUksQ0FBQzNCLG9DQUFvQyxDQUFDNEIsWUFBWTtRQUU3RSxNQUFNQyxnQkFBZ0IsR0FBR1IsY0FBYyxHQUFHLElBQUksQ0FBQ3RCLHVCQUF1QixDQUFDK0IsT0FBTyxDQUFDQyxhQUFhLENBQUNoSyxLQUFNO1FBQ25HLE1BQU1pSyxnQkFBZ0IsR0FBR1QsY0FBYyxHQUFHLElBQUksQ0FBQ3hCLHVCQUF1QixDQUFDa0MsT0FBTyxDQUFDRixhQUFhLENBQUNoSyxLQUFNO1FBQ25HLE1BQU1tSyxnQkFBZ0IsR0FBR1QsY0FBYyxHQUFHLElBQUksQ0FBQzFCLHVCQUF1QixDQUFDb0MsT0FBTyxDQUFDSixhQUFhLENBQUNoSyxLQUFNO1FBQ25HLE1BQU1xSyxnQkFBZ0IsR0FBR1QsY0FBYyxHQUFHLElBQUksQ0FBQzVCLHVCQUF1QixDQUFDc0MsT0FBTyxDQUFDTixhQUFhLENBQUNoSyxLQUFNO1FBQ25HLE1BQU11SyxnQkFBZ0IsR0FBRyxDQUFFVCxnQkFBZ0IsRUFBRUcsZ0JBQWdCLEVBQUVFLGdCQUFnQixFQUFFRSxnQkFBZ0IsQ0FBRTs7UUFFbkc7UUFDQSxJQUFJLENBQUM1QyxrQkFBa0IsR0FBRytDLENBQUMsQ0FBQ0MsSUFBSSxDQUFFRixnQkFBZ0IsRUFBRUcsZUFBZSxJQUFJckQsSUFBSSxDQUFDc0QsR0FBRyxDQUFFRCxlQUFnQixDQUFDLEdBQUd0RCx3QkFBeUIsQ0FBQztRQUUvSCxNQUFNd0QsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDM0Msb0NBQW9DLENBQUM0QyxZQUFZO1FBQy9FLE1BQU1DLGdCQUFnQixHQUFHLElBQUksQ0FBQzdDLG9DQUFvQyxDQUFDOEMsWUFBWTtRQUMvRSxNQUFNQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMvQyxvQ0FBb0MsQ0FBQ2dELFlBQVk7UUFDL0UsTUFBTUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDakQsb0NBQW9DLENBQUNrRCxZQUFZO1FBRS9FLE1BQU1DLGtCQUFrQixHQUFHUixnQkFBZ0IsR0FBRyxJQUFJLENBQUM1Qyx1QkFBdUIsQ0FBQ3FELE1BQU0sQ0FBQ0MsY0FBYyxDQUFDdEwsS0FBSztRQUN0RyxNQUFNdUwsa0JBQWtCLEdBQUdULGdCQUFnQixHQUFHLElBQUksQ0FBQzlDLHVCQUF1QixDQUFDd0QsTUFBTSxDQUFDRixjQUFjLENBQUN0TCxLQUFLO1FBQ3RHLE1BQU15TCxrQkFBa0IsR0FBR1QsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDaEQsdUJBQXVCLENBQUMwRCxNQUFNLENBQUNKLGNBQWMsQ0FBQ3RMLEtBQUs7UUFDdEcsTUFBTTJMLGtCQUFrQixHQUFHVCxnQkFBZ0IsR0FBRyxJQUFJLENBQUNsRCx1QkFBdUIsQ0FBQzRELE1BQU0sQ0FBQ04sY0FBYyxDQUFDdEwsS0FBSztRQUN0RyxNQUFNNkwsaUJBQWlCLEdBQUcsQ0FBRVQsa0JBQWtCLEVBQUVHLGtCQUFrQixFQUFFRSxrQkFBa0IsRUFBRUUsa0JBQWtCLENBQUU7O1FBRTVHO1FBQ0E7UUFDQSxNQUFNRyxxQkFBcUIsR0FBR3RCLENBQUMsQ0FBQ0MsSUFBSSxDQUFFRixnQkFBZ0IsRUFBRUcsZUFBZSxJQUFJQSxlQUFlLEdBQUduRCxpQ0FBa0MsQ0FBQzs7UUFFaEk7UUFDQSxJQUFJLENBQUNHLG1CQUFtQixHQUFHOEMsQ0FBQyxDQUFDQyxJQUFJLENBQUVvQixpQkFBaUIsRUFBRUUsZ0JBQWdCLElBQUkxRSxJQUFJLENBQUNzRCxHQUFHLENBQUVvQixnQkFBaUIsQ0FBQyxHQUFHMU0saUJBQWlCLENBQUMyTSxtQkFBb0IsQ0FBQyxJQUFJLENBQUNGLHFCQUFxQjtRQUUxSyxNQUFNRyx5QkFBeUIsR0FBRyxJQUFJLENBQUNqRSx1QkFBdUIsQ0FBQ0ksK0JBQStCLENBQUNDLGdCQUFnQixDQUFDLENBQUM7UUFDakgsTUFBTTZELHlCQUF5QixHQUFHLElBQUksQ0FBQ2xFLHVCQUF1QixDQUFDTywrQkFBK0IsQ0FBQ0YsZ0JBQWdCLENBQUMsQ0FBQzs7UUFFakg7UUFDQTtRQUNBO1FBQ0EsTUFBTThELHlCQUF5QixHQUFLLENBQUMsSUFBSSxDQUFDaEUsdUJBQXVCLElBQUksQ0FBQyxJQUFJLENBQUNHLHVCQUF1QixLQUFRMkQseUJBQXlCLElBQUlDLHlCQUF5QixDQUFFO1FBQ2xLLElBQUksQ0FBQy9ELHVCQUF1QixHQUFHOEQseUJBQXlCO1FBQ3hELElBQUksQ0FBQzNELHVCQUF1QixHQUFHNEQseUJBQXlCOztRQUV4RDtRQUNBO1FBQ0E7UUFDQSxNQUFNRSx1QkFBdUIsR0FBRyxJQUFJLENBQUNDLDBCQUEwQixDQUFDLENBQUM7UUFDakUsSUFBS0QsdUJBQXVCLEVBQUc7VUFFN0I7VUFDQWhELGNBQWMsQ0FBQ2tELGVBQWUsR0FBR0YsdUJBQXdCO1VBQ3pEL0MsU0FBUyxHQUFHUixxQkFBcUI7UUFDbkMsQ0FBQyxNQUNJLElBQUssSUFBSSxDQUFDcEIsa0JBQWtCLElBQUksSUFBSSxDQUFDQyxtQkFBbUIsSUFBSXlFLHlCQUF5QixFQUFHO1VBRTNGO1VBQ0EsTUFBTUksa0JBQWtCLEdBQUdULHFCQUFxQixHQUFHLE9BQU8sR0FBRyxRQUFRO1VBRXJFLElBQUssSUFBSSxDQUFDN0Qsb0NBQW9DLENBQUN1RSxrQkFBa0IsS0FBSyxJQUFJLENBQUN4RSx1QkFBdUIsQ0FBQ3lFLGlCQUFpQixDQUFDek0sS0FBSyxFQUFHO1lBRTNIO1lBQ0E7WUFDQSxNQUFNME0sd0JBQXdCLEdBQUcsSUFBSSxDQUFDQyxrQ0FBa0MsQ0FBRSxJQUFJLENBQUMzRSx1QkFBdUIsQ0FBQ3lFLGlCQUFpQixDQUFDek0sS0FBSyxFQUFFLElBQUksQ0FBQ2lJLG9DQUFvQyxFQUFFc0Usa0JBQW1CLENBQUM7WUFDL0xuRCxjQUFjLENBQUNrRCxlQUFlLEdBQUdJLHdCQUF3QjtVQUUzRCxDQUFDLE1BQ0k7WUFDSCxNQUFNRSxrQkFBa0IsR0FBRyxJQUFJLENBQUNDLHNCQUFzQixDQUFFLElBQUksQ0FBQzdFLHVCQUF1QixFQUFFLElBQUksQ0FBQ0Msb0NBQW9DLEVBQUVzRSxrQkFBbUIsQ0FBQztZQUNySm5ELGNBQWMsQ0FBQ2tELGVBQWUsR0FBR00sa0JBQW1CO1VBQ3REO1VBRUF2RCxTQUFTLEdBQUdWLHVCQUF1QjtRQUNyQzs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBZixLQUFLLENBQUNJLHVCQUF1QixDQUFDOEUsS0FBSyxDQUFDQyxPQUFPLENBQUVDLElBQUksSUFBSTtVQUNuRCxJQUFLQSxJQUFJLENBQUNDLDBCQUEwQixFQUFHO1lBQ3JDN0QsY0FBYyxDQUFDOEQsY0FBYyxHQUFHLElBQUksQ0FBQ0MsMkJBQTJCLENBQUVILElBQUssQ0FBQztZQUN4RUEsSUFBSSxDQUFDQywwQkFBMEIsR0FBRyxLQUFLO1VBQ3pDO1FBQ0YsQ0FBRSxDQUFDO1FBRUhyRixLQUFLLENBQUNJLHVCQUF1QixDQUFDb0YsUUFBUSxDQUFDTCxPQUFPLENBQUVNLE1BQU0sSUFBSTtVQUN4RCxJQUFLQSxNQUFNLENBQUNKLDBCQUEwQixFQUFHO1lBQ3ZDN0QsY0FBYyxDQUFDOEQsY0FBYyxHQUFHLElBQUksQ0FBQ0ksNkJBQTZCLENBQUVELE1BQU8sQ0FBQztZQUM1RUEsTUFBTSxDQUFDSiwwQkFBMEIsR0FBRyxLQUFLO1VBQzNDO1FBQ0YsQ0FBRSxDQUFDOztRQUVIO1FBQ0E7UUFDQTtRQUNBLElBQUs3RCxjQUFjLENBQUNrRCxlQUFlLElBQUlsRCxjQUFjLENBQUM4RCxjQUFjLEVBQUc7VUFDckU3RCxTQUFTLENBQUNrRSxLQUFLLEdBQUduRSxjQUFjO1VBQ2hDLElBQUksQ0FBQ21FLEtBQUssQ0FBRWxFLFNBQVUsQ0FBQzs7VUFFdkI7VUFDQSxJQUFLRCxjQUFjLENBQUNrRCxlQUFlLEVBQUc7WUFDcEMsSUFBSSxDQUFDckUsb0NBQW9DLEdBQUcsSUFBSTdJLDBCQUEwQixDQUFFLElBQUksQ0FBQzRJLHVCQUF3QixDQUFDO1VBQzVHO1VBQ0EsSUFBS29CLGNBQWMsQ0FBQzhELGNBQWMsRUFBRztZQUNuQyxJQUFJLENBQUNoRixtQ0FBbUMsR0FBRyxJQUFJOUksMEJBQTBCLENBQUUsSUFBSSxDQUFDNEksdUJBQXdCLENBQUM7VUFDM0c7UUFDRjtNQUNGO0lBQ0YsQ0FBRSxDQUFDOztJQUVIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTXdGLG9CQUFvQixHQUFHLElBQUl0TyxjQUFjLENBQUMsQ0FBQztJQUNqRCxNQUFNdU8sZUFBZSxHQUFHLElBQUkxTyxTQUFTLENBQUU7TUFDckN3TyxLQUFLLEVBQUVDLG9CQUFvQjtNQUMzQi9FLFFBQVEsRUFBRTFKLFNBQVMsQ0FBQzJKO0lBQ3RCLENBQUUsQ0FBQztJQUVILE1BQU1nRixvQkFBb0IsR0FBRzlGLEtBQUssQ0FBQytGLHVCQUF1QixDQUFDRCxvQkFBb0I7SUFDL0VBLG9CQUFvQixDQUFDRSxnQ0FBZ0MsQ0FBQzVFLElBQUksQ0FBRTZFLHdCQUF3QixJQUFJO01BQ3RGLElBQUtILG9CQUFvQixDQUFDSSw4QkFBOEIsQ0FBQzlOLEtBQUssRUFBRztRQUMvRHdOLG9CQUFvQixDQUFDbEIsZUFBZSxHQUFHdUIsd0JBQXdCLEdBQUdsSyxpQkFBaUIsR0FBR0UsaUJBQWlCO1FBQ3ZHLElBQUksQ0FBQzBKLEtBQUssQ0FBRUUsZUFBZ0IsQ0FBQztNQUMvQjtJQUNGLENBQUUsQ0FBQztJQUVILE1BQU1NLCtCQUErQixHQUFHQSxDQUFFQyxXQUFtQixFQUFFQyxRQUFpQixLQUFNO01BQ3BGLElBQUtQLG9CQUFvQixDQUFDSSw4QkFBOEIsQ0FBQzlOLEtBQUssRUFBRztRQUMvRCxNQUFNa08sV0FBVyxHQUFHRCxRQUFRLEdBQUcxSyxVQUFVLEdBQUdFLFVBQVU7UUFDdEQrSixvQkFBb0IsQ0FBQ2xCLGVBQWUsR0FBR2hOLFdBQVcsQ0FBQzZPLE1BQU0sQ0FBRXBLLDJCQUEyQixFQUFFO1VBQ3RGcUssS0FBSyxFQUFFSixXQUFXO1VBQ2xCSyxLQUFLLEVBQUVIO1FBQ1QsQ0FBRSxDQUFDO1FBQ0gsSUFBSSxDQUFDWCxLQUFLLENBQUVFLGVBQWdCLENBQUM7TUFDL0I7SUFDRixDQUFDO0lBRURDLG9CQUFvQixDQUFDWSw2QkFBNkIsQ0FBQ3RGLElBQUksQ0FBRWlGLFFBQVEsSUFBSTtNQUFFRiwrQkFBK0IsQ0FBRWhMLGFBQWEsRUFBRWtMLFFBQVMsQ0FBQztJQUFFLENBQUUsQ0FBQztJQUN0SVAsb0JBQW9CLENBQUNhLDZCQUE2QixDQUFDdkYsSUFBSSxDQUFFaUYsUUFBUSxJQUFJO01BQUVGLCtCQUErQixDQUFFOUssYUFBYSxFQUFFZ0wsUUFBUyxDQUFDO0lBQUUsQ0FBRSxDQUFDO0lBQ3RJUCxvQkFBb0IsQ0FBQ2MsNkJBQTZCLENBQUN4RixJQUFJLENBQUVpRixRQUFRLElBQUk7TUFBRUYsK0JBQStCLENBQUU1SyxhQUFhLEVBQUU4SyxRQUFTLENBQUM7SUFBRSxDQUFFLENBQUM7SUFDdElQLG9CQUFvQixDQUFDZSw2QkFBNkIsQ0FBQ3pGLElBQUksQ0FBRWlGLFFBQVEsSUFBSTtNQUFFRiwrQkFBK0IsQ0FBRTFLLGFBQWEsRUFBRTRLLFFBQVMsQ0FBQztJQUFFLENBQUUsQ0FBQzs7SUFFdEk7SUFDQTtJQUNBO0lBQ0FoUCxPQUFPLENBQUN5UCx1QkFBdUIsQ0FBRWxHLG9CQUFvQixFQUFFWCxVQUFXLENBQUM7SUFDbkU1SSxPQUFPLENBQUN5UCx1QkFBdUIsQ0FBRS9GLHVCQUF1QixFQUFFZCxVQUFXLENBQUM7SUFDdEU1SSxPQUFPLENBQUN5UCx1QkFBdUIsQ0FBRTdGLHFCQUFxQixFQUFFaEIsVUFBVyxDQUFDO0lBQ3BFNUksT0FBTyxDQUFDeVAsdUJBQXVCLENBQUVqQixlQUFlLEVBQUU1RixVQUFXLENBQUM7RUFDaEU7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ1VzRiwyQkFBMkJBLENBQUVILElBQXVCLEVBQVc7SUFDckUsSUFBSTJCLFFBQVEsR0FBRyxFQUFFO0lBRWpCLE1BQU1DLGVBQWUsR0FBRyxJQUFJLENBQUNoSCxLQUFLLENBQUNJLHVCQUF1QixDQUFDNkcsNEJBQTRCO0lBQ3ZGLE1BQU1DLFVBQVUsR0FBRyxJQUFJLENBQUNsSCxLQUFLLENBQUNJLHVCQUF1QjtJQUVyRCxNQUFNK0csa0NBQWtDLEdBQUdILGVBQWUsR0FBRyxDQUFDO0lBRTlELE1BQU1JLG9CQUFvQixHQUFHLElBQUk1UCwwQkFBMEIsQ0FBRSxJQUFJLENBQUN3SSxLQUFLLENBQUNJLHVCQUF3QixDQUFDOztJQUVqRztJQUNBLE1BQU1pSCx1QkFBdUIsR0FBRyxJQUFJLENBQUMvRyxtQ0FBbUMsQ0FBQ2dILG1DQUFtQyxDQUFFbEMsSUFBSSxDQUFDbUMsU0FBVSxDQUFDO0lBQzlILE1BQU1DLCtCQUErQixHQUFHSCx1QkFBdUIsQ0FBRSxDQUFDLENBQUU7SUFDcEUsTUFBTUksZ0NBQWdDLEdBQUdKLHVCQUF1QixDQUFFLENBQUMsQ0FBRTtJQUNyRSxNQUFNSywwQkFBMEIsR0FBRzlQLEtBQUssQ0FBQytQLGFBQWEsQ0FBRUgsK0JBQStCLEVBQUVDLGdDQUFnQyxFQUFFVCxlQUFnQixDQUFDO0lBQzVJLE1BQU1ZLDZCQUE2QixHQUFHLElBQUksQ0FBQ3RILG1DQUFtQyxDQUFDdUgscUNBQXFDLENBQUV6QyxJQUFJLENBQUNtQyxTQUFVLENBQUM7SUFDdEksTUFBTU8sY0FBYyxHQUFHLElBQUksQ0FBQ3hILG1DQUFtQyxDQUFDeUgsc0JBQXNCLENBQUUzQyxJQUFJLENBQUNtQyxTQUFVLENBQUM7SUFDeEcsTUFBTVMsNEJBQTRCLEdBQUdkLFVBQVUsQ0FBQ2UseUJBQXlCLENBQUVILGNBQWMsRUFBRU4sK0JBQWdDLENBQUM7SUFDNUgsTUFBTVUsNkJBQTZCLEdBQUdoQixVQUFVLENBQUNlLHlCQUF5QixDQUFFSCxjQUFjLEVBQUVMLGdDQUFpQyxDQUFDO0lBQzlILE1BQU1VLDBCQUEwQixHQUFHSCw0QkFBNEIsS0FBS0UsNkJBQTZCO0lBQ2pHLE1BQU1FLDBCQUEwQixHQUFHLElBQUksQ0FBQzlILG1DQUFtQyxDQUFDK0gsdUJBQXVCLENBQUMsQ0FBQzs7SUFFckc7SUFDQSxNQUFNQyxhQUFhLEdBQUdsQixvQkFBb0IsQ0FBQ0UsbUNBQW1DLENBQUVsQyxJQUFJLENBQUNtQyxTQUFVLENBQUM7SUFDaEcsTUFBTWdCLHVCQUF1QixHQUFHRCxhQUFhLENBQUUsQ0FBQyxDQUFFO0lBQ2xELE1BQU1FLHdCQUF3QixHQUFHRixhQUFhLENBQUUsQ0FBQyxDQUFFO0lBQ25ELE1BQU1HLGtCQUFrQixHQUFHN1EsS0FBSyxDQUFDK1AsYUFBYSxDQUFFWSx1QkFBdUIsRUFBRUMsd0JBQXdCLEVBQUV4QixlQUFnQixDQUFDO0lBQ3BILE1BQU0wQixxQkFBcUIsR0FBR3RCLG9CQUFvQixDQUFDUyxxQ0FBcUMsQ0FBRXpDLElBQUksQ0FBQ21DLFNBQVUsQ0FBQztJQUMxRyxNQUFNb0IsVUFBVSxHQUFHdkIsb0JBQW9CLENBQUNXLHNCQUFzQixDQUFFM0MsSUFBSSxDQUFDbUMsU0FBVSxDQUFDO0lBQ2hGLE1BQU1xQixvQkFBb0IsR0FBRzFCLFVBQVUsQ0FBQ2UseUJBQXlCLENBQUVVLFVBQVUsRUFBRUosdUJBQXdCLENBQUM7SUFDeEcsTUFBTU0scUJBQXFCLEdBQUczQixVQUFVLENBQUNlLHlCQUF5QixDQUFFVSxVQUFVLEVBQUVILHdCQUF5QixDQUFDO0lBQzFHLE1BQU1NLGtCQUFrQixHQUFHRixvQkFBb0IsS0FBS0MscUJBQXFCO0lBQ3pFLE1BQU1FLGtCQUFrQixHQUFHM0Isb0JBQW9CLENBQUNpQix1QkFBdUIsQ0FBQyxDQUFDO0lBRXpFLE1BQU1XLGlDQUFpQyxHQUFHVCx1QkFBdUIsR0FBR2YsK0JBQStCO0lBQ25HLE1BQU15QixrQ0FBa0MsR0FBR1Qsd0JBQXdCLEdBQUdmLGdDQUFnQztJQUV0RyxNQUFNeUIsMkJBQTJCLEdBQUd6SixJQUFJLENBQUNzRCxHQUFHLENBQUVpRyxpQ0FBa0MsQ0FBQztJQUNqRixNQUFNRyw0QkFBNEIsR0FBRzFKLElBQUksQ0FBQ3NELEdBQUcsQ0FBRWtHLGtDQUFtQyxDQUFDOztJQUVuRjtJQUNBLElBQUtSLGtCQUFrQixLQUFRRyxvQkFBb0IsSUFBSSxDQUFDWiw0QkFBNEIsSUFBUWEscUJBQXFCLElBQUksQ0FBQ1gsNkJBQStCLENBQUUsRUFBRztNQUV4SjtNQUNBbkIsUUFBUSxHQUFHbkksMEJBQTBCO0lBQ3ZDLENBQUMsTUFDSSxJQUFLNkosa0JBQWtCLElBQUksQ0FBQ2YsMEJBQTBCLEVBQUc7TUFFNUQ7TUFDQVgsUUFBUSxHQUFHakksd0JBQXdCO0lBQ3JDLENBQUMsTUFDSSxJQUFLNEoscUJBQXFCLElBQUksQ0FBQ2QsNkJBQTZCLEVBQUc7TUFFbEU7TUFDQWIsUUFBUSxHQUFHL0gsMkJBQTJCO0lBQ3hDLENBQUMsTUFDSSxJQUFLOEosa0JBQWtCLElBQUksQ0FBQ1gsMEJBQTBCLEVBQUc7TUFFNUQ7TUFDQXBCLFFBQVEsR0FBRzdILDRCQUE0QjtJQUN6QyxDQUFDLE1BQ0ksSUFBSzZKLGtCQUFrQixLQUFLLENBQUMsSUFBSVgsMEJBQTBCLEdBQUcsQ0FBQyxFQUFHO01BRXJFO01BQ0FyQixRQUFRLEdBQUd6SCxxQkFBcUI7SUFDbEMsQ0FBQyxNQUNJLElBQUt5SixrQkFBa0IsS0FBSyxDQUFDLElBQUlYLDBCQUEwQixHQUFHLENBQUMsRUFBRztNQUVyRTtNQUNBckIsUUFBUSxHQUFHM0gsbUJBQW1CO0lBQ2hDLENBQUMsTUFDSSxJQUFLOEosMkJBQTJCLEdBQUcvQixrQ0FBa0MsSUFBSWdDLDRCQUE0QixHQUFHaEMsa0NBQWtDLEVBQUc7TUFDaEosSUFBSzFILElBQUksQ0FBQzJKLElBQUksQ0FBRUosaUNBQWtDLENBQUMsS0FBS3ZKLElBQUksQ0FBQzJKLElBQUksQ0FBRUgsa0NBQW1DLENBQUMsRUFBRztRQUV4RyxNQUFNSSxtQkFBbUIsR0FBR0wsaUNBQWlDLEdBQUcsQ0FBQztRQUNqRSxNQUFNTSxZQUFZLEdBQUdELG1CQUFtQixHQUFHN00sWUFBWSxHQUFHSCxhQUFhOztRQUV2RTtRQUNBO1FBQ0EsSUFBS3FNLHFCQUFxQixFQUFHO1VBQzNCM0IsUUFBUSxHQUFHclAsV0FBVyxDQUFDNk8sTUFBTSxDQUFFL0gsd0NBQXdDLEVBQUU7WUFDdkUrSyxZQUFZLEVBQUVEO1VBQ2hCLENBQUUsQ0FBQztRQUNMLENBQUMsTUFDSSxJQUFLYixrQkFBa0IsRUFBRztVQUM3QjFCLFFBQVEsR0FBR3JQLFdBQVcsQ0FBQzZPLE1BQU0sQ0FBRTdILHFDQUFxQyxFQUFFO1lBQ3BFNkssWUFBWSxFQUFFRDtVQUNoQixDQUFFLENBQUM7UUFDTCxDQUFDLE1BQ0k7VUFDSHZDLFFBQVEsR0FBR3JQLFdBQVcsQ0FBQzZPLE1BQU0sQ0FBRXZKLGdDQUFnQyxFQUFFO1lBQy9EdU0sWUFBWSxFQUFFRDtVQUNoQixDQUFFLENBQUM7UUFDTDtNQUNGLENBQUMsTUFDSTtRQUVIO1FBQ0F2QyxRQUFRLEdBQUd6SSxpQ0FBaUM7TUFDOUM7SUFDRixDQUFDLE1BQ0k7TUFFSDtNQUNBLE1BQU1rTCxzQkFBc0IsR0FBR3BFLElBQUksQ0FBQ3FFLE9BQU8sQ0FBQ0MsZ0JBQWdCLENBQUN0UixLQUFLO01BQ2xFLE1BQU11Uix1QkFBdUIsR0FBRyxJQUFJLENBQUNySixtQ0FBbUMsQ0FBQ3NKLCtCQUErQixDQUFFeEUsSUFBSSxDQUFDbUMsU0FBVSxDQUFDLENBQUUsQ0FBQyxDQUFFO01BQy9IUixRQUFRLEdBQUduSCxvQkFBb0IsQ0FBQ2lLLHVCQUF1QixDQUFFRix1QkFBdUIsRUFBRUgsc0JBQXNCLEVBQUUsSUFBSSxDQUFDdEosa0JBQW1CLENBQUM7SUFDckk7SUFFQSxPQUFPNkcsUUFBUTtFQUNqQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNVckIsNkJBQTZCQSxDQUFFRCxNQUEyQixFQUFXO0lBQzNFLElBQUlzQixRQUFROztJQUVaO0lBQ0E7SUFDQSxJQUFJK0MsZ0JBQStCLEdBQUcsSUFBSTs7SUFFMUM7SUFDQTtJQUNBLElBQUlDLGFBQTRCLEdBQUcsSUFBSTtJQUV2QyxNQUFNN0MsVUFBVSxHQUFHLElBQUksQ0FBQzlHLHVCQUF1QjtJQUMvQyxNQUFNNEosZUFBZSxHQUFHLElBQUksQ0FBQzdKLFNBQVMsQ0FBQzhKLDBCQUEwQixDQUFFeEUsTUFBTSxDQUFDeUUsV0FBWSxDQUFDO0lBRXZGLE1BQU1DLFlBQVksR0FBRzFFLE1BQU0sQ0FBQ3JELGFBQWEsQ0FBQ2hLLEtBQU07SUFDaEQsTUFBTWdTLGFBQWEsR0FBRyxJQUFJLENBQUM5SixtQ0FBbUMsQ0FBQytKLHVCQUF1QixDQUFFNUUsTUFBTSxDQUFDeUUsV0FBWSxDQUFDO0lBRTVHLE1BQU1JLGNBQWMsR0FBR3BELFVBQVUsQ0FBQ3FELGlCQUFpQixDQUFDQyxHQUFHLENBQUUvRSxNQUFPLENBQUU7SUFDbEUsTUFBTWdGLG1CQUFtQixHQUFHSCxjQUFjLENBQUNsSSxhQUFhLENBQUNoSyxLQUFNO0lBRS9ELE1BQU1zUyxnQkFBZ0IsR0FBR3hELFVBQVUsQ0FBQ3lELGlCQUFpQixDQUFDSCxHQUFHLENBQUUvRSxNQUFPLENBQUU7SUFDcEUsTUFBTW1GLG1CQUFtQixHQUFHRixnQkFBZ0IsQ0FBRSxDQUFDLENBQUU7SUFDakQsTUFBTUcsa0JBQWtCLEdBQUdELG1CQUFtQixDQUFDeEksYUFBYSxDQUFDaEssS0FBTTtJQUNuRSxNQUFNMFMsb0JBQW9CLEdBQUdKLGdCQUFnQixDQUFFLENBQUMsQ0FBRTtJQUNsRCxNQUFNSyxtQkFBbUIsR0FBR0Qsb0JBQW9CLENBQUMxSSxhQUFhLENBQUNoSyxLQUFNOztJQUVyRTtJQUNBLE1BQU00Uyx5QkFBeUIsR0FBRzlELFVBQVUsQ0FBQytELHdCQUF3QixDQUFFZCxZQUFZLEVBQUVVLGtCQUFtQixDQUFDO0lBQ3pHLE1BQU1LLDBCQUEwQixHQUFHaEUsVUFBVSxDQUFDK0Qsd0JBQXdCLENBQUVkLFlBQVksRUFBRVksbUJBQW9CLENBQUM7SUFDM0csTUFBTUksb0JBQW9CLEdBQUdqRSxVQUFVLENBQUMrRCx3QkFBd0IsQ0FBRWQsWUFBWSxFQUFFTSxtQkFBb0IsQ0FBQzs7SUFFckc7SUFDQTtJQUNBLElBQUtMLGFBQWEsS0FBS0QsWUFBWSxFQUFHO01BRXBDO01BQ0E7TUFDQSxNQUFNaUIsZUFBZSxHQUFHM0YsTUFBTSxDQUFDaUUsZ0JBQWdCLENBQUN0UixLQUFLO01BQ3JELE1BQU1pVCxnQkFBZ0IsR0FBRyxJQUFJLENBQUMvSyxtQ0FBbUMsQ0FBQ2dMLDBCQUEwQixDQUFFN0YsTUFBTSxDQUFDeUUsV0FBWSxDQUFDO01BQ2xISixnQkFBZ0IsR0FBR2xLLG9CQUFvQixDQUFDaUssdUJBQXVCLENBQUV3QixnQkFBZ0IsRUFBRUQsZUFBZSxFQUFFLElBQUksQ0FBQ2xMLGtCQUFtQixDQUFDO0lBQy9ILENBQUMsTUFDSSxJQUFLZ0gsVUFBVSxDQUFDcUUsWUFBWSxDQUFFcEIsWUFBYSxDQUFDLEVBQUc7TUFDbERMLGdCQUFnQixHQUFHNU0sZ0JBQWdCO0lBQ3JDLENBQUMsTUFDSSxJQUFLZ0ssVUFBVSxDQUFDc0UsV0FBVyxDQUFFckIsWUFBYSxDQUFDLEVBQUc7TUFDakRMLGdCQUFnQixHQUFHMU0sZUFBZTtJQUNwQyxDQUFDLE1BQ0ksSUFBSyxDQUFDNE4seUJBQXlCLElBQUksQ0FBQ0UsMEJBQTBCLElBQUksQ0FBQ0Msb0JBQW9CLEVBQUc7TUFFN0Y7TUFDQTtNQUNBLE1BQU1NLGlCQUFpQixHQUFHdEIsWUFBWSxHQUFHQyxhQUFhLEdBQUcxTixXQUFXLEdBQUdHLHVCQUF1QjtNQUM5RmlOLGdCQUFnQixHQUFHcFMsV0FBVyxDQUFDNk8sTUFBTSxDQUFFekoscUNBQXFDLEVBQUU7UUFDNUU0TyxXQUFXLEVBQUVEO01BQ2YsQ0FBRSxDQUFDO0lBQ0w7SUFFQSxNQUFNRSxTQUFTLEdBQUd6RSxVQUFVLENBQUNyQyxpQkFBaUIsQ0FBQ3pNLEtBQUs7O0lBRXBEO0lBQ0E7SUFDQTtJQUNBLElBQUtnUyxhQUFhLEtBQUtELFlBQVksRUFBRztNQUNwQyxJQUFLakQsVUFBVSxDQUFDMEUsb0JBQW9CLENBQUMsQ0FBQyxFQUFHO1FBRXZDO1FBQ0E3QixhQUFhLEdBQUcvTCxpREFBaUQ7TUFDbkUsQ0FBQyxNQUNJLElBQUtnTix5QkFBeUIsSUFBSUUsMEJBQTBCLEVBQUc7UUFFbEU7UUFDQW5CLGFBQWEsR0FBRzNMLDRCQUE0QjtNQUM5QyxDQUFDLE1BQ0ksSUFBSzRNLHlCQUF5QixJQUFJRyxvQkFBb0IsSUFBSUQsMEJBQTBCLEVBQUc7UUFFMUY7UUFDQTtRQUNBLE1BQU1XLFdBQVcsR0FBR2IseUJBQXlCLEdBQUdKLG1CQUFtQixHQUMvQ08sb0JBQW9CLEdBQUdiLGNBQWMsR0FDckNRLG9CQUFvQjs7UUFFeEM7UUFDQSxNQUFNZ0Isc0JBQXNCLEdBQUdYLG9CQUFvQixHQUFHM04sb0JBQW9CLEdBQzNDekYsNEJBQTRCLENBQUNnVSx1QkFBdUIsQ0FBQ3ZCLEdBQUcsQ0FBRXFCLFdBQVcsQ0FBQzNCLFdBQVksQ0FBQztRQUVsSCxNQUFNOEIscUJBQXFCLEdBQUdoQyxlQUFlLENBQUNpQyw2QkFBNkIsQ0FBRUosV0FBVyxFQUFFRixTQUFVLENBQUM7UUFDckc1QixhQUFhLEdBQUdyUyxXQUFXLENBQUM2TyxNQUFNLENBQUVqSiw0QkFBNEIsRUFBRTtVQUNoRTRPLFVBQVUsRUFBRUYscUJBQXFCO1VBQ2pDRyxXQUFXLEVBQUVMO1FBQ2YsQ0FBRSxDQUFDO01BQ0wsQ0FBQyxNQUNJLElBQUssSUFBSSxDQUFDTSxtQ0FBbUMsQ0FBRWpDLFlBQVksRUFBRU0sbUJBQW9CLENBQUMsRUFBRztRQUV4RjtRQUNBLE1BQU11QixxQkFBcUIsR0FBR2hDLGVBQWUsQ0FBQ2lDLDZCQUE2QixDQUFFM0IsY0FBYyxFQUFFcUIsU0FBVSxDQUFDO1FBQ3hHNUIsYUFBYSxHQUFHclMsV0FBVyxDQUFDNk8sTUFBTSxDQUFFakosNEJBQTRCLEVBQUU7VUFDaEU0TyxVQUFVLEVBQUVGLHFCQUFxQjtVQUNqQ0csV0FBVyxFQUFFM087UUFDZixDQUFFLENBQUM7TUFDTCxDQUFDLE1BQ0ksSUFBSzBKLFVBQVUsQ0FBQytELHdCQUF3QixDQUFFSixrQkFBa0IsRUFBRUUsbUJBQW9CLENBQUMsRUFBRztRQUV6RjtRQUNBLElBQUs3RCxVQUFVLENBQUNxRSxZQUFZLENBQUVWLGtCQUFtQixDQUFDLEVBQUc7VUFDbkRkLGFBQWEsR0FBR25NLGdDQUFnQztRQUNsRCxDQUFDLE1BQ0k7VUFDSG1NLGFBQWEsR0FBR3JNLDBCQUEwQjtRQUM1QztNQUNGLENBQUMsTUFDSSxJQUFLLElBQUksQ0FBQzBPLG1DQUFtQyxDQUFFakMsWUFBWSxFQUFFVSxrQkFBbUIsQ0FBQyxFQUFHO1FBRXZGO1FBQ0EsTUFBTW1CLHFCQUFxQixHQUFHaEMsZUFBZSxDQUFDaUMsNkJBQTZCLENBQUVyQixtQkFBbUIsRUFBRWUsU0FBVSxDQUFDO1FBQzdHNUIsYUFBYSxHQUFHclMsV0FBVyxDQUFDNk8sTUFBTSxDQUFFakosNEJBQTRCLEVBQUU7VUFDaEU0TyxVQUFVLEVBQUVGLHFCQUFxQjtVQUNqQ0csV0FBVyxFQUFFcFUsNEJBQTRCLENBQUNnVSx1QkFBdUIsQ0FBQ3ZCLEdBQUcsQ0FBRUksbUJBQW1CLENBQUNWLFdBQVk7UUFDekcsQ0FBRSxDQUFDO01BQ0wsQ0FBQyxNQUNJLElBQUssSUFBSSxDQUFDa0MsbUNBQW1DLENBQUVqQyxZQUFZLEVBQUVZLG1CQUFvQixDQUFDLEVBQUc7UUFFeEY7UUFDQSxNQUFNaUIscUJBQXFCLEdBQUdoQyxlQUFlLENBQUNpQyw2QkFBNkIsQ0FBRW5CLG9CQUFvQixFQUFFYSxTQUFVLENBQUM7UUFDOUc1QixhQUFhLEdBQUdyUyxXQUFXLENBQUM2TyxNQUFNLENBQUVqSiw0QkFBNEIsRUFBRTtVQUNoRTRPLFVBQVUsRUFBRUYscUJBQXFCO1VBQ2pDRyxXQUFXLEVBQUVwVSw0QkFBNEIsQ0FBQ2dVLHVCQUF1QixDQUFDdkIsR0FBRyxDQUFFTSxvQkFBb0IsQ0FBQ1osV0FBWTtRQUMxRyxDQUFFLENBQUM7TUFDTDtJQUNGO0lBRUFtQyxNQUFNLElBQUlBLE1BQU0sQ0FBRXZDLGdCQUFnQixJQUFJQyxhQUFhLEVBQUUscUVBQXNFLENBQUM7SUFDNUgsSUFBS0QsZ0JBQWdCLElBQUlDLGFBQWEsRUFBRztNQUV2Q2hELFFBQVEsR0FBR3JQLFdBQVcsQ0FBQzZPLE1BQU0sQ0FBRXpJLDBCQUEwQixFQUFFO1FBQ3pEd08sUUFBUSxFQUFFeEMsZ0JBQWdCO1FBQzFCckQsS0FBSyxFQUFFc0Q7TUFDVCxDQUFFLENBQUM7SUFDTCxDQUFDLE1BQ0ksSUFBS0EsYUFBYSxFQUFHO01BQ3hCaEQsUUFBUSxHQUFHZ0QsYUFBYTtJQUMxQixDQUFDLE1BQ0k7TUFDSGhELFFBQVEsR0FBRytDLGdCQUFnQjtJQUM3QjtJQUVBLE9BQU8vQyxRQUFRO0VBQ2pCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDVXFGLG1DQUFtQ0EsQ0FBRUcsbUJBQTJCLEVBQUVDLGdCQUF3QixFQUFZO0lBQzVHLE9BQU96VSw0QkFBNEIsQ0FBQzBVLHFCQUFxQixDQUFFRixtQkFBbUIsRUFBRUMsZ0JBQWlCLENBQUMsSUFDM0Z6VSw0QkFBNEIsQ0FBQzJVLHNCQUFzQixDQUFFSCxtQkFBbUIsRUFBRUMsZ0JBQWlCLENBQUMsSUFDNUYsSUFBSSxDQUFDcE0sdUJBQXVCLENBQUM2Syx3QkFBd0IsQ0FBRXNCLG1CQUFtQixFQUFFQyxnQkFBaUIsQ0FBQztFQUN2Rzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNVdkgsc0JBQXNCQSxDQUFFaUMsVUFBbUMsRUFBRXlGLHFCQUFpRCxFQUFFQyxjQUE4QixFQUFrQjtJQUN0SyxJQUFJN0YsUUFBdUIsR0FBRyxJQUFJO0lBRWxDLE1BQU04RixjQUFjLEdBQUczRixVQUFVLENBQUM0RixZQUFZLENBQUMxVSxLQUFLLEdBQUd1VSxxQkFBcUIsQ0FBQ0ksSUFBSTtJQUNqRixNQUFNQyxnQkFBZ0IsR0FBR0gsY0FBYyxHQUFHLENBQUMsR0FBRzlSLFlBQVksR0FBR0UsYUFBYTtJQUUxRSxJQUFLaU0sVUFBVSxDQUFDK0YsZUFBZSxDQUFDLENBQUMsSUFBSU4scUJBQXFCLENBQUNNLGVBQWUsRUFBRztNQUUzRTtNQUNBLElBQUtMLGNBQWMsS0FBSyxPQUFPLEVBQUc7UUFFaEM7UUFDQSxNQUFNTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUNDLDhCQUE4QixDQUFFUixxQkFBc0IsQ0FBQztRQUNyRjVGLFFBQVEsR0FBR3JQLFdBQVcsQ0FBQzZPLE1BQU0sQ0FBRTFOLDhCQUE4QixFQUFFO1VBQzdEdVUsVUFBVSxFQUFFRjtRQUNkLENBQUUsQ0FBQztNQUNMLENBQUMsTUFDSSxJQUFLTixjQUFjLEtBQUssUUFBUSxFQUFHO1FBRXRDO1FBQ0EsTUFBTVMsYUFBYSxHQUFHdFUsb0NBQW9DO1FBQzFEZ08sUUFBUSxHQUFHclAsV0FBVyxDQUFDNk8sTUFBTSxDQUFFOEcsYUFBYSxFQUFFO1VBQzVDQyxVQUFVLEVBQUVOO1FBQ2QsQ0FBRSxDQUFDO01BQ0w7SUFDRixDQUFDLE1BQ0k7TUFFSCxNQUFNTywwQkFBMEIsR0FBR1oscUJBQXFCLENBQUNhLG9CQUFvQjtNQUM3RSxNQUFNQywwQkFBMEIsR0FBR2QscUJBQXFCLENBQUNlLG9CQUFvQjtNQUU3RSxNQUFNckoseUJBQXlCLEdBQUc2QyxVQUFVLENBQUMxRywrQkFBK0IsQ0FBQ0MsZ0JBQWdCLENBQUMsQ0FBQztNQUMvRixNQUFNNkQseUJBQXlCLEdBQUc0QyxVQUFVLENBQUN2RywrQkFBK0IsQ0FBQ0YsZ0JBQWdCLENBQUMsQ0FBQzs7TUFFL0Y7TUFDQSxNQUFNa04sb0JBQW9CLEdBQUd0Six5QkFBeUIsS0FBS0MseUJBQXlCO01BQ3BGLE1BQU1zSixxQkFBcUIsR0FBRyxDQUFDTCwwQkFBMEIsSUFBSSxDQUFDRSwwQkFBMEI7TUFDeEYsTUFBTUksb0JBQW9CLEdBQUcsQ0FBQ3hKLHlCQUF5QixJQUFJLENBQUNDLHlCQUF5QjtNQUNyRixNQUFNd0osd0JBQXdCLEdBQUdQLDBCQUEwQixJQUFJRSwwQkFBMEI7O01BRXpGO01BQ0EsSUFBSU0sZUFBZTtNQUNuQixJQUFJQyxnQkFBZ0I7TUFDcEIsSUFBSzNKLHlCQUF5QixFQUFHO1FBQy9CMEosZUFBZSxHQUFHMVYsUUFBUTtRQUMxQjJWLGdCQUFnQixHQUFHdlYsUUFBUTtNQUM3QixDQUFDLE1BQ0k7UUFDSHNWLGVBQWUsR0FBR3hWLFFBQVE7UUFDMUJ5VixnQkFBZ0IsR0FBR3JWLFFBQVE7TUFDN0I7TUFFQSxJQUFLaVYscUJBQXFCLElBQUlELG9CQUFvQixFQUFHO1FBQ25ELE1BQU1OLGFBQWEsR0FBR3BVLDBEQUEwRDtRQUVoRjhOLFFBQVEsR0FBR3JQLFdBQVcsQ0FBQzZPLE1BQU0sQ0FBRThHLGFBQWEsRUFBRTtVQUM1Q1ksU0FBUyxFQUFFRixlQUFlO1VBQzFCRyxVQUFVLEVBQUVGO1FBQ2QsQ0FBRSxDQUFDO01BQ0wsQ0FBQyxNQUNJLElBQUtMLG9CQUFvQixFQUFHO1FBRS9CO1FBQ0EsTUFBTU4sYUFBYSxHQUFHbFUsNENBQTRDO1FBQ2xFNE4sUUFBUSxHQUFHclAsV0FBVyxDQUFDNk8sTUFBTSxDQUFFOEcsYUFBYSxFQUFFO1VBQzVDWSxTQUFTLEVBQUVGLGVBQWU7VUFDMUJHLFVBQVUsRUFBRUYsZ0JBQWdCO1VBQzVCVixVQUFVLEVBQUVOO1FBQ2QsQ0FBRSxDQUFDO01BQ0wsQ0FBQyxNQUNJLElBQUtjLHdCQUF3QixJQUFJRCxvQkFBb0IsRUFBRztRQUUzRDtRQUNBOUcsUUFBUSxHQUFHeE0sa0NBQWtDO01BQy9DLENBQUMsTUFDSSxJQUFLcVQscUJBQXFCLElBQUlDLG9CQUFvQixFQUFHO1FBRXhEO1FBQ0EsTUFBTVIsYUFBYSxHQUFHNVMsdURBQXVEO1FBQzdFc00sUUFBUSxHQUFHclAsV0FBVyxDQUFDNk8sTUFBTSxDQUFFOEcsYUFBYSxFQUFFO1VBQzVDQyxVQUFVLEVBQUVOO1FBQ2QsQ0FBRSxDQUFDO01BQ0w7SUFDRjtJQUVBLE9BQU9qRyxRQUFRO0VBQ2pCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ1VoQyxrQ0FBa0NBLENBQUU0RyxTQUE2QixFQUFFZ0IscUJBQWlELEVBQUVoSSxrQkFBa0MsRUFBa0I7SUFDaEwsSUFBSW9DLFFBQXVCLEdBQUcsSUFBSTtJQUVsQyxNQUFNOEYsY0FBYyxHQUFHLElBQUksQ0FBQ3pNLHVCQUF1QixDQUFDME0sWUFBWSxDQUFDMVUsS0FBSyxHQUFHdVUscUJBQXFCLENBQUNJLElBQUk7SUFDbkcsTUFBTUMsZ0JBQWdCLEdBQUdILGNBQWMsR0FBRyxDQUFDLEdBQUc5UixZQUFZLEdBQUdFLGFBQWE7SUFFMUUsSUFBSzBRLFNBQVMsS0FBSzlULGtCQUFrQixDQUFDc1csb0JBQW9CLElBQUl4QyxTQUFTLEtBQUs5VCxrQkFBa0IsQ0FBQ3VXLHFCQUFxQixFQUFHO01BQ3JIckgsUUFBUSxHQUFHclAsV0FBVyxDQUFDNk8sTUFBTSxDQUFFOUwsdURBQXVELEVBQUU7UUFDdEY2UyxVQUFVLEVBQUVOO01BQ2QsQ0FBRSxDQUFDO0lBQ0wsQ0FBQyxNQUNJLElBQUtyQixTQUFTLEtBQUs5VCxrQkFBa0IsQ0FBQ3dXLFFBQVEsRUFBRztNQUNwRCxNQUFNQyxVQUFVLEdBQUcxTCxDQUFDLENBQUMyTCxJQUFJLENBQ3ZCLElBQUksQ0FBQ25PLHVCQUF1QixDQUFDb0YsUUFBUSxFQUNyQ0MsTUFBTSxJQUFJLElBQUksQ0FBQ3JGLHVCQUF1QixDQUFDb08seUJBQXlCLENBQUUvSSxNQUFNLENBQUNyRCxhQUFhLENBQUNoSyxLQUFLLEVBQUdxSCxJQUFJLENBQUNDLEVBQUcsQ0FDekcsQ0FBQzs7TUFFRDtNQUNBO01BQ0EsSUFBS21OLGNBQWMsR0FBRyxJQUFJLEVBQUc7UUFFM0I7UUFDQTtRQUNBOUYsUUFBUSxHQUFHclAsV0FBVyxDQUFDNk8sTUFBTSxDQUFFcE0scUNBQXFDLEVBQUU7VUFDcEVnUyxXQUFXLEVBQUVwVSw0QkFBNEIsQ0FBQ2dVLHVCQUF1QixDQUFDdkIsR0FBRyxDQUFFOEQsVUFBVSxDQUFFcEUsV0FBWTtRQUNqRyxDQUFFLENBQUM7TUFDTCxDQUFDLE1BQ0k7UUFFSDtRQUNBOztRQUVBO1FBQ0EsTUFBTXVFLFNBQVMsR0FBRzdMLENBQUMsQ0FBQzhMLE1BQU0sQ0FBRSxJQUFJLENBQUN0Tyx1QkFBdUIsQ0FBQzhFLEtBQUssRUFBRUUsSUFBSSxJQUFJQSxJQUFJLENBQUNxRSxPQUFPLEtBQUs2RSxVQUFVLElBQUlsSixJQUFJLENBQUN1SixPQUFPLEtBQUtMLFVBQVcsQ0FBQztRQUNwSWpDLE1BQU0sSUFBSUEsTUFBTSxDQUFFb0MsU0FBUyxDQUFDRyxNQUFNLEtBQUssQ0FBQyxFQUFFLDZEQUE4RCxDQUFDO1FBRXpHN0gsUUFBUSxHQUFHclAsV0FBVyxDQUFDNk8sTUFBTSxDQUFFckksZ0NBQWdDLEVBQUU7VUFDL0QrUCxTQUFTLEVBQUVuVyxzQkFBc0IsQ0FBQytXLGtCQUFrQixDQUFFSixTQUFTLENBQUUsQ0FBQyxDQUFFLENBQUNsSCxTQUFVLENBQUM7VUFDaEYyRyxVQUFVLEVBQUVwVyxzQkFBc0IsQ0FBQytXLGtCQUFrQixDQUFFSixTQUFTLENBQUUsQ0FBQyxDQUFFLENBQUNsSCxTQUFVLENBQUM7VUFDakYrRixVQUFVLEVBQUVOO1FBQ2QsQ0FBRSxDQUFDO01BQ0w7SUFDRixDQUFDLE1BQ0ksSUFBS3JCLFNBQVMsS0FBSzlULGtCQUFrQixDQUFDaVgsSUFBSSxJQUFJbkQsU0FBUyxLQUFLOVQsa0JBQWtCLENBQUNrWCxJQUFJLEVBQUc7TUFDekZoSSxRQUFRLEdBQUdyUCxXQUFXLENBQUM2TyxNQUFNLENBQUVsTSxxREFBcUQsRUFBRTtRQUNwRmlULFVBQVUsRUFBRU47TUFDZCxDQUFFLENBQUM7SUFDTCxDQUFDLE1BQ0ksSUFBS3JCLFNBQVMsS0FBSzlULGtCQUFrQixDQUFDbVgsU0FBUyxFQUFHO01BQ3JELE1BQU1DLG9CQUFvQixHQUFHdEMscUJBQXFCLENBQUNhLG9CQUFvQjtNQUV2RSxJQUFJTyxlQUFlO01BQ25CLElBQUlDLGdCQUFnQjtNQUNwQixJQUFLaUIsb0JBQW9CLEVBQUc7UUFDMUJsQixlQUFlLEdBQUcxVixRQUFRO1FBQzFCMlYsZ0JBQWdCLEdBQUd2VixRQUFRO01BQzdCLENBQUMsTUFDSTtRQUNIc1YsZUFBZSxHQUFHeFYsUUFBUTtRQUMxQnlWLGdCQUFnQixHQUFHclYsUUFBUTtNQUM3QjtNQUVBb08sUUFBUSxHQUFHclAsV0FBVyxDQUFDNk8sTUFBTSxDQUFFNU0sZ0RBQWdELEVBQUU7UUFDL0VzVSxTQUFTLEVBQUVGLGVBQWU7UUFDMUJHLFVBQVUsRUFBRUYsZ0JBQWdCO1FBQzVCVixVQUFVLEVBQUVOO01BQ2QsQ0FBRSxDQUFDO0lBQ0wsQ0FBQyxNQUNJLElBQUtyQixTQUFTLEtBQUs5VCxrQkFBa0IsQ0FBQ3FYLG1CQUFtQixFQUFHO01BRS9EO01BQ0EsTUFBTUQsb0JBQW9CLEdBQUd0QyxxQkFBcUIsQ0FBQ2Esb0JBQW9COztNQUV2RTtNQUNBO01BQ0EsSUFBSU8sZUFBZTtNQUNuQixJQUFJQyxnQkFBZ0I7TUFDcEIsSUFBS2lCLG9CQUFvQixFQUFHO1FBQzFCbEIsZUFBZSxHQUFHeFYsUUFBUTtRQUMxQnlWLGdCQUFnQixHQUFHclYsUUFBUTtNQUM3QixDQUFDLE1BQ0k7UUFDSG9WLGVBQWUsR0FBRzFWLFFBQVE7UUFDMUIyVixnQkFBZ0IsR0FBR3ZWLFFBQVE7TUFDN0I7TUFFQXNPLFFBQVEsR0FBR3JQLFdBQVcsQ0FBQzZPLE1BQU0sQ0FBRWxOLDZDQUE2QyxFQUFFO1FBQzVFNFUsU0FBUyxFQUFFRixlQUFlO1FBQzFCRyxVQUFVLEVBQUVGLGdCQUFnQjtRQUM1QlYsVUFBVSxFQUFFTjtNQUNkLENBQUUsQ0FBQztJQUNMLENBQUMsTUFDSSxJQUFLckIsU0FBUyxLQUFLOVQsa0JBQWtCLENBQUNzWCxhQUFhLEVBQUc7TUFDekQsSUFBS3hLLGtCQUFrQixLQUFLLE9BQU8sRUFBRztRQUNwQ29DLFFBQVEsR0FBR3JQLFdBQVcsQ0FBQzZPLE1BQU0sQ0FBRWhOLDRDQUE0QyxFQUFFO1VBQzNFK1QsVUFBVSxFQUFFTjtRQUNkLENBQUUsQ0FBQztNQUNMLENBQUMsTUFDSTtRQUNIakcsUUFBUSxHQUFHclAsV0FBVyxDQUFDNk8sTUFBTSxDQUFFOU0sb0RBQW9ELEVBQUU7VUFDbkY2VCxVQUFVLEVBQUVOO1FBQ2QsQ0FBRSxDQUFDO01BQ0w7SUFDRixDQUFDLE1BQ0ksSUFBS3JCLFNBQVMsS0FBSzlULGtCQUFrQixDQUFDdVgsU0FBUyxFQUFHO01BQ3JEckksUUFBUSxHQUFHclAsV0FBVyxDQUFDNk8sTUFBTSxDQUFFMU0seUNBQXlDLEVBQUU7UUFDeEV5VCxVQUFVLEVBQUVOO01BQ2QsQ0FBRSxDQUFDO0lBQ0wsQ0FBQyxNQUNJLElBQUtyQixTQUFTLEtBQUs5VCxrQkFBa0IsQ0FBQ3dYLE9BQU8sRUFBRztNQUNuRHRJLFFBQVEsR0FBR2hOLHlCQUF5QjtJQUN0QyxDQUFDLE1BQ0ksSUFBSzRSLFNBQVMsS0FBSzlULGtCQUFrQixDQUFDeVgsTUFBTSxFQUFHO01BQ2xEdkksUUFBUSxHQUFHclAsV0FBVyxDQUFDNk8sTUFBTSxDQUFFdE0sd0NBQXdDLEVBQUU7UUFDdkVxVCxVQUFVLEVBQUVOO01BQ2QsQ0FBRSxDQUFDO0lBQ0w7SUFFQSxPQUFPakcsUUFBUTtFQUNqQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNVb0csOEJBQThCQSxDQUFFUixxQkFBaUQsRUFBVztJQUVsRztJQUNBLE1BQU00Qyx1QkFBdUIsR0FBRyxDQUM5QixJQUFJLENBQUNuUCx1QkFBdUIsQ0FBQytCLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDaEssS0FBSyxFQUN4RCxJQUFJLENBQUNnSSx1QkFBdUIsQ0FBQ2tDLE9BQU8sQ0FBQ0YsYUFBYSxDQUFDaEssS0FBSyxFQUN4RCxJQUFJLENBQUNnSSx1QkFBdUIsQ0FBQ29DLE9BQU8sQ0FBQ0osYUFBYSxDQUFDaEssS0FBSyxFQUN4RCxJQUFJLENBQUNnSSx1QkFBdUIsQ0FBQ3NDLE9BQU8sQ0FBQ04sYUFBYSxDQUFDaEssS0FBSyxDQUN6RCxDQUFDb1gsR0FBRyxDQUFFNVAsb0JBQW9CLENBQUM2UCxzQkFBdUIsQ0FBQztJQUVwRCxNQUFNQyx3QkFBd0IsR0FBRyxDQUMvQi9DLHFCQUFxQixDQUFDaEwsWUFBWSxFQUNsQ2dMLHFCQUFxQixDQUFDOUssWUFBWSxFQUNsQzhLLHFCQUFxQixDQUFDNUssWUFBWSxFQUNsQzRLLHFCQUFxQixDQUFDMUssWUFBWSxDQUNuQyxDQUFDdU4sR0FBRyxDQUFFNVAsb0JBQW9CLENBQUM2UCxzQkFBdUIsQ0FBQztJQUVwRCxNQUFNRSxXQUFXLEdBQUcsRUFBRTtJQUN0QixLQUFNLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0wsdUJBQXVCLENBQUNYLE1BQU0sRUFBRWdCLENBQUMsRUFBRSxFQUFHO01BQ3pERCxXQUFXLENBQUNFLElBQUksQ0FBRU4sdUJBQXVCLENBQUVLLENBQUMsQ0FBRSxHQUFJRix3QkFBd0IsQ0FBRUUsQ0FBQyxDQUFHLENBQUM7SUFDbkY7O0lBRUE7SUFDQTtJQUNBLE9BQU9oTixDQUFDLENBQUNrTixLQUFLLENBQUVILFdBQVcsRUFBRUksVUFBVSxJQUFJQSxVQUFVLEdBQUcsQ0FBRSxDQUFDLEdBQUdwVixVQUFVLEdBQUdFLGdCQUFnQjtFQUM3Rjs7RUFFQTtBQUNGO0FBQ0E7RUFDRSxPQUFlNFUsc0JBQXNCQSxDQUFFTyxLQUFhLEVBQVc7SUFDN0QsT0FBT3ZRLElBQUksQ0FBQ3NELEdBQUcsQ0FBRXRELElBQUksQ0FBQ0MsRUFBRSxHQUFHLENBQUMsR0FBR3NRLEtBQU0sQ0FBQztFQUN4Qzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFLE9BQWVuRyx1QkFBdUJBLENBQUV3QixnQkFBeUIsRUFBRUQsZUFBd0IsRUFBRWxMLGtCQUF1QyxFQUFXO0lBQzdJLE1BQU0rUCxpQkFBaUIsR0FBRzdFLGVBQWUsQ0FBQzhFLEtBQUssQ0FBRTdFLGdCQUFpQixDQUFDO0lBQ25FLE1BQU04RSxhQUFhLEdBQUdGLGlCQUFpQixDQUFDRCxLQUFLO0lBQzdDLE9BQU9yWSxlQUFlLENBQUN5WSxnQ0FBZ0MsQ0FBRUQsYUFBYSxFQUFFO01BQ3RFalEsa0JBQWtCLEVBQUVBO0lBQ3RCLENBQUUsQ0FBQztFQUNMOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ1V1RSwwQkFBMEJBLENBQUEsRUFBb0M7SUFDcEUsTUFBTTRMLGdCQUFnQixHQUFHLElBQUksQ0FBQ3JRLEtBQUssQ0FBQ0ksdUJBQXVCLENBQUN5RSxpQkFBaUIsQ0FBQ3pNLEtBQUs7SUFFbkYsSUFBSXNNLGVBQWdELEdBQUcsSUFBSTtJQUMzRCxJQUFLMkwsZ0JBQWdCLEtBQUssSUFBSSxDQUFDaFEsb0NBQW9DLENBQUN1RSxrQkFBa0IsRUFBRztNQUN2RixJQUFLLElBQUksQ0FBQzVFLEtBQUssQ0FBQ3NRLGVBQWUsQ0FBQ0Msd0JBQXdCLENBQUNuWSxLQUFLLEVBQUc7UUFDL0RzTSxlQUFlLEdBQUcsSUFBSSxDQUFDOEwscUJBQXFCLENBQUVILGdCQUFpQixDQUFDO01BQ2xFLENBQUMsTUFDSTtRQUNIM0wsZUFBZSxHQUFHLElBQUksQ0FBQ3ZFLFNBQVMsQ0FBQ3NRLDZCQUE2QixDQUFDLENBQUM7TUFDbEU7SUFDRjtJQUVBLE9BQU8vTCxlQUFlO0VBQ3hCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDVThMLHFCQUFxQkEsQ0FBRTVMLGtCQUFzQyxFQUFXO0lBQzlFLE9BQU9sTixXQUFXLENBQUM2TyxNQUFNLENBQUV2Tyx1QkFBdUIsRUFBRTtNQUNsRDJULFNBQVMsRUFBRTdULHNCQUFzQixDQUFDNFksbUNBQW1DLENBQUU5TCxrQkFBbUI7SUFDNUYsQ0FBRSxDQUFDO0VBQ0w7QUFDRjtBQUVBMU4sYUFBYSxDQUFDeVosUUFBUSxDQUFFLHNCQUFzQixFQUFFL1Esb0JBQXFCLENBQUMifQ==