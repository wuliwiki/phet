// Copyright 2023, University of Colorado Boulder

/**
 * A general class that updates the sim from tangible device input. In that way it "controls" the simulation model.
 *
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import Vector2 from '../../../../../dot/js/Vector2.js';
import quadrilateral from '../../../quadrilateral.js';
import QuadrilateralUtils from '../../model/QuadrilateralUtils.js';
import LinearFunction from '../../../../../dot/js/LinearFunction.js';
import QuadrilateralConstants from '../../../QuadrilateralConstants.js';
export default class QuadrilateralTangibleController {
  constructor(quadrilateralModel) {
    this.quadrilateralModel = quadrilateralModel;
    this.shapeModel = this.quadrilateralModel.quadrilateralShapeModel;
    this.tangibleConnectionModel = this.quadrilateralModel.tangibleConnectionModel;
  }

  /**
   * Sets the quadrilateral shape QuadrilateralVertex positions to good initial values after calibration.
   *
   * During calibration, we request the largest shape that can possibly be made from the device. So when
   * calibration is finished, the tangible is as large as it can be and QuadrilateralVertex positions are positioned
   * based on full width of the device.
   */
  finishCalibration() {
    const physicalModelBounds = this.tangibleConnectionModel.physicalModelBoundsProperty.value;
    assert && assert(physicalModelBounds && physicalModelBounds.isValid(), 'Physical dimensions of device need to be set during calibration');
    this.setPositionsFromLengthAndAngleData(physicalModelBounds.width, physicalModelBounds.width, physicalModelBounds.width, Math.PI / 2, Math.PI / 2);
  }

  /**
   * Set positions of the Vertices from length and angle data. We get the angles at each vertex and lengths
   * of each side from the hardware. We need to convert that to vertex positions in model space.
   *
   * With angle and length data alone we do not know the orientation or position in space of the shape. So the
   * shape is constructed with the top left vertex (vertexA) and top side (sideAB) anchored  while the rest
   * of the vertices are relatively positioned from the angle and length data. Once the shape is constructed it is
   * translated so that the centroid of the shape is in the center of model space (0, 0). The final result is that only
   * the tilt of the top side remains anchored. Perhaps if a gyroscope is added in the future we may be able to rotate
   * the shape correctly without anchoring the top side.
   */
  setPositionsFromLengthAndAngleData(topLength, rightLength, leftLength, leftTopAngle, rightTopAngle) {
    // only try to set to sim if values look reasonable - we want to handle this gracefully, the sim shouldn't crash
    // if data isn't right
    const allDataGood = _.every([topLength, rightLength, leftLength, leftTopAngle, rightTopAngle], value => {
      return !isNaN(value) && value >= 0 && value !== null;
    });
    if (!allDataGood) {
      return;
    }
    const tangibleConnectionModel = this.tangibleConnectionModel;

    // you must calibrate before setting positions from a physical device
    if (tangibleConnectionModel.physicalModelBoundsProperty.value !== null && !tangibleConnectionModel.isCalibratingProperty.value) {
      // the physical device lengths can only become half as long as the largest length, so map to the sim model
      // with that constraint as well so that the smallest shape on the physical device doesn't bring vertices
      // all the way to the center of the screen (0, 0).
      const deviceLengthToSimLength = new LinearFunction(0, tangibleConnectionModel.physicalModelBoundsProperty.value.width, 0, QuadrilateralConstants.BOUNDS_WIDTH / 3);
      const mappedTopLength = deviceLengthToSimLength.evaluate(topLength);
      const mappedRightLength = deviceLengthToSimLength.evaluate(rightLength);
      const mappedLeftLength = deviceLengthToSimLength.evaluate(leftLength);
      this.setPositionsFromLengthsAndAngles(mappedTopLength, mappedRightLength, mappedLeftLength, leftTopAngle, rightTopAngle);
    }
  }

  /**
   * Set positions from the length and angle data provided. Useful when working with a tangible device that is
   * providing length and angle data. When reconstructing the shape we start by making the top side parallel
   * with the top of model bounds. The remaining vertices are positioned accordingly. Finally, if there is some
   * rotation to apply (from the experimental marker input), that rotation is applied.
   *
   * @param topLength
   * @param rightLength
   * @param leftLength
   * @param p1Angle - the left top angle (vertexA)
   * @param p2Angle - the right top angle (vertexB)
   */
  setPositionsFromLengthsAndAngles(topLength, rightLength, leftLength, p1Angle, p2Angle) {
    const shapeModel = this.shapeModel;

    // vertexA and the topLine are anchored, the rest of the shape is relative to this
    const vector1Position = new Vector2(QuadrilateralConstants.MODEL_BOUNDS.minX, QuadrilateralConstants.MODEL_BOUNDS.maxX);
    const vector2Position = new Vector2(vector1Position.x + topLength, vector1Position.y);
    const vector4Offset = new Vector2(Math.cos(-p1Angle), Math.sin(-p1Angle)).timesScalar(leftLength);
    const vector4Position = vector1Position.plus(vector4Offset);
    const vector3Offset = new Vector2(Math.cos(Math.PI + p2Angle), Math.sin(Math.PI + p2Angle)).timesScalar(rightLength);
    const vector3Position = vector2Position.plus(vector3Offset);

    // make sure that the proposed positions are within bounds defined in the simulation model
    const proposedPositions = [vector1Position, vector2Position, vector3Position, vector4Position];

    // we have the vertex positions to recreate the shape, but shift them so that the centroid of the quadrilateral is
    // in the center of the model space
    const centroidPosition = QuadrilateralUtils.getCentroidFromPositions(proposedPositions);
    const centroidOffset = centroidPosition.negated();
    const shiftedPositions = _.map(proposedPositions, shapePosition => shapePosition.plus(centroidOffset));

    // make sure that all positions are within model bounds
    const constrainedPositions = _.map(shiftedPositions, position => QuadrilateralConstants.MODEL_BOUNDS.closestPointTo(position));

    // smooth positions to try to reduce noise
    const smoothedPositions = [shapeModel.vertexA.smoothPosition(constrainedPositions[0]), shapeModel.vertexB.smoothPosition(constrainedPositions[1]), shapeModel.vertexC.smoothPosition(constrainedPositions[2]), shapeModel.vertexD.smoothPosition(constrainedPositions[3])];

    // Constrain to intervals of deviceGridSpacingProperty.value to try to reduce noise
    const constrainedGridPositions = _.map(smoothedPositions, smoothedPosition => this.quadrilateralModel.getClosestGridPosition(smoothedPosition));
    const vertexLabelMap = new Map([[shapeModel.vertexA.vertexLabel, constrainedGridPositions[0]], [shapeModel.vertexB.vertexLabel, constrainedGridPositions[1]], [shapeModel.vertexC.vertexLabel, constrainedGridPositions[2]], [shapeModel.vertexD.vertexLabel, constrainedGridPositions[3]]]);
    this.shapeModel.setVertexPositions(vertexLabelMap);
  }

  /**
   * Set the positions of vertices directly from a tangible device. A connection to a physical device might use this
   * function to set the positions in model space. If it doesn't have absolute positioning it may need to use
   * setPositionsFromLengthAndAngleData instead.
   *
   * Currently this is being used by the OpenCV prototype and a prototype using MediaPipe.
   */
  setPositionsFromAbsolutePositionData(labelToProposedPositionMap) {
    const tangibleConnectionModel = this.tangibleConnectionModel;

    // you must calibrate before setting positions from a physical device
    if (tangibleConnectionModel.physicalToModelTransform !== null && !tangibleConnectionModel.isCalibratingProperty.value) {
      // scale the physical positions to the simulation virtual model
      const labelToConstrainedPositionMap = new Map();
      labelToProposedPositionMap.forEach((proposedPosition, labelKey) => {
        const vertex = this.shapeModel.getLabelledVertex(labelKey);
        let constrainedPosition;

        // only try to set a new position if values look reasonable - we want to handle this gracefully, the sim
        // shouldn't crash if data isn't right
        if (proposedPosition && proposedPosition.isFinite()) {
          // transform from tangible to virtual coordinates
          const virtualPosition = tangibleConnectionModel.physicalToModelTransform.modelToViewPosition(proposedPosition);

          // apply smoothing over a number of values to reduce noise
          constrainedPosition = vertex.smoothPosition(virtualPosition);

          // constrain within model bounds
          constrainedPosition = QuadrilateralConstants.MODEL_BOUNDS.closestPointTo(constrainedPosition);
        } else {
          // If the value is not reasonable, just fall back to the current position
          constrainedPosition = vertex.positionProperty.value;
        }

        // align with model grid positions
        constrainedPosition = this.quadrilateralModel.getClosestGridPosition(constrainedPosition);
        labelToConstrainedPositionMap.set(labelKey, constrainedPosition);
      });

      // Only set to the model if the shape is allowed and reasonable (no overlaps, no intersections)
      if (tangibleConnectionModel.isShapeAllowedForTangible(labelToConstrainedPositionMap)) {
        this.shapeModel.setVertexPositions(labelToConstrainedPositionMap);
      }
    }
  }
}
quadrilateral.register('QuadrilateralTangibleController', QuadrilateralTangibleController);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwicXVhZHJpbGF0ZXJhbCIsIlF1YWRyaWxhdGVyYWxVdGlscyIsIkxpbmVhckZ1bmN0aW9uIiwiUXVhZHJpbGF0ZXJhbENvbnN0YW50cyIsIlF1YWRyaWxhdGVyYWxUYW5naWJsZUNvbnRyb2xsZXIiLCJjb25zdHJ1Y3RvciIsInF1YWRyaWxhdGVyYWxNb2RlbCIsInNoYXBlTW9kZWwiLCJxdWFkcmlsYXRlcmFsU2hhcGVNb2RlbCIsInRhbmdpYmxlQ29ubmVjdGlvbk1vZGVsIiwiZmluaXNoQ2FsaWJyYXRpb24iLCJwaHlzaWNhbE1vZGVsQm91bmRzIiwicGh5c2ljYWxNb2RlbEJvdW5kc1Byb3BlcnR5IiwidmFsdWUiLCJhc3NlcnQiLCJpc1ZhbGlkIiwic2V0UG9zaXRpb25zRnJvbUxlbmd0aEFuZEFuZ2xlRGF0YSIsIndpZHRoIiwiTWF0aCIsIlBJIiwidG9wTGVuZ3RoIiwicmlnaHRMZW5ndGgiLCJsZWZ0TGVuZ3RoIiwibGVmdFRvcEFuZ2xlIiwicmlnaHRUb3BBbmdsZSIsImFsbERhdGFHb29kIiwiXyIsImV2ZXJ5IiwiaXNOYU4iLCJpc0NhbGlicmF0aW5nUHJvcGVydHkiLCJkZXZpY2VMZW5ndGhUb1NpbUxlbmd0aCIsIkJPVU5EU19XSURUSCIsIm1hcHBlZFRvcExlbmd0aCIsImV2YWx1YXRlIiwibWFwcGVkUmlnaHRMZW5ndGgiLCJtYXBwZWRMZWZ0TGVuZ3RoIiwic2V0UG9zaXRpb25zRnJvbUxlbmd0aHNBbmRBbmdsZXMiLCJwMUFuZ2xlIiwicDJBbmdsZSIsInZlY3RvcjFQb3NpdGlvbiIsIk1PREVMX0JPVU5EUyIsIm1pblgiLCJtYXhYIiwidmVjdG9yMlBvc2l0aW9uIiwieCIsInkiLCJ2ZWN0b3I0T2Zmc2V0IiwiY29zIiwic2luIiwidGltZXNTY2FsYXIiLCJ2ZWN0b3I0UG9zaXRpb24iLCJwbHVzIiwidmVjdG9yM09mZnNldCIsInZlY3RvcjNQb3NpdGlvbiIsInByb3Bvc2VkUG9zaXRpb25zIiwiY2VudHJvaWRQb3NpdGlvbiIsImdldENlbnRyb2lkRnJvbVBvc2l0aW9ucyIsImNlbnRyb2lkT2Zmc2V0IiwibmVnYXRlZCIsInNoaWZ0ZWRQb3NpdGlvbnMiLCJtYXAiLCJzaGFwZVBvc2l0aW9uIiwiY29uc3RyYWluZWRQb3NpdGlvbnMiLCJwb3NpdGlvbiIsImNsb3Nlc3RQb2ludFRvIiwic21vb3RoZWRQb3NpdGlvbnMiLCJ2ZXJ0ZXhBIiwic21vb3RoUG9zaXRpb24iLCJ2ZXJ0ZXhCIiwidmVydGV4QyIsInZlcnRleEQiLCJjb25zdHJhaW5lZEdyaWRQb3NpdGlvbnMiLCJzbW9vdGhlZFBvc2l0aW9uIiwiZ2V0Q2xvc2VzdEdyaWRQb3NpdGlvbiIsInZlcnRleExhYmVsTWFwIiwiTWFwIiwidmVydGV4TGFiZWwiLCJzZXRWZXJ0ZXhQb3NpdGlvbnMiLCJzZXRQb3NpdGlvbnNGcm9tQWJzb2x1dGVQb3NpdGlvbkRhdGEiLCJsYWJlbFRvUHJvcG9zZWRQb3NpdGlvbk1hcCIsInBoeXNpY2FsVG9Nb2RlbFRyYW5zZm9ybSIsImxhYmVsVG9Db25zdHJhaW5lZFBvc2l0aW9uTWFwIiwiZm9yRWFjaCIsInByb3Bvc2VkUG9zaXRpb24iLCJsYWJlbEtleSIsInZlcnRleCIsImdldExhYmVsbGVkVmVydGV4IiwiY29uc3RyYWluZWRQb3NpdGlvbiIsImlzRmluaXRlIiwidmlydHVhbFBvc2l0aW9uIiwibW9kZWxUb1ZpZXdQb3NpdGlvbiIsInBvc2l0aW9uUHJvcGVydHkiLCJzZXQiLCJpc1NoYXBlQWxsb3dlZEZvclRhbmdpYmxlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJRdWFkcmlsYXRlcmFsVGFuZ2libGVDb250cm9sbGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBBIGdlbmVyYWwgY2xhc3MgdGhhdCB1cGRhdGVzIHRoZSBzaW0gZnJvbSB0YW5naWJsZSBkZXZpY2UgaW5wdXQuIEluIHRoYXQgd2F5IGl0IFwiY29udHJvbHNcIiB0aGUgc2ltdWxhdGlvbiBtb2RlbC5cclxuICpcclxuICogQGF1dGhvciBKZXNzZSBHcmVlbmJlcmcgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgcXVhZHJpbGF0ZXJhbCBmcm9tICcuLi8uLi8uLi9xdWFkcmlsYXRlcmFsLmpzJztcclxuaW1wb3J0IFF1YWRyaWxhdGVyYWxNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9RdWFkcmlsYXRlcmFsTW9kZWwuanMnO1xyXG5pbXBvcnQgUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwsIHsgVmVydGV4TGFiZWxUb1Byb3Bvc2VkUG9zaXRpb25NYXAgfSBmcm9tICcuLi8uLi9tb2RlbC9RdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsVXRpbHMgZnJvbSAnLi4vLi4vbW9kZWwvUXVhZHJpbGF0ZXJhbFV0aWxzLmpzJztcclxuaW1wb3J0IFRhbmdpYmxlQ29ubmVjdGlvbk1vZGVsIGZyb20gJy4uLy4uL21vZGVsL3Byb3RvdHlwZS9UYW5naWJsZUNvbm5lY3Rpb25Nb2RlbC5qcyc7XHJcbmltcG9ydCBMaW5lYXJGdW5jdGlvbiBmcm9tICcuLi8uLi8uLi8uLi8uLi9kb3QvanMvTGluZWFyRnVuY3Rpb24uanMnO1xyXG5pbXBvcnQgUXVhZHJpbGF0ZXJhbENvbnN0YW50cyBmcm9tICcuLi8uLi8uLi9RdWFkcmlsYXRlcmFsQ29uc3RhbnRzLmpzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YWRyaWxhdGVyYWxUYW5naWJsZUNvbnRyb2xsZXIge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgcXVhZHJpbGF0ZXJhbE1vZGVsOiBRdWFkcmlsYXRlcmFsTW9kZWw7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgc2hhcGVNb2RlbDogUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWw7XHJcbiAgcHJpdmF0ZSByZWFkb25seSB0YW5naWJsZUNvbm5lY3Rpb25Nb2RlbDogVGFuZ2libGVDb25uZWN0aW9uTW9kZWw7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggcXVhZHJpbGF0ZXJhbE1vZGVsOiBRdWFkcmlsYXRlcmFsTW9kZWwgKSB7XHJcbiAgICB0aGlzLnF1YWRyaWxhdGVyYWxNb2RlbCA9IHF1YWRyaWxhdGVyYWxNb2RlbDtcclxuXHJcbiAgICB0aGlzLnNoYXBlTW9kZWwgPSB0aGlzLnF1YWRyaWxhdGVyYWxNb2RlbC5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbDtcclxuICAgIHRoaXMudGFuZ2libGVDb25uZWN0aW9uTW9kZWwgPSB0aGlzLnF1YWRyaWxhdGVyYWxNb2RlbC50YW5naWJsZUNvbm5lY3Rpb25Nb2RlbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHF1YWRyaWxhdGVyYWwgc2hhcGUgUXVhZHJpbGF0ZXJhbFZlcnRleCBwb3NpdGlvbnMgdG8gZ29vZCBpbml0aWFsIHZhbHVlcyBhZnRlciBjYWxpYnJhdGlvbi5cclxuICAgKlxyXG4gICAqIER1cmluZyBjYWxpYnJhdGlvbiwgd2UgcmVxdWVzdCB0aGUgbGFyZ2VzdCBzaGFwZSB0aGF0IGNhbiBwb3NzaWJseSBiZSBtYWRlIGZyb20gdGhlIGRldmljZS4gU28gd2hlblxyXG4gICAqIGNhbGlicmF0aW9uIGlzIGZpbmlzaGVkLCB0aGUgdGFuZ2libGUgaXMgYXMgbGFyZ2UgYXMgaXQgY2FuIGJlIGFuZCBRdWFkcmlsYXRlcmFsVmVydGV4IHBvc2l0aW9ucyBhcmUgcG9zaXRpb25lZFxyXG4gICAqIGJhc2VkIG9uIGZ1bGwgd2lkdGggb2YgdGhlIGRldmljZS5cclxuICAgKi9cclxuICBwdWJsaWMgZmluaXNoQ2FsaWJyYXRpb24oKTogdm9pZCB7XHJcbiAgICBjb25zdCBwaHlzaWNhbE1vZGVsQm91bmRzID0gdGhpcy50YW5naWJsZUNvbm5lY3Rpb25Nb2RlbC5waHlzaWNhbE1vZGVsQm91bmRzUHJvcGVydHkudmFsdWUhO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggcGh5c2ljYWxNb2RlbEJvdW5kcyAmJiBwaHlzaWNhbE1vZGVsQm91bmRzLmlzVmFsaWQoKSxcclxuICAgICAgJ1BoeXNpY2FsIGRpbWVuc2lvbnMgb2YgZGV2aWNlIG5lZWQgdG8gYmUgc2V0IGR1cmluZyBjYWxpYnJhdGlvbicgKTtcclxuXHJcbiAgICB0aGlzLnNldFBvc2l0aW9uc0Zyb21MZW5ndGhBbmRBbmdsZURhdGEoXHJcbiAgICAgIHBoeXNpY2FsTW9kZWxCb3VuZHMud2lkdGgsXHJcbiAgICAgIHBoeXNpY2FsTW9kZWxCb3VuZHMud2lkdGgsXHJcbiAgICAgIHBoeXNpY2FsTW9kZWxCb3VuZHMud2lkdGgsXHJcbiAgICAgIE1hdGguUEkgLyAyLFxyXG4gICAgICBNYXRoLlBJIC8gMlxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBwb3NpdGlvbnMgb2YgdGhlIFZlcnRpY2VzIGZyb20gbGVuZ3RoIGFuZCBhbmdsZSBkYXRhLiBXZSBnZXQgdGhlIGFuZ2xlcyBhdCBlYWNoIHZlcnRleCBhbmQgbGVuZ3Roc1xyXG4gICAqIG9mIGVhY2ggc2lkZSBmcm9tIHRoZSBoYXJkd2FyZS4gV2UgbmVlZCB0byBjb252ZXJ0IHRoYXQgdG8gdmVydGV4IHBvc2l0aW9ucyBpbiBtb2RlbCBzcGFjZS5cclxuICAgKlxyXG4gICAqIFdpdGggYW5nbGUgYW5kIGxlbmd0aCBkYXRhIGFsb25lIHdlIGRvIG5vdCBrbm93IHRoZSBvcmllbnRhdGlvbiBvciBwb3NpdGlvbiBpbiBzcGFjZSBvZiB0aGUgc2hhcGUuIFNvIHRoZVxyXG4gICAqIHNoYXBlIGlzIGNvbnN0cnVjdGVkIHdpdGggdGhlIHRvcCBsZWZ0IHZlcnRleCAodmVydGV4QSkgYW5kIHRvcCBzaWRlIChzaWRlQUIpIGFuY2hvcmVkICB3aGlsZSB0aGUgcmVzdFxyXG4gICAqIG9mIHRoZSB2ZXJ0aWNlcyBhcmUgcmVsYXRpdmVseSBwb3NpdGlvbmVkIGZyb20gdGhlIGFuZ2xlIGFuZCBsZW5ndGggZGF0YS4gT25jZSB0aGUgc2hhcGUgaXMgY29uc3RydWN0ZWQgaXQgaXNcclxuICAgKiB0cmFuc2xhdGVkIHNvIHRoYXQgdGhlIGNlbnRyb2lkIG9mIHRoZSBzaGFwZSBpcyBpbiB0aGUgY2VudGVyIG9mIG1vZGVsIHNwYWNlICgwLCAwKS4gVGhlIGZpbmFsIHJlc3VsdCBpcyB0aGF0IG9ubHlcclxuICAgKiB0aGUgdGlsdCBvZiB0aGUgdG9wIHNpZGUgcmVtYWlucyBhbmNob3JlZC4gUGVyaGFwcyBpZiBhIGd5cm9zY29wZSBpcyBhZGRlZCBpbiB0aGUgZnV0dXJlIHdlIG1heSBiZSBhYmxlIHRvIHJvdGF0ZVxyXG4gICAqIHRoZSBzaGFwZSBjb3JyZWN0bHkgd2l0aG91dCBhbmNob3JpbmcgdGhlIHRvcCBzaWRlLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRQb3NpdGlvbnNGcm9tTGVuZ3RoQW5kQW5nbGVEYXRhKCB0b3BMZW5ndGg6IG51bWJlciwgcmlnaHRMZW5ndGg6IG51bWJlciwgbGVmdExlbmd0aDogbnVtYmVyLCBsZWZ0VG9wQW5nbGU6IG51bWJlciwgcmlnaHRUb3BBbmdsZTogbnVtYmVyICk6IHZvaWQge1xyXG5cclxuICAgIC8vIG9ubHkgdHJ5IHRvIHNldCB0byBzaW0gaWYgdmFsdWVzIGxvb2sgcmVhc29uYWJsZSAtIHdlIHdhbnQgdG8gaGFuZGxlIHRoaXMgZ3JhY2VmdWxseSwgdGhlIHNpbSBzaG91bGRuJ3QgY3Jhc2hcclxuICAgIC8vIGlmIGRhdGEgaXNuJ3QgcmlnaHRcclxuICAgIGNvbnN0IGFsbERhdGFHb29kID0gXy5ldmVyeSggW1xyXG4gICAgICB0b3BMZW5ndGgsIHJpZ2h0TGVuZ3RoLCBsZWZ0TGVuZ3RoLCBsZWZ0VG9wQW5nbGUsIHJpZ2h0VG9wQW5nbGVcclxuICAgIF0sIHZhbHVlID0+IHtcclxuICAgICAgcmV0dXJuICFpc05hTiggdmFsdWUgKSAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlICE9PSBudWxsO1xyXG4gICAgfSApO1xyXG4gICAgaWYgKCAhYWxsRGF0YUdvb2QgKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YW5naWJsZUNvbm5lY3Rpb25Nb2RlbCA9IHRoaXMudGFuZ2libGVDb25uZWN0aW9uTW9kZWw7XHJcblxyXG4gICAgLy8geW91IG11c3QgY2FsaWJyYXRlIGJlZm9yZSBzZXR0aW5nIHBvc2l0aW9ucyBmcm9tIGEgcGh5c2ljYWwgZGV2aWNlXHJcbiAgICBpZiAoIHRhbmdpYmxlQ29ubmVjdGlvbk1vZGVsLnBoeXNpY2FsTW9kZWxCb3VuZHNQcm9wZXJ0eS52YWx1ZSAhPT0gbnVsbCAmJiAhdGFuZ2libGVDb25uZWN0aW9uTW9kZWwuaXNDYWxpYnJhdGluZ1Byb3BlcnR5LnZhbHVlICkge1xyXG5cclxuICAgICAgLy8gdGhlIHBoeXNpY2FsIGRldmljZSBsZW5ndGhzIGNhbiBvbmx5IGJlY29tZSBoYWxmIGFzIGxvbmcgYXMgdGhlIGxhcmdlc3QgbGVuZ3RoLCBzbyBtYXAgdG8gdGhlIHNpbSBtb2RlbFxyXG4gICAgICAvLyB3aXRoIHRoYXQgY29uc3RyYWludCBhcyB3ZWxsIHNvIHRoYXQgdGhlIHNtYWxsZXN0IHNoYXBlIG9uIHRoZSBwaHlzaWNhbCBkZXZpY2UgZG9lc24ndCBicmluZyB2ZXJ0aWNlc1xyXG4gICAgICAvLyBhbGwgdGhlIHdheSB0byB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW4gKDAsIDApLlxyXG4gICAgICBjb25zdCBkZXZpY2VMZW5ndGhUb1NpbUxlbmd0aCA9IG5ldyBMaW5lYXJGdW5jdGlvbiggMCwgdGFuZ2libGVDb25uZWN0aW9uTW9kZWwucGh5c2ljYWxNb2RlbEJvdW5kc1Byb3BlcnR5LnZhbHVlLndpZHRoLCAwLCBRdWFkcmlsYXRlcmFsQ29uc3RhbnRzLkJPVU5EU19XSURUSCAvIDMgKTtcclxuXHJcbiAgICAgIGNvbnN0IG1hcHBlZFRvcExlbmd0aCA9IGRldmljZUxlbmd0aFRvU2ltTGVuZ3RoLmV2YWx1YXRlKCB0b3BMZW5ndGggKTtcclxuICAgICAgY29uc3QgbWFwcGVkUmlnaHRMZW5ndGggPSBkZXZpY2VMZW5ndGhUb1NpbUxlbmd0aC5ldmFsdWF0ZSggcmlnaHRMZW5ndGggKTtcclxuICAgICAgY29uc3QgbWFwcGVkTGVmdExlbmd0aCA9IGRldmljZUxlbmd0aFRvU2ltTGVuZ3RoLmV2YWx1YXRlKCBsZWZ0TGVuZ3RoICk7XHJcblxyXG4gICAgICB0aGlzLnNldFBvc2l0aW9uc0Zyb21MZW5ndGhzQW5kQW5nbGVzKCBtYXBwZWRUb3BMZW5ndGgsIG1hcHBlZFJpZ2h0TGVuZ3RoLCBtYXBwZWRMZWZ0TGVuZ3RoLCBsZWZ0VG9wQW5nbGUsIHJpZ2h0VG9wQW5nbGUgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBwb3NpdGlvbnMgZnJvbSB0aGUgbGVuZ3RoIGFuZCBhbmdsZSBkYXRhIHByb3ZpZGVkLiBVc2VmdWwgd2hlbiB3b3JraW5nIHdpdGggYSB0YW5naWJsZSBkZXZpY2UgdGhhdCBpc1xyXG4gICAqIHByb3ZpZGluZyBsZW5ndGggYW5kIGFuZ2xlIGRhdGEuIFdoZW4gcmVjb25zdHJ1Y3RpbmcgdGhlIHNoYXBlIHdlIHN0YXJ0IGJ5IG1ha2luZyB0aGUgdG9wIHNpZGUgcGFyYWxsZWxcclxuICAgKiB3aXRoIHRoZSB0b3Agb2YgbW9kZWwgYm91bmRzLiBUaGUgcmVtYWluaW5nIHZlcnRpY2VzIGFyZSBwb3NpdGlvbmVkIGFjY29yZGluZ2x5LiBGaW5hbGx5LCBpZiB0aGVyZSBpcyBzb21lXHJcbiAgICogcm90YXRpb24gdG8gYXBwbHkgKGZyb20gdGhlIGV4cGVyaW1lbnRhbCBtYXJrZXIgaW5wdXQpLCB0aGF0IHJvdGF0aW9uIGlzIGFwcGxpZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdG9wTGVuZ3RoXHJcbiAgICogQHBhcmFtIHJpZ2h0TGVuZ3RoXHJcbiAgICogQHBhcmFtIGxlZnRMZW5ndGhcclxuICAgKiBAcGFyYW0gcDFBbmdsZSAtIHRoZSBsZWZ0IHRvcCBhbmdsZSAodmVydGV4QSlcclxuICAgKiBAcGFyYW0gcDJBbmdsZSAtIHRoZSByaWdodCB0b3AgYW5nbGUgKHZlcnRleEIpXHJcbiAgICovXHJcbiAgcHVibGljIHNldFBvc2l0aW9uc0Zyb21MZW5ndGhzQW5kQW5nbGVzKCB0b3BMZW5ndGg6IG51bWJlciwgcmlnaHRMZW5ndGg6IG51bWJlciwgbGVmdExlbmd0aDogbnVtYmVyLCBwMUFuZ2xlOiBudW1iZXIsIHAyQW5nbGU6IG51bWJlciApOiB2b2lkIHtcclxuICAgIGNvbnN0IHNoYXBlTW9kZWwgPSB0aGlzLnNoYXBlTW9kZWw7XHJcblxyXG4gICAgLy8gdmVydGV4QSBhbmQgdGhlIHRvcExpbmUgYXJlIGFuY2hvcmVkLCB0aGUgcmVzdCBvZiB0aGUgc2hhcGUgaXMgcmVsYXRpdmUgdG8gdGhpc1xyXG4gICAgY29uc3QgdmVjdG9yMVBvc2l0aW9uID0gbmV3IFZlY3RvcjIoIFF1YWRyaWxhdGVyYWxDb25zdGFudHMuTU9ERUxfQk9VTkRTLm1pblgsIFF1YWRyaWxhdGVyYWxDb25zdGFudHMuTU9ERUxfQk9VTkRTLm1heFggKTtcclxuICAgIGNvbnN0IHZlY3RvcjJQb3NpdGlvbiA9IG5ldyBWZWN0b3IyKCB2ZWN0b3IxUG9zaXRpb24ueCArIHRvcExlbmd0aCwgdmVjdG9yMVBvc2l0aW9uLnkgKTtcclxuXHJcbiAgICBjb25zdCB2ZWN0b3I0T2Zmc2V0ID0gbmV3IFZlY3RvcjIoIE1hdGguY29zKCAtcDFBbmdsZSApLCBNYXRoLnNpbiggLXAxQW5nbGUgKSApLnRpbWVzU2NhbGFyKCBsZWZ0TGVuZ3RoICk7XHJcbiAgICBjb25zdCB2ZWN0b3I0UG9zaXRpb24gPSB2ZWN0b3IxUG9zaXRpb24ucGx1cyggdmVjdG9yNE9mZnNldCApO1xyXG5cclxuICAgIGNvbnN0IHZlY3RvcjNPZmZzZXQgPSBuZXcgVmVjdG9yMiggTWF0aC5jb3MoIE1hdGguUEkgKyBwMkFuZ2xlICksIE1hdGguc2luKCBNYXRoLlBJICsgcDJBbmdsZSApICkudGltZXNTY2FsYXIoIHJpZ2h0TGVuZ3RoICk7XHJcbiAgICBjb25zdCB2ZWN0b3IzUG9zaXRpb24gPSB2ZWN0b3IyUG9zaXRpb24ucGx1cyggdmVjdG9yM09mZnNldCApO1xyXG5cclxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBwcm9wb3NlZCBwb3NpdGlvbnMgYXJlIHdpdGhpbiBib3VuZHMgZGVmaW5lZCBpbiB0aGUgc2ltdWxhdGlvbiBtb2RlbFxyXG4gICAgY29uc3QgcHJvcG9zZWRQb3NpdGlvbnMgPSBbIHZlY3RvcjFQb3NpdGlvbiwgdmVjdG9yMlBvc2l0aW9uLCB2ZWN0b3IzUG9zaXRpb24sIHZlY3RvcjRQb3NpdGlvbiBdO1xyXG5cclxuICAgIC8vIHdlIGhhdmUgdGhlIHZlcnRleCBwb3NpdGlvbnMgdG8gcmVjcmVhdGUgdGhlIHNoYXBlLCBidXQgc2hpZnQgdGhlbSBzbyB0aGF0IHRoZSBjZW50cm9pZCBvZiB0aGUgcXVhZHJpbGF0ZXJhbCBpc1xyXG4gICAgLy8gaW4gdGhlIGNlbnRlciBvZiB0aGUgbW9kZWwgc3BhY2VcclxuICAgIGNvbnN0IGNlbnRyb2lkUG9zaXRpb24gPSBRdWFkcmlsYXRlcmFsVXRpbHMuZ2V0Q2VudHJvaWRGcm9tUG9zaXRpb25zKCBwcm9wb3NlZFBvc2l0aW9ucyApO1xyXG4gICAgY29uc3QgY2VudHJvaWRPZmZzZXQgPSBjZW50cm9pZFBvc2l0aW9uLm5lZ2F0ZWQoKTtcclxuICAgIGNvbnN0IHNoaWZ0ZWRQb3NpdGlvbnMgPSBfLm1hcCggcHJvcG9zZWRQb3NpdGlvbnMsIHNoYXBlUG9zaXRpb24gPT4gc2hhcGVQb3NpdGlvbi5wbHVzKCBjZW50cm9pZE9mZnNldCApICk7XHJcblxyXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgYWxsIHBvc2l0aW9ucyBhcmUgd2l0aGluIG1vZGVsIGJvdW5kc1xyXG4gICAgY29uc3QgY29uc3RyYWluZWRQb3NpdGlvbnMgPSBfLm1hcCggc2hpZnRlZFBvc2l0aW9ucywgcG9zaXRpb24gPT4gUXVhZHJpbGF0ZXJhbENvbnN0YW50cy5NT0RFTF9CT1VORFMuY2xvc2VzdFBvaW50VG8oIHBvc2l0aW9uICkgKTtcclxuXHJcbiAgICAvLyBzbW9vdGggcG9zaXRpb25zIHRvIHRyeSB0byByZWR1Y2Ugbm9pc2VcclxuICAgIGNvbnN0IHNtb290aGVkUG9zaXRpb25zID0gW1xyXG4gICAgICBzaGFwZU1vZGVsLnZlcnRleEEuc21vb3RoUG9zaXRpb24oIGNvbnN0cmFpbmVkUG9zaXRpb25zWyAwIF0hICksXHJcbiAgICAgIHNoYXBlTW9kZWwudmVydGV4Qi5zbW9vdGhQb3NpdGlvbiggY29uc3RyYWluZWRQb3NpdGlvbnNbIDEgXSEgKSxcclxuICAgICAgc2hhcGVNb2RlbC52ZXJ0ZXhDLnNtb290aFBvc2l0aW9uKCBjb25zdHJhaW5lZFBvc2l0aW9uc1sgMiBdISApLFxyXG4gICAgICBzaGFwZU1vZGVsLnZlcnRleEQuc21vb3RoUG9zaXRpb24oIGNvbnN0cmFpbmVkUG9zaXRpb25zWyAzIF0hIClcclxuICAgIF07XHJcblxyXG4gICAgLy8gQ29uc3RyYWluIHRvIGludGVydmFscyBvZiBkZXZpY2VHcmlkU3BhY2luZ1Byb3BlcnR5LnZhbHVlIHRvIHRyeSB0byByZWR1Y2Ugbm9pc2VcclxuICAgIGNvbnN0IGNvbnN0cmFpbmVkR3JpZFBvc2l0aW9ucyA9IF8ubWFwKCBzbW9vdGhlZFBvc2l0aW9ucywgc21vb3RoZWRQb3NpdGlvbiA9PiB0aGlzLnF1YWRyaWxhdGVyYWxNb2RlbC5nZXRDbG9zZXN0R3JpZFBvc2l0aW9uKCBzbW9vdGhlZFBvc2l0aW9uICkgKTtcclxuXHJcbiAgICBjb25zdCB2ZXJ0ZXhMYWJlbE1hcCA9IG5ldyBNYXAoIFtcclxuICAgICAgWyBzaGFwZU1vZGVsLnZlcnRleEEudmVydGV4TGFiZWwsIGNvbnN0cmFpbmVkR3JpZFBvc2l0aW9uc1sgMCBdISBdLFxyXG4gICAgICBbIHNoYXBlTW9kZWwudmVydGV4Qi52ZXJ0ZXhMYWJlbCwgY29uc3RyYWluZWRHcmlkUG9zaXRpb25zWyAxIF0hIF0sXHJcbiAgICAgIFsgc2hhcGVNb2RlbC52ZXJ0ZXhDLnZlcnRleExhYmVsLCBjb25zdHJhaW5lZEdyaWRQb3NpdGlvbnNbIDIgXSEgXSxcclxuICAgICAgWyBzaGFwZU1vZGVsLnZlcnRleEQudmVydGV4TGFiZWwsIGNvbnN0cmFpbmVkR3JpZFBvc2l0aW9uc1sgMyBdISBdXHJcbiAgICBdICk7XHJcblxyXG4gICAgdGhpcy5zaGFwZU1vZGVsLnNldFZlcnRleFBvc2l0aW9ucyggdmVydGV4TGFiZWxNYXAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgcG9zaXRpb25zIG9mIHZlcnRpY2VzIGRpcmVjdGx5IGZyb20gYSB0YW5naWJsZSBkZXZpY2UuIEEgY29ubmVjdGlvbiB0byBhIHBoeXNpY2FsIGRldmljZSBtaWdodCB1c2UgdGhpc1xyXG4gICAqIGZ1bmN0aW9uIHRvIHNldCB0aGUgcG9zaXRpb25zIGluIG1vZGVsIHNwYWNlLiBJZiBpdCBkb2Vzbid0IGhhdmUgYWJzb2x1dGUgcG9zaXRpb25pbmcgaXQgbWF5IG5lZWQgdG8gdXNlXHJcbiAgICogc2V0UG9zaXRpb25zRnJvbUxlbmd0aEFuZEFuZ2xlRGF0YSBpbnN0ZWFkLlxyXG4gICAqXHJcbiAgICogQ3VycmVudGx5IHRoaXMgaXMgYmVpbmcgdXNlZCBieSB0aGUgT3BlbkNWIHByb3RvdHlwZSBhbmQgYSBwcm90b3R5cGUgdXNpbmcgTWVkaWFQaXBlLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRQb3NpdGlvbnNGcm9tQWJzb2x1dGVQb3NpdGlvbkRhdGEoIGxhYmVsVG9Qcm9wb3NlZFBvc2l0aW9uTWFwOiBWZXJ0ZXhMYWJlbFRvUHJvcG9zZWRQb3NpdGlvbk1hcCApOiB2b2lkIHtcclxuICAgIGNvbnN0IHRhbmdpYmxlQ29ubmVjdGlvbk1vZGVsID0gdGhpcy50YW5naWJsZUNvbm5lY3Rpb25Nb2RlbDtcclxuXHJcbiAgICAvLyB5b3UgbXVzdCBjYWxpYnJhdGUgYmVmb3JlIHNldHRpbmcgcG9zaXRpb25zIGZyb20gYSBwaHlzaWNhbCBkZXZpY2VcclxuICAgIGlmICggdGFuZ2libGVDb25uZWN0aW9uTW9kZWwucGh5c2ljYWxUb01vZGVsVHJhbnNmb3JtICE9PSBudWxsICYmICF0YW5naWJsZUNvbm5lY3Rpb25Nb2RlbC5pc0NhbGlicmF0aW5nUHJvcGVydHkudmFsdWUgKSB7XHJcblxyXG4gICAgICAvLyBzY2FsZSB0aGUgcGh5c2ljYWwgcG9zaXRpb25zIHRvIHRoZSBzaW11bGF0aW9uIHZpcnR1YWwgbW9kZWxcclxuICAgICAgY29uc3QgbGFiZWxUb0NvbnN0cmFpbmVkUG9zaXRpb25NYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgIGxhYmVsVG9Qcm9wb3NlZFBvc2l0aW9uTWFwLmZvckVhY2goICggcHJvcG9zZWRQb3NpdGlvbiwgbGFiZWxLZXkgKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmVydGV4ID0gdGhpcy5zaGFwZU1vZGVsLmdldExhYmVsbGVkVmVydGV4KCBsYWJlbEtleSApO1xyXG5cclxuICAgICAgICBsZXQgY29uc3RyYWluZWRQb3NpdGlvbjogVmVjdG9yMjtcclxuXHJcbiAgICAgICAgLy8gb25seSB0cnkgdG8gc2V0IGEgbmV3IHBvc2l0aW9uIGlmIHZhbHVlcyBsb29rIHJlYXNvbmFibGUgLSB3ZSB3YW50IHRvIGhhbmRsZSB0aGlzIGdyYWNlZnVsbHksIHRoZSBzaW1cclxuICAgICAgICAvLyBzaG91bGRuJ3QgY3Jhc2ggaWYgZGF0YSBpc24ndCByaWdodFxyXG4gICAgICAgIGlmICggcHJvcG9zZWRQb3NpdGlvbiAmJiBwcm9wb3NlZFBvc2l0aW9uLmlzRmluaXRlKCkgKSB7XHJcblxyXG4gICAgICAgICAgLy8gdHJhbnNmb3JtIGZyb20gdGFuZ2libGUgdG8gdmlydHVhbCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgY29uc3QgdmlydHVhbFBvc2l0aW9uID0gdGFuZ2libGVDb25uZWN0aW9uTW9kZWwucGh5c2ljYWxUb01vZGVsVHJhbnNmb3JtLm1vZGVsVG9WaWV3UG9zaXRpb24oIHByb3Bvc2VkUG9zaXRpb24gKTtcclxuXHJcbiAgICAgICAgICAvLyBhcHBseSBzbW9vdGhpbmcgb3ZlciBhIG51bWJlciBvZiB2YWx1ZXMgdG8gcmVkdWNlIG5vaXNlXHJcbiAgICAgICAgICBjb25zdHJhaW5lZFBvc2l0aW9uID0gdmVydGV4LnNtb290aFBvc2l0aW9uKCB2aXJ0dWFsUG9zaXRpb24gKTtcclxuXHJcbiAgICAgICAgICAvLyBjb25zdHJhaW4gd2l0aGluIG1vZGVsIGJvdW5kc1xyXG4gICAgICAgICAgY29uc3RyYWluZWRQb3NpdGlvbiA9IFF1YWRyaWxhdGVyYWxDb25zdGFudHMuTU9ERUxfQk9VTkRTLmNsb3Nlc3RQb2ludFRvKCBjb25zdHJhaW5lZFBvc2l0aW9uICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBub3QgcmVhc29uYWJsZSwganVzdCBmYWxsIGJhY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb25cclxuICAgICAgICAgIGNvbnN0cmFpbmVkUG9zaXRpb24gPSB2ZXJ0ZXgucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFsaWduIHdpdGggbW9kZWwgZ3JpZCBwb3NpdGlvbnNcclxuICAgICAgICBjb25zdHJhaW5lZFBvc2l0aW9uID0gdGhpcy5xdWFkcmlsYXRlcmFsTW9kZWwuZ2V0Q2xvc2VzdEdyaWRQb3NpdGlvbiggY29uc3RyYWluZWRQb3NpdGlvbiEgKTtcclxuXHJcbiAgICAgICAgbGFiZWxUb0NvbnN0cmFpbmVkUG9zaXRpb25NYXAuc2V0KCBsYWJlbEtleSwgY29uc3RyYWluZWRQb3NpdGlvbiApO1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICAvLyBPbmx5IHNldCB0byB0aGUgbW9kZWwgaWYgdGhlIHNoYXBlIGlzIGFsbG93ZWQgYW5kIHJlYXNvbmFibGUgKG5vIG92ZXJsYXBzLCBubyBpbnRlcnNlY3Rpb25zKVxyXG4gICAgICBpZiAoIHRhbmdpYmxlQ29ubmVjdGlvbk1vZGVsLmlzU2hhcGVBbGxvd2VkRm9yVGFuZ2libGUoIGxhYmVsVG9Db25zdHJhaW5lZFBvc2l0aW9uTWFwICkgKSB7XHJcbiAgICAgICAgdGhpcy5zaGFwZU1vZGVsLnNldFZlcnRleFBvc2l0aW9ucyggbGFiZWxUb0NvbnN0cmFpbmVkUG9zaXRpb25NYXAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbnF1YWRyaWxhdGVyYWwucmVnaXN0ZXIoICdRdWFkcmlsYXRlcmFsVGFuZ2libGVDb250cm9sbGVyJywgUXVhZHJpbGF0ZXJhbFRhbmdpYmxlQ29udHJvbGxlciApO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFNLGtDQUFrQztBQUN0RCxPQUFPQyxhQUFhLE1BQU0sMkJBQTJCO0FBR3JELE9BQU9DLGtCQUFrQixNQUFNLG1DQUFtQztBQUVsRSxPQUFPQyxjQUFjLE1BQU0seUNBQXlDO0FBQ3BFLE9BQU9DLHNCQUFzQixNQUFNLG9DQUFvQztBQUV2RSxlQUFlLE1BQU1DLCtCQUErQixDQUFDO0VBTTVDQyxXQUFXQSxDQUFFQyxrQkFBc0MsRUFBRztJQUMzRCxJQUFJLENBQUNBLGtCQUFrQixHQUFHQSxrQkFBa0I7SUFFNUMsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSSxDQUFDRCxrQkFBa0IsQ0FBQ0UsdUJBQXVCO0lBQ2pFLElBQUksQ0FBQ0MsdUJBQXVCLEdBQUcsSUFBSSxDQUFDSCxrQkFBa0IsQ0FBQ0csdUJBQXVCO0VBQ2hGOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ1NDLGlCQUFpQkEsQ0FBQSxFQUFTO0lBQy9CLE1BQU1DLG1CQUFtQixHQUFHLElBQUksQ0FBQ0YsdUJBQXVCLENBQUNHLDJCQUEyQixDQUFDQyxLQUFNO0lBQzNGQyxNQUFNLElBQUlBLE1BQU0sQ0FBRUgsbUJBQW1CLElB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