// Copyright 2021-2023, University of Colorado Boulder

/**
 * The view for a side of the quadrilateral shape.
 *
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import { DragListener, KeyboardDragListener, Line as LineNode, Path } from '../../../../scenery/js/imports.js';
import quadrilateral from '../../quadrilateral.js';
import QuadrilateralSide from '../model/QuadrilateralSide.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import QuadrilateralShapeModel from '../model/QuadrilateralShapeModel.js';
import { Line, Shape } from '../../../../kite/js/imports.js';
import Multilink from '../../../../axon/js/Multilink.js';
import release_mp3 from '../../../../tambo/sounds/release_mp3.js';
import Bounds2 from '../../../../dot/js/Bounds2.js';
import SideTicksNode from './SideTicksNode.js';
import QuadrilateralMovableNode from './QuadrilateralMovableNode.js';
import optionize from '../../../../phet-core/js/optionize.js';

// The dilation around side shapes when drawing the focus highlight.
const FOCUS_HIGHLIGHT_DILATION = 15;
// Reusable map that saves proposed vertex positions, to avoid excessive garbage.
const scratchLabelToPositionMap = new Map();
class QuadrilateralSideNode extends QuadrilateralMovableNode {
  // A reference to the equivalent side with the two relevant vertices in the scratch model.

  constructor(quadrilateralModel, side, scratchSide, sideDescriber, modelViewTransform, providedOptions) {
    const options = optionize()({
      // The 'release' sound is used instead of the 'grab' to distinguish sides from vertices
      grabbedSound: release_mp3,
      grabbedSoundOutputLevel: 0.8
    }, providedOptions);
    const sidePath = new Path(null);
    super(side, modelViewTransform, sidePath, options);
    this.side = side;
    this.scratchSide = scratchSide;
    this.quadrilateralModel = quadrilateralModel;
    const ticksNode = new SideTicksNode(side, modelViewTransform);
    this.addChild(ticksNode);
    const markersVisibleProperty = quadrilateralModel.visibilityModel.markersVisibleProperty;

    // Reusable lineNode for calculating the shape of the focus highlight
    const lineNode = new LineNode(0, 0, 0, 0);

    // listeners
    Multilink.multilink([side.modelLineProperty, markersVisibleProperty], (modelLine, markersVisible) => {
      ticksNode.visible = markersVisible;

      // The Shape for our Path - drawn in model coordinates until a transform at the end
      const lineShape = new Shape();
      if (markersVisible) {
        // If markers are visible we need to draw each unit segment. Break the line into multiple segments.
        const lineSegments = [];

        // The length of a segment parametrically relative to the full line length
        const parametricSegmentLength = QuadrilateralSide.SIDE_SEGMENT_LENGTH / modelLine.getArcLength();
        const numberOfFullSegments = Math.floor(1 / parametricSegmentLength);
        let t = 0;
        for (let i = 0; i < numberOfFullSegments && t < 1; i++) {
          const nextPosition = Math.min(t + parametricSegmentLength, 1);
          lineSegments.push(new Line(modelLine.positionAt(t), modelLine.positionAt(nextPosition)));
          t = nextPosition;
        }

        // the final segment should be the remainder from 1 (parametric end) to the last full segment
        assert && assert(1 - t >= 0, 'we cannot have gone beyond the end of the full line parametrically');

        // Ad the remaining portion of a segment if there is one. t might not be exactly one but close enough
        // that line.positionAt produces a line with zero length, so we only add another segment if it is large enough.
        if (1 - t > 0.0005) {
          const remainderLine = new Line(modelLine.positionAt(t), modelLine.positionAt(1));
          lineSegments.push(remainderLine);

          // ensure that t was large enough that we didnt create a zero-length line
          assert && assert(!remainderLine.start.equals(remainderLine.end), 'Should be a non-zero length remainder for the line in this case');
        }
        const rightStrokes = [];
        const leftStrokes = [];
        lineSegments.forEach((lineSegment, index) => {
          // stroke functions divide width by two for us
          const strokeRight = lineSegment.strokeRight(QuadrilateralSide.SIDE_WIDTH);
          const strokeLeft = lineSegment.strokeLeft(QuadrilateralSide.SIDE_WIDTH);
          rightStrokes.push(strokeRight[0]);
          leftStrokes.push(strokeLeft[0]);
        });
        rightStrokes.forEach((rightStroke, index) => {
          lineShape.moveToPoint(rightStroke.start);
          lineShape.lineToPoint(rightStroke.end);
          lineShape.lineToPoint(leftStrokes[index].start);
          lineShape.lineToPoint(leftStrokes[index].end);

          // so that fill will fill each segment individually and so we see strokes in between each segment
          lineShape.close();
        });

        // only to the redrawing work for ticks when they are visible
        ticksNode.redraw();
      } else {
        // just a rectangular path along the line with the width of SIDE_WIDTH
        const rightStroke = modelLine.strokeRight(QuadrilateralSide.SIDE_WIDTH);
        const leftStroke = modelLine.strokeLeft(QuadrilateralSide.SIDE_WIDTH);
        lineShape.moveToPoint(rightStroke[0].start);
        lineShape.lineToPoint(rightStroke[0].end);
        lineShape.lineToPoint(leftStroke[0].start);
        lineShape.lineToPoint(leftStroke[0].end);
        lineShape.close();
      }

      // transform shape to view coordinates
      sidePath.shape = modelViewTransform.modelToViewShape(lineShape);

      // Draw the custom focus highlight so that the highlight surrounds the shape of the line
      const vertex1ViewPosition = modelViewTransform.modelToViewPosition(modelLine.start);
      const vertex2ViewPosition = modelViewTransform.modelToViewPosition(modelLine.end);
      lineNode.setLine(vertex1ViewPosition.x, vertex1ViewPosition.y, vertex2ViewPosition.x, vertex2ViewPosition.y);
      lineNode.lineWidth = modelViewTransform.modelToViewDeltaX(QuadrilateralSide.SIDE_WIDTH) + FOCUS_HIGHLIGHT_DILATION;
      this.focusHighlight = lineNode.getStrokedShape();
    });
    const keyboardDragListener = new KeyboardDragListener({
      dragDelta: this.largeViewDragDelta,
      shiftDragDelta: this.smallViewDragDelta,
      transform: modelViewTransform,
      drag: vectorDelta => {
        this.moveVerticesFromModelDelta(vectorDelta);
      },
      moveOnHoldDelay: 750,
      moveOnHoldInterval: 50,
      tandem: providedOptions?.tandem?.createTandem('keyboardDragListener')
    });
    this.addInputListener(keyboardDragListener);

    // Vectors between the start position during drag and each vertex so that we can translate vertex positions
    // relative to a pointer position on a side.
    let vectorToVertex1 = null;
    let vectorToVertex2 = null;
    let vertex1StartPosition = side.vertex1.positionProperty.value;
    let vertex2StartPosition = side.vertex2.positionProperty.value;
    this.addInputListener(new DragListener({
      transform: modelViewTransform,
      start: (event, listener) => {
        side.isPressedProperty.value = true;

        // point in the coordinate frame of the play area, then in model coordinates
        assert && assert(event.pointer.point, 'How could there not be a point from an event?');
        const parentPoint = this.globalToParentPoint(event.pointer.point);
        const modelPoint = modelViewTransform.viewToModelPosition(parentPoint);
        vectorToVertex1 = side.vertex1.positionProperty.value.minus(modelPoint);
        vectorToVertex2 = side.vertex2.positionProperty.value.minus(modelPoint);
        vertex1StartPosition = side.vertex1.positionProperty.value;
        vertex2StartPosition = side.vertex2.positionProperty.value;
      },
      end: () => {
        side.isPressedProperty.value = false;

        // If there is no motion speak information about this side. If there is movement during drag other
        // responses describing the change will be used.
        const vertex1Position = side.vertex1.positionProperty.value;
        const vertex2Position = side.vertex2.positionProperty.value;
        if (vertex1StartPosition === vertex1Position && vertex2StartPosition === vertex2Position) {
          this.voicingSpeakFullResponse();
        }
      },
      drag: (event, listener) => {
        const vertex1Pressed = side.vertex1.isPressedProperty.value;
        const vertex2Pressed = side.vertex2.isPressedProperty.value;

        // A side cannot be dragged while one of its Vertices is dragged (multitouch)
        if (!vertex1Pressed && !vertex2Pressed) {
          // point in the coordinate frame of the play area, then in model coordinates
          const parentPoint = this.globalToParentPoint(event.pointer.point);
          const modelPoint = modelViewTransform.viewToModelPosition(parentPoint);
          assert && assert(vectorToVertex1, 'vectorToVertex1 should have been defined at start of drag');
          assert && assert(vectorToVertex2, 'vectorToVertex1 should have been defined at start of drag');
          const modelVertex1Position = modelPoint.plus(vectorToVertex1);
          const modelVertex2Position = modelPoint.plus(vectorToVertex2);

          // Absolute bounding box around the side - useful for determine allowable vertex positions while supporting
          // smooth dragging
          const sideBounds = new Bounds2(0, 0, 0, 0);
          sideBounds.addPoint(modelVertex1Position);
          sideBounds.addPoint(modelVertex2Position);

          // now shift the proposed positions by a delta that would keep the sideBounds within vertexDragBounds
          const vertexDragBounds = quadrilateralModel.vertexDragBounds;
          const correctingVector = new Vector2(0, 0);
          const inBounds = vertexDragBounds.containsBounds(sideBounds);
          if (!inBounds) {
            if (sideBounds.maxY > vertexDragBounds.maxY) {
              correctingVector.y = vertexDragBounds.maxY - sideBounds.maxY;
            } else if (sideBounds.minY < vertexDragBounds.minY) {
              correctingVector.y = vertexDragBounds.minY - sideBounds.minY;
            }
            if (sideBounds.maxX > vertexDragBounds.maxX) {
              correctingVector.x = vertexDragBounds.maxX - sideBounds.maxX;
            } else if (sideBounds.minX < vertexDragBounds.minX) {
              correctingVector.x = vertexDragBounds.minX - sideBounds.minX;
            }
          }
          const boundsConstrainedVertex1Position = modelVertex1Position.plus(correctingVector);
          const boundsConstrainedVertex2Position = modelVertex2Position.plus(correctingVector);

          // constrain each to the model grid, allowing for diagonal movement
          const gridConstrainedVertex1Position = quadrilateralModel.getClosestGridPositionAlongDiagonal(side.vertex1.positionProperty.value, boundsConstrainedVertex1Position);
          const gridConstrainedVertex2Position = quadrilateralModel.getClosestGridPositionAlongDiagonal(side.vertex2.positionProperty.value, boundsConstrainedVertex2Position);

          // deltas for each QuadrilateralVertex must be the same for the side to not change tilt while dragging - update
          // both Vertices by the smallest translation vector so they move together
          const smallestDeltaVector = this.getSmallestTranslationVector(gridConstrainedVertex1Position, gridConstrainedVertex2Position);
          const proposedVertex1Position = side.vertex1.positionProperty.value.plus(smallestDeltaVector);
          const proposedVertex2Position = side.vertex2.positionProperty.value.plus(smallestDeltaVector);
          scratchLabelToPositionMap.clear();
          scratchLabelToPositionMap.set(side.vertex1.vertexLabel, proposedVertex1Position);
          scratchLabelToPositionMap.set(side.vertex2.vertexLabel, proposedVertex2Position);

          // only update positions if both are allowed
          const positionsAllowed = quadrilateralModel.areVertexPositionsAllowed(scratchLabelToPositionMap);
          if (positionsAllowed) {
            this.quadrilateralModel.quadrilateralShapeModel.setVertexPositions(scratchLabelToPositionMap);
          }
          this.updateBlockedState(!positionsAllowed, !inBounds);
        }
      },
      tandem: providedOptions?.tandem?.createTandem('dragListener')
    }));

    // voicing - re-generate the voicing descriptions when Properties used for content change
    this.quadrilateralModel.quadrilateralShapeModel.shapeChangedEmitter.addListener(() => {
      this.voicingObjectResponse = sideDescriber.getSideObjectResponse();
    });
    markersVisibleProperty.link(() => {
      this.voicingObjectResponse = sideDescriber.getSideObjectResponse();
    });
  }
  getSmallestTranslationVector(proposedVertex1Position, proposedVertex2Position) {
    const currentVertex1Position = this.side.vertex1.positionProperty.value;
    const currentVertex2Position = this.side.vertex2.positionProperty.value;

    // Each QuadrilateralVertex must move by the same amount so that the side does not tile during input. Find the smallest change
    // after constraining vertices to the grid, and we will move both vertices by that delta.
    return _.minBy([proposedVertex1Position.minus(currentVertex1Position), proposedVertex2Position.minus(currentVertex2Position)], vector => vector.magnitude);
  }

  /**
   * Move both vertices of this side from the change in position specified by deltaVector.
   *
   * @param deltaVector - change of position in model coordinates
   */
  moveVerticesFromModelDelta(deltaVector) {
    const shapeModel = this.quadrilateralModel.quadrilateralShapeModel;
    const scratchShapeModel = this.quadrilateralModel.quadrilateralTestShapeModel;
    const currentVertex1Position = this.side.vertex1.positionProperty.value;
    const currentVertex2Position = this.side.vertex2.positionProperty.value;

    // constrain each QuadrilateralVertex position to the closest allowable grid position
    const closestVertex1Position = this.quadrilateralModel.getClosestGridPositionInDirection(currentVertex1Position, deltaVector);
    const closestVertex2Position = this.quadrilateralModel.getClosestGridPositionInDirection(currentVertex2Position, deltaVector);

    // Each QuadrilateralVertex must move by the same amount so that the side does not tile during input. Find the smallest change
    // after constraining vertices to the grid, and we will move both vertices by that delta.
    const smallestDeltaVector = this.getSmallestTranslationVector(closestVertex1Position, closestVertex2Position);
    const proposedVertex1Position = currentVertex1Position.plus(smallestDeltaVector);
    const proposedVertex2Position = currentVertex2Position.plus(smallestDeltaVector);
    const vertexDragBounds = this.quadrilateralModel.vertexDragBounds;
    const inBounds = vertexDragBounds.containsPoint(proposedVertex1Position) && vertexDragBounds.containsPoint(proposedVertex2Position);

    // update the scratch model before setting proposed vertex positions
    scratchShapeModel.setFromShape(shapeModel);

    // Set the positions to the scratch model so that we can verify that this produces a valid shape. Since we are
    // moving two vertices at the same time we need to check the validity after both have moved, checking the shape
    // moving one vertex at a time may result in incorrect results since that is not the shape we are ultimately
    // going to create with this change.
    scratchLabelToPositionMap.clear();
    scratchLabelToPositionMap.set(this.scratchSide.vertex1.vertexLabel, proposedVertex1Position);
    scratchLabelToPositionMap.set(this.scratchSide.vertex2.vertexLabel, proposedVertex2Position);
    scratchShapeModel.setVertexPositions(scratchLabelToPositionMap);
    if (QuadrilateralShapeModel.isQuadrilateralShapeAllowed(scratchShapeModel)) {
      // signify to the Alerter that it will be time to generate a new object response from input
      this.side.voicingObjectResponseDirty = true;
      shapeModel.setVertexPositions(scratchLabelToPositionMap);
    }

    // The side is only blocked by shape in the case of crossed quadrilaterals - isQuadrilateralShapeAllowed will return
    // false if a vertex is out of bounds, but that shouldn't count toward 'blocked by shape' because there is a
    // special check just for bounds.
    const isShapeAllowed = QuadrilateralShapeModel.isQuadrilateralShapeNotCrossed(scratchShapeModel);
    this.updateBlockedState(!isShapeAllowed, !inBounds);
  }
}
quadrilateral.register('QuadrilateralSideNode', QuadrilateralSideNode);
export default QuadrilateralSideNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEcmFnTGlzdGVuZXIiLCJLZXlib2FyZERyYWdMaXN0ZW5lciIsIkxpbmUiLCJMaW5lTm9kZSIsIlBhdGgiLCJxdWFkcmlsYXRlcmFsIiwiUXVhZHJpbGF0ZXJhbFNpZGUiLCJWZWN0b3IyIiwiUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwiLCJTaGFwZSIsIk11bHRpbGluayIsInJlbGVhc2VfbXAzIiwiQm91bmRzMiIsIlNpZGVUaWNrc05vZGUiLCJRdWFkcmlsYXRlcmFsTW92YWJsZU5vZGUiLCJvcHRpb25pemUiLCJGT0NVU19ISUdITElHSFRfRElMQVRJT04iLCJzY3JhdGNoTGFiZWxUb1Bvc2l0aW9uTWFwIiwiTWFwIiwiUXVhZHJpbGF0ZXJhbFNpZGVOb2RlIiwiY29uc3RydWN0b3IiLCJxdWFkcmlsYXRlcmFsTW9kZWwiLCJzaWRlIiwic2NyYXRjaFNpZGUiLCJzaWRlRGVzY3JpYmVyIiwibW9kZWxWaWV3VHJhbnNmb3JtIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsImdyYWJiZWRTb3VuZCIsImdyYWJiZWRTb3VuZE91dHB1dExldmVsIiwic2lkZVBhdGgiLCJ0aWNrc05vZGUiLCJhZGRDaGlsZCIsIm1hcmtlcnNWaXNpYmxlUHJvcGVydHkiLCJ2aXNpYmlsaXR5TW9kZWwiLCJsaW5lTm9kZSIsIm11bHRpbGluayIsIm1vZGVsTGluZVByb3BlcnR5IiwibW9kZWxMaW5lIiwibWFya2Vyc1Zpc2libGUiLCJ2aXNpYmxlIiwibGluZVNoYXBlIiwibGluZVNlZ21lbnRzIiwicGFyYW1ldHJpY1NlZ21lbnRMZW5ndGgiLCJTSURFX1NFR01FTlRfTEVOR1RIIiwiZ2V0QXJjTGVuZ3RoIiwibnVtYmVyT2ZGdWxsU2VnbWVudHMiLCJNYXRoIiwiZmxvb3IiLCJ0IiwiaSIsIm5leHRQb3NpdGlvbiIsIm1pbiIsInB1c2giLCJwb3NpdGlvbkF0IiwiYXNzZXJ0IiwicmVtYWluZGVyTGluZSIsInN0YXJ0IiwiZXF1YWxzIiwiZW5kIiwicmlnaHRTdHJva2VzIiwibGVmdFN0cm9rZXMiLCJmb3JFYWNoIiwibGluZVNlZ21lbnQiLCJpbmRleCIsInN0cm9rZVJpZ2h0IiwiU0lERV9XSURUSCIsInN0cm9rZUxlZnQiLCJyaWdodFN0cm9rZSIsIm1vdmVUb1BvaW50IiwibGluZVRvUG9pbnQiLCJjbG9zZSIsInJlZHJhdyIsImxlZnRTdHJva2UiLCJzaGFwZSIsIm1vZGVsVG9WaWV3U2hhcGUiLCJ2ZXJ0ZXgxVmlld1Bvc2l0aW9uIiwibW9kZWxUb1ZpZXdQb3NpdGlvbiIsInZlcnRleDJWaWV3UG9zaXRpb24iLCJzZXRMaW5lIiwieCIsInkiLCJsaW5lV2lkdGgiLCJtb2RlbFRvVmlld0RlbHRhWCIsImZvY3VzSGlnaGxpZ2h0IiwiZ2V0U3Ryb2tlZFNoYXBlIiwia2V5Ym9hcmREcmFnTGlzdGVuZXIiLCJkcmFnRGVsdGEiLCJsYXJnZVZpZXdEcmFnRGVsdGEiLCJzaGlmdERyYWdEZWx0YSIsInNtYWxsVmlld0RyYWdEZWx0YSIsInRyYW5zZm9ybSIsImRyYWciLCJ2ZWN0b3JEZWx0YSIsIm1vdmVWZXJ0aWNlc0Zyb21Nb2RlbERlbHRhIiwibW92ZU9uSG9sZERlbGF5IiwibW92ZU9uSG9sZEludGVydmFsIiwidGFuZGVtIiwiY3JlYXRlVGFuZGVtIiwiYWRkSW5wdXRMaXN0ZW5lciIsInZlY3RvclRvVmVydGV4MSIsInZlY3RvclRvVmVydGV4MiIsInZlcnRleDFTdGFydFBvc2l0aW9uIiwidmVydGV4MSIsInBvc2l0aW9uUHJvcGVydHkiLCJ2YWx1ZSIsInZlcnRleDJTdGFydFBvc2l0aW9uIiwidmVydGV4MiIsImV2ZW50IiwibGlzdGVuZXIiLCJpc1ByZXNzZWRQcm9wZXJ0eSIsInBvaW50ZXIiLCJwb2ludCIsInBhcmVudFBvaW50IiwiZ2xvYmFsVG9QYXJlbnRQb2ludCIsIm1vZGVsUG9pbnQiLCJ2aWV3VG9Nb2RlbFBvc2l0aW9uIiwibWludXMiLCJ2ZXJ0ZXgxUG9zaXRpb24iLCJ2ZXJ0ZXgyUG9zaXRpb24iLCJ2b2ljaW5nU3BlYWtGdWxsUmVzcG9uc2UiLCJ2ZXJ0ZXgxUHJlc3NlZCIsInZlcnRleDJQcmVzc2VkIiwibW9kZWxWZXJ0ZXgxUG9zaXRpb24iLCJwbHVzIiwibW9kZWxWZXJ0ZXgyUG9zaXRpb24iLCJzaWRlQm91bmRzIiwiYWRkUG9pbnQiLCJ2ZXJ0ZXhEcmFnQm91bmRzIiwiY29ycmVjdGluZ1ZlY3RvciIsImluQm91bmRzIiwiY29udGFpbnNCb3VuZHMiLCJtYXhZIiwibWluWSIsIm1heFgiLCJtaW5YIiwiYm91bmRzQ29uc3RyYWluZWRWZXJ0ZXgxUG9zaXRpb24iLCJib3VuZHNDb25zdHJhaW5lZFZlcnRleDJQb3NpdGlvbiIsImdyaWRDb25zdHJhaW5lZFZlcnRleDFQb3NpdGlvbiIsImdldENsb3Nlc3RHcmlkUG9zaXRpb25BbG9uZ0RpYWdvbmFsIiwiZ3JpZENvbnN0cmFpbmVkVmVydGV4MlBvc2l0aW9uIiwic21hbGxlc3REZWx0YVZlY3RvciIsImdldFNtYWxsZXN0VHJhbnNsYXRpb25WZWN0b3IiLCJwcm9wb3NlZFZlcnRleDFQb3NpdGlvbiIsInByb3Bvc2VkVmVydGV4MlBvc2l0aW9uIiwiY2xlYXIiLCJzZXQiLCJ2ZXJ0ZXhMYWJlbCIsInBvc2l0aW9uc0FsbG93ZWQiLCJhcmVWZXJ0ZXhQb3NpdGlvbnNBbGxvd2VkIiwicXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwiLCJzZXRWZXJ0ZXhQb3NpdGlvbnMiLCJ1cGRhdGVCbG9ja2VkU3RhdGUiLCJzaGFwZUNoYW5nZWRFbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJ2b2ljaW5nT2JqZWN0UmVzcG9uc2UiLCJnZXRTaWRlT2JqZWN0UmVzcG9uc2UiLCJsaW5rIiwiY3VycmVudFZlcnRleDFQb3NpdGlvbiIsImN1cnJlbnRWZXJ0ZXgyUG9zaXRpb24iLCJfIiwibWluQnkiLCJ2ZWN0b3IiLCJtYWduaXR1ZGUiLCJkZWx0YVZlY3RvciIsInNoYXBlTW9kZWwiLCJzY3JhdGNoU2hhcGVNb2RlbCIsInF1YWRyaWxhdGVyYWxUZXN0U2hhcGVNb2RlbCIsImNsb3Nlc3RWZXJ0ZXgxUG9zaXRpb24iLCJnZXRDbG9zZXN0R3JpZFBvc2l0aW9uSW5EaXJlY3Rpb24iLCJjbG9zZXN0VmVydGV4MlBvc2l0aW9uIiwiY29udGFpbnNQb2ludCIsInNldEZyb21TaGFwZSIsImlzUXVhZHJpbGF0ZXJhbFNoYXBlQWxsb3dlZCIsInZvaWNpbmdPYmplY3RSZXNwb25zZURpcnR5IiwiaXNTaGFwZUFsbG93ZWQiLCJpc1F1YWRyaWxhdGVyYWxTaGFwZU5vdENyb3NzZWQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlF1YWRyaWxhdGVyYWxTaWRlTm9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBUaGUgdmlldyBmb3IgYSBzaWRlIG9mIHRoZSBxdWFkcmlsYXRlcmFsIHNoYXBlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEplc3NlIEdyZWVuYmVyZyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgeyBEcmFnTGlzdGVuZXIsIEtleWJvYXJkRHJhZ0xpc3RlbmVyLCBMaW5lIGFzIExpbmVOb2RlLCBQYXRoLCBTY2VuZXJ5RXZlbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgcXVhZHJpbGF0ZXJhbCBmcm9tICcuLi8uLi9xdWFkcmlsYXRlcmFsLmpzJztcclxuaW1wb3J0IFF1YWRyaWxhdGVyYWxTaWRlIGZyb20gJy4uL21vZGVsL1F1YWRyaWxhdGVyYWxTaWRlLmpzJztcclxuaW1wb3J0IE1vZGVsVmlld1RyYW5zZm9ybTIgZnJvbSAnLi4vLi4vLi4vLi4vcGhldGNvbW1vbi9qcy92aWV3L01vZGVsVmlld1RyYW5zZm9ybTIuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsU2hhcGVNb2RlbCwgeyBWZXJ0ZXhMYWJlbFRvUHJvcG9zZWRQb3NpdGlvbk1hcCB9IGZyb20gJy4uL21vZGVsL1F1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLmpzJztcclxuaW1wb3J0IFF1YWRyaWxhdGVyYWxNb2RlbCBmcm9tICcuLi9tb2RlbC9RdWFkcmlsYXRlcmFsTW9kZWwuanMnO1xyXG5pbXBvcnQgeyBMaW5lLCBTaGFwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsU2lkZURlc2NyaWJlciBmcm9tICcuL1F1YWRyaWxhdGVyYWxTaWRlRGVzY3JpYmVyLmpzJztcclxuaW1wb3J0IE11bHRpbGluayBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL011bHRpbGluay5qcyc7XHJcbmltcG9ydCByZWxlYXNlX21wMyBmcm9tICcuLi8uLi8uLi8uLi90YW1iby9zb3VuZHMvcmVsZWFzZV9tcDMuanMnO1xyXG5pbXBvcnQgQm91bmRzMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvQm91bmRzMi5qcyc7XHJcbmltcG9ydCBTaWRlVGlja3NOb2RlIGZyb20gJy4vU2lkZVRpY2tzTm9kZS5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsTW92YWJsZU5vZGUsIHsgUXVhZHJpbGF0ZXJhbE1vdmFibGVOb2RlT3B0aW9ucyB9IGZyb20gJy4vUXVhZHJpbGF0ZXJhbE1vdmFibGVOb2RlLmpzJztcclxuaW1wb3J0IFN0cmljdE9taXQgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL1N0cmljdE9taXQuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplLCB7IEVtcHR5U2VsZk9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcclxuXHJcbi8vIFRoZSBkaWxhdGlvbiBhcm91bmQgc2lkZSBzaGFwZXMgd2hlbiBkcmF3aW5nIHRoZSBmb2N1cyBoaWdobGlnaHQuXHJcbmNvbnN0IEZPQ1VTX0hJR0hMSUdIVF9ESUxBVElPTiA9IDE1O1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IEVtcHR5U2VsZk9wdGlvbnM7XHJcbnR5cGUgU2lkZU5vZGVPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBTdHJpY3RPbWl0PFF1YWRyaWxhdGVyYWxNb3ZhYmxlTm9kZU9wdGlvbnMsICdncmFiYmVkU291bmRPdXRwdXRMZXZlbCcgfCAnZ3JhYmJlZFNvdW5kJz47XHJcblxyXG4vLyBSZXVzYWJsZSBtYXAgdGhhdCBzYXZlcyBwcm9wb3NlZCB2ZXJ0ZXggcG9zaXRpb25zLCB0byBhdm9pZCBleGNlc3NpdmUgZ2FyYmFnZS5cclxuY29uc3Qgc2NyYXRjaExhYmVsVG9Qb3NpdGlvbk1hcDogVmVydGV4TGFiZWxUb1Byb3Bvc2VkUG9zaXRpb25NYXAgPSBuZXcgTWFwKCk7XHJcblxyXG5jbGFzcyBRdWFkcmlsYXRlcmFsU2lkZU5vZGUgZXh0ZW5kcyBRdWFkcmlsYXRlcmFsTW92YWJsZU5vZGUge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgcXVhZHJpbGF0ZXJhbE1vZGVsOiBRdWFkcmlsYXRlcmFsTW9kZWw7XHJcbiAgcHVibGljIHJlYWRvbmx5IHNpZGU6IFF1YWRyaWxhdGVyYWxTaWRlO1xyXG5cclxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgZXF1aXZhbGVudCBzaWRlIHdpdGggdGhlIHR3byByZWxldmFudCB2ZXJ0aWNlcyBpbiB0aGUgc2NyYXRjaCBtb2RlbC5cclxuICBwcml2YXRlIHNjcmF0Y2hTaWRlOiBRdWFkcmlsYXRlcmFsU2lkZTtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxyXG4gICAgcXVhZHJpbGF0ZXJhbE1vZGVsOiBRdWFkcmlsYXRlcmFsTW9kZWwsXHJcbiAgICBzaWRlOiBRdWFkcmlsYXRlcmFsU2lkZSxcclxuICAgIHNjcmF0Y2hTaWRlOiBRdWFkcmlsYXRlcmFsU2lkZSxcclxuICAgIHNpZGVEZXNjcmliZXI6IFF1YWRyaWxhdGVyYWxTaWRlRGVzY3JpYmVyLFxyXG4gICAgbW9kZWxWaWV3VHJhbnNmb3JtOiBNb2RlbFZpZXdUcmFuc2Zvcm0yLFxyXG4gICAgcHJvdmlkZWRPcHRpb25zPzogU2lkZU5vZGVPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8U2lkZU5vZGVPcHRpb25zLCBTZWxmT3B0aW9ucywgUXVhZHJpbGF0ZXJhbE1vdmFibGVOb2RlT3B0aW9ucz4oKSgge1xyXG5cclxuICAgICAgLy8gVGhlICdyZWxlYXNlJyBzb3VuZCBpcyB1c2VkIGluc3RlYWQgb2YgdGhlICdncmFiJyB0byBkaXN0aW5ndWlzaCBzaWRlcyBmcm9tIHZlcnRpY2VzXHJcbiAgICAgIGdyYWJiZWRTb3VuZDogcmVsZWFzZV9tcDMsXHJcbiAgICAgIGdyYWJiZWRTb3VuZE91dHB1dExldmVsOiAwLjhcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIGNvbnN0IHNpZGVQYXRoID0gbmV3IFBhdGgoIG51bGwgKTtcclxuICAgIHN1cGVyKCBzaWRlLCBtb2RlbFZpZXdUcmFuc2Zvcm0sIHNpZGVQYXRoLCBvcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy5zaWRlID0gc2lkZTtcclxuICAgIHRoaXMuc2NyYXRjaFNpZGUgPSBzY3JhdGNoU2lkZTtcclxuICAgIHRoaXMucXVhZHJpbGF0ZXJhbE1vZGVsID0gcXVhZHJpbGF0ZXJhbE1vZGVsO1xyXG5cclxuICAgIGNvbnN0IHRpY2tzTm9kZSA9IG5ldyBTaWRlVGlja3NOb2RlKCBzaWRlLCBtb2RlbFZpZXdUcmFuc2Zvcm0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIHRpY2tzTm9kZSApO1xyXG5cclxuICAgIGNvbnN0IG1hcmtlcnNWaXNpYmxlUHJvcGVydHkgPSBxdWFkcmlsYXRlcmFsTW9kZWwudmlzaWJpbGl0eU1vZGVsLm1hcmtlcnNWaXNpYmxlUHJvcGVydHk7XHJcblxyXG4gICAgLy8gUmV1c2FibGUgbGluZU5vZGUgZm9yIGNhbGN1bGF0aW5nIHRoZSBzaGFwZSBvZiB0aGUgZm9jdXMgaGlnaGxpZ2h0XHJcbiAgICBjb25zdCBsaW5lTm9kZSA9IG5ldyBMaW5lTm9kZSggMCwgMCwgMCwgMCApO1xyXG5cclxuICAgIC8vIGxpc3RlbmVyc1xyXG4gICAgTXVsdGlsaW5rLm11bHRpbGluayggWyBzaWRlLm1vZGVsTGluZVByb3BlcnR5LCBtYXJrZXJzVmlzaWJsZVByb3BlcnR5IF0sICggbW9kZWxMaW5lLCBtYXJrZXJzVmlzaWJsZSApID0+IHtcclxuICAgICAgdGlja3NOb2RlLnZpc2libGUgPSBtYXJrZXJzVmlzaWJsZTtcclxuXHJcbiAgICAgIC8vIFRoZSBTaGFwZSBmb3Igb3VyIFBhdGggLSBkcmF3biBpbiBtb2RlbCBjb29yZGluYXRlcyB1bnRpbCBhIHRyYW5zZm9ybSBhdCB0aGUgZW5kXHJcbiAgICAgIGNvbnN0IGxpbmVTaGFwZSA9IG5ldyBTaGFwZSgpO1xyXG5cclxuICAgICAgaWYgKCBtYXJrZXJzVmlzaWJsZSApIHtcclxuXHJcbiAgICAgICAgLy8gSWYgbWFya2VycyBhcmUgdmlzaWJsZSB3ZSBuZWVkIHRvIGRyYXcgZWFjaCB1bml0IHNlZ21lbnQuIEJyZWFrIHRoZSBsaW5lIGludG8gbXVsdGlwbGUgc2VnbWVudHMuXHJcbiAgICAgICAgY29uc3QgbGluZVNlZ21lbnRzID0gW107XHJcblxyXG4gICAgICAgIC8vIFRoZSBsZW5ndGggb2YgYSBzZWdtZW50IHBhcmFtZXRyaWNhbGx5IHJlbGF0aXZlIHRvIHRoZSBmdWxsIGxpbmUgbGVuZ3RoXHJcbiAgICAgICAgY29uc3QgcGFyYW1ldHJpY1NlZ21lbnRMZW5ndGggPSBRdWFkcmlsYXRlcmFsU2lkZS5TSURFX1NFR01FTlRfTEVOR1RIIC8gbW9kZWxMaW5lLmdldEFyY0xlbmd0aCgpO1xyXG5cclxuICAgICAgICBjb25zdCBudW1iZXJPZkZ1bGxTZWdtZW50cyA9IE1hdGguZmxvb3IoIDEgLyBwYXJhbWV0cmljU2VnbWVudExlbmd0aCApO1xyXG4gICAgICAgIGxldCB0ID0gMDtcclxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkZ1bGxTZWdtZW50cyAmJiB0IDwgMTsgaSsrICkge1xyXG4gICAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0gTWF0aC5taW4oIHQgKyBwYXJhbWV0cmljU2VnbWVudExlbmd0aCwgMSApO1xyXG4gICAgICAgICAgbGluZVNlZ21lbnRzLnB1c2goIG5ldyBMaW5lKCBtb2RlbExpbmUucG9zaXRpb25BdCggdCApLCBtb2RlbExpbmUucG9zaXRpb25BdCggbmV4dFBvc2l0aW9uICkgKSApO1xyXG4gICAgICAgICAgdCA9IG5leHRQb3NpdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRoZSBmaW5hbCBzZWdtZW50IHNob3VsZCBiZSB0aGUgcmVtYWluZGVyIGZyb20gMSAocGFyYW1ldHJpYyBlbmQpIHRvIHRoZSBsYXN0IGZ1bGwgc2VnbWVudFxyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIDEgLSB0ID49IDAsICd3ZSBjYW5ub3QgaGF2ZSBnb25lIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBmdWxsIGxpbmUgcGFyYW1ldHJpY2FsbHknICk7XHJcblxyXG4gICAgICAgIC8vIEFkIHRoZSByZW1haW5pbmcgcG9ydGlvbiBvZiBhIHNlZ21lbnQgaWYgdGhlcmUgaXMgb25lLiB0IG1pZ2h0IG5vdCBiZSBleGFjdGx5IG9uZSBidXQgY2xvc2UgZW5vdWdoXHJcbiAgICAgICAgLy8gdGhhdCBsaW5lLnBvc2l0aW9uQXQgcHJvZHVjZXMgYSBsaW5lIHdpdGggemVybyBsZW5ndGgsIHNvIHdlIG9ubHkgYWRkIGFub3RoZXIgc2VnbWVudCBpZiBpdCBpcyBsYXJnZSBlbm91Z2guXHJcbiAgICAgICAgaWYgKCAxIC0gdCA+IDAuMDAwNSApIHtcclxuICAgICAgICAgIGNvbnN0IHJlbWFpbmRlckxpbmUgPSBuZXcgTGluZSggbW9kZWxMaW5lLnBvc2l0aW9uQXQoIHQgKSwgbW9kZWxMaW5lLnBvc2l0aW9uQXQoIDEgKSApO1xyXG4gICAgICAgICAgbGluZVNlZ21lbnRzLnB1c2goIHJlbWFpbmRlckxpbmUgKTtcclxuXHJcbiAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0IHdhcyBsYXJnZSBlbm91Z2ggdGhhdCB3ZSBkaWRudCBjcmVhdGUgYSB6ZXJvLWxlbmd0aCBsaW5lXHJcbiAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhcmVtYWluZGVyTGluZS5zdGFydC5lcXVhbHMoIHJlbWFpbmRlckxpbmUuZW5kICksICdTaG91bGQgYmUgYSBub24temVybyBsZW5ndGggcmVtYWluZGVyIGZvciB0aGUgbGluZSBpbiB0aGlzIGNhc2UnICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByaWdodFN0cm9rZXM6IExpbmVbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGxlZnRTdHJva2VzOiBMaW5lW10gPSBbXTtcclxuICAgICAgICBsaW5lU2VnbWVudHMuZm9yRWFjaCggKCBsaW5lU2VnbWVudCwgaW5kZXggKSA9PiB7XHJcblxyXG4gICAgICAgICAgLy8gc3Ryb2tlIGZ1bmN0aW9ucyBkaXZpZGUgd2lkdGggYnkgdHdvIGZvciB1c1xyXG4gICAgICAgICAgY29uc3Qgc3Ryb2tlUmlnaHQgPSBsaW5lU2VnbWVudC5zdHJva2VSaWdodCggUXVhZHJpbGF0ZXJhbFNpZGUuU0lERV9XSURUSCApO1xyXG4gICAgICAgICAgY29uc3Qgc3Ryb2tlTGVmdCA9IGxpbmVTZWdtZW50LnN0cm9rZUxlZnQoIFF1YWRyaWxhdGVyYWxTaWRlLlNJREVfV0lEVEggKTtcclxuXHJcbiAgICAgICAgICByaWdodFN0cm9rZXMucHVzaCggc3Ryb2tlUmlnaHRbIDAgXSApO1xyXG4gICAgICAgICAgbGVmdFN0cm9rZXMucHVzaCggc3Ryb2tlTGVmdFsgMCBdICk7XHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgICAgICByaWdodFN0cm9rZXMuZm9yRWFjaCggKCByaWdodFN0cm9rZSwgaW5kZXggKSA9PiB7XHJcbiAgICAgICAgICBsaW5lU2hhcGUubW92ZVRvUG9pbnQoIHJpZ2h0U3Ryb2tlLnN0YXJ0ICk7XHJcbiAgICAgICAgICBsaW5lU2hhcGUubGluZVRvUG9pbnQoIHJpZ2h0U3Ryb2tlLmVuZCApO1xyXG4gICAgICAgICAgbGluZVNoYXBlLmxpbmVUb1BvaW50KCBsZWZ0U3Ryb2tlc1sgaW5kZXggXS5zdGFydCApO1xyXG4gICAgICAgICAgbGluZVNoYXBlLmxpbmVUb1BvaW50KCBsZWZ0U3Ryb2tlc1sgaW5kZXggXS5lbmQgKTtcclxuXHJcbiAgICAgICAgICAvLyBzbyB0aGF0IGZpbGwgd2lsbCBmaWxsIGVhY2ggc2VnbWVudCBpbmRpdmlkdWFsbHkgYW5kIHNvIHdlIHNlZSBzdHJva2VzIGluIGJldHdlZW4gZWFjaCBzZWdtZW50XHJcbiAgICAgICAgICBsaW5lU2hhcGUuY2xvc2UoKTtcclxuICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgIC8vIG9ubHkgdG8gdGhlIHJlZHJhd2luZyB3b3JrIGZvciB0aWNrcyB3aGVuIHRoZXkgYXJlIHZpc2libGVcclxuICAgICAgICB0aWNrc05vZGUucmVkcmF3KCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIGp1c3QgYSByZWN0YW5ndWxhciBwYXRoIGFsb25nIHRoZSBsaW5lIHdpdGggdGhlIHdpZHRoIG9mIFNJREVfV0lEVEhcclxuICAgICAgICBjb25zdCByaWdodFN0cm9rZSA9IG1vZGVsTGluZS5zdHJva2VSaWdodCggUXVhZHJpbGF0ZXJhbFNpZGUuU0lERV9XSURUSCApO1xyXG4gICAgICAgIGNvbnN0IGxlZnRTdHJva2UgPSBtb2RlbExpbmUuc3Ryb2tlTGVmdCggUXVhZHJpbGF0ZXJhbFNpZGUuU0lERV9XSURUSCApO1xyXG5cclxuICAgICAgICBsaW5lU2hhcGUubW92ZVRvUG9pbnQoIHJpZ2h0U3Ryb2tlWyAwIF0uc3RhcnQgKTtcclxuICAgICAgICBsaW5lU2hhcGUubGluZVRvUG9pbnQoIHJpZ2h0U3Ryb2tlWyAwIF0uZW5kICk7XHJcbiAgICAgICAgbGluZVNoYXBlLmxpbmVUb1BvaW50KCBsZWZ0U3Ryb2tlWyAwIF0uc3RhcnQgKTtcclxuICAgICAgICBsaW5lU2hhcGUubGluZVRvUG9pbnQoIGxlZnRTdHJva2VbIDAgXS5lbmQgKTtcclxuXHJcbiAgICAgICAgbGluZVNoYXBlLmNsb3NlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHRyYW5zZm9ybSBzaGFwZSB0byB2aWV3IGNvb3JkaW5hdGVzXHJcbiAgICAgIHNpZGVQYXRoLnNoYXBlID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3U2hhcGUoIGxpbmVTaGFwZSApO1xyXG5cclxuICAgICAgLy8gRHJhdyB0aGUgY3VzdG9tIGZvY3VzIGhpZ2hsaWdodCBzbyB0aGF0IHRoZSBoaWdobGlnaHQgc3Vycm91bmRzIHRoZSBzaGFwZSBvZiB0aGUgbGluZVxyXG4gICAgICBjb25zdCB2ZXJ0ZXgxVmlld1Bvc2l0aW9uID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3UG9zaXRpb24oIG1vZGVsTGluZS5zdGFydCApO1xyXG4gICAgICBjb25zdCB2ZXJ0ZXgyVmlld1Bvc2l0aW9uID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3UG9zaXRpb24oIG1vZGVsTGluZS5lbmQgKTtcclxuICAgICAgbGluZU5vZGUuc2V0TGluZSggdmVydGV4MVZpZXdQb3NpdGlvbi54LCB2ZXJ0ZXgxVmlld1Bvc2l0aW9uLnksIHZlcnRleDJWaWV3UG9zaXRpb24ueCwgdmVydGV4MlZpZXdQb3NpdGlvbi55ICk7XHJcbiAgICAgIGxpbmVOb2RlLmxpbmVXaWR0aCA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhWCggUXVhZHJpbGF0ZXJhbFNpZGUuU0lERV9XSURUSCApICsgRk9DVVNfSElHSExJR0hUX0RJTEFUSU9OO1xyXG4gICAgICB0aGlzLmZvY3VzSGlnaGxpZ2h0ID0gbGluZU5vZGUuZ2V0U3Ryb2tlZFNoYXBlKCk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgY29uc3Qga2V5Ym9hcmREcmFnTGlzdGVuZXIgPSBuZXcgS2V5Ym9hcmREcmFnTGlzdGVuZXIoIHtcclxuICAgICAgZHJhZ0RlbHRhOiB0aGlzLmxhcmdlVmlld0RyYWdEZWx0YSxcclxuICAgICAgc2hpZnREcmFnRGVsdGE6IHRoaXMuc21hbGxWaWV3RHJhZ0RlbHRhLFxyXG4gICAgICB0cmFuc2Zvcm06IG1vZGVsVmlld1RyYW5zZm9ybSxcclxuICAgICAgZHJhZzogKCB2ZWN0b3JEZWx0YTogVmVjdG9yMiApID0+IHtcclxuICAgICAgICB0aGlzLm1vdmVWZXJ0aWNlc0Zyb21Nb2RlbERlbHRhKCB2ZWN0b3JEZWx0YSApO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgbW92ZU9uSG9sZERlbGF5OiA3NTAsXHJcbiAgICAgIG1vdmVPbkhvbGRJbnRlcnZhbDogNTAsXHJcblxyXG4gICAgICB0YW5kZW06IHByb3ZpZGVkT3B0aW9ucz8udGFuZGVtPy5jcmVhdGVUYW5kZW0oICdrZXlib2FyZERyYWdMaXN0ZW5lcicgKVxyXG4gICAgfSApO1xyXG4gICAgdGhpcy5hZGRJbnB1dExpc3RlbmVyKCBrZXlib2FyZERyYWdMaXN0ZW5lciApO1xyXG5cclxuICAgIC8vIFZlY3RvcnMgYmV0d2VlbiB0aGUgc3RhcnQgcG9zaXRpb24gZHVyaW5nIGRyYWcgYW5kIGVhY2ggdmVydGV4IHNvIHRoYXQgd2UgY2FuIHRyYW5zbGF0ZSB2ZXJ0ZXggcG9zaXRpb25zXHJcbiAgICAvLyByZWxhdGl2ZSB0byBhIHBvaW50ZXIgcG9zaXRpb24gb24gYSBzaWRlLlxyXG4gICAgbGV0IHZlY3RvclRvVmVydGV4MTogbnVsbCB8IFZlY3RvcjIgPSBudWxsO1xyXG4gICAgbGV0IHZlY3RvclRvVmVydGV4MjogbnVsbCB8IFZlY3RvcjIgPSBudWxsO1xyXG5cclxuICAgIGxldCB2ZXJ0ZXgxU3RhcnRQb3NpdGlvbiA9IHNpZGUudmVydGV4MS5wb3NpdGlvblByb3BlcnR5LnZhbHVlO1xyXG4gICAgbGV0IHZlcnRleDJTdGFydFBvc2l0aW9uID0gc2lkZS52ZXJ0ZXgyLnBvc2l0aW9uUHJvcGVydHkudmFsdWU7XHJcblxyXG4gICAgdGhpcy5hZGRJbnB1dExpc3RlbmVyKCBuZXcgRHJhZ0xpc3RlbmVyKCB7XHJcbiAgICAgIHRyYW5zZm9ybTogbW9kZWxWaWV3VHJhbnNmb3JtLFxyXG4gICAgICBzdGFydDogKCBldmVudCwgbGlzdGVuZXIgKSA9PiB7XHJcbiAgICAgICAgc2lkZS5pc1ByZXNzZWRQcm9wZXJ0eS52YWx1ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIHBvaW50IGluIHRoZSBjb29yZGluYXRlIGZyYW1lIG9mIHRoZSBwbGF5IGFyZWEsIHRoZW4gaW4gbW9kZWwgY29vcmRpbmF0ZXNcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBldmVudC5wb2ludGVyLnBvaW50LCAnSG93IGNvdWxkIHRoZXJlIG5vdCBiZSBhIHBvaW50IGZyb20gYW4gZXZlbnQ/JyApO1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBvaW50ID0gdGhpcy5nbG9iYWxUb1BhcmVudFBvaW50KCBldmVudC5wb2ludGVyLnBvaW50ICk7XHJcbiAgICAgICAgY29uc3QgbW9kZWxQb2ludCA9IG1vZGVsVmlld1RyYW5zZm9ybS52aWV3VG9Nb2RlbFBvc2l0aW9uKCBwYXJlbnRQb2ludCApO1xyXG5cclxuICAgICAgICB2ZWN0b3JUb1ZlcnRleDEgPSAoIHNpZGUudmVydGV4MS5wb3NpdGlvblByb3BlcnR5LnZhbHVlICkubWludXMoIG1vZGVsUG9pbnQgKTtcclxuICAgICAgICB2ZWN0b3JUb1ZlcnRleDIgPSAoIHNpZGUudmVydGV4Mi5wb3NpdGlvblByb3BlcnR5LnZhbHVlICkubWludXMoIG1vZGVsUG9pbnQgKTtcclxuXHJcbiAgICAgICAgdmVydGV4MVN0YXJ0UG9zaXRpb24gPSBzaWRlLnZlcnRleDEucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZTtcclxuICAgICAgICB2ZXJ0ZXgyU3RhcnRQb3NpdGlvbiA9IHNpZGUudmVydGV4Mi5wb3NpdGlvblByb3BlcnR5LnZhbHVlO1xyXG4gICAgICB9LFxyXG4gICAgICBlbmQ6ICgpID0+IHtcclxuICAgICAgICBzaWRlLmlzUHJlc3NlZFByb3BlcnR5LnZhbHVlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG1vdGlvbiBzcGVhayBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIHNpZGUuIElmIHRoZXJlIGlzIG1vdmVtZW50IGR1cmluZyBkcmFnIG90aGVyXHJcbiAgICAgICAgLy8gcmVzcG9uc2VzIGRlc2NyaWJpbmcgdGhlIGNoYW5nZSB3aWxsIGJlIHVzZWQuXHJcbiAgICAgICAgY29uc3QgdmVydGV4MVBvc2l0aW9uID0gc2lkZS52ZXJ0ZXgxLnBvc2l0aW9uUHJvcGVydHkudmFsdWU7XHJcbiAgICAgICAgY29uc3QgdmVydGV4MlBvc2l0aW9uID0gc2lkZS52ZXJ0ZXgyLnBvc2l0aW9uUHJvcGVydHkudmFsdWU7XHJcbiAgICAgICAgaWYgKCB2ZXJ0ZXgxU3RhcnRQb3NpdGlvbiA9PT0gdmVydGV4MVBvc2l0aW9uICYmIHZlcnRleDJTdGFydFBvc2l0aW9uID09PSB2ZXJ0ZXgyUG9zaXRpb24gKSB7XHJcbiAgICAgICAgICB0aGlzLnZvaWNpbmdTcGVha0Z1bGxSZXNwb25zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgZHJhZzogKCBldmVudDogU2NlbmVyeUV2ZW50LCBsaXN0ZW5lcjogRHJhZ0xpc3RlbmVyICkgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXgxUHJlc3NlZCA9IHNpZGUudmVydGV4MS5pc1ByZXNzZWRQcm9wZXJ0eS52YWx1ZTtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXgyUHJlc3NlZCA9IHNpZGUudmVydGV4Mi5pc1ByZXNzZWRQcm9wZXJ0eS52YWx1ZTtcclxuXHJcbiAgICAgICAgLy8gQSBzaWRlIGNhbm5vdCBiZSBkcmFnZ2VkIHdoaWxlIG9uZSBvZiBpdHMgVmVydGljZXMgaXMgZHJhZ2dlZCAobXVsdGl0b3VjaClcclxuICAgICAgICBpZiAoICF2ZXJ0ZXgxUHJlc3NlZCAmJiAhdmVydGV4MlByZXNzZWQgKSB7XHJcblxyXG4gICAgICAgICAgLy8gcG9pbnQgaW4gdGhlIGNvb3JkaW5hdGUgZnJhbWUgb2YgdGhlIHBsYXkgYXJlYSwgdGhlbiBpbiBtb2RlbCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgY29uc3QgcGFyZW50UG9pbnQgPSB0aGlzLmdsb2JhbFRvUGFyZW50UG9pbnQoIGV2ZW50LnBvaW50ZXIucG9pbnQgKTtcclxuICAgICAgICAgIGNvbnN0IG1vZGVsUG9pbnQgPSBtb2RlbFZpZXdUcmFuc2Zvcm0udmlld1RvTW9kZWxQb3NpdGlvbiggcGFyZW50UG9pbnQgKTtcclxuXHJcbiAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2ZWN0b3JUb1ZlcnRleDEsICd2ZWN0b3JUb1ZlcnRleDEgc2hvdWxkIGhhdmUgYmVlbiBkZWZpbmVkIGF0IHN0YXJ0IG9mIGRyYWcnICk7XHJcbiAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2ZWN0b3JUb1ZlcnRleDIsICd2ZWN0b3JUb1ZlcnRleDEgc2hvdWxkIGhhdmUgYmVlbiBkZWZpbmVkIGF0IHN0YXJ0IG9mIGRyYWcnICk7XHJcbiAgICAgICAgICBjb25zdCBtb2RlbFZlcnRleDFQb3NpdGlvbiA9IG1vZGVsUG9pbnQucGx1cyggdmVjdG9yVG9WZXJ0ZXgxISApO1xyXG4gICAgICAgICAgY29uc3QgbW9kZWxWZXJ0ZXgyUG9zaXRpb24gPSBtb2RlbFBvaW50LnBsdXMoIHZlY3RvclRvVmVydGV4MiEgKTtcclxuXHJcbiAgICAgICAgICAvLyBBYnNvbHV0ZSBib3VuZGluZyBib3ggYXJvdW5kIHRoZSBzaWRlIC0gdXNlZnVsIGZvciBkZXRlcm1pbmUgYWxsb3dhYmxlIHZlcnRleCBwb3NpdGlvbnMgd2hpbGUgc3VwcG9ydGluZ1xyXG4gICAgICAgICAgLy8gc21vb3RoIGRyYWdnaW5nXHJcbiAgICAgICAgICBjb25zdCBzaWRlQm91bmRzID0gbmV3IEJvdW5kczIoIDAsIDAsIDAsIDAgKTtcclxuICAgICAgICAgIHNpZGVCb3VuZHMuYWRkUG9pbnQoIG1vZGVsVmVydGV4MVBvc2l0aW9uICk7XHJcbiAgICAgICAgICBzaWRlQm91bmRzLmFkZFBvaW50KCBtb2RlbFZlcnRleDJQb3NpdGlvbiApO1xyXG5cclxuICAgICAgICAgIC8vIG5vdyBzaGlmdCB0aGUgcHJvcG9zZWQgcG9zaXRpb25zIGJ5IGEgZGVsdGEgdGhhdCB3b3VsZCBrZWVwIHRoZSBzaWRlQm91bmRzIHdpdGhpbiB2ZXJ0ZXhEcmFnQm91bmRzXHJcbiAgICAgICAgICBjb25zdCB2ZXJ0ZXhEcmFnQm91bmRzID0gcXVhZHJpbGF0ZXJhbE1vZGVsLnZlcnRleERyYWdCb3VuZHM7XHJcbiAgICAgICAgICBjb25zdCBjb3JyZWN0aW5nVmVjdG9yID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBpbkJvdW5kcyA9IHZlcnRleERyYWdCb3VuZHMuY29udGFpbnNCb3VuZHMoIHNpZGVCb3VuZHMgKTtcclxuICAgICAgICAgIGlmICggIWluQm91bmRzICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBzaWRlQm91bmRzLm1heFkgPiB2ZXJ0ZXhEcmFnQm91bmRzLm1heFkgKSB7XHJcbiAgICAgICAgICAgICAgY29ycmVjdGluZ1ZlY3Rvci55ID0gdmVydGV4RHJhZ0JvdW5kcy5tYXhZIC0gc2lkZUJvdW5kcy5tYXhZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCBzaWRlQm91bmRzLm1pblkgPCB2ZXJ0ZXhEcmFnQm91bmRzLm1pblkgKSB7XHJcbiAgICAgICAgICAgICAgY29ycmVjdGluZ1ZlY3Rvci55ID0gdmVydGV4RHJhZ0JvdW5kcy5taW5ZIC0gc2lkZUJvdW5kcy5taW5ZO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHNpZGVCb3VuZHMubWF4WCA+IHZlcnRleERyYWdCb3VuZHMubWF4WCApIHtcclxuICAgICAgICAgICAgICBjb3JyZWN0aW5nVmVjdG9yLnggPSB2ZXJ0ZXhEcmFnQm91bmRzLm1heFggLSBzaWRlQm91bmRzLm1heFg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIHNpZGVCb3VuZHMubWluWCA8IHZlcnRleERyYWdCb3VuZHMubWluWCApIHtcclxuICAgICAgICAgICAgICBjb3JyZWN0aW5nVmVjdG9yLnggPSB2ZXJ0ZXhEcmFnQm91bmRzLm1pblggLSBzaWRlQm91bmRzLm1pblg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCBib3VuZHNDb25zdHJhaW5lZFZlcnRleDFQb3NpdGlvbiA9IG1vZGVsVmVydGV4MVBvc2l0aW9uLnBsdXMoIGNvcnJlY3RpbmdWZWN0b3IgKTtcclxuICAgICAgICAgIGNvbnN0IGJvdW5kc0NvbnN0cmFpbmVkVmVydGV4MlBvc2l0aW9uID0gbW9kZWxWZXJ0ZXgyUG9zaXRpb24ucGx1cyggY29ycmVjdGluZ1ZlY3RvciApO1xyXG5cclxuICAgICAgICAgIC8vIGNvbnN0cmFpbiBlYWNoIHRvIHRoZSBtb2RlbCBncmlkLCBhbGxvd2luZyBmb3IgZGlhZ29uYWwgbW92ZW1lbnRcclxuICAgICAgICAgIGNvbnN0IGdyaWRDb25zdHJhaW5lZFZlcnRleDFQb3NpdGlvbiA9IHF1YWRyaWxhdGVyYWxNb2RlbC5nZXRDbG9zZXN0R3JpZFBvc2l0aW9uQWxvbmdEaWFnb25hbCggc2lkZS52ZXJ0ZXgxLnBvc2l0aW9uUHJvcGVydHkudmFsdWUsIGJvdW5kc0NvbnN0cmFpbmVkVmVydGV4MVBvc2l0aW9uICk7XHJcbiAgICAgICAgICBjb25zdCBncmlkQ29uc3RyYWluZWRWZXJ0ZXgyUG9zaXRpb24gPSBxdWFkcmlsYXRlcmFsTW9kZWwuZ2V0Q2xvc2VzdEdyaWRQb3NpdGlvbkFsb25nRGlhZ29uYWwoIHNpZGUudmVydGV4Mi5wb3NpdGlvblByb3BlcnR5LnZhbHVlLCBib3VuZHNDb25zdHJhaW5lZFZlcnRleDJQb3NpdGlvbiApO1xyXG5cclxuICAgICAgICAgIC8vIGRlbHRhcyBmb3IgZWFjaCBRdWFkcmlsYXRlcmFsVmVydGV4IG11c3QgYmUgdGhlIHNhbWUgZm9yIHRoZSBzaWRlIHRvIG5vdCBjaGFuZ2UgdGlsdCB3aGlsZSBkcmFnZ2luZyAtIHVwZGF0ZVxyXG4gICAgICAgICAgLy8gYm90aCBWZXJ0aWNlcyBieSB0aGUgc21hbGxlc3QgdHJhbnNsYXRpb24gdmVjdG9yIHNvIHRoZXkgbW92ZSB0b2dldGhlclxyXG4gICAgICAgICAgY29uc3Qgc21hbGxlc3REZWx0YVZlY3RvciA9IHRoaXMuZ2V0U21hbGxlc3RUcmFuc2xhdGlvblZlY3RvciggZ3JpZENvbnN0cmFpbmVkVmVydGV4MVBvc2l0aW9uLCBncmlkQ29uc3RyYWluZWRWZXJ0ZXgyUG9zaXRpb24gKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBwcm9wb3NlZFZlcnRleDFQb3NpdGlvbiA9IHNpZGUudmVydGV4MS5wb3NpdGlvblByb3BlcnR5LnZhbHVlLnBsdXMoIHNtYWxsZXN0RGVsdGFWZWN0b3IgKTtcclxuICAgICAgICAgIGNvbnN0IHByb3Bvc2VkVmVydGV4MlBvc2l0aW9uID0gc2lkZS52ZXJ0ZXgyLnBvc2l0aW9uUHJvcGVydHkudmFsdWUucGx1cyggc21hbGxlc3REZWx0YVZlY3RvciApO1xyXG5cclxuICAgICAgICAgIHNjcmF0Y2hMYWJlbFRvUG9zaXRpb25NYXAuY2xlYXIoKTtcclxuICAgICAgICAgIHNjcmF0Y2hMYWJlbFRvUG9zaXRpb25NYXAuc2V0KCBzaWRlLnZlcnRleDEudmVydGV4TGFiZWwsIHByb3Bvc2VkVmVydGV4MVBvc2l0aW9uICk7XHJcbiAgICAgICAgICBzY3JhdGNoTGFiZWxUb1Bvc2l0aW9uTWFwLnNldCggc2lkZS52ZXJ0ZXgyLnZlcnRleExhYmVsLCBwcm9wb3NlZFZlcnRleDJQb3NpdGlvbiApO1xyXG5cclxuICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIHBvc2l0aW9ucyBpZiBib3RoIGFyZSBhbGxvd2VkXHJcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbnNBbGxvd2VkID0gcXVhZHJpbGF0ZXJhbE1vZGVsLmFyZVZlcnRleFBvc2l0aW9uc0FsbG93ZWQoIHNjcmF0Y2hMYWJlbFRvUG9zaXRpb25NYXAgKTtcclxuICAgICAgICAgIGlmICggcG9zaXRpb25zQWxsb3dlZCApIHtcclxuICAgICAgICAgICAgdGhpcy5xdWFkcmlsYXRlcmFsTW9kZWwucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwuc2V0VmVydGV4UG9zaXRpb25zKCBzY3JhdGNoTGFiZWxUb1Bvc2l0aW9uTWFwICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy51cGRhdGVCbG9ja2VkU3RhdGUoICFwb3NpdGlvbnNBbGxvd2VkLCAhaW5Cb3VuZHMgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICB0YW5kZW06IHByb3ZpZGVkT3B0aW9ucz8udGFuZGVtPy5jcmVhdGVUYW5kZW0oICdkcmFnTGlzdGVuZXInIClcclxuICAgIH0gKSApO1xyXG5cclxuICAgIC8vIHZvaWNpbmcgLSByZS1nZW5lcmF0ZSB0aGUgdm9pY2luZyBkZXNjcmlwdGlvbnMgd2hlbiBQcm9wZXJ0aWVzIHVzZWQgZm9yIGNvbnRlbnQgY2hhbmdlXHJcbiAgICB0aGlzLnF1YWRyaWxhdGVyYWxNb2RlbC5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC5zaGFwZUNoYW5nZWRFbWl0dGVyLmFkZExpc3RlbmVyKCAoKSA9PiB7XHJcbiAgICAgIHRoaXMudm9pY2luZ09iamVjdFJlc3BvbnNlID0gc2lkZURlc2NyaWJlci5nZXRTaWRlT2JqZWN0UmVzcG9uc2UoKTtcclxuICAgIH0gKTtcclxuICAgIG1hcmtlcnNWaXNpYmxlUHJvcGVydHkubGluayggKCkgPT4ge1xyXG4gICAgICB0aGlzLnZvaWNpbmdPYmplY3RSZXNwb25zZSA9IHNpZGVEZXNjcmliZXIuZ2V0U2lkZU9iamVjdFJlc3BvbnNlKCk7XHJcbiAgICB9ICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldFNtYWxsZXN0VHJhbnNsYXRpb25WZWN0b3IoIHByb3Bvc2VkVmVydGV4MVBvc2l0aW9uOiBWZWN0b3IyLCBwcm9wb3NlZFZlcnRleDJQb3NpdGlvbjogVmVjdG9yMiApOiBWZWN0b3IyIHtcclxuICAgIGNvbnN0IGN1cnJlbnRWZXJ0ZXgxUG9zaXRpb24gPSB0aGlzLnNpZGUudmVydGV4MS5wb3NpdGlvblByb3BlcnR5LnZhbHVlO1xyXG4gICAgY29uc3QgY3VycmVudFZlcnRleDJQb3NpdGlvbiA9IHRoaXMuc2lkZS52ZXJ0ZXgyLnBvc2l0aW9uUHJvcGVydHkudmFsdWU7XHJcblxyXG4gICAgLy8gRWFjaCBRdWFkcmlsYXRlcmFsVmVydGV4IG11c3QgbW92ZSBieSB0aGUgc2FtZSBhbW91bnQgc28gdGhhdCB0aGUgc2lkZSBkb2VzIG5vdCB0aWxlIGR1cmluZyBpbnB1dC4gRmluZCB0aGUgc21hbGxlc3QgY2hhbmdlXHJcbiAgICAvLyBhZnRlciBjb25zdHJhaW5pbmcgdmVydGljZXMgdG8gdGhlIGdyaWQsIGFuZCB3ZSB3aWxsIG1vdmUgYm90aCB2ZXJ0aWNlcyBieSB0aGF0IGRlbHRhLlxyXG4gICAgcmV0dXJuIF8ubWluQnkoIFtcclxuICAgICAgcHJvcG9zZWRWZXJ0ZXgxUG9zaXRpb24ubWludXMoIGN1cnJlbnRWZXJ0ZXgxUG9zaXRpb24gKSxcclxuICAgICAgcHJvcG9zZWRWZXJ0ZXgyUG9zaXRpb24ubWludXMoIGN1cnJlbnRWZXJ0ZXgyUG9zaXRpb24gKVxyXG4gICAgXSwgdmVjdG9yID0+IHZlY3Rvci5tYWduaXR1ZGUgKSE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3ZlIGJvdGggdmVydGljZXMgb2YgdGhpcyBzaWRlIGZyb20gdGhlIGNoYW5nZSBpbiBwb3NpdGlvbiBzcGVjaWZpZWQgYnkgZGVsdGFWZWN0b3IuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGVsdGFWZWN0b3IgLSBjaGFuZ2Ugb2YgcG9zaXRpb24gaW4gbW9kZWwgY29vcmRpbmF0ZXNcclxuICAgKi9cclxuICBwcml2YXRlIG1vdmVWZXJ0aWNlc0Zyb21Nb2RlbERlbHRhKCBkZWx0YVZlY3RvcjogVmVjdG9yMiApOiB2b2lkIHtcclxuICAgIGNvbnN0IHNoYXBlTW9kZWwgPSB0aGlzLnF1YWRyaWxhdGVyYWxNb2RlbC5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbDtcclxuICAgIGNvbnN0IHNjcmF0Y2hTaGFwZU1vZGVsID0gdGhpcy5xdWFkcmlsYXRlcmFsTW9kZWwucXVhZHJpbGF0ZXJhbFRlc3RTaGFwZU1vZGVsO1xyXG5cclxuICAgIGNvbnN0IGN1cnJlbnRWZXJ0ZXgxUG9zaXRpb24gPSB0aGlzLnNpZGUudmVydGV4MS5wb3NpdGlvblByb3BlcnR5LnZhbHVlO1xyXG4gICAgY29uc3QgY3VycmVudFZlcnRleDJQb3NpdGlvbiA9IHRoaXMuc2lkZS52ZXJ0ZXgyLnBvc2l0aW9uUHJvcGVydHkudmFsdWU7XHJcblxyXG4gICAgLy8gY29uc3RyYWluIGVhY2ggUXVhZHJpbGF0ZXJhbFZlcnRleCBwb3NpdGlvbiB0byB0aGUgY2xvc2VzdCBhbGxvd2FibGUgZ3JpZCBwb3NpdGlvblxyXG4gICAgY29uc3QgY2xvc2VzdFZlcnRleDFQb3NpdGlvbiA9IHRoaXMucXVhZHJpbGF0ZXJhbE1vZGVsLmdldENsb3Nlc3RHcmlkUG9zaXRpb25JbkRpcmVjdGlvbiggY3VycmVudFZlcnRleDFQb3NpdGlvbiwgZGVsdGFWZWN0b3IgKTtcclxuICAgIGNvbnN0IGNsb3Nlc3RWZXJ0ZXgyUG9zaXRpb24gPSB0aGlzLnF1YWRyaWxhdGVyYWxNb2RlbC5nZXRDbG9zZXN0R3JpZFBvc2l0aW9uSW5EaXJlY3Rpb24oIGN1cnJlbnRWZXJ0ZXgyUG9zaXRpb24sIGRlbHRhVmVjdG9yICk7XHJcblxyXG4gICAgLy8gRWFjaCBRdWFkcmlsYXRlcmFsVmVydGV4IG11c3QgbW92ZSBieSB0aGUgc2FtZSBhbW91bnQgc28gdGhhdCB0aGUgc2lkZSBkb2VzIG5vdCB0aWxlIGR1cmluZyBpbnB1dC4gRmluZCB0aGUgc21hbGxlc3QgY2hhbmdlXHJcbiAgICAvLyBhZnRlciBjb25zdHJhaW5pbmcgdmVydGljZXMgdG8gdGhlIGdyaWQsIGFuZCB3ZSB3aWxsIG1vdmUgYm90aCB2ZXJ0aWNlcyBieSB0aGF0IGRlbHRhLlxyXG4gICAgY29uc3Qgc21hbGxlc3REZWx0YVZlY3RvciA9IHRoaXMuZ2V0U21hbGxlc3RUcmFuc2xhdGlvblZlY3RvciggY2xvc2VzdFZlcnRleDFQb3NpdGlvbiwgY2xvc2VzdFZlcnRleDJQb3NpdGlvbiApO1xyXG5cclxuICAgIGNvbnN0IHByb3Bvc2VkVmVydGV4MVBvc2l0aW9uID0gY3VycmVudFZlcnRleDFQb3NpdGlvbi5wbHVzKCBzbWFsbGVzdERlbHRhVmVjdG9yICk7XHJcbiAgICBjb25zdCBwcm9wb3NlZFZlcnRleDJQb3NpdGlvbiA9IGN1cnJlbnRWZXJ0ZXgyUG9zaXRpb24ucGx1cyggc21hbGxlc3REZWx0YVZlY3RvciApO1xyXG5cclxuICAgIGNvbnN0IHZlcnRleERyYWdCb3VuZHMgPSB0aGlzLnF1YWRyaWxhdGVyYWxNb2RlbC52ZXJ0ZXhEcmFnQm91bmRzO1xyXG4gICAgY29uc3QgaW5Cb3VuZHMgPSB2ZXJ0ZXhEcmFnQm91bmRzLmNvbnRhaW5zUG9pbnQoIHByb3Bvc2VkVmVydGV4MVBvc2l0aW9uICkgJiYgdmVydGV4RHJhZ0JvdW5kcy5jb250YWluc1BvaW50KCBwcm9wb3NlZFZlcnRleDJQb3NpdGlvbiApO1xyXG5cclxuICAgIC8vIHVwZGF0ZSB0aGUgc2NyYXRjaCBtb2RlbCBiZWZvcmUgc2V0dGluZyBwcm9wb3NlZCB2ZXJ0ZXggcG9zaXRpb25zXHJcbiAgICBzY3JhdGNoU2hhcGVNb2RlbC5zZXRGcm9tU2hhcGUoIHNoYXBlTW9kZWwgKTtcclxuXHJcbiAgICAvLyBTZXQgdGhlIHBvc2l0aW9ucyB0byB0aGUgc2NyYXRjaCBtb2RlbCBzbyB0aGF0IHdlIGNhbiB2ZXJpZnkgdGhhdCB0aGlzIHByb2R1Y2VzIGEgdmFsaWQgc2hhcGUuIFNpbmNlIHdlIGFyZVxyXG4gICAgLy8gbW92aW5nIHR3byB2ZXJ0aWNlcyBhdCB0aGUgc2FtZSB0aW1lIHdlIG5lZWQgdG8gY2hlY2sgdGhlIHZhbGlkaXR5IGFmdGVyIGJvdGggaGF2ZSBtb3ZlZCwgY2hlY2tpbmcgdGhlIHNoYXBlXHJcbiAgICAvLyBtb3Zpbmcgb25lIHZlcnRleCBhdCBhIHRpbWUgbWF5IHJlc3VsdCBpbiBpbmNvcnJlY3QgcmVzdWx0cyBzaW5jZSB0aGF0IGlzIG5vdCB0aGUgc2hhcGUgd2UgYXJlIHVsdGltYXRlbHlcclxuICAgIC8vIGdvaW5nIHRvIGNyZWF0ZSB3aXRoIHRoaXMgY2hhbmdlLlxyXG4gICAgc2NyYXRjaExhYmVsVG9Qb3NpdGlvbk1hcC5jbGVhcigpO1xyXG4gICAgc2NyYXRjaExhYmVsVG9Qb3NpdGlvbk1hcC5zZXQoIHRoaXMuc2NyYXRjaFNpZGUudmVydGV4MS52ZXJ0ZXhMYWJlbCwgcHJvcG9zZWRWZXJ0ZXgxUG9zaXRpb24gKTtcclxuICAgIHNjcmF0Y2hMYWJlbFRvUG9zaXRpb25NYXAuc2V0KCB0aGlzLnNjcmF0Y2hTaWRlLnZlcnRleDIudmVydGV4TGFiZWwsIHByb3Bvc2VkVmVydGV4MlBvc2l0aW9uICk7XHJcbiAgICBzY3JhdGNoU2hhcGVNb2RlbC5zZXRWZXJ0ZXhQb3NpdGlvbnMoIHNjcmF0Y2hMYWJlbFRvUG9zaXRpb25NYXAgKTtcclxuXHJcbiAgICBpZiAoIFF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLmlzUXVhZHJpbGF0ZXJhbFNoYXBlQWxsb3dlZCggc2NyYXRjaFNoYXBlTW9kZWwgKSApIHtcclxuXHJcbiAgICAgIC8vIHNpZ25pZnkgdG8gdGhlIEFsZXJ0ZXIgdGhhdCBpdCB3aWxsIGJlIHRpbWUgdG8gZ2VuZXJhdGUgYSBuZXcgb2JqZWN0IHJlc3BvbnNlIGZyb20gaW5wdXRcclxuICAgICAgdGhpcy5zaWRlLnZvaWNpbmdPYmplY3RSZXNwb25zZURpcnR5ID0gdHJ1ZTtcclxuICAgICAgc2hhcGVNb2RlbC5zZXRWZXJ0ZXhQb3NpdGlvbnMoIHNjcmF0Y2hMYWJlbFRvUG9zaXRpb25NYXAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgc2lkZSBpcyBvbmx5IGJsb2NrZWQgYnkgc2hhcGUgaW4gdGhlIGNhc2Ugb2YgY3Jvc3NlZCBxdWFkcmlsYXRlcmFscyAtIGlzUXVhZHJpbGF0ZXJhbFNoYXBlQWxsb3dlZCB3aWxsIHJldHVyblxyXG4gICAgLy8gZmFsc2UgaWYgYSB2ZXJ0ZXggaXMgb3V0IG9mIGJvdW5kcywgYnV0IHRoYXQgc2hvdWxkbid0IGNvdW50IHRvd2FyZCAnYmxvY2tlZCBieSBzaGFwZScgYmVjYXVzZSB0aGVyZSBpcyBhXHJcbiAgICAvLyBzcGVjaWFsIGNoZWNrIGp1c3QgZm9yIGJvdW5kcy5cclxuICAgIGNvbnN0IGlzU2hhcGVBbGxvd2VkID0gUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwuaXNRdWFkcmlsYXRlcmFsU2hhcGVOb3RDcm9zc2VkKCBzY3JhdGNoU2hhcGVNb2RlbCApO1xyXG4gICAgdGhpcy51cGRhdGVCbG9ja2VkU3RhdGUoICFpc1NoYXBlQWxsb3dlZCwgIWluQm91bmRzICk7XHJcbiAgfVxyXG59XHJcblxyXG5xdWFkcmlsYXRlcmFsLnJlZ2lzdGVyKCAnUXVhZHJpbGF0ZXJhbFNpZGVOb2RlJywgUXVhZHJpbGF0ZXJhbFNpZGVOb2RlICk7XHJcbmV4cG9ydCBkZWZhdWx0IFF1YWRyaWxhdGVyYWxTaWRlTm9kZTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVNBLFlBQVksRUFBRUMsb0JBQW9CLEVBQUVDLElBQUksSUFBSUMsUUFBUSxFQUFFQyxJQUFJLFFBQXNCLG1DQUFtQztBQUM1SCxPQUFPQyxhQUFhLE1BQU0sd0JBQXdCO0FBQ2xELE9BQU9DLGlCQUFpQixNQUFNLCtCQUErQjtBQUU3RCxPQUFPQyxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLHVCQUF1QixNQUE0QyxxQ0FBcUM7QUFFL0csU0FBU04sSUFBSSxFQUFF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