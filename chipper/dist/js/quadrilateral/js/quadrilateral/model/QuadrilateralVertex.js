// Copyright 2021-2023, University of Colorado Boulder

/**
 * Models a vertex of the quadrilateral.
 *
 * @author Jesse Greenberg
 */

import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import Property from '../../../../axon/js/Property.js';
import Vector2Property from '../../../../dot/js/Vector2Property.js';
import quadrilateral from '../../quadrilateral.js';
import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import Bounds2 from '../../../../dot/js/Bounds2.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import NullableIO from '../../../../tandem/js/types/NullableIO.js';
import NumberIO from '../../../../tandem/js/types/NumberIO.js';
import QuadrilateralMovable from './QuadrilateralMovable.js';
import QuadrilateralConstants from '../../QuadrilateralConstants.js';
const VERTEX_BOUNDS = new Bounds2(0, 0, QuadrilateralConstants.VERTEX_WIDTH, QuadrilateralConstants.VERTEX_WIDTH);
const HALF_WIDTH = VERTEX_BOUNDS.width / 2;
const HALF_HEIGHT = VERTEX_BOUNDS.height / 2;
export default class QuadrilateralVertex extends QuadrilateralMovable {
  // The position of the vertex in model coordinates.

  // The angle at this vertex of the quadrilateral, null until this vertex is connected to two others because we
  // need three points to form the angle.
  // Identification of this QuadrilateralVertex within the QuadrilateralShape.
  // The Shape in model coordinates that defines where this QuadrilateralVertex can move. It can never
  // go outside this area. The dragAreaProperty is determined by other vertices of the quadrilateral
  // and constraints movement so the quadrilateral can never become crossed or "complex". It is null until
  // the model bounds are defined and this QuadrilateralVertex is connected to others to form the quadrilateral shape.
  // The bounds in model coordinates of this vertex, with dimensions VERTEX_BOUNDS, centered at the value of the
  // positionProperty.
  // Referenced so that we can pass the tandem to Properties as they are dynamically created in the methods below.
  // Properties tracking when a QuadrilateralVertex becomes blocked by ony of the individual sides of model bounds.
  // So that we can trigger some feedback as a QuadrilateralVertex is blocked by new edges of bounds.
  leftConstrainedProperty = new BooleanProperty(false);
  rightConstrainedProperty = new BooleanProperty(false);
  topConstrainedProperty = new BooleanProperty(false);
  bottomConstrainedProperty = new BooleanProperty(false);
  numberOfConstrainingEdgesProperty = new DerivedProperty([this.topConstrainedProperty, this.rightConstrainedProperty, this.bottomConstrainedProperty, this.leftConstrainedProperty], (topConstrained, rightConstrained, bottomConstrained, leftConstrained) => {
    const topVal = topConstrained ? 1 : 0;
    const rightVal = rightConstrained ? 1 : 0;
    const bottomVal = bottomConstrained ? 1 : 0;
    const leftVal = leftConstrained ? 1 : 0;
    return topVal + rightVal + bottomVal + leftVal;
  });

  // A reference to vertices connected to this vertex for so we can calculate the angle at this vertex.
  // The orientation of vertex1 and vertex2 for angle calculations are as shown in the following diagram:
  //        thisVertex
  //          /       \
  //   sideA /         \ sideB
  //        /           \
  // vertex1 --------- vertex2
  // Property that controls how many values to include in the "smoothing" of potential positions when being
  // controlled by a prototype tangible. See smoothPosition().
  // The collection of n <= SMOOTHING_LENGTH number of positions for prototype tangible control. See smoothPosition().
  smoothingPositions = [];

  /**
   * @param initialPosition - The initial position for the QuadrilateralVertex in model coordinates.
   * @param vertexLabel - A label tagging the vertex, so we can look up the equivalent vertex on another shape model
   * @param smoothingLengthProperty - Controlling how many values to use in the position smoothing when connected to
   *                                  a tangible device (prototype).
   * @param tandem
   */
  constructor(initialPosition, vertexLabel, smoothingLengthProperty, tandem) {
    super(tandem);
    this.smoothingLengthProperty = smoothingLengthProperty;
    this.positionProperty = new Vector2Property(initialPosition, {
      tandem: tandem.createTandem('positionProperty')
    });
    this.angleProperty = new Property(null, {
      tandem: tandem.createTandem('angleProperty'),
      phetioValueType: NullableIO(NumberIO)
    });

    // The label for this vertex so we can get the same vertex on another QuadrilateralShapeModel.
    this.vertexLabel = vertexLabel;
    this.vertex1 = null;
    this.vertex2 = null;
    this.dragAreaProperty = new Property(null);
    this.modelBoundsProperty = new DerivedProperty([this.positionProperty], position => {
      return new Bounds2(position.x - HALF_WIDTH, position.y - HALF_HEIGHT, position.x + HALF_WIDTH, position.y + HALF_HEIGHT);
    });
    this.tandem = tandem;
  }

  /**
   * Returns true if this QuadrilateralVertex intersects another.
   */
  overlapsOther(other) {
    assert && assert(other !== this, 'You are trying to see if this vertex overlaps self?');
    return other.modelBoundsProperty.value.intersectsBounds(this.modelBoundsProperty.value);
  }

  /**
   * Set Properties that need to be updated all at once for the quadrilateral shape to a deferred state so that
   * they can be updated together without calling listeners with bad transient states during updates.
   */
  setPropertiesDeferred(deferred) {
    return this.positionProperty.setDeferred(deferred);
  }

  /**
   * Reset this vertex.
   */
  reset() {
    this.positionProperty.reset();
    this.smoothingPositions.length = 0;
  }

  /**
   * Update the angle at this vertex. Uses atan2 to get the angle at this vertex counter-clockwise
   * between 0 and 2 * Math.PI. See
   * https://math.stackexchange.com/questions/878785/how-to-find-an-angle-in-range0-360-between-2-vectors
   *
   * Custom angle claculation used instead of Vector2.angleBetween because we need the angle to span from
   * 0 to 2PI instead of 0 to PI.
   *
   * Assumes the following arrangement of vertices:
   *
   *        thisVertex
   *          /       \
   *   sideA /         \ sideB
   *        /           \
   * vertex1 --------- vertex2
   *
   * This should only be used after all vertex positions have been updated to make sure that the quadrilateral does
   * not appear to exist in incorrect states as positions are updated in the natural listener order. See
   * QuadrilateralShapeModel.updateOrderDependentProperties for more information.
   */
  updateAngle() {
    assert && assert(this.vertex1 && this.vertex2, 'Need connected vertices to determine an angle');
    const vector1 = this.vertex1.positionProperty.value.minus(this.positionProperty.value);
    const vector2 = this.vertex2.positionProperty.value.minus(this.positionProperty.value);
    const dot = vector1.x * vector2.x + vector1.y * vector2.y;
    const det = vector1.x * vector2.y - vector2.x * vector1.y;
    let angle = Math.atan2(det, dot);

    // if the angle is less than zero, we have wrapped around Math.PI and formed a concave shape - the actual
    // angle should be greater than PI
    if (angle < 0) {
      angle = angle + 2 * Math.PI;
    }
    this.angleProperty.value = angle;
  }

  /**
   * Connect this vertex to two others to form an angle and sides of the quadrilateral.
   */
  connectToOthers(vertex1, vertex2) {
    this.vertex1 = vertex1;
    this.vertex2 = vertex2;
  }

  /**
   * "Smooth" the provided position for the vertex by saving it in a collection of positions of max length
   * and returning the average position. Only used for prototype tangible connection.
   */
  smoothPosition(position) {
    this.smoothingPositions.push(position);
    while (this.smoothingPositions.length > this.smoothingLengthProperty.value) {
      this.smoothingPositions.shift();
    }
    return Vector2.average(this.smoothingPositions);
  }
}
quadrilateral.register('QuadrilateralVertex', QuadrilateralVertex);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEZXJpdmVkUHJvcGVydHkiLCJQcm9wZXJ0eSIsIlZlY3RvcjJQcm9wZXJ0eSIsInF1YWRyaWxhdGVyYWwiLCJCb29sZWFuUHJvcGVydHkiLCJCb3VuZHMyIiwiVmVjdG9yMiIsIk51bGxhYmxlSU8iLCJOdW1iZXJJTyIsIlF1YWRyaWxhdGVyYWxNb3ZhYmxlIiwiUXVhZHJpbGF0ZXJhbENvbnN0YW50cyIsIlZFUlRFWF9CT1VORFMiLCJWRVJURVhfV0lEVEgiLCJIQUxGX1dJRFRIIiwid2lkdGgiLCJIQUxGX0hFSUdIVCIsImhlaWdodCIsIlF1YWRyaWxhdGVyYWxWZXJ0ZXgiLCJsZWZ0Q29uc3RyYWluZWRQcm9wZXJ0eSIsInJpZ2h0Q29uc3RyYWluZWRQcm9wZXJ0eSIsInRvcENvbnN0cmFpbmVkUHJvcGVydHkiLCJib3R0b21Db25zdHJhaW5lZFByb3BlcnR5IiwibnVtYmVyT2ZDb25zdHJhaW5pbmdFZGdlc1Byb3BlcnR5IiwidG9wQ29uc3RyYWluZWQiLCJyaWdodENvbnN0cmFpbmVkIiwiYm90dG9tQ29uc3RyYWluZWQiLCJsZWZ0Q29uc3RyYWluZWQiLCJ0b3BWYWwiLCJyaWdodFZhbCIsImJvdHRvbVZhbCIsImxlZnRWYWwiLCJzbW9vdGhpbmdQb3NpdGlvbnMiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxQb3NpdGlvbiIsInZlcnRleExhYmVsIiwic21vb3RoaW5nTGVuZ3RoUHJvcGVydHkiLCJ0YW5kZW0iLCJwb3NpdGlvblByb3BlcnR5IiwiY3JlYXRlVGFuZGVtIiwiYW5nbGVQcm9wZXJ0eSIsInBoZXRpb1ZhbHVlVHlwZSIsInZlcnRleDEiLCJ2ZXJ0ZXgyIiwiZHJhZ0FyZWFQcm9wZXJ0eSIsIm1vZGVsQm91bmRzUHJvcGVydHkiLCJwb3NpdGlvbiIsIngiLCJ5Iiwib3ZlcmxhcHNPdGhlciIsIm90aGVyIiwiYXNzZXJ0IiwidmFsdWUiLCJpbnRlcnNlY3RzQm91bmRzIiwic2V0UHJvcGVydGllc0RlZmVycmVkIiwiZGVmZXJyZWQiLCJzZXREZWZlcnJlZCIsInJlc2V0IiwibGVuZ3RoIiwidXBkYXRlQW5nbGUiLCJ2ZWN0b3IxIiwibWludXMiLCJ2ZWN0b3IyIiwiZG90IiwiZGV0IiwiYW5nbGUiLCJNYXRoIiwiYXRhbjIiLCJQSSIsImNvbm5lY3RUb090aGVycyIsInNtb290aFBvc2l0aW9uIiwicHVzaCIsInNoaWZ0IiwiYXZlcmFnZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiUXVhZHJpbGF0ZXJhbFZlcnRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBNb2RlbHMgYSB2ZXJ0ZXggb2YgdGhlIHF1YWRyaWxhdGVyYWwuXHJcbiAqXHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnXHJcbiAqL1xyXG5cclxuaW1wb3J0IERlcml2ZWRQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0Rlcml2ZWRQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IFZlY3RvcjJQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMlByb3BlcnR5LmpzJztcclxuaW1wb3J0IHF1YWRyaWxhdGVyYWwgZnJvbSAnLi4vLi4vcXVhZHJpbGF0ZXJhbC5qcyc7XHJcbmltcG9ydCBCb29sZWFuUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9Cb29sZWFuUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgQm91bmRzMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvQm91bmRzMi5qcyc7XHJcbmltcG9ydCBUYW5kZW0gZnJvbSAnLi4vLi4vLi4vLi4vdGFuZGVtL2pzL1RhbmRlbS5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi8uLi8uLi8uLi9raXRlL2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsVmVydGV4TGFiZWwgZnJvbSAnLi9RdWFkcmlsYXRlcmFsVmVydGV4TGFiZWwuanMnO1xyXG5pbXBvcnQgTnVsbGFibGVJTyBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvTnVsbGFibGVJTy5qcyc7XHJcbmltcG9ydCBOdW1iZXJJTyBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvTnVtYmVySU8uanMnO1xyXG5pbXBvcnQgUXVhZHJpbGF0ZXJhbE1vdmFibGUgZnJvbSAnLi9RdWFkcmlsYXRlcmFsTW92YWJsZS5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsQ29uc3RhbnRzIGZyb20gJy4uLy4uL1F1YWRyaWxhdGVyYWxDb25zdGFudHMuanMnO1xyXG5cclxuY29uc3QgVkVSVEVYX0JPVU5EUyA9IG5ldyBCb3VuZHMyKCAwLCAwLCBRdWFkcmlsYXRlcmFsQ29uc3RhbnRzLlZFUlRFWF9XSURUSCwgUXVhZHJpbGF0ZXJhbENvbnN0YW50cy5WRVJURVhfV0lEVEggKTtcclxuY29uc3QgSEFMRl9XSURUSCA9IFZFUlRFWF9CT1VORFMud2lkdGggLyAyO1xyXG5jb25zdCBIQUxGX0hFSUdIVCA9IFZFUlRFWF9CT1VORFMuaGVpZ2h0IC8gMjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YWRyaWxhdGVyYWxWZXJ0ZXggZXh0ZW5kcyBRdWFkcmlsYXRlcmFsTW92YWJsZSB7XHJcblxyXG4gIC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgdmVydGV4IGluIG1vZGVsIGNvb3JkaW5hdGVzLlxyXG4gIHB1YmxpYyByZWFkb25seSBwb3NpdGlvblByb3BlcnR5OiBQcm9wZXJ0eTxWZWN0b3IyPjtcclxuXHJcbiAgLy8gVGhlIGFuZ2xlIGF0IHRoaXMgdmVydGV4IG9mIHRoZSBxdWFkcmlsYXRlcmFsLCBudWxsIHVudGlsIHRoaXMgdmVydGV4IGlzIGNvbm5lY3RlZCB0byB0d28gb3RoZXJzIGJlY2F1c2Ugd2VcclxuICAvLyBuZWVkIHRocmVlIHBvaW50cyB0byBmb3JtIHRoZSBhbmdsZS5cclxuICBwdWJsaWMgcmVhZG9ubHkgYW5nbGVQcm9wZXJ0eTogUHJvcGVydHk8bnVtYmVyIHwgbnVsbD47XHJcblxyXG4gIC8vIElkZW50aWZpY2F0aW9uIG9mIHRoaXMgUXVhZHJpbGF0ZXJhbFZlcnRleCB3aXRoaW4gdGhlIFF1YWRyaWxhdGVyYWxTaGFwZS5cclxuICBwdWJsaWMgcmVhZG9ubHkgdmVydGV4TGFiZWw6IFF1YWRyaWxhdGVyYWxWZXJ0ZXhMYWJlbDtcclxuXHJcbiAgLy8gVGhlIFNoYXBlIGluIG1vZGVsIGNvb3JkaW5hdGVzIHRoYXQgZGVmaW5lcyB3aGVyZSB0aGlzIFF1YWRyaWxhdGVyYWxWZXJ0ZXggY2FuIG1vdmUuIEl0IGNhbiBuZXZlclxyXG4gIC8vIGdvIG91dHNpZGUgdGhpcyBhcmVhLiBUaGUgZHJhZ0FyZWFQcm9wZXJ0eSBpcyBkZXRlcm1pbmVkIGJ5IG90aGVyIHZlcnRpY2VzIG9mIHRoZSBxdWFkcmlsYXRlcmFsXHJcbiAgLy8gYW5kIGNvbnN0cmFpbnRzIG1vdmVtZW50IHNvIHRoZSBxdWFkcmlsYXRlcmFsIGNhbiBuZXZlciBiZWNvbWUgY3Jvc3NlZCBvciBcImNvbXBsZXhcIi4gSXQgaXMgbnVsbCB1bnRpbFxyXG4gIC8vIHRoZSBtb2RlbCBib3VuZHMgYXJlIGRlZmluZWQgYW5kIHRoaXMgUXVhZHJpbGF0ZXJhbFZlcnRleCBpcyBjb25uZWN0ZWQgdG8gb3RoZXJzIHRvIGZvcm0gdGhlIHF1YWRyaWxhdGVyYWwgc2hhcGUuXHJcbiAgcHVibGljIHJlYWRvbmx5IGRyYWdBcmVhUHJvcGVydHk6IFByb3BlcnR5PG51bGwgfCBTaGFwZT47XHJcblxyXG4gIC8vIFRoZSBib3VuZHMgaW4gbW9kZWwgY29vcmRpbmF0ZXMgb2YgdGhpcyB2ZXJ0ZXgsIHdpdGggZGltZW5zaW9ucyBWRVJURVhfQk9VTkRTLCBjZW50ZXJlZCBhdCB0aGUgdmFsdWUgb2YgdGhlXHJcbiAgLy8gcG9zaXRpb25Qcm9wZXJ0eS5cclxuICBwdWJsaWMgcmVhZG9ubHkgbW9kZWxCb3VuZHNQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8Qm91bmRzMj47XHJcblxyXG4gIC8vIFJlZmVyZW5jZWQgc28gdGhhdCB3ZSBjYW4gcGFzcyB0aGUgdGFuZGVtIHRvIFByb3BlcnRpZXMgYXMgdGhleSBhcmUgZHluYW1pY2FsbHkgY3JlYXRlZCBpbiB0aGUgbWV0aG9kcyBiZWxvdy5cclxuICBwcml2YXRlIHJlYWRvbmx5IHRhbmRlbTogVGFuZGVtO1xyXG5cclxuICAvLyBQcm9wZXJ0aWVzIHRyYWNraW5nIHdoZW4gYSBRdWFkcmlsYXRlcmFsVmVydGV4IGJlY29tZXMgYmxvY2tlZCBieSBvbnkgb2YgdGhlIGluZGl2aWR1YWwgc2lkZXMgb2YgbW9kZWwgYm91bmRzLlxyXG4gIC8vIFNvIHRoYXQgd2UgY2FuIHRyaWdnZXIgc29tZSBmZWVkYmFjayBhcyBhIFF1YWRyaWxhdGVyYWxWZXJ0ZXggaXMgYmxvY2tlZCBieSBuZXcgZWRnZXMgb2YgYm91bmRzLlxyXG4gIHB1YmxpYyByZWFkb25seSBsZWZ0Q29uc3RyYWluZWRQcm9wZXJ0eSA9IG5ldyBCb29sZWFuUHJvcGVydHkoIGZhbHNlICk7XHJcbiAgcHVibGljIHJlYWRvbmx5IHJpZ2h0Q29uc3RyYWluZWRQcm9wZXJ0eSA9IG5ldyBCb29sZWFuUHJvcGVydHkoIGZhbHNlICk7XHJcbiAgcHVibGljIHJlYWRvbmx5IHRvcENvbnN0cmFpbmVkUHJvcGVydHkgPSBuZXcgQm9vbGVhblByb3BlcnR5KCBmYWxzZSApO1xyXG4gIHB1YmxpYyByZWFkb25seSBib3R0b21Db25zdHJhaW5lZFByb3BlcnR5ID0gbmV3IEJvb2xlYW5Qcm9wZXJ0eSggZmFsc2UgKTtcclxuICBwdWJsaWMgcmVhZG9ubHkgbnVtYmVyT2ZDb25zdHJhaW5pbmdFZGdlc1Byb3BlcnR5ID0gbmV3IERlcml2ZWRQcm9wZXJ0eSggW1xyXG4gICAgdGhpcy50b3BDb25zdHJhaW5lZFByb3BlcnR5LFxyXG4gICAgdGhpcy5yaWdodENvbnN0cmFpbmVkUHJvcGVydHksXHJcbiAgICB0aGlzLmJvdHRvbUNvbnN0cmFpbmVkUHJvcGVydHksXHJcbiAgICB0aGlzLmxlZnRDb25zdHJhaW5lZFByb3BlcnR5XHJcbiAgXSwgKCB0b3BDb25zdHJhaW5lZCwgcmlnaHRDb25zdHJhaW5lZCwgYm90dG9tQ29uc3RyYWluZWQsIGxlZnRDb25zdHJhaW5lZCApID0+IHtcclxuICAgIGNvbnN0IHRvcFZhbCA9IHRvcENvbnN0cmFpbmVkID8gMSA6IDA7XHJcbiAgICBjb25zdCByaWdodFZhbCA9IHJpZ2h0Q29uc3RyYWluZWQgPyAxIDogMDtcclxuICAgIGNvbnN0IGJvdHRvbVZhbCA9IGJvdHRvbUNvbnN0cmFpbmVkID8gMSA6IDA7XHJcbiAgICBjb25zdCBsZWZ0VmFsID0gbGVmdENvbnN0cmFpbmVkID8gMSA6IDA7XHJcbiAgICByZXR1cm4gdG9wVmFsICsgcmlnaHRWYWwgKyBib3R0b21WYWwgKyBsZWZ0VmFsO1xyXG4gIH0gKTtcclxuXHJcbiAgLy8gQSByZWZlcmVuY2UgdG8gdmVydGljZXMgY29ubmVjdGVkIHRvIHRoaXMgdmVydGV4IGZvciBzbyB3ZSBjYW4gY2FsY3VsYXRlIHRoZSBhbmdsZSBhdCB0aGlzIHZlcnRleC5cclxuICAvLyBUaGUgb3JpZW50YXRpb24gb2YgdmVydGV4MSBhbmQgdmVydGV4MiBmb3IgYW5nbGUgY2FsY3VsYXRpb25zIGFyZSBhcyBzaG93biBpbiB0aGUgZm9sbG93aW5nIGRpYWdyYW06XHJcbiAgLy8gICAgICAgIHRoaXNWZXJ0ZXhcclxuICAvLyAgICAgICAgICAvICAgICAgIFxcXHJcbiAgLy8gICBzaWRlQSAvICAgICAgICAgXFwgc2lkZUJcclxuICAvLyAgICAgICAgLyAgICAgICAgICAgXFxcclxuICAvLyB2ZXJ0ZXgxIC0tLS0tLS0tLSB2ZXJ0ZXgyXHJcbiAgcHJpdmF0ZSB2ZXJ0ZXgxOiBRdWFkcmlsYXRlcmFsVmVydGV4IHwgbnVsbDtcclxuICBwcml2YXRlIHZlcnRleDI6IFF1YWRyaWxhdGVyYWxWZXJ0ZXggfCBudWxsO1xyXG5cclxuICAvLyBQcm9wZXJ0eSB0aGF0IGNvbnRyb2xzIGhvdyBtYW55IHZhbHVlcyB0byBpbmNsdWRlIGluIHRoZSBcInNtb290aGluZ1wiIG9mIHBvdGVudGlhbCBwb3NpdGlvbnMgd2hlbiBiZWluZ1xyXG4gIC8vIGNvbnRyb2xsZWQgYnkgYSBwcm90b3R5cGUgdGFuZ2libGUuIFNlZSBzbW9vdGhQb3NpdGlvbigpLlxyXG4gIHByaXZhdGUgcmVhZG9ubHkgc21vb3RoaW5nTGVuZ3RoUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PG51bWJlcj47XHJcblxyXG4gIC8vIFRoZSBjb2xsZWN0aW9uIG9mIG4gPD0gU01PT1RISU5HX0xFTkdUSCBudW1iZXIgb2YgcG9zaXRpb25zIGZvciBwcm90b3R5cGUgdGFuZ2libGUgY29udHJvbC4gU2VlIHNtb290aFBvc2l0aW9uKCkuXHJcbiAgcHJpdmF0ZSByZWFkb25seSBzbW9vdGhpbmdQb3NpdGlvbnM6IFZlY3RvcjJbXSA9IFtdO1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gaW5pdGlhbFBvc2l0aW9uIC0gVGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoZSBRdWFkcmlsYXRlcmFsVmVydGV4IGluIG1vZGVsIGNvb3JkaW5hdGVzLlxyXG4gICAqIEBwYXJhbSB2ZXJ0ZXhMYWJlbCAtIEEgbGFiZWwgdGFnZ2luZyB0aGUgdmVydGV4LCBzbyB3ZSBjYW4gbG9vayB1cCB0aGUgZXF1aXZhbGVudCB2ZXJ0ZXggb24gYW5vdGhlciBzaGFwZSBtb2RlbFxyXG4gICAqIEBwYXJhbSBzbW9vdGhpbmdMZW5ndGhQcm9wZXJ0eSAtIENvbnRyb2xsaW5nIGhvdyBtYW55IHZhbHVlcyB0byB1c2UgaW4gdGhlIHBvc2l0aW9uIHNtb290aGluZyB3aGVuIGNvbm5lY3RlZCB0b1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgdGFuZ2libGUgZGV2aWNlIChwcm90b3R5cGUpLlxyXG4gICAqIEBwYXJhbSB0YW5kZW1cclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIGluaXRpYWxQb3NpdGlvbjogVmVjdG9yMiwgdmVydGV4TGFiZWw6IFF1YWRyaWxhdGVyYWxWZXJ0ZXhMYWJlbCwgc21vb3RoaW5nTGVuZ3RoUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PG51bWJlcj4sIHRhbmRlbTogVGFuZGVtICkge1xyXG4gICAgc3VwZXIoIHRhbmRlbSApO1xyXG5cclxuICAgIHRoaXMuc21vb3RoaW5nTGVuZ3RoUHJvcGVydHkgPSBzbW9vdGhpbmdMZW5ndGhQcm9wZXJ0eTtcclxuICAgIHRoaXMucG9zaXRpb25Qcm9wZXJ0eSA9IG5ldyBWZWN0b3IyUHJvcGVydHkoIGluaXRpYWxQb3NpdGlvbiwge1xyXG4gICAgICB0YW5kZW06IHRhbmRlbS5jcmVhdGVUYW5kZW0oICdwb3NpdGlvblByb3BlcnR5JyApXHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy5hbmdsZVByb3BlcnR5ID0gbmV3IFByb3BlcnR5PG51bGwgfCBudW1iZXI+KCBudWxsLCB7XHJcbiAgICAgIHRhbmRlbTogdGFuZGVtLmNyZWF0ZVRhbmRlbSggJ2FuZ2xlUHJvcGVydHknICksXHJcbiAgICAgIHBoZXRpb1ZhbHVlVHlwZTogTnVsbGFibGVJTyggTnVtYmVySU8gKVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFRoZSBsYWJlbCBmb3IgdGhpcyB2ZXJ0ZXggc28gd2UgY2FuIGdldCB0aGUgc2FtZSB2ZXJ0ZXggb24gYW5vdGhlciBRdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC5cclxuICAgIHRoaXMudmVydGV4TGFiZWwgPSB2ZXJ0ZXhMYWJlbDtcclxuXHJcbiAgICB0aGlzLnZlcnRleDEgPSBudWxsO1xyXG4gICAgdGhpcy52ZXJ0ZXgyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmRyYWdBcmVhUHJvcGVydHkgPSBuZXcgUHJvcGVydHk8U2hhcGUgfCBudWxsPiggbnVsbCApO1xyXG5cclxuICAgIHRoaXMubW9kZWxCb3VuZHNQcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoIFsgdGhpcy5wb3NpdGlvblByb3BlcnR5IF0sIHBvc2l0aW9uID0+IHtcclxuICAgICAgcmV0dXJuIG5ldyBCb3VuZHMyKCBwb3NpdGlvbi54IC0gSEFMRl9XSURUSCwgcG9zaXRpb24ueSAtIEhBTEZfSEVJR0hULCBwb3NpdGlvbi54ICsgSEFMRl9XSURUSCwgcG9zaXRpb24ueSArIEhBTEZfSEVJR0hUICk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy50YW5kZW0gPSB0YW5kZW07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBRdWFkcmlsYXRlcmFsVmVydGV4IGludGVyc2VjdHMgYW5vdGhlci5cclxuICAgKi9cclxuICBwdWJsaWMgb3ZlcmxhcHNPdGhlciggb3RoZXI6IFF1YWRyaWxhdGVyYWxWZXJ0ZXggKTogYm9vbGVhbiB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvdGhlciAhPT0gdGhpcywgJ1lvdSBhcmUgdHJ5aW5nIHRvIHNlZSBpZiB0aGlzIHZlcnRleCBvdmVybGFwcyBzZWxmPycgKTtcclxuICAgIHJldHVybiBvdGhlci5tb2RlbEJvdW5kc1Byb3BlcnR5LnZhbHVlLmludGVyc2VjdHNCb3VuZHMoIHRoaXMubW9kZWxCb3VuZHNQcm9wZXJ0eS52YWx1ZSApO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBQcm9wZXJ0aWVzIHRoYXQgbmVlZCB0byBiZSB1cGRhdGVkIGFsbCBhdCBvbmNlIGZvciB0aGUgcXVhZHJpbGF0ZXJhbCBzaGFwZSB0byBhIGRlZmVycmVkIHN0YXRlIHNvIHRoYXRcclxuICAgKiB0aGV5IGNhbiBiZSB1cGRhdGVkIHRvZ2V0aGVyIHdpdGhvdXQgY2FsbGluZyBsaXN0ZW5lcnMgd2l0aCBiYWQgdHJhbnNpZW50IHN0YXRlcyBkdXJpbmcgdXBkYXRlcy5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0UHJvcGVydGllc0RlZmVycmVkKCBkZWZlcnJlZDogYm9vbGVhbiApOiAoICgpID0+IHZvaWQgKSB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25Qcm9wZXJ0eS5zZXREZWZlcnJlZCggZGVmZXJyZWQgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoaXMgdmVydGV4LlxyXG4gICAqL1xyXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuICAgIHRoaXMucG9zaXRpb25Qcm9wZXJ0eS5yZXNldCgpO1xyXG4gICAgdGhpcy5zbW9vdGhpbmdQb3NpdGlvbnMubGVuZ3RoID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgYW5nbGUgYXQgdGhpcyB2ZXJ0ZXguIFVzZXMgYXRhbjIgdG8gZ2V0IHRoZSBhbmdsZSBhdCB0aGlzIHZlcnRleCBjb3VudGVyLWNsb2Nrd2lzZVxyXG4gICAqIGJldHdlZW4gMCBhbmQgMiAqIE1hdGguUEkuIFNlZVxyXG4gICAqIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvODc4Nzg1L2hvdy10by1maW5kLWFuLWFuZ2xlLWluLXJhbmdlMC0zNjAtYmV0d2Vlbi0yLXZlY3RvcnNcclxuICAgKlxyXG4gICAqIEN1c3RvbSBhbmdsZSBjbGFjdWxhdGlvbiB1c2VkIGluc3RlYWQgb2YgVmVjdG9yMi5hbmdsZUJldHdlZW4gYmVjYXVzZSB3ZSBuZWVkIHRoZSBhbmdsZSB0byBzcGFuIGZyb21cclxuICAgKiAwIHRvIDJQSSBpbnN0ZWFkIG9mIDAgdG8gUEkuXHJcbiAgICpcclxuICAgKiBBc3N1bWVzIHRoZSBmb2xsb3dpbmcgYXJyYW5nZW1lbnQgb2YgdmVydGljZXM6XHJcbiAgICpcclxuICAgKiAgICAgICAgdGhpc1ZlcnRleFxyXG4gICAqICAgICAgICAgIC8gICAgICAgXFxcclxuICAgKiAgIHNpZGVBIC8gICAgICAgICBcXCBzaWRlQlxyXG4gICAqICAgICAgICAvICAgICAgICAgICBcXFxyXG4gICAqIHZlcnRleDEgLS0tLS0tLS0tIHZlcnRleDJcclxuICAgKlxyXG4gICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBhZnRlciBhbGwgdmVydGV4IHBvc2l0aW9ucyBoYXZlIGJlZW4gdXBkYXRlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgcXVhZHJpbGF0ZXJhbCBkb2VzXHJcbiAgICogbm90IGFwcGVhciB0byBleGlzdCBpbiBpbmNvcnJlY3Qgc3RhdGVzIGFzIHBvc2l0aW9ucyBhcmUgdXBkYXRlZCBpbiB0aGUgbmF0dXJhbCBsaXN0ZW5lciBvcmRlci4gU2VlXHJcbiAgICogUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwudXBkYXRlT3JkZXJEZXBlbmRlbnRQcm9wZXJ0aWVzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAqL1xyXG4gIHB1YmxpYyB1cGRhdGVBbmdsZSgpOiB2b2lkIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMudmVydGV4MSAmJiB0aGlzLnZlcnRleDIsICdOZWVkIGNvbm5lY3RlZCB2ZXJ0aWNlcyB0byBkZXRlcm1pbmUgYW4gYW5nbGUnICk7XHJcblxyXG4gICAgY29uc3QgdmVjdG9yMSA9IHRoaXMudmVydGV4MSEucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS5taW51cyggdGhpcy5wb3NpdGlvblByb3BlcnR5LnZhbHVlICk7XHJcbiAgICBjb25zdCB2ZWN0b3IyID0gdGhpcy52ZXJ0ZXgyIS5wb3NpdGlvblByb3BlcnR5LnZhbHVlLm1pbnVzKCB0aGlzLnBvc2l0aW9uUHJvcGVydHkudmFsdWUgKTtcclxuXHJcbiAgICBjb25zdCBkb3QgPSB2ZWN0b3IxLnggKiB2ZWN0b3IyLnggKyB2ZWN0b3IxLnkgKiB2ZWN0b3IyLnk7XHJcbiAgICBjb25zdCBkZXQgPSB2ZWN0b3IxLnggKiB2ZWN0b3IyLnkgLSB2ZWN0b3IyLnggKiB2ZWN0b3IxLnk7XHJcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKCBkZXQsIGRvdCApO1xyXG5cclxuICAgIC8vIGlmIHRoZSBhbmdsZSBpcyBsZXNzIHRoYW4gemVybywgd2UgaGF2ZSB3cmFwcGVkIGFyb3VuZCBNYXRoLlBJIGFuZCBmb3JtZWQgYSBjb25jYXZlIHNoYXBlIC0gdGhlIGFjdHVhbFxyXG4gICAgLy8gYW5nbGUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBQSVxyXG4gICAgaWYgKCBhbmdsZSA8IDAgKSB7XHJcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyAyICogTWF0aC5QSTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmFuZ2xlUHJvcGVydHkudmFsdWUgPSBhbmdsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbm5lY3QgdGhpcyB2ZXJ0ZXggdG8gdHdvIG90aGVycyB0byBmb3JtIGFuIGFuZ2xlIGFuZCBzaWRlcyBvZiB0aGUgcXVhZHJpbGF0ZXJhbC5cclxuICAgKi9cclxuICBwdWJsaWMgY29ubmVjdFRvT3RoZXJzKCB2ZXJ0ZXgxOiBRdWFkcmlsYXRlcmFsVmVydGV4LCB2ZXJ0ZXgyOiBRdWFkcmlsYXRlcmFsVmVydGV4ICk6IHZvaWQge1xyXG4gICAgdGhpcy52ZXJ0ZXgxID0gdmVydGV4MTtcclxuICAgIHRoaXMudmVydGV4MiA9IHZlcnRleDI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBcIlNtb290aFwiIHRoZSBwcm92aWRlZCBwb3NpdGlvbiBmb3IgdGhlIHZlcnRleCBieSBzYXZpbmcgaXQgaW4gYSBjb2xsZWN0aW9uIG9mIHBvc2l0aW9ucyBvZiBtYXggbGVuZ3RoXHJcbiAgICogYW5kIHJldHVybmluZyB0aGUgYXZlcmFnZSBwb3NpdGlvbi4gT25seSB1c2VkIGZvciBwcm90b3R5cGUgdGFuZ2libGUgY29ubmVjdGlvbi5cclxuICAgKi9cclxuICBwdWJsaWMgc21vb3RoUG9zaXRpb24oIHBvc2l0aW9uOiBWZWN0b3IyICk6IFZlY3RvcjIge1xyXG4gICAgdGhpcy5zbW9vdGhpbmdQb3NpdGlvbnMucHVzaCggcG9zaXRpb24gKTtcclxuXHJcbiAgICB3aGlsZSAoIHRoaXMuc21vb3RoaW5nUG9zaXRpb25zLmxlbmd0aCA+IHRoaXMuc21vb3RoaW5nTGVuZ3RoUHJvcGVydHkudmFsdWUgKSB7XHJcbiAgICAgIHRoaXMuc21vb3RoaW5nUG9zaXRpb25zLnNoaWZ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFZlY3RvcjIuYXZlcmFnZSggdGhpcy5zbW9vdGhpbmdQb3NpdGlvbnMgKTtcclxuICB9XHJcbn1cclxuXHJcbnF1YWRyaWxhdGVyYWwucmVnaXN0ZXIoICdRdWFkcmlsYXRlcmFsVmVydGV4JywgUXVhZHJpbGF0ZXJhbFZlcnRleCApO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsZUFBZSxNQUFNLHdDQUF3QztBQUNwRSxPQUFPQyxRQUFRLE1BQU0saUNBQWlDO0FBQ3RELE9BQU9DLGVBQWUsTUFBTSx1Q0FBdUM7QUFDbkUsT0FBT0MsYUFBYSxNQUFNLHdCQUF3QjtBQUNsRCxPQUFPQyxlQUFlLE1BQU0sd0NBQXdDO0FBQ3BFLE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFFbkQsT0FBT0MsT0FBTyxNQUFNLCtCQUErQjtBQUluRCxPQUFPQyxVQUFVLE1BQU0sMkNBQTJDO0FBQ2xFLE9BQU9DLFFBQVEsTUFBTSx5Q0FBeUM7QUFDOUQsT0FBT0Msb0JBQW9CLE1BQU0sMkJBQTJCO0FBQzVELE9BQU9DLHNCQUFzQixNQUFNLGlDQUFpQztBQUVwRSxNQUFNQyxhQUFhLEdBQUcsSUFBSU4sT0FBTyxDQUFFLENBQUMsRUFBRSxDQUFDLEVBQUVLLHNCQUFzQixDQUFDRSxZQUFZLEVBQUVGLHNCQUFzQixDQUFDRSxZQUFhLENBQUM7QUFDbkgsTUFBTUMsVUFBVSxHQUFHRixhQUFhLENBQUNHLEtBQUss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