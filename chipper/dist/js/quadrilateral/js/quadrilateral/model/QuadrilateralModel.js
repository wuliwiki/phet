// Copyright 2021-2023, University of Colorado Boulder

/**
 * The base model class for the sim. Assembles all model components and responsible for managing Properties
 * that indicate the state of the Quadrilateral shape. Also includes Properties that manage the state of the Sim (UI
 * element visibility and so on).
 *
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import QuadrilateralQueryParameters from '../QuadrilateralQueryParameters.js';
import QuadrilateralShapeModel from './QuadrilateralShapeModel.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import Utils from '../../../../dot/js/Utils.js';
import Emitter from '../../../../axon/js/Emitter.js';
import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import quadrilateral from '../../quadrilateral.js';
import QuadrilateralConstants from '../../QuadrilateralConstants.js';
import TangibleConnectionModel from './prototype/TangibleConnectionModel.js';
import QuadrilateralVisibilityModel from './QuadrilateralVisibilityModel.js';
export default class QuadrilateralModel {
  // Manages visibility of view components

  // Controls runtime options for the simulation.

  // A model that manages Properties used by prototype connections with tangible devdevices (Serial, OpenCV, BLE).

  // Whether a reset is currently in progress. Added for sound. If the model is actively resetting, SoundManagers
  // are disabled so we don't play sounds for transient model states. Tracks when the reset is NOT in progress
  // because that makes it most convenient to pass to SoundGenerator enableControlProperties.
  // The available bounds for smooth vertex dragging (the model bounds eroded by the width of a vertex so a vertex
  // can never go out of the model bounds.
  vertexDragBounds = QuadrilateralConstants.MODEL_BOUNDS.eroded(QuadrilateralConstants.VERTEX_WIDTH / 2);

  // The interval that Vertices are constrained to during interaction. There are many things that control the value:
  //  - A button in the UI to lock to small intervals (see useMinorIntervalsProperty and lockToMinorIntervalsProperty)
  //  - A global hotkey for small intervals (see useMinorIntervalsProperty and minorIntervalsFromGlobalHotkeyProperty)
  //  - Using ?reducedStepSize to make all intervals smaller (see vertexIntervalProperty derivation)
  //  - Connecting to a prototype tangible device (see vertexIntervalProperty derivation)
  // Whether vertices are going to snap to the minor intervals of the model grid. The user can "lock" this setting
  // from the user interface. There is also a global hotkey to toggle this quickly during interaction. Derived from
  // lockToMinorIntervalsProperty and minorIntervalsFromGlobalKeyProperty.
  // Whether the vertices will lock to the minor grid intervals during interaction. Controlled by a toggle in the UI.
  // When true, the global hotkey for using minor intervals does nothing.
  // Whether the vertices should snap to the minor grid intervals because of pressing a hotkey.
  // Whether the simulation sound design is enabled to play as the shape changes. For now,
  // this only controls the "Tracks" sound designs in this simulation. When this is false,
  // we will still hear general and common code sounds.
  // Model component for the quadrilateral shape.
  // A reference to a "test" model for the simulation. Used to validate vertex positions before setting them for
  // the "real" quadrilateralShapeModel. See QuadrilateralShapeModel.isQuadrilateralShapeAllowed().
  // Emits an event when a full model reset happens (but not when a shape reset happens)
  resetEmitter = new Emitter();
  constructor(optionsModel, tandem) {
    this.optionsModel = optionsModel;
    this.resetNotInProgressProperty = new BooleanProperty(true, {
      tandem: tandem.createTandem('resetNotInProgressProperty')
    });
    const smoothingLengthProperty = optionsModel.tangibleOptionsModel.smoothingLengthProperty;
    this.quadrilateralShapeModel = new QuadrilateralShapeModel(this.resetNotInProgressProperty, smoothingLengthProperty, {
      tandem: tandem.createTandem('quadrilateralShapeModel')
    });
    this.quadrilateralTestShapeModel = new QuadrilateralShapeModel(this.resetNotInProgressProperty, smoothingLengthProperty, {
      validateShape: false
    });
    this.visibilityModel = new QuadrilateralVisibilityModel(tandem.createTandem('visibilityModel'));
    this.tangibleConnectionModel = new TangibleConnectionModel(this.quadrilateralShapeModel, this.quadrilateralTestShapeModel, this.optionsModel.tangibleOptionsModel, tandem.createTandem('tangibleConnectionModel'));
    this.shapeSoundEnabledProperty = new BooleanProperty(true, {
      tandem: tandem.createTandem('shapeSoundEnabledProperty')
    });
    this.minorIntervalsFromGlobalKeyProperty = new BooleanProperty(false, {
      tandem: tandem.createTandem('minorIntervalsFromGlobalKeyProperty')
    });
    this.lockToMinorIntervalsProperty = new BooleanProperty(false, {
      tandem: tandem.createTandem('lockToMinorIntervalsProperty')
    });
    this.useMinorIntervalsProperty = DerivedProperty.or([this.minorIntervalsFromGlobalKeyProperty, this.lockToMinorIntervalsProperty]);

    // QuadrilateralVertex intervals are controlled whether we are "locked" to smaller steps, whether we are temporarily using
    // smaller steps because of a hotkey, or if running with ?reducedStepSize
    this.vertexIntervalProperty = new DerivedProperty([this.useMinorIntervalsProperty, this.tangibleConnectionModel.connectedToDeviceProperty, optionsModel.tangibleOptionsModel.deviceGridSpacingProperty], (useMinorIntervals, connectedToDevice, deviceGridSpacing) => {
      return connectedToDevice ? deviceGridSpacing : QuadrilateralQueryParameters.reducedStepSize ? useMinorIntervals ? QuadrilateralConstants.MINOR_REDUCED_SIZE_VERTEX_INTERVAL : QuadrilateralConstants.MAJOR_REDUCED_SIZE_VERTEX_INTERVAL : useMinorIntervals ? QuadrilateralQueryParameters.minorVertexInterval : QuadrilateralQueryParameters.majorVertexInterval;
    });

    // Adds a function to the window that prints the current vertex positions (only for development)
    if (phet.chipper.queryParameters.dev) {
      // @ts-expect-error - assigning to the window is bad, but its fine for this debugging tool
      window.printVertexPositions = () => {
        this.quadrilateralShapeModel.vertices.forEach(vertex => {
          console.log(vertex.vertexLabel.name, vertex.positionProperty.value);
        });
      };
    }
  }

  /**
   * Returns true if the two vertex positions are allowed for the quadrilateral.
   */
  areVertexPositionsAllowed(labelToPositionMap) {
    // Set the test shape to the current value of the actual shape before proposed positions
    this.quadrilateralTestShapeModel.setFromShape(this.quadrilateralShapeModel);
    this.quadrilateralTestShapeModel.setVertexPositions(labelToPositionMap);
    return QuadrilateralShapeModel.isQuadrilateralShapeAllowed(this.quadrilateralTestShapeModel);
  }

  /**
   * Resets the model.
   */
  reset() {
    // reset is in progress (not-not in progress)
    this.resetNotInProgressProperty.value = false;
    this.visibilityModel.reset();
    this.lockToMinorIntervalsProperty.reset();
    this.shapeSoundEnabledProperty.reset();
    this.quadrilateralShapeModel.reset();
    this.quadrilateralTestShapeModel.reset();
    this.resetEmitter.emit();

    // reset is not in progress anymore
    this.resetNotInProgressProperty.value = true;
  }

  /**
   * Returns the closest position in the model from the point provided that will be constrain the position to align
   * with the model grid. See vertexIntervalProperty for more information about how the intervals of the grid
   * can change.
   */
  getClosestGridPosition(proposedPosition) {
    const interval = this.vertexIntervalProperty.value;
    return new Vector2(Utils.roundToInterval(proposedPosition.x, interval), Utils.roundToInterval(proposedPosition.y, interval));
  }

  /**
   * Get the closest grid position to the proposed position, in x/y dimensions OR along the diagonal if we detect
   * movement close to the diagonal. This allows you to drag diagonally across grid cells if you want to, creating
   * more intuitive interaction.
   *
   * The implementation of this function is summarized by
   * https://github.com/phetsims/quadrilateral/issues/406#issuecomment-1485982113. If the proposed position
   * is close enough to a diagonal line between the grid points, we assume that the user wants to move diagonally
   * so we don't snap to axis-aligned positions.
   */
  getClosestGridPositionAlongDiagonal(currentPosition, proposedPosition) {
    // At this tiny step size, this feature is more harm than help and the grid size is so small that it
    // makes sense to just get the closest grid position.
    if (this.useMinorIntervalsProperty.value && QuadrilateralQueryParameters.reducedStepSize) {
      return this.getClosestGridPosition(proposedPosition);
    }
    const interval = this.vertexIntervalProperty.value;

    // create a diagonal line from currentPosition to next interval, in the direction of movement
    const diagonalIntervalPosition = currentPosition.plusXY(interval * (proposedPosition.x > currentPosition.x ? 1 : -1), interval * (proposedPosition.y > currentPosition.y ? 1 : -1));

    // If we are within this distance to the diagonal line between currentPosition and proposedPosition we are
    // moving along the diagonal and should try to find the closest grid position along that diagonal line.
    // This value was chosen by inspection. It is difficult to get a value that "feels right" without being too biased
    // toward diagonal or movement along the axis.
    const maximumDiagonalDistance = interval / 400;
    const distanceToDiagonal = Utils.distToSegmentSquared(proposedPosition, currentPosition, diagonalIntervalPosition);
    if (distanceToDiagonal < maximumDiagonalDistance) {
      // Close enough to be moving along the diagonal, so the interval needs to be larger to trigger a transition.
      // Value is the interval along the diagonal so we use the pythagorean theorem.
      const halfInterval = interval / 2;
      const diagonalInterval = Math.sqrt(halfInterval * halfInterval + halfInterval * halfInterval);
      const distanceToCurrentPosition = currentPosition.distance(proposedPosition);
      if (distanceToCurrentPosition > diagonalInterval) {
        return diagonalIntervalPosition;
      } else {
        // distance along the diagonal was not large enough, don't move
        return currentPosition;
      }
    } else {
      return this.getClosestGridPosition(proposedPosition);
    }
  }

  /**
   * Get the closest grid position to the provided position, in the direction of the provided directionVector.
   * Use this when you need to move to the closest grid position in one dimension, instead of moving to the
   * closest grid position in both X and Y.
   */
  getClosestGridPositionInDirection(currentPosition, directionVector) {
    let nextX = currentPosition.x;
    let nextY = currentPosition.y;
    if (directionVector.x !== 0) {
      nextX = this.getNextPositionInDimension(currentPosition, directionVector, 'x');
    } else if (directionVector.y !== 0) {
      nextY = this.getNextPositionInDimension(currentPosition, directionVector, 'y');
    }
    return new Vector2(nextX, nextY);
  }

  /**
   * Get the next value on the interval in provided dimension. The following diagram demonstrates how this works:
   *                interval
   *           |---------------|
   *              A
   *         |---------|
   * -----C--*-|-*-----|-----*-|-*-----------------
   *                   |---------|
   *                        B
   *  C: currentValue
   *  A: If the value lands in this region, next position should be left side of interval.
   *  B: If value lands in this region, next position should be right side of interval.
   *  *: small offset so if currentValue is very close to the interval, we will round to next interval.
   *
   *  So the length of A (or B) is added to currentValue before rounding to the interval.
   *
   *  See https://github.com/phetsims/quadrilateral/issues/402 for more implementation notes.
   */
  getNextPositionInDimension(currentPosition, directionVector, dimension) {
    const currentValue = currentPosition[dimension];
    const gettingLarger = directionVector[dimension] > 0;
    const interval = this.vertexIntervalProperty.value;
    const delta = 0.01 + interval / 2;
    const sign = gettingLarger ? 1 : -1;
    return Utils.roundToInterval(currentValue + sign * delta, interval);
  }
}
quadrilateral.register('QuadrilateralModel', QuadrilateralModel);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJRdWFkcmlsYXRlcmFsUXVlcnlQYXJhbWV0ZXJzIiwiUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwiLCJWZWN0b3IyIiwiVXRpbHMiLCJFbWl0dGVyIiwiRGVyaXZlZFByb3BlcnR5IiwicXVhZHJpbGF0ZXJhbCIsIlF1YWRyaWxhdGVyYWxDb25zdGFudHMiLCJUYW5naWJsZUNvbm5lY3Rpb25Nb2RlbCIsIlF1YWRyaWxhdGVyYWxWaXNpYmlsaXR5TW9kZWwiLCJRdWFkcmlsYXRlcmFsTW9kZWwiLCJ2ZXJ0ZXhEcmFnQm91bmRzIiwiTU9ERUxfQk9VTkRTIiwiZXJvZGVkIiwiVkVSVEVYX1dJRFRIIiwicmVzZXRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zTW9kZWwiLCJ0YW5kZW0iLCJyZXNldE5vdEluUHJvZ3Jlc3NQcm9wZXJ0eSIsImNyZWF0ZVRhbmRlbSIsInNtb290aGluZ0xlbmd0aFByb3BlcnR5IiwidGFuZ2libGVPcHRpb25zTW9kZWwiLCJxdWFkcmlsYXRlcmFsU2hhcGVNb2RlbCIsInF1YWRyaWxhdGVyYWxUZXN0U2hhcGVNb2RlbCIsInZhbGlkYXRlU2hhcGUiLCJ2aXNpYmlsaXR5TW9kZWwiLCJ0YW5naWJsZUNvbm5lY3Rpb25Nb2RlbCIsInNoYXBlU291bmRFbmFibGVkUHJvcGVydHkiLCJtaW5vckludGVydmFsc0Zyb21HbG9iYWxLZXlQcm9wZXJ0eSIsImxvY2tUb01pbm9ySW50ZXJ2YWxzUHJvcGVydHkiLCJ1c2VNaW5vckludGVydmFsc1Byb3BlcnR5Iiwib3IiLCJ2ZXJ0ZXhJbnRlcnZhbFByb3BlcnR5IiwiY29ubmVjdGVkVG9EZXZpY2VQcm9wZXJ0eSIsImRldmljZUdyaWRTcGFjaW5nUHJvcGVydHkiLCJ1c2VNaW5vckludGVydmFscyIsImNvbm5lY3RlZFRvRGV2aWNlIiwiZGV2aWNlR3JpZFNwYWNpbmciLCJyZWR1Y2VkU3RlcFNpemUiLCJNSU5PUl9SRURVQ0VEX1NJWkVfVkVSVEVYX0lOVEVSVkFMIiwiTUFKT1JfUkVEVUNFRF9TSVpFX1ZFUlRFWF9JTlRFUlZBTCIsIm1pbm9yVmVydGV4SW50ZXJ2YWwiLCJtYWpvclZlcnRleEludGVydmFsIiwicGhldCIsImNoaXBwZXIiLCJxdWVyeVBhcmFtZXRlcnMiLCJkZXYiLCJ3aW5kb3ciLCJwcmludFZlcnRleFBvc2l0aW9ucyIsInZlcnRpY2VzIiwiZm9yRWFjaCIsInZlcnRleCIsImNvbnNvbGUiLCJsb2ciLCJ2ZXJ0ZXhMYWJlbCIsIm5hbWUiLCJwb3NpdGlvblByb3BlcnR5IiwidmFsdWUiLCJhcmVWZXJ0ZXhQb3NpdGlvbnNBbGxvd2VkIiwibGFiZWxUb1Bvc2l0aW9uTWFwIiwic2V0RnJvbVNoYXBlIiwic2V0VmVydGV4UG9zaXRpb25zIiwiaXNRdWFkcmlsYXRlcmFsU2hhcGVBbGxvd2VkIiwicmVzZXQiLCJlbWl0IiwiZ2V0Q2xvc2VzdEdyaWRQb3NpdGlvbiIsInByb3Bvc2VkUG9zaXRpb24iLCJpbnRlcnZhbCIsInJvdW5kVG9JbnRlcnZhbCIsIngiLCJ5IiwiZ2V0Q2xvc2VzdEdyaWRQb3NpdGlvbkFsb25nRGlhZ29uYWwiLCJjdXJyZW50UG9zaXRpb24iLCJkaWFnb25hbEludGVydmFsUG9zaXRpb24iLCJwbHVzWFkiLCJtYXhpbXVtRGlhZ29uYWxEaXN0YW5jZSIsImRpc3RhbmNlVG9EaWFnb25hbCIsImRpc3RUb1NlZ21lbnRTcXVhcmVkIiwiaGFsZkludGVydmFsIiwiZGlhZ29uYWxJbnRlcnZhbCIsIk1hdGgiLCJzcXJ0IiwiZGlzdGFuY2VUb0N1cnJlbnRQb3NpdGlvbiIsImRpc3RhbmNlIiwiZ2V0Q2xvc2VzdEdyaWRQb3NpdGlvbkluRGlyZWN0aW9uIiwiZGlyZWN0aW9uVmVjdG9yIiwibmV4dFgiLCJuZXh0WSIsImdldE5leHRQb3NpdGlvbkluRGltZW5zaW9uIiwiZGltZW5zaW9uIiwiY3VycmVudFZhbHVlIiwiZ2V0dGluZ0xhcmdlciIsImRlbHRhIiwic2lnbiIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiUXVhZHJpbGF0ZXJhbE1vZGVsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIG1vZGVsIGNsYXNzIGZvciB0aGUgc2ltLiBBc3NlbWJsZXMgYWxsIG1vZGVsIGNvbXBvbmVudHMgYW5kIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyBQcm9wZXJ0aWVzXHJcbiAqIHRoYXQgaW5kaWNhdGUgdGhlIHN0YXRlIG9mIHRoZSBRdWFkcmlsYXRlcmFsIHNoYXBlLiBBbHNvIGluY2x1ZGVzIFByb3BlcnRpZXMgdGhhdCBtYW5hZ2UgdGhlIHN0YXRlIG9mIHRoZSBTaW0gKFVJXHJcbiAqIGVsZW1lbnQgdmlzaWJpbGl0eSBhbmQgc28gb24pLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEplc3NlIEdyZWVuYmVyZyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgQm9vbGVhblByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvQm9vbGVhblByb3BlcnR5LmpzJztcclxuaW1wb3J0IFRhbmRlbSBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvVGFuZGVtLmpzJztcclxuaW1wb3J0IFF1YWRyaWxhdGVyYWxRdWVyeVBhcmFtZXRlcnMgZnJvbSAnLi4vUXVhZHJpbGF0ZXJhbFF1ZXJ5UGFyYW1ldGVycy5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsU2hhcGVNb2RlbCwgeyBWZXJ0ZXhMYWJlbFRvUHJvcG9zZWRQb3NpdGlvbk1hcCB9IGZyb20gJy4vUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVXRpbHMuanMnO1xyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsT3B0aW9uc01vZGVsIGZyb20gJy4vUXVhZHJpbGF0ZXJhbE9wdGlvbnNNb2RlbC5qcyc7XHJcbmltcG9ydCBUUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9UUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0VtaXR0ZXIuanMnO1xyXG5pbXBvcnQgRGVyaXZlZFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvRGVyaXZlZFByb3BlcnR5LmpzJztcclxuaW1wb3J0IHF1YWRyaWxhdGVyYWwgZnJvbSAnLi4vLi4vcXVhZHJpbGF0ZXJhbC5qcyc7XHJcbmltcG9ydCBRdWFkcmlsYXRlcmFsQ29uc3RhbnRzIGZyb20gJy4uLy4uL1F1YWRyaWxhdGVyYWxDb25zdGFudHMuanMnO1xyXG5pbXBvcnQgVGFuZ2libGVDb25uZWN0aW9uTW9kZWwgZnJvbSAnLi9wcm90b3R5cGUvVGFuZ2libGVDb25uZWN0aW9uTW9kZWwuanMnO1xyXG5pbXBvcnQgUXVhZHJpbGF0ZXJhbFZpc2liaWxpdHlNb2RlbCBmcm9tICcuL1F1YWRyaWxhdGVyYWxWaXNpYmlsaXR5TW9kZWwuanMnO1xyXG5pbXBvcnQgVE1vZGVsIGZyb20gJy4uLy4uLy4uLy4uL2pvaXN0L2pzL1RNb2RlbC5qcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWFkcmlsYXRlcmFsTW9kZWwgaW1wbGVtZW50cyBUTW9kZWwge1xyXG5cclxuICAvLyBNYW5hZ2VzIHZpc2liaWxpdHkgb2YgdmlldyBjb21wb25lbnRzXHJcbiAgcHVibGljIHJlYWRvbmx5IHZpc2liaWxpdHlNb2RlbDogUXVhZHJpbGF0ZXJhbFZpc2liaWxpdHlNb2RlbDtcclxuXHJcbiAgLy8gQ29udHJvbHMgcnVudGltZSBvcHRpb25zIGZvciB0aGUgc2ltdWxhdGlvbi5cclxuICBwdWJsaWMgcmVhZG9ubHkgb3B0aW9uc01vZGVsOiBRdWFkcmlsYXRlcmFsT3B0aW9uc01vZGVsO1xyXG5cclxuICAvLyBBIG1vZGVsIHRoYXQgbWFuYWdlcyBQcm9wZXJ0aWVzIHVzZWQgYnkgcHJvdG90eXBlIGNvbm5lY3Rpb25zIHdpdGggdGFuZ2libGUgZGV2ZGV2aWNlcyAoU2VyaWFsLCBPcGVuQ1YsIEJMRSkuXHJcbiAgcHVibGljIHJlYWRvbmx5IHRhbmdpYmxlQ29ubmVjdGlvbk1vZGVsOiBUYW5naWJsZUNvbm5lY3Rpb25Nb2RlbDtcclxuXHJcbiAgLy8gV2hldGhlciBhIHJlc2V0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy4gQWRkZWQgZm9yIHNvdW5kLiBJZiB0aGUgbW9kZWwgaXMgYWN0aXZlbHkgcmVzZXR0aW5nLCBTb3VuZE1hbmFnZXJzXHJcbiAgLy8gYXJlIGRpc2FibGVkIHNvIHdlIGRvbid0IHBsYXkgc291bmRzIGZvciB0cmFuc2llbnQgbW9kZWwgc3RhdGVzLiBUcmFja3Mgd2hlbiB0aGUgcmVzZXQgaXMgTk9UIGluIHByb2dyZXNzXHJcbiAgLy8gYmVjYXVzZSB0aGF0IG1ha2VzIGl0IG1vc3QgY29udmVuaWVudCB0byBwYXNzIHRvIFNvdW5kR2VuZXJhdG9yIGVuYWJsZUNvbnRyb2xQcm9wZXJ0aWVzLlxyXG4gIHB1YmxpYyByZWFkb25seSByZXNldE5vdEluUHJvZ3Jlc3NQcm9wZXJ0eTogVFByb3BlcnR5PGJvb2xlYW4+O1xyXG5cclxuICAvLyBUaGUgYXZhaWxhYmxlIGJvdW5kcyBmb3Igc21vb3RoIHZlcnRleCBkcmFnZ2luZyAodGhlIG1vZGVsIGJvdW5kcyBlcm9kZWQgYnkgdGhlIHdpZHRoIG9mIGEgdmVydGV4IHNvIGEgdmVydGV4XHJcbiAgLy8gY2FuIG5ldmVyIGdvIG91dCBvZiB0aGUgbW9kZWwgYm91bmRzLlxyXG4gIHB1YmxpYyByZWFkb25seSB2ZXJ0ZXhEcmFnQm91bmRzID0gUXVhZHJpbGF0ZXJhbENvbnN0YW50cy5NT0RFTF9CT1VORFMuZXJvZGVkKCBRdWFkcmlsYXRlcmFsQ29uc3RhbnRzLlZFUlRFWF9XSURUSCAvIDIgKTtcclxuXHJcbiAgLy8gVGhlIGludGVydmFsIHRoYXQgVmVydGljZXMgYXJlIGNvbnN0cmFpbmVkIHRvIGR1cmluZyBpbnRlcmFjdGlvbi4gVGhlcmUgYXJlIG1hbnkgdGhpbmdzIHRoYXQgY29udHJvbCB0aGUgdmFsdWU6XHJcbiAgLy8gIC0gQSBidXR0b24gaW4gdGhlIFVJIHRvIGxvY2sgdG8gc21hbGwgaW50ZXJ2YWxzIChzZWUgdXNlTWlub3JJbnRlcnZhbHNQcm9wZXJ0eSBhbmQgbG9ja1RvTWlub3JJbnRlcnZhbHNQcm9wZXJ0eSlcclxuICAvLyAgLSBBIGdsb2JhbCBob3RrZXkgZm9yIHNtYWxsIGludGVydmFscyAoc2VlIHVzZU1pbm9ySW50ZXJ2YWxzUHJvcGVydHkgYW5kIG1pbm9ySW50ZXJ2YWxzRnJvbUdsb2JhbEhvdGtleVByb3BlcnR5KVxyXG4gIC8vICAtIFVzaW5nID9yZWR1Y2VkU3RlcFNpemUgdG8gbWFrZSBhbGwgaW50ZXJ2YWxzIHNtYWxsZXIgKHNlZSB2ZXJ0ZXhJbnRlcnZhbFByb3BlcnR5IGRlcml2YXRpb24pXHJcbiAgLy8gIC0gQ29ubmVjdGluZyB0byBhIHByb3RvdHlwZSB0YW5naWJsZSBkZXZpY2UgKHNlZSB2ZXJ0ZXhJbnRlcnZhbFByb3BlcnR5IGRlcml2YXRpb24pXHJcbiAgcHVibGljIHJlYWRvbmx5IHZlcnRleEludGVydmFsUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PG51bWJlcj47XHJcblxyXG4gIC8vIFdoZXRoZXIgdmVydGljZXMgYXJlIGdvaW5nIHRvIHNuYXAgdG8gdGhlIG1pbm9yIGludGVydmFscyBvZiB0aGUgbW9kZWwgZ3JpZC4gVGhlIHVzZXIgY2FuIFwibG9ja1wiIHRoaXMgc2V0dGluZ1xyXG4gIC8vIGZyb20gdGhlIHVzZXIgaW50ZXJmYWNlLiBUaGVyZSBpcyBhbHNvIGEgZ2xvYmFsIGhvdGtleSB0byB0b2dnbGUgdGhpcyBxdWlja2x5IGR1cmluZyBpbnRlcmFjdGlvbi4gRGVyaXZlZCBmcm9tXHJcbiAgLy8gbG9ja1RvTWlub3JJbnRlcnZhbHNQcm9wZXJ0eSBhbmQgbWlub3JJbnRlcnZhbHNGcm9tR2xvYmFsS2V5UHJvcGVydHkuXHJcbiAgcHJpdmF0ZSByZWFkb25seSB1c2VNaW5vckludGVydmFsc1Byb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxib29sZWFuPjtcclxuXHJcbiAgLy8gV2hldGhlciB0aGUgdmVydGljZXMgd2lsbCBsb2NrIHRvIHRoZSBtaW5vciBncmlkIGludGVydmFscyBkdXJpbmcgaW50ZXJhY3Rpb24uIENvbnRyb2xsZWQgYnkgYSB0b2dnbGUgaW4gdGhlIFVJLlxyXG4gIC8vIFdoZW4gdHJ1ZSwgdGhlIGdsb2JhbCBob3RrZXkgZm9yIHVzaW5nIG1pbm9yIGludGVydmFscyBkb2VzIG5vdGhpbmcuXHJcbiAgcHVibGljIHJlYWRvbmx5IGxvY2tUb01pbm9ySW50ZXJ2YWxzUHJvcGVydHk6IEJvb2xlYW5Qcm9wZXJ0eTtcclxuXHJcbiAgLy8gV2hldGhlciB0aGUgdmVydGljZXMgc2hvdWxkIHNuYXAgdG8gdGhlIG1pbm9yIGdyaWQgaW50ZXJ2YWxzIGJlY2F1c2Ugb2YgcHJlc3NpbmcgYSBob3RrZXkuXHJcbiAgcHVibGljIHJlYWRvbmx5IG1pbm9ySW50ZXJ2YWxzRnJvbUdsb2JhbEtleVByb3BlcnR5OiBUUHJvcGVydHk8Ym9vbGVhbj47XHJcblxyXG4gIC8vIFdoZXRoZXIgdGhlIHNpbXVsYXRpb24gc291bmQgZGVzaWduIGlzIGVuYWJsZWQgdG8gcGxheSBhcyB0aGUgc2hhcGUgY2hhbmdlcy4gRm9yIG5vdyxcclxuICAvLyB0aGlzIG9ubHkgY29udHJvbHMgdGhlIFwiVHJhY2tzXCIgc291bmQgZGVzaWducyBpbiB0aGlzIHNpbXVsYXRpb24uIFdoZW4gdGhpcyBpcyBmYWxzZSxcclxuICAvLyB3ZSB3aWxsIHN0aWxsIGhlYXIgZ2VuZXJhbCBhbmQgY29tbW9uIGNvZGUgc291bmRzLlxyXG4gIHB1YmxpYyByZWFkb25seSBzaGFwZVNvdW5kRW5hYmxlZFByb3BlcnR5OiBCb29sZWFuUHJvcGVydHk7XHJcblxyXG4gIC8vIE1vZGVsIGNvbXBvbmVudCBmb3IgdGhlIHF1YWRyaWxhdGVyYWwgc2hhcGUuXHJcbiAgcHVibGljIHJlYWRvbmx5IHF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsOiBRdWFkcmlsYXRlcmFsU2hhcGVNb2RlbDtcclxuXHJcbiAgLy8gQSByZWZlcmVuY2UgdG8gYSBcInRlc3RcIiBtb2RlbCBmb3IgdGhlIHNpbXVsYXRpb24uIFVzZWQgdG8gdmFsaWRhdGUgdmVydGV4IHBvc2l0aW9ucyBiZWZvcmUgc2V0dGluZyB0aGVtIGZvclxyXG4gIC8vIHRoZSBcInJlYWxcIiBxdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC4gU2VlIFF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsLmlzUXVhZHJpbGF0ZXJhbFNoYXBlQWxsb3dlZCgpLlxyXG4gIHB1YmxpYyByZWFkb25seSBxdWFkcmlsYXRlcmFsVGVzdFNoYXBlTW9kZWw6IFF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsO1xyXG5cclxuICAvLyBFbWl0cyBhbiBldmVudCB3aGVuIGEgZnVsbCBtb2RlbCByZXNldCBoYXBwZW5zIChidXQgbm90IHdoZW4gYSBzaGFwZSByZXNldCBoYXBwZW5zKVxyXG4gIHB1YmxpYyByZWFkb25seSByZXNldEVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIG9wdGlvbnNNb2RlbDogUXVhZHJpbGF0ZXJhbE9wdGlvbnNNb2RlbCwgdGFuZGVtOiBUYW5kZW0gKSB7XHJcbiAgICB0aGlzLm9wdGlvbnNNb2RlbCA9IG9wdGlvbnNNb2RlbDtcclxuXHJcbiAgICB0aGlzLnJlc2V0Tm90SW5Qcm9ncmVzc1Byb3BlcnR5ID0gbmV3IEJvb2xlYW5Qcm9wZXJ0eSggdHJ1ZSwge1xyXG4gICAgICB0YW5kZW06IHRhbmRlbS5jcmVhdGVUYW5kZW0oICdyZXNldE5vdEluUHJvZ3Jlc3NQcm9wZXJ0eScgKVxyXG4gICAgfSApO1xyXG5cclxuICAgIGNvbnN0IHNtb290aGluZ0xlbmd0aFByb3BlcnR5ID0gb3B0aW9uc01vZGVsLnRhbmdpYmxlT3B0aW9uc01vZGVsLnNtb290aGluZ0xlbmd0aFByb3BlcnR5O1xyXG4gICAgdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbCA9IG5ldyBRdWFkcmlsYXRlcmFsU2hhcGVNb2RlbCggdGhpcy5yZXNldE5vdEluUHJvZ3Jlc3NQcm9wZXJ0eSwgc21vb3RoaW5nTGVuZ3RoUHJvcGVydHksIHtcclxuICAgICAgdGFuZGVtOiB0YW5kZW0uY3JlYXRlVGFuZGVtKCAncXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwnIClcclxuICAgIH0gKTtcclxuICAgIHRoaXMucXVhZHJpbGF0ZXJhbFRlc3RTaGFwZU1vZGVsID0gbmV3IFF1YWRyaWxhdGVyYWxTaGFwZU1vZGVsKCB0aGlzLnJlc2V0Tm90SW5Qcm9ncmVzc1Byb3BlcnR5LCBzbW9vdGhpbmdMZW5ndGhQcm9wZXJ0eSwge1xyXG4gICAgICB2YWxpZGF0ZVNoYXBlOiBmYWxzZVxyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMudmlzaWJpbGl0eU1vZGVsID0gbmV3IFF1YWRyaWxhdGVyYWxWaXNpYmlsaXR5TW9kZWwoIHRhbmRlbS5jcmVhdGVUYW5kZW0oICd2aXNpYmlsaXR5TW9kZWwnICkgKTtcclxuICAgIHRoaXMudGFuZ2libGVDb25uZWN0aW9uTW9kZWwgPSBuZXcgVGFuZ2libGVDb25uZWN0aW9uTW9kZWwoXHJcbiAgICAgIHRoaXMucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwsXHJcbiAgICAgIHRoaXMucXVhZHJpbGF0ZXJhbFRlc3RTaGFwZU1vZGVsLFxyXG4gICAgICB0aGlzLm9wdGlvbnNNb2RlbC50YW5naWJsZU9wdGlvbnNNb2RlbCxcclxuICAgICAgdGFuZGVtLmNyZWF0ZVRhbmRlbSggJ3RhbmdpYmxlQ29ubmVjdGlvbk1vZGVsJyApXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuc2hhcGVTb3VuZEVuYWJsZWRQcm9wZXJ0eSA9IG5ldyBCb29sZWFuUHJvcGVydHkoIHRydWUsIHtcclxuICAgICAgdGFuZGVtOiB0YW5kZW0uY3JlYXRlVGFuZGVtKCAnc2hhcGVTb3VuZEVuYWJsZWRQcm9wZXJ0eScgKVxyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMubWlub3JJbnRlcnZhbHNGcm9tR2xvYmFsS2V5UHJvcGVydHkgPSBuZXcgQm9vbGVhblByb3BlcnR5KCBmYWxzZSwge1xyXG4gICAgICB0YW5kZW06IHRhbmRlbS5jcmVhdGVUYW5kZW0oICdtaW5vckludGVydmFsc0Zyb21HbG9iYWxLZXlQcm9wZXJ0eScgKVxyXG4gICAgfSApO1xyXG4gICAgdGhpcy5sb2NrVG9NaW5vckludGVydmFsc1Byb3BlcnR5ID0gbmV3IEJvb2xlYW5Qcm9wZXJ0eSggZmFsc2UsIHtcclxuICAgICAgdGFuZGVtOiB0YW5kZW0uY3JlYXRlVGFuZGVtKCAnbG9ja1RvTWlub3JJbnRlcnZhbHNQcm9wZXJ0eScgKVxyXG4gICAgfSApO1xyXG4gICAgdGhpcy51c2VNaW5vckludGVydmFsc1Byb3BlcnR5ID0gRGVyaXZlZFByb3BlcnR5Lm9yKCBbIHRoaXMubWlub3JJbnRlcnZhbHNGcm9tR2xvYmFsS2V5UHJvcGVydHksIHRoaXMubG9ja1RvTWlub3JJbnRlcnZhbHNQcm9wZXJ0eSBdICk7XHJcblxyXG4gICAgLy8gUXVhZHJpbGF0ZXJhbFZlcnRleCBpbnRlcnZhbHMgYXJlIGNvbnRyb2xsZWQgd2hldGhlciB3ZSBhcmUgXCJsb2NrZWRcIiB0byBzbWFsbGVyIHN0ZXBzLCB3aGV0aGVyIHdlIGFyZSB0ZW1wb3JhcmlseSB1c2luZ1xyXG4gICAgLy8gc21hbGxlciBzdGVwcyBiZWNhdXNlIG9mIGEgaG90a2V5LCBvciBpZiBydW5uaW5nIHdpdGggP3JlZHVjZWRTdGVwU2l6ZVxyXG4gICAgdGhpcy52ZXJ0ZXhJbnRlcnZhbFByb3BlcnR5ID0gbmV3IERlcml2ZWRQcm9wZXJ0eShcclxuICAgICAgWyB0aGlzLnVzZU1pbm9ySW50ZXJ2YWxzUHJvcGVydHksIHRoaXMudGFuZ2libGVDb25uZWN0aW9uTW9kZWwuY29ubmVjdGVkVG9EZXZpY2VQcm9wZXJ0eSwgb3B0aW9uc01vZGVsLnRhbmdpYmxlT3B0aW9uc01vZGVsLmRldmljZUdyaWRTcGFjaW5nUHJvcGVydHkgXSxcclxuICAgICAgKCB1c2VNaW5vckludGVydmFscywgY29ubmVjdGVkVG9EZXZpY2UsIGRldmljZUdyaWRTcGFjaW5nICkgPT4ge1xyXG4gICAgICAgIHJldHVybiBjb25uZWN0ZWRUb0RldmljZSA/IGRldmljZUdyaWRTcGFjaW5nIDpcclxuICAgICAgICAgICAgICAgUXVhZHJpbGF0ZXJhbFF1ZXJ5UGFyYW1ldGVycy5yZWR1Y2VkU3RlcFNpemUgPyAoIHVzZU1pbm9ySW50ZXJ2YWxzID8gUXVhZHJpbGF0ZXJhbENvbnN0YW50cy5NSU5PUl9SRURVQ0VEX1NJWkVfVkVSVEVYX0lOVEVSVkFMIDogUXVhZHJpbGF0ZXJhbENvbnN0YW50cy5NQUpPUl9SRURVQ0VEX1NJWkVfVkVSVEVYX0lOVEVSVkFMICkgOlxyXG4gICAgICAgICAgICAgICB1c2VNaW5vckludGVydmFscyA/IFF1YWRyaWxhdGVyYWxRdWVyeVBhcmFtZXRlcnMubWlub3JWZXJ0ZXhJbnRlcnZhbCA6IFF1YWRyaWxhdGVyYWxRdWVyeVBhcmFtZXRlcnMubWFqb3JWZXJ0ZXhJbnRlcnZhbDtcclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBZGRzIGEgZnVuY3Rpb24gdG8gdGhlIHdpbmRvdyB0aGF0IHByaW50cyB0aGUgY3VycmVudCB2ZXJ0ZXggcG9zaXRpb25zIChvbmx5IGZvciBkZXZlbG9wbWVudClcclxuICAgIGlmICggcGhldC5jaGlwcGVyLnF1ZXJ5UGFyYW1ldGVycy5kZXYgKSB7XHJcblxyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gYXNzaWduaW5nIHRvIHRoZSB3aW5kb3cgaXMgYmFkLCBidXQgaXRzIGZpbmUgZm9yIHRoaXMgZGVidWdnaW5nIHRvb2xcclxuICAgICAgd2luZG93LnByaW50VmVydGV4UG9zaXRpb25zID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwudmVydGljZXMuZm9yRWFjaCggdmVydGV4ID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCB2ZXJ0ZXgudmVydGV4TGFiZWwubmFtZSwgdmVydGV4LnBvc2l0aW9uUHJvcGVydHkudmFsdWUgKTtcclxuICAgICAgICB9ICk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byB2ZXJ0ZXggcG9zaXRpb25zIGFyZSBhbGxvd2VkIGZvciB0aGUgcXVhZHJpbGF0ZXJhbC5cclxuICAgKi9cclxuICBwdWJsaWMgYXJlVmVydGV4UG9zaXRpb25zQWxsb3dlZCggbGFiZWxUb1Bvc2l0aW9uTWFwOiBWZXJ0ZXhMYWJlbFRvUHJvcG9zZWRQb3NpdGlvbk1hcCApOiBib29sZWFuIHtcclxuXHJcbiAgICAvLyBTZXQgdGhlIHRlc3Qgc2hhcGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGFjdHVhbCBzaGFwZSBiZWZvcmUgcHJvcG9zZWQgcG9zaXRpb25zXHJcbiAgICB0aGlzLnF1YWRyaWxhdGVyYWxUZXN0U2hhcGVNb2RlbC5zZXRGcm9tU2hhcGUoIHRoaXMucXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwgKTtcclxuICAgIHRoaXMucXVhZHJpbGF0ZXJhbFRlc3RTaGFwZU1vZGVsLnNldFZlcnRleFBvc2l0aW9ucyggbGFiZWxUb1Bvc2l0aW9uTWFwICk7XHJcbiAgICByZXR1cm4gUXVhZHJpbGF0ZXJhbFNoYXBlTW9kZWwuaXNRdWFkcmlsYXRlcmFsU2hhcGVBbGxvd2VkKCB0aGlzLnF1YWRyaWxhdGVyYWxUZXN0U2hhcGVNb2RlbCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXRzIHRoZSBtb2RlbC5cclxuICAgKi9cclxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcblxyXG4gICAgLy8gcmVzZXQgaXMgaW4gcHJvZ3Jlc3MgKG5vdC1ub3QgaW4gcHJvZ3Jlc3MpXHJcbiAgICB0aGlzLnJlc2V0Tm90SW5Qcm9ncmVzc1Byb3BlcnR5LnZhbHVlID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy52aXNpYmlsaXR5TW9kZWwucmVzZXQoKTtcclxuICAgIHRoaXMubG9ja1RvTWlub3JJbnRlcnZhbHNQcm9wZXJ0eS5yZXNldCgpO1xyXG4gICAgdGhpcy5zaGFwZVNvdW5kRW5hYmxlZFByb3BlcnR5LnJlc2V0KCk7XHJcblxyXG4gICAgdGhpcy5xdWFkcmlsYXRlcmFsU2hhcGVNb2RlbC5yZXNldCgpO1xyXG4gICAgdGhpcy5xdWFkcmlsYXRlcmFsVGVzdFNoYXBlTW9kZWwucmVzZXQoKTtcclxuXHJcbiAgICB0aGlzLnJlc2V0RW1pdHRlci5lbWl0KCk7XHJcblxyXG4gICAgLy8gcmVzZXQgaXMgbm90IGluIHByb2dyZXNzIGFueW1vcmVcclxuICAgIHRoaXMucmVzZXROb3RJblByb2dyZXNzUHJvcGVydHkudmFsdWUgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgY2xvc2VzdCBwb3NpdGlvbiBpbiB0aGUgbW9kZWwgZnJvbSB0aGUgcG9pbnQgcHJvdmlkZWQgdGhhdCB3aWxsIGJlIGNvbnN0cmFpbiB0aGUgcG9zaXRpb24gdG8gYWxpZ25cclxuICAgKiB3aXRoIHRoZSBtb2RlbCBncmlkLiBTZWUgdmVydGV4SW50ZXJ2YWxQcm9wZXJ0eSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgdGhlIGludGVydmFscyBvZiB0aGUgZ3JpZFxyXG4gICAqIGNhbiBjaGFuZ2UuXHJcbiAgICovXHJcbiAgcHVibGljIGdldENsb3Nlc3RHcmlkUG9zaXRpb24oIHByb3Bvc2VkUG9zaXRpb246IFZlY3RvcjIgKTogVmVjdG9yMiB7XHJcblxyXG4gICAgY29uc3QgaW50ZXJ2YWwgPSB0aGlzLnZlcnRleEludGVydmFsUHJvcGVydHkudmFsdWU7XHJcbiAgICByZXR1cm4gbmV3IFZlY3RvcjIoIFV0aWxzLnJvdW5kVG9JbnRlcnZhbCggcHJvcG9zZWRQb3NpdGlvbi54LCBpbnRlcnZhbCApLCBVdGlscy5yb3VuZFRvSW50ZXJ2YWwoIHByb3Bvc2VkUG9zaXRpb24ueSwgaW50ZXJ2YWwgKSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjbG9zZXN0IGdyaWQgcG9zaXRpb24gdG8gdGhlIHByb3Bvc2VkIHBvc2l0aW9uLCBpbiB4L3kgZGltZW5zaW9ucyBPUiBhbG9uZyB0aGUgZGlhZ29uYWwgaWYgd2UgZGV0ZWN0XHJcbiAgICogbW92ZW1lbnQgY2xvc2UgdG8gdGhlIGRpYWdvbmFsLiBUaGlzIGFsbG93cyB5b3UgdG8gZHJhZyBkaWFnb25hbGx5IGFjcm9zcyBncmlkIGNlbGxzIGlmIHlvdSB3YW50IHRvLCBjcmVhdGluZ1xyXG4gICAqIG1vcmUgaW50dWl0aXZlIGludGVyYWN0aW9uLlxyXG4gICAqXHJcbiAgICogVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gaXMgc3VtbWFyaXplZCBieVxyXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9xdWFkcmlsYXRlcmFsL2lzc3Vlcy80MDYjaXNzdWVjb21tZW50LTE0ODU5ODIxMTMuIElmIHRoZSBwcm9wb3NlZCBwb3NpdGlvblxyXG4gICAqIGlzIGNsb3NlIGVub3VnaCB0byBhIGRpYWdvbmFsIGxpbmUgYmV0d2VlbiB0aGUgZ3JpZCBwb2ludHMsIHdlIGFzc3VtZSB0aGF0IHRoZSB1c2VyIHdhbnRzIHRvIG1vdmUgZGlhZ29uYWxseVxyXG4gICAqIHNvIHdlIGRvbid0IHNuYXAgdG8gYXhpcy1hbGlnbmVkIHBvc2l0aW9ucy5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0Q2xvc2VzdEdyaWRQb3NpdGlvbkFsb25nRGlhZ29uYWwoIGN1cnJlbnRQb3NpdGlvbjogVmVjdG9yMiwgcHJvcG9zZWRQb3NpdGlvbjogVmVjdG9yMiApOiBWZWN0b3IyIHtcclxuXHJcbiAgICAvLyBBdCB0aGlzIHRpbnkgc3RlcCBzaXplLCB0aGlzIGZlYXR1cmUgaXMgbW9yZSBoYXJtIHRoYW4gaGVscCBhbmQgdGhlIGdyaWQgc2l6ZSBpcyBzbyBzbWFsbCB0aGF0IGl0XHJcbiAgICAvLyBtYWtlcyBzZW5zZSB0byBqdXN0IGdldCB0aGUgY2xvc2VzdCBncmlkIHBvc2l0aW9uLlxyXG4gICAgaWYgKCB0aGlzLnVzZU1pbm9ySW50ZXJ2YWxzUHJvcGVydHkudmFsdWUgJiYgUXVhZHJpbGF0ZXJhbFF1ZXJ5UGFyYW1ldGVycy5yZWR1Y2VkU3RlcFNpemUgKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldENsb3Nlc3RHcmlkUG9zaXRpb24oIHByb3Bvc2VkUG9zaXRpb24gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMudmVydGV4SW50ZXJ2YWxQcm9wZXJ0eS52YWx1ZTtcclxuXHJcbiAgICAvLyBjcmVhdGUgYSBkaWFnb25hbCBsaW5lIGZyb20gY3VycmVudFBvc2l0aW9uIHRvIG5leHQgaW50ZXJ2YWwsIGluIHRoZSBkaXJlY3Rpb24gb2YgbW92ZW1lbnRcclxuICAgIGNvbnN0IGRpYWdvbmFsSW50ZXJ2YWxQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbi5wbHVzWFkoXHJcbiAgICAgIGludGVydmFsICogKCBwcm9wb3NlZFBvc2l0aW9uLnggPiBjdXJyZW50UG9zaXRpb24ueCA/IDEgOiAtMSApLFxyXG4gICAgICBpbnRlcnZhbCAqICggcHJvcG9zZWRQb3NpdGlvbi55ID4gY3VycmVudFBvc2l0aW9uLnkgPyAxIDogLTEgKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBJZiB3ZSBhcmUgd2l0aGluIHRoaXMgZGlzdGFuY2UgdG8gdGhlIGRpYWdvbmFsIGxpbmUgYmV0d2VlbiBjdXJyZW50UG9zaXRpb24gYW5kIHByb3Bvc2VkUG9zaXRpb24gd2UgYXJlXHJcbiAgICAvLyBtb3ZpbmcgYWxvbmcgdGhlIGRpYWdvbmFsIGFuZCBzaG91bGQgdHJ5IHRvIGZpbmQgdGhlIGNsb3Nlc3QgZ3JpZCBwb3NpdGlvbiBhbG9uZyB0aGF0IGRpYWdvbmFsIGxpbmUuXHJcbiAgICAvLyBUaGlzIHZhbHVlIHdhcyBjaG9zZW4gYnkgaW5zcGVjdGlvbi4gSXQgaXMgZGlmZmljdWx0IHRvIGdldCBhIHZhbHVlIHRoYXQgXCJmZWVscyByaWdodFwiIHdpdGhvdXQgYmVpbmcgdG9vIGJpYXNlZFxyXG4gICAgLy8gdG93YXJkIGRpYWdvbmFsIG9yIG1vdmVtZW50IGFsb25nIHRoZSBheGlzLlxyXG4gICAgY29uc3QgbWF4aW11bURpYWdvbmFsRGlzdGFuY2UgPSBpbnRlcnZhbCAvIDQwMDtcclxuXHJcbiAgICBjb25zdCBkaXN0YW5jZVRvRGlhZ29uYWwgPSBVdGlscy5kaXN0VG9TZWdtZW50U3F1YXJlZCggcHJvcG9zZWRQb3NpdGlvbiwgY3VycmVudFBvc2l0aW9uLCBkaWFnb25hbEludGVydmFsUG9zaXRpb24gKTtcclxuICAgIGlmICggZGlzdGFuY2VUb0RpYWdvbmFsIDwgbWF4aW11bURpYWdvbmFsRGlzdGFuY2UgKSB7XHJcblxyXG4gICAgICAvLyBDbG9zZSBlbm91Z2ggdG8gYmUgbW92aW5nIGFsb25nIHRoZSBkaWFnb25hbCwgc28gdGhlIGludGVydmFsIG5lZWRzIHRvIGJlIGxhcmdlciB0byB0cmlnZ2VyIGEgdHJhbnNpdGlvbi5cclxuICAgICAgLy8gVmFsdWUgaXMgdGhlIGludGVydmFsIGFsb25nIHRoZSBkaWFnb25hbCBzbyB3ZSB1c2UgdGhlIHB5dGhhZ29yZWFuIHRoZW9yZW0uXHJcbiAgICAgIGNvbnN0IGhhbGZJbnRlcnZhbCA9IGludGVydmFsIC8gMjtcclxuICAgICAgY29uc3QgZGlhZ29uYWxJbnRlcnZhbCA9IE1hdGguc3FydCggaGFsZkludGVydmFsICogaGFsZkludGVydmFsICsgaGFsZkludGVydmFsICogaGFsZkludGVydmFsICk7XHJcbiAgICAgIGNvbnN0IGRpc3RhbmNlVG9DdXJyZW50UG9zaXRpb24gPSBjdXJyZW50UG9zaXRpb24uZGlzdGFuY2UoIHByb3Bvc2VkUG9zaXRpb24gKTtcclxuXHJcbiAgICAgIGlmICggZGlzdGFuY2VUb0N1cnJlbnRQb3NpdGlvbiA+IGRpYWdvbmFsSW50ZXJ2YWwgKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpYWdvbmFsSW50ZXJ2YWxQb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gZGlzdGFuY2UgYWxvbmcgdGhlIGRpYWdvbmFsIHdhcyBub3QgbGFyZ2UgZW5vdWdoLCBkb24ndCBtb3ZlXHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldENsb3Nlc3RHcmlkUG9zaXRpb24oIHByb3Bvc2VkUG9zaXRpb24gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY2xvc2VzdCBncmlkIHBvc2l0aW9uIHRvIHRoZSBwcm92aWRlZCBwb3NpdGlvbiwgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgcHJvdmlkZWQgZGlyZWN0aW9uVmVjdG9yLlxyXG4gICAqIFVzZSB0aGlzIHdoZW4geW91IG5lZWQgdG8gbW92ZSB0byB0aGUgY2xvc2VzdCBncmlkIHBvc2l0aW9uIGluIG9uZSBkaW1lbnNpb24sIGluc3RlYWQgb2YgbW92aW5nIHRvIHRoZVxyXG4gICAqIGNsb3Nlc3QgZ3JpZCBwb3NpdGlvbiBpbiBib3RoIFggYW5kIFkuXHJcbiAgICovXHJcbiAgcHVibGljIGdldENsb3Nlc3RHcmlkUG9zaXRpb25JbkRpcmVjdGlvbiggY3VycmVudFBvc2l0aW9uOiBWZWN0b3IyLCBkaXJlY3Rpb25WZWN0b3I6IFZlY3RvcjIgKTogVmVjdG9yMiB7XHJcbiAgICBsZXQgbmV4dFggPSBjdXJyZW50UG9zaXRpb24ueDtcclxuICAgIGxldCBuZXh0WSA9IGN1cnJlbnRQb3NpdGlvbi55O1xyXG5cclxuICAgIGlmICggZGlyZWN0aW9uVmVjdG9yLnggIT09IDAgKSB7XHJcbiAgICAgIG5leHRYID0gdGhpcy5nZXROZXh0UG9zaXRpb25JbkRpbWVuc2lvbiggY3VycmVudFBvc2l0aW9uLCBkaXJlY3Rpb25WZWN0b3IsICd4JyApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIGRpcmVjdGlvblZlY3Rvci55ICE9PSAwICkge1xyXG4gICAgICBuZXh0WSA9IHRoaXMuZ2V0TmV4dFBvc2l0aW9uSW5EaW1lbnNpb24oIGN1cnJlbnRQb3NpdGlvbiwgZGlyZWN0aW9uVmVjdG9yLCAneScgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFZlY3RvcjIoIG5leHRYLCBuZXh0WSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBuZXh0IHZhbHVlIG9uIHRoZSBpbnRlcnZhbCBpbiBwcm92aWRlZCBkaW1lbnNpb24uIFRoZSBmb2xsb3dpbmcgZGlhZ3JhbSBkZW1vbnN0cmF0ZXMgaG93IHRoaXMgd29ya3M6XHJcbiAgICogICAgICAgICAgICAgICAgaW50ZXJ2YWxcclxuICAgKiAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLXxcclxuICAgKiAgICAgICAgICAgICAgQVxyXG4gICAqICAgICAgICAgfC0tLS0tLS0tLXxcclxuICAgKiAtLS0tLUMtLSotfC0qLS0tLS18LS0tLS0qLXwtKi0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLXxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIEJcclxuICAgKiAgQzogY3VycmVudFZhbHVlXHJcbiAgICogIEE6IElmIHRoZSB2YWx1ZSBsYW5kcyBpbiB0aGlzIHJlZ2lvbiwgbmV4dCBwb3NpdGlvbiBzaG91bGQgYmUgbGVmdCBzaWRlIG9mIGludGVydmFsLlxyXG4gICAqICBCOiBJZiB2YWx1ZSBsYW5kcyBpbiB0aGlzIHJlZ2lvbiwgbmV4dCBwb3NpdGlvbiBzaG91bGQgYmUgcmlnaHQgc2lkZSBvZiBpbnRlcnZhbC5cclxuICAgKiAgKjogc21hbGwgb2Zmc2V0IHNvIGlmIGN1cnJlbnRWYWx1ZSBpcyB2ZXJ5IGNsb3NlIHRvIHRoZSBpbnRlcnZhbCwgd2Ugd2lsbCByb3VuZCB0byBuZXh0IGludGVydmFsLlxyXG4gICAqXHJcbiAgICogIFNvIHRoZSBsZW5ndGggb2YgQSAob3IgQikgaXMgYWRkZWQgdG8gY3VycmVudFZhbHVlIGJlZm9yZSByb3VuZGluZyB0byB0aGUgaW50ZXJ2YWwuXHJcbiAgICpcclxuICAgKiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9xdWFkcmlsYXRlcmFsL2lzc3Vlcy80MDIgZm9yIG1vcmUgaW1wbGVtZW50YXRpb24gbm90ZXMuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXROZXh0UG9zaXRpb25JbkRpbWVuc2lvbiggY3VycmVudFBvc2l0aW9uOiBWZWN0b3IyLCBkaXJlY3Rpb25WZWN0b3I6IFZlY3RvcjIsIGRpbWVuc2lvbjogJ3gnIHwgJ3knICk6IG51bWJlciB7XHJcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBjdXJyZW50UG9zaXRpb25bIGRpbWVuc2lvbiBdO1xyXG4gICAgY29uc3QgZ2V0dGluZ0xhcmdlciA9IGRpcmVjdGlvblZlY3RvclsgZGltZW5zaW9uIF0gPiAwO1xyXG4gICAgY29uc3QgaW50ZXJ2YWwgPSB0aGlzLnZlcnRleEludGVydmFsUHJvcGVydHkudmFsdWU7XHJcblxyXG4gICAgY29uc3QgZGVsdGEgPSAwLjAxICsgaW50ZXJ2YWwgLyAyO1xyXG4gICAgY29uc3Qgc2lnbiA9IGdldHRpbmdMYXJnZXIgPyAxIDogLTE7XHJcbiAgICByZXR1cm4gVXRpbHMucm91bmRUb0ludGVydmFsKCBjdXJyZW50VmFsdWUgKyBzaWduICogZGVsdGEsIGludGVydmFsICk7XHJcbiAgfVxyXG59XHJcblxyXG5xdWFkcmlsYXRlcmFsLnJlZ2lzdGVyKCAnUXVhZHJpbGF0ZXJhbE1vZGVsJywg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