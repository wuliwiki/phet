// Copyright 2018-2023, University of Colorado Boulder

/**
 * This file contains the subset of es6 features that are supported in the PhET sim codebase. If there is desirable
 * es6 code that isn't in this file. Likely it should be discussed in a dev meeting and tested with babel transpiling
 * before use. Commented out es6 features in this file are disallowed in the code base. They likely are accompanied by
 * a comment explaining why it is off limits.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import interleave from '../../../../phet-core/js/interleave.js';
import { Node } from '../../../../scenery/js/imports.js';
import wilder from '../../wilder.js';
import WilderOptionsPatterns from './WilderOptionsPatterns.js';
import WilderEnumerationPatterns from './WilderEnumerationPatterns.js';
// Commented out for the currently-unsupported ES6 features
// const Utils = require( '/dot/js/Utils' );
// constants
const something = 'foo';
class WilderModel {
  constructor(providedOptions) {
    this.wilderOptionsPatterns = new WilderOptionsPatterns();
    this.wilderEnumerationPatterns = new WilderEnumerationPatterns({
      tandem: providedOptions.tandem.createTandem('wilderEnumerationPatterns')
    });

    // We want a built version to error out for these "asserts"
    function hardAssert(condition, message = '') {
      if (!condition) {
        throw new Error(message);
      }
    }

    // block scoping for let/const
    const blocky = 'outside';
    if (window) {
      const blocky = 'inside';
      hardAssert(blocky === 'inside');
    }
    for (let blocky = 0; blocky <= 0; blocky++) {
      hardAssert(blocky === 0);
    }
    hardAssert(blocky === 'outside');

    // Expression-based arrow functions
    hardAssert(_.range(0, 5).map(x => x * x)[3] === 9);

    // Statement-based arrow functions
    hardAssert(_.range(0, 5).map(x => {
      hardAssert(x < 5);
      return x * x;
    })[3] === 9);
    const self = this; // eslint-disable-line @typescript-eslint/no-this-alias
    [1].forEach(() => {
      hardAssert(this === self);
    });

    // Default function parameters
    function defaults(x = 1, y = 2, z = 3) {
      return x + y + z;
    }
    hardAssert(defaults(0) === 5);

    // Rest parameters
    function rest(x, y, ...others) {
      return x + y + others.length;
    }
    hardAssert(rest(1, 2, 3, 4, 5, 6) === 7);

    // Spread operator - NOTE Do not use this on "array like" things, it doesn't get transpiled correctly. Instead use
    // `Array.from`. See https://github.com/phetsims/perennial/issues/153
    const constArray = [1, 2, 3];
    hardAssert([...constArray, 4, 5, ...constArray].length === 8);

    // String interpolation
    hardAssert(`Testing ${2 + 3}` === 'Testing 5');

    // Custom interpolation
    function quoter(strings, ...quotations) {
      return interleave(strings, i => `"${quotations[i]}"`).join('');
    }
    hardAssert(quoter`He said ${something} but then answered ${3 * 2}` === 'He said "foo" but then answered "6"');
    const multiLineString = `This
 is a test of the emergency
 newline system`;
    hardAssert(multiLineString.length === 48);

    // Binary
    hardAssert(3 + 4 === 0b111);

    // Object shorthand is not allowed in PhET code! Note that method shorthand is ok, like `{ listener(){} }`
    const a = 5;
    const b = 4;
    const shortObj = {
      a,
      b
    }; // eslint-disable-line phet-object-shorthand
    hardAssert(shortObj.a === a);
    hardAssert(shortObj.b === b);

    // Computed property names
    const computedObj = {
      [something]: a
    };
    hardAssert(computedObj[something] === a);

    // Method notation
    const methodObj = {
      add(a, b) {
        return a + b;
      }
    };
    hardAssert(methodObj.add(1, 2) === 3);

    // Array destructuring
    const arrList = [1, 2, 3];
    const [firstElement,, thirdElement] = arrList;
    hardAssert(firstElement === arrList[0]);
    hardAssert(thirdElement === arrList[2]);

    // Swapping with destructuring
    let arf = 5;
    let woof = 10;
    [arf, woof] = [woof, arf];
    hardAssert(arf === 10);
    hardAssert(woof === 5);

    // Object destructuring
    // NOTE: This is not allowed in PhET code because of the challenge it creates in renaming object keys,
    // see https://github.com/phetsims/chipper/issues/758
    const destObject = {
      cat: 5,
      mouse: {
        animals: [1, 2]
      },
      bird: 'canary'
    };
    const {
      cat,
      bird
    } = destObject;
    hardAssert(cat === destObject.cat);
    hardAssert(bird === destObject.bird);
    const {
      cat: tabby
    } = destObject;
    hardAssert(tabby === destObject.cat);
    const {
      mouse: {
        animals
      }
    } = destObject;
    hardAssert(animals === destObject.mouse.animals);

    // Parameter destructuring
    function destruct({
      cat,
      mouse: {
        animals: [firstAnimal]
      }
    }) {
      return cat + firstAnimal;
    }
    hardAssert(destruct(destObject) === destObject.cat + destObject.mouse.animals[0]);

    // Options object destructuring with defaults

    const optionsObject = {
      tree: 4,
      forest: 5
    };
    const {
      tree = 12,
      forest = 100,
      leaf = 1024
    } = optionsObject || {};
    hardAssert(tree === 4);
    hardAssert(forest === 5);
    hardAssert(leaf === 1024);
    class SecretNode extends Node {
      // @ts-expect-error
      _mutatorKeys = [...Node.prototype._mutatorKeys, 'secret'];
      constructor(options) {
        // Can't reference `this` before the super() call
        // Don't pass options here, since want to initialize defaults before passing options to mutate. We still only
        // want to call mutate once per constructor.
        super();
        this._secret = 42;

        // mutate after instance variables have been assigned.
        this.mutate(options);
      }
      set secret(value) {
        this._secret = value;
      }
      get secret() {
        return this._secret;
      }
      dispose() {
        super.dispose();
        this._secret = 0; // Don't tell!
      }

      static createSecretNode() {
        return new SecretNode({
          secret: 0
        });
      }
    }
    hardAssert(new SecretNode({
      secret: 5
    }).secret === 5);
    hardAssert(new SecretNode({
      opacity: 0.5
    }).opacity === 0.5);
    hardAssert(SecretNode.createSecretNode().secret === 0);

    // Unsupported without babel-polyfill, commented out for now. DO NOT USE in simulations. May be used in the future.
    // Iterable class (with a generator method)
    // class RelativePrimes {
    //   private n: number;
    //   constructor( n ) {
    //     this.n = n;
    //   }
    //   *[Symbol.iterator]() {
    //     for ( let i = 1;; i++ ) {
    //       if ( Utils.gcd( i, this.n ) === 1 ) {
    //         yield i;
    //       }
    //     }
    //   }
    // }
    // // Find all relative primes to 5 less than 12.
    // const relativePrimes = [];
    // for ( const n of new RelativePrimes( 5 ) ) {
    //   if ( n >= 12 ) { break; }
    //   relativePrimes.push( n );
    // }
    // hardAssert( _.isEqual( relativePrimes, [ 1, 2, 3, 4, 6, 7, 8, 9, 11 ] ) );

    // Sets
    const bag = new Set();
    bag.add('a').add('b').add('a');
    hardAssert(bag.size === 2);
    hardAssert(bag.has('a'));
    hardAssert(!bag.has('c'));

    // Maps
    const map = new Map();
    map.set(bag, 5);
    map.set(Node, 2);
    hardAssert(map.get(bag) === 5);
    hardAssert(map.get(Node) === 2);
  }

  /**
   */
  reset() {
    // console.log( 'reset' );
  }
}
wilder.register('WilderModel', WilderModel);
export default WilderModel;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpbnRlcmxlYXZlIiwiTm9kZSIsIndpbGRlciIsIldpbGRlck9wdGlvbnNQYXR0ZXJucyIsIldpbGRlckVudW1lcmF0aW9uUGF0dGVybnMiLCJzb21ldGhpbmciLCJXaWxkZXJNb2RlbCIsImNvbnN0cnVjdG9yIiwicHJvdmlkZWRPcHRpb25zIiwid2lsZGVyT3B0aW9uc1BhdHRlcm5zIiwid2lsZGVyRW51bWVyYXRpb25QYXR0ZXJucyIsInRhbmRlbSIsImNyZWF0ZVRhbmRlbSIsImhhcmRBc3NlcnQiLCJjb25kaXRpb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJibG9ja3kiLCJ3aW5kb3ciLCJfIiwicmFuZ2UiLCJtYXAiLCJ4Iiwic2VsZiIsImZvckVhY2giLCJkZWZhdWx0cyIsInkiLCJ6IiwicmVzdCIsIm90aGVycyIsImxlbmd0aCIsImNvbnN0QXJyYXkiLCJxdW90ZXIiLCJzdHJpbmdzIiwicXVvdGF0aW9ucyIsImkiLCJqb2luIiwibXVsdGlMaW5lU3RyaW5nIiwiYSIsImIiLCJzaG9ydE9iaiIsImNvbXB1dGVkT2JqIiwibWV0aG9kT2JqIiwiYWRkIiwiYXJyTGlzdCIsImZpcnN0RWxlbWVudCIsInRoaXJkRWxlbWVudCIsImFyZiIsIndvb2YiLCJkZXN0T2JqZWN0IiwiY2F0IiwibW91c2UiLCJhbmltYWxzIiwiYmlyZCIsInRhYmJ5IiwiZGVzdHJ1Y3QiLCJmaXJzdEFuaW1hbCIsIm9wdGlvbnNPYmplY3QiLCJ0cmVlIiwiZm9yZXN0IiwibGVhZiIsIlNlY3JldE5vZGUiLCJfbXV0YXRvcktleXMiLCJwcm90b3R5cGUiLCJvcHRpb25zIiwiX3NlY3JldCIsIm11dGF0ZSIsInNlY3JldCIsInZhbHVlIiwiZGlzcG9zZSIsImNyZWF0ZVNlY3JldE5vZGUiLCJvcGFjaXR5IiwiYmFnIiwiU2V0Iiwic2l6ZSIsImhhcyIsIk1hcCIsInNldCIsImdldCIsInJlc2V0IiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJXaWxkZXJNb2RlbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHN1YnNldCBvZiBlczYgZmVhdHVyZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGluIHRoZSBQaEVUIHNpbSBjb2RlYmFzZS4gSWYgdGhlcmUgaXMgZGVzaXJhYmxlXHJcbiAqIGVzNiBjb2RlIHRoYXQgaXNuJ3QgaW4gdGhpcyBmaWxlLiBMaWtlbHkgaXQgc2hvdWxkIGJlIGRpc2N1c3NlZCBpbiBhIGRldiBtZWV0aW5nIGFuZCB0ZXN0ZWQgd2l0aCBiYWJlbCB0cmFuc3BpbGluZ1xyXG4gKiBiZWZvcmUgdXNlLiBDb21tZW50ZWQgb3V0IGVzNiBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgYXJlIGRpc2FsbG93ZWQgaW4gdGhlIGNvZGUgYmFzZS4gVGhleSBsaWtlbHkgYXJlIGFjY29tcGFuaWVkIGJ5XHJcbiAqIGEgY29tbWVudCBleHBsYWluaW5nIHdoeSBpdCBpcyBvZmYgbGltaXRzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XHJcbiAqL1xyXG5cclxuaW1wb3J0IGludGVybGVhdmUgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL2ludGVybGVhdmUuanMnO1xyXG5pbXBvcnQgeyBOb2RlLCBOb2RlT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCB3aWxkZXIgZnJvbSAnLi4vLi4vd2lsZGVyLmpzJztcclxuaW1wb3J0IFdpbGRlck9wdGlvbnNQYXR0ZXJucyBmcm9tICcuL1dpbGRlck9wdGlvbnNQYXR0ZXJucy5qcyc7XHJcbmltcG9ydCBXaWxkZXJFbnVtZXJhdGlvblBhdHRlcm5zIGZyb20gJy4vV2lsZGVyRW51bWVyYXRpb25QYXR0ZXJucy5qcyc7XHJcbmltcG9ydCBUYW5kZW0gZnJvbSAnLi4vLi4vLi4vLi4vdGFuZGVtL2pzL1RhbmRlbS5qcyc7XHJcbmltcG9ydCBUTW9kZWwgZnJvbSAnLi4vLi4vLi4vLi4vam9pc3QvanMvVE1vZGVsLmpzJztcclxuXHJcbi8vIENvbW1lbnRlZCBvdXQgZm9yIHRoZSBjdXJyZW50bHktdW5zdXBwb3J0ZWQgRVM2IGZlYXR1cmVzXHJcbi8vIGNvbnN0IFV0aWxzID0gcmVxdWlyZSggJy9kb3QvanMvVXRpbHMnICk7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3Qgc29tZXRoaW5nID0gJ2Zvbyc7XHJcblxyXG50eXBlIFdpbGRlck1vZGVsT3B0aW9ucyA9IHtcclxuICB0YW5kZW06IFRhbmRlbTtcclxufTtcclxuXHJcbmNsYXNzIFdpbGRlck1vZGVsIGltcGxlbWVudHMgVE1vZGVsIHtcclxuICBwcml2YXRlIHdpbGRlck9wdGlvbnNQYXR0ZXJuczogV2lsZGVyT3B0aW9uc1BhdHRlcm5zO1xyXG4gIHByaXZhdGUgd2lsZGVyRW51bWVyYXRpb25QYXR0ZXJuczogV2lsZGVyRW51bWVyYXRpb25QYXR0ZXJucztcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBwcm92aWRlZE9wdGlvbnM6IFdpbGRlck1vZGVsT3B0aW9ucyApIHtcclxuXHJcbiAgICB0aGlzLndpbGRlck9wdGlvbnNQYXR0ZXJucyA9IG5ldyBXaWxkZXJPcHRpb25zUGF0dGVybnMoKTtcclxuICAgIHRoaXMud2lsZGVyRW51bWVyYXRpb25QYXR0ZXJucyA9IG5ldyBXaWxkZXJFbnVtZXJhdGlvblBhdHRlcm5zKCB7XHJcbiAgICAgIHRhbmRlbTogcHJvdmlkZWRPcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICd3aWxkZXJFbnVtZXJhdGlvblBhdHRlcm5zJyApXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gV2Ugd2FudCBhIGJ1aWx0IHZlcnNpb24gdG8gZXJyb3Igb3V0IGZvciB0aGVzZSBcImFzc2VydHNcIlxyXG4gICAgZnVuY3Rpb24gaGFyZEFzc2VydCggY29uZGl0aW9uOiBib29sZWFuLCBtZXNzYWdlID0gJycgKTogdm9pZCB7XHJcbiAgICAgIGlmICggIWNvbmRpdGlvbiApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIG1lc3NhZ2UgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGJsb2NrIHNjb3BpbmcgZm9yIGxldC9jb25zdFxyXG4gICAgY29uc3QgYmxvY2t5ID0gJ291dHNpZGUnO1xyXG4gICAgaWYgKCB3aW5kb3cgKSB7XHJcbiAgICAgIGNvbnN0IGJsb2NreSA9ICdpbnNpZGUnO1xyXG4gICAgICBoYXJkQXNzZXJ0KCBibG9ja3kgPT09ICdpbnNpZGUnICk7XHJcbiAgICB9XHJcbiAgICBmb3IgKCBsZXQgYmxvY2t5ID0gMDsgYmxvY2t5IDw9IDA7IGJsb2NreSsrICkge1xyXG4gICAgICBoYXJkQXNzZXJ0KCBibG9ja3kgPT09IDAgKTtcclxuICAgIH1cclxuICAgIGhhcmRBc3NlcnQoIGJsb2NreSA9PT0gJ291dHNpZGUnICk7XHJcblxyXG4gICAgLy8gRXhwcmVzc2lvbi1iYXNlZCBhcnJvdyBmdW5jdGlvbnNcclxuICAgIGhhcmRBc3NlcnQoIF8ucmFuZ2UoIDAsIDUgKS5tYXAoICggeDogbnVtYmVyICkgPT4geCAqIHggKVsgMyBdID09PSA5ICk7XHJcblxyXG4gICAgLy8gU3RhdGVtZW50LWJhc2VkIGFycm93IGZ1bmN0aW9uc1xyXG4gICAgaGFyZEFzc2VydCggXy5yYW5nZSggMCwgNSApLm1hcCggKCB4OiBudW1iZXIgKSA9PiB7XHJcbiAgICAgIGhhcmRBc3NlcnQoIHggPCA1ICk7XHJcbiAgICAgIHJldHVybiB4ICogeDtcclxuICAgIH0gKVsgMyBdID09PSA5ICk7XHJcblxyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcclxuICAgIFsgMSBdLmZvckVhY2goICgpID0+IHtcclxuICAgICAgaGFyZEFzc2VydCggdGhpcyA9PT0gc2VsZiApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIERlZmF1bHQgZnVuY3Rpb24gcGFyYW1ldGVyc1xyXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoIHggPSAxLCB5ID0gMiwgeiA9IDMgKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHggKyB5ICsgejtcclxuICAgIH1cclxuXHJcbiAgICBoYXJkQXNzZXJ0KCBkZWZhdWx0cyggMCApID09PSA1ICk7XHJcblxyXG4gICAgLy8gUmVzdCBwYXJhbWV0ZXJzXHJcbiAgICBmdW5jdGlvbiByZXN0KCB4OiBudW1iZXIsIHk6IG51bWJlciwgLi4ub3RoZXJzOiBudW1iZXJbXSApOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4geCArIHkgKyBvdGhlcnMubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGhhcmRBc3NlcnQoIHJlc3QoIDEsIDIsIDMsIDQsIDUsIDYgKSA9PT0gNyApO1xyXG5cclxuICAgIC8vIFNwcmVhZCBvcGVyYXRvciAtIE5PVEUgRG8gbm90IHVzZSB0aGlzIG9uIFwiYXJyYXkgbGlrZVwiIHRoaW5ncywgaXQgZG9lc24ndCBnZXQgdHJhbnNwaWxlZCBjb3JyZWN0bHkuIEluc3RlYWQgdXNlXHJcbiAgICAvLyBgQXJyYXkuZnJvbWAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGVyZW5uaWFsL2lzc3Vlcy8xNTNcclxuICAgIGNvbnN0IGNvbnN0QXJyYXkgPSBbIDEsIDIsIDMgXTtcclxuICAgIGhhcmRBc3NlcnQoIFsgLi4uY29uc3RBcnJheSwgNCwgNSwgLi4uY29uc3RBcnJheSBdLmxlbmd0aCA9PT0gOCApO1xyXG5cclxuICAgIC8vIFN0cmluZyBpbnRlcnBvbGF0aW9uXHJcbiAgICBoYXJkQXNzZXJ0KCBgVGVzdGluZyAkezIgKyAzfWAgPT09ICdUZXN0aW5nIDUnICk7XHJcblxyXG4gICAgLy8gQ3VzdG9tIGludGVycG9sYXRpb25cclxuICAgIGZ1bmN0aW9uIHF1b3Rlciggc3RyaW5nczogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLnF1b3RhdGlvbnM6ICggc3RyaW5nIHwgbnVtYmVyIClbXSApOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gaW50ZXJsZWF2ZSggc3RyaW5ncywgKCBpOiBudW1iZXIgKSA9PiBgXCIke3F1b3RhdGlvbnNbIGkgXX1cImAgKS5qb2luKCAnJyApO1xyXG4gICAgfVxyXG5cclxuICAgIGhhcmRBc3NlcnQoIHF1b3RlcmBIZSBzYWlkICR7c29tZXRoaW5nfSBidXQgdGhlbiBhbnN3ZXJlZCAkezMgKiAyfWAgPT09ICdIZSBzYWlkIFwiZm9vXCIgYnV0IHRoZW4gYW5zd2VyZWQgXCI2XCInICk7XHJcblxyXG4gICAgY29uc3QgbXVsdGlMaW5lU3RyaW5nID0gYFRoaXNcclxuIGlzIGEgdGVzdCBvZiB0aGUgZW1lcmdlbmN5XHJcbiBuZXdsaW5lIHN5c3RlbWA7XHJcbiAgICBoYXJkQXNzZXJ0KCBtdWx0aUxpbmVTdHJpbmcubGVuZ3RoID09PSA0OCApO1xyXG5cclxuICAgIC8vIEJpbmFyeVxyXG4gICAgaGFyZEFzc2VydCggMyArIDQgPT09IDBiMTExICk7XHJcblxyXG4gICAgLy8gT2JqZWN0IHNob3J0aGFuZCBpcyBub3QgYWxsb3dlZCBpbiBQaEVUIGNvZGUhIE5vdGUgdGhhdCBtZXRob2Qgc2hvcnRoYW5kIGlzIG9rLCBsaWtlIGB7IGxpc3RlbmVyKCl7fSB9YFxyXG4gICAgY29uc3QgYSA9IDU7XHJcbiAgICBjb25zdCBiID0gNDtcclxuICAgIGNvbnN0IHNob3J0T2JqID0geyBhLCBiIH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcGhldC1vYmplY3Qtc2hvcnRoYW5kXHJcbiAgICBoYXJkQXNzZXJ0KCBzaG9ydE9iai5hID09PSBhICk7XHJcbiAgICBoYXJkQXNzZXJ0KCBzaG9ydE9iai5iID09PSBiICk7XHJcblxyXG4gICAgLy8gQ29tcHV0ZWQgcHJvcGVydHkgbmFtZXNcclxuICAgIGNvbnN0IGNvbXB1dGVkT2JqID0ge1xyXG4gICAgICBbIHNvbWV0aGluZyBdOiBhXHJcbiAgICB9O1xyXG4gICAgaGFyZEFzc2VydCggY29tcHV0ZWRPYmpbIHNvbWV0aGluZyBdID09PSBhICk7XHJcblxyXG4gICAgLy8gTWV0aG9kIG5vdGF0aW9uXHJcbiAgICBjb25zdCBtZXRob2RPYmogPSB7XHJcbiAgICAgIGFkZCggYTogbnVtYmVyLCBiOiBudW1iZXIgKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgKyBiO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgaGFyZEFzc2VydCggbWV0aG9kT2JqLmFkZCggMSwgMiApID09PSAzICk7XHJcblxyXG4gICAgLy8gQXJyYXkgZGVzdHJ1Y3R1cmluZ1xyXG4gICAgY29uc3QgYXJyTGlzdCA9IFsgMSwgMiwgMyBdO1xyXG4gICAgY29uc3QgWyBmaXJzdEVsZW1lbnQsICwgdGhpcmRFbGVtZW50IF0gPSBhcnJMaXN0O1xyXG4gICAgaGFyZEFzc2VydCggZmlyc3RFbGVtZW50ID09PSBhcnJMaXN0WyAwIF0gKTtcclxuICAgIGhhcmRBc3NlcnQoIHRoaXJkRWxlbWVudCA9PT0gYXJyTGlzdFsgMiBdICk7XHJcblxyXG4gICAgLy8gU3dhcHBpbmcgd2l0aCBkZXN0cnVjdHVyaW5nXHJcbiAgICBsZXQgYXJmID0gNTtcclxuICAgIGxldCB3b29mID0gMTA7XHJcbiAgICBbIGFyZiwgd29vZiBdID0gWyB3b29mLCBhcmYgXTtcclxuICAgIGhhcmRBc3NlcnQoIGFyZiA9PT0gMTAgKTtcclxuICAgIGhhcmRBc3NlcnQoIHdvb2YgPT09IDUgKTtcclxuXHJcbiAgICAvLyBPYmplY3QgZGVzdHJ1Y3R1cmluZ1xyXG4gICAgLy8gTk9URTogVGhpcyBpcyBub3QgYWxsb3dlZCBpbiBQaEVUIGNvZGUgYmVjYXVzZSBvZiB0aGUgY2hhbGxlbmdlIGl0IGNyZWF0ZXMgaW4gcmVuYW1pbmcgb2JqZWN0IGtleXMsXHJcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NoaXBwZXIvaXNzdWVzLzc1OFxyXG4gICAgY29uc3QgZGVzdE9iamVjdCA9IHtcclxuICAgICAgY2F0OiA1LFxyXG4gICAgICBtb3VzZToge1xyXG4gICAgICAgIGFuaW1hbHM6IFsgMSwgMiBdXHJcbiAgICAgIH0sXHJcbiAgICAgIGJpcmQ6ICdjYW5hcnknXHJcbiAgICB9O1xyXG4gICAgY29uc3QgeyBjYXQsIGJpcmQgfSA9IGRlc3RPYmplY3Q7XHJcbiAgICBoYXJkQXNzZXJ0KCBjYXQgPT09IGRlc3RPYmplY3QuY2F0ICk7XHJcbiAgICBoYXJkQXNzZXJ0KCBiaXJkID09PSBkZXN0T2JqZWN0LmJpcmQgKTtcclxuICAgIGNvbnN0IHsgY2F0OiB0YWJieSB9ID0gZGVzdE9iamVjdDtcclxuICAgIGhhcmRBc3NlcnQoIHRhYmJ5ID09PSBkZXN0T2JqZWN0LmNhdCApO1xyXG4gICAgY29uc3QgeyBtb3VzZTogeyBhbmltYWxzIH0gfSA9IGRlc3RPYmplY3Q7XHJcbiAgICBoYXJkQXNzZXJ0KCBhbmltYWxzID09PSBkZXN0T2JqZWN0Lm1vdXNlLmFuaW1hbHMgKTtcclxuXHJcbiAgICAvLyBQYXJhbWV0ZXIgZGVzdHJ1Y3R1cmluZ1xyXG4gICAgZnVuY3Rpb24gZGVzdHJ1Y3QoIHsgY2F0LCBtb3VzZTogeyBhbmltYWxzOiBbIGZpcnN0QW5pbWFsIF0gfSB9OiB7IGNhdDogbnVtYmVyOyBtb3VzZTogeyBhbmltYWxzOiBudW1iZXJbXSB9IH0gKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIGNhdCArIGZpcnN0QW5pbWFsO1xyXG4gICAgfVxyXG5cclxuICAgIGhhcmRBc3NlcnQoIGRlc3RydWN0KCBkZXN0T2JqZWN0ICkgPT09IGRlc3RPYmplY3QuY2F0ICsgZGVzdE9iamVjdC5tb3VzZS5hbmltYWxzWyAwIF0gKTtcclxuXHJcbiAgICAvLyBPcHRpb25zIG9iamVjdCBkZXN0cnVjdHVyaW5nIHdpdGggZGVmYXVsdHNcclxuICAgIHR5cGUgT3B0aW9uc1R5cGUgPSB7XHJcbiAgICAgIHRyZWU/OiBudW1iZXI7XHJcbiAgICAgIGZvcmVzdD86IG51bWJlcjtcclxuICAgICAgbGVhZj86IG51bWJlcjtcclxuICAgIH07XHJcbiAgICBjb25zdCBvcHRpb25zT2JqZWN0OiBPcHRpb25zVHlwZSA9IHtcclxuICAgICAgdHJlZTogNCxcclxuICAgICAgZm9yZXN0OiA1XHJcbiAgICB9O1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB0cmVlID0gMTIsXHJcbiAgICAgIGZvcmVzdCA9IDEwMCxcclxuICAgICAgbGVhZiA9IDEwMjRcclxuICAgIH0gPSBvcHRpb25zT2JqZWN0IHx8IHt9O1xyXG4gICAgaGFyZEFzc2VydCggdHJlZSA9PT0gNCApO1xyXG4gICAgaGFyZEFzc2VydCggZm9yZXN0ID09PSA1ICk7XHJcbiAgICBoYXJkQXNzZXJ0KCBsZWFmID09PSAxMDI0ICk7XHJcblxyXG5cclxuICAgIHR5cGUgU2VjcmV0U2VsZk9wdGlvbnMgPSB7XHJcbiAgICAgIHNlY3JldD86IG51bWJlcjtcclxuICAgIH07XHJcbiAgICB0eXBlIFNlY3JldE9wdGlvbnMgPSBTZWNyZXRTZWxmT3B0aW9ucyAmIE5vZGVPcHRpb25zO1xyXG4gICAgY2xhc3MgU2VjcmV0Tm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgICBwdWJsaWMgX211dGF0b3JLZXlzID0gWyAuLi5Ob2RlLnByb3RvdHlwZS5fbXV0YXRvcktleXMsICdzZWNyZXQnIF07XHJcbiAgICAgIHByaXZhdGUgX3NlY3JldDogbnVtYmVyO1xyXG5cclxuICAgICAgcHVibGljIGNvbnN0cnVjdG9yKCBvcHRpb25zPzogU2VjcmV0T3B0aW9ucyApIHtcclxuXHJcbiAgICAgICAgLy8gQ2FuJ3QgcmVmZXJlbmNlIGB0aGlzYCBiZWZvcmUgdGhlIHN1cGVyKCkgY2FsbFxyXG4gICAgICAgIC8vIERvbid0IHBhc3Mgb3B0aW9ucyBoZXJlLCBzaW5jZSB3YW50IHRvIGluaXRpYWxpemUgZGVmYXVsdHMgYmVmb3JlIHBhc3Npbmcgb3B0aW9ucyB0byBtdXRhdGUuIFdlIHN0aWxsIG9ubHlcclxuICAgICAgICAvLyB3YW50IHRvIGNhbGwgbXV0YXRlIG9uY2UgcGVyIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3NlY3JldCA9IDQyO1xyXG5cclxuICAgICAgICAvLyBtdXRhdGUgYWZ0ZXIgaW5zdGFuY2UgdmFyaWFibGVzIGhhdmUgYmVlbiBhc3NpZ25lZC5cclxuICAgICAgICB0aGlzLm11dGF0ZSggb3B0aW9ucyApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgc2V0IHNlY3JldCggdmFsdWUgKSB7IHRoaXMuX3NlY3JldCA9IHZhbHVlOyB9XHJcblxyXG4gICAgICBwdWJsaWMgZ2V0IHNlY3JldCgpIHsgcmV0dXJuIHRoaXMuX3NlY3JldDsgfVxyXG5cclxuICAgICAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuX3NlY3JldCA9IDA7IC8vIERvbid0IHRlbGwhXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlU2VjcmV0Tm9kZSgpOiBTZWNyZXROb2RlIHsgcmV0dXJuIG5ldyBTZWNyZXROb2RlKCB7IHNlY3JldDogMCB9ICk7IH1cclxuICAgIH1cclxuXHJcbiAgICBoYXJkQXNzZXJ0KCBuZXcgU2VjcmV0Tm9kZSggeyBzZWNyZXQ6IDUgfSApLnNlY3JldCA9PT0gNSApO1xyXG4gICAgaGFyZEFzc2VydCggbmV3IFNlY3JldE5vZGUoIHsgb3BhY2l0eTogMC41IH0gKS5vcGFjaXR5ID09PSAwLjUgKTtcclxuICAgIGhhcmRBc3NlcnQoIFNlY3JldE5vZGUuY3JlYXRlU2VjcmV0Tm9kZSgpLnNlY3JldCA9PT0gMCApO1xyXG5cclxuICAgIC8vIFVuc3VwcG9ydGVkIHdpdGhvdXQgYmFiZWwtcG9seWZpbGwsIGNvbW1lbnRlZCBvdXQgZm9yIG5vdy4gRE8gTk9UIFVTRSBpbiBzaW11bGF0aW9ucy4gTWF5IGJlIHVzZWQgaW4gdGhlIGZ1dHVyZS5cclxuICAgIC8vIEl0ZXJhYmxlIGNsYXNzICh3aXRoIGEgZ2VuZXJhdG9yIG1ldGhvZClcclxuICAgIC8vIGNsYXNzIFJlbGF0aXZlUHJpbWVzIHtcclxuICAgIC8vICAgcHJpdmF0ZSBuOiBudW1iZXI7XHJcbiAgICAvLyAgIGNvbnN0cnVjdG9yKCBuICkge1xyXG4gICAgLy8gICAgIHRoaXMubiA9IG47XHJcbiAgICAvLyAgIH1cclxuICAgIC8vICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgLy8gICAgIGZvciAoIGxldCBpID0gMTs7IGkrKyApIHtcclxuICAgIC8vICAgICAgIGlmICggVXRpbHMuZ2NkKCBpLCB0aGlzLm4gKSA9PT0gMSApIHtcclxuICAgIC8vICAgICAgICAgeWllbGQgaTtcclxuICAgIC8vICAgICAgIH1cclxuICAgIC8vICAgICB9XHJcbiAgICAvLyAgIH1cclxuICAgIC8vIH1cclxuICAgIC8vIC8vIEZpbmQgYWxsIHJlbGF0aXZlIHByaW1lcyB0byA1IGxlc3MgdGhhbiAxMi5cclxuICAgIC8vIGNvbnN0IHJlbGF0aXZlUHJpbWVzID0gW107XHJcbiAgICAvLyBmb3IgKCBjb25zdCBuIG9mIG5ldyBSZWxhdGl2ZVByaW1lcyggNSApICkge1xyXG4gICAgLy8gICBpZiAoIG4gPj0gMTIgKSB7IGJyZWFrOyB9XHJcbiAgICAvLyAgIHJlbGF0aXZlUHJpbWVzLnB1c2goIG4gKTtcclxuICAgIC8vIH1cclxuICAgIC8vIGhhcmRBc3NlcnQoIF8uaXNFcXVhbCggcmVsYXRpdmVQcmltZXMsIFsgMSwgMiwgMywgNCwgNiwgNywgOCwgOSwgMTEgXSApICk7XHJcblxyXG4gICAgLy8gU2V0c1xyXG4gICAgY29uc3QgYmFnID0gbmV3IFNldCgpO1xyXG4gICAgYmFnLmFkZCggJ2EnICkuYWRkKCAnYicgKS5hZGQoICdhJyApO1xyXG4gICAgaGFyZEFzc2VydCggYmFnLnNpemUgPT09IDIgKTtcclxuICAgIGhhcmRBc3NlcnQoIGJhZy5oYXMoICdhJyApICk7XHJcbiAgICBoYXJkQXNzZXJ0KCAhYmFnLmhhcyggJ2MnICkgKTtcclxuXHJcbiAgICAvLyBNYXBzXHJcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XHJcbiAgICBtYXAuc2V0KCBiYWcsIDUgKTtcclxuICAgIG1hcC5zZXQoIE5vZGUsIDIgKTtcclxuICAgIGhhcmRBc3NlcnQoIG1hcC5nZXQoIGJhZyApID09PSA1ICk7XHJcbiAgICBoYXJkQXNzZXJ0KCBtYXAuZ2V0KCBOb2RlICkgPT09IDIgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqL1xyXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKCAncmVzZXQnICk7XHJcbiAgfVxyXG59XHJcblxyXG53aWxkZXIucmVnaXN0ZXIoICdXaWxkZXJNb2RlbCcsIFdpbGRlck1vZGVsICk7XHJcbmV4cG9ydCBkZWZhdWx0IFdpbGRlck1vZGVsOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxVQUFVLE1BQU0sd0NBQXdDO0FBQy9ELFNBQVNDLElBQUksUUFBcUIsbUNBQW1DO0FBQ3JFLE9BQU9DLE1BQU0sTUFBTSxpQkFBaUI7QUFDcEMsT0FBT0MscUJBQXFCLE1BQU0sNEJBQTRCO0FBQzlELE9BQU9DLHlCQUF5QixNQUFNLGdDQUFnQztBQUl0RTtBQUNBO0FBRUE7QUFDQSxNQUFNQyxTQUFTLEdBQUcsS0FBSztBQU12QixNQUFNQyxXQUFXLENBQW1CO0VBSTNCQyxXQUFXQSxDQUFFQyxlQUFtQyxFQUFHO0lBRXhELElBQUksQ0FBQ0MscUJBQXFCLEdBQUcsSUFBSU4scUJBQXFCLENBQUMsQ0FBQztJQUN4RCxJQUFJLENBQUNPLHlCQUF5QixHQUFHLElBQUlOLHlCQUF5QixDQUFFO01BQzlETyxNQUFNLEVBQUVILGVBQWUsQ0FBQ0csTUFB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