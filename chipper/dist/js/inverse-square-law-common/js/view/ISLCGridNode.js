// Copyright 2017-2022, University of Colorado Boulder

/**
 * Grid that shows the possible positions of where the objects can be in the play area. For several
 * sims that use inverse-square-law-common, objects are constrained to positions along a 2D grid.
 * This node should only be used for debugging and will be hidden behind query parameter "showGrid".
 *
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import { Shape } from '../../../kite/js/imports.js';
import merge from '../../../phet-core/js/merge.js';
import { Path } from '../../../scenery/js/imports.js';
import inverseSquareLawCommon from '../inverseSquareLawCommon.js';
class ISLCGridNode extends Path {
  /**
   * @param {number} deltaX - position step for the object in model coordinates
   * @param {Bounds2} layoutBounds - layout bounds of the ScreenView
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Object} [options]
   */
  constructor(deltaX, layoutBounds, modelViewTransform, options) {
    options = merge({
      stroke: 'rgba( 0, 0, 0, 0.6 )'
    }, options);
    const gridShape = new Shape();

    // subtract 1 so grid aligns with model, see https://github.com/phetsims/inverse-square-law-common/issues/49
    let gridPosition = modelViewTransform.viewToModelX(layoutBounds.minX - 1);
    const rightBoundary = modelViewTransform.viewToModelX(layoutBounds.maxX);
    while (gridPosition <= rightBoundary) {
      // grid position in view coords
      const viewPosition = modelViewTransform.modelToViewX(gridPosition);

      // draw the grid line
      gridShape.moveTo(viewPosition, layoutBounds.top);
      gridShape.lineTo(viewPosition, layoutBounds.bottom);

      // move to the next position
      gridPosition += deltaX;
    }
    super(gridShape, {
      stroke: options.stroke,
      lineWidth: 1
    });
  }
}
inverseSquareLawCommon.register('ISLCGridNode', ISLCGridNode);
export default ISLCGridNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTaGFwZSIsIm1lcmdlIiwiUGF0aCIsImludmVyc2VTcXVhcmVMYXdDb21tb24iLCJJU0xDR3JpZE5vZGUiLCJjb25zdHJ1Y3RvciIsImRlbHRhWCIsImxheW91dEJvdW5kcyIsIm1vZGVsVmlld1RyYW5zZm9ybSIsIm9wdGlvbnMiLCJzdHJva2UiLCJncmlkU2hhcGUiLCJncmlkUG9zaXRpb24iLCJ2aWV3VG9Nb2RlbFgiLCJtaW5YIiwicmlnaHRCb3VuZGFyeSIsIm1heFgiLCJ2aWV3UG9zaXRpb24iLCJtb2RlbFRvVmlld1giLCJtb3ZlVG8iLCJ0b3AiLCJsaW5lVG8iLCJib3R0b20iLCJsaW5lV2lkdGgiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIklTTENHcmlkTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNy0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBHcmlkIHRoYXQgc2hvd3MgdGhlIHBvc3NpYmxlIHBvc2l0aW9ucyBvZiB3aGVyZSB0aGUgb2JqZWN0cyBjYW4gYmUgaW4gdGhlIHBsYXkgYXJlYS4gRm9yIHNldmVyYWxcclxuICogc2ltcyB0aGF0IHVzZSBpbnZlcnNlLXNxdWFyZS1sYXctY29tbW9uLCBvYmplY3RzIGFyZSBjb25zdHJhaW5lZCB0byBwb3NpdGlvbnMgYWxvbmcgYSAyRCBncmlkLlxyXG4gKiBUaGlzIG5vZGUgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgZGVidWdnaW5nIGFuZCB3aWxsIGJlIGhpZGRlbiBiZWhpbmQgcXVlcnkgcGFyYW1ldGVyIFwic2hvd0dyaWRcIi5cclxuICpcclxuICogQGF1dGhvciBKZXNzZSBHcmVlbmJlcmcgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi8uLi8uLi9raXRlL2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lcmdlLmpzJztcclxuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBpbnZlcnNlU3F1YXJlTGF3Q29tbW9uIGZyb20gJy4uL2ludmVyc2VTcXVhcmVMYXdDb21tb24uanMnO1xyXG5cclxuY2xhc3MgSVNMQ0dyaWROb2RlIGV4dGVuZHMgUGF0aCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggLSBwb3NpdGlvbiBzdGVwIGZvciB0aGUgb2JqZWN0IGluIG1vZGVsIGNvb3JkaW5hdGVzXHJcbiAgICogQHBhcmFtIHtCb3VuZHMyfSBsYXlvdXRCb3VuZHMgLSBsYXlvdXQgYm91bmRzIG9mIHRoZSBTY3JlZW5WaWV3XHJcbiAgICogQHBhcmFtIHtNb2RlbFZpZXdUcmFuc2Zvcm0yfSBtb2RlbFZpZXdUcmFuc2Zvcm1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGRlbHRhWCwgbGF5b3V0Qm91bmRzLCBtb2RlbFZpZXdUcmFuc2Zvcm0sIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgb3B0aW9ucyA9IG1lcmdlKCB7XHJcbiAgICAgIHN0cm9rZTogJ3JnYmEoIDAsIDAsIDAsIDAuNiApJ1xyXG4gICAgfSwgb3B0aW9ucyApO1xyXG5cclxuICAgIGNvbnN0IGdyaWRTaGFwZSA9IG5ldyBTaGFwZSgpO1xyXG5cclxuICAgIC8vIHN1YnRyYWN0IDEgc28gZ3JpZCBhbGlnbnMgd2l0aCBtb2RlbCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9pbnZlcnNlLXNxdWFyZS1sYXctY29tbW9uL2lzc3Vlcy80OVxyXG4gICAgbGV0IGdyaWRQb3NpdGlvbiA9IG1vZGVsVmlld1RyYW5zZm9ybS52aWV3VG9Nb2RlbFgoIGxheW91dEJvdW5kcy5taW5YIC0gMSApO1xyXG4gICAgY29uc3QgcmlnaHRCb3VuZGFyeSA9IG1vZGVsVmlld1RyYW5zZm9ybS52aWV3VG9Nb2RlbFgoIGxheW91dEJvdW5kcy5tYXhYICk7XHJcbiAgICB3aGlsZSAoIGdyaWRQb3NpdGlvbiA8PSByaWdodEJvdW5kYXJ5ICkge1xyXG5cclxuICAgICAgLy8gZ3JpZCBwb3NpdGlvbiBpbiB2aWV3IGNvb3Jkc1xyXG4gICAgICBjb25zdCB2aWV3UG9zaXRpb24gPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdYKCBncmlkUG9zaXRpb24gKTtcclxuXHJcbiAgICAgIC8vIGRyYXcgdGhlIGdyaWQgbGluZVxyXG4gICAgICBncmlkU2hhcGUubW92ZVRvKCB2aWV3UG9zaXRpb24sIGxheW91dEJvdW5kcy50b3AgKTtcclxuICAgICAgZ3JpZFNoYXBlLmxpbmVUbyggdmlld1Bvc2l0aW9uLCBsYXlvdXRCb3VuZHMuYm90dG9tICk7XHJcblxyXG4gICAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHBvc2l0aW9uXHJcbiAgICAgIGdyaWRQb3NpdGlvbiArPSBkZWx0YVg7XHJcbiAgICB9XHJcblxyXG4gICAgc3VwZXIoIGdyaWRTaGFwZSwge1xyXG4gICAgICBzdHJva2U6IG9wdGlvbnMuc3Ryb2tlLFxyXG4gICAgICBsaW5lV2lkdGg6IDFcclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcbmludmVyc2VTcXVhcmVMYXdDb21tb24ucmVnaXN0ZXIoICdJU0xDR3JpZE5vZGUnLCBJU0xDR3JpZE5vZGUgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IElTTENHcmlkTm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVNBLEtBQUssUUFBUSw2QkFBNkI7QUFDbkQsT0FBT0MsS0FBSyxNQUFNLGdDQUFnQztBQUNsRCxTQUFTQyxJQUFJLFFBQVEsZ0NBQWdDO0FBQ3JELE9BQU9DLHNCQUFzQixNQUFNLDhCQUE4QjtBQUVqRSxNQUFNQyxZQUFZLFNBQVNGLElBQUksQ0FBQztFQUU5QjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUcsV0FBV0EsQ0FBRUMsTUFBTSxFQUFFQyxZQUFZLEVBQUVDLGtCQUFrQixFQUFFQyxPQUFPLEVBQUc7SUFFL0RBLE9BQU8sR0FBR1IsS0FBSyxDQUFFO01BQ2ZTLE1BQU0sRUFBRTtJQUNWLENBQUMsRUFBRUQsT0FBUSxDQUFDO0lBRVosTUFBTUUsU0FBUyxHQUFHLElBQUlYLEtBQUssQ0FBQyxDQUFDOztJQUU3QjtJQUNBLElBQUlZLFlBQVksR0FBR0osa0JBQWtCLENBQUNLLFlBQVksQ0FBRU4sWUFBWSxDQUFDTyxJQUFJLEdBQUcsQ0FBRSxDQUFDO0lBQzNFLE1BQU1DLGFBQWEsR0FBR1Asa0JBQWtCLENBQUNLLFlBQVksQ0FBRU4sWUFBWSxDQUFDUyxJQUFLLENBQUM7SUFDMUUsT0FBUUosWUFBWSxJQUFJRyxhQUFhLEVBQUc7TUFFdEM7TUFDQSxNQUFNRSxZQUFZLEdBQUdULGtCQUFrQixDQUFDVSxZQUFZLENBQUVOLFlBQWEsQ0FBQzs7TUFFcEU7TUFDQUQsU0FBUyxDQUFDUSxNQUFNLENBQUVGLFlBQVksRUFBRVYsWUFBWSxDQUFDYSxHQUFJLENBQUM7TUFDbERULFNBQVMsQ0FBQ1UsTUFBTSxDQUFFSixZQUFZLEVBQUVWLFlBQVksQ0FBQ2UsTUFBTyxDQUFDOztNQUVyRDtNQUNBVixZQUFZLElBQUlOLE1BQU07SUFDeEI7SUFFQSxLQUFLLENBQUVLLFNBQVMsRUFBRTtNQUNoQkQsTUFBTSxFQUFFRCxPQUFPLENBQUNDLE1BQU07TUFDdEJhLFNBQVMsRUFBRTtJQUNiLENBQUUsQ0FBQztFQUNMO0FBQ0Y7QUFFQXBCLHNCQUFzQixDQUFDcUIsUUFBUSxDQUFFLGNBQWMsRUFBRXBCLFlBQWEsQ0FBQztBQUUvRCxlQUFlQSxZQUFZIn0=