// Copyright 2020-2023, University of Colorado Boulder

/**
 * Model type that stores the state of the Ratio. This includes its values, the velocity of how it is changing, as well
 * as logic that maintains its "locked" state, when appropriate.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import NumberProperty from '../../../../axon/js/NumberProperty.js';
import Property from '../../../../axon/js/Property.js';
import Range from '../../../../dot/js/Range.js';
import Utils from '../../../../dot/js/Utils.js';
import BooleanIO from '../../../../tandem/js/types/BooleanIO.js';
import ratioAndProportion from '../../ratioAndProportion.js';
import rapConstants from '../rapConstants.js';
import RAPRatioTuple from './RAPRatioTuple.js';
// The threshold for velocity of a moving ratio value to indicate that it is "moving."
const VELOCITY_THRESHOLD = 0.01;

// How often (in frames) to capture the change in ratio values for the ratio's "velocity"
const STEP_FRAME_GRANULARITY = 30;

// How many values must be different within the STEP_FRAME_GRANULARITY number of frames to trigger a velocity calculation.
const VELOCITY_MEMORY = 3;
const DEFAULT_TERM_VALUE_RANGE = rapConstants.TOTAL_RATIO_TERM_VALUE_RANGE;

// Use the same value as the no-success region threshold. This cannot be the same as the no-success threshold though
// because that threshold value, by definition, will unlock the ratio, see https://github.com/phetsims/ratio-and-proportion/issues/257#issuecomment-748285667
const LOCK_RATIO_RANGE_MIN = rapConstants.NO_SUCCESS_VALUE_THRESHOLD + Number.EPSILON;

// This value needs to be an "even and round" number as it pertains to the step size of the sliders that control the ratio.
// See https://github.com/phetsims/ratio-and-proportion/issues/535
assert && assert(LOCK_RATIO_RANGE_MIN === 0.01, 'please be careful when changing this');
class RAPRatio {
  // Keep two references so that this can be public readonly, AND changed internally.

  // Central Property that holds the value of the ratio. Using a tuple that holds
  // both the antecedent and consequent values as a single data structure is vital for changing both hands at once, and
  // in supporting the "locked ratio" state. Otherwise there are complicated reentrant cases where changing the
  // antecedent cascades to the consequent to snap it back into ratio. Thus the creation of RAPRatioTuple.
  // when true, moving one ratio value will maintain the current ratio by updating the other value Property
  // if the ratio is in the "moving in direction" state: whether or not the two hands are moving fast
  // enough together in the same direction. This indicates, among other things a bimodal interaction.
  // To avoid an infinite loop as setting the tupleProperty from inside its lock-ratio-support
  // listener. This is predominately needed because even same antecedent/consequent values get wrapped in a new
  // RAPRatioTuple instance.
  ratioLockListenerEnabled = true;
  constructor(initialAntecedent, initialConsequent, tandem) {
    this._enabledRatioTermsRangeProperty = new Property(DEFAULT_TERM_VALUE_RANGE, {
      tandem: tandem.createTandem('enabledRatioTermsRangeProperty'),
      phetioValueType: Range.RangeIO
    });
    this.enabledRatioTermsRangeProperty = this._enabledRatioTermsRangeProperty;
    this.tupleProperty = new Property(new RAPRatioTuple(initialAntecedent, initialConsequent), {
      valueType: RAPRatioTuple,
      valueComparisonStrategy: 'equalsFunction',
      reentrant: true,
      // phet-io
      tandem: tandem.createTandem('tupleProperty'),
      phetioValueType: RAPRatioTuple.RAPRatioTupleIO
    });
    this.lockedProperty = new BooleanProperty(false, {
      tandem: tandem.createTandem('lockedProperty')
    });
    this.antecedentVelocityTracker = new VelocityTracker(this.lockedProperty);
    this.consequentVelocityTracker = new VelocityTracker(this.lockedProperty);
    this.movingInDirectionProperty = new DerivedProperty([this.antecedentVelocityTracker.currentVelocityProperty, this.consequentVelocityTracker.currentVelocityProperty, this.lockedProperty], (changeInAntecedent, changeInConsequent, ratioLocked) => {
      const bothMoving = changeInAntecedent !== 0 && changeInConsequent !== 0;

      // both hands should be moving in the same direction
      const movingInSameDirection = changeInAntecedent > 0 === changeInConsequent > 0;
      const movingFastEnough = Math.abs(changeInAntecedent) > VELOCITY_THRESHOLD &&
      // antecedent past threshold
      Math.abs(changeInConsequent) > VELOCITY_THRESHOLD; // consequent past threshold

      // Ignore the speed component when the ratio is locked
      return bothMoving && movingInSameDirection && (movingFastEnough || ratioLocked);
    }, {
      tandem: tandem.createTandem('movingInDirectionProperty'),
      phetioValueType: BooleanIO
    });

    // Listener that will handle keeping both ratio tuple values in sync when the ratio is locked.
    this.tupleProperty.link((tuple, oldTuple) => {
      if (this.lockedProperty.value && this.ratioLockListenerEnabled) {
        assert && assert(oldTuple, 'need an old value to compute locked ratio values');
        const antecedentChanged = tuple.antecedent !== oldTuple.antecedent;
        const consequentChanged = tuple.consequent !== oldTuple.consequent;
        const previousRatio = oldTuple.getRatio();
        let newAntecedent = tuple.antecedent;
        let newConsequent = tuple.consequent;
        if (this.enabledRatioTermsRangeProperty.value.contains(oldTuple.antecedent) && this.enabledRatioTermsRangeProperty.value.contains(oldTuple.consequent) && antecedentChanged && consequentChanged && !phet.joist.sim.isSettingPhetioStateProperty.value) {
          assert && assert(rapConstants.toFixed(tuple.getRatio()) === rapConstants.toFixed(oldTuple.getRatio()),
          // eslint-disable-line bad-sim-text
          'if both values change while locked, the ratio should be maintained.');
        }
        if (antecedentChanged) {
          newConsequent = newAntecedent / previousRatio;
        } else if (consequentChanged) {
          newAntecedent = newConsequent * previousRatio;
        }
        const newRatioTuple = this.clampRatioTupleValuesInRange(newAntecedent, newConsequent, previousRatio);

        // guard against reentrancy in this case.
        this.ratioLockListenerEnabled = false;
        this.tupleProperty.value = newRatioTuple;
        this.ratioLockListenerEnabled = true;
      }
    });
    this.lockedProperty.link(ratioLocked => {
      this._enabledRatioTermsRangeProperty.value = new Range(ratioLocked ? LOCK_RATIO_RANGE_MIN : DEFAULT_TERM_VALUE_RANGE.min, DEFAULT_TERM_VALUE_RANGE.max);
    });
    this.enabledRatioTermsRangeProperty.link(enabledRange => {
      const currentTuple = this.tupleProperty.value;
      const newAntecedent = enabledRange.constrainValue(currentTuple.antecedent);
      const newConsequent = enabledRange.constrainValue(currentTuple.consequent);

      // new instance to trigger notifications
      this.tupleProperty.value = new RAPRatioTuple(newAntecedent, newConsequent);
    });
  }

  /**
   * While keeping the same ratio, make sure that both ratio terms are within the provided range. Returns a new
   * RAPRatioTuple, not mutated.
   */
  clampRatioTupleValuesInRange(antecedent, consequent, ratio, range = this.enabledRatioTermsRangeProperty.value) {
    // Handle if the antecedent is out of range
    if (!range.contains(antecedent)) {
      antecedent = Utils.clamp(antecedent, range.min, range.max);
      consequent = antecedent / ratio;
    }

    // Handle if the consequent is out of range
    if (!range.contains(consequent)) {
      consequent = Utils.clamp(consequent, range.min, range.max);
      antecedent = consequent * ratio;
    }
    assert && assert(range.contains(consequent));
    assert && assert(range.contains(antecedent));
    return new RAPRatioTuple(antecedent, consequent);
  }
  setRatioToTarget(targetRatio) {
    const currentRatioTuple = this.tupleProperty.value;
    let antecedent = currentRatioTuple.antecedent;
    let consequent = currentRatioTuple.consequent;

    // Snap the smaller value, because that will yield a smaller snap distance, see https://github.com/phetsims/ratio-and-proportion/issues/257
    if (antecedent < consequent) {
      antecedent = targetRatio * consequent;
    } else {
      consequent = antecedent / targetRatio;
    }

    // Then clamp to be within the currently enabled range.
    const newRatioTuple = this.clampRatioTupleValuesInRange(antecedent, consequent, targetRatio);
    assert && assert(newRatioTuple !== currentRatioTuple, 'Cannot mutate here, as we rely on notifications below when setting the Property.');

    // Make sure that the lock ratio listener won't try to mutate the new RAPRatioTuple
    this.ratioLockListenerEnabled = false;
    this.tupleProperty.value = newRatioTuple;
    this.ratioLockListenerEnabled = true;
  }
  get currentRatio() {
    return this.tupleProperty.value.getRatio();
  }
  step() {
    const currentTuple = this.tupleProperty.value;
    this.antecedentVelocityTracker.step(currentTuple.antecedent);
    this.consequentVelocityTracker.step(currentTuple.consequent);
  }
  reset() {
    // it is easiest if this is reset first
    this.lockedProperty.reset();
    this.tupleProperty.reset();
    this._enabledRatioTermsRangeProperty.reset();
    this.antecedentVelocityTracker.reset();
    this.consequentVelocityTracker.reset();
    this.ratioLockListenerEnabled = true;
  }
}

// Private class to keep details about tracking the velocity of each ratio term encapsulated.
class VelocityTracker {
  // keep track of previous values to calculate the change, only unique values are appended to this

  // The change in ratio values since last capture. The frequency (or granularity) of this value
  // is determined by STEP_FRAME_GRANULARITY.
  // Used for keeping track of how often dVelocity is checked.
  constructor(ratioLockedProperty) {
    this.ratioLockedProperty = ratioLockedProperty;
    this.previousValues = [];
    this.earliestTime = 0;
    this.currentVelocityProperty = new NumberProperty(0);
    this.stepCountTracker = 0;
  }
  reset() {
    this.currentVelocityProperty.reset();
    this.stepCountTracker = 0;
    this.previousValues.length = 0;
  }
  step(currentValue) {
    this.stepCountTracker++;

    // Capture a value at intervals within the timeframe for each velocity calculation.
    this.previousValues.push(currentValue);

    // only recalculate every X steps to help smooth out noise
    if (this.stepCountTracker % STEP_FRAME_GRANULARITY === 0) {
      // Keep only at most this many values in the list.
      while (this.previousValues.length > STEP_FRAME_GRANULARITY) {
        this.previousValues.shift();
      }

      // There must be at least VELOCITY_MEMORY number of unique values (VELOCITY_MEMORY-1 number of changes) in order
      // to have velocity in this model. This doesn't account for the case in which you change from A -> B -> A, but that
      // is acceptable for our particular case since this velocity is very directional. When locked
      if (this.previousValues.length >= VELOCITY_MEMORY && (_.uniq(this.previousValues).length >= VELOCITY_MEMORY || this.ratioLockedProperty.value)) {
        this.currentVelocityProperty.value = this.previousValues[this.previousValues.length - 1] - this.previousValues[0];
      } else {
        // No velocity if the above criteria hasn't been fulfilled
        this.currentVelocityProperty.value = 0;
      }
    }
  }
}
ratioAndProportion.register('RAPRatio', RAPRatio);
export default RAPRatio;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJEZXJpdmVkUHJvcGVydHkiLCJOdW1iZXJQcm9wZXJ0eSIsIlByb3BlcnR5IiwiUmFuZ2UiLCJVdGlscyIsIkJvb2xlYW5JTyIsInJhdGlvQW5kUHJvcG9ydGlvbiIsInJhcENvbnN0YW50cyIsIlJBUFJhdGlvVHVwbGUiLCJWRUxPQ0lUWV9USFJFU0hPTEQiLCJTVEVQX0ZSQU1FX0dSQU5VTEFSSVRZIiwiVkVMT0NJVFlfTUVNT1JZIiwiREVGQVVMVF9URVJNX1ZBTFVFX1JBTkdFIiwiVE9UQUxfUkFUSU9fVEVSTV9WQUxVRV9SQU5HRSIsIkxPQ0tfUkFUSU9fUkFOR0VfTUlOIiwiTk9fU1VDQ0VTU19WQUxVRV9USFJFU0hPTEQiLCJOdW1iZXIiLCJFUFNJTE9OIiwiYXNzZXJ0IiwiUkFQUmF0aW8iLCJyYXRpb0xvY2tMaXN0ZW5lckVuYWJsZWQiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxBbnRlY2VkZW50IiwiaW5pdGlhbENvbnNlcXVlbnQiLCJ0YW5kZW0iLCJfZW5hYmxlZFJhdGlvVGVybXNSYW5nZVByb3BlcnR5IiwiY3JlYXRlVGFuZGVtIiwicGhldGlvVmFsdWVUeXBlIiwiUmFuZ2VJTyIsImVuYWJsZWRSYXRpb1Rlcm1zUmFuZ2VQcm9wZXJ0eSIsInR1cGxlUHJvcGVydHkiLCJ2YWx1ZVR5cGUiLCJ2YWx1ZUNvbXBhcmlzb25TdHJhdGVneSIsInJlZW50cmFudCIsIlJBUFJhdGlvVHVwbGVJTyIsImxvY2tlZFByb3BlcnR5IiwiYW50ZWNlZGVudFZlbG9jaXR5VHJhY2tlciIsIlZlbG9jaXR5VHJhY2tlciIsImNvbnNlcXVlbnRWZWxvY2l0eVRyYWNrZXIiLCJtb3ZpbmdJbkRpcmVjdGlvblByb3BlcnR5IiwiY3VycmVudFZlbG9jaXR5UHJvcGVydHkiLCJjaGFuZ2VJbkFudGVjZWRlbnQiLCJjaGFuZ2VJbkNvbnNlcXVlbnQiLCJyYXRpb0xvY2tlZCIsImJvdGhNb3ZpbmciLCJtb3ZpbmdJblNhbWVEaXJlY3Rpb24iLCJtb3ZpbmdGYXN0RW5vdWdoIiwiTWF0aCIsImFicyIsImxpbmsiLCJ0dXBsZSIsIm9sZFR1cGxlIiwidmFsdWUiLCJhbnRlY2VkZW50Q2hhbmdlZCIsImFudGVjZWRlbnQiLCJjb25zZXF1ZW50Q2hhbmdlZCIsImNvbnNlcXVlbnQiLCJwcmV2aW91c1JhdGlvIiwiZ2V0UmF0aW8iLCJuZXdBbnRlY2VkZW50IiwibmV3Q29uc2VxdWVudCIsImNvbnRhaW5zIiwicGhldCIsImpvaXN0Iiwic2ltIiwiaXNTZXR0aW5nUGhldGlvU3RhdGVQcm9wZXJ0eSIsInRvRml4ZWQiLCJuZXdSYXRpb1R1cGxlIiwiY2xhbXBSYXRpb1R1cGxlVmFsdWVzSW5SYW5nZSIsIm1pbiIsIm1heCIsImVuYWJsZWRSYW5nZSIsImN1cnJlbnRUdXBsZSIsImNvbnN0cmFpblZhbHVlIiwicmF0aW8iLCJyYW5nZSIsImNsYW1wIiwic2V0UmF0aW9Ub1RhcmdldCIsInRhcmdldFJhdGlvIiwiY3VycmVudFJhdGlvVHVwbGUiLCJjdXJyZW50UmF0aW8iLCJzdGVwIiwicmVzZXQiLCJyYXRpb0xvY2tlZFByb3BlcnR5IiwicHJldmlvdXNWYWx1ZXMiLCJlYXJsaWVzdFRpbWUiLCJzdGVwQ291bnRUcmFja2VyIiwibGVuZ3RoIiwiY3VycmVudFZhbHVlIiwicHVzaCIsInNoaWZ0IiwiXyIsInVuaXEiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlJBUFJhdGlvLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIwLTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIE1vZGVsIHR5cGUgdGhhdCBzdG9yZXMgdGhlIHN0YXRlIG9mIHRoZSBSYXRpby4gVGhpcyBpbmNsdWRlcyBpdHMgdmFsdWVzLCB0aGUgdmVsb2NpdHkgb2YgaG93IGl0IGlzIGNoYW5naW5nLCBhcyB3ZWxsXHJcbiAqIGFzIGxvZ2ljIHRoYXQgbWFpbnRhaW5zIGl0cyBcImxvY2tlZFwiIHN0YXRlLCB3aGVuIGFwcHJvcHJpYXRlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIE1pY2hhZWwgS2F1em1hbm4gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IEJvb2xlYW5Qcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0Jvb2xlYW5Qcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBEZXJpdmVkUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9EZXJpdmVkUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgTnVtYmVyUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9OdW1iZXJQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IFJhbmdlIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9SYW5nZS5qcyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVXRpbHMuanMnO1xyXG5pbXBvcnQgQm9vbGVhbklPIGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy90eXBlcy9Cb29sZWFuSU8uanMnO1xyXG5pbXBvcnQgcmF0aW9BbmRQcm9wb3J0aW9uIGZyb20gJy4uLy4uL3JhdGlvQW5kUHJvcG9ydGlvbi5qcyc7XHJcbmltcG9ydCByYXBDb25zdGFudHMgZnJvbSAnLi4vcmFwQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IFJBUFJhdGlvVHVwbGUgZnJvbSAnLi9SQVBSYXRpb1R1cGxlLmpzJztcclxuaW1wb3J0IFRhbmRlbSBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvVGFuZGVtLmpzJztcclxuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5cclxuLy8gVGhlIHRocmVzaG9sZCBmb3IgdmVsb2NpdHkgb2YgYSBtb3ZpbmcgcmF0aW8gdmFsdWUgdG8gaW5kaWNhdGUgdGhhdCBpdCBpcyBcIm1vdmluZy5cIlxyXG5jb25zdCBWRUxPQ0lUWV9USFJFU0hPTEQgPSAwLjAxO1xyXG5cclxuLy8gSG93IG9mdGVuIChpbiBmcmFtZXMpIHRvIGNhcHR1cmUgdGhlIGNoYW5nZSBpbiByYXRpbyB2YWx1ZXMgZm9yIHRoZSByYXRpbydzIFwidmVsb2NpdHlcIlxyXG5jb25zdCBTVEVQX0ZSQU1FX0dSQU5VTEFSSVRZID0gMzA7XHJcblxyXG4vLyBIb3cgbWFueSB2YWx1ZXMgbXVzdCBiZSBkaWZmZXJlbnQgd2l0aGluIHRoZSBTVEVQX0ZSQU1FX0dSQU5VTEFSSVRZIG51bWJlciBvZiBmcmFtZXMgdG8gdHJpZ2dlciBhIHZlbG9jaXR5IGNhbGN1bGF0aW9uLlxyXG5jb25zdCBWRUxPQ0lUWV9NRU1PUlkgPSAzO1xyXG5cclxuY29uc3QgREVGQVVMVF9URVJNX1ZBTFVFX1JBTkdFID0gcmFwQ29uc3RhbnRzLlRPVEFMX1JBVElPX1RFUk1fVkFMVUVfUkFOR0U7XHJcblxyXG4vLyBVc2UgdGhlIHNhbWUgdmFsdWUgYXMgdGhlIG5vLXN1Y2Nlc3MgcmVnaW9uIHRocmVzaG9sZC4gVGhpcyBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgdGhlIG5vLXN1Y2Nlc3MgdGhyZXNob2xkIHRob3VnaFxyXG4vLyBiZWNhdXNlIHRoYXQgdGhyZXNob2xkIHZhbHVlLCBieSBkZWZpbml0aW9uLCB3aWxsIHVubG9jayB0aGUgcmF0aW8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcmF0aW8tYW5kLXByb3BvcnRpb24vaXNzdWVzLzI1NyNpc3N1ZWNvbW1lbnQtNzQ4Mjg1NjY3XHJcbmNvbnN0IExPQ0tfUkFUSU9fUkFOR0VfTUlOID0gcmFwQ29uc3RhbnRzLk5PX1NVQ0NFU1NfVkFMVUVfVEhSRVNIT0xEICsgTnVtYmVyLkVQU0lMT047XHJcblxyXG4vLyBUaGlzIHZhbHVlIG5lZWRzIHRvIGJlIGFuIFwiZXZlbiBhbmQgcm91bmRcIiBudW1iZXIgYXMgaXQgcGVydGFpbnMgdG8gdGhlIHN0ZXAgc2l6ZSBvZiB0aGUgc2xpZGVycyB0aGF0IGNvbnRyb2wgdGhlIHJhdGlvLlxyXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3JhdGlvLWFuZC1wcm9wb3J0aW9uL2lzc3Vlcy81MzVcclxuYXNzZXJ0ICYmIGFzc2VydCggTE9DS19SQVRJT19SQU5HRV9NSU4gPT09IDAuMDEsICdwbGVhc2UgYmUgY2FyZWZ1bCB3aGVuIGNoYW5naW5nIHRoaXMnICk7XHJcblxyXG5jbGFzcyBSQVBSYXRpbyB7XHJcblxyXG4gIC8vIEtlZXAgdHdvIHJlZmVyZW5jZXMgc28gdGhhdCB0aGlzIGNhbiBiZSBwdWJsaWMgcmVhZG9ubHksIEFORCBjaGFuZ2VkIGludGVybmFsbHkuXHJcbiAgcHVibGljIHJlYWRvbmx5IGVuYWJsZWRSYXRpb1Rlcm1zUmFuZ2VQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8UmFuZ2U+O1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2VuYWJsZWRSYXRpb1Rlcm1zUmFuZ2VQcm9wZXJ0eTogUHJvcGVydHk8UmFuZ2U+O1xyXG5cclxuICAvLyBDZW50cmFsIFByb3BlcnR5IHRoYXQgaG9sZHMgdGhlIHZhbHVlIG9mIHRoZSByYXRpby4gVXNpbmcgYSB0dXBsZSB0aGF0IGhvbGRzXHJcbiAgLy8gYm90aCB0aGUgYW50ZWNlZGVudCBhbmQgY29uc2VxdWVudCB2YWx1ZXMgYXMgYSBzaW5nbGUgZGF0YSBzdHJ1Y3R1cmUgaXMgdml0YWwgZm9yIGNoYW5naW5nIGJvdGggaGFuZHMgYXQgb25jZSwgYW5kXHJcbiAgLy8gaW4gc3VwcG9ydGluZyB0aGUgXCJsb2NrZWQgcmF0aW9cIiBzdGF0ZS4gT3RoZXJ3aXNlIHRoZXJlIGFyZSBjb21wbGljYXRlZCByZWVudHJhbnQgY2FzZXMgd2hlcmUgY2hhbmdpbmcgdGhlXHJcbiAgLy8gYW50ZWNlZGVudCBjYXNjYWRlcyB0byB0aGUgY29uc2VxdWVudCB0byBzbmFwIGl0IGJhY2sgaW50byByYXRpby4gVGh1cyB0aGUgY3JlYXRpb24gb2YgUkFQUmF0aW9UdXBsZS5cclxuICBwdWJsaWMgcmVhZG9ubHkgdHVwbGVQcm9wZXJ0eTogUHJvcGVydHk8UkFQUmF0aW9UdXBsZT47XHJcblxyXG4gIC8vIHdoZW4gdHJ1ZSwgbW92aW5nIG9uZSByYXRpbyB2YWx1ZSB3aWxsIG1haW50YWluIHRoZSBjdXJyZW50IHJhdGlvIGJ5IHVwZGF0aW5nIHRoZSBvdGhlciB2YWx1ZSBQcm9wZXJ0eVxyXG4gIHB1YmxpYyByZWFkb25seSBsb2NrZWRQcm9wZXJ0eTogQm9vbGVhblByb3BlcnR5O1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgYW50ZWNlZGVudFZlbG9jaXR5VHJhY2tlcjogVmVsb2NpdHlUcmFja2VyO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgY29uc2VxdWVudFZlbG9jaXR5VHJhY2tlcjogVmVsb2NpdHlUcmFja2VyO1xyXG5cclxuICAvLyBpZiB0aGUgcmF0aW8gaXMgaW4gdGhlIFwibW92aW5nIGluIGRpcmVjdGlvblwiIHN0YXRlOiB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIGhhbmRzIGFyZSBtb3ZpbmcgZmFzdFxyXG4gIC8vIGVub3VnaCB0b2dldGhlciBpbiB0aGUgc2FtZSBkaXJlY3Rpb24uIFRoaXMgaW5kaWNhdGVzLCBhbW9uZyBvdGhlciB0aGluZ3MgYSBiaW1vZGFsIGludGVyYWN0aW9uLlxyXG4gIHB1YmxpYyByZWFkb25seSBtb3ZpbmdJbkRpcmVjdGlvblByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxib29sZWFuPjtcclxuXHJcbiAgLy8gVG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCBhcyBzZXR0aW5nIHRoZSB0dXBsZVByb3BlcnR5IGZyb20gaW5zaWRlIGl0cyBsb2NrLXJhdGlvLXN1cHBvcnRcclxuICAvLyBsaXN0ZW5lci4gVGhpcyBpcyBwcmVkb21pbmF0ZWx5IG5lZWRlZCBiZWNhdXNlIGV2ZW4gc2FtZSBhbnRlY2VkZW50L2NvbnNlcXVlbnQgdmFsdWVzIGdldCB3cmFwcGVkIGluIGEgbmV3XHJcbiAgLy8gUkFQUmF0aW9UdXBsZSBpbnN0YW5jZS5cclxuICBwcml2YXRlIHJhdGlvTG9ja0xpc3RlbmVyRW5hYmxlZCA9IHRydWU7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggaW5pdGlhbEFudGVjZWRlbnQ6IG51bWJlciwgaW5pdGlhbENvbnNlcXVlbnQ6IG51bWJlciwgdGFuZGVtOiBUYW5kZW0gKSB7XHJcblxyXG4gICAgdGhpcy5fZW5hYmxlZFJhdGlvVGVybXNSYW5nZVByb3BlcnR5ID0gbmV3IFByb3BlcnR5KCBERUZBVUxUX1RFUk1fVkFMVUVfUkFOR0UsIHtcclxuICAgICAgdGFuZGVtOiB0YW5kZW0uY3JlYXRlVGFuZGVtKCAnZW5hYmxlZFJhdGlvVGVybXNSYW5nZVByb3BlcnR5JyApLFxyXG4gICAgICBwaGV0aW9WYWx1ZVR5cGU6IFJhbmdlLlJhbmdlSU9cclxuICAgIH0gKTtcclxuICAgIHRoaXMuZW5hYmxlZFJhdGlvVGVybXNSYW5nZVByb3BlcnR5ID0gdGhpcy5fZW5hYmxlZFJhdGlvVGVybXNSYW5nZVByb3BlcnR5O1xyXG5cclxuICAgIHRoaXMudHVwbGVQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eSggbmV3IFJBUFJhdGlvVHVwbGUoIGluaXRpYWxBbnRlY2VkZW50LCBpbml0aWFsQ29uc2VxdWVudCApLCB7XHJcbiAgICAgIHZhbHVlVHlwZTogUkFQUmF0aW9UdXBsZSxcclxuICAgICAgdmFsdWVDb21wYXJpc29uU3RyYXRlZ3k6ICdlcXVhbHNGdW5jdGlvbicsXHJcbiAgICAgIHJlZW50cmFudDogdHJ1ZSxcclxuXHJcbiAgICAgIC8vIHBoZXQtaW9cclxuICAgICAgdGFuZGVtOiB0YW5kZW0uY3JlYXRlVGFuZGVtKCAndHVwbGVQcm9wZXJ0eScgKSxcclxuICAgICAgcGhldGlvVmFsdWVUeXBlOiBSQVBSYXRpb1R1cGxlLlJBUFJhdGlvVHVwbGVJT1xyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMubG9ja2VkUHJvcGVydHkgPSBuZXcgQm9vbGVhblByb3BlcnR5KCBmYWxzZSwgeyB0YW5kZW06IHRhbmRlbS5jcmVhdGVUYW5kZW0oICdsb2NrZWRQcm9wZXJ0eScgKSB9ICk7XHJcblxyXG4gICAgdGhpcy5hbnRlY2VkZW50VmVsb2NpdHlUcmFja2VyID0gbmV3IFZlbG9jaXR5VHJhY2tlciggdGhpcy5sb2NrZWRQcm9wZXJ0eSApO1xyXG4gICAgdGhpcy5jb25zZXF1ZW50VmVsb2NpdHlUcmFja2VyID0gbmV3IFZlbG9jaXR5VHJhY2tlciggdGhpcy5sb2NrZWRQcm9wZXJ0eSApO1xyXG5cclxuICAgIHRoaXMubW92aW5nSW5EaXJlY3Rpb25Qcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoIFtcclxuICAgICAgdGhpcy5hbnRlY2VkZW50VmVsb2NpdHlUcmFja2VyLmN1cnJlbnRWZWxvY2l0eVByb3BlcnR5LFxyXG4gICAgICB0aGlzLmNvbnNlcXVlbnRWZWxvY2l0eVRyYWNrZXIuY3VycmVudFZlbG9jaXR5UHJvcGVydHksXHJcbiAgICAgIHRoaXMubG9ja2VkUHJvcGVydHlcclxuICAgIF0sICggY2hhbmdlSW5BbnRlY2VkZW50LCBjaGFuZ2VJbkNvbnNlcXVlbnQsIHJhdGlvTG9ja2VkICkgPT4ge1xyXG4gICAgICBjb25zdCBib3RoTW92aW5nID0gY2hhbmdlSW5BbnRlY2VkZW50ICE9PSAwICYmIGNoYW5nZUluQ29uc2VxdWVudCAhPT0gMDtcclxuXHJcbiAgICAgIC8vIGJvdGggaGFuZHMgc2hvdWxkIGJlIG1vdmluZyBpbiB0aGUgc2FtZSBkaXJlY3Rpb25cclxuICAgICAgY29uc3QgbW92aW5nSW5TYW1lRGlyZWN0aW9uID0gY2hhbmdlSW5BbnRlY2VkZW50ID4gMCA9PT0gY2hhbmdlSW5Db25zZXF1ZW50ID4gMDtcclxuXHJcbiAgICAgIGNvbnN0IG1vdmluZ0Zhc3RFbm91Z2ggPSBNYXRoLmFicyggY2hhbmdlSW5BbnRlY2VkZW50ICkgPiBWRUxPQ0lUWV9USFJFU0hPTEQgJiYgLy8gYW50ZWNlZGVudCBwYXN0IHRocmVzaG9sZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoIGNoYW5nZUluQ29uc2VxdWVudCApID4gVkVMT0NJVFlfVEhSRVNIT0xEOyAvLyBjb25zZXF1ZW50IHBhc3QgdGhyZXNob2xkXHJcblxyXG4gICAgICAvLyBJZ25vcmUgdGhlIHNwZWVkIGNvbXBvbmVudCB3aGVuIHRoZSByYXRpbyBpcyBsb2NrZWRcclxuICAgICAgcmV0dXJuIGJvdGhNb3ZpbmcgJiYgbW92aW5nSW5TYW1lRGlyZWN0aW9uICYmICggbW92aW5nRmFzdEVub3VnaCB8fCByYXRpb0xvY2tlZCApO1xyXG4gICAgfSwge1xyXG4gICAgICB0YW5kZW06IHRhbmRlbS5jcmVhdGVUYW5kZW0oICdtb3ZpbmdJbkRpcmVjdGlvblByb3BlcnR5JyApLFxyXG4gICAgICBwaGV0aW9WYWx1ZVR5cGU6IEJvb2xlYW5JT1xyXG4gICAgfSApO1xyXG5cclxuXHJcbiAgICAvLyBMaXN0ZW5lciB0aGF0IHdpbGwgaGFuZGxlIGtlZXBpbmcgYm90aCByYXRpbyB0dXBsZSB2YWx1ZXMgaW4gc3luYyB3aGVuIHRoZSByYXRpbyBpcyBsb2NrZWQuXHJcbiAgICB0aGlzLnR1cGxlUHJvcGVydHkubGluayggKCB0dXBsZSwgb2xkVHVwbGUgKSA9PiB7XHJcbiAgICAgIGlmICggdGhpcy5sb2NrZWRQcm9wZXJ0eS52YWx1ZSAmJiB0aGlzLnJhdGlvTG9ja0xpc3RlbmVyRW5hYmxlZCApIHtcclxuICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBvbGRUdXBsZSwgJ25lZWQgYW4gb2xkIHZhbHVlIHRvIGNvbXB1dGUgbG9ja2VkIHJhdGlvIHZhbHVlcycgKTtcclxuXHJcbiAgICAgICAgY29uc3QgYW50ZWNlZGVudENoYW5nZWQgPSB0dXBsZS5hbnRlY2VkZW50ICE9PSBvbGRUdXBsZSEuYW50ZWNlZGVudDtcclxuICAgICAgICBjb25zdCBjb25zZXF1ZW50Q2hhbmdlZCA9IHR1cGxlLmNvbnNlcXVlbnQgIT09IG9sZFR1cGxlIS5jb25zZXF1ZW50O1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzUmF0aW8gPSBvbGRUdXBsZSEuZ2V0UmF0aW8oKTtcclxuXHJcbiAgICAgICAgbGV0IG5ld0FudGVjZWRlbnQgPSB0dXBsZS5hbnRlY2VkZW50O1xyXG4gICAgICAgIGxldCBuZXdDb25zZXF1ZW50ID0gdHVwbGUuY29uc2VxdWVudDtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmVuYWJsZWRSYXRpb1Rlcm1zUmFuZ2VQcm9wZXJ0eS52YWx1ZS5jb250YWlucyggb2xkVHVwbGUhLmFudGVjZWRlbnQgKSAmJlxyXG4gICAgICAgICAgICAgdGhpcy5lbmFibGVkUmF0aW9UZXJtc1JhbmdlUHJvcGVydHkudmFsdWUuY29udGFpbnMoIG9sZFR1cGxlIS5jb25zZXF1ZW50ICkgJiZcclxuICAgICAgICAgICAgIGFudGVjZWRlbnRDaGFuZ2VkICYmIGNvbnNlcXVlbnRDaGFuZ2VkICYmICFwaGV0LmpvaXN0LnNpbS5pc1NldHRpbmdQaGV0aW9TdGF0ZVByb3BlcnR5LnZhbHVlICkge1xyXG4gICAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggcmFwQ29uc3RhbnRzLnRvRml4ZWQoIHR1cGxlLmdldFJhdGlvKCkgKSA9PT0gcmFwQ29uc3RhbnRzLnRvRml4ZWQoIG9sZFR1cGxlIS5nZXRSYXRpbygpICksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFkLXNpbS10ZXh0XHJcbiAgICAgICAgICAgICdpZiBib3RoIHZhbHVlcyBjaGFuZ2Ugd2hpbGUgbG9ja2VkLCB0aGUgcmF0aW8gc2hvdWxkIGJlIG1haW50YWluZWQuJyApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBhbnRlY2VkZW50Q2hhbmdlZCApIHtcclxuICAgICAgICAgIG5ld0NvbnNlcXVlbnQgPSBuZXdBbnRlY2VkZW50IC8gcHJldmlvdXNSYXRpbztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIGNvbnNlcXVlbnRDaGFuZ2VkICkge1xyXG4gICAgICAgICAgbmV3QW50ZWNlZGVudCA9IG5ld0NvbnNlcXVlbnQgKiBwcmV2aW91c1JhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbmV3UmF0aW9UdXBsZSA9IHRoaXMuY2xhbXBSYXRpb1R1cGxlVmFsdWVzSW5SYW5nZSggbmV3QW50ZWNlZGVudCwgbmV3Q29uc2VxdWVudCwgcHJldmlvdXNSYXRpbyApO1xyXG5cclxuICAgICAgICAvLyBndWFyZCBhZ2FpbnN0IHJlZW50cmFuY3kgaW4gdGhpcyBjYXNlLlxyXG4gICAgICAgIHRoaXMucmF0aW9Mb2NrTGlzdGVuZXJFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50dXBsZVByb3BlcnR5LnZhbHVlID0gbmV3UmF0aW9UdXBsZTtcclxuICAgICAgICB0aGlzLnJhdGlvTG9ja0xpc3RlbmVyRW5hYmxlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICB0aGlzLmxvY2tlZFByb3BlcnR5LmxpbmsoIHJhdGlvTG9ja2VkID0+IHtcclxuICAgICAgdGhpcy5fZW5hYmxlZFJhdGlvVGVybXNSYW5nZVByb3BlcnR5LnZhbHVlID0gbmV3IFJhbmdlKCByYXRpb0xvY2tlZCA/IExPQ0tfUkFUSU9fUkFOR0VfTUlOIDogREVGQVVMVF9URVJNX1ZBTFVFX1JBTkdFLm1pbiwgREVGQVVMVF9URVJNX1ZBTFVFX1JBTkdFLm1heCApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMuZW5hYmxlZFJhdGlvVGVybXNSYW5nZVByb3BlcnR5LmxpbmsoIGVuYWJsZWRSYW5nZSA9PiB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRUdXBsZSA9IHRoaXMudHVwbGVQcm9wZXJ0eS52YWx1ZTtcclxuICAgICAgY29uc3QgbmV3QW50ZWNlZGVudCA9IGVuYWJsZWRSYW5nZS5jb25zdHJhaW5WYWx1ZSggY3VycmVudFR1cGxlLmFudGVjZWRlbnQgKTtcclxuICAgICAgY29uc3QgbmV3Q29uc2VxdWVudCA9IGVuYWJsZWRSYW5nZS5jb25zdHJhaW5WYWx1ZSggY3VycmVudFR1cGxlLmNvbnNlcXVlbnQgKTtcclxuXHJcbiAgICAgIC8vIG5ldyBpbnN0YW5jZSB0byB0cmlnZ2VyIG5vdGlmaWNhdGlvbnNcclxuICAgICAgdGhpcy50dXBsZVByb3BlcnR5LnZhbHVlID0gbmV3IFJBUFJhdGlvVHVwbGUoIG5ld0FudGVjZWRlbnQsIG5ld0NvbnNlcXVlbnQgKTtcclxuICAgIH0gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoaWxlIGtlZXBpbmcgdGhlIHNhbWUgcmF0aW8sIG1ha2Ugc3VyZSB0aGF0IGJvdGggcmF0aW8gdGVybXMgYXJlIHdpdGhpbiB0aGUgcHJvdmlkZWQgcmFuZ2UuIFJldHVybnMgYSBuZXdcclxuICAgKiBSQVBSYXRpb1R1cGxlLCBub3QgbXV0YXRlZC5cclxuICAgKi9cclxuICBwcml2YXRlIGNsYW1wUmF0aW9UdXBsZVZhbHVlc0luUmFuZ2UoIGFudGVjZWRlbnQ6IG51bWJlciwgY29uc2VxdWVudDogbnVtYmVyLCByYXRpbzogbnVtYmVyLCByYW5nZTogUmFuZ2UgPSB0aGlzLmVuYWJsZWRSYXRpb1Rlcm1zUmFuZ2VQcm9wZXJ0eS52YWx1ZSApOiBSQVBSYXRpb1R1cGxlIHtcclxuXHJcbiAgICAvLyBIYW5kbGUgaWYgdGhlIGFudGVjZWRlbnQgaXMgb3V0IG9mIHJhbmdlXHJcbiAgICBpZiAoICFyYW5nZS5jb250YWlucyggYW50ZWNlZGVudCApICkge1xyXG4gICAgICBhbnRlY2VkZW50ID0gVXRpbHMuY2xhbXAoIGFudGVjZWRlbnQsIHJhbmdlLm1pbiwgcmFuZ2UubWF4ICk7XHJcbiAgICAgIGNvbnNlcXVlbnQgPSBhbnRlY2VkZW50IC8gcmF0aW87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIGlmIHRoZSBjb25zZXF1ZW50IGlzIG91dCBvZiByYW5nZVxyXG4gICAgaWYgKCAhcmFuZ2UuY29udGFpbnMoIGNvbnNlcXVlbnQgKSApIHtcclxuICAgICAgY29uc2VxdWVudCA9IFV0aWxzLmNsYW1wKCBjb25zZXF1ZW50LCByYW5nZS5taW4sIHJhbmdlLm1heCApO1xyXG4gICAgICBhbnRlY2VkZW50ID0gY29uc2VxdWVudCAqIHJhdGlvO1xyXG4gICAgfVxyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHJhbmdlLmNvbnRhaW5zKCBjb25zZXF1ZW50ICkgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHJhbmdlLmNvbnRhaW5zKCBhbnRlY2VkZW50ICkgKTtcclxuICAgIHJldHVybiBuZXcgUkFQUmF0aW9UdXBsZSggYW50ZWNlZGVudCwgY29uc2VxdWVudCApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldFJhdGlvVG9UYXJnZXQoIHRhcmdldFJhdGlvOiBudW1iZXIgKTogdm9pZCB7XHJcbiAgICBjb25zdCBjdXJyZW50UmF0aW9UdXBsZSA9IHRoaXMudHVwbGVQcm9wZXJ0eS52YWx1ZTtcclxuXHJcbiAgICBsZXQgYW50ZWNlZGVudCA9IGN1cnJlbnRSYXRpb1R1cGxlLmFudGVjZWRlbnQ7XHJcbiAgICBsZXQgY29uc2VxdWVudCA9IGN1cnJlbnRSYXRpb1R1cGxlLmNvbnNlcXVlbnQ7XHJcblxyXG4gICAgLy8gU25hcCB0aGUgc21hbGxlciB2YWx1ZSwgYmVjYXVzZSB0aGF0IHdpbGwgeWllbGQgYSBzbWFsbGVyIHNuYXAgZGlzdGFuY2UsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcmF0aW8tYW5kLXByb3BvcnRpb24vaXNzdWVzLzI1N1xyXG4gICAgaWYgKCBhbnRlY2VkZW50IDwgY29uc2VxdWVudCApIHtcclxuICAgICAgYW50ZWNlZGVudCA9IHRhcmdldFJhdGlvICogY29uc2VxdWVudDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBjb25zZXF1ZW50ID0gYW50ZWNlZGVudCAvIHRhcmdldFJhdGlvO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZW4gY2xhbXAgdG8gYmUgd2l0aGluIHRoZSBjdXJyZW50bHkgZW5hYmxlZCByYW5nZS5cclxuICAgIGNvbnN0IG5ld1JhdGlvVHVwbGUgPSB0aGlzLmNsYW1wUmF0aW9UdXBsZVZhbHVlc0luUmFuZ2UoIGFudGVjZWRlbnQsIGNvbnNlcXVlbnQsIHRhcmdldFJhdGlvICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBuZXdSYXRpb1R1cGxlICE9PSBjdXJyZW50UmF0aW9UdXBsZSxcclxuICAgICAgJ0Nhbm5vdCBtdXRhdGUgaGVyZSwgYXMgd2UgcmVseSBvbiBub3RpZmljYXRpb25zIGJlbG93IHdoZW4gc2V0dGluZyB0aGUgUHJvcGVydHkuJyApO1xyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBsb2NrIHJhdGlvIGxpc3RlbmVyIHdvbid0IHRyeSB0byBtdXRhdGUgdGhlIG5ldyBSQVBSYXRpb1R1cGxlXHJcbiAgICB0aGlzLnJhdGlvTG9ja0xpc3RlbmVyRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy50dXBsZVByb3BlcnR5LnZhbHVlID0gbmV3UmF0aW9UdXBsZTtcclxuICAgIHRoaXMucmF0aW9Mb2NrTGlzdGVuZXJFbmFibGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgY3VycmVudFJhdGlvKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy50dXBsZVByb3BlcnR5LnZhbHVlLmdldFJhdGlvKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RlcCgpOiB2b2lkIHtcclxuICAgIGNvbnN0IGN1cnJlbnRUdXBsZSA9IHRoaXMudHVwbGVQcm9wZXJ0eS52YWx1ZTtcclxuICAgIHRoaXMuYW50ZWNlZGVudFZlbG9jaXR5VHJhY2tlci5zdGVwKCBjdXJyZW50VHVwbGUuYW50ZWNlZGVudCApO1xyXG4gICAgdGhpcy5jb25zZXF1ZW50VmVsb2NpdHlUcmFja2VyLnN0ZXAoIGN1cnJlbnRUdXBsZS5jb25zZXF1ZW50ICk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcblxyXG4gICAgLy8gaXQgaXMgZWFzaWVzdCBpZiB0aGlzIGlzIHJlc2V0IGZpcnN0XHJcbiAgICB0aGlzLmxvY2tlZFByb3BlcnR5LnJlc2V0KCk7XHJcblxyXG4gICAgdGhpcy50dXBsZVByb3BlcnR5LnJlc2V0KCk7XHJcblxyXG4gICAgdGhpcy5fZW5hYmxlZFJhdGlvVGVybXNSYW5nZVByb3BlcnR5LnJlc2V0KCk7XHJcbiAgICB0aGlzLmFudGVjZWRlbnRWZWxvY2l0eVRyYWNrZXIucmVzZXQoKTtcclxuICAgIHRoaXMuY29uc2VxdWVudFZlbG9jaXR5VHJhY2tlci5yZXNldCgpO1xyXG4gICAgdGhpcy5yYXRpb0xvY2tMaXN0ZW5lckVuYWJsZWQgPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuLy8gUHJpdmF0ZSBjbGFzcyB0byBrZWVwIGRldGFpbHMgYWJvdXQgdHJhY2tpbmcgdGhlIHZlbG9jaXR5IG9mIGVhY2ggcmF0aW8gdGVybSBlbmNhcHN1bGF0ZWQuXHJcbmNsYXNzIFZlbG9jaXR5VHJhY2tlciB7XHJcblxyXG4gIHByaXZhdGUgcmF0aW9Mb2NrZWRQcm9wZXJ0eTogUHJvcGVydHk8Ym9vbGVhbj47XHJcblxyXG4gIC8vIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIHRvIGNhbGN1bGF0ZSB0aGUgY2hhbmdlLCBvbmx5IHVuaXF1ZSB2YWx1ZXMgYXJlIGFwcGVuZGVkIHRvIHRoaXNcclxuICBwcml2YXRlIHByZXZpb3VzVmFsdWVzOiBudW1iZXJbXTtcclxuICBwcml2YXRlIGVhcmxpZXN0VGltZTogbnVtYmVyO1xyXG5cclxuICAvLyBUaGUgY2hhbmdlIGluIHJhdGlvIHZhbHVlcyBzaW5jZSBsYXN0IGNhcHR1cmUuIFRoZSBmcmVxdWVuY3kgKG9yIGdyYW51bGFyaXR5KSBvZiB0aGlzIHZhbHVlXHJcbiAgLy8gaXMgZGV0ZXJtaW5lZCBieSBTVEVQX0ZSQU1FX0dSQU5VTEFSSVRZLlxyXG4gIHB1YmxpYyBjdXJyZW50VmVsb2NpdHlQcm9wZXJ0eTogTnVtYmVyUHJvcGVydHk7XHJcblxyXG4gIC8vIFVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgaG93IG9mdGVuIGRWZWxvY2l0eSBpcyBjaGVja2VkLlxyXG4gIHByaXZhdGUgc3RlcENvdW50VHJhY2tlcjogbnVtYmVyO1xyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIHJhdGlvTG9ja2VkUHJvcGVydHk6IFByb3BlcnR5PGJvb2xlYW4+ICkge1xyXG5cclxuICAgIHRoaXMucmF0aW9Mb2NrZWRQcm9wZXJ0eSA9IHJhdGlvTG9ja2VkUHJvcGVydHk7XHJcbiAgICB0aGlzLnByZXZpb3VzVmFsdWVzID0gW107XHJcbiAgICB0aGlzLmVhcmxpZXN0VGltZSA9IDA7XHJcbiAgICB0aGlzLmN1cnJlbnRWZWxvY2l0eVByb3BlcnR5ID0gbmV3IE51bWJlclByb3BlcnR5KCAwICk7XHJcbiAgICB0aGlzLnN0ZXBDb3VudFRyYWNrZXIgPSAwO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5jdXJyZW50VmVsb2NpdHlQcm9wZXJ0eS5yZXNldCgpO1xyXG4gICAgdGhpcy5zdGVwQ291bnRUcmFja2VyID0gMDtcclxuICAgIHRoaXMucHJldmlvdXNWYWx1ZXMubGVuZ3RoID0gMDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzdGVwKCBjdXJyZW50VmFsdWU6IG51bWJlciApOiB2b2lkIHtcclxuICAgIHRoaXMuc3RlcENvdW50VHJhY2tlcisrO1xyXG5cclxuICAgIC8vIENhcHR1cmUgYSB2YWx1ZSBhdCBpbnRlcnZhbHMgd2l0aGluIHRoZSB0aW1lZnJhbWUgZm9yIGVhY2ggdmVsb2NpdHkgY2FsY3VsYXRpb24uXHJcbiAgICB0aGlzLnByZXZpb3VzVmFsdWVzLnB1c2goIGN1cnJlbnRWYWx1ZSApO1xyXG5cclxuICAgIC8vIG9ubHkgcmVjYWxjdWxhdGUgZXZlcnkgWCBzdGVwcyB0byBoZWxwIHNtb290aCBvdXQgbm9pc2VcclxuICAgIGlmICggdGhpcy5zdGVwQ291bnRUcmFja2VyICUgU1RFUF9GUkFNRV9HUkFOVUxBUklUWSA9PT0gMCApIHtcclxuXHJcbiAgICAgIC8vIEtlZXAgb25seSBhdCBtb3N0IHRoaXMgbWFueSB2YWx1ZXMgaW4gdGhlIGxpc3QuXHJcbiAgICAgIHdoaWxlICggdGhpcy5wcmV2aW91c1ZhbHVlcy5sZW5ndGggPiBTVEVQX0ZSQU1FX0dSQU5VTEFSSVRZICkge1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZXMuc2hpZnQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBWRUxPQ0lUWV9NRU1PUlkgbnVtYmVyIG9mIHVuaXF1ZSB2YWx1ZXMgKFZFTE9DSVRZX01FTU9SWS0xIG51bWJlciBvZiBjaGFuZ2VzKSBpbiBvcmRlclxyXG4gICAgICAvLyB0byBoYXZlIHZlbG9jaXR5IGluIHRoaXMgbW9kZWwuIFRoaXMgZG9lc24ndCBhY2NvdW50IGZvciB0aGUgY2FzZSBpbiB3aGljaCB5b3UgY2hhbmdlIGZyb20gQSAtPiBCIC0+IEEsIGJ1dCB0aGF0XHJcbiAgICAgIC8vIGlzIGFjY2VwdGFibGUgZm9yIG91ciBwYXJ0aWN1bGFyIGNhc2Ugc2luY2UgdGhpcyB2ZWxvY2l0eSBpcyB2ZXJ5IGRpcmVjdGlvbmFsLiBXaGVuIGxvY2tlZFxyXG4gICAgICBpZiAoIHRoaXMucHJldmlvdXNWYWx1ZXMubGVuZ3RoID49IFZFTE9DSVRZX01FTU9SWSAmJlxyXG4gICAgICAgICAgICggXy51bmlxKCB0aGlzLnByZXZpb3VzVmFsdWVzICkubGVuZ3RoID49IFZFTE9DSVRZX01FTU9SWSB8fCB0aGlzLnJhdGlvTG9ja2VkUHJvcGVydHkudmFsdWUgKSApIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRWZWxvY2l0eVByb3BlcnR5LnZhbHVlID0gdGhpcy5wcmV2aW91c1ZhbHVlc1sgdGhpcy5wcmV2aW91c1ZhbHVlcy5sZW5ndGggLSAxIF0gLSB0aGlzLnByZXZpb3VzVmFsdWVzWyAwIF07XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIE5vIHZlbG9jaXR5IGlmIHRoZSBhYm92ZSBjcml0ZXJpYSBoYXNuJ3QgYmVlbiBmdWxmaWxsZWRcclxuICAgICAgICB0aGlzLmN1cnJlbnRWZWxvY2l0eVByb3BlcnR5LnZhbHVlID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxucmF0aW9BbmRQcm9wb3J0aW9uLnJlZ2lzdGVyKCAnUkFQUmF0aW8nLCBSQVBSYXRpbyApO1xyXG5leHBvcnQgZGVmYXVsdCBSQVBSYXRpbztcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsZUFBZSxNQUFNLHdDQUF3QztBQUNwRSxPQUFPQyxlQUFlLE1BQU0sd0NBQXdDO0FBQ3BFLE9BQU9DLGNBQWMsTUFBTSx1Q0FBdUM7QUFDbEUsT0FBT0MsUUFBUSxNQUFNLGlDQUFpQztBQUN0RCxPQUFPQyxLQUFLLE1BQU0sNkJBQTZCO0FBQy9DLE9BQU9DLEtBQUssTUFBTSw2QkFBNkI7QUFDL0MsT0FBT0MsU0FBUyxNQUFNLDBDQUEwQztBQUNoRSxPQUFPQyxrQkFBa0IsTUFBTSw2QkFBNkI7QUFDNUQsT0FBT0MsWUFBWSxNQUFNLG9CQUFvQjtBQUM3QyxPQUFPQyxhQUFhLE1BQU0sb0JBQW9CO0FBSTlDO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUcsSUFBSTs7QUFFL0I7QUFDQSxNQUFNQyxzQkFBc0IsR0FBRyxFQUFFOztBQUVqQztBQUNBLE1BQU1DLGVBQWUsR0FBRyxDQUFDO0FBRXpCLE1BQU1DLHdCQUF3QixHQUFHTCxZQUFZLENBQUNNLDRCQUE0Qjs7QUFFMUU7QUFDQTtBQUNBLE1BQU1DLG9CQUFvQixHQUFHUCxZQUFZLENBQUNRLDBCQUEwQixHQUFHQyxNQUFNLENBQUNDLE9BQU87O0FBRXJGO0FBQ0E7QUFDQUMsTUFBTSxJQUFJQSxNQUFNLENBQUVKLG9CQUFvQixLQUFLLElBQUksRUFBRSxzQ0FBdUMsQ0FBQztBQUV6RixNQUFNSyxRQUFRLENBQUM7RUFFYjs7RUFJ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