// Copyright 2020-2023, University of Colorado Boulder

/**
 * This is the main model for the ratio in this sim. It has a RAPRatio, with its antecedent and consequent tuple, and
 * add to it a target ratio value, as well as a fitness of how close the current ratio (stored in the RAPRatio instance)
 * is to the target. In general use RAPRatio.ratioFitnessProperty (ranged from 0-1) to determine if you are far or close
 * to the target, respectively. See implementation-notes.md for more information.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */

import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import NumberProperty from '../../../../axon/js/NumberProperty.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import BooleanIO from '../../../../tandem/js/types/BooleanIO.js';
import NumberIO from '../../../../tandem/js/types/NumberIO.js';
import ratioAndProportion from '../../ratioAndProportion.js';
import rapConstants from '../rapConstants.js';
import RAPRatio from './RAPRatio.js';
import RatioTerm from './RatioTerm.js';
import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
// constant to help achieve feedback in 40% of the visual screen height (2 default tick marks). Calculated by taking the
// fitness distance when the right hand is 2 tick marks from the target ratio. This number is based on a target ratio of
// .5, so it is normalized here. When used, it should be multiplied by the current target ratio.
const MIN_CLAMPED_FITNESS_DISTANCE = 0.08944271909999162 / 0.5;

// The value in which, if a ratio term's difference between its ideal (to achieve the exact target ratio) is less than
// this value, then the model will automatically force the in-proportion state. This is to support general mouse/touch
// usability with small ratios, see https://github.com/phetsims/ratio-and-proportion/issues/369
const MINIMUM_DISTANCE_FORCES_IN_PROPORTION = 0.001;
const TOTAL_RANGE = rapConstants.TOTAL_RATIO_TERM_VALUE_RANGE;
class RAPModel {
  // the current state of the ratio (value of terms, if its locked, etc)

  // The desired ratio of the antecedent as compared to the consequent. As in 1:2. Initialized to default ratio
  // so that we always start in-proportion.
  // How "correct" the proportion currently is. Max is RATIO_FITNESS_RANGE.max, but the min depends on the range of the
  // ratio terms (see RAPRatio), and the current targetRatio value. Thus using this Property should likely be used with
  // `RAPModel.getMinFitness()`. In most cases, this should not be used, since it isn't normalized. See
  // `this.ratioFitnessProperty` for the preferred method of monitoring ratio fitness. This Property can be useful
  // if you need to map feedback based on the entire range of fitness, and not just when the current ratio gets
  // "close enough" to the target (since negative values in this Property are all clamped to 0 in this.ratioFitnessProperty).
  // How "correct" the proportion currently is. clamped within RATIO_FITNESS_RANGE. If at max (1), the proportion of
  // the two ratio terms is exactly the value of the targetRatioProperty. If min (0), it is at or outside the tolerance
  // threshold for some feedback in the view (like color/sound); in that case those will be omitted until the ratio is
  // closer to the target. In general, this Property should be used to listen to the fitness of the current ratio. It
  // is preferable to the unclampedFitnessProperty because it is normalized, and simpler when comparing the current ratio
  // to the target ratio.
  //  whether the model is in its "in-proportion" state.
  // If the model is being interacted with MediaPipe as an input. This will alter the characteristics of the ratio.
  constructor(tandem) {
    this.ratio = new RAPRatio(0.2, 0.4, tandem.createTandem('ratio'));
    this.targetRatioProperty = new NumberProperty(this.ratio.currentRatio, {
      tandem: tandem.createTandem('targetRatioProperty')
    });
    this.mediaPipeInteractedWithProperty = new BooleanProperty(false, {
      tandem: tandem.createTandem('mediaPipeInteractedWithProperty')
    });
    this.unclampedFitnessProperty = new DerivedProperty([this.ratio.tupleProperty, this.targetRatioProperty, this.ratio.movingInDirectionProperty], (ratioTuple, ratio, movingInDirection) => {
      const antecedent = ratioTuple.antecedent;
      const consequent = ratioTuple.consequent;
      let unclampedFitness = this.calculateFitness(antecedent, consequent, ratio);
      if (this.inProportion(unclampedFitness) && (
      // If either value is small enough, then we don't allow an "in proportion" fitness level, so make it just below
      // that threshold.
      this.valuesTooSmallForInProportion() ||
      // In this case, the normal model behavior looks buggy because both values are equal, but still in proportion.
      this.ratioEvenButNotAtTarget())) {
        unclampedFitness = rapConstants.RATIO_FITNESS_RANGE.max - this.getInProportionThreshold() - 0.01;
      }
      phet.log && phet.log(`
left: ${antecedent}, 
right: ${consequent}, 
distance: ${Math.abs(consequent - antecedent)}, 
current ratio: ${this.ratio.currentRatio}, 
target ratio: ${this.targetRatioProperty.value},
unclampedFitness: ${unclampedFitness}
`);
      return unclampedFitness;
    }, {
      isValidValue: value => value <= rapConstants.RATIO_FITNESS_RANGE.max,
      // phet-io
      tandem: tandem.createTandem('unclampedFitnessProperty'),
      phetioDocumentation: 'A number stating how "correct" the current ratio is to the target. The max is 1, and min is ' + 'based on what the target ratio is',
      phetioValueType: NumberIO
    });
    this.ratioFitnessProperty = new DerivedProperty([this.unclampedFitnessProperty], unclampedFitness => Utils.clamp(unclampedFitness, rapConstants.RATIO_FITNESS_RANGE.min, rapConstants.RATIO_FITNESS_RANGE.max), {
      isValidValue: value => rapConstants.RATIO_FITNESS_RANGE.contains(value)
    });
    this.inProportionProperty = new DerivedProperty([this.unclampedFitnessProperty, this.ratio.movingInDirectionProperty], this.inProportion.bind(this), {
      tandem: tandem.createTandem('inProportionProperty'),
      phetioValueType: BooleanIO
    });

    // This must be done here, because of the reentrant nature of how fitness changes when the ratio is locked
    this.targetRatioProperty.link(() => {
      this.ratio.lockedProperty.value = false;
    });

    // snap to target ratio when the ratio is locked.
    this.ratio.lockedProperty.link(locked => locked && this.ratio.setRatioToTarget(this.targetRatioProperty.value));
  }

  /**
   * This fitness algorithm is explained in https://github.com/phetsims/ratio-and-proportion/issues/325. It is based
   * on plotting the perpendicular intersection between a point representing the current ratio, and the function of the
   * target ratio. This is possible because the ratio term values are normalized between 0 and 1.
   *
   * NOTE: when targetRatio is greater than 1, the algorithm is flipped to yield the same fitness relationship to the
   * larger term value. Thus moving the consequent when the target ratio is 1/2 will yield identical fitness to moving the
   * antecedent when the target ratio is 2.
   *
   * (see rapConstants.TOTAL_RATIO_TERM_VALUE_RANGE).
   */
  calculateFitness(antecedent, consequent, targetRatio) {
    // This fitness algorithm was designed and executed to target ratios between 0 and 1, when larger, the fitness looks
    // best if the reciprocal is calculated (yielding a similar relationship between the consequent and target ratio of X,
    // as with antecedent when the targetRatio is 1/X). See https://github.com/phetsims/ratio-and-proportion/issues/345
    if (targetRatio > 1) {
      const oldAnt = antecedent;
      antecedent = consequent;
      consequent = oldAnt;
      targetRatio = 1 / targetRatio;
    }
    const idealAntecedent = consequent * targetRatio;
    const idealConsequent = antecedent / targetRatio;

    // If either value is so very close to the ideal, map to being in-proportion. This is to support general usability
    // for small displays that may not have as much granularity for very small or very large ratios.
    if (Math.abs(antecedent - idealAntecedent) < MINIMUM_DISTANCE_FORCES_IN_PROPORTION || Math.abs(consequent - idealConsequent) < MINIMUM_DISTANCE_FORCES_IN_PROPORTION) {
      return rapConstants.RATIO_FITNESS_RANGE.max;
    }

    // Calculate the inverse slope from the current target ratio.
    const coefficient = -1 / targetRatio;
    const yIntercept = antecedent - consequent * coefficient;
    const pointOnTarget = Utils.lineLineIntersection(Vector2.ZERO, new Vector2(1, targetRatio),
    // line for the target ratio
    new Vector2(0, yIntercept), new Vector2(1, coefficient + yIntercept) // line for the inverse slope of target
    );

    assert && assert(pointOnTarget !== null);

    // Find the distance between the current ratio, and the calculated intersection with the target ratio function.
    const distanceFromTarget = new Vector2(consequent, antecedent).distance(pointOnTarget);
    return rapConstants.RATIO_FITNESS_RANGE.max - rapConstants.RATIO_FITNESS_RANGE.max * distanceFromTarget / (MIN_CLAMPED_FITNESS_DISTANCE * targetRatio);
  }

  /**
   * Get the minimum fitness value (unclamped) for the provided target ratio, based on the range of the ratio terms.
   */
  getMinFitness(ratio = this.targetRatioProperty.value) {
    const minRatioFitness = Math.min(this.calculateFitness(TOTAL_RANGE.min, TOTAL_RANGE.max, ratio), this.calculateFitness(TOTAL_RANGE.min, TOTAL_RANGE.min, ratio));
    const maxRatioFitness = Math.min(this.calculateFitness(TOTAL_RANGE.min, TOTAL_RANGE.max, ratio), this.calculateFitness(TOTAL_RANGE.max, TOTAL_RANGE.max, ratio));
    return Math.min(minRatioFitness, maxRatioFitness);
  }

  /**
   * If either value is smaller than a threshold, then the fitness cannot be at its max, "in-proportion" state. This function
   * will return true when the model is in that state. When true, one or both value is too small to allow for a success state.
   */
  valuesTooSmallForInProportion() {
    const currentTuple = this.ratio.tupleProperty.value;
    return currentTuple.antecedent < rapConstants.NO_SUCCESS_VALUE_THRESHOLD || currentTuple.consequent < rapConstants.NO_SUCCESS_VALUE_THRESHOLD;
  }
  getInProportionThreshold() {
    return this.ratio.movingInDirectionProperty.value ? rapConstants.MOVING_IN_PROPORTION_FITNESS_THRESHOLD : this.mediaPipeInteractedWithProperty.value ? rapConstants.MEDIA_PIPE_IN_PROPORTION_FITNESS_THRESHOLD : rapConstants.IN_PROPORTION_FITNESS_THRESHOLD;
  }

  /**
   * This is the sim's definition of if the ratio is in the "success" metric, what we call "in proportion." This changes
   * based on if moving in proportion (bimodal interaction), or not. If fitness is provided, calculate if this fitness is in proportion
   */
  inProportion(fitness = this.ratioFitnessProperty.value) {
    return fitness > rapConstants.RATIO_FITNESS_RANGE.max - this.getInProportionThreshold();
  }
  step() {
    this.ratio.step();
  }

  /**
   * Given a ratio component (antecedent or consequent), determine what it should be to make the current ratio equal to
   * the target ratio.
   */
  getIdealValueForTerm(ratioTerm) {
    if (ratioTerm === RatioTerm.ANTECEDENT) {
      return this.targetRatioProperty.value * this.ratio.tupleProperty.value.consequent;
    }
    if (ratioTerm === RatioTerm.CONSEQUENT) {
      return this.ratio.tupleProperty.value.antecedent / this.targetRatioProperty.value;
    }
    assert && assert(false, 'Invalidat ratioTerm');
    return -1;
  }

  /**
   * A special case in the model where the target ratio is not 1, but both ratio terms are even. This case is worth
   * its own function because it often produces weird bugs in the view's output, see https://github.com/phetsims/ratio-and-proportion/issues/297 and https://github.com/phetsims/ratio-and-proportion/issues/299
   */
  ratioEvenButNotAtTarget() {
    return this.targetRatioProperty.value !== 1 && this.ratio.tupleProperty.value.antecedent === this.ratio.tupleProperty.value.consequent;
  }

  /**
   * Resets the model.
   */
  reset() {
    this.ratio.reset(); // do this first

    this.targetRatioProperty.reset();
    this.mediaPipeInteractedWithProperty.reset();
  }
}
ratioAndProportion.register('RAPModel', RAPModel);
export default RAPModel;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEZXJpdmVkUHJvcGVydHkiLCJOdW1iZXJQcm9wZXJ0eSIsIlV0aWxzIiwiVmVjdG9yMiIsIkJvb2xlYW5JTyIsIk51bWJlcklPIiwicmF0aW9BbmRQcm9wb3J0aW9uIiwicmFwQ29uc3RhbnRzIiwiUkFQUmF0aW8iLCJSYXRpb1Rlcm0iLCJCb29sZWFuUHJvcGVydHkiLCJNSU5fQ0xBTVBFRF9GSVRORVNTX0RJU1RBTkNFIiwiTUlOSU1VTV9ESVNUQU5DRV9GT1JDRVNfSU5fUFJPUE9SVElPTiIsIlRPVEFMX1JBTkdFIiwiVE9UQUxfUkFUSU9fVEVSTV9WQUxVRV9SQU5HRSIsIlJBUE1vZGVsIiwiY29uc3RydWN0b3IiLCJ0YW5kZW0iLCJyYXRpbyIsImNyZWF0ZVRhbmRlbSIsInRhcmdldFJhdGlvUHJvcGVydHkiLCJjdXJyZW50UmF0aW8iLCJtZWRpYVBpcGVJbnRlcmFjdGVkV2l0aFByb3BlcnR5IiwidW5jbGFtcGVkRml0bmVzc1Byb3BlcnR5IiwidHVwbGVQcm9wZXJ0eSIsIm1vdmluZ0luRGlyZWN0aW9uUHJvcGVydHkiLCJyYXRpb1R1cGxlIiwibW92aW5nSW5EaXJlY3Rpb24iLCJhbnRlY2VkZW50IiwiY29uc2VxdWVudCIsInVuY2xhbXBlZEZpdG5lc3MiLCJjYWxjdWxhdGVGaXRuZXNzIiwiaW5Qcm9wb3J0aW9uIiwidmFsdWVzVG9vU21hbGxGb3JJblByb3BvcnRpb24iLCJyYXRpb0V2ZW5CdXROb3RBdFRhcmdldCIsIlJBVElPX0ZJVE5FU1NfUkFOR0UiLCJtYXgiLCJnZXRJblByb3BvcnRpb25UaHJlc2hvbGQiLCJwaGV0IiwibG9nIiwiTWF0aCIsImFicyIsInZhbHVlIiwiaXNWYWxpZFZhbHVlIiwicGhldGlvRG9jdW1lbnRhdGlvbiIsInBoZXRpb1ZhbHVlVHlwZSIsInJhdGlvRml0bmVzc1Byb3BlcnR5IiwiY2xhbXAiLCJtaW4iLCJjb250YWlucyIsImluUHJvcG9ydGlvblByb3BlcnR5IiwiYmluZCIsImxpbmsiLCJsb2NrZWRQcm9wZXJ0eSIsImxvY2tlZCIsInNldFJhdGlvVG9UYXJnZXQiLCJ0YXJnZXRSYXRpbyIsIm9sZEFudCIsImlkZWFsQW50ZWNlZGVudCIsImlkZWFsQ29uc2VxdWVudCIsImNvZWZmaWNpZW50IiwieUludGVyY2VwdCIsInBvaW50T25UYXJnZXQiLCJsaW5lTGluZUludGVyc2VjdGlvbiIsIlpFUk8iLCJhc3NlcnQiLCJkaXN0YW5jZUZyb21UYXJnZXQiLCJkaXN0YW5jZSIsImdldE1pbkZpdG5lc3MiLCJtaW5SYXRpb0ZpdG5lc3MiLCJtYXhSYXRpb0ZpdG5lc3MiLCJjdXJyZW50VHVwbGUiLCJOT19TVUNDRVNTX1ZBTFVFX1RIUkVTSE9MRCIsIk1PVklOR19JTl9QUk9QT1JUSU9OX0ZJVE5FU1NfVEhSRVNIT0xEIiwiTUVESUFfUElQRV9JTl9QUk9QT1JUSU9OX0ZJVE5FU1NfVEhSRVNIT0xEIiwiSU5fUFJPUE9SVElPTl9GSVRORVNTX1RIUkVTSE9MRCIsImZpdG5lc3MiLCJzdGVwIiwiZ2V0SWRlYWxWYWx1ZUZvclRlcm0iLCJyYXRpb1Rlcm0iLCJBTlRFQ0VERU5UIiwiQ09OU0VRVUVOVCIsInJlc2V0IiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJSQVBNb2RlbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMC0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBtYWluIG1vZGVsIGZvciB0aGUgcmF0aW8gaW4gdGhpcyBzaW0uIEl0IGhhcyBhIFJBUFJhdGlvLCB3aXRoIGl0cyBhbnRlY2VkZW50IGFuZCBjb25zZXF1ZW50IHR1cGxlLCBhbmRcclxuICogYWRkIHRvIGl0IGEgdGFyZ2V0IHJhdGlvIHZhbHVlLCBhcyB3ZWxsIGFzIGEgZml0bmVzcyBvZiBob3cgY2xvc2UgdGhlIGN1cnJlbnQgcmF0aW8gKHN0b3JlZCBpbiB0aGUgUkFQUmF0aW8gaW5zdGFuY2UpXHJcbiAqIGlzIHRvIHRoZSB0YXJnZXQuIEluIGdlbmVyYWwgdXNlIFJBUFJhdGlvLnJhdGlvRml0bmVzc1Byb3BlcnR5IChyYW5nZWQgZnJvbSAwLTEpIHRvIGRldGVybWluZSBpZiB5b3UgYXJlIGZhciBvciBjbG9zZVxyXG4gKiB0byB0aGUgdGFyZ2V0LCByZXNwZWN0aXZlbHkuIFNlZSBpbXBsZW1lbnRhdGlvbi1ub3Rlcy5tZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogQGF1dGhvciBNaWNoYWVsIEthdXptYW5uIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBEZXJpdmVkUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9EZXJpdmVkUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgTnVtYmVyUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9OdW1iZXJQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVXRpbHMuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBCb29sZWFuSU8gZnJvbSAnLi4vLi4vLi4vLi4vdGFuZGVtL2pzL3R5cGVzL0Jvb2xlYW5JTy5qcyc7XHJcbmltcG9ydCBOdW1iZXJJTyBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvTnVtYmVySU8uanMnO1xyXG5pbXBvcnQgcmF0aW9BbmRQcm9wb3J0aW9uIGZyb20gJy4uLy4uL3JhdGlvQW5kUHJvcG9ydGlvbi5qcyc7XHJcbmltcG9ydCByYXBDb25zdGFudHMgZnJvbSAnLi4vcmFwQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IFJBUFJhdGlvIGZyb20gJy4vUkFQUmF0aW8uanMnO1xyXG5pbXBvcnQgUmF0aW9UZXJtIGZyb20gJy4vUmF0aW9UZXJtLmpzJztcclxuaW1wb3J0IFRhbmRlbSBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvVGFuZGVtLmpzJztcclxuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5cclxuaW1wb3J0IFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgQm9vbGVhblByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvQm9vbGVhblByb3BlcnR5LmpzJztcclxuaW1wb3J0IFRNb2RlbCBmcm9tICcuLi8uLi8uLi8uLi9qb2lzdC9qcy9UTW9kZWwuanMnO1xyXG4vLyBjb25zdGFudCB0byBoZWxwIGFjaGlldmUgZmVlZGJhY2sgaW4gNDAlIG9mIHRoZSB2aXN1YWwgc2NyZWVuIGhlaWdodCAoMiBkZWZhdWx0IHRpY2sgbWFya3MpLiBDYWxjdWxhdGVkIGJ5IHRha2luZyB0aGVcclxuLy8gZml0bmVzcyBkaXN0YW5jZSB3aGVuIHRoZSByaWdodCBoYW5kIGlzIDIgdGljayBtYXJrcyBmcm9tIHRoZSB0YXJnZXQgcmF0aW8uIFRoaXMgbnVtYmVyIGlzIGJhc2VkIG9uIGEgdGFyZ2V0IHJhdGlvIG9mXHJcbi8vIC41LCBzbyBpdCBpcyBub3JtYWxpemVkIGhlcmUuIFdoZW4gdXNlZCwgaXQgc2hvdWxkIGJlIG11bHRpcGxpZWQgYnkgdGhlIGN1cnJlbnQgdGFyZ2V0IHJhdGlvLlxyXG5jb25zdCBNSU5fQ0xBTVBFRF9GSVRORVNTX0RJU1RBTkNFID0gMC4wODk0NDI3MTkwOTk5OTE2MiAvIDAuNTtcclxuXHJcbi8vIFRoZSB2YWx1ZSBpbiB3aGljaCwgaWYgYSByYXRpbyB0ZXJtJ3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGl0cyBpZGVhbCAodG8gYWNoaWV2ZSB0aGUgZXhhY3QgdGFyZ2V0IHJhdGlvKSBpcyBsZXNzIHRoYW5cclxuLy8gdGhpcyB2YWx1ZSwgdGhlbiB0aGUgbW9kZWwgd2lsbCBhdXRvbWF0aWNhbGx5IGZvcmNlIHRoZSBpbi1wcm9wb3J0aW9uIHN0YXRlLiBUaGlzIGlzIHRvIHN1cHBvcnQgZ2VuZXJhbCBtb3VzZS90b3VjaFxyXG4vLyB1c2FiaWxpdHkgd2l0aCBzbWFsbCByYXRpb3MsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcmF0aW8tYW5kLXByb3BvcnRpb24vaXNzdWVzLzM2OVxyXG5jb25zdCBNSU5JTVVNX0RJU1RBTkNFX0ZPUkNFU19JTl9QUk9QT1JUSU9OID0gMC4wMDE7XHJcblxyXG5jb25zdCBUT1RBTF9SQU5HRSA9IHJhcENvbnN0YW50cy5UT1RBTF9SQVRJT19URVJNX1ZBTFVFX1JBTkdFO1xyXG5cclxuY2xhc3MgUkFQTW9kZWwgaW1wbGVtZW50cyBUTW9kZWwge1xyXG5cclxuICAvLyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcmF0aW8gKHZhbHVlIG9mIHRlcm1zLCBpZiBpdHMgbG9ja2VkLCBldGMpXHJcbiAgcHVibGljIHJhdGlvOiBSQVBSYXRpbztcclxuXHJcbiAgLy8gVGhlIGRlc2lyZWQgcmF0aW8gb2YgdGhlIGFudGVjZWRlbnQgYXMgY29tcGFyZWQgdG8gdGhlIGNvbnNlcXVlbnQuIEFzIGluIDE6Mi4gSW5pdGlhbGl6ZWQgdG8gZGVmYXVsdCByYXRpb1xyXG4gIC8vIHNvIHRoYXQgd2UgYWx3YXlzIHN0YXJ0IGluLXByb3BvcnRpb24uXHJcbiAgcHVibGljIHRhcmdldFJhdGlvUHJvcGVydHk6IE51bWJlclByb3BlcnR5O1xyXG5cclxuICAvLyBIb3cgXCJjb3JyZWN0XCIgdGhlIHByb3BvcnRpb24gY3VycmVudGx5IGlzLiBNYXggaXMgUkFUSU9fRklUTkVTU19SQU5HRS5tYXgsIGJ1dCB0aGUgbWluIGRlcGVuZHMgb24gdGhlIHJhbmdlIG9mIHRoZVxyXG4gIC8vIHJhdGlvIHRlcm1zIChzZWUgUkFQUmF0aW8pLCBhbmQgdGhlIGN1cnJlbnQgdGFyZ2V0UmF0aW8gdmFsdWUuIFRodXMgdXNpbmcgdGhpcyBQcm9wZXJ0eSBzaG91bGQgbGlrZWx5IGJlIHVzZWQgd2l0aFxyXG4gIC8vIGBSQVBNb2RlbC5nZXRNaW5GaXRuZXNzKClgLiBJbiBtb3N0IGNhc2VzLCB0aGlzIHNob3VsZCBub3QgYmUgdXNlZCwgc2luY2UgaXQgaXNuJ3Qgbm9ybWFsaXplZC4gU2VlXHJcbiAgLy8gYHRoaXMucmF0aW9GaXRuZXNzUHJvcGVydHlgIGZvciB0aGUgcHJlZmVycmVkIG1ldGhvZCBvZiBtb25pdG9yaW5nIHJhdGlvIGZpdG5lc3MuIFRoaXMgUHJvcGVydHkgY2FuIGJlIHVzZWZ1bFxyXG4gIC8vIGlmIHlvdSBuZWVkIHRvIG1hcCBmZWVkYmFjayBiYXNlZCBvbiB0aGUgZW50aXJlIHJhbmdlIG9mIGZpdG5lc3MsIGFuZCBub3QganVzdCB3aGVuIHRoZSBjdXJyZW50IHJhdGlvIGdldHNcclxuICAvLyBcImNsb3NlIGVub3VnaFwiIHRvIHRoZSB0YXJnZXQgKHNpbmNlIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGlzIFByb3BlcnR5IGFyZSBhbGwgY2xhbXBlZCB0byAwIGluIHRoaXMucmF0aW9GaXRuZXNzUHJvcGVydHkpLlxyXG4gIHB1YmxpYyB1bmNsYW1wZWRGaXRuZXNzUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PG51bWJlcj47XHJcblxyXG4gIC8vIEhvdyBcImNvcnJlY3RcIiB0aGUgcHJvcG9ydGlvbiBjdXJyZW50bHkgaXMuIGNsYW1wZWQgd2l0aGluIFJBVElPX0ZJVE5FU1NfUkFOR0UuIElmIGF0IG1heCAoMSksIHRoZSBwcm9wb3J0aW9uIG9mXHJcbiAgLy8gdGhlIHR3byByYXRpbyB0ZXJtcyBpcyBleGFjdGx5IHRoZSB2YWx1ZSBvZiB0aGUgdGFyZ2V0UmF0aW9Qcm9wZXJ0eS4gSWYgbWluICgwKSwgaXQgaXMgYXQgb3Igb3V0c2lkZSB0aGUgdG9sZXJhbmNlXHJcbiAgLy8gdGhyZXNob2xkIGZvciBzb21lIGZlZWRiYWNrIGluIHRoZSB2aWV3IChsaWtlIGNvbG9yL3NvdW5kKTsgaW4gdGhhdCBjYXNlIHRob3NlIHdpbGwgYmUgb21pdHRlZCB1bnRpbCB0aGUgcmF0aW8gaXNcclxuICAvLyBjbG9zZXIgdG8gdGhlIHRhcmdldC4gSW4gZ2VuZXJhbCwgdGhpcyBQcm9wZXJ0eSBzaG91bGQgYmUgdXNlZCB0byBsaXN0ZW4gdG8gdGhlIGZpdG5lc3Mgb2YgdGhlIGN1cnJlbnQgcmF0aW8uIEl0XHJcbiAgLy8gaXMgcHJlZmVyYWJsZSB0byB0aGUgdW5jbGFtcGVkRml0bmVzc1Byb3BlcnR5IGJlY2F1c2UgaXQgaXMgbm9ybWFsaXplZCwgYW5kIHNpbXBsZXIgd2hlbiBjb21wYXJpbmcgdGhlIGN1cnJlbnQgcmF0aW9cclxuICAvLyB0byB0aGUgdGFyZ2V0IHJhdGlvLlxyXG4gIHB1YmxpYyByYXRpb0ZpdG5lc3NQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8bnVtYmVyPjtcclxuXHJcbiAgLy8gIHdoZXRoZXIgdGhlIG1vZGVsIGlzIGluIGl0cyBcImluLXByb3BvcnRpb25cIiBzdGF0ZS5cclxuICBwdWJsaWMgaW5Qcm9wb3J0aW9uUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PGJvb2xlYW4+O1xyXG5cclxuICAvLyBJZiB0aGUgbW9kZWwgaXMgYmVpbmcgaW50ZXJhY3RlZCB3aXRoIE1lZGlhUGlwZSBhcyBhbiBpbnB1dC4gVGhpcyB3aWxsIGFsdGVyIHRoZSBjaGFyYWN0ZXJpc3RpY3Mgb2YgdGhlIHJhdGlvLlxyXG4gIHB1YmxpYyBtZWRpYVBpcGVJbnRlcmFjdGVkV2l0aFByb3BlcnR5OiBQcm9wZXJ0eTxib29sZWFuPjtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCB0YW5kZW06IFRhbmRlbSApIHtcclxuXHJcbiAgICB0aGlzLnJhdGlvID0gbmV3IFJBUFJhdGlvKCAwLjIsIDAuNCwgdGFuZGVtLmNyZWF0ZVRhbmRlbSggJ3JhdGlvJyApICk7XHJcblxyXG4gICAgdGhpcy50YXJnZXRSYXRpb1Byb3BlcnR5ID0gbmV3IE51bWJlclByb3BlcnR5KCB0aGlzLnJhdGlvLmN1cnJlbnRSYXRpbywge1xyXG4gICAgICB0YW5kZW06IHRhbmRlbS5jcmVhdGVUYW5kZW0oICd0YXJnZXRSYXRpb1Byb3BlcnR5JyApXHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy5tZWRpYVBpcGVJbnRlcmFjdGVkV2l0aFByb3BlcnR5ID0gbmV3IEJvb2xlYW5Qcm9wZXJ0eSggZmFsc2UsIHtcclxuICAgICAgdGFuZGVtOiB0YW5kZW0uY3JlYXRlVGFuZGVtKCAnbWVkaWFQaXBlSW50ZXJhY3RlZFdpdGhQcm9wZXJ0eScgKVxyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMudW5jbGFtcGVkRml0bmVzc1Byb3BlcnR5ID0gbmV3IERlcml2ZWRQcm9wZXJ0eSggW1xyXG4gICAgICB0aGlzLnJhdGlvLnR1cGxlUHJvcGVydHksXHJcbiAgICAgIHRoaXMudGFyZ2V0UmF0aW9Qcm9wZXJ0eSxcclxuICAgICAgdGhpcy5yYXRpby5tb3ZpbmdJbkRpcmVjdGlvblByb3BlcnR5XHJcbiAgICBdLCAoIHJhdGlvVHVwbGUsIHJhdGlvLCBtb3ZpbmdJbkRpcmVjdGlvbiApID0+IHtcclxuXHJcbiAgICAgIGNvbnN0IGFudGVjZWRlbnQgPSByYXRpb1R1cGxlLmFudGVjZWRlbnQ7XHJcbiAgICAgIGNvbnN0IGNvbnNlcXVlbnQgPSByYXRpb1R1cGxlLmNvbnNlcXVlbnQ7XHJcblxyXG4gICAgICBsZXQgdW5jbGFtcGVkRml0bmVzcyA9IHRoaXMuY2FsY3VsYXRlRml0bmVzcyggYW50ZWNlZGVudCwgY29uc2VxdWVudCwgcmF0aW8gKTtcclxuXHJcbiAgICAgIGlmICggdGhpcy5pblByb3BvcnRpb24oIHVuY2xhbXBlZEZpdG5lc3MgKSAmJlxyXG5cclxuICAgICAgICAgICAvLyBJZiBlaXRoZXIgdmFsdWUgaXMgc21hbGwgZW5vdWdoLCB0aGVuIHdlIGRvbid0IGFsbG93IGFuIFwiaW4gcHJvcG9ydGlvblwiIGZpdG5lc3MgbGV2ZWwsIHNvIG1ha2UgaXQganVzdCBiZWxvd1xyXG4gICAgICAgICAgIC8vIHRoYXQgdGhyZXNob2xkLlxyXG4gICAgICAgICAgICggdGhpcy52YWx1ZXNUb29TbWFsbEZvckluUHJvcG9ydGlvbigpIHx8XHJcblxyXG4gICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgbm9ybWFsIG1vZGVsIGJlaGF2aW9yIGxvb2tzIGJ1Z2d5IGJlY2F1c2UgYm90aCB2YWx1ZXMgYXJlIGVxdWFsLCBidXQgc3RpbGwgaW4gcHJvcG9ydGlvbi5cclxuICAgICAgICAgICAgIHRoaXMucmF0aW9FdmVuQnV0Tm90QXRUYXJnZXQoKSApICkge1xyXG4gICAgICAgIHVuY2xhbXBlZEZpdG5lc3MgPSByYXBDb25zdGFudHMuUkFUSU9fRklUTkVTU19SQU5HRS5tYXggLSB0aGlzLmdldEluUHJvcG9ydGlvblRocmVzaG9sZCgpIC0gMC4wMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcGhldC5sb2cgJiYgcGhldC5sb2coIGBcclxubGVmdDogJHthbnRlY2VkZW50fSwgXHJcbnJpZ2h0OiAke2NvbnNlcXVlbnR9LCBcclxuZGlzdGFuY2U6ICR7TWF0aC5hYnMoIGNvbnNlcXVlbnQgLSBhbnRlY2VkZW50ICl9LCBcclxuY3VycmVudCByYXRpbzogJHt0aGlzLnJhdGlvLmN1cnJlbnRSYXRpb30sIFxyXG50YXJnZXQgcmF0aW86ICR7dGhpcy50YXJnZXRSYXRpb1Byb3BlcnR5LnZhbHVlfSxcclxudW5jbGFtcGVkRml0bmVzczogJHt1bmNsYW1wZWRGaXRuZXNzfVxyXG5gXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gdW5jbGFtcGVkRml0bmVzcztcclxuICAgIH0sIHtcclxuICAgICAgaXNWYWxpZFZhbHVlOiAoIHZhbHVlOiBudW1iZXIgKSA9PiB2YWx1ZSA8PSByYXBDb25zdGFudHMuUkFUSU9fRklUTkVTU19SQU5HRS5tYXgsXHJcblxyXG4gICAgICAvLyBwaGV0LWlvXHJcbiAgICAgIHRhbmRlbTogdGFuZGVtLmNyZWF0ZVRhbmRlbSggJ3VuY2xhbXBlZEZpdG5lc3NQcm9wZXJ0eScgKSxcclxuICAgICAgcGhldGlvRG9jdW1lbnRhdGlvbjogJ0EgbnVtYmVyIHN0YXRpbmcgaG93IFwiY29ycmVjdFwiIHRoZSBjdXJyZW50IHJhdGlvIGlzIHRvIHRoZSB0YXJnZXQuIFRoZSBtYXggaXMgMSwgYW5kIG1pbiBpcyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Jhc2VkIG9uIHdoYXQgdGhlIHRhcmdldCByYXRpbyBpcycsXHJcbiAgICAgIHBoZXRpb1ZhbHVlVHlwZTogTnVtYmVySU9cclxuICAgIH0gKTtcclxuXHJcbiAgICB0aGlzLnJhdGlvRml0bmVzc1Byb3BlcnR5ID0gbmV3IERlcml2ZWRQcm9wZXJ0eSggWyB0aGlzLnVuY2xhbXBlZEZpdG5lc3NQcm9wZXJ0eSBdLFxyXG4gICAgICB1bmNsYW1wZWRGaXRuZXNzID0+IFV0aWxzLmNsYW1wKCB1bmNsYW1wZWRGaXRuZXNzLCByYXBDb25zdGFudHMuUkFUSU9fRklUTkVTU19SQU5HRS5taW4sIHJhcENvbnN0YW50cy5SQVRJT19GSVRORVNTX1JBTkdFLm1heCApLCB7XHJcbiAgICAgICAgaXNWYWxpZFZhbHVlOiAoIHZhbHVlOiBudW1iZXIgKSA9PiByYXBDb25zdGFudHMuUkFUSU9fRklUTkVTU19SQU5HRS5jb250YWlucyggdmFsdWUgKVxyXG4gICAgICB9ICk7XHJcblxyXG4gICAgdGhpcy5pblByb3BvcnRpb25Qcm9wZXJ0eSA9IG5ldyBEZXJpdmVkUHJvcGVydHkoIFtcclxuICAgICAgdGhpcy51bmNsYW1wZWRGaXRuZXNzUHJvcGVydHksXHJcbiAgICAgIHRoaXMucmF0aW8ubW92aW5nSW5EaXJlY3Rpb25Qcm9wZXJ0eVxyXG4gICAgXSwgdGhpcy5pblByb3BvcnRpb24uYmluZCggdGhpcyApLCB7XHJcbiAgICAgIHRhbmRlbTogdGFuZGVtLmNyZWF0ZVRhbmRlbSggJ2luUHJvcG9ydGlvblByb3BlcnR5JyApLFxyXG4gICAgICBwaGV0aW9WYWx1ZVR5cGU6IEJvb2xlYW5JT1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFRoaXMgbXVzdCBiZSBkb25lIGhlcmUsIGJlY2F1c2Ugb2YgdGhlIHJlZW50cmFudCBuYXR1cmUgb2YgaG93IGZpdG5lc3MgY2hhbmdlcyB3aGVuIHRoZSByYXRpbyBpcyBsb2NrZWRcclxuICAgIHRoaXMudGFyZ2V0UmF0aW9Qcm9wZXJ0eS5saW5rKCAoKSA9PiB7XHJcbiAgICAgIHRoaXMucmF0aW8ubG9ja2VkUHJvcGVydHkudmFsdWUgPSBmYWxzZTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBzbmFwIHRvIHRhcmdldCByYXRpbyB3aGVuIHRoZSByYXRpbyBpcyBsb2NrZWQuXHJcbiAgICB0aGlzLnJhdGlvLmxvY2tlZFByb3BlcnR5LmxpbmsoIGxvY2tlZCA9PiBsb2NrZWQgJiYgdGhpcy5yYXRpby5zZXRSYXRpb1RvVGFyZ2V0KCB0aGlzLnRhcmdldFJhdGlvUHJvcGVydHkudmFsdWUgKSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmaXRuZXNzIGFsZ29yaXRobSBpcyBleHBsYWluZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3JhdGlvLWFuZC1wcm9wb3J0aW9uL2lzc3Vlcy8zMjUuIEl0IGlzIGJhc2VkXHJcbiAgICogb24gcGxvdHRpbmcgdGhlIHBlcnBlbmRpY3VsYXIgaW50ZXJzZWN0aW9uIGJldHdlZW4gYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcmF0aW8sIGFuZCB0aGUgZnVuY3Rpb24gb2YgdGhlXHJcbiAgICogdGFyZ2V0IHJhdGlvLiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgdGhlIHJhdGlvIHRlcm0gdmFsdWVzIGFyZSBub3JtYWxpemVkIGJldHdlZW4gMCBhbmQgMS5cclxuICAgKlxyXG4gICAqIE5PVEU6IHdoZW4gdGFyZ2V0UmF0aW8gaXMgZ3JlYXRlciB0aGFuIDEsIHRoZSBhbGdvcml0aG0gaXMgZmxpcHBlZCB0byB5aWVsZCB0aGUgc2FtZSBmaXRuZXNzIHJlbGF0aW9uc2hpcCB0byB0aGVcclxuICAgKiBsYXJnZXIgdGVybSB2YWx1ZS4gVGh1cyBtb3ZpbmcgdGhlIGNvbnNlcXVlbnQgd2hlbiB0aGUgdGFyZ2V0IHJhdGlvIGlzIDEvMiB3aWxsIHlpZWxkIGlkZW50aWNhbCBmaXRuZXNzIHRvIG1vdmluZyB0aGVcclxuICAgKiBhbnRlY2VkZW50IHdoZW4gdGhlIHRhcmdldCByYXRpbyBpcyAyLlxyXG4gICAqXHJcbiAgICogKHNlZSByYXBDb25zdGFudHMuVE9UQUxfUkFUSU9fVEVSTV9WQUxVRV9SQU5HRSkuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVGaXRuZXNzKCBhbnRlY2VkZW50OiBudW1iZXIsIGNvbnNlcXVlbnQ6IG51bWJlciwgdGFyZ2V0UmF0aW86IG51bWJlciApOiBudW1iZXIge1xyXG5cclxuICAgIC8vIFRoaXMgZml0bmVzcyBhbGdvcml0aG0gd2FzIGRlc2lnbmVkIGFuZCBleGVjdXRlZCB0byB0YXJnZXQgcmF0aW9zIGJldHdlZW4gMCBhbmQgMSwgd2hlbiBsYXJnZXIsIHRoZSBmaXRuZXNzIGxvb2tzXHJcbiAgICAvLyBiZXN0IGlmIHRoZSByZWNpcHJvY2FsIGlzIGNhbGN1bGF0ZWQgKHlpZWxkaW5nIGEgc2ltaWxhciByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgY29uc2VxdWVudCBhbmQgdGFyZ2V0IHJhdGlvIG9mIFgsXHJcbiAgICAvLyBhcyB3aXRoIGFudGVjZWRlbnQgd2hlbiB0aGUgdGFyZ2V0UmF0aW8gaXMgMS9YKS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9yYXRpby1hbmQtcHJvcG9ydGlvbi9pc3N1ZXMvMzQ1XHJcbiAgICBpZiAoIHRhcmdldFJhdGlvID4gMSApIHtcclxuICAgICAgY29uc3Qgb2xkQW50ID0gYW50ZWNlZGVudDtcclxuICAgICAgYW50ZWNlZGVudCA9IGNvbnNlcXVlbnQ7XHJcbiAgICAgIGNvbnNlcXVlbnQgPSBvbGRBbnQ7XHJcbiAgICAgIHRhcmdldFJhdGlvID0gMSAvIHRhcmdldFJhdGlvO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlkZWFsQW50ZWNlZGVudCA9IGNvbnNlcXVlbnQgKiB0YXJnZXRSYXRpbztcclxuICAgIGNvbnN0IGlkZWFsQ29uc2VxdWVudCA9IGFudGVjZWRlbnQgLyB0YXJnZXRSYXRpbztcclxuXHJcbiAgICAvLyBJZiBlaXRoZXIgdmFsdWUgaXMgc28gdmVyeSBjbG9zZSB0byB0aGUgaWRlYWwsIG1hcCB0byBiZWluZyBpbi1wcm9wb3J0aW9uLiBUaGlzIGlzIHRvIHN1cHBvcnQgZ2VuZXJhbCB1c2FiaWxpdHlcclxuICAgIC8vIGZvciBzbWFsbCBkaXNwbGF5cyB0aGF0IG1heSBub3QgaGF2ZSBhcyBtdWNoIGdyYW51bGFyaXR5IGZvciB2ZXJ5IHNtYWxsIG9yIHZlcnkgbGFyZ2UgcmF0aW9zLlxyXG4gICAgaWYgKCBNYXRoLmFicyggYW50ZWNlZGVudCAtIGlkZWFsQW50ZWNlZGVudCApIDwgTUlOSU1VTV9ESVNUQU5DRV9GT1JDRVNfSU5fUFJPUE9SVElPTiB8fFxyXG4gICAgICAgICBNYXRoLmFicyggY29uc2VxdWVudCAtIGlkZWFsQ29uc2VxdWVudCApIDwgTUlOSU1VTV9ESVNUQU5DRV9GT1JDRVNfSU5fUFJPUE9SVElPTiApIHtcclxuICAgICAgcmV0dXJuIHJhcENvbnN0YW50cy5SQVRJT19GSVRORVNTX1JBTkdFLm1heDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGludmVyc2Ugc2xvcGUgZnJvbSB0aGUgY3VycmVudCB0YXJnZXQgcmF0aW8uXHJcbiAgICBjb25zdCBjb2VmZmljaWVudCA9IC0xIC8gdGFyZ2V0UmF0aW87XHJcblxyXG4gICAgY29uc3QgeUludGVyY2VwdCA9IGFudGVjZWRlbnQgLSBjb25zZXF1ZW50ICogY29lZmZpY2llbnQ7XHJcblxyXG4gICAgY29uc3QgcG9pbnRPblRhcmdldCA9IFV0aWxzLmxpbmVMaW5lSW50ZXJzZWN0aW9uKFxyXG4gICAgICBWZWN0b3IyLlpFUk8sIG5ldyBWZWN0b3IyKCAxLCB0YXJnZXRSYXRpbyApLCAvLyBsaW5lIGZvciB0aGUgdGFyZ2V0IHJhdGlvXHJcbiAgICAgIG5ldyBWZWN0b3IyKCAwLCB5SW50ZXJjZXB0ICksIG5ldyBWZWN0b3IyKCAxLCBjb2VmZmljaWVudCArIHlJbnRlcmNlcHQgKSAvLyBsaW5lIGZvciB0aGUgaW52ZXJzZSBzbG9wZSBvZiB0YXJnZXRcclxuICAgICk7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggcG9pbnRPblRhcmdldCAhPT0gbnVsbCApO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgcmF0aW8sIGFuZCB0aGUgY2FsY3VsYXRlZCBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgdGFyZ2V0IHJhdGlvIGZ1bmN0aW9uLlxyXG4gICAgY29uc3QgZGlzdGFuY2VGcm9tVGFyZ2V0ID0gbmV3IFZlY3RvcjIoIGNvbnNlcXVlbnQsIGFudGVjZWRlbnQgKS5kaXN0YW5jZSggcG9pbnRPblRhcmdldCEgKTtcclxuXHJcbiAgICByZXR1cm4gcmFwQ29uc3RhbnRzLlJBVElPX0ZJVE5FU1NfUkFOR0UubWF4IC0gKCByYXBDb25zdGFudHMuUkFUSU9fRklUTkVTU19SQU5HRS5tYXggKiBkaXN0YW5jZUZyb21UYXJnZXQgKSAvICggTUlOX0NMQU1QRURfRklUTkVTU19ESVNUQU5DRSAqIHRhcmdldFJhdGlvICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIG1pbmltdW0gZml0bmVzcyB2YWx1ZSAodW5jbGFtcGVkKSBmb3IgdGhlIHByb3ZpZGVkIHRhcmdldCByYXRpbywgYmFzZWQgb24gdGhlIHJhbmdlIG9mIHRoZSByYXRpbyB0ZXJtcy5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0TWluRml0bmVzcyggcmF0aW8gPSB0aGlzLnRhcmdldFJhdGlvUHJvcGVydHkudmFsdWUgKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IG1pblJhdGlvRml0bmVzcyA9IE1hdGgubWluKCB0aGlzLmNhbGN1bGF0ZUZpdG5lc3MoIFRPVEFMX1JBTkdFLm1pbiwgVE9UQUxfUkFOR0UubWF4LCByYXRpbyApLFxyXG4gICAgICB0aGlzLmNhbGN1bGF0ZUZpdG5lc3MoIFRPVEFMX1JBTkdFLm1pbiwgVE9UQUxfUkFOR0UubWluLCByYXRpbyApICk7XHJcbiAgICBjb25zdCBtYXhSYXRpb0ZpdG5lc3MgPSBNYXRoLm1pbiggdGhpcy5jYWxjdWxhdGVGaXRuZXNzKCBUT1RBTF9SQU5HRS5taW4sIFRPVEFMX1JBTkdFLm1heCwgcmF0aW8gKSxcclxuICAgICAgdGhpcy5jYWxjdWxhdGVGaXRuZXNzKCBUT1RBTF9SQU5HRS5tYXgsIFRPVEFMX1JBTkdFLm1heCwgcmF0aW8gKSApO1xyXG4gICAgcmV0dXJuIE1hdGgubWluKCBtaW5SYXRpb0ZpdG5lc3MsIG1heFJhdGlvRml0bmVzcyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgZWl0aGVyIHZhbHVlIGlzIHNtYWxsZXIgdGhhbiBhIHRocmVzaG9sZCwgdGhlbiB0aGUgZml0bmVzcyBjYW5ub3QgYmUgYXQgaXRzIG1heCwgXCJpbi1wcm9wb3J0aW9uXCIgc3RhdGUuIFRoaXMgZnVuY3Rpb25cclxuICAgKiB3aWxsIHJldHVybiB0cnVlIHdoZW4gdGhlIG1vZGVsIGlzIGluIHRoYXQgc3RhdGUuIFdoZW4gdHJ1ZSwgb25lIG9yIGJvdGggdmFsdWUgaXMgdG9vIHNtYWxsIHRvIGFsbG93IGZvciBhIHN1Y2Nlc3Mgc3RhdGUuXHJcbiAgICovXHJcbiAgcHVibGljIHZhbHVlc1Rvb1NtYWxsRm9ySW5Qcm9wb3J0aW9uKCk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgY3VycmVudFR1cGxlID0gdGhpcy5yYXRpby50dXBsZVByb3BlcnR5LnZhbHVlO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRUdXBsZS5hbnRlY2VkZW50IDwgcmFwQ29uc3RhbnRzLk5PX1NVQ0NFU1NfVkFMVUVfVEhSRVNIT0xEIHx8XHJcbiAgICAgICAgICAgY3VycmVudFR1cGxlLmNvbnNlcXVlbnQgPCByYXBDb25zdGFudHMuTk9fU1VDQ0VTU19WQUxVRV9USFJFU0hPTEQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0SW5Qcm9wb3J0aW9uVGhyZXNob2xkKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5yYXRpby5tb3ZpbmdJbkRpcmVjdGlvblByb3BlcnR5LnZhbHVlID8gcmFwQ29uc3RhbnRzLk1PVklOR19JTl9QUk9QT1JUSU9OX0ZJVE5FU1NfVEhSRVNIT0xEIDpcclxuICAgICAgICAgICB0aGlzLm1lZGlhUGlwZUludGVyYWN0ZWRXaXRoUHJvcGVydHkudmFsdWUgPyByYXBDb25zdGFudHMuTUVESUFfUElQRV9JTl9QUk9QT1JUSU9OX0ZJVE5FU1NfVEhSRVNIT0xEIDpcclxuICAgICAgICAgICByYXBDb25zdGFudHMuSU5fUFJPUE9SVElPTl9GSVRORVNTX1RIUkVTSE9MRDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgaXMgdGhlIHNpbSdzIGRlZmluaXRpb24gb2YgaWYgdGhlIHJhdGlvIGlzIGluIHRoZSBcInN1Y2Nlc3NcIiBtZXRyaWMsIHdoYXQgd2UgY2FsbCBcImluIHByb3BvcnRpb24uXCIgVGhpcyBjaGFuZ2VzXHJcbiAgICogYmFzZWQgb24gaWYgbW92aW5nIGluIHByb3BvcnRpb24gKGJpbW9kYWwgaW50ZXJhY3Rpb24pLCBvciBub3QuIElmIGZpdG5lc3MgaXMgcHJvdmlkZWQsIGNhbGN1bGF0ZSBpZiB0aGlzIGZpdG5lc3MgaXMgaW4gcHJvcG9ydGlvblxyXG4gICAqL1xyXG4gIHB1YmxpYyBpblByb3BvcnRpb24oIGZpdG5lc3MgPSB0aGlzLnJhdGlvRml0bmVzc1Byb3BlcnR5LnZhbHVlICk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGZpdG5lc3MgPiByYXBDb25zdGFudHMuUkFUSU9fRklUTkVTU19SQU5HRS5tYXggLSB0aGlzLmdldEluUHJvcG9ydGlvblRocmVzaG9sZCgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0ZXAoKTogdm9pZCB7XHJcbiAgICB0aGlzLnJhdGlvLnN0ZXAoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgcmF0aW8gY29tcG9uZW50IChhbnRlY2VkZW50IG9yIGNvbnNlcXVlbnQpLCBkZXRlcm1pbmUgd2hhdCBpdCBzaG91bGQgYmUgdG8gbWFrZSB0aGUgY3VycmVudCByYXRpbyBlcXVhbCB0b1xyXG4gICAqIHRoZSB0YXJnZXQgcmF0aW8uXHJcbiAgICovXHJcbiAgcHVibGljIGdldElkZWFsVmFsdWVGb3JUZXJtKCByYXRpb1Rlcm06IFJhdGlvVGVybSApOiBudW1iZXIge1xyXG4gICAgaWYgKCByYXRpb1Rlcm0gPT09IFJhdGlvVGVybS5BTlRFQ0VERU5UICkge1xyXG4gICAgICByZXR1cm4gdGhpcy50YXJnZXRSYXRpb1Byb3BlcnR5LnZhbHVlICogdGhpcy5yYXRpby50dXBsZVByb3BlcnR5LnZhbHVlLmNvbnNlcXVlbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoIHJhdGlvVGVybSA9PT0gUmF0aW9UZXJtLkNPTlNFUVVFTlQgKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnJhdGlvLnR1cGxlUHJvcGVydHkudmFsdWUuYW50ZWNlZGVudCAvIHRoaXMudGFyZ2V0UmF0aW9Qcm9wZXJ0eS52YWx1ZTtcclxuICAgIH1cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCAnSW52YWxpZGF0IHJhdGlvVGVybScgKTtcclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc3BlY2lhbCBjYXNlIGluIHRoZSBtb2RlbCB3aGVyZSB0aGUgdGFyZ2V0IHJhdGlvIGlzIG5vdCAxLCBidXQgYm90aCByYXRpbyB0ZXJtcyBhcmUgZXZlbi4gVGhpcyBjYXNlIGlzIHdvcnRoXHJcbiAgICogaXRzIG93biBmdW5jdGlvbiBiZWNhdXNlIGl0IG9mdGVuIHByb2R1Y2VzIHdlaXJkIGJ1Z3MgaW4gdGhlIHZpZXcncyBvdXRwdXQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcmF0aW8tYW5kLXByb3BvcnRpb24vaXNzdWVzLzI5NyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3JhdGlvLWFuZC1wcm9wb3J0aW9uL2lzc3Vlcy8yOTlcclxuICAgKi9cclxuICBwdWJsaWMgcmF0aW9FdmVuQnV0Tm90QXRUYXJnZXQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy50YXJnZXRSYXRpb1Byb3BlcnR5LnZhbHVlICE9PSAxICYmXHJcbiAgICAgICAgICAgdGhpcy5yYXRpby50dXBsZVByb3BlcnR5LnZhbHVlLmFudGVjZWRlbnQgPT09IHRoaXMucmF0aW8udHVwbGVQcm9wZXJ0eS52YWx1ZS5jb25zZXF1ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXRzIHRoZSBtb2RlbC5cclxuICAgKi9cclxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcbiAgICB0aGlzLnJhdGlvLnJlc2V0KCk7IC8vIGRvIHRoaXMgZmlyc3RcclxuXHJcbiAgICB0aGlzLnRhcmdldFJhdGlvUHJvcGVydHkucmVzZXQoKTtcclxuICAgIHRoaXMubWVkaWFQaXBlSW50ZXJhY3RlZFdpdGhQcm9wZXJ0eS5yZXNldCgpO1xyXG4gIH1cclxufVxyXG5cclxucmF0aW9BbmRQcm9wb3J0aW9uLnJlZ2lzdGVyKCAnUkFQTW9kZWwnLCBSQVBNb2RlbCApO1xyXG5leHBvcnQgZGVmYXVsdCBSQVBNb2RlbDsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsZUFBZSxNQUFNLHdDQUF3QztBQUNwRSxPQUFPQyxjQUFjLE1BQU0sdUNBQXVDO0FBQ2xFLE9BQU9DLEtBQUssTUFBTSw2QkFBNkI7QUFDL0MsT0FBT0MsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxPQUFPQyxTQUFTLE1BQU0sMENBQTBDO0FBQ2hFLE9BQU9DLFFBQVEsTUFBTSx5Q0FBeUM7QUFDOUQsT0FBT0Msa0JBQWtCLE1BQU0sNkJBQTZCO0FBQzVELE9BQU9DLFlBQVksTUFBTSxvQkFBb0I7QUFDN0MsT0FBT0Ms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