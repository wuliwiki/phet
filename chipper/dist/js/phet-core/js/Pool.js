// Copyright 2022-2023, University of Colorado Boulder

/**
 * PROTOTYPE version for better support
 *
 * Object pooling mixin, for cases where creating new objects is expensive, and we'd rather mark some objects as able
 * to be reused (i.e. 'in the pool'). This provides a pool of objects for each type it is invoked on. It allows for
 * getting "new" objects that can either be constructed OR pulled in from a pool, and requires that the objects are
 * essentially able to "re-run" the constructor. Then when putting the object back in the pool, references should be
 * released, so memory isn't leaked.
 *
 * With this style of pooling, the following should be standard boilerplate within the class:

  public freeToPool(): void {
    MyType.pool.freeToPool( this );
  }

  public static readonly pool = new Pool( MyType );

 * and can additionally implement TPoolable to make it clear that the type is pooled
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import phetCore from './phetCore.js';
import optionize from './optionize.js';

// Our linter complains that {} should be either Record<string, unknown>, unknown, or Record<string, never>. However in
// this case, we actually want it to be any type of non-nullish structural type, to see if there is anything required.
// eslint-disable-line @typescript-eslint/ban-types

export default class Pool {
  objects = [];
  // The `initialize` option is required if the type doesn't have a correctly-typed initialize method. Therefore, we
  // do some Typescript magic to require providedOptions if that's the case (otherwise providedOptions is optional).
  constructor(type, ...providedOptionsSpread) {
    const options = optionize()({
      defaultArguments: [],
      initialize: type.prototype.initialize,
      maxSize: 100,
      initialSize: 0,
      useDefaultConstruction: false
    }, providedOptionsSpread[0]);
    assert && assert(options.maxSize >= 0);
    assert && assert(options.initialSize >= 0);
    this._maxPoolSize = options.maxSize;

    // There is a madness to this craziness. We'd want to use the method noted at
    // https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible, but the type is
    // not provided in the arguments array below. By calling bind on itself, we're able to get a version of bind that
    // inserts the constructor as the first argument of the .apply called later so we don't create garbage by having
    // to pack `arguments` into an array AND THEN concatenate it with a new first element (the type itself).
    this.partialConstructor = Function.prototype.bind.bind(type, type);

    // Basically our type constructor, but with the default arguments included already.
    this.DefaultConstructor = this.partialConstructor(...options.defaultArguments); // eslint-disable-line @typescript-eslint/no-unnecessary-type-assertion

    this.initialize = options.initialize;
    assert && assert(this.initialize, 'Either pass in an initialize option, or provide a method named initialize on the type with the proper signature');
    this.useDefaultConstruction = options.useDefaultConstruction;

    // Initialize the pool (if it should have objects)
    while (this.objects.length < options.initialSize) {
      this.objects.push(this.createDefaultObject());
    }
  }
  createDefaultObject() {
    return new this.DefaultConstructor();
  }

  /**
   * Returns an object with arbitrary state (possibly constructed with the default arguments).
   */
  fetch() {
    return this.objects.length ? this.objects.pop() : this.createDefaultObject();
  }

  /**
   * Returns an object that behaves as if it was constructed with the given arguments. May result in a new object
   * being created (if the pool is empty), or it may use the constructor to mutate an object from the pool.
   */
  create(...args) {
    let result;
    if (this.objects.length) {
      result = this.objects.pop();
      this.initialize.apply(result, args);
    } else if (this.useDefaultConstruction) {
      result = this.createDefaultObject();
      this.initialize.apply(result, args);
    } else {
      result = new (this.partialConstructor(...args))();
    }
    return result;
  }

  /**
   * Returns the current size of the pool.
   */
  get poolSize() {
    return this.objects.length;
  }

  /**
   * Sets the maximum pool size.
   */
  set maxPoolSize(value) {
    assert && assert(value === Number.POSITIVE_INFINITY || Number.isInteger(value) && value >= 0, 'maxPoolSize should be a non-negative integer or infinity');
    this._maxPoolSize = value;
  }

  /**
   * Returns the maximum pool size.
   */
  get maxPoolSize() {
    return this._maxPoolSize;
  }
  freeToPool(object) {
    if (this.objects.length < this.maxPoolSize) {
      this.objects.push(object);
    }
  }
  forEach(callback) {
    this.objects.forEach(callback);
  }
}
phetCore.register('Pool', Pool);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwaGV0Q29yZSIsIm9wdGlvbml6ZSIsIlBvb2wiLCJvYmplY3RzIiwiY29uc3RydWN0b3IiLCJ0eXBlIiwicHJvdmlkZWRPcHRpb25zU3ByZWFkIiwib3B0aW9ucyIsImRlZmF1bHRBcmd1bWVudHMiLCJpbml0aWFsaXplIiwicHJvdG90eXBlIiwibWF4U2l6ZSIsImluaXRpYWxTaXplIiwidXNlRGVmYXVsdENvbnN0cnVjdGlvbiIsImFzc2VydCIsIl9tYXhQb29sU2l6ZSIsInBhcnRpYWxDb25zdHJ1Y3RvciIsIkZ1bmN0aW9uIiwiYmluZCIsIkRlZmF1bHRDb25zdHJ1Y3RvciIsImxlbmd0aCIsInB1c2giLCJjcmVhdGVEZWZhdWx0T2JqZWN0IiwiZmV0Y2giLCJwb3AiLCJjcmVhdGUiLCJhcmdzIiwicmVzdWx0IiwiYXBwbHkiLCJwb29sU2l6ZSIsIm1heFBvb2xTaXplIiwidmFsdWUiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsImlzSW50ZWdlciIsImZyZWVUb1Bvb2wiLCJvYmplY3QiLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlBvb2wudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjItMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogUFJPVE9UWVBFIHZlcnNpb24gZm9yIGJldHRlciBzdXBwb3J0XHJcbiAqXHJcbiAqIE9iamVjdCBwb29saW5nIG1peGluLCBmb3IgY2FzZXMgd2hlcmUgY3JlYXRpbmcgbmV3IG9iamVjdHMgaXMgZXhwZW5zaXZlLCBhbmQgd2UnZCByYXRoZXIgbWFyayBzb21lIG9iamVjdHMgYXMgYWJsZVxyXG4gKiB0byBiZSByZXVzZWQgKGkuZS4gJ2luIHRoZSBwb29sJykuIFRoaXMgcHJvdmlkZXMgYSBwb29sIG9mIG9iamVjdHMgZm9yIGVhY2ggdHlwZSBpdCBpcyBpbnZva2VkIG9uLiBJdCBhbGxvd3MgZm9yXHJcbiAqIGdldHRpbmcgXCJuZXdcIiBvYmplY3RzIHRoYXQgY2FuIGVpdGhlciBiZSBjb25zdHJ1Y3RlZCBPUiBwdWxsZWQgaW4gZnJvbSBhIHBvb2wsIGFuZCByZXF1aXJlcyB0aGF0IHRoZSBvYmplY3RzIGFyZVxyXG4gKiBlc3NlbnRpYWxseSBhYmxlIHRvIFwicmUtcnVuXCIgdGhlIGNvbnN0cnVjdG9yLiBUaGVuIHdoZW4gcHV0dGluZyB0aGUgb2JqZWN0IGJhY2sgaW4gdGhlIHBvb2wsIHJlZmVyZW5jZXMgc2hvdWxkIGJlXHJcbiAqIHJlbGVhc2VkLCBzbyBtZW1vcnkgaXNuJ3QgbGVha2VkLlxyXG4gKlxyXG4gKiBXaXRoIHRoaXMgc3R5bGUgb2YgcG9vbGluZywgdGhlIGZvbGxvd2luZyBzaG91bGQgYmUgc3RhbmRhcmQgYm9pbGVycGxhdGUgd2l0aGluIHRoZSBjbGFzczpcclxuXHJcbiAgcHVibGljIGZyZWVUb1Bvb2woKTogdm9pZCB7XHJcbiAgICBNeVR5cGUucG9vbC5mcmVlVG9Qb29sKCB0aGlzICk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHBvb2wgPSBuZXcgUG9vbCggTXlUeXBlICk7XHJcblxyXG4gKiBhbmQgY2FuIGFkZGl0aW9uYWxseSBpbXBsZW1lbnQgVFBvb2xhYmxlIHRvIG1ha2UgaXQgY2xlYXIgdGhhdCB0aGUgdHlwZSBpcyBwb29sZWRcclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBDb25zdHJ1Y3RvciBmcm9tICcuL3R5cGVzL0NvbnN0cnVjdG9yLmpzJztcclxuaW1wb3J0IHBoZXRDb3JlIGZyb20gJy4vcGhldENvcmUuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4vb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4vdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xyXG5cclxuZXhwb3J0IHR5cGUgU2VsZlBvb2xhYmxlT3B0aW9uczxUIGV4dGVuZHMgQ29uc3RydWN0b3I+ID0ge1xyXG4gIC8vIElmIGFuIG9iamVjdCBuZWVkcyB0byBiZSBjcmVhdGVkIHdpdGhvdXQgYSBkaXJlY3QgY2FsbCAoc2F5LCB0byBmaWxsIHRoZSBwb29sIGluaXRpYWxseSksIHRoZXNlIGFyZSB0aGUgYXJndW1lbnRzXHJcbiAgLy8gdGhhdCB3aWxsIGJlIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvclxyXG4gIGRlZmF1bHRBcmd1bWVudHM/OiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD47XHJcblxyXG4gIC8vIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIHRoZSBvYmplY3RzIHRvIHJlaW5pdGlhbGl6ZSB0aGVtICh0aGF0IGlzIGVpdGhlciB0aGUgY29uc3RydWN0b3IsIG9yIGFjdHMgbGlrZSB0aGVcclxuICAvLyBjb25zdHJ1Y3RvcikuIE5PVEU6IFRoaXMgc2hvdWxkIHJldHVybiB0aGUgb2JqZWN0IGl0c2VsZiFcclxuICBpbml0aWFsaXplPzogUG9vbGFibGVJbml0aWFsaXplcjxUPjtcclxuXHJcbiAgLy8gQSBsaW1pdCBmb3IgdGhlIHBvb2wgc2l6ZSAoc28gd2UgZG9uJ3QgbGVhayBtZW1vcnkgYnkgZ3Jvd2luZyB0aGUgcG9vbCBmYXN0ZXIgdGhhbiB3ZSB0YWtlIHRoaW5ncyBmcm9tIGl0KS4gQ2FuIGJlXHJcbiAgLy8gY3VzdG9taXplZCBieSBzZXR0aW5nIFR5cGUubWF4UG9vbFNpemVcclxuICBtYXhTaXplPzogbnVtYmVyO1xyXG5cclxuICAvLyBUaGUgaW5pdGlhbCBzaXplIG9mIHRoZSBwb29sLiBUbyBmaWxsIGl0LCBvYmplY3RzIHdpbGwgYmUgY3JlYXRlZCB3aXRoIHRoZSBkZWZhdWx0IGFyZ3VtZW50cy5cclxuICBpbml0aWFsU2l6ZT86IG51bWJlcjtcclxuXHJcbiAgLy8gSWYgdHJ1ZSwgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIGRlZmF1bHQgYXJndW1lbnRzIHdpbGwgYWx3YXlzIGJlIHVzZWQgKGFuZCB0aGVuIGluaXRpYWxpemVkIHdpdGggdGhlIGluaXRpYWxpemVyKVxyXG4gIC8vIGluc3RlYWQgb2YganVzdCBwcm92aWRpbmcgdGhlIGFyZ3VtZW50cyBzdHJhaWdodCB0byB0aGUgY29uc3RydWN0b3IuXHJcbiAgdXNlRGVmYXVsdENvbnN0cnVjdGlvbj86IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBQb29sYWJsZU9wdGlvbnM8VCBleHRlbmRzIENvbnN0cnVjdG9yPiA9XHJcbiAgU2VsZlBvb2xhYmxlT3B0aW9uczxUPiAmICggSW5zdGFuY2VUeXBlPFQ+IGV4dGVuZHMgeyBpbml0aWFsaXplOiBQb29sYWJsZUluaXRpYWxpemVyPFQ+IH0gPyB1bmtub3duIDoge1xyXG4gICAgLy8gUmVxdWlyZSBpbml0aWFsaXplIGlmIG91ciB0eXBlIGRvZXNuJ3QgaGF2ZSBhIGNvbXBhdGlibGUgaW5pdGlhbGl6ZSBtZXRob2QuXHJcbiAgICBpbml0aWFsaXplOiBQb29sYWJsZUluaXRpYWxpemVyPFQ+O1xyXG4gIH0gKTtcclxudHlwZSBQb29sYWJsZUluaXRpYWxpemVyPFQgZXh0ZW5kcyBDb25zdHJ1Y3Rvcj4gPSAoIC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiApID0+IEluc3RhbmNlVHlwZTxUPjtcclxuXHJcbmV4cG9ydCB0eXBlIFRQb29sYWJsZSA9IHtcclxuXHJcbiAgLy8gQWRkcyB0aGlzIG9iamVjdCBpbnRvIHRoZSBwb29sLCBzbyB0aGF0IGl0IGNhbiBiZSByZXVzZWQgZWxzZXdoZXJlLiBHZW5lcmFsbHkgd2hlbiB0aGlzIGlzIGRvbmUsIG5vIG90aGVyXHJcbiAgLy8gcmVmZXJlbmNlcyB0byB0aGUgb2JqZWN0IHNob3VsZCBiZSBoZWxkIChzaW5jZSB0aGV5IHNob3VsZCBub3QgYmUgdXNlZCBhdCBhbGwpLlxyXG4gIGZyZWVUb1Bvb2w6ICgpID0+IHZvaWQ7XHJcbn07XHJcblxyXG4vLyBPdXIgbGludGVyIGNvbXBsYWlucyB0aGF0IHt9IHNob3VsZCBiZSBlaXRoZXIgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIHVua25vd24sIG9yIFJlY29yZDxzdHJpbmcsIG5ldmVyPi4gSG93ZXZlciBpblxyXG4vLyB0aGlzIGNhc2UsIHdlIGFjdHVhbGx5IHdhbnQgaXQgdG8gYmUgYW55IHR5cGUgb2Ygbm9uLW51bGxpc2ggc3RydWN0dXJhbCB0eXBlLCB0byBzZWUgaWYgdGhlcmUgaXMgYW55dGhpbmcgcmVxdWlyZWQuXHJcbmV4cG9ydCB0eXBlIFBvc3NpYmx5UmVxdWlyZWRQYXJhbWV0ZXJTcHJlYWQ8VD4gPSAoIHt9IGV4dGVuZHMgVCA/IFsgVD8gXSA6IFsgVCBdICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9vbDxUIGV4dGVuZHMgQ29uc3RydWN0b3I+IHtcclxuICBwcml2YXRlIHJlYWRvbmx5IG9iamVjdHM6IEluc3RhbmNlVHlwZTxUPltdID0gW107XHJcblxyXG4gIHByaXZhdGUgX21heFBvb2xTaXplOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBwYXJ0aWFsQ29uc3RydWN0b3I6ICggLi4uYXJnczogSW50ZW50aW9uYWxBbnlbXSApID0+IEludGVudGlvbmFsQW55O1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgRGVmYXVsdENvbnN0cnVjdG9yOiBJbnRlbnRpb25hbEFueTtcclxuICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxpemU6IFBvb2xhYmxlSW5pdGlhbGl6ZXI8VD47XHJcbiAgcHJpdmF0ZSByZWFkb25seSB1c2VEZWZhdWx0Q29uc3RydWN0aW9uOiBib29sZWFuO1xyXG5cclxuICAvLyBUaGUgYGluaXRpYWxpemVgIG9wdGlvbiBpcyByZXF1aXJlZCBpZiB0aGUgdHlwZSBkb2Vzbid0IGhhdmUgYSBjb3JyZWN0bHktdHlwZWQgaW5pdGlhbGl6ZSBtZXRob2QuIFRoZXJlZm9yZSwgd2VcclxuICAvLyBkbyBzb21lIFR5cGVzY3JpcHQgbWFnaWMgdG8gcmVxdWlyZSBwcm92aWRlZE9wdGlvbnMgaWYgdGhhdCdzIHRoZSBjYXNlIChvdGhlcndpc2UgcHJvdmlkZWRPcHRpb25zIGlzIG9wdGlvbmFsKS5cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIHR5cGU6IFQsIC4uLnByb3ZpZGVkT3B0aW9uc1NwcmVhZDogUG9zc2libHlSZXF1aXJlZFBhcmFtZXRlclNwcmVhZDxQb29sYWJsZU9wdGlvbnM8VD4+ICkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxTZWxmUG9vbGFibGVPcHRpb25zPFQ+LCBTZWxmUG9vbGFibGVPcHRpb25zPFQ+PigpKCB7XHJcblxyXG4gICAgICBkZWZhdWx0QXJndW1lbnRzOiBbXSBhcyB1bmtub3duIGFzIENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPixcclxuICAgICAgaW5pdGlhbGl6ZTogKCB0eXBlLnByb3RvdHlwZSBhcyB1bmtub3duIGFzIHsgaW5pdGlhbGl6ZTogUG9vbGFibGVJbml0aWFsaXplcjxUPiB9ICkuaW5pdGlhbGl6ZSxcclxuICAgICAgbWF4U2l6ZTogMTAwLFxyXG4gICAgICBpbml0aWFsU2l6ZTogMCxcclxuICAgICAgdXNlRGVmYXVsdENvbnN0cnVjdGlvbjogZmFsc2VcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9uc1NwcmVhZFsgMCBdICk7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggb3B0aW9ucy5tYXhTaXplID49IDAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG9wdGlvbnMuaW5pdGlhbFNpemUgPj0gMCApO1xyXG5cclxuICAgIHRoaXMuX21heFBvb2xTaXplID0gb3B0aW9ucy5tYXhTaXplO1xyXG5cclxuICAgIC8vIFRoZXJlIGlzIGEgbWFkbmVzcyB0byB0aGlzIGNyYXppbmVzcy4gV2UnZCB3YW50IHRvIHVzZSB0aGUgbWV0aG9kIG5vdGVkIGF0XHJcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjA2Nzk3L3VzZS1vZi1hcHBseS13aXRoLW5ldy1vcGVyYXRvci1pcy10aGlzLXBvc3NpYmxlLCBidXQgdGhlIHR5cGUgaXNcclxuICAgIC8vIG5vdCBwcm92aWRlZCBpbiB0aGUgYXJndW1lbnRzIGFycmF5IGJlbG93LiBCeSBjYWxsaW5nIGJpbmQgb24gaXRzZWxmLCB3ZSdyZSBhYmxlIHRvIGdldCBhIHZlcnNpb24gb2YgYmluZCB0aGF0XHJcbiAgICAvLyBpbnNlcnRzIHRoZSBjb25zdHJ1Y3RvciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIC5hcHBseSBjYWxsZWQgbGF0ZXIgc28gd2UgZG9uJ3QgY3JlYXRlIGdhcmJhZ2UgYnkgaGF2aW5nXHJcbiAgICAvLyB0byBwYWNrIGBhcmd1bWVudHNgIGludG8gYW4gYXJyYXkgQU5EIFRIRU4gY29uY2F0ZW5hdGUgaXQgd2l0aCBhIG5ldyBmaXJzdCBlbGVtZW50ICh0aGUgdHlwZSBpdHNlbGYpLlxyXG4gICAgdGhpcy5wYXJ0aWFsQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5iaW5kKCB0eXBlLCB0eXBlICk7XHJcblxyXG4gICAgLy8gQmFzaWNhbGx5IG91ciB0eXBlIGNvbnN0cnVjdG9yLCBidXQgd2l0aCB0aGUgZGVmYXVsdCBhcmd1bWVudHMgaW5jbHVkZWQgYWxyZWFkeS5cclxuICAgIHRoaXMuRGVmYXVsdENvbnN0cnVjdG9yID0gdGhpcy5wYXJ0aWFsQ29uc3RydWN0b3IoIC4uLm9wdGlvbnMuZGVmYXVsdEFyZ3VtZW50cyEgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cclxuXHJcbiAgICB0aGlzLmluaXRpYWxpemUgPSBvcHRpb25zLmluaXRpYWxpemU7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmluaXRpYWxpemUsICdFaXRoZXIgcGFzcyBpbiBhbiBpbml0aWFsaXplIG9wdGlvbiwgb3IgcHJvdmlkZSBhIG1ldGhvZCBuYW1lZCBpbml0aWFsaXplIG9uIHRoZSB0eXBlIHdpdGggdGhlIHByb3BlciBzaWduYXR1cmUnICk7XHJcblxyXG4gICAgdGhpcy51c2VEZWZhdWx0Q29uc3RydWN0aW9uID0gb3B0aW9ucy51c2VEZWZhdWx0Q29uc3RydWN0aW9uO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgdGhlIHBvb2wgKGlmIGl0IHNob3VsZCBoYXZlIG9iamVjdHMpXHJcbiAgICB3aGlsZSAoIHRoaXMub2JqZWN0cy5sZW5ndGggPCBvcHRpb25zLmluaXRpYWxTaXplICkge1xyXG4gICAgICB0aGlzLm9iamVjdHMucHVzaCggdGhpcy5jcmVhdGVEZWZhdWx0T2JqZWN0KCkgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlRGVmYXVsdE9iamVjdCgpOiBJbnN0YW5jZVR5cGU8VD4ge1xyXG4gICAgcmV0dXJuIG5ldyAoIHRoaXMuRGVmYXVsdENvbnN0cnVjdG9yICkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYXJiaXRyYXJ5IHN0YXRlIChwb3NzaWJseSBjb25zdHJ1Y3RlZCB3aXRoIHRoZSBkZWZhdWx0IGFyZ3VtZW50cykuXHJcbiAgICovXHJcbiAgcHVibGljIGZldGNoKCk6IEluc3RhbmNlVHlwZTxUPiB7XHJcbiAgICByZXR1cm4gdGhpcy5vYmplY3RzLmxlbmd0aCA/IHRoaXMub2JqZWN0cy5wb3AoKSEgOiB0aGlzLmNyZWF0ZURlZmF1bHRPYmplY3QoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgYmVoYXZlcyBhcyBpZiBpdCB3YXMgY29uc3RydWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzLiBNYXkgcmVzdWx0IGluIGEgbmV3IG9iamVjdFxyXG4gICAqIGJlaW5nIGNyZWF0ZWQgKGlmIHRoZSBwb29sIGlzIGVtcHR5KSwgb3IgaXQgbWF5IHVzZSB0aGUgY29uc3RydWN0b3IgdG8gbXV0YXRlIGFuIG9iamVjdCBmcm9tIHRoZSBwb29sLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBjcmVhdGUoIC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiApOiBJbnN0YW5jZVR5cGU8VD4ge1xyXG4gICAgbGV0IHJlc3VsdDtcclxuXHJcbiAgICBpZiAoIHRoaXMub2JqZWN0cy5sZW5ndGggKSB7XHJcbiAgICAgIHJlc3VsdCA9IHRoaXMub2JqZWN0cy5wb3AoKTtcclxuICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KCByZXN1bHQsIGFyZ3MgKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCB0aGlzLnVzZURlZmF1bHRDb25zdHJ1Y3Rpb24gKSB7XHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuY3JlYXRlRGVmYXVsdE9iamVjdCgpO1xyXG4gICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkoIHJlc3VsdCwgYXJncyApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJlc3VsdCA9IG5ldyAoIHRoaXMucGFydGlhbENvbnN0cnVjdG9yKCAuLi5hcmdzICkgKSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIHBvb2wuXHJcbiAgICovXHJcbiAgcHVibGljIGdldCBwb29sU2l6ZSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMub2JqZWN0cy5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBtYXhpbXVtIHBvb2wgc2l6ZS5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0IG1heFBvb2xTaXplKCB2YWx1ZTogbnVtYmVyICkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdmFsdWUgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fCAoIE51bWJlci5pc0ludGVnZXIoIHZhbHVlICkgJiYgdmFsdWUgPj0gMCApLCAnbWF4UG9vbFNpemUgc2hvdWxkIGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgb3IgaW5maW5pdHknICk7XHJcblxyXG4gICAgdGhpcy5fbWF4UG9vbFNpemUgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG1heGltdW0gcG9vbCBzaXplLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXQgbWF4UG9vbFNpemUoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLl9tYXhQb29sU2l6ZTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBmcmVlVG9Qb29sKCBvYmplY3Q6IEluc3RhbmNlVHlwZTxUPiApOiB2b2lkIHtcclxuICAgIGlmICggdGhpcy5vYmplY3RzLmxlbmd0aCA8IHRoaXMubWF4UG9vbFNpemUgKSB7XHJcbiAgICAgIHRoaXMub2JqZWN0cy5wdXNoKCBvYmplY3QgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBmb3JFYWNoKCBjYWxsYmFjazogKCBvYmplY3Q6IEluc3RhbmNlVHlwZTxUPiApID0+IHZvaWQgKTogdm9pZCB7XHJcbiAgICB0aGlzLm9iamVjdHMuZm9yRWFjaCggY2FsbGJhY2sgKTtcclxuICB9XHJcbn1cclxuXHJcbnBoZXRDb3JlLnJlZ2lzdGVyKCAnUG9vbCcsIFBvb2wgKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0EsT0FBT0EsUUFBUSxNQUFNLGVBQWU7QUFDcEMsT0FBT0MsU0FBUyxNQUFNLGdCQUFnQjs7QUFzQ3RDO0FBQ0E7QUFDb0Y7O0FBRXBGLGVBQWUsTUFBTUMsSUFBSSxDQUF3QjtFQUM5QkMsT0FBTyxHQUFzQixFQUFFO0VBUWhEO0VBQ0E7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