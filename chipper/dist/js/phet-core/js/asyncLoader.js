// Copyright 2021-2022, University of Colorado Boulder
/**
 * Singleton which keeps track of all async items currently loading, and doesn't proceed until all have been loaded.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */

import arrayRemove from '../../phet-core/js/arrayRemove.js';
import phetCore from './phetCore.js';
class AsyncLoader {
  // Locks waiting to be resolved before we can move to the next phase after loading. Lock objects can be arbitrary
  // objects.

  // Marked as true when there are no more locks and we try to proceed.  Helps protect against new locks being created
  // after they should be.
  // Listeners which will be invoked after everything has been loaded.
  constructor() {
    this.pendingLocks = [];
    this.loadComplete = false;
    this.listeners = [];
  }

  /**
   * @param listener - called when load is complete
   */
  addListener(listener) {
    this.listeners.push(listener);
  }

  /**
   * Attempts to proceed to the next phase if possible (otherwise it's a no-op).
   */
  proceedIfReady() {
    if (this.pendingLocks.length === 0) {
      assert && assert(!this.loadComplete, 'cannot complete load twice');
      this.loadComplete = true;
      this.listeners.forEach(listener => listener());
    }
  }

  /**
   * Creates a lock, which is a callback that needs to be run before we can proceed.
   */
  createLock(object) {
    assert && assert(!this.loadComplete, 'Cannot create more locks after load-step has completed');
    this.pendingLocks.push(object);
    return () => {
      assert && assert(this.pendingLocks.includes(object), 'invalid lock');
      arrayRemove(this.pendingLocks, object);
      this.proceedIfReady();
    };
  }
}
const asyncLoader = new AsyncLoader();
phetCore.register('asyncLoader', asyncLoader);
export default asyncLoader;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhcnJheVJlbW92ZSIsInBoZXRDb3JlIiwiQXN5bmNMb2FkZXIiLCJjb25zdHJ1Y3RvciIsInBlbmRpbmdMb2NrcyIsImxvYWRDb21wbGV0ZSIsImxpc3RlbmVycyIsImFkZExpc3RlbmVyIiwibGlzdGVuZXIiLCJwdXNoIiwicHJvY2VlZElmUmVhZHkiLCJsZW5ndGgiLCJhc3NlcnQiLCJmb3JFYWNoIiwiY3JlYXRlTG9jayIsIm9iamVjdCIsImluY2x1ZGVzIiwiYXN5bmNMb2FkZXIiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbImFzeW5jTG9hZGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG4vKipcclxuICogU2luZ2xldG9uIHdoaWNoIGtlZXBzIHRyYWNrIG9mIGFsbCBhc3luYyBpdGVtcyBjdXJyZW50bHkgbG9hZGluZywgYW5kIGRvZXNuJ3QgcHJvY2VlZCB1bnRpbCBhbGwgaGF2ZSBiZWVuIGxvYWRlZC5cclxuICpcclxuICogQGF1dGhvciBNaWNoYWVsIEthdXptYW5uIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBhcnJheVJlbW92ZSBmcm9tICcuLi8uLi9waGV0LWNvcmUvanMvYXJyYXlSZW1vdmUuanMnO1xyXG5pbXBvcnQgcGhldENvcmUgZnJvbSAnLi9waGV0Q29yZS5qcyc7XHJcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuL3R5cGVzL0ludGVudGlvbmFsQW55LmpzJztcclxuXHJcbnR5cGUgQXN5bmNMb2FkZXJMaXN0ZW5lciA9ICgpID0+IHZvaWQ7XHJcbnR5cGUgQXN5bmNMb2FkZXJMb2NrID0gKCkgPT4gdm9pZDtcclxuXHJcbmNsYXNzIEFzeW5jTG9hZGVyIHtcclxuXHJcbiAgLy8gTG9ja3Mgd2FpdGluZyB0byBiZSByZXNvbHZlZCBiZWZvcmUgd2UgY2FuIG1vdmUgdG8gdGhlIG5leHQgcGhhc2UgYWZ0ZXIgbG9hZGluZy4gTG9jayBvYmplY3RzIGNhbiBiZSBhcmJpdHJhcnlcclxuICAvLyBvYmplY3RzLlxyXG4gIHByaXZhdGUgcGVuZGluZ0xvY2tzOiBJbnRlbnRpb25hbEFueVtdO1xyXG5cclxuICAvLyBNYXJrZWQgYXMgdHJ1ZSB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGxvY2tzIGFuZCB3ZSB0cnkgdG8gcHJvY2VlZC4gIEhlbHBzIHByb3RlY3QgYWdhaW5zdCBuZXcgbG9ja3MgYmVpbmcgY3JlYXRlZFxyXG4gIC8vIGFmdGVyIHRoZXkgc2hvdWxkIGJlLlxyXG4gIHByaXZhdGUgbG9hZENvbXBsZXRlOiBib29sZWFuO1xyXG5cclxuICAvLyBMaXN0ZW5lcnMgd2hpY2ggd2lsbCBiZSBpbnZva2VkIGFmdGVyIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gbG9hZGVkLlxyXG4gIHByaXZhdGUgbGlzdGVuZXJzOiBBc3luY0xvYWRlckxpc3RlbmVyW107XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMucGVuZGluZ0xvY2tzID0gW107XHJcbiAgICB0aGlzLmxvYWRDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGNhbGxlZCB3aGVuIGxvYWQgaXMgY29tcGxldGVcclxuICAgKi9cclxuICBwdWJsaWMgYWRkTGlzdGVuZXIoIGxpc3RlbmVyOiBBc3luY0xvYWRlckxpc3RlbmVyICk6IHZvaWQge1xyXG4gICAgdGhpcy5saXN0ZW5lcnMucHVzaCggbGlzdGVuZXIgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGVtcHRzIHRvIHByb2NlZWQgdG8gdGhlIG5leHQgcGhhc2UgaWYgcG9zc2libGUgKG90aGVyd2lzZSBpdCdzIGEgbm8tb3ApLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgcHJvY2VlZElmUmVhZHkoKTogdm9pZCB7XHJcbiAgICBpZiAoIHRoaXMucGVuZGluZ0xvY2tzLmxlbmd0aCA9PT0gMCApIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggIXRoaXMubG9hZENvbXBsZXRlLCAnY2Fubm90IGNvbXBsZXRlIGxvYWQgdHdpY2UnICk7XHJcbiAgICAgIHRoaXMubG9hZENvbXBsZXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goIGxpc3RlbmVyID0+IGxpc3RlbmVyKCkgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBsb2NrLCB3aGljaCBpcyBhIGNhbGxiYWNrIHRoYXQgbmVlZHMgdG8gYmUgcnVuIGJlZm9yZSB3ZSBjYW4gcHJvY2VlZC5cclxuICAgKi9cclxuICBwdWJsaWMgY3JlYXRlTG9jayggb2JqZWN0PzogSW50ZW50aW9uYWxBbnkgKTogQXN5bmNMb2FkZXJMb2NrIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICF0aGlzLmxvYWRDb21wbGV0ZSwgJ0Nhbm5vdCBjcmVhdGUgbW9yZSBsb2NrcyBhZnRlciBsb2FkLXN0ZXAgaGFzIGNvbXBsZXRlZCcgKTtcclxuICAgIHRoaXMucGVuZGluZ0xvY2tzLnB1c2goIG9iamVjdCApO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5wZW5kaW5nTG9ja3MuaW5jbHVkZXMoIG9iamVjdCApLCAnaW52YWxpZCBsb2NrJyApO1xyXG4gICAgICBhcnJheVJlbW92ZSggdGhpcy5wZW5kaW5nTG9ja3MsIG9iamVjdCApO1xyXG4gICAgICB0aGlzLnByb2NlZWRJZlJlYWR5KCk7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgYXN5bmNMb2FkZXIgPSBuZXcgQXN5bmNMb2FkZXIoKTtcclxuXHJcbnBoZXRDb3JlLnJlZ2lzdGVyKCAnYXN5bmNMb2FkZXInLCBhc3luY0xvYWRlciApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmNMb2FkZXI7XHJcbmV4cG9ydCB0eXBlIHsgQXN5bmNMb2FkZXJMb2NrLCBBc3luY0xvYWRlckxpc3RlbmVyIH07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsV0FBVyxNQUFNLG1DQUFtQztBQUMzRCxPQUFPQyxRQUFRLE1BQU0sZUFBZTtBQU1wQyxNQUFNQyxXQUFXLENBQUM7RUFFaEI7RUFDQTs7RUFHQTtFQUNBO0VBR0E7RUFHT0MsV0FBV0EsQ0FBQSxFQUFHO0lBQ25CLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7SUFDdEIsSUFBSSxDQUFDQyxZQUFZLEdBQUcsS0FBSztJQUN6QixJQUFJLENBQUNDLFNBQVMsR0FBRyxFQUFFO0VBQ3JCOztFQUVBO0FBQ0Y7QUFDQTtFQUNTQyxXQUFXQSxDQUFFQyxRQUE2QixFQUFTO0lBQ3hELElBQUksQ0FBQ0YsU0FBUyxDQUFDRyxJQUFJLENBQUVELFFBQVMsQ0FBQztFQUNqQzs7RUFFQTtBQUNGO0FBQ0E7RUFDVUUsY0FBY0EsQ0FBQSxFQUFTO0lBQzdCLElBQUssSUFBSSxDQUFDTixZQUFZLENBQUNPLE1BQU0sS0FBSyxDQUFDLEVBQUc7TUFDcENDLE1BQU0sSUFBSUEsTUFBTSxDQUFFLENBQUMsSUFBSSxDQUFDUCxZQUFZLEVBQUUsNEJBQTZCLENBQUM7TUFDcEUsSUFBSSxDQUFDQSxZQUFZLEdBQUcsSUFBSTtNQUV4QixJQUFJLENBQUNDLFNBQVMsQ0FBQ08sT0FBTyxDQUFFTCxRQUFRLElBQUlBLFFBQVEsQ0FBQyxDQUFFLENBQUM7SUFDbEQ7RUFDRjs7RUFFQTtBQUNGO0FBQ0E7RUFDU00sVUFBVUEsQ0FBRUMsTUFBdUIsRUFBb0I7SUFDNURILE1BQU0sSUFBSUEsTUFBTSxDQUFFLENBQUMsSUFBSSxDQUFDUCxZQUFZLEVBQUUsd0RBQXlELENBQUM7SUFDaEcsSUFBSSxDQUFDRCxZQUFZLENBQUNLLElBQUksQ0FBRU0sTUFBTyxDQUFDO0lBQ2hDLE9BQU8sTUFBTTtNQUNYSCxNQUFNLElBQUlBLE1BQU0sQ0FBRSxJQUFJLENBQUNSLFlBQVksQ0FBQ1ksUUFBUSxDQUFFRCxNQUFPLENBQUMsRUFBRSxjQUFlLENBQUM7TUFDeEVmLFdBQVcsQ0FBRSxJQUFJLENBQUNJLFlBQVksRUFBRVcsTUFBTyxDQUFDO01BQ3hDLElBQUksQ0FBQ0wsY0FBYyxDQUFDLENBQUM7SUFDdkIsQ0FBQztFQUNIO0FBQ0Y7QUFFQSxNQUFNTyxXQUFXLEdBQUcsSUFBSWYsV0FBVyxDQUFDLENBQUM7QUFFckNELFFBQVEsQ0FBQ2lCLFFBQVEsQ0FBRSxhQUFhLEVBQUVELFdBQVksQ0FBQztBQUUvQyxlQUFlQSxXQUFXIn0=