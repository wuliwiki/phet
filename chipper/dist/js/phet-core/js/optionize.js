// Copyright 2022-2023, University of Colorado Boulder

/**
 * Optionize is a TypeScript layer built on PHET_CORE/merge. Its goal is to satisfy type safety within PhET's "options"
 * pattern.
 *
 * For up-to-date examples on how to use this file, see WILDER/WilderOptionsPatterns.ts
 *
 * This pattern is still being solidified. Although the long term location of PhET's options pattern documentation
 * can be found at https://github.com/phetsims/phet-info/blob/master/doc/phet-software-design-patterns.md#options-and-config,
 * that document is currently out of date. Please see https://github.com/phetsims/phet-core/issues/128 for current
 * progress on this pattern.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */

import phetCore from './phetCore.js';
import merge from './merge.js';

// Gets the parts of an object that are optional

// This is the type for the `defaults` argument to optionize

// eslint-disable-line @typescript-eslint/ban-types
// Factor out the merge arrow closure to avoid heap/cpu at runtime
const merge4 = (a, b, c, d) => merge(a, b, c, d);

// ProvidedOptions = The type of this class's public API (type of the providedOptions parameter in the constructor)
// SelfOptions = Options that are defined by "this" class. Anything optional in this block must have a default provided in "defaults"
// ParentOptions = The public API for parent options, this will be exported by the parent class, like "NodeOptions"
// KeysUsedInSubclassConstructor = list of keys from ParentOptions that are used in this constructor.
export default function optionize() {
  return merge4;
}

// Use this function to gain the typing that optionize provides but in a case where the first argument is an empty object.
export function optionize3() {
  return merge4;
}

/**
 * Use this function to replace merge in cases like:
 *
 * const options = m-e-r-g-e(
 *   {},
 *
 *   // ParentOptions defaults that are common throughout the sim
 *   MyConstants.SOME_COMMON_OPTIONS,
 *
 *   // SelfOptions and ParentOptions defaults that are provided by this class
 *   { ... },
 *
 *   // option values that are provided by the caller
 *   providedOptions );
 */
export function optionize4() {
  return merge4;
}

// Use combineOptions to combine object literals (typically options) that all have the same type.
export function combineOptions(target, ...sources) {
  return merge4(target, ...sources);
}

// function optionize<ProvidedOptions, // eslint-disable-line no-redeclare
//   SelfOptions = ProvidedOptions,
//   ParentOptions = EmptySelfOptions>():
//   <KeysUsedInSubclassConstructor extends keyof ( ParentOptions )>(
//     emptyObject: ObjectWithNoKeys,
//     defaults: OptionizeDefaults<SelfOptions, ParentOptions>,
//     providedOptions?: ProvidedOptions
//   ) => OptionizeDefaults<SelfOptions, ParentOptions> & ProvidedOptions & Required<Pick<ParentOptions, KeysUsedInSubclassConstructor>>;
//
// function optionize<ProvidedOptions, // eslint-disable-line no-redeclare
//   SelfOptions = ProvidedOptions,
//   ParentOptions = EmptySelfOptions,
//   KeysUsedInSubclassConstructor extends keyof ParentOptions = never>():
//   (
//     empytObject: ObjectWithNoKeys,
//     defaults: OptionizeDefaults<SelfOptions, ParentOptions, KeysUsedInSubclassConstructor>,
//     providedOptions?: ProvidedOptions
//   ) => ObjectWithNoKeys & OptionizeDefaults<SelfOptions, ParentOptions, KeysUsedInSubclassConstructor> & ProvidedOptions;

// The implementation gets "any" types because of the above signatures
// function optionize<???>() { return ( a: any, b?: any, c?: any ) => merge( a, b, c ); } // eslint-disable-line no-redeclare,bad-text

// TypeScript is all-or-none on inferring generic parameter types (per function), so we must use the nested strategy in
// https://stackoverflow.com/questions/63678306/typescript-partial-type-inference to specify the types we want
// while still allowing definitions to flow through.
// This also works, we will keep it here now in case it helps with further improvements with inference.
// const optionize = <S, P, M extends keyof P = never>() => {
//   return <B>( defaults: Required<Options<S>> & Partial<P> & Required<Pick<P, M>>, providedOptions?: B ) => {
//     return merge( defaults, providedOptions );
//   };
// };

/*
Limitation (I):

This gets us half way there, when you have required args to the parent, this makes sure that you don't make
providedOptions optional (with a question mark). We still need a way to note when the required param is specified via the self options.
const optionize = <S, P = EmptySelfOptions, M extends keyof P = never, A = S & P>(
  defaults: Required<Options<S>> & Partial<P> & Required<Pick<P, M>>,
  providedOptions: RequiredKeys<A> extends never ? ( A | undefined ) : A
) => {
  return merge( defaults, providedOptions );
};

TEST TO SEE IF WE CAN GET TYPESCRIPT TO KNOW ABOUT REQUIRED ARGUMENTS TO POTENTIALLY COME FROM EITHER ARG.
const optionize = <S, P = EmptySelfOptions, M extends keyof P = never, A = S & P>() => {
  type FirstArg = Required<Options<S>> & Partial<P> & Required<Pick<P, M>>;
  return (
    defaults: FirstArg,
    //NOT WORKING: If any required elements were in the first arg, then we don't need them here, and potentially can mark providedOptions as a whole as optional
    providedOptions: RequiredKeys<FirstArg> extends never ? RequiredKeys<A> extends never ? ( A | undefined ) : A : A
  ) => {
    return merge( defaults, providedOptions );
  };
};
 */

phetCore.register('optionize', optionize);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwaGV0Q29yZSIsIm1lcmdlIiwibWVyZ2U0IiwiYSIsImIiLCJjIiwiZCIsIm9wdGlvbml6ZSIsIm9wdGlvbml6ZTMiLCJvcHRpb25pemU0IiwiY29tYmluZU9wdGlvbnMiLCJ0YXJnZXQiLCJzb3VyY2VzIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJvcHRpb25pemUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjItMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogT3B0aW9uaXplIGlzIGEgVHlwZVNjcmlwdCBsYXllciBidWlsdCBvbiBQSEVUX0NPUkUvbWVyZ2UuIEl0cyBnb2FsIGlzIHRvIHNhdGlzZnkgdHlwZSBzYWZldHkgd2l0aGluIFBoRVQncyBcIm9wdGlvbnNcIlxyXG4gKiBwYXR0ZXJuLlxyXG4gKlxyXG4gKiBGb3IgdXAtdG8tZGF0ZSBleGFtcGxlcyBvbiBob3cgdG8gdXNlIHRoaXMgZmlsZSwgc2VlIFdJTERFUi9XaWxkZXJPcHRpb25zUGF0dGVybnMudHNcclxuICpcclxuICogVGhpcyBwYXR0ZXJuIGlzIHN0aWxsIGJlaW5nIHNvbGlkaWZpZWQuIEFsdGhvdWdoIHRoZSBsb25nIHRlcm0gbG9jYXRpb24gb2YgUGhFVCdzIG9wdGlvbnMgcGF0dGVybiBkb2N1bWVudGF0aW9uXHJcbiAqIGNhbiBiZSBmb3VuZCBhdCBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pbmZvL2Jsb2IvbWFzdGVyL2RvYy9waGV0LXNvZnR3YXJlLWRlc2lnbi1wYXR0ZXJucy5tZCNvcHRpb25zLWFuZC1jb25maWcsXHJcbiAqIHRoYXQgZG9jdW1lbnQgaXMgY3VycmVudGx5IG91dCBvZiBkYXRlLiBQbGVhc2Ugc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9waGV0LWNvcmUvaXNzdWVzLzEyOCBmb3IgY3VycmVudFxyXG4gKiBwcm9ncmVzcyBvbiB0aGlzIHBhdHRlcm4uXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIFJlaWQgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqIEBhdXRob3IgTWljaGFlbCBLYXV6bWFubiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgcGhldENvcmUgZnJvbSAnLi9waGV0Q29yZS5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuL21lcmdlLmpzJztcclxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4vdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xyXG5pbXBvcnQgUmVxdWlyZWRLZXlzIGZyb20gJy4vdHlwZXMvUmVxdWlyZWRLZXlzLmpzJztcclxuaW1wb3J0IE9wdGlvbmFsS2V5cyBmcm9tICcuL3R5cGVzL09wdGlvbmFsS2V5cy5qcyc7XHJcblxyXG4vLyBHZXRzIHRoZSBwYXJ0cyBvZiBhbiBvYmplY3QgdGhhdCBhcmUgb3B0aW9uYWxcclxudHlwZSBPcHRpb25zPFQ+ID0gUGljazxULCBPcHRpb25hbEtleXM8VD4+O1xyXG5cclxudHlwZSBPYmplY3RXaXRoTm9LZXlzID0gUmVjb3JkPHN0cmluZyB8IG51bWJlciwgbmV2ZXI+O1xyXG5cclxuZXhwb3J0IHR5cGUgRW1wdHlTZWxmT3B0aW9ucyA9IHtcclxuICBfZW1wdHlTZWxmT3B0aW9uc0tleT86IG5ldmVyO1xyXG59O1xyXG5cclxudHlwZSBFbXB0eVNlbGZPcHRpb25zS2V5cyA9IGtleW9mIEVtcHR5U2VsZk9wdGlvbnM7XHJcblxyXG4vLyBUaGlzIGlzIHRoZSB0eXBlIGZvciB0aGUgYGRlZmF1bHRzYCBhcmd1bWVudCB0byBvcHRpb25pemVcclxudHlwZSBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucyA9IEVtcHR5U2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnMgPSBFbXB0eVNlbGZPcHRpb25zLCBQcm92aWRlZE9wdGlvbnMgPSBFbXB0eVNlbGZPcHRpb25zPiA9XHJcblxyXG4vLyBFdmVyeXRoaW5nIG9wdGlvbmFsIGZyb20gU2VsZk9wdGlvbnMgbXVzdCBoYXZlIGEgZGVmYXVsdCBzcGVjaWZpZWRcclxuICBPbWl0PFJlcXVpcmVkPE9wdGlvbnM8U2VsZk9wdGlvbnM+PiwgRW1wdHlTZWxmT3B0aW9uc0tleXM+ICYgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcblxyXG4gIC8vIEFueXRoaW5nIHJlcXVpcmVkIGluIHRoZSBQcm92aWRlZE9wdGlvbnMgc2hvdWxkIG5vdCBzaG93IHVwIGluIHRoZSBcImRlZmF1bHRzXCIgb2JqZWN0XHJcbiAgeyBbayBpbiBSZXF1aXJlZEtleXM8UHJvdmlkZWRPcHRpb25zPl0/OiBuZXZlcjsgfSAmXHJcblxyXG4gIC8vIEFueSBvciBub25lIG9mIFBhcmVudCBvcHRpb25zIGNhbiBiZSBwcm92aWRlZFxyXG4gIFBhcnRpYWw8UGFyZW50T3B0aW9ucz5cclxuXHJcbiAgLy8gSW5jbHVkZSB0aGUgcmVxdWlyZWQgcHJvcGVydGllcyBmcm9tIFBhcmVudE9wdGlvbnMgdGhhdCBhcmUgbm90IGluIHRoZSBQcm92aWRlZE9wdGlvbnNcclxuICAmIFJlcXVpcmVkPE9taXQ8UGljazxQYXJlbnRPcHRpb25zLCBSZXF1aXJlZEtleXM8UGFyZW50T3B0aW9ucz4+LCBSZXF1aXJlZEtleXM8UHJvdmlkZWRPcHRpb25zPj4+OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuXHJcbi8vIEZhY3RvciBvdXQgdGhlIG1lcmdlIGFycm93IGNsb3N1cmUgdG8gYXZvaWQgaGVhcC9jcHUgYXQgcnVudGltZVxyXG5jb25zdCBtZXJnZTQgPSAoIGE6IEludGVudGlvbmFsQW55LCBiPzogSW50ZW50aW9uYWxBbnksIGM/OiBJbnRlbnRpb25hbEFueSwgZD86IEludGVudGlvbmFsQW55ICkgPT4gbWVyZ2UoIGEsIGIsIGMsIGQgKTtcclxuXHJcbi8vIFByb3ZpZGVkT3B0aW9ucyA9IFRoZSB0eXBlIG9mIHRoaXMgY2xhc3MncyBwdWJsaWMgQVBJICh0eXBlIG9mIHRoZSBwcm92aWRlZE9wdGlvbnMgcGFyYW1ldGVyIGluIHRoZSBjb25zdHJ1Y3RvcilcclxuLy8gU2VsZk9wdGlvbnMgPSBPcHRpb25zIHRoYXQgYXJlIGRlZmluZWQgYnkgXCJ0aGlzXCIgY2xhc3MuIEFueXRoaW5nIG9wdGlvbmFsIGluIHRoaXMgYmxvY2sgbXVzdCBoYXZlIGEgZGVmYXVsdCBwcm92aWRlZCBpbiBcImRlZmF1bHRzXCJcclxuLy8gUGFyZW50T3B0aW9ucyA9IFRoZSBwdWJsaWMgQVBJIGZvciBwYXJlbnQgb3B0aW9ucywgdGhpcyB3aWxsIGJlIGV4cG9ydGVkIGJ5IHRoZSBwYXJlbnQgY2xhc3MsIGxpa2UgXCJOb2RlT3B0aW9uc1wiXHJcbi8vIEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yID0gbGlzdCBvZiBrZXlzIGZyb20gUGFyZW50T3B0aW9ucyB0aGF0IGFyZSB1c2VkIGluIHRoaXMgY29uc3RydWN0b3IuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9wdGlvbml6ZTxQcm92aWRlZE9wdGlvbnMsXHJcbiAgU2VsZk9wdGlvbnMgPSBQcm92aWRlZE9wdGlvbnMsIC8vIEJ5IGRlZmF1bHQsIGV2ZXJ5IG9wdGlvbmFsIG9wdGlvbiBpbiB0aGUgUHJvdmlkZWRPcHRpb25zIG11c3QgaGF2ZSBhIGRlZmF1bHQgdW5sZXNzIHlvdSBzcGVjaWZ5IGFub3RoZXIgb2JqZWN0IGZvciBTZWxmT3B0aW9uc1xyXG4gIFBhcmVudE9wdGlvbnMgPSBSZWNvcmQ8bmV2ZXIsIG5ldmVyPj4oKTpcclxuICA8S2V5c1VzZWRJblN1YmNsYXNzQ29uc3RydWN0b3IgZXh0ZW5kcyBrZXlvZiAoIFBhcmVudE9wdGlvbnMgKT4oXHJcbiAgICBkZWZhdWx0czogT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnMsIFByb3ZpZGVkT3B0aW9ucz4sXHJcbiAgICBwcm92aWRlZE9wdGlvbnM/OiBQcm92aWRlZE9wdGlvbnNcclxuICApID0+IE9wdGlvbml6ZURlZmF1bHRzPFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zPiAmIFByb3ZpZGVkT3B0aW9ucyAmIFJlcXVpcmVkPFBpY2s8UGFyZW50T3B0aW9ucywgS2V5c1VzZWRJblN1YmNsYXNzQ29uc3RydWN0b3I+PiB7XHJcbiAgcmV0dXJuIG1lcmdlNDtcclxufVxyXG5cclxuLy8gVXNlIHRoaXMgZnVuY3Rpb24gdG8gZ2FpbiB0aGUgdHlwaW5nIHRoYXQgb3B0aW9uaXplIHByb3ZpZGVzIGJ1dCBpbiBhIGNhc2Ugd2hlcmUgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGVtcHR5IG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbml6ZTM8UHJvdmlkZWRPcHRpb25zLFxyXG4gIFNlbGZPcHRpb25zID0gUHJvdmlkZWRPcHRpb25zLCAvLyBCeSBkZWZhdWx0LCBldmVyeSBvcHRpb25hbCBvcHRpb24gaW4gdGhlIFByb3ZpZGVkT3B0aW9ucyBtdXN0IGhhdmUgYSBkZWZhdWx0IHVubGVzcyB5b3Ugc3BlY2lmeSBhbm90aGVyIG9iamVjdCBmb3IgU2VsZk9wdGlvbnNcclxuICBQYXJlbnRPcHRpb25zID0gUmVjb3JkPG5ldmVyLCBuZXZlcj4+KCk6XHJcbiAgPEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yIGV4dGVuZHMga2V5b2YgKCBQYXJlbnRPcHRpb25zICk+KFxyXG4gICAgZW1wdHlPYmplY3Q6IE9iamVjdFdpdGhOb0tleXMsXHJcbiAgICBkZWZhdWx0czogT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnM+LFxyXG4gICAgcHJvdmlkZWRPcHRpb25zPzogUHJvdmlkZWRPcHRpb25zXHJcbiAgKSA9PiBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucywgUGFyZW50T3B0aW9ucz4gJiBQcm92aWRlZE9wdGlvbnMgJiBSZXF1aXJlZDxQaWNrPFBhcmVudE9wdGlvbnMsIEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yPj4ge1xyXG4gIHJldHVybiBtZXJnZTQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2UgdGhpcyBmdW5jdGlvbiB0byByZXBsYWNlIG1lcmdlIGluIGNhc2VzIGxpa2U6XHJcbiAqXHJcbiAqIGNvbnN0IG9wdGlvbnMgPSBtLWUtci1nLWUoXHJcbiAqICAge30sXHJcbiAqXHJcbiAqICAgLy8gUGFyZW50T3B0aW9ucyBkZWZhdWx0cyB0aGF0IGFyZSBjb21tb24gdGhyb3VnaG91dCB0aGUgc2ltXHJcbiAqICAgTXlDb25zdGFudHMuU09NRV9DT01NT05fT1BUSU9OUyxcclxuICpcclxuICogICAvLyBTZWxmT3B0aW9ucyBhbmQgUGFyZW50T3B0aW9ucyBkZWZhdWx0cyB0aGF0IGFyZSBwcm92aWRlZCBieSB0aGlzIGNsYXNzXHJcbiAqICAgeyAuLi4gfSxcclxuICpcclxuICogICAvLyBvcHRpb24gdmFsdWVzIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSBjYWxsZXJcclxuICogICBwcm92aWRlZE9wdGlvbnMgKTtcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25pemU0PFByb3ZpZGVkT3B0aW9ucyxcclxuICBTZWxmT3B0aW9ucyA9IFByb3ZpZGVkT3B0aW9ucyxcclxuICBQYXJlbnRPcHRpb25zID0gb2JqZWN0PigpOlxyXG4gIDxLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3RvciBleHRlbmRzIGtleW9mICggUGFyZW50T3B0aW9ucyApPihcclxuICAgIGVtcHR5T2JqZWN0OiBPYmplY3RXaXRoTm9LZXlzLFxyXG4gICAgZGVmYXVsdHMxOiBQYXJ0aWFsPFBhcmVudE9wdGlvbnM+LFxyXG4gICAgZGVmYXVsdHMyOiBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucywgUGFyZW50T3B0aW9ucz4sXHJcbiAgICBwcm92aWRlZE9wdGlvbnM/OiBQcm92aWRlZE9wdGlvbnNcclxuICApID0+IE9wdGlvbml6ZURlZmF1bHRzPFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zPiAmIFByb3ZpZGVkT3B0aW9ucyAmIFJlcXVpcmVkPFBpY2s8UGFyZW50T3B0aW9ucywgS2V5c1VzZWRJblN1YmNsYXNzQ29uc3RydWN0b3I+PiB7XHJcbiAgcmV0dXJuIG1lcmdlNDtcclxufVxyXG5cclxuLy8gVXNlIGNvbWJpbmVPcHRpb25zIHRvIGNvbWJpbmUgb2JqZWN0IGxpdGVyYWxzICh0eXBpY2FsbHkgb3B0aW9ucykgdGhhdCBhbGwgaGF2ZSB0aGUgc2FtZSB0eXBlLlxyXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZU9wdGlvbnM8VHlwZSBleHRlbmRzIG9iamVjdD4oIHRhcmdldDogUGFydGlhbDxUeXBlPiwgLi4uc291cmNlczogQXJyYXk8UGFydGlhbDxUeXBlPiB8IHVuZGVmaW5lZD4gKTogVHlwZSB7XHJcbiAgcmV0dXJuIG1lcmdlNCggdGFyZ2V0LCAuLi5zb3VyY2VzICk7XHJcbn1cclxuXHJcblxyXG4vLyBmdW5jdGlvbiBvcHRpb25pemU8UHJvdmlkZWRPcHRpb25zLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlZGVjbGFyZVxyXG4vLyAgIFNlbGZPcHRpb25zID0gUHJvdmlkZWRPcHRpb25zLFxyXG4vLyAgIFBhcmVudE9wdGlvbnMgPSBFbXB0eVNlbGZPcHRpb25zPigpOlxyXG4vLyAgIDxLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3RvciBleHRlbmRzIGtleW9mICggUGFyZW50T3B0aW9ucyApPihcclxuLy8gICAgIGVtcHR5T2JqZWN0OiBPYmplY3RXaXRoTm9LZXlzLFxyXG4vLyAgICAgZGVmYXVsdHM6IE9wdGlvbml6ZURlZmF1bHRzPFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zPixcclxuLy8gICAgIHByb3ZpZGVkT3B0aW9ucz86IFByb3ZpZGVkT3B0aW9uc1xyXG4vLyAgICkgPT4gT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnM+ICYgUHJvdmlkZWRPcHRpb25zICYgUmVxdWlyZWQ8UGljazxQYXJlbnRPcHRpb25zLCBLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3Rvcj4+O1xyXG4vL1xyXG4vLyBmdW5jdGlvbiBvcHRpb25pemU8UHJvdmlkZWRPcHRpb25zLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlZGVjbGFyZVxyXG4vLyAgIFNlbGZPcHRpb25zID0gUHJvdmlkZWRPcHRpb25zLFxyXG4vLyAgIFBhcmVudE9wdGlvbnMgPSBFbXB0eVNlbGZPcHRpb25zLFxyXG4vLyAgIEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yIGV4dGVuZHMga2V5b2YgUGFyZW50T3B0aW9ucyA9IG5ldmVyPigpOlxyXG4vLyAgIChcclxuLy8gICAgIGVtcHl0T2JqZWN0OiBPYmplY3RXaXRoTm9LZXlzLFxyXG4vLyAgICAgZGVmYXVsdHM6IE9wdGlvbml6ZURlZmF1bHRzPFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zLCBLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3Rvcj4sXHJcbi8vICAgICBwcm92aWRlZE9wdGlvbnM/OiBQcm92aWRlZE9wdGlvbnNcclxuLy8gICApID0+IE9iamVjdFdpdGhOb0tleXMgJiBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucywgUGFyZW50T3B0aW9ucywgS2V5c1VzZWRJblN1YmNsYXNzQ29uc3RydWN0b3I+ICYgUHJvdmlkZWRPcHRpb25zO1xyXG5cclxuLy8gVGhlIGltcGxlbWVudGF0aW9uIGdldHMgXCJhbnlcIiB0eXBlcyBiZWNhdXNlIG9mIHRoZSBhYm92ZSBzaWduYXR1cmVzXHJcbi8vIGZ1bmN0aW9uIG9wdGlvbml6ZTw/Pz8+KCkgeyByZXR1cm4gKCBhOiBhbnksIGI/OiBhbnksIGM/OiBhbnkgKSA9PiBtZXJnZSggYSwgYiwgYyApOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVkZWNsYXJlLGJhZC10ZXh0XHJcblxyXG4vLyBUeXBlU2NyaXB0IGlzIGFsbC1vci1ub25lIG9uIGluZmVycmluZyBnZW5lcmljIHBhcmFtZXRlciB0eXBlcyAocGVyIGZ1bmN0aW9uKSwgc28gd2UgbXVzdCB1c2UgdGhlIG5lc3RlZCBzdHJhdGVneSBpblxyXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MzY3ODMwNi90eXBlc2NyaXB0LXBhcnRpYWwtdHlwZS1pbmZlcmVuY2UgdG8gc3BlY2lmeSB0aGUgdHlwZXMgd2Ugd2FudFxyXG4vLyB3aGlsZSBzdGlsbCBhbGxvd2luZyBkZWZpbml0aW9ucyB0byBmbG93IHRocm91Z2guXHJcbi8vIFRoaXMgYWxzbyB3b3Jrcywgd2Ugd2lsbCBrZWVwIGl0IGhlcmUgbm93IGluIGNhc2UgaXQgaGVscHMgd2l0aCBmdXJ0aGVyIGltcHJvdmVtZW50cyB3aXRoIGluZmVyZW5jZS5cclxuLy8gY29uc3Qgb3B0aW9uaXplID0gPFMsIFAsIE0gZXh0ZW5kcyBrZXlvZiBQID0gbmV2ZXI+KCkgPT4ge1xyXG4vLyAgIHJldHVybiA8Qj4oIGRlZmF1bHRzOiBSZXF1aXJlZDxPcHRpb25zPFM+PiAmIFBhcnRpYWw8UD4gJiBSZXF1aXJlZDxQaWNrPFAsIE0+PiwgcHJvdmlkZWRPcHRpb25zPzogQiApID0+IHtcclxuLy8gICAgIHJldHVybiBtZXJnZSggZGVmYXVsdHMsIHByb3ZpZGVkT3B0aW9ucyApO1xyXG4vLyAgIH07XHJcbi8vIH07XHJcblxyXG4vKlxyXG5MaW1pdGF0aW9uIChJKTpcclxuXHJcblRoaXMgZ2V0cyB1cyBoYWxmIHdheSB0aGVyZSwgd2hlbiB5b3UgaGF2ZSByZXF1aXJlZCBhcmdzIHRvIHRoZSBwYXJlbnQsIHRoaXMgbWFrZXMgc3VyZSB0aGF0IHlvdSBkb24ndCBtYWtlXHJcbnByb3ZpZGVkT3B0aW9ucyBvcHRpb25hbCAod2l0aCBhIHF1ZXN0aW9uIG1hcmspLiBXZSBzdGlsbCBuZWVkIGEgd2F5IHRvIG5vdGUgd2hlbiB0aGUgcmVxdWlyZWQgcGFyYW0gaXMgc3BlY2lmaWVkIHZpYSB0aGUgc2VsZiBvcHRpb25zLlxyXG5jb25zdCBvcHRpb25pemUgPSA8UywgUCA9IEVtcHR5U2VsZk9wdGlvbnMsIE0gZXh0ZW5kcyBrZXlvZiBQID0gbmV2ZXIsIEEgPSBTICYgUD4oXHJcbiAgZGVmYXVsdHM6IFJlcXVpcmVkPE9wdGlvbnM8Uz4+ICYgUGFydGlhbDxQPiAmIFJlcXVpcmVkPFBpY2s8UCwgTT4+LFxyXG4gIHByb3ZpZGVkT3B0aW9uczogUmVxdWlyZWRLZXlzPEE+IGV4dGVuZHMgbmV2ZXIgPyAoIEEgfCB1bmRlZmluZWQgKSA6IEFcclxuKSA9PiB7XHJcbiAgcmV0dXJuIG1lcmdlKCBkZWZhdWx0cywgcHJvdmlkZWRPcHRpb25zICk7XHJcbn07XHJcblxyXG5URVNUIFRPIFNFRSBJRiBXRSBDQU4gR0VUIFRZUEVTQ1JJUFQgVE8gS05PVyBBQk9VVCBSRVFVSVJFRCBBUkdVTUVOVFMgVE8gUE9URU5USUFMTFkgQ09NRSBGUk9NIEVJVEhFUiBBUkcuXHJcbmNvbnN0IG9wdGlvbml6ZSA9IDxTLCBQID0gRW1wdHlTZWxmT3B0aW9ucywgTSBleHRlbmRzIGtleW9mIFAgPSBuZXZlciwgQSA9IFMgJiBQPigpID0+IHtcclxuICB0eXBlIEZpcnN0QXJnID0gUmVxdWlyZWQ8T3B0aW9uczxTPj4gJiBQYXJ0aWFsPFA+ICYgUmVxdWlyZWQ8UGljazxQLCBNPj47XHJcbiAgcmV0dXJuIChcclxuICAgIGRlZmF1bHRzOiBGaXJzdEFyZyxcclxuICAgIC8vTk9UIFdPUktJTkc6IElmIGFueSByZXF1aXJlZCBlbGVtZW50cyB3ZXJlIGluIHRoZSBmaXJzdCBhcmcsIHRoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGhlcmUsIGFuZCBwb3RlbnRpYWxseSBjYW4gbWFyayBwcm92aWRlZE9wdGlvbnMgYXMgYSB3aG9sZSBhcyBvcHRpb25hbFxyXG4gICAgcHJvdmlkZWRPcHRpb25zOiBSZXF1aXJlZEtleXM8Rmlyc3RBcmc+IGV4dGVuZHMgbmV2ZXIgPyBSZXF1aXJlZEtleXM8QT4gZXh0ZW5kcyBuZXZlciA/ICggQSB8IHVuZGVmaW5lZCApIDogQSA6IEFcclxuICApID0+IHtcclxuICAgIHJldHVybiBtZXJnZSggZGVmYXVsdHMsIHByb3ZpZGVkT3B0aW9ucyApO1xyXG4gIH07XHJcbn07XHJcbiAqL1xyXG5cclxucGhldENvcmUucmVnaXN0ZXIoICdvcHRpb25pemUnLCBvcHRpb25pemUgKTtcclxuZXhwb3J0IHR5cGUgeyBPcHRpb25pemVEZWZhdWx0cyB9OyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxRQUFRLE1BQU0sZUFBZTtBQUNwQyxPQUFPQyxLQUFLLE1BQU0sWUFBWTs7QUFLOUI7O0FBV0E7O0FBYXFHO0FBRXJHO0FBQ0EsTUFBTUMsTUFBTSxHQUFHQSxDQUFFQyxDQUFpQixFQUFFQyxDQUFrQixFQUFFQyxDQUFrQixFQUFFQyxDQUFrQixLQUFNTCxLQUFLLENBQUVFLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUUsQ0FBQzs7QUFFdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVNDLFNBQVNBLENBQUEsRUFNcUc7RUFDcEksT0FBT0wsTUFBTTtBQUNmOztBQUVBO0FBQ0EsT0FBTyxTQUFTTSxVQUFVQSxDQUFBLEVBTzRHO0VBQ3BJLE9BQU9OLE1BQU07QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFNBQVNPLFVBQVVBLENBQUEsRUFRNEc7RUFDcEksT0FBT1AsTUFBTTtBQUNmOztBQUVBO0FBQ0EsT0FBTyxTQUFTUSxjQUFjQSxDQUF1QkMsTUFBcUIsRUFBRSxHQUFHQyxPQUF5QyxFQUFTO0VBQy9ILE9BQU9WLE1BQU0sQ0FBRVMsTUFBTSxFQUFFLEdBQUdDLE9BQVEsQ0FBQztBQUNyQzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBWixRQUFRLENBQUNhLFFBQVEsQ0FBRSxXQUFXLEVBQUVOLFNBQVUsQ0FBQyJ9