// Copyright 2016-2022, University of Colorado Boulder

/**
 * Canvas drawable for Line nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import Poolable from '../../../../phet-core/js/Poolable.js';
import { CanvasSelfDrawable, LineStatelessDrawable, Node, scenery } from '../../imports.js';
class LineCanvasDrawable extends LineStatelessDrawable(CanvasSelfDrawable) {
  /**
   * Paints this drawable to a Canvas (the wrapper contains both a Canvas reference and its drawing context).
   * @public
   *
   * Assumes that the Canvas's context is already in the proper local coordinate frame for the node, and that any
   * other required effects (opacity, clipping, etc.) have already been prepared.
   *
   * This is part of the CanvasSelfDrawable API required to be implemented for subtypes.
   *
   * @param {CanvasContextWrapper} wrapper - Contains the Canvas and its drawing context
   * @param {Node} node - Our node that is being drawn
   * @param {Matrix3} matrix - The transformation matrix applied for this node's coordinate system.
   */
  paintCanvas(wrapper, node, matrix) {
    assert && assert(node instanceof Node);
    const context = wrapper.context;
    context.beginPath();
    context.moveTo(node.x1, node.y1);
    context.lineTo(node.x2, node.y2);
    if (node.hasPaintableStroke()) {
      node.beforeCanvasStroke(wrapper); // defined in Paintable
      context.stroke();
      node.afterCanvasStroke(wrapper); // defined in Paintable
    }
  }
}

scenery.register('LineCanvasDrawable', LineCanvasDrawable);
Poolable.mixInto(LineCanvasDrawable);
export default LineCanvasDrawable;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQb29sYWJsZSIsIkNhbnZhc1NlbGZEcmF3YWJsZSIsIkxpbmVTdGF0ZWxlc3NEcmF3YWJsZSIsIk5vZGUiLCJzY2VuZXJ5IiwiTGluZUNhbnZhc0RyYXdhYmxlIiwicGFpbnRDYW52YXMiLCJ3cmFwcGVyIiwibm9kZSIsIm1hdHJpeCIsImFzc2VydCIsImNvbnRleHQiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJ4MSIsInkxIiwibGluZVRvIiwieDIiLCJ5MiIsImhhc1BhaW50YWJsZVN0cm9rZSIsImJlZm9yZUNhbnZhc1N0cm9rZSIsInN0cm9rZSIsImFmdGVyQ2FudmFzU3Ryb2tlIiwicmVnaXN0ZXIiLCJtaXhJbnRvIl0sInNvdXJjZXMiOlsiTGluZUNhbnZhc0RyYXdhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE2LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIENhbnZhcyBkcmF3YWJsZSBmb3IgTGluZSBub2Rlcy5cclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBQb29sYWJsZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvUG9vbGFibGUuanMnO1xyXG5pbXBvcnQgeyBDYW52YXNTZWxmRHJhd2FibGUsIExpbmVTdGF0ZWxlc3NEcmF3YWJsZSwgTm9kZSwgc2NlbmVyeSB9IGZyb20gJy4uLy4uL2ltcG9ydHMuanMnO1xyXG5cclxuY2xhc3MgTGluZUNhbnZhc0RyYXdhYmxlIGV4dGVuZHMgTGluZVN0YXRlbGVzc0RyYXdhYmxlKCBDYW52YXNTZWxmRHJhd2FibGUgKSB7XHJcbiAgLyoqXHJcbiAgICogUGFpbnRzIHRoaXMgZHJhd2FibGUgdG8gYSBDYW52YXMgKHRoZSB3cmFwcGVyIGNvbnRhaW5zIGJvdGggYSBDYW52YXMgcmVmZXJlbmNlIGFuZCBpdHMgZHJhd2luZyBjb250ZXh0KS5cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBBc3N1bWVzIHRoYXQgdGhlIENhbnZhcydzIGNvbnRleHQgaXMgYWxyZWFkeSBpbiB0aGUgcHJvcGVyIGxvY2FsIGNvb3JkaW5hdGUgZnJhbWUgZm9yIHRoZSBub2RlLCBhbmQgdGhhdCBhbnlcclxuICAgKiBvdGhlciByZXF1aXJlZCBlZmZlY3RzIChvcGFjaXR5LCBjbGlwcGluZywgZXRjLikgaGF2ZSBhbHJlYWR5IGJlZW4gcHJlcGFyZWQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHBhcnQgb2YgdGhlIENhbnZhc1NlbGZEcmF3YWJsZSBBUEkgcmVxdWlyZWQgdG8gYmUgaW1wbGVtZW50ZWQgZm9yIHN1YnR5cGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDYW52YXNDb250ZXh0V3JhcHBlcn0gd3JhcHBlciAtIENvbnRhaW5zIHRoZSBDYW52YXMgYW5kIGl0cyBkcmF3aW5nIGNvbnRleHRcclxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBPdXIgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYXduXHJcbiAgICogQHBhcmFtIHtNYXRyaXgzfSBtYXRyaXggLSBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGFwcGxpZWQgZm9yIHRoaXMgbm9kZSdzIGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAqL1xyXG4gIHBhaW50Q2FudmFzKCB3cmFwcGVyLCBub2RlLCBtYXRyaXggKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBub2RlIGluc3RhbmNlb2YgTm9kZSApO1xyXG5cclxuICAgIGNvbnN0IGNvbnRleHQgPSB3cmFwcGVyLmNvbnRleHQ7XHJcblxyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQubW92ZVRvKCBub2RlLngxLCBub2RlLnkxICk7XHJcbiAgICBjb250ZXh0LmxpbmVUbyggbm9kZS54Miwgbm9kZS55MiApO1xyXG5cclxuICAgIGlmICggbm9kZS5oYXNQYWludGFibGVTdHJva2UoKSApIHtcclxuICAgICAgbm9kZS5iZWZvcmVDYW52YXNTdHJva2UoIHdyYXBwZXIgKTsgLy8gZGVmaW5lZCBpbiBQYWludGFibGVcclxuICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgbm9kZS5hZnRlckNhbnZhc1N0cm9rZSggd3JhcHBlciApOyAvLyBkZWZpbmVkIGluIFBhaW50YWJsZVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuc2NlbmVyeS5yZWdpc3RlciggJ0xpbmVDYW52YXNEcmF3YWJsZScsIExpbmVDYW52YXNEcmF3YWJsZSApO1xyXG5cclxuUG9vbGFibGUubWl4SW50byggTGluZUNhbnZhc0RyYXdhYmxlICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaW5lQ2FudmFzRHJhd2FibGU7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFFBQVEsTUFBTSxzQ0FBc0M7QUFDM0QsU0FBU0Msa0JBQWtCLEVBQUVDLHFCQUFxQixFQUFFQyxJQUFJLEVBQUVDLE9BQU8sUUFBUSxrQkFBa0I7QUFFM0YsTUFBTUMsa0JBQWtCLFNBQVNILHFCQUFxQixDQUFFRCxrQkFBbUIsQ0FBQyxDQUFDO0VBQzNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VLLFdBQVdBLENBQUVDLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUc7SUFDbkNDLE1BQU0sSUFBSUEsTUFBTSxDQUFFRixJQUFJLFlBQVlMLElBQUssQ0FBQztJQUV4QyxNQUFNUSxPQUFPLEdBQUdKLE9BQU8sQ0FBQ0ksT0FBTztJQUUvQkEsT0FBTyxDQUFDQyxTQUFTLENBQUMsQ0FBQztJQUNuQkQsT0FBTyxDQUFDRSxNQUFNLENBQUVMLElBQUksQ0FBQ00sRUFBRSxFQUFFTixJQUFJLENBQUNPLEVBQUcsQ0FBQztJQUNsQ0osT0FBTyxDQUFDSyxNQUFNLENBQUVSLElBQUksQ0FBQ1MsRUFBRSxFQUFFVCxJQUFJLENBQUNVLEVBQUcsQ0FBQztJQUVsQyxJQUFLVixJQUFJLENBQUNXLGtCQUFrQixDQUFDLENBQUMsRUFBRztNQUMvQlgsSUFBSSxDQUFDWSxrQkFBa0IsQ0FBRWIsT0FBUSxDQUFDLENBQUMsQ0FBQztNQUNwQ0ksT0FBTyxDQUFDVSxNQUFNLENBQUMsQ0FBQztNQUNoQmIsSUFBSSxDQUFDYyxpQkFBaUIsQ0FBRWYsT0FBUSxDQUFDLENBQUMsQ0FBQztJQUNyQztFQUNGO0FBQ0Y7O0FBRUFILE9BQU8sQ0FBQ21CLFFBQVEsQ0FBRSxvQkFBb0IsRUFBRWxCLGtCQUFtQixDQUFDO0FBRTVETCxRQUFRLENBQUN3QixPQUFPLENBQUVuQixrQkFBbUIsQ0FBQztBQUV0QyxlQUFlQSxrQkFBa0IifQ==