// Copyright 2016-2022, University of Colorado Boulder

/**
 * Canvas drawable for Path nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import Poolable from '../../../../phet-core/js/Poolable.js';
import { CanvasSelfDrawable, PaintableStatelessDrawable, scenery } from '../../imports.js';
class PathCanvasDrawable extends PaintableStatelessDrawable(CanvasSelfDrawable) {
  /**
   * Paints this drawable to a Canvas (the wrapper contains both a Canvas reference and its drawing context).
   * @public
   *
   * Assumes that the Canvas's context is already in the proper local coordinate frame for the node, and that any
   * other required effects (opacity, clipping, etc.) have already been prepared.
   *
   * This is part of the CanvasSelfDrawable API required to be implemented for subtypes.
   *
   * @param {CanvasContextWrapper} wrapper - Contains the Canvas and its drawing context
   * @param {scenery.Node} node - Our node that is being drawn
   * @param {Matrix3} matrix - The transformation matrix applied for this node's coordinate system.
   */
  paintCanvas(wrapper, node, matrix) {
    const context = wrapper.context;
    if (node.hasShape()) {
      // TODO: fill/stroke delay optimizations?
      context.beginPath();
      node._shape.writeToContext(context);
      if (node.hasFill()) {
        node.beforeCanvasFill(wrapper); // defined in Paintable
        context.fill();
        node.afterCanvasFill(wrapper); // defined in Paintable
      }

      if (node.hasPaintableStroke()) {
        node.beforeCanvasStroke(wrapper); // defined in Paintable
        context.stroke();
        node.afterCanvasStroke(wrapper); // defined in Paintable
      }
    }
  }

  /**
   * @public
   */
  markDirtyShape() {
    this.markPaintDirty();
  }
}
scenery.register('PathCanvasDrawable', PathCanvasDrawable);
Poolable.mixInto(PathCanvasDrawable);
export default PathCanvasDrawable;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQb29sYWJsZSIsIkNhbnZhc1NlbGZEcmF3YWJsZSIsIlBhaW50YWJsZVN0YXRlbGVzc0RyYXdhYmxlIiwic2NlbmVyeSIsIlBhdGhDYW52YXNEcmF3YWJsZSIsInBhaW50Q2FudmFzIiwid3JhcHBlciIsIm5vZGUiLCJtYXRyaXgiLCJjb250ZXh0IiwiaGFzU2hhcGUiLCJiZWdpblBhdGgiLCJfc2hhcGUiLCJ3cml0ZVRvQ29udGV4dCIsImhhc0ZpbGwiLCJiZWZvcmVDYW52YXNGaWxsIiwiZmlsbCIsImFmdGVyQ2FudmFzRmlsbCIsImhhc1BhaW50YWJsZVN0cm9rZSIsImJlZm9yZUNhbnZhc1N0cm9rZSIsInN0cm9rZSIsImFmdGVyQ2FudmFzU3Ryb2tlIiwibWFya0RpcnR5U2hhcGUiLCJtYXJrUGFpbnREaXJ0eSIsInJlZ2lzdGVyIiwibWl4SW50byJdLCJzb3VyY2VzIjpbIlBhdGhDYW52YXNEcmF3YWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNi0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBDYW52YXMgZHJhd2FibGUgZm9yIFBhdGggbm9kZXMuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cclxuICovXHJcblxyXG5pbXBvcnQgUG9vbGFibGUgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL1Bvb2xhYmxlLmpzJztcclxuaW1wb3J0IHsgQ2FudmFzU2VsZkRyYXdhYmxlLCBQYWludGFibGVTdGF0ZWxlc3NEcmF3YWJsZSwgc2NlbmVyeSB9IGZyb20gJy4uLy4uL2ltcG9ydHMuanMnO1xyXG5cclxuY2xhc3MgUGF0aENhbnZhc0RyYXdhYmxlIGV4dGVuZHMgUGFpbnRhYmxlU3RhdGVsZXNzRHJhd2FibGUoIENhbnZhc1NlbGZEcmF3YWJsZSApIHtcclxuICAvKipcclxuICAgKiBQYWludHMgdGhpcyBkcmF3YWJsZSB0byBhIENhbnZhcyAodGhlIHdyYXBwZXIgY29udGFpbnMgYm90aCBhIENhbnZhcyByZWZlcmVuY2UgYW5kIGl0cyBkcmF3aW5nIGNvbnRleHQpLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEFzc3VtZXMgdGhhdCB0aGUgQ2FudmFzJ3MgY29udGV4dCBpcyBhbHJlYWR5IGluIHRoZSBwcm9wZXIgbG9jYWwgY29vcmRpbmF0ZSBmcmFtZSBmb3IgdGhlIG5vZGUsIGFuZCB0aGF0IGFueVxyXG4gICAqIG90aGVyIHJlcXVpcmVkIGVmZmVjdHMgKG9wYWNpdHksIGNsaXBwaW5nLCBldGMuKSBoYXZlIGFscmVhZHkgYmVlbiBwcmVwYXJlZC5cclxuICAgKlxyXG4gICAqIFRoaXMgaXMgcGFydCBvZiB0aGUgQ2FudmFzU2VsZkRyYXdhYmxlIEFQSSByZXF1aXJlZCB0byBiZSBpbXBsZW1lbnRlZCBmb3Igc3VidHlwZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NhbnZhc0NvbnRleHRXcmFwcGVyfSB3cmFwcGVyIC0gQ29udGFpbnMgdGhlIENhbnZhcyBhbmQgaXRzIGRyYXdpbmcgY29udGV4dFxyXG4gICAqIEBwYXJhbSB7c2NlbmVyeS5Ob2RlfSBub2RlIC0gT3VyIG5vZGUgdGhhdCBpcyBiZWluZyBkcmF3blxyXG4gICAqIEBwYXJhbSB7TWF0cml4M30gbWF0cml4IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhcHBsaWVkIGZvciB0aGlzIG5vZGUncyBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgKi9cclxuICBwYWludENhbnZhcyggd3JhcHBlciwgbm9kZSwgbWF0cml4ICkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHdyYXBwZXIuY29udGV4dDtcclxuXHJcbiAgICBpZiAoIG5vZGUuaGFzU2hhcGUoKSApIHtcclxuICAgICAgLy8gVE9ETzogZmlsbC9zdHJva2UgZGVsYXkgb3B0aW1pemF0aW9ucz9cclxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgbm9kZS5fc2hhcGUud3JpdGVUb0NvbnRleHQoIGNvbnRleHQgKTtcclxuXHJcbiAgICAgIGlmICggbm9kZS5oYXNGaWxsKCkgKSB7XHJcbiAgICAgICAgbm9kZS5iZWZvcmVDYW52YXNGaWxsKCB3cmFwcGVyICk7IC8vIGRlZmluZWQgaW4gUGFpbnRhYmxlXHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgICAgbm9kZS5hZnRlckNhbnZhc0ZpbGwoIHdyYXBwZXIgKTsgLy8gZGVmaW5lZCBpbiBQYWludGFibGVcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCBub2RlLmhhc1BhaW50YWJsZVN0cm9rZSgpICkge1xyXG4gICAgICAgIG5vZGUuYmVmb3JlQ2FudmFzU3Ryb2tlKCB3cmFwcGVyICk7IC8vIGRlZmluZWQgaW4gUGFpbnRhYmxlXHJcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICBub2RlLmFmdGVyQ2FudmFzU3Ryb2tlKCB3cmFwcGVyICk7IC8vIGRlZmluZWQgaW4gUGFpbnRhYmxlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBtYXJrRGlydHlTaGFwZSgpIHtcclxuICAgIHRoaXMubWFya1BhaW50RGlydHkoKTtcclxuICB9XHJcbn1cclxuXHJcbnNjZW5lcnkucmVnaXN0ZXIoICdQYXRoQ2FudmFzRHJhd2FibGUnLCBQYXRoQ2FudmFzRHJhd2FibGUgKTtcclxuXHJcblBvb2xhYmxlLm1peEludG8oIFBhdGhDYW52YXNEcmF3YWJsZSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGF0aENhbnZhc0RyYXdhYmxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxRQUFRLE1BQU0sc0NBQXNDO0FBQzNELFNBQVNDLGtCQUFrQixFQUFFQywwQkFBMEIsRUFBRUMsT0FBTyxRQUFRLGtCQUFrQjtBQUUxRixNQUFNQyxrQkFBa0IsU0FBU0YsMEJBQTBCLENBQUVELGtCQUFtQixDQUFDLENBQUM7RUFDaEY7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUksV0FBV0EsQ0FBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRztJQUNuQyxNQUFNQyxPQUFPLEdBQUdILE9BQU8sQ0FBQ0csT0FBTztJQUUvQixJQUFLRixJQUFJLENBQUNHLFFBQVEsQ0FBQyxDQUFDLEVBQUc7TUFDckI7TUFDQUQsT0FBTyxDQUFDRSxTQUFTLENBQUMsQ0FBQztNQUNuQkosSUFBSSxDQUFDSyxNQUFNLENBQUNDLGNBQWMsQ0FBRUosT0FBUSxDQUFDO01BRXJDLElBQUtGLElBQUksQ0FBQ08sT0FBTyxDQUFDLENBQUMsRUFBRztRQUNwQlAsSUFBSSxDQUFDUSxnQkFBZ0IsQ0FBRVQsT0FBUSxDQUFDLENBQUMsQ0FBQztRQUNsQ0csT0FBTyxDQUFDTyxJQUFJLENBQUMsQ0FBQztRQUNkVCxJQUFJLENBQUNVLGVBQWUsQ0FBRVgsT0FBUSxDQUFDLENBQUMsQ0FBQztNQUNuQzs7TUFFQSxJQUFLQyxJQUFJLENBQUNXLGtCQUFrQixDQUFDLENBQUMsRUFBRztRQUMvQlgsSUFBSSxDQUFDWSxrQkFBa0IsQ0FBRWIsT0FBUSxDQUFDLENBQUMsQ0FBQztRQUNwQ0csT0FBTyxDQUFDVyxNQUFNLENBQUMsQ0FBQztRQUNoQmIsSUFBSSxDQUFDYyxpQkFBaUIsQ0FBRWYsT0FBUSxDQUFDLENBQUMsQ0FBQztNQUNyQztJQUNGO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0VBQ0VnQixjQUFjQSxDQUFBLEVBQUc7SUFDZixJQUFJLENBQUNDLGNBQWMsQ0FBQyxDQUFDO0VBQ3ZCO0FBQ0Y7QUFFQXBCLE9BQU8sQ0FBQ3FCLFFBQVEsQ0FBRSxvQkFBb0IsRUFBRXBCLGtCQUFtQixDQUFDO0FBRTVESixRQUFRLENBQUN5QixPQUFPLENBQUVyQixrQkFBbUIsQ0FBQztBQUV0QyxlQUFlQSxrQkFBa0IifQ==