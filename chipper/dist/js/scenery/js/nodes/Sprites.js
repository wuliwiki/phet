// Copyright 2019-2023, University of Colorado Boulder

/**
 * Meant for displaying a large amount of high-performance instances of sprites.
 * See https://github.com/phetsims/scenery/issues/990 for more information.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import { Shape } from '../../../kite/js/imports.js';
import optionize from '../../../phet-core/js/optionize.js';
import { Node, Renderer, scenery, SpritesCanvasDrawable, SpritesWebGLDrawable } from '../imports.js';

// We don't specify a default for canvasBounds on purpose, so we'll omit this from the optionize type parameter.

export default class Sprites extends Node {
  constructor(providedOptions) {
    const options = optionize()({
      sprites: [],
      spriteInstances: [],
      hitTestSprites: false,
      // Sets the node's default renderer to WebGL (as we'll generally want that when using this type)
      renderer: 'webgl'
    }, providedOptions);
    super();
    this._sprites = options.sprites;
    this._spriteInstances = options.spriteInstances;
    this._hitTestSprites = options.hitTestSprites;

    // WebGL and Canvas are supported.
    this.setRendererBitmask(Renderer.bitmaskCanvas | Renderer.bitmaskWebGL);
    this.mutate(options);
  }

  /**
   * Sets the bounds that are used for layout/repainting.
   *
   * These bounds should always cover at least the area where the Sprites will draw in. If this is violated, this
   * node may be partially or completely invisible in Scenery's output.
   */
  setCanvasBounds(selfBounds) {
    this.invalidateSelf(selfBounds);
  }
  set canvasBounds(value) {
    this.setCanvasBounds(value);
  }
  get canvasBounds() {
    return this.getCanvasBounds();
  }

  /**
   * Returns the previously-set canvasBounds, or Bounds2.NOTHING if it has not been set yet.
   */
  getCanvasBounds() {
    return this.getSelfBounds();
  }

  /**
   * Draws the current Node's self representation, assuming the wrapper's Canvas context is already in the local
   * coordinate frame of this node.
   *
   * @param wrapper
   * @param matrix - The transformation matrix already applied to the context.
   */
  canvasPaintSelf(wrapper, matrix) {
    SpritesCanvasDrawable.prototype.paintCanvas(wrapper, this, matrix);
  }

  /**
   * Creates a Canvas drawable for this Sprites node. (scenery-internal)
   *
   * @param renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
   * @param instance - Instance object that will be associated with the drawable
   */
  createCanvasDrawable(renderer, instance) {
    // @ts-expect-error Pooling
    return SpritesCanvasDrawable.createFromPool(renderer, instance);
  }

  /**
   * Creates a WebGL drawable for this Image. (scenery-internal)
   *
   * @param renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
   * @param instance - Instance object that will be associated with the drawable
   */
  createWebGLDrawable(renderer, instance) {
    // @ts-expect-error Pooling
    return SpritesWebGLDrawable.createFromPool(renderer, instance);
  }

  /**
   * Computes whether the provided point is "inside" (contained) in this Node's self content, or "outside".
   *
   * @param point - Considered to be in the local coordinate frame
   */
  containsPointSelf(point) {
    const inBounds = super.containsPointSelf(point);
    if (!inBounds) {
      return false;
    }
    if (this._hitTestSprites) {
      return !!this.getSpriteInstanceFromPoint(point);
    } else {
      return true;
    }
  }

  /**
   * Finds which sprite instance is on top under a certain point (or null if none are).
   */
  getSpriteInstanceFromPoint(point) {
    for (let i = this._spriteInstances.length - 1; i >= 0; i--) {
      if (this._spriteInstances[i].containsPoint(point)) {
        return this._spriteInstances[i];
      }
    }
    return null;
  }

  /**
   * Returns a Shape that represents the area covered by containsPointSelf.
   */
  getSelfShape() {
    if (this._hitTestSprites) {
      return Shape.union(this._spriteInstances.map(instance => instance.getShape()));
    } else {
      return Shape.bounds(this.selfBounds);
    }
  }

  /**
   * Whether this Node itself is painted (displays something itself).
   */
  isPainted() {
    // Always true for Sprites nodes
    return true;
  }

  /**
   * Should be called when this node needs to be repainted. When not called, Scenery assumes that this node does
   * NOT need to be repainted (although Scenery may repaint it due to other nodes needing to be repainted).
   *
   * This sets a "dirty" flag, so that it will be repainted the next time it would be displayed.
   */
  invalidatePaint() {
    const stateLen = this._drawables.length;
    for (let i = 0; i < stateLen; i++) {
      this._drawables[i].markDirty();
    }
  }
  mutate(options) {
    return super.mutate(options);
  }
}

/**
 * {Array.<string>} - String keys for all the allowed options that will be set by node.mutate( options ), in the
 * order they will be evaluated in.
 *
 * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
 *       cases that may apply.
 */
Sprites.prototype._mutatorKeys = ['canvasBounds'].concat(Node.prototype._mutatorKeys);
scenery.register('Sprites', Sprites);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTaGFwZSIsIm9wdGlvbml6ZSIsIk5vZGUiLCJSZW5kZXJlciIsInNjZW5lcnkiLCJTcHJpdGVzQ2FudmFzRHJhd2FibGUiLCJTcHJpdGVzV2ViR0xEcmF3YWJsZSIsIlNwcml0ZXMiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJzcHJpdGVzIiwic3ByaXRlSW5zdGFuY2VzIiwiaGl0VGVzdFNwcml0ZXMiLCJyZW5kZXJlciIsIl9zcHJpdGVzIiwiX3Nwcml0ZUluc3RhbmNlcyIsIl9oaXRUZXN0U3ByaXRlcyIsInNldFJlbmRlcmVyQml0bWFzayIsImJpdG1hc2tDYW52YXMiLCJiaXRtYXNrV2ViR0wiLCJtdXRhdGUiLCJzZXRDYW52YXNCb3VuZHMiLCJzZWxmQm91bmRzIiwiaW52YWxpZGF0ZVNlbGYiLCJjYW52YXNCb3VuZHMiLCJ2YWx1ZSIsImdldENhbnZhc0JvdW5kcyIsImdldFNlbGZCb3VuZHMiLCJjYW52YXNQYWludFNlbGYiLCJ3cmFwcGVyIiwibWF0cml4IiwicHJvdG90eXBlIiwicGFpbnRDYW52YXMiLCJjcmVhdGVDYW52YXNEcmF3YWJsZSIsImluc3RhbmNlIiwiY3JlYXRlRnJvbVBvb2wiLCJjcmVhdGVXZWJHTERyYXdhYmxlIiwiY29udGFpbnNQb2ludFNlbGYiLCJwb2ludCIsImluQm91bmRzIiwiZ2V0U3ByaXRlSW5zdGFuY2VGcm9tUG9pbnQiLCJpIiwibGVuZ3RoIiwiY29udGFpbnNQb2ludCIsImdldFNlbGZTaGFwZSIsInVuaW9uIiwibWFwIiwiZ2V0U2hhcGUiLCJib3VuZHMiLCJpc1BhaW50ZWQiLCJpbnZhbGlkYXRlUGFpbnQiLCJzdGF0ZUxlbiIsIl9kcmF3YWJsZXMiLCJtYXJrRGlydHkiLCJfbXV0YXRvcktleXMiLCJjb25jYXQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlNwcml0ZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogTWVhbnQgZm9yIGRpc3BsYXlpbmcgYSBsYXJnZSBhbW91bnQgb2YgaGlnaC1wZXJmb3JtYW5jZSBpbnN0YW5jZXMgb2Ygc3ByaXRlcy5cclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zY2VuZXJ5L2lzc3Vlcy85OTAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cclxuICovXHJcblxyXG5pbXBvcnQgQm91bmRzMiBmcm9tICcuLi8uLi8uLi9kb3QvanMvQm91bmRzMi5qcyc7XHJcbmltcG9ydCBTdHJpY3RPbWl0IGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9TdHJpY3RPbWl0LmpzJztcclxuaW1wb3J0IE1hdHJpeDMgZnJvbSAnLi4vLi4vLi4vZG90L2pzL01hdHJpeDMuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvb3B0aW9uaXplLmpzJztcclxuaW1wb3J0IHsgQ2FudmFzQ29udGV4dFdyYXBwZXIsIENhbnZhc1NlbGZEcmF3YWJsZSwgSW5zdGFuY2UsIE5vZGUsIE5vZGVPcHRpb25zLCBSZW5kZXJlciwgc2NlbmVyeSwgU3ByaXRlLCBTcHJpdGVJbnN0YW5jZSwgU3ByaXRlc0NhbnZhc0RyYXdhYmxlLCBTcHJpdGVzV2ViR0xEcmF3YWJsZSwgV2ViR0xTZWxmRHJhd2FibGUgfSBmcm9tICcuLi9pbXBvcnRzLmpzJztcclxuXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSB7XHJcbiAgLy8gUHJvdmlkZSBhIGZpeGVkIHNldCBvZiBTcHJpdGUgb2JqZWN0cyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhpcyBub2RlLiBDdXJyZW50bHksIGl0IGNhbm5vdCBiZSBtb2RpZmllZCBhZnRlclxyXG4gIC8vIGNvbnN0cnVjdGlvbiBmb3Igc2ltcGxpY2l0eSBvZiB0aGUgaW1wbGVtZW50YXRpb24uXHJcbiAgc3ByaXRlcz86IFNwcml0ZVtdO1xyXG5cclxuICAvLyBBIHJlZmVyZW5jZSB0byBhbiBBcnJheSBvZiBpbnN0YW5jZXMuIFRoaXMgYXJyYXkgY2FuIGJlIChhbmQgc2hvdWxkIGJlKVxyXG4gIC8vIG1hbmlwdWxhdGVkIHRvIGFkanVzdCB0aGUgZGlzcGxheWVkIGluc3RhbmNlcyAodGhlaXIgc3ByaXRlcy90cmFuc2Zvcm1zL2V0Yy4pLiBBZnRlciB0aGlzIGhhcyBiZWVuIGFkanVzdGVkLFxyXG4gIC8vIGludmFsaWRhdGVQYWludCgpIHNob3VsZCBiZSBjYWxsZWQgb24gdGhlIFNwcml0ZXMgbm9kZS5cclxuICBzcHJpdGVJbnN0YW5jZXM/OiBTcHJpdGVJbnN0YW5jZVtdO1xyXG5cclxuICAvLyBXaGV0aGVyIGluZGl2aWR1YWwgc3ByaXRlcyB3aWxsIGJlIGhpdC10ZXN0ZWQgdG8gZGV0ZXJtaW5lIHdoYXQgaXMgYSBjb250YWluZWQgcG9pbnQgKGZvciBoaXRcclxuICAvLyB0ZXN0aW5nLCBldGMuKS4gSWYgZmFsc2UsIHRoZSBjYW52YXNCb3VuZHMgd2lsbCBiZSB1c2VkIGZvciBoaXQgdGVzdGluZy5cclxuICBoaXRUZXN0U3ByaXRlcz86IGJvb2xlYW47XHJcblxyXG4gIGNhbnZhc0JvdW5kcz86IEJvdW5kczI7XHJcbn07XHJcblxyXG4vLyBXZSBkb24ndCBzcGVjaWZ5IGEgZGVmYXVsdCBmb3IgY2FudmFzQm91bmRzIG9uIHB1cnBvc2UsIHNvIHdlJ2xsIG9taXQgdGhpcyBmcm9tIHRoZSBvcHRpb25pemUgdHlwZSBwYXJhbWV0ZXIuXHJcbnR5cGUgU3BlY2lmaWVkU2VsZk9wdGlvbnMgPSBTdHJpY3RPbWl0PFNlbGZPcHRpb25zLCAnY2FudmFzQm91bmRzJz47XHJcblxyXG5leHBvcnQgdHlwZSBTcHJpdGVzT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgTm9kZU9wdGlvbnM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGVzIGV4dGVuZHMgTm9kZSB7XHJcblxyXG4gIHByaXZhdGUgX3Nwcml0ZXM6IFNwcml0ZVtdO1xyXG4gIHByaXZhdGUgX3Nwcml0ZUluc3RhbmNlczogU3ByaXRlSW5zdGFuY2VbXTtcclxuICBwcml2YXRlIF9oaXRUZXN0U3ByaXRlczogYm9vbGVhbjtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBwcm92aWRlZE9wdGlvbnM/OiBTcHJpdGVzT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPFNwcml0ZXNPcHRpb25zLCBTcGVjaWZpZWRTZWxmT3B0aW9ucywgTm9kZU9wdGlvbnM+KCkoIHtcclxuICAgICAgc3ByaXRlczogW10sXHJcbiAgICAgIHNwcml0ZUluc3RhbmNlczogW10sXHJcbiAgICAgIGhpdFRlc3RTcHJpdGVzOiBmYWxzZSxcclxuXHJcbiAgICAgIC8vIFNldHMgdGhlIG5vZGUncyBkZWZhdWx0IHJlbmRlcmVyIHRvIFdlYkdMIChhcyB3ZSdsbCBnZW5lcmFsbHkgd2FudCB0aGF0IHdoZW4gdXNpbmcgdGhpcyB0eXBlKVxyXG4gICAgICByZW5kZXJlcjogJ3dlYmdsJ1xyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9zcHJpdGVzID0gb3B0aW9ucy5zcHJpdGVzO1xyXG4gICAgdGhpcy5fc3ByaXRlSW5zdGFuY2VzID0gb3B0aW9ucy5zcHJpdGVJbnN0YW5jZXM7XHJcbiAgICB0aGlzLl9oaXRUZXN0U3ByaXRlcyA9IG9wdGlvbnMuaGl0VGVzdFNwcml0ZXM7XHJcblxyXG4gICAgLy8gV2ViR0wgYW5kIENhbnZhcyBhcmUgc3VwcG9ydGVkLlxyXG4gICAgdGhpcy5zZXRSZW5kZXJlckJpdG1hc2soIFJlbmRlcmVyLmJpdG1hc2tDYW52YXMgfCBSZW5kZXJlci5iaXRtYXNrV2ViR0wgKTtcclxuXHJcbiAgICB0aGlzLm11dGF0ZSggb3B0aW9ucyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgYm91bmRzIHRoYXQgYXJlIHVzZWQgZm9yIGxheW91dC9yZXBhaW50aW5nLlxyXG4gICAqXHJcbiAgICogVGhlc2UgYm91bmRzIHNob3VsZCBhbHdheXMgY292ZXIgYXQgbGVhc3QgdGhlIGFyZWEgd2hlcmUgdGhlIFNwcml0ZXMgd2lsbCBkcmF3IGluLiBJZiB0aGlzIGlzIHZpb2xhdGVkLCB0aGlzXHJcbiAgICogbm9kZSBtYXkgYmUgcGFydGlhbGx5IG9yIGNvbXBsZXRlbHkgaW52aXNpYmxlIGluIFNjZW5lcnkncyBvdXRwdXQuXHJcbiAgICovXHJcbiAgcHVibGljIHNldENhbnZhc0JvdW5kcyggc2VsZkJvdW5kczogQm91bmRzMiApOiB2b2lkIHtcclxuICAgIHRoaXMuaW52YWxpZGF0ZVNlbGYoIHNlbGZCb3VuZHMgKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXQgY2FudmFzQm91bmRzKCB2YWx1ZTogQm91bmRzMiApIHsgdGhpcy5zZXRDYW52YXNCb3VuZHMoIHZhbHVlICk7IH1cclxuXHJcbiAgcHVibGljIGdldCBjYW52YXNCb3VuZHMoKTogQm91bmRzMiB7IHJldHVybiB0aGlzLmdldENhbnZhc0JvdW5kcygpOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHByZXZpb3VzbHktc2V0IGNhbnZhc0JvdW5kcywgb3IgQm91bmRzMi5OT1RISU5HIGlmIGl0IGhhcyBub3QgYmVlbiBzZXQgeWV0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRDYW52YXNCb3VuZHMoKTogQm91bmRzMiB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRTZWxmQm91bmRzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmF3cyB0aGUgY3VycmVudCBOb2RlJ3Mgc2VsZiByZXByZXNlbnRhdGlvbiwgYXNzdW1pbmcgdGhlIHdyYXBwZXIncyBDYW52YXMgY29udGV4dCBpcyBhbHJlYWR5IGluIHRoZSBsb2NhbFxyXG4gICAqIGNvb3JkaW5hdGUgZnJhbWUgb2YgdGhpcyBub2RlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHdyYXBwZXJcclxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhbHJlYWR5IGFwcGxpZWQgdG8gdGhlIGNvbnRleHQuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGNhbnZhc1BhaW50U2VsZiggd3JhcHBlcjogQ2FudmFzQ29udGV4dFdyYXBwZXIsIG1hdHJpeDogTWF0cml4MyApOiB2b2lkIHtcclxuICAgIFNwcml0ZXNDYW52YXNEcmF3YWJsZS5wcm90b3R5cGUucGFpbnRDYW52YXMoIHdyYXBwZXIsIHRoaXMsIG1hdHJpeCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIENhbnZhcyBkcmF3YWJsZSBmb3IgdGhpcyBTcHJpdGVzIG5vZGUuIChzY2VuZXJ5LWludGVybmFsKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gSW4gdGhlIGJpdG1hc2sgZm9ybWF0IHNwZWNpZmllZCBieSBSZW5kZXJlciwgd2hpY2ggbWF5IGNvbnRhaW4gYWRkaXRpb25hbCBiaXQgZmxhZ3MuXHJcbiAgICogQHBhcmFtIGluc3RhbmNlIC0gSW5zdGFuY2Ugb2JqZWN0IHRoYXQgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggdGhlIGRyYXdhYmxlXHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIGNyZWF0ZUNhbnZhc0RyYXdhYmxlKCByZW5kZXJlcjogbnVtYmVyLCBpbnN0YW5jZTogSW5zdGFuY2UgKTogQ2FudmFzU2VsZkRyYXdhYmxlIHtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgUG9vbGluZ1xyXG4gICAgcmV0dXJuIFNwcml0ZXNDYW52YXNEcmF3YWJsZS5jcmVhdGVGcm9tUG9vbCggcmVuZGVyZXIsIGluc3RhbmNlICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgV2ViR0wgZHJhd2FibGUgZm9yIHRoaXMgSW1hZ2UuIChzY2VuZXJ5LWludGVybmFsKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gSW4gdGhlIGJpdG1hc2sgZm9ybWF0IHNwZWNpZmllZCBieSBSZW5kZXJlciwgd2hpY2ggbWF5IGNvbnRhaW4gYWRkaXRpb25hbCBiaXQgZmxhZ3MuXHJcbiAgICogQHBhcmFtIGluc3RhbmNlIC0gSW5zdGFuY2Ugb2JqZWN0IHRoYXQgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggdGhlIGRyYXdhYmxlXHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIGNyZWF0ZVdlYkdMRHJhd2FibGUoIHJlbmRlcmVyOiBudW1iZXIsIGluc3RhbmNlOiBJbnN0YW5jZSApOiBXZWJHTFNlbGZEcmF3YWJsZSB7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBvb2xpbmdcclxuICAgIHJldHVybiBTcHJpdGVzV2ViR0xEcmF3YWJsZS5jcmVhdGVGcm9tUG9vbCggcmVuZGVyZXIsIGluc3RhbmNlICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwb2ludCBpcyBcImluc2lkZVwiIChjb250YWluZWQpIGluIHRoaXMgTm9kZSdzIHNlbGYgY29udGVudCwgb3IgXCJvdXRzaWRlXCIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gcG9pbnQgLSBDb25zaWRlcmVkIHRvIGJlIGluIHRoZSBsb2NhbCBjb29yZGluYXRlIGZyYW1lXHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIGNvbnRhaW5zUG9pbnRTZWxmKCBwb2ludDogVmVjdG9yMiApOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGluQm91bmRzID0gc3VwZXIuY29udGFpbnNQb2ludFNlbGYoIHBvaW50ICk7XHJcbiAgICBpZiAoICFpbkJvdW5kcyApIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICggdGhpcy5faGl0VGVzdFNwcml0ZXMgKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuZ2V0U3ByaXRlSW5zdGFuY2VGcm9tUG9pbnQoIHBvaW50ICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kcyB3aGljaCBzcHJpdGUgaW5zdGFuY2UgaXMgb24gdG9wIHVuZGVyIGEgY2VydGFpbiBwb2ludCAob3IgbnVsbCBpZiBub25lIGFyZSkuXHJcbiAgICovXHJcbiAgcHVibGljIGdldFNwcml0ZUluc3RhbmNlRnJvbVBvaW50KCBwb2ludDogVmVjdG9yMiApOiBTcHJpdGVJbnN0YW5jZSB8IG51bGwge1xyXG4gICAgZm9yICggbGV0IGkgPSB0aGlzLl9zcHJpdGVJbnN0YW5jZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XHJcbiAgICAgIGlmICggdGhpcy5fc3ByaXRlSW5zdGFuY2VzWyBpIF0uY29udGFpbnNQb2ludCggcG9pbnQgKSApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3ByaXRlSW5zdGFuY2VzWyBpIF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIFNoYXBlIHRoYXQgcmVwcmVzZW50cyB0aGUgYXJlYSBjb3ZlcmVkIGJ5IGNvbnRhaW5zUG9pbnRTZWxmLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBnZXRTZWxmU2hhcGUoKTogU2hhcGUge1xyXG4gICAgaWYgKCB0aGlzLl9oaXRUZXN0U3ByaXRlcyApIHtcclxuICAgICAgcmV0dXJuIFNoYXBlLnVuaW9uKCB0aGlzLl9zcHJpdGVJbnN0YW5jZXMubWFwKCBpbnN0YW5jZSA9PiBpbnN0YW5jZS5nZXRTaGFwZSgpICkgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gU2hhcGUuYm91bmRzKCB0aGlzLnNlbGZCb3VuZHMgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhpcyBOb2RlIGl0c2VsZiBpcyBwYWludGVkIChkaXNwbGF5cyBzb21ldGhpbmcgaXRzZWxmKS5cclxuICAgKi9cclxuICBwdWJsaWMgb3ZlcnJpZGUgaXNQYWludGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgLy8gQWx3YXlzIHRydWUgZm9yIFNwcml0ZXMgbm9kZXNcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoaXMgbm9kZSBuZWVkcyB0byBiZSByZXBhaW50ZWQuIFdoZW4gbm90IGNhbGxlZCwgU2NlbmVyeSBhc3N1bWVzIHRoYXQgdGhpcyBub2RlIGRvZXNcclxuICAgKiBOT1QgbmVlZCB0byBiZSByZXBhaW50ZWQgKGFsdGhvdWdoIFNjZW5lcnkgbWF5IHJlcGFpbnQgaXQgZHVlIHRvIG90aGVyIG5vZGVzIG5lZWRpbmcgdG8gYmUgcmVwYWludGVkKS5cclxuICAgKlxyXG4gICAqIFRoaXMgc2V0cyBhIFwiZGlydHlcIiBmbGFnLCBzbyB0aGF0IGl0IHdpbGwgYmUgcmVwYWludGVkIHRoZSBuZXh0IHRpbWUgaXQgd291bGQgYmUgZGlzcGxheWVkLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBpbnZhbGlkYXRlUGFpbnQoKTogdm9pZCB7XHJcbiAgICBjb25zdCBzdGF0ZUxlbiA9IHRoaXMuX2RyYXdhYmxlcy5sZW5ndGg7XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBzdGF0ZUxlbjsgaSsrICkge1xyXG4gICAgICB0aGlzLl9kcmF3YWJsZXNbIGkgXS5tYXJrRGlydHkoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBvdmVycmlkZSBtdXRhdGUoIG9wdGlvbnM/OiBTcHJpdGVzT3B0aW9ucyApOiB0aGlzIHtcclxuICAgIHJldHVybiBzdXBlci5tdXRhdGUoIG9wdGlvbnMgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB7QXJyYXkuPHN0cmluZz59IC0gU3RyaW5nIGtleXMgZm9yIGFsbCB0aGUgYWxsb3dlZCBvcHRpb25zIHRoYXQgd2lsbCBiZSBzZXQgYnkgbm9kZS5tdXRhdGUoIG9wdGlvbnMgKSwgaW4gdGhlXHJcbiAqIG9yZGVyIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgaW4uXHJcbiAqXHJcbiAqIE5PVEU6IFNlZSBOb2RlJ3MgX211dGF0b3JLZXlzIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRoaXMgb3BlcmF0ZXMsIGFuZCBwb3RlbnRpYWwgc3BlY2lhbFxyXG4gKiAgICAgICBjYXNlcyB0aGF0IG1heSBhcHBseS5cclxuICovXHJcblNwcml0ZXMucHJvdG90eXBlLl9tdXRhdG9yS2V5cyA9IFsgJ2NhbnZhc0JvdW5kcycgXS5jb25jYXQoIE5vZGUucHJvdG90eXBlLl9tdXRhdG9yS2V5cyApO1xyXG5cclxuc2NlbmVyeS5yZWdpc3RlciggJ1Nwcml0ZXMnLCBTcHJpdGVzICk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU1BLFNBQVNBLEtBQUssUUFBUSw2QkFBNkI7QUFDbkQsT0FBT0MsU0FBUyxNQUFNLG9DQUFvQztBQUMxRCxTQUE2REMsSUFBSSxFQUFlQyxRQUFRLEVBQUVDLE9BQU8sRUFBMEJDLHFCQUFxQixFQUFFQyxvQkFBb0IsUUFBMkIsZUFBZTs7QUFtQmhOOztBQUtBLGVBQWUsTUFBTUMsT0FBTyxTQUFTTCxJQUFJLENBQUM7RUFNakNNLFdBQVdBLENBQUVDLGVBQWdDLEVBQUc7SUFFckQsTUFBTUMsT0FBTyxHQUFHVCxTQUFTLENBQW9ELENBQUMsQ0FBRTtNQUM5RVUsT0FBTyxFQUFFLEVBQUU7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