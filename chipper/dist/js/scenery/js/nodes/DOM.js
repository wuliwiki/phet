// Copyright 2013-2023, University of Colorado Boulder

/**
 * Displays a DOM element directly in a node, so that it can be positioned/transformed properly, and bounds are handled properly in Scenery.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import Bounds2 from '../../../dot/js/Bounds2.js';
import extendDefined from '../../../phet-core/js/extendDefined.js';
import { DOMDrawable, Node, Renderer, scenery } from '../imports.js';
const DOM_OPTION_KEYS = ['element',
// {HTMLElement} - Sets the element, see setElement() for more documentation
'preventTransform' // {boolean} - Sets whether Scenery is allowed to transform the element. see setPreventTransform() for docs
];

// User-defined type guard
const isJQueryElement = element => !!(element && element.jquery);
export default class DOM extends Node {
  // Container div that will have our main element as a child (so we can position and mutate it).
  // scenery-internal
  // jQuery selection so that we can properly determine size information
  // Flag that indicates whether we are updating/invalidating ourself due to changes to the DOM element. The flag is
  // needed so that updates to our element that we make in the update/invalidate section doesn't trigger an infinite
  // loop with another update.
  // Flag that when true won't let Scenery apply a transform directly (the client will take care of that).
  /**
   * @param element - The HTML element, or a jQuery selector result.
   * @param [options] - DOM-specific options are documented in DOM_OPTION_KEYS above, and can be provided
   *                             along-side options for Node
   */
  constructor(element, options) {
    assert && assert(options === undefined || Object.getPrototypeOf(options) === Object.prototype, 'Extra prototype on Node options object is a code smell');
    assert && assert(element instanceof window.Element || element.jquery, 'DOM nodes need to be passed an HTML/DOM element or a jQuery selection like $( ... )'); // eslint-disable-line no-simple-type-checking-assertions

    // unwrap from jQuery if that is passed in, for consistency
    if (isJQueryElement(element)) {
      element = element[0];
      assert && assert(element instanceof window.Element); // eslint-disable-line no-simple-type-checking-assertions
    }

    super();
    this._container = document.createElement('div');
    this._$container = $(this._container);
    this._$container.css('position', 'absolute');
    this._$container.css('left', 0);
    this._$container.css('top', 0);
    this.invalidateDOMLock = false;
    this._preventTransform = false;

    // Have mutate() call setElement() in the proper order
    options = extendDefined({
      element: element
    }, options);

    // will set the element after initializing
    this.mutate(options);

    // Only renderer supported, no need to dynamically compute
    this.setRendererBitmask(Renderer.bitmaskDOM);
  }

  /**
   * Computes the bounds of our current DOM element (using jQuery, as replacing this with other things seems a bit
   * bug-prone and has caused issues in the past).
   *
   * The dom element needs to be attached to the DOM tree in order for this to work.
   *
   * Alternative getBoundingClientRect explored, but did not seem sufficient (possibly due to CSS transforms)?
   */
  calculateDOMBounds() {
    const $element = $(this._element);
    return new Bounds2(0, 0, $element.width(), $element.height());
  }

  /**
   * Triggers recomputation of our DOM element's bounds.
   *
   * This should be called after the DOM element's bounds may have changed, to properly update the bounding box
   * in Scenery.
   */
  invalidateDOM() {
    // prevent this from being executed as a side-effect from inside one of its own calls
    if (this.invalidateDOMLock) {
      return;
    }
    this.invalidateDOMLock = true;

    // we will place ourselves in a temporary container to get our real desired bounds
    const temporaryContainer = document.createElement('div');
    $(temporaryContainer).css({
      display: 'hidden',
      padding: '0 !important',
      margin: '0 !important',
      position: 'absolute',
      left: 0,
      top: 0,
      width: 65535,
      height: 65535
    });

    // move to the temporary container
    this._container.removeChild(this._element);
    temporaryContainer.appendChild(this._element);
    document.body.appendChild(temporaryContainer);

    // bounds computation and resize our container to fit precisely
    const selfBounds = this.calculateDOMBounds();
    this.invalidateSelf(selfBounds);
    this._$container.width(selfBounds.getWidth());
    this._$container.height(selfBounds.getHeight());

    // move back to the main container
    document.body.removeChild(temporaryContainer);
    temporaryContainer.removeChild(this._element);
    this._container.appendChild(this._element);

    // unlock
    this.invalidateDOMLock = false;
  }

  /**
   * Creates a DOM drawable for this DOM node. (scenery-internal)
   *
   * @param renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
   * @param instance - Instance object that will be associated with the drawable
   */
  createDOMDrawable(renderer, instance) {
    // @ts-expect-error Poolable
    return DOMDrawable.createFromPool(renderer, instance);
  }

  /**
   * Whether this Node itself is painted (displays something itself).
   */
  isPainted() {
    // Always true for DOM nodes
    return true;
  }

  /**
   * Changes the DOM element of this DOM node to another element.
   */
  setElement(element) {
    assert && assert(!this._element, 'We should only ever attach one DOMElement to a DOM node');
    if (this._element !== element) {
      if (this._element) {
        this._container.removeChild(this._element);
      }
      this._element = element;
      this._container.appendChild(this._element);
      this.invalidateDOM();
    }
    return this; // allow chaining
  }

  set element(value) {
    this.setElement(value);
  }
  get element() {
    return this.getElement();
  }

  /**
   * Returns the DOM element being displayed by this DOM node.
   */
  getElement() {
    return this._element;
  }

  /**
   * Sets the value of the preventTransform flag.
   *
   * When the preventTransform flag is set to true, Scenery will not reposition (CSS transform) the DOM element, but
   * instead it will be at the upper-left (0,0) of the Scenery Display. The client will be responsible for sizing or
   * positioning this element instead.
   */
  setPreventTransform(preventTransform) {
    if (this._preventTransform !== preventTransform) {
      this._preventTransform = preventTransform;
    }
  }
  set preventTransform(value) {
    this.setPreventTransform(value);
  }
  get preventTransform() {
    return this.isTransformPrevented();
  }

  /**
   * Returns the value of the preventTransform flag.
   *
   * See the setPreventTransform documentation for more information on the flag.
   */
  isTransformPrevented() {
    return this._preventTransform;
  }
  mutate(options) {
    return super.mutate(options);
  }
}

/**
 * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
 * order they will be evaluated in.
 *
 * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
 *       cases that may apply.
 */
DOM.prototype._mutatorKeys = DOM_OPTION_KEYS.concat(Node.prototype._mutatorKeys);
scenery.register('DOM', DOM);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiZXh0ZW5kRGVmaW5lZCIsIkRPTURyYXdhYmxlIiwiTm9kZSIsIlJlbmRlcmVyIiwic2NlbmVyeSIsIkRPTV9PUFRJT05fS0VZUyIsImlzSlF1ZXJ5RWxlbWVudCIsImVsZW1lbnQiLCJqcXVlcnkiLCJET00iLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJhc3NlcnQiLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsIndpbmRvdyIsIkVsZW1lbnQiLCJfY29udGFpbmVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiXyRjb250YWluZXIiLCIkIiwiY3NzIiwiaW52YWxpZGF0ZURPTUxvY2siLCJfcHJldmVudFRyYW5zZm9ybSIsIm11dGF0ZSIsInNldFJlbmRlcmVyQml0bWFzayIsImJpdG1hc2tET00iLCJjYWxjdWxhdGVET01Cb3VuZHMiLCIkZWxlbWVudCIsIl9lbGVtZW50Iiwid2lkdGgiLCJoZWlnaHQiLCJpbnZhbGlkYXRlRE9NIiwidGVtcG9yYXJ5Q29udGFpbmVyIiwiZGlzcGxheSIsInBhZGRpbmciLCJtYXJnaW4iLCJwb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwiYm9keSIsInNlbGZCb3VuZHMiLCJpbnZhbGlkYXRlU2VsZiIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwiY3JlYXRlRE9NRHJhd2FibGUiLCJyZW5kZXJlciIsImluc3RhbmNlIiwiY3JlYXRlRnJvbVBvb2wiLCJpc1BhaW50ZWQiLCJzZXRFbGVtZW50IiwidmFsdWUiLCJnZXRFbGVtZW50Iiwic2V0UHJldmVudFRyYW5zZm9ybSIsInByZXZlbnRUcmFuc2Zvcm0iLCJpc1RyYW5zZm9ybVByZXZlbnRlZCIsIl9tdXRhdG9yS2V5cyIsImNvbmNhdCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRE9NLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDEzLTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIERpc3BsYXlzIGEgRE9NIGVsZW1lbnQgZGlyZWN0bHkgaW4gYSBub2RlLCBzbyB0aGF0IGl0IGNhbiBiZSBwb3NpdGlvbmVkL3RyYW5zZm9ybWVkIHByb3Blcmx5LCBhbmQgYm91bmRzIGFyZSBoYW5kbGVkIHByb3Blcmx5IGluIFNjZW5lcnkuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cclxuICovXHJcblxyXG5pbXBvcnQgQm91bmRzMiBmcm9tICcuLi8uLi8uLi9kb3QvanMvQm91bmRzMi5qcyc7XHJcbmltcG9ydCBleHRlbmREZWZpbmVkIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9leHRlbmREZWZpbmVkLmpzJztcclxuaW1wb3J0IHsgRE9NRHJhd2FibGUsIERPTVNlbGZEcmF3YWJsZSwgSW5zdGFuY2UsIE5vZGUsIE5vZGVPcHRpb25zLCBSZW5kZXJlciwgc2NlbmVyeSB9IGZyb20gJy4uL2ltcG9ydHMuanMnO1xyXG5cclxuY29uc3QgRE9NX09QVElPTl9LRVlTID0gW1xyXG4gICdlbGVtZW50JywgLy8ge0hUTUxFbGVtZW50fSAtIFNldHMgdGhlIGVsZW1lbnQsIHNlZSBzZXRFbGVtZW50KCkgZm9yIG1vcmUgZG9jdW1lbnRhdGlvblxyXG4gICdwcmV2ZW50VHJhbnNmb3JtJyAvLyB7Ym9vbGVhbn0gLSBTZXRzIHdoZXRoZXIgU2NlbmVyeSBpcyBhbGxvd2VkIHRvIHRyYW5zZm9ybSB0aGUgZWxlbWVudC4gc2VlIHNldFByZXZlbnRUcmFuc2Zvcm0oKSBmb3IgZG9jc1xyXG5dO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuICBlbGVtZW50PzogSFRNTEVsZW1lbnQ7XHJcbiAgcHJldmVudFRyYW5zZm9ybT86IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBET01PcHRpb25zID0gU2VsZk9wdGlvbnMgJiBOb2RlT3B0aW9ucztcclxuXHJcbi8vIFVzZXItZGVmaW5lZCB0eXBlIGd1YXJkXHJcbmNvbnN0IGlzSlF1ZXJ5RWxlbWVudCA9ICggZWxlbWVudDogRWxlbWVudCB8IEpRdWVyeSApOiBlbGVtZW50IGlzIEpRdWVyeSA9PiAhISggZWxlbWVudCAmJiAoIGVsZW1lbnQgYXMgSlF1ZXJ5ICkuanF1ZXJ5ICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET00gZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgcHJpdmF0ZSBfZWxlbWVudCE6IEhUTUxFbGVtZW50O1xyXG5cclxuICAvLyBDb250YWluZXIgZGl2IHRoYXQgd2lsbCBoYXZlIG91ciBtYWluIGVsZW1lbnQgYXMgYSBjaGlsZCAoc28gd2UgY2FuIHBvc2l0aW9uIGFuZCBtdXRhdGUgaXQpLlxyXG4gIHB1YmxpYyByZWFkb25seSBfY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudDsgLy8gc2NlbmVyeS1pbnRlcm5hbFxyXG5cclxuICAvLyBqUXVlcnkgc2VsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIHByb3Blcmx5IGRldGVybWluZSBzaXplIGluZm9ybWF0aW9uXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfJGNvbnRhaW5lcjogSlF1ZXJ5PEhUTUxEaXZFbGVtZW50PjtcclxuXHJcbiAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHdlIGFyZSB1cGRhdGluZy9pbnZhbGlkYXRpbmcgb3Vyc2VsZiBkdWUgdG8gY2hhbmdlcyB0byB0aGUgRE9NIGVsZW1lbnQuIFRoZSBmbGFnIGlzXHJcbiAgLy8gbmVlZGVkIHNvIHRoYXQgdXBkYXRlcyB0byBvdXIgZWxlbWVudCB0aGF0IHdlIG1ha2UgaW4gdGhlIHVwZGF0ZS9pbnZhbGlkYXRlIHNlY3Rpb24gZG9lc24ndCB0cmlnZ2VyIGFuIGluZmluaXRlXHJcbiAgLy8gbG9vcCB3aXRoIGFub3RoZXIgdXBkYXRlLlxyXG4gIHByaXZhdGUgaW52YWxpZGF0ZURPTUxvY2s6IGJvb2xlYW47XHJcblxyXG4gIC8vIEZsYWcgdGhhdCB3aGVuIHRydWUgd29uJ3QgbGV0IFNjZW5lcnkgYXBwbHkgYSB0cmFuc2Zvcm0gZGlyZWN0bHkgKHRoZSBjbGllbnQgd2lsbCB0YWtlIGNhcmUgb2YgdGhhdCkuXHJcbiAgcHJpdmF0ZSBfcHJldmVudFRyYW5zZm9ybTogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgSFRNTCBlbGVtZW50LCBvciBhIGpRdWVyeSBzZWxlY3RvciByZXN1bHQuXHJcbiAgICogQHBhcmFtIFtvcHRpb25zXSAtIERPTS1zcGVjaWZpYyBvcHRpb25zIGFyZSBkb2N1bWVudGVkIGluIERPTV9PUFRJT05fS0VZUyBhYm92ZSwgYW5kIGNhbiBiZSBwcm92aWRlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbG9uZy1zaWRlIG9wdGlvbnMgZm9yIE5vZGVcclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIGVsZW1lbnQ6IEVsZW1lbnQgfCBKUXVlcnksIG9wdGlvbnM/OiBET01PcHRpb25zICkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggb3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZiggb3B0aW9ucyApID09PSBPYmplY3QucHJvdG90eXBlLFxyXG4gICAgICAnRXh0cmEgcHJvdG90eXBlIG9uIE5vZGUgb3B0aW9ucyBvYmplY3QgaXMgYSBjb2RlIHNtZWxsJyApO1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGVsZW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRWxlbWVudCB8fCBlbGVtZW50LmpxdWVyeSwgJ0RPTSBub2RlcyBuZWVkIHRvIGJlIHBhc3NlZCBhbiBIVE1ML0RPTSBlbGVtZW50IG9yIGEgalF1ZXJ5IHNlbGVjdGlvbiBsaWtlICQoIC4uLiApJyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNpbXBsZS10eXBlLWNoZWNraW5nLWFzc2VydGlvbnNcclxuXHJcbiAgICAvLyB1bndyYXAgZnJvbSBqUXVlcnkgaWYgdGhhdCBpcyBwYXNzZWQgaW4sIGZvciBjb25zaXN0ZW5jeVxyXG4gICAgaWYgKCBpc0pRdWVyeUVsZW1lbnQoIGVsZW1lbnQgKSApIHtcclxuICAgICAgZWxlbWVudCA9IGVsZW1lbnRbIDAgXTtcclxuXHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIGVsZW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRWxlbWVudCApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNpbXBsZS10eXBlLWNoZWNraW5nLWFzc2VydGlvbnNcclxuICAgIH1cclxuXHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XHJcblxyXG4gICAgdGhpcy5fJGNvbnRhaW5lciA9ICQoIHRoaXMuX2NvbnRhaW5lciApO1xyXG4gICAgdGhpcy5fJGNvbnRhaW5lci5jc3MoICdwb3NpdGlvbicsICdhYnNvbHV0ZScgKTtcclxuICAgIHRoaXMuXyRjb250YWluZXIuY3NzKCAnbGVmdCcsIDAgKTtcclxuICAgIHRoaXMuXyRjb250YWluZXIuY3NzKCAndG9wJywgMCApO1xyXG5cclxuICAgIHRoaXMuaW52YWxpZGF0ZURPTUxvY2sgPSBmYWxzZTtcclxuICAgIHRoaXMuX3ByZXZlbnRUcmFuc2Zvcm0gPSBmYWxzZTtcclxuXHJcbiAgICAvLyBIYXZlIG11dGF0ZSgpIGNhbGwgc2V0RWxlbWVudCgpIGluIHRoZSBwcm9wZXIgb3JkZXJcclxuICAgIG9wdGlvbnMgPSBleHRlbmREZWZpbmVkKCB7XHJcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyB3aWxsIHNldCB0aGUgZWxlbWVudCBhZnRlciBpbml0aWFsaXppbmdcclxuICAgIHRoaXMubXV0YXRlKCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gT25seSByZW5kZXJlciBzdXBwb3J0ZWQsIG5vIG5lZWQgdG8gZHluYW1pY2FsbHkgY29tcHV0ZVxyXG4gICAgdGhpcy5zZXRSZW5kZXJlckJpdG1hc2soIFJlbmRlcmVyLmJpdG1hc2tET00gKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlcyB0aGUgYm91bmRzIG9mIG91ciBjdXJyZW50IERPTSBlbGVtZW50ICh1c2luZyBqUXVlcnksIGFzIHJlcGxhY2luZyB0aGlzIHdpdGggb3RoZXIgdGhpbmdzIHNlZW1zIGEgYml0XHJcbiAgICogYnVnLXByb25lIGFuZCBoYXMgY2F1c2VkIGlzc3VlcyBpbiB0aGUgcGFzdCkuXHJcbiAgICpcclxuICAgKiBUaGUgZG9tIGVsZW1lbnQgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIERPTSB0cmVlIGluIG9yZGVyIGZvciB0aGlzIHRvIHdvcmsuXHJcbiAgICpcclxuICAgKiBBbHRlcm5hdGl2ZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZXhwbG9yZWQsIGJ1dCBkaWQgbm90IHNlZW0gc3VmZmljaWVudCAocG9zc2libHkgZHVlIHRvIENTUyB0cmFuc2Zvcm1zKT9cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgY2FsY3VsYXRlRE9NQm91bmRzKCk6IEJvdW5kczIge1xyXG4gICAgY29uc3QgJGVsZW1lbnQgPSAkKCB0aGlzLl9lbGVtZW50ICk7XHJcbiAgICByZXR1cm4gbmV3IEJvdW5kczIoIDAsIDAsICRlbGVtZW50LndpZHRoKCkhLCAkZWxlbWVudC5oZWlnaHQoKSEgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJzIHJlY29tcHV0YXRpb24gb2Ygb3VyIERPTSBlbGVtZW50J3MgYm91bmRzLlxyXG4gICAqXHJcbiAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoZSBET00gZWxlbWVudCdzIGJvdW5kcyBtYXkgaGF2ZSBjaGFuZ2VkLCB0byBwcm9wZXJseSB1cGRhdGUgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAqIGluIFNjZW5lcnkuXHJcbiAgICovXHJcbiAgcHVibGljIGludmFsaWRhdGVET00oKTogdm9pZCB7XHJcbiAgICAvLyBwcmV2ZW50IHRoaXMgZnJvbSBiZWluZyBleGVjdXRlZCBhcyBhIHNpZGUtZWZmZWN0IGZyb20gaW5zaWRlIG9uZSBvZiBpdHMgb3duIGNhbGxzXHJcbiAgICBpZiAoIHRoaXMuaW52YWxpZGF0ZURPTUxvY2sgKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuaW52YWxpZGF0ZURPTUxvY2sgPSB0cnVlO1xyXG5cclxuICAgIC8vIHdlIHdpbGwgcGxhY2Ugb3Vyc2VsdmVzIGluIGEgdGVtcG9yYXJ5IGNvbnRhaW5lciB0byBnZXQgb3VyIHJlYWwgZGVzaXJlZCBib3VuZHNcclxuICAgIGNvbnN0IHRlbXBvcmFyeUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XHJcbiAgICAkKCB0ZW1wb3JhcnlDb250YWluZXIgKS5jc3MoIHtcclxuICAgICAgZGlzcGxheTogJ2hpZGRlbicsXHJcbiAgICAgIHBhZGRpbmc6ICcwICFpbXBvcnRhbnQnLFxyXG4gICAgICBtYXJnaW46ICcwICFpbXBvcnRhbnQnLFxyXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgbGVmdDogMCxcclxuICAgICAgdG9wOiAwLFxyXG4gICAgICB3aWR0aDogNjU1MzUsXHJcbiAgICAgIGhlaWdodDogNjU1MzVcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBtb3ZlIHRvIHRoZSB0ZW1wb3JhcnkgY29udGFpbmVyXHJcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQoIHRoaXMuX2VsZW1lbnQgKTtcclxuICAgIHRlbXBvcmFyeUNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy5fZWxlbWVudCApO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggdGVtcG9yYXJ5Q29udGFpbmVyICk7XHJcblxyXG4gICAgLy8gYm91bmRzIGNvbXB1dGF0aW9uIGFuZCByZXNpemUgb3VyIGNvbnRhaW5lciB0byBmaXQgcHJlY2lzZWx5XHJcbiAgICBjb25zdCBzZWxmQm91bmRzID0gdGhpcy5jYWxjdWxhdGVET01Cb3VuZHMoKTtcclxuICAgIHRoaXMuaW52YWxpZGF0ZVNlbGYoIHNlbGZCb3VuZHMgKTtcclxuICAgIHRoaXMuXyRjb250YWluZXIud2lkdGgoIHNlbGZCb3VuZHMuZ2V0V2lkdGgoKSApO1xyXG4gICAgdGhpcy5fJGNvbnRhaW5lci5oZWlnaHQoIHNlbGZCb3VuZHMuZ2V0SGVpZ2h0KCkgKTtcclxuXHJcbiAgICAvLyBtb3ZlIGJhY2sgdG8gdGhlIG1haW4gY29udGFpbmVyXHJcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKCB0ZW1wb3JhcnlDb250YWluZXIgKTtcclxuICAgIHRlbXBvcmFyeUNvbnRhaW5lci5yZW1vdmVDaGlsZCggdGhpcy5fZWxlbWVudCApO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKCB0aGlzLl9lbGVtZW50ICk7XHJcblxyXG4gICAgLy8gdW5sb2NrXHJcbiAgICB0aGlzLmludmFsaWRhdGVET01Mb2NrID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgRE9NIGRyYXdhYmxlIGZvciB0aGlzIERPTSBub2RlLiAoc2NlbmVyeS1pbnRlcm5hbClcclxuICAgKlxyXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIEluIHRoZSBiaXRtYXNrIGZvcm1hdCBzcGVjaWZpZWQgYnkgUmVuZGVyZXIsIHdoaWNoIG1heSBjb250YWluIGFkZGl0aW9uYWwgYml0IGZsYWdzLlxyXG4gICAqIEBwYXJhbSBpbnN0YW5jZSAtIEluc3RhbmNlIG9iamVjdCB0aGF0IHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBkcmF3YWJsZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBjcmVhdGVET01EcmF3YWJsZSggcmVuZGVyZXI6IG51bWJlciwgaW5zdGFuY2U6IEluc3RhbmNlICk6IERPTVNlbGZEcmF3YWJsZSB7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBvb2xhYmxlXHJcbiAgICByZXR1cm4gRE9NRHJhd2FibGUuY3JlYXRlRnJvbVBvb2woIHJlbmRlcmVyLCBpbnN0YW5jZSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGlzIE5vZGUgaXRzZWxmIGlzIHBhaW50ZWQgKGRpc3BsYXlzIHNvbWV0aGluZyBpdHNlbGYpLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBpc1BhaW50ZWQoKTogYm9vbGVhbiB7XHJcbiAgICAvLyBBbHdheXMgdHJ1ZSBmb3IgRE9NIG5vZGVzXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoYW5nZXMgdGhlIERPTSBlbGVtZW50IG9mIHRoaXMgRE9NIG5vZGUgdG8gYW5vdGhlciBlbGVtZW50LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRFbGVtZW50KCBlbGVtZW50OiBIVE1MRWxlbWVudCApOiB0aGlzIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICF0aGlzLl9lbGVtZW50LCAnV2Ugc2hvdWxkIG9ubHkgZXZlciBhdHRhY2ggb25lIERPTUVsZW1lbnQgdG8gYSBET00gbm9kZScgKTtcclxuXHJcbiAgICBpZiAoIHRoaXMuX2VsZW1lbnQgIT09IGVsZW1lbnQgKSB7XHJcbiAgICAgIGlmICggdGhpcy5fZWxlbWVudCApIHtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQoIHRoaXMuX2VsZW1lbnQgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcblxyXG4gICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoIHRoaXMuX2VsZW1lbnQgKTtcclxuXHJcbiAgICAgIHRoaXMuaW52YWxpZGF0ZURPTSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzOyAvLyBhbGxvdyBjaGFpbmluZ1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldCBlbGVtZW50KCB2YWx1ZTogSFRNTEVsZW1lbnQgKSB7IHRoaXMuc2V0RWxlbWVudCggdmFsdWUgKTsgfVxyXG5cclxuICBwdWJsaWMgZ2V0IGVsZW1lbnQoKTogSFRNTEVsZW1lbnQgeyByZXR1cm4gdGhpcy5nZXRFbGVtZW50KCk7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgZGlzcGxheWVkIGJ5IHRoaXMgRE9NIG5vZGUuXHJcbiAgICovXHJcbiAgcHVibGljIGdldEVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcHJldmVudFRyYW5zZm9ybSBmbGFnLlxyXG4gICAqXHJcbiAgICogV2hlbiB0aGUgcHJldmVudFRyYW5zZm9ybSBmbGFnIGlzIHNldCB0byB0cnVlLCBTY2VuZXJ5IHdpbGwgbm90IHJlcG9zaXRpb24gKENTUyB0cmFuc2Zvcm0pIHRoZSBET00gZWxlbWVudCwgYnV0XHJcbiAgICogaW5zdGVhZCBpdCB3aWxsIGJlIGF0IHRoZSB1cHBlci1sZWZ0ICgwLDApIG9mIHRoZSBTY2VuZXJ5IERpc3BsYXkuIFRoZSBjbGllbnQgd2lsbCBiZSByZXNwb25zaWJsZSBmb3Igc2l6aW5nIG9yXHJcbiAgICogcG9zaXRpb25pbmcgdGhpcyBlbGVtZW50IGluc3RlYWQuXHJcbiAgICovXHJcbiAgcHVibGljIHNldFByZXZlbnRUcmFuc2Zvcm0oIHByZXZlbnRUcmFuc2Zvcm06IGJvb2xlYW4gKTogdm9pZCB7XHJcbiAgICBpZiAoIHRoaXMuX3ByZXZlbnRUcmFuc2Zvcm0gIT09IHByZXZlbnRUcmFuc2Zvcm0gKSB7XHJcbiAgICAgIHRoaXMuX3ByZXZlbnRUcmFuc2Zvcm0gPSBwcmV2ZW50VHJhbnNmb3JtO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldCBwcmV2ZW50VHJhbnNmb3JtKCB2YWx1ZTogYm9vbGVhbiApIHsgdGhpcy5zZXRQcmV2ZW50VHJhbnNmb3JtKCB2YWx1ZSApOyB9XHJcblxyXG4gIHB1YmxpYyBnZXQgcHJldmVudFRyYW5zZm9ybSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuaXNUcmFuc2Zvcm1QcmV2ZW50ZWQoKTsgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcHJldmVudFRyYW5zZm9ybSBmbGFnLlxyXG4gICAqXHJcbiAgICogU2VlIHRoZSBzZXRQcmV2ZW50VHJhbnNmb3JtIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIGZsYWcuXHJcbiAgICovXHJcbiAgcHVibGljIGlzVHJhbnNmb3JtUHJldmVudGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3ByZXZlbnRUcmFuc2Zvcm07XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgb3ZlcnJpZGUgbXV0YXRlKCBvcHRpb25zPzogRE9NT3B0aW9ucyApOiB0aGlzIHtcclxuICAgIHJldHVybiBzdXBlci5tdXRhdGUoIG9wdGlvbnMgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB7QXJyYXkuPHN0cmluZz59IC0gU3RyaW5nIGtleXMgZm9yIGFsbCBvZiB0aGUgYWxsb3dlZCBvcHRpb25zIHRoYXQgd2lsbCBiZSBzZXQgYnkgbm9kZS5tdXRhdGUoIG9wdGlvbnMgKSwgaW4gdGhlXHJcbiAqIG9yZGVyIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgaW4uXHJcbiAqXHJcbiAqIE5PVEU6IFNlZSBOb2RlJ3MgX211dGF0b3JLZXlzIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRoaXMgb3BlcmF0ZXMsIGFuZCBwb3RlbnRpYWwgc3BlY2lhbFxyXG4gKiAgICAgICBjYXNlcyB0aGF0IG1heSBhcHBseS5cclxuICovXHJcbkRPTS5wcm90b3R5cGUuX211dGF0b3JLZXlzID0gRE9NX09QVElPTl9LRVlTLmNvbmNhdCggTm9kZS5wcm90b3R5cGUuX211dGF0b3JLZXlzICk7XHJcblxyXG5zY2VuZXJ5LnJlZ2lzdGVyKCAnRE9NJywgRE9NICk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxPQUFPLE1BQU0sNEJBQTRCO0FBQ2hELE9BQU9DLGFBQWEsTUFBTSx3Q0FBd0M7QUFDbEUsU0FBU0MsV0FBVyxFQUE2QkMsSUFBSSxFQUFlQyxRQUFRLEVBQUVDLE9BQU8sUUFBUSxlQUFlO0FBRTVHLE1BQU1DLGVBQWUsR0FBRyxDQUN0QixTQUFTO0FBQUU7QUFDWCxrQkFBa0IsQ0FBQztBQUFBLENBQ3BCOztBQVNEO0FBQ0EsTUFBTUMsZUFBZSxHQUFLQyxPQUF5QixJQUF5QixDQUFDLEVBQUdBLE9BQU8sSUFBTUEsT0FBTyxDQUFhQyxNQUFNLENBQUU7QUFFekgsZUFBZSxNQUFNQyxHQUFHLFNBQVNQLElBQUksQ0FBQztFQUlwQztFQUM0QztFQUU1QztFQUdBO0VBQ0E7RUFDQTtFQUdBO0VBR0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNTUSxXQUFXQSxDQUFFSCxPQUF5QixFQUFFSSxPQUFvQixFQUFHO0lBQ3BFQyxNQUFNLElBQUlBLE1BQU0sQ0FBRUQsT0FBTyxLQUFLRSxTQUFTLElBQUlDLE1BQU0sQ0FBQ0MsY0FBYyxDQUFFSixPQUFRLENBQUMsS0FBS0csTUFBTSxDQUFDRSxTQUFTLEVBQzlGLHdEQUF5RCxDQUFDO0lBRTVESixNQUFNLElBQUlBLE1BQU0sQ0FBRUwsT0FBTyxZQUFZVSxNQUFNLENBQUNDLE9BQU8sSUFBSVgsT0FBTyxDQUFDQyxNQUFNLEVBQUUscUZBQXNGLENBQUMsQ0FBQyxDQUFDOztJQUVoSztJQUNBLElBQUtGLGVBQWUsQ0FBRUMsT0FBUSxDQUFDLEVBQUc7TUFDaENBLE9BQU8sR0FBR0EsT0FBTyxDQUFFLENBQUMsQ0FBRTtNQUV0QkssTUFB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