// Copyright 2013-2023, University of Colorado Boulder

/**
 * An abstract node (should be subtyped) that is drawn by user-provided custom Canvas code.
 *
 * The region that can be drawn in is handled manually, by controlling the canvasBounds property of this CanvasNode.
 * Any regions outside of the canvasBounds will not be guaranteed to be drawn. This can be set with canvasBounds in the
 * constructor, or later with node.canvasBounds = bounds or setCanvasBounds( bounds ).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import { Shape } from '../../../kite/js/imports.js';
import { CanvasNodeDrawable, Node, Renderer, scenery } from '../imports.js';
const CANVAS_NODE_OPTION_KEYS = ['canvasBounds'];
export default class CanvasNode extends Node {
  constructor(options) {
    super(options);

    // This shouldn't change, as we only support one renderer
    this.setRendererBitmask(Renderer.bitmaskCanvas);
  }

  /**
   * Sets the bounds that are used for layout/repainting.
   *
   * These bounds should always cover at least the area where the CanvasNode will draw in. If this is violated, this
   * node may be partially or completely invisible in Scenery's output.
   */
  setCanvasBounds(selfBounds) {
    this.invalidateSelf(selfBounds);
  }
  set canvasBounds(value) {
    this.setCanvasBounds(value);
  }
  get canvasBounds() {
    return this.getCanvasBounds();
  }

  /**
   * Returns the previously-set canvasBounds, or Bounds2.NOTHING if it has not been set yet.
   */
  getCanvasBounds() {
    return this.getSelfBounds();
  }

  /**
   * Whether this Node itself is painted (displays something itself).
   */
  isPainted() {
    // Always true for CanvasNode
    return true;
  }

  /**
   * Override paintCanvas with a faster version, since fillRect and drawRect don't affect the current default path.
   *
   * IMPORTANT NOTE: This function will be run from inside Scenery's Display.updateDisplay(), so it should not modify
   * or mutate any Scenery nodes (particularly anything that would cause something to be marked as needing a repaint).
   * Ideally, this function should have no outside effects other than painting to the Canvas provided.
   */

  /**
   * Should be called when this node needs to be repainted. When not called, Scenery assumes that this node does
   * NOT need to be repainted (although Scenery may repaint it due to other nodes needing to be repainted).
   *
   * This sets a "dirty" flag, so that it will be repainted the next time it would be displayed.
   */
  invalidatePaint() {
    const stateLen = this._drawables.length;
    for (let i = 0; i < stateLen; i++) {
      this._drawables[i].markDirty();
    }
  }

  /**
   * Draws the current Node's self representation, assuming the wrapper's Canvas context is already in the local
   * coordinate frame of this node.
   *
   * @param wrapper
   * @param matrix - The transformation matrix already applied to the context.
   */
  canvasPaintSelf(wrapper, matrix) {
    this.paintCanvas(wrapper.context);
  }

  /**
   * Computes whether the provided point is "inside" (contained) in this Node's self content, or "outside".
   *
   * If CanvasNode subtypes want to support being picked or hit-tested, it should override this function.
   *
   * @param point - Considered to be in the local coordinate frame
   */
  containsPointSelf(point) {
    return false;
  }

  /**
   * Returns a Shape that represents the area covered by containsPointSelf.
   */
  getSelfShape() {
    return new Shape();
  }

  /**
   * Creates a Canvas drawable for this CanvasNode. (scenery-internal)
   *
   * @param renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
   * @param instance - Instance object that will be associated with the drawable
   */
  createCanvasDrawable(renderer, instance) {
    // @ts-expect-error
    return CanvasNodeDrawable.createFromPool(renderer, instance);
  }
  mutate(options) {
    return super.mutate(options);
  }
}

/**
 * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
 * order they will be evaluated in.
 *
 * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
 *       cases that may apply.
 */
CanvasNode.prototype._mutatorKeys = CANVAS_NODE_OPTION_KEYS.concat(Node.prototype._mutatorKeys);
scenery.register('CanvasNode', CanvasNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTaGFwZSIsIkNhbnZhc05vZGVEcmF3YWJsZSIsIk5vZGUiLCJSZW5kZXJlciIsInNjZW5lcnkiLCJDQU5WQVNfTk9ERV9PUFRJT05fS0VZUyIsIkNhbnZhc05vZGUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJzZXRSZW5kZXJlckJpdG1hc2siLCJiaXRtYXNrQ2FudmFzIiwic2V0Q2FudmFzQm91bmRzIiwic2VsZkJvdW5kcyIsImludmFsaWRhdGVTZWxmIiwiY2FudmFzQm91bmRzIiwidmFsdWUiLCJnZXRDYW52YXNCb3VuZHMiLCJnZXRTZWxmQm91bmRzIiwiaXNQYWludGVkIiwiaW52YWxpZGF0ZVBhaW50Iiwic3RhdGVMZW4iLCJfZHJhd2FibGVzIiwibGVuZ3RoIiwiaSIsIm1hcmtEaXJ0eSIsImNhbnZhc1BhaW50U2VsZiIsIndyYXBwZXIiLCJtYXRyaXgiLCJwYWludENhbnZhcyIsImNvbnRleHQiLCJjb250YWluc1BvaW50U2VsZiIsInBvaW50IiwiZ2V0U2VsZlNoYXBlIiwiY3JlYXRlQ2FudmFzRHJhd2FibGUiLCJyZW5kZXJlciIsImluc3RhbmNlIiwiY3JlYXRlRnJvbVBvb2wiLCJtdXRhdGUiLCJwcm90b3R5cGUiLCJfbXV0YXRvcktleXMiLCJjb25jYXQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkNhbnZhc05vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQW4gYWJzdHJhY3Qgbm9kZSAoc2hvdWxkIGJlIHN1YnR5cGVkKSB0aGF0IGlzIGRyYXduIGJ5IHVzZXItcHJvdmlkZWQgY3VzdG9tIENhbnZhcyBjb2RlLlxyXG4gKlxyXG4gKiBUaGUgcmVnaW9uIHRoYXQgY2FuIGJlIGRyYXduIGluIGlzIGhhbmRsZWQgbWFudWFsbHksIGJ5IGNvbnRyb2xsaW5nIHRoZSBjYW52YXNCb3VuZHMgcHJvcGVydHkgb2YgdGhpcyBDYW52YXNOb2RlLlxyXG4gKiBBbnkgcmVnaW9ucyBvdXRzaWRlIG9mIHRoZSBjYW52YXNCb3VuZHMgd2lsbCBub3QgYmUgZ3VhcmFudGVlZCB0byBiZSBkcmF3bi4gVGhpcyBjYW4gYmUgc2V0IHdpdGggY2FudmFzQm91bmRzIGluIHRoZVxyXG4gKiBjb25zdHJ1Y3Rvciwgb3IgbGF0ZXIgd2l0aCBub2RlLmNhbnZhc0JvdW5kcyA9IGJvdW5kcyBvciBzZXRDYW52YXNCb3VuZHMoIGJvdW5kcyApLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XHJcbiAqL1xyXG5cclxuaW1wb3J0IEJvdW5kczIgZnJvbSAnLi4vLi4vLi4vZG90L2pzL0JvdW5kczIuanMnO1xyXG5pbXBvcnQgTWF0cml4MyBmcm9tICcuLi8uLi8uLi9kb3QvanMvTWF0cml4My5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi8uLi8uLi9raXRlL2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgeyBDYW52YXNDb250ZXh0V3JhcHBlciwgQ2FudmFzTm9kZURyYXdhYmxlLCBDYW52YXNTZWxmRHJhd2FibGUsIEluc3RhbmNlLCBOb2RlLCBOb2RlT3B0aW9ucywgUmVuZGVyZXIsIHNjZW5lcnkgfSBmcm9tICcuLi9pbXBvcnRzLmpzJztcclxuXHJcbmNvbnN0IENBTlZBU19OT0RFX09QVElPTl9LRVlTID0gW1xyXG4gICdjYW52YXNCb3VuZHMnXHJcbl07XHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0ge1xyXG4gIGNhbnZhc0JvdW5kcz86IEJvdW5kczI7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBDYW52YXNOb2RlT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgTm9kZU9wdGlvbnM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDYW52YXNOb2RlIGV4dGVuZHMgTm9kZSB7XHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBvcHRpb25zPzogQ2FudmFzTm9kZU9wdGlvbnMgKSB7XHJcbiAgICBzdXBlciggb3B0aW9ucyApO1xyXG5cclxuICAgIC8vIFRoaXMgc2hvdWxkbid0IGNoYW5nZSwgYXMgd2Ugb25seSBzdXBwb3J0IG9uZSByZW5kZXJlclxyXG4gICAgdGhpcy5zZXRSZW5kZXJlckJpdG1hc2soIFJlbmRlcmVyLmJpdG1hc2tDYW52YXMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGJvdW5kcyB0aGF0IGFyZSB1c2VkIGZvciBsYXlvdXQvcmVwYWludGluZy5cclxuICAgKlxyXG4gICAqIFRoZXNlIGJvdW5kcyBzaG91bGQgYWx3YXlzIGNvdmVyIGF0IGxlYXN0IHRoZSBhcmVhIHdoZXJlIHRoZSBDYW52YXNOb2RlIHdpbGwgZHJhdyBpbi4gSWYgdGhpcyBpcyB2aW9sYXRlZCwgdGhpc1xyXG4gICAqIG5vZGUgbWF5IGJlIHBhcnRpYWxseSBvciBjb21wbGV0ZWx5IGludmlzaWJsZSBpbiBTY2VuZXJ5J3Mgb3V0cHV0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRDYW52YXNCb3VuZHMoIHNlbGZCb3VuZHM6IEJvdW5kczIgKTogdm9pZCB7XHJcbiAgICB0aGlzLmludmFsaWRhdGVTZWxmKCBzZWxmQm91bmRzICk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2V0IGNhbnZhc0JvdW5kcyggdmFsdWU6IEJvdW5kczIgKSB7IHRoaXMuc2V0Q2FudmFzQm91bmRzKCB2YWx1ZSApOyB9XHJcblxyXG4gIHB1YmxpYyBnZXQgY2FudmFzQm91bmRzKCk6IEJvdW5kczIgeyByZXR1cm4gdGhpcy5nZXRDYW52YXNCb3VuZHMoKTsgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBwcmV2aW91c2x5LXNldCBjYW52YXNCb3VuZHMsIG9yIEJvdW5kczIuTk9USElORyBpZiBpdCBoYXMgbm90IGJlZW4gc2V0IHlldC5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0Q2FudmFzQm91bmRzKCk6IEJvdW5kczIge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VsZkJvdW5kcygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGlzIE5vZGUgaXRzZWxmIGlzIHBhaW50ZWQgKGRpc3BsYXlzIHNvbWV0aGluZyBpdHNlbGYpLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBpc1BhaW50ZWQoKTogYm9vbGVhbiB7XHJcbiAgICAvLyBBbHdheXMgdHJ1ZSBmb3IgQ2FudmFzTm9kZVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdmVycmlkZSBwYWludENhbnZhcyB3aXRoIGEgZmFzdGVyIHZlcnNpb24sIHNpbmNlIGZpbGxSZWN0IGFuZCBkcmF3UmVjdCBkb24ndCBhZmZlY3QgdGhlIGN1cnJlbnQgZGVmYXVsdCBwYXRoLlxyXG4gICAqXHJcbiAgICogSU1QT1JUQU5UIE5PVEU6IFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBydW4gZnJvbSBpbnNpZGUgU2NlbmVyeSdzIERpc3BsYXkudXBkYXRlRGlzcGxheSgpLCBzbyBpdCBzaG91bGQgbm90IG1vZGlmeVxyXG4gICAqIG9yIG11dGF0ZSBhbnkgU2NlbmVyeSBub2RlcyAocGFydGljdWxhcmx5IGFueXRoaW5nIHRoYXQgd291bGQgY2F1c2Ugc29tZXRoaW5nIHRvIGJlIG1hcmtlZCBhcyBuZWVkaW5nIGEgcmVwYWludCkuXHJcbiAgICogSWRlYWxseSwgdGhpcyBmdW5jdGlvbiBzaG91bGQgaGF2ZSBubyBvdXRzaWRlIGVmZmVjdHMgb3RoZXIgdGhhbiBwYWludGluZyB0byB0aGUgQ2FudmFzIHByb3ZpZGVkLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBhYnN0cmFjdCBwYWludENhbnZhcyggY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGlzIG5vZGUgbmVlZHMgdG8gYmUgcmVwYWludGVkLiBXaGVuIG5vdCBjYWxsZWQsIFNjZW5lcnkgYXNzdW1lcyB0aGF0IHRoaXMgbm9kZSBkb2VzXHJcbiAgICogTk9UIG5lZWQgdG8gYmUgcmVwYWludGVkIChhbHRob3VnaCBTY2VuZXJ5IG1heSByZXBhaW50IGl0IGR1ZSB0byBvdGhlciBub2RlcyBuZWVkaW5nIHRvIGJlIHJlcGFpbnRlZCkuXHJcbiAgICpcclxuICAgKiBUaGlzIHNldHMgYSBcImRpcnR5XCIgZmxhZywgc28gdGhhdCBpdCB3aWxsIGJlIHJlcGFpbnRlZCB0aGUgbmV4dCB0aW1lIGl0IHdvdWxkIGJlIGRpc3BsYXllZC5cclxuICAgKi9cclxuICBwdWJsaWMgaW52YWxpZGF0ZVBhaW50KCk6IHZvaWQge1xyXG4gICAgY29uc3Qgc3RhdGVMZW4gPSB0aGlzLl9kcmF3YWJsZXMubGVuZ3RoO1xyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgc3RhdGVMZW47IGkrKyApIHtcclxuICAgICAgdGhpcy5fZHJhd2FibGVzWyBpIF0ubWFya0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmF3cyB0aGUgY3VycmVudCBOb2RlJ3Mgc2VsZiByZXByZXNlbnRhdGlvbiwgYXNzdW1pbmcgdGhlIHdyYXBwZXIncyBDYW52YXMgY29udGV4dCBpcyBhbHJlYWR5IGluIHRoZSBsb2NhbFxyXG4gICAqIGNvb3JkaW5hdGUgZnJhbWUgb2YgdGhpcyBub2RlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHdyYXBwZXJcclxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhbHJlYWR5IGFwcGxpZWQgdG8gdGhlIGNvbnRleHQuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGNhbnZhc1BhaW50U2VsZiggd3JhcHBlcjogQ2FudmFzQ29udGV4dFdyYXBwZXIsIG1hdHJpeDogTWF0cml4MyApOiB2b2lkIHtcclxuICAgIHRoaXMucGFpbnRDYW52YXMoIHdyYXBwZXIuY29udGV4dCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcHV0ZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgcG9pbnQgaXMgXCJpbnNpZGVcIiAoY29udGFpbmVkKSBpbiB0aGlzIE5vZGUncyBzZWxmIGNvbnRlbnQsIG9yIFwib3V0c2lkZVwiLlxyXG4gICAqXHJcbiAgICogSWYgQ2FudmFzTm9kZSBzdWJ0eXBlcyB3YW50IHRvIHN1cHBvcnQgYmVpbmcgcGlja2VkIG9yIGhpdC10ZXN0ZWQsIGl0IHNob3VsZCBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHBvaW50IC0gQ29uc2lkZXJlZCB0byBiZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBmcmFtZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBjb250YWluc1BvaW50U2VsZiggcG9pbnQ6IFZlY3RvcjIgKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgU2hhcGUgdGhhdCByZXByZXNlbnRzIHRoZSBhcmVhIGNvdmVyZWQgYnkgY29udGFpbnNQb2ludFNlbGYuXHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIGdldFNlbGZTaGFwZSgpOiBTaGFwZSB7XHJcbiAgICByZXR1cm4gbmV3IFNoYXBlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgQ2FudmFzIGRyYXdhYmxlIGZvciB0aGlzIENhbnZhc05vZGUuIChzY2VuZXJ5LWludGVybmFsKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gSW4gdGhlIGJpdG1hc2sgZm9ybWF0IHNwZWNpZmllZCBieSBSZW5kZXJlciwgd2hpY2ggbWF5IGNvbnRhaW4gYWRkaXRpb25hbCBiaXQgZmxhZ3MuXHJcbiAgICogQHBhcmFtIGluc3RhbmNlIC0gSW5zdGFuY2Ugb2JqZWN0IHRoYXQgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggdGhlIGRyYXdhYmxlXHJcbiAgICovXHJcbiAgcHVibGljIG92ZXJyaWRlIGNyZWF0ZUNhbnZhc0RyYXdhYmxlKCByZW5kZXJlcjogbnVtYmVyLCBpbnN0YW5jZTogSW5zdGFuY2UgKTogQ2FudmFzU2VsZkRyYXdhYmxlIHtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHJldHVybiBDYW52YXNOb2RlRHJhd2FibGUuY3JlYXRlRnJvbVBvb2woIHJlbmRlcmVyLCBpbnN0YW5jZSApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG92ZXJyaWRlIG11dGF0ZSggb3B0aW9ucz86IENhbnZhc05vZGVPcHRpb25zICk6IHRoaXMge1xyXG4gICAgcmV0dXJuIHN1cGVyLm11dGF0ZSggb3B0aW9ucyApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIHtBcnJheS48c3RyaW5nPn0gLSBTdHJpbmcga2V5cyBmb3IgYWxsIG9mIHRoZSBhbGxvd2VkIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHNldCBieSBub2RlLm11dGF0ZSggb3B0aW9ucyApLCBpbiB0aGVcclxuICogb3JkZXIgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBpbi5cclxuICpcclxuICogTk9URTogU2VlIE5vZGUncyBfbXV0YXRvcktleXMgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdGhpcyBvcGVyYXRlcywgYW5kIHBvdGVudGlhbCBzcGVjaWFsXHJcbiAqICAgICAgIGNhc2VzIHRoYXQgbWF5IGFwcGx5LlxyXG4gKi9cclxuQ2FudmFzTm9kZS5wcm90b3R5cGUuX211dGF0b3JLZXlzID0gQ0FOVkFTX05PREVfT1BUSU9OX0tFWVMuY29uY2F0KCBOb2RlLnByb3RvdHlwZS5fbXV0YXRvcktleXMgKTtcclxuXHJcbnNjZW5lcnkucmVnaXN0ZXIoICdDYW52YXNOb2RlJywgQ2FudmFzTm9kZSApO1xyXG4i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