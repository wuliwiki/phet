// Copyright 2017-2023, University of Colorado Boulder

/**
 * A MultiListener that is designed to pan and zoom a target Node, where you can provide limiting and
 * describing bounds so that the targetNode is limited to a region.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import Property from '../../../axon/js/Property.js';
import Bounds2 from '../../../dot/js/Bounds2.js';
import Matrix3 from '../../../dot/js/Matrix3.js';
import merge from '../../../phet-core/js/merge.js';
import ModelViewTransform2 from '../../../phetcommon/js/view/ModelViewTransform2.js';
import Tandem from '../../../tandem/js/Tandem.js';
import { MultiListener, scenery } from '../imports.js';

// constants
// Reusable Matrix3 instance to avoid creating lots of them
const SCRATCH_MATRIX = new Matrix3();
class PanZoomListener extends MultiListener {
  /**
   * @param {Node} targetNode - The Node that should be transformed by this PanZoomListener.
   * @param {Object} [options] - See the constructor body (below) for documented options.
   */
  constructor(targetNode, options) {
    options = merge({
      // {Bounds2} - these bounds should be fully filled with content at all times, in the global coordinate frame
      panBounds: Bounds2.NOTHING,
      // {null|Bounds2} - Bounds for the target node that get transformed with this listener and fill panBounds,
      // useful if the targetNode bounds do not accurately describe the targetNode (like if invisible content
      // extends off screen). Defaults to targetNode bounds if null. Bounds in the global coordinate frame of the
      // target Node.
      targetBounds: null,
      // {number} - Scale that accurately describes scale of the targetNode, but is different from the actual
      // scale of the targetNode's transform. This scale is applied to translation Vectors for the TargetNode during
      // panning. If targetNode children get scaled uniformly (such as in response to window resizing or native
      // browser zoom), you likely want that scale to be applied during translation operations so that pan/zoom behaves
      // the same regardless of window size or native browser zoom.
      targetScale: 1,
      // {boolean} - by default, the PanZoomListener does now allow rotation
      allowRotation: false,
      // {Tandem}
      tandem: Tandem.OPTIONAL
    }, options);
    super(targetNode, options);

    // @private {Bounds2} - see options
    this._panBounds = options.panBounds;
    this._targetBounds = options.targetBounds || targetNode.globalBounds.copy();

    // @protected {number}
    this._targetScale = options.targetScale;

    // @protected {Property.<Bounds2>} - Only needed for PhET-iO instrumented. The pan bounds of the source
    // so if the destination bounds are different due to a differently sized iframe or window,
    // this can be used to determine a correction for the destination targetNode transform.
    // This could be removed by work recommended in

    // When generating a PhET-iO API, the specific bounds of the window should be excluded from the initial state
    // so that the initial state part of the API doesn't depend on the window size.
    this.sourceFramePanBoundsProperty = new Property(Tandem.API_GENERATION ? new Bounds2(0, 0, 0, 0) : this._panBounds, {
      tandem: options.tandem.createTandem('sourceFramePanBoundsProperty'),
      phetioReadOnly: true,
      phetioValueType: Bounds2.Bounds2IO
    });
    this.sourceFramePanBoundsProperty.lazyLink(() => {
      const simGlobal = _.get(window, 'phet.joist.sim', null); // returns null if global isn't found

      if (simGlobal && simGlobal.isSettingPhetioStateProperty.value) {
        // The matrixProperty has transformations relative to the global view coordinates of the source simulation,
        // so it will not be correct if source and destination frames are different sizes. This will map transforamtions
        // if destination frame has different size.
        const sourceDestinationTransform = ModelViewTransform2.createRectangleMapping(this.sourceFramePanBoundsProperty.get(), this._panBounds);
        const newTranslation = this._targetNode.matrix.translation.componentMultiply(sourceDestinationTransform.matrix.getScaleVector());
        const scale = this.matrixProperty.get().getScaleVector();
        this.matrixProperty.set(Matrix3.translationFromVector(newTranslation).timesMatrix(Matrix3.scaling(scale.x, scale.y)));
      }
    }, {
      // so that the listener will be called only after the matrixProperty is up to date in the downstream sim
      phetioDependencies: [this.matrixProperty]
    });
  }

  /**
   * If the targetNode is larger than the panBounds specified, keep the panBounds completely filled with
   * targetNode content.
   *
   * @protected
   */
  correctReposition() {
    // Save values of the current matrix, so that we only do certain work when the matrix actually changes
    SCRATCH_MATRIX.set(this._targetNode.matrix);

    // the targetBounds transformed by the targetNode's transform, to determine if targetBounds are out of panBounds
    const transformedBounds = this._targetBounds.transformed(this._targetNode.getMatrix());

    // Don't let panning go through if the node is fully contained by the panBounds
    if (transformedBounds.left > this._panBounds.left) {
      this._targetNode.left = this._panBounds.left - (transformedBounds.left - this._targetNode.left);
    }
    if (transformedBounds.top > this._panBounds.top) {
      this._targetNode.top = this._panBounds.top - (transformedBounds.top - this._targetNode.top);
    }
    if (transformedBounds.right < this._panBounds.right) {
      this._targetNode.right = this._panBounds.right + (this._targetNode.right - transformedBounds.right);
    }
    if (transformedBounds.bottom < this._panBounds.bottom) {
      this._targetNode.bottom = this._panBounds.bottom + (this._targetNode.bottom - transformedBounds.bottom);
    }

    // Update Property with matrix once position has been corrected to notify listeners and set PhET-iO state, but
    // only notify when there has been an actual change.
    if (!SCRATCH_MATRIX.equals(this._targetNode.matrix)) {
      this.matrixProperty.set(this._targetNode.matrix.copy());
    }
  }

  /**
   * If the transformed targetBounds are equal to the panBounds, there is no space for us to pan so do not change
   * the pointer cursor.
   * @protected
   * @override
   *
   * @param {Press} press
   */
  addPress(press) {
    super.addPress(press);

    // don't show the pressCursor if our bounds are limited by pan bounds, and we cannot pan anywhere
    const transformedBounds = this._targetBounds.transformed(this._targetNode.getMatrix());
    const boundsLimited = transformedBounds.equalsEpsilon(this._panBounds, 1E-8);
    press.pointer.cursor = boundsLimited ? null : this._pressCursor;
  }

  /**
   * Reposition but keep content within this._panBounds.
   * @public
   * @override
   */
  reposition() {
    super.reposition();
    this.correctReposition();
  }

  /**
   * Reset the transform on the targetNode and follow up by making sure that the content is still within panBounds.
   * @public
   * @override
   */
  resetTransform() {
    MultiListener.prototype.resetTransform.call(this);
    this.correctReposition();
  }

  /**
   * Set the containing panBounds and then make sure that the targetBounds fully fill the new panBounds.
   * @override
   * @public
   *
   * @param {Bounds2} panBounds
   */
  setPanBounds(panBounds) {
    this._panBounds = panBounds;

    // When generating a PhET-iO API, the specific bounds of the window should be excluded from the initial state
    // so that the initial state part of the API doesn't depend on the window size.
    if (!Tandem.API_GENERATION) {
      this.sourceFramePanBoundsProperty.set(this._panBounds);
    }
    this.correctReposition();
  }

  /**
   * Set the targetBounds which should totally fill the panBounds at all times. Useful if the targetNode has bounds
   * which don't accurately describe the node. For instance, if an overlay plane is on top of the node and extends
   * beyond the dimensions of the visible node.
   * @public
   *
   * @param {Bounds2} targetBounds - in the global coordinate frame
   */
  setTargetBounds(targetBounds) {
    this._targetBounds = targetBounds;
    this.correctReposition();
  }

  /**
   * Set the representative scale of the target Node. If the targetBounds are different from the targetNode.bounds
   * it may be useful to correct changes to panning and zooming by a scale that is different from the
   * actual scale applied to the targetNode during panning.
   * @public
   * @param {number} scale
   */
  setTargetScale(scale) {
    this._targetScale = scale;
  }

  /**
   * Get the targetBounds, in the global coordinate frame.
   * @public
   *
   * @returns {Bounds2}
   */
  getTargetBounds(targetBounds) {
    return this._targetBounds;
  }
}
scenery.register('PanZoomListener', PanZoomListener);
export default PanZoomListener;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQcm9wZXJ0eSIsIkJvdW5kczIiLCJNYXRyaXgzIiwibWVyZ2UiLCJNb2RlbFZpZXdUcmFuc2Zvcm0yIiwiVGFuZGVtIiwiTXVsdGlMaXN0ZW5lciIsInNjZW5lcnkiLCJTQ1JBVENIX01BVFJJWCIsIlBhblpvb21MaXN0ZW5lciIsImNvbnN0cnVjdG9yIiwidGFyZ2V0Tm9kZSIsIm9wdGlvbnMiLCJwYW5Cb3VuZHMiLCJOT1RISU5HIiwidGFyZ2V0Qm91bmRzIiwidGFyZ2V0U2NhbGUiLCJhbGxvd1JvdGF0aW9uIiwidGFuZGVtIiwiT1BUSU9OQUwiLCJfcGFuQm91bmRzIiwiX3RhcmdldEJvdW5kcyIsImdsb2JhbEJvdW5kcyIsImNvcHkiLCJfdGFyZ2V0U2NhbGUiLCJzb3VyY2VGcmFtZVBhbkJvdW5kc1Byb3BlcnR5IiwiQVBJX0dFTkVSQVRJT04iLCJjcmVhdGVUYW5kZW0iLCJwaGV0aW9SZWFkT25seSIsInBoZXRpb1ZhbHVlVHlwZSIsIkJvdW5kczJJTyIsImxhenlMaW5rIiwic2ltR2xvYmFsIiwiXyIsImdldCIsIndpbmRvdyIsImlzU2V0dGluZ1BoZXRpb1N0YXRlUHJvcGVydHkiLCJ2YWx1ZSIsInNvdXJjZURlc3RpbmF0aW9uVHJhbnNmb3JtIiwiY3JlYXRlUmVjdGFuZ2xlTWFwcGluZyIsIm5ld1RyYW5zbGF0aW9uIiwiX3RhcmdldE5vZGUiLCJtYXRyaXgiLCJ0cmFuc2xhdGlvbiIsImNvbXBvbmVudE11bHRpcGx5IiwiZ2V0U2NhbGVWZWN0b3IiLCJzY2FsZSIsIm1hdHJpeFByb3BlcnR5Iiwic2V0IiwidHJhbnNsYXRpb25Gcm9tVmVjdG9yIiwidGltZXNNYXRyaXgiLCJzY2FsaW5nIiwieCIsInkiLCJwaGV0aW9EZXBlbmRlbmNpZXMiLCJjb3JyZWN0UmVwb3NpdGlvbiIsInRyYW5zZm9ybWVkQm91bmRzIiwidHJhbnNmb3JtZWQiLCJnZXRNYXRyaXgiLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJlcXVhbHMiLCJhZGRQcmVzcyIsInByZXNzIiwiYm91bmRzTGltaXRlZCIsImVxdWFsc0Vwc2lsb24iLCJwb2ludGVyIiwiY3Vyc29yIiwiX3ByZXNzQ3Vyc29yIiwicmVwb3NpdGlvbiIsInJlc2V0VHJhbnNmb3JtIiwicHJvdG90eXBlIiwiY2FsbCIsInNldFBhbkJvdW5kcyIsInNldFRhcmdldEJvdW5kcyIsInNldFRhcmdldFNjYWxlIiwiZ2V0VGFyZ2V0Qm91bmRzIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJQYW5ab29tTGlzdGVuZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTctMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSBNdWx0aUxpc3RlbmVyIHRoYXQgaXMgZGVzaWduZWQgdG8gcGFuIGFuZCB6b29tIGEgdGFyZ2V0IE5vZGUsIHdoZXJlIHlvdSBjYW4gcHJvdmlkZSBsaW1pdGluZyBhbmRcclxuICogZGVzY3JpYmluZyBib3VuZHMgc28gdGhhdCB0aGUgdGFyZ2V0Tm9kZSBpcyBsaW1pdGVkIHRvIGEgcmVnaW9uLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IEJvdW5kczIgZnJvbSAnLi4vLi4vLi4vZG90L2pzL0JvdW5kczIuanMnO1xyXG5pbXBvcnQgTWF0cml4MyBmcm9tICcuLi8uLi8uLi9kb3QvanMvTWF0cml4My5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgTW9kZWxWaWV3VHJhbnNmb3JtMiBmcm9tICcuLi8uLi8uLi9waGV0Y29tbW9uL2pzL3ZpZXcvTW9kZWxWaWV3VHJhbnNmb3JtMi5qcyc7XHJcbmltcG9ydCBUYW5kZW0gZnJvbSAnLi4vLi4vLi4vdGFuZGVtL2pzL1RhbmRlbS5qcyc7XHJcbmltcG9ydCB7IE11bHRpTGlzdGVuZXIsIHNjZW5lcnkgfSBmcm9tICcuLi9pbXBvcnRzLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG4vLyBSZXVzYWJsZSBNYXRyaXgzIGluc3RhbmNlIHRvIGF2b2lkIGNyZWF0aW5nIGxvdHMgb2YgdGhlbVxyXG5jb25zdCBTQ1JBVENIX01BVFJJWCA9IG5ldyBNYXRyaXgzKCk7XHJcblxyXG5jbGFzcyBQYW5ab29tTGlzdGVuZXIgZXh0ZW5kcyBNdWx0aUxpc3RlbmVyIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXROb2RlIC0gVGhlIE5vZGUgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQgYnkgdGhpcyBQYW5ab29tTGlzdGVuZXIuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFNlZSB0aGUgY29uc3RydWN0b3IgYm9keSAoYmVsb3cpIGZvciBkb2N1bWVudGVkIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIHRhcmdldE5vZGUsIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgb3B0aW9ucyA9IG1lcmdlKCB7XHJcblxyXG4gICAgICAvLyB7Qm91bmRzMn0gLSB0aGVzZSBib3VuZHMgc2hvdWxkIGJlIGZ1bGx5IGZpbGxlZCB3aXRoIGNvbnRlbnQgYXQgYWxsIHRpbWVzLCBpbiB0aGUgZ2xvYmFsIGNvb3JkaW5hdGUgZnJhbWVcclxuICAgICAgcGFuQm91bmRzOiBCb3VuZHMyLk5PVEhJTkcsXHJcblxyXG4gICAgICAvLyB7bnVsbHxCb3VuZHMyfSAtIEJvdW5kcyBmb3IgdGhlIHRhcmdldCBub2RlIHRoYXQgZ2V0IHRyYW5zZm9ybWVkIHdpdGggdGhpcyBsaXN0ZW5lciBhbmQgZmlsbCBwYW5Cb3VuZHMsXHJcbiAgICAgIC8vIHVzZWZ1bCBpZiB0aGUgdGFyZ2V0Tm9kZSBib3VuZHMgZG8gbm90IGFjY3VyYXRlbHkgZGVzY3JpYmUgdGhlIHRhcmdldE5vZGUgKGxpa2UgaWYgaW52aXNpYmxlIGNvbnRlbnRcclxuICAgICAgLy8gZXh0ZW5kcyBvZmYgc2NyZWVuKS4gRGVmYXVsdHMgdG8gdGFyZ2V0Tm9kZSBib3VuZHMgaWYgbnVsbC4gQm91bmRzIGluIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBmcmFtZSBvZiB0aGVcclxuICAgICAgLy8gdGFyZ2V0IE5vZGUuXHJcbiAgICAgIHRhcmdldEJvdW5kczogbnVsbCxcclxuXHJcbiAgICAgIC8vIHtudW1iZXJ9IC0gU2NhbGUgdGhhdCBhY2N1cmF0ZWx5IGRlc2NyaWJlcyBzY2FsZSBvZiB0aGUgdGFyZ2V0Tm9kZSwgYnV0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhY3R1YWxcclxuICAgICAgLy8gc2NhbGUgb2YgdGhlIHRhcmdldE5vZGUncyB0cmFuc2Zvcm0uIFRoaXMgc2NhbGUgaXMgYXBwbGllZCB0byB0cmFuc2xhdGlvbiBWZWN0b3JzIGZvciB0aGUgVGFyZ2V0Tm9kZSBkdXJpbmdcclxuICAgICAgLy8gcGFubmluZy4gSWYgdGFyZ2V0Tm9kZSBjaGlsZHJlbiBnZXQgc2NhbGVkIHVuaWZvcm1seSAoc3VjaCBhcyBpbiByZXNwb25zZSB0byB3aW5kb3cgcmVzaXppbmcgb3IgbmF0aXZlXHJcbiAgICAgIC8vIGJyb3dzZXIgem9vbSksIHlvdSBsaWtlbHkgd2FudCB0aGF0IHNjYWxlIHRvIGJlIGFwcGxpZWQgZHVyaW5nIHRyYW5zbGF0aW9uIG9wZXJhdGlvbnMgc28gdGhhdCBwYW4vem9vbSBiZWhhdmVzXHJcbiAgICAgIC8vIHRoZSBzYW1lIHJlZ2FyZGxlc3Mgb2Ygd2luZG93IHNpemUgb3IgbmF0aXZlIGJyb3dzZXIgem9vbS5cclxuICAgICAgdGFyZ2V0U2NhbGU6IDEsXHJcblxyXG4gICAgICAvLyB7Ym9vbGVhbn0gLSBieSBkZWZhdWx0LCB0aGUgUGFuWm9vbUxpc3RlbmVyIGRvZXMgbm93IGFsbG93IHJvdGF0aW9uXHJcbiAgICAgIGFsbG93Um90YXRpb246IGZhbHNlLFxyXG5cclxuICAgICAgLy8ge1RhbmRlbX1cclxuICAgICAgdGFuZGVtOiBUYW5kZW0uT1BUSU9OQUxcclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICBzdXBlciggdGFyZ2V0Tm9kZSwgb3B0aW9ucyApO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtCb3VuZHMyfSAtIHNlZSBvcHRpb25zXHJcbiAgICB0aGlzLl9wYW5Cb3VuZHMgPSBvcHRpb25zLnBhbkJvdW5kcztcclxuICAgIHRoaXMuX3RhcmdldEJvdW5kcyA9IG9wdGlvbnMudGFyZ2V0Qm91bmRzIHx8IHRhcmdldE5vZGUuZ2xvYmFsQm91bmRzLmNvcHkoKTtcclxuXHJcbiAgICAvLyBAcHJvdGVjdGVkIHtudW1iZXJ9XHJcbiAgICB0aGlzLl90YXJnZXRTY2FsZSA9IG9wdGlvbnMudGFyZ2V0U2NhbGU7XHJcblxyXG4gICAgLy8gQHByb3RlY3RlZCB7UHJvcGVydHkuPEJvdW5kczI+fSAtIE9ubHkgbmVlZGVkIGZvciBQaEVULWlPIGluc3RydW1lbnRlZC4gVGhlIHBhbiBib3VuZHMgb2YgdGhlIHNvdXJjZVxyXG4gICAgLy8gc28gaWYgdGhlIGRlc3RpbmF0aW9uIGJvdW5kcyBhcmUgZGlmZmVyZW50IGR1ZSB0byBhIGRpZmZlcmVudGx5IHNpemVkIGlmcmFtZSBvciB3aW5kb3csXHJcbiAgICAvLyB0aGlzIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSBhIGNvcnJlY3Rpb24gZm9yIHRoZSBkZXN0aW5hdGlvbiB0YXJnZXROb2RlIHRyYW5zZm9ybS5cclxuICAgIC8vIFRoaXMgY291bGQgYmUgcmVtb3ZlZCBieSB3b3JrIHJlY29tbWVuZGVkIGluXHJcblxyXG4gICAgLy8gV2hlbiBnZW5lcmF0aW5nIGEgUGhFVC1pTyBBUEksIHRoZSBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIHdpbmRvdyBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZVxyXG4gICAgLy8gc28gdGhhdCB0aGUgaW5pdGlhbCBzdGF0ZSBwYXJ0IG9mIHRoZSBBUEkgZG9lc24ndCBkZXBlbmQgb24gdGhlIHdpbmRvdyBzaXplLlxyXG4gICAgdGhpcy5zb3VyY2VGcmFtZVBhbkJvdW5kc1Byb3BlcnR5ID0gbmV3IFByb3BlcnR5KCBUYW5kZW0uQVBJX0dFTkVSQVRJT04gPyBuZXcgQm91bmRzMiggMCwgMCwgMCwgMCApIDogdGhpcy5fcGFuQm91bmRzLCB7XHJcbiAgICAgIHRhbmRlbTogb3B0aW9ucy50YW5kZW0uY3JlYXRlVGFuZGVtKCAnc291cmNlRnJhbWVQYW5Cb3VuZHNQcm9wZXJ0eScgKSxcclxuICAgICAgcGhldGlvUmVhZE9ubHk6IHRydWUsXHJcbiAgICAgIHBoZXRpb1ZhbHVlVHlwZTogQm91bmRzMi5Cb3VuZHMySU9cclxuICAgIH0gKTtcclxuXHJcbiAgICB0aGlzLnNvdXJjZUZyYW1lUGFuQm91bmRzUHJvcGVydHkubGF6eUxpbmsoICgpID0+IHtcclxuICAgICAgY29uc3Qgc2ltR2xvYmFsID0gXy5nZXQoIHdpbmRvdywgJ3BoZXQuam9pc3Quc2ltJywgbnVsbCApOyAvLyByZXR1cm5zIG51bGwgaWYgZ2xvYmFsIGlzbid0IGZvdW5kXHJcblxyXG4gICAgICBpZiAoICggc2ltR2xvYmFsICYmIHNpbUdsb2JhbC5pc1NldHRpbmdQaGV0aW9TdGF0ZVByb3BlcnR5LnZhbHVlICkgKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBtYXRyaXhQcm9wZXJ0eSBoYXMgdHJhbnNmb3JtYXRpb25zIHJlbGF0aXZlIHRvIHRoZSBnbG9iYWwgdmlldyBjb29yZGluYXRlcyBvZiB0aGUgc291cmNlIHNpbXVsYXRpb24sXHJcbiAgICAgICAgLy8gc28gaXQgd2lsbCBub3QgYmUgY29ycmVjdCBpZiBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGZyYW1lcyBhcmUgZGlmZmVyZW50IHNpemVzLiBUaGlzIHdpbGwgbWFwIHRyYW5zZm9yYW10aW9uc1xyXG4gICAgICAgIC8vIGlmIGRlc3RpbmF0aW9uIGZyYW1lIGhhcyBkaWZmZXJlbnQgc2l6ZS5cclxuICAgICAgICBjb25zdCBzb3VyY2VEZXN0aW5hdGlvblRyYW5zZm9ybSA9IE1vZGVsVmlld1RyYW5zZm9ybTIuY3JlYXRlUmVjdGFuZ2xlTWFwcGluZyggdGhpcy5zb3VyY2VGcmFtZVBhbkJvdW5kc1Byb3BlcnR5LmdldCgpLCB0aGlzLl9wYW5Cb3VuZHMgKTtcclxuXHJcbiAgICAgICAgY29uc3QgbmV3VHJhbnNsYXRpb24gPSB0aGlzLl90YXJnZXROb2RlLm1hdHJpeC50cmFuc2xhdGlvbi5jb21wb25lbnRNdWx0aXBseSggc291cmNlRGVzdGluYXRpb25UcmFuc2Zvcm0ubWF0cml4LmdldFNjYWxlVmVjdG9yKCkgKTtcclxuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMubWF0cml4UHJvcGVydHkuZ2V0KCkuZ2V0U2NhbGVWZWN0b3IoKTtcclxuICAgICAgICB0aGlzLm1hdHJpeFByb3BlcnR5LnNldCggTWF0cml4My50cmFuc2xhdGlvbkZyb21WZWN0b3IoIG5ld1RyYW5zbGF0aW9uICkudGltZXNNYXRyaXgoIE1hdHJpeDMuc2NhbGluZyggc2NhbGUueCwgc2NhbGUueSApICkgKTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG5cclxuICAgICAgLy8gc28gdGhhdCB0aGUgbGlzdGVuZXIgd2lsbCBiZSBjYWxsZWQgb25seSBhZnRlciB0aGUgbWF0cml4UHJvcGVydHkgaXMgdXAgdG8gZGF0ZSBpbiB0aGUgZG93bnN0cmVhbSBzaW1cclxuICAgICAgcGhldGlvRGVwZW5kZW5jaWVzOiBbIHRoaXMubWF0cml4UHJvcGVydHkgXVxyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgdGhlIHRhcmdldE5vZGUgaXMgbGFyZ2VyIHRoYW4gdGhlIHBhbkJvdW5kcyBzcGVjaWZpZWQsIGtlZXAgdGhlIHBhbkJvdW5kcyBjb21wbGV0ZWx5IGZpbGxlZCB3aXRoXHJcbiAgICogdGFyZ2V0Tm9kZSBjb250ZW50LlxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIGNvcnJlY3RSZXBvc2l0aW9uKCkge1xyXG5cclxuICAgIC8vIFNhdmUgdmFsdWVzIG9mIHRoZSBjdXJyZW50IG1hdHJpeCwgc28gdGhhdCB3ZSBvbmx5IGRvIGNlcnRhaW4gd29yayB3aGVuIHRoZSBtYXRyaXggYWN0dWFsbHkgY2hhbmdlc1xyXG4gICAgU0NSQVRDSF9NQVRSSVguc2V0KCB0aGlzLl90YXJnZXROb2RlLm1hdHJpeCApO1xyXG5cclxuICAgIC8vIHRoZSB0YXJnZXRCb3VuZHMgdHJhbnNmb3JtZWQgYnkgdGhlIHRhcmdldE5vZGUncyB0cmFuc2Zvcm0sIHRvIGRldGVybWluZSBpZiB0YXJnZXRCb3VuZHMgYXJlIG91dCBvZiBwYW5Cb3VuZHNcclxuICAgIGNvbnN0IHRyYW5zZm9ybWVkQm91bmRzID0gdGhpcy5fdGFyZ2V0Qm91bmRzLnRyYW5zZm9ybWVkKCB0aGlzLl90YXJnZXROb2RlLmdldE1hdHJpeCgpICk7XHJcblxyXG4gICAgLy8gRG9uJ3QgbGV0IHBhbm5pbmcgZ28gdGhyb3VnaCBpZiB0aGUgbm9kZSBpcyBmdWxseSBjb250YWluZWQgYnkgdGhlIHBhbkJvdW5kc1xyXG4gICAgaWYgKCB0cmFuc2Zvcm1lZEJvdW5kcy5sZWZ0ID4gdGhpcy5fcGFuQm91bmRzLmxlZnQgKSB7XHJcbiAgICAgIHRoaXMuX3RhcmdldE5vZGUubGVmdCA9IHRoaXMuX3BhbkJvdW5kcy5sZWZ0IC0gKCB0cmFuc2Zvcm1lZEJvdW5kcy5sZWZ0IC0gdGhpcy5fdGFyZ2V0Tm9kZS5sZWZ0ICk7XHJcbiAgICB9XHJcbiAgICBpZiAoIHRyYW5zZm9ybWVkQm91bmRzLnRvcCA+IHRoaXMuX3BhbkJvdW5kcy50b3AgKSB7XHJcbiAgICAgIHRoaXMuX3RhcmdldE5vZGUudG9wID0gdGhpcy5fcGFuQm91bmRzLnRvcCAtICggdHJhbnNmb3JtZWRCb3VuZHMudG9wIC0gdGhpcy5fdGFyZ2V0Tm9kZS50b3AgKTtcclxuICAgIH1cclxuICAgIGlmICggdHJhbnNmb3JtZWRCb3VuZHMucmlnaHQgPCB0aGlzLl9wYW5Cb3VuZHMucmlnaHQgKSB7XHJcbiAgICAgIHRoaXMuX3RhcmdldE5vZGUucmlnaHQgPSB0aGlzLl9wYW5Cb3VuZHMucmlnaHQgKyAoIHRoaXMuX3RhcmdldE5vZGUucmlnaHQgLSB0cmFuc2Zvcm1lZEJvdW5kcy5yaWdodCApO1xyXG4gICAgfVxyXG4gICAgaWYgKCB0cmFuc2Zvcm1lZEJvdW5kcy5ib3R0b20gPCB0aGlzLl9wYW5Cb3VuZHMuYm90dG9tICkge1xyXG4gICAgICB0aGlzLl90YXJnZXROb2RlLmJvdHRvbSA9IHRoaXMuX3BhbkJvdW5kcy5ib3R0b20gKyAoIHRoaXMuX3RhcmdldE5vZGUuYm90dG9tIC0gdHJhbnNmb3JtZWRCb3VuZHMuYm90dG9tICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIFByb3BlcnR5IHdpdGggbWF0cml4IG9uY2UgcG9zaXRpb24gaGFzIGJlZW4gY29ycmVjdGVkIHRvIG5vdGlmeSBsaXN0ZW5lcnMgYW5kIHNldCBQaEVULWlPIHN0YXRlLCBidXRcclxuICAgIC8vIG9ubHkgbm90aWZ5IHdoZW4gdGhlcmUgaGFzIGJlZW4gYW4gYWN0dWFsIGNoYW5nZS5cclxuICAgIGlmICggIVNDUkFUQ0hfTUFUUklYLmVxdWFscyggdGhpcy5fdGFyZ2V0Tm9kZS5tYXRyaXggKSApIHtcclxuICAgICAgdGhpcy5tYXRyaXhQcm9wZXJ0eS5zZXQoIHRoaXMuX3RhcmdldE5vZGUubWF0cml4LmNvcHkoKSApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgdGhlIHRyYW5zZm9ybWVkIHRhcmdldEJvdW5kcyBhcmUgZXF1YWwgdG8gdGhlIHBhbkJvdW5kcywgdGhlcmUgaXMgbm8gc3BhY2UgZm9yIHVzIHRvIHBhbiBzbyBkbyBub3QgY2hhbmdlXHJcbiAgICogdGhlIHBvaW50ZXIgY3Vyc29yLlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UHJlc3N9IHByZXNzXHJcbiAgICovXHJcbiAgYWRkUHJlc3MoIHByZXNzICkge1xyXG4gICAgc3VwZXIuYWRkUHJlc3MoIHByZXNzICk7XHJcblxyXG4gICAgLy8gZG9uJ3Qgc2hvdyB0aGUgcHJlc3NDdXJzb3IgaWYgb3VyIGJvdW5kcyBhcmUgbGltaXRlZCBieSBwYW4gYm91bmRzLCBhbmQgd2UgY2Fubm90IHBhbiBhbnl3aGVyZVxyXG4gICAgY29uc3QgdHJhbnNmb3JtZWRCb3VuZHMgPSB0aGlzLl90YXJnZXRCb3VuZHMudHJhbnNmb3JtZWQoIHRoaXMuX3RhcmdldE5vZGUuZ2V0TWF0cml4KCkgKTtcclxuICAgIGNvbnN0IGJvdW5kc0xpbWl0ZWQgPSB0cmFuc2Zvcm1lZEJvdW5kcy5lcXVhbHNFcHNpbG9uKCB0aGlzLl9wYW5Cb3VuZHMsIDFFLTggKTtcclxuICAgIHByZXNzLnBvaW50ZXIuY3Vyc29yID0gYm91bmRzTGltaXRlZCA/IG51bGwgOiB0aGlzLl9wcmVzc0N1cnNvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcG9zaXRpb24gYnV0IGtlZXAgY29udGVudCB3aXRoaW4gdGhpcy5fcGFuQm91bmRzLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cclxuICByZXBvc2l0aW9uKCkge1xyXG4gICAgc3VwZXIucmVwb3NpdGlvbigpO1xyXG4gICAgdGhpcy5jb3JyZWN0UmVwb3NpdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHRyYW5zZm9ybSBvbiB0aGUgdGFyZ2V0Tm9kZSBhbmQgZm9sbG93IHVwIGJ5IG1ha2luZyBzdXJlIHRoYXQgdGhlIGNvbnRlbnQgaXMgc3RpbGwgd2l0aGluIHBhbkJvdW5kcy5cclxuICAgKiBAcHVibGljXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXHJcbiAgcmVzZXRUcmFuc2Zvcm0oKSB7XHJcbiAgICBNdWx0aUxpc3RlbmVyLnByb3RvdHlwZS5yZXNldFRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XHJcbiAgICB0aGlzLmNvcnJlY3RSZXBvc2l0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIGNvbnRhaW5pbmcgcGFuQm91bmRzIGFuZCB0aGVuIG1ha2Ugc3VyZSB0aGF0IHRoZSB0YXJnZXRCb3VuZHMgZnVsbHkgZmlsbCB0aGUgbmV3IHBhbkJvdW5kcy5cclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0JvdW5kczJ9IHBhbkJvdW5kc1xyXG4gICAqL1xyXG4gIHNldFBhbkJvdW5kcyggcGFuQm91bmRzICkge1xyXG4gICAgdGhpcy5fcGFuQm91bmRzID0gcGFuQm91bmRzO1xyXG5cclxuICAgIC8vIFdoZW4gZ2VuZXJhdGluZyBhIFBoRVQtaU8gQVBJLCB0aGUgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSB3aW5kb3cgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGluaXRpYWwgc3RhdGVcclxuICAgIC8vIHNvIHRoYXQgdGhlIGluaXRpYWwgc3RhdGUgcGFydCBvZiB0aGUgQVBJIGRvZXNuJ3QgZGVwZW5kIG9uIHRoZSB3aW5kb3cgc2l6ZS5cclxuICAgIGlmICggIVRhbmRlbS5BUElfR0VORVJBVElPTiApIHtcclxuICAgICAgdGhpcy5zb3VyY2VGcmFtZVBhbkJvdW5kc1Byb3BlcnR5LnNldCggdGhpcy5fcGFuQm91bmRzICk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNvcnJlY3RSZXBvc2l0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHRhcmdldEJvdW5kcyB3aGljaCBzaG91bGQgdG90YWxseSBmaWxsIHRoZSBwYW5Cb3VuZHMgYXQgYWxsIHRpbWVzLiBVc2VmdWwgaWYgdGhlIHRhcmdldE5vZGUgaGFzIGJvdW5kc1xyXG4gICAqIHdoaWNoIGRvbid0IGFjY3VyYXRlbHkgZGVzY3JpYmUgdGhlIG5vZGUuIEZvciBpbnN0YW5jZSwgaWYgYW4gb3ZlcmxheSBwbGFuZSBpcyBvbiB0b3Agb2YgdGhlIG5vZGUgYW5kIGV4dGVuZHNcclxuICAgKiBiZXlvbmQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHZpc2libGUgbm9kZS5cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0JvdW5kczJ9IHRhcmdldEJvdW5kcyAtIGluIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBmcmFtZVxyXG4gICAqL1xyXG4gIHNldFRhcmdldEJvdW5kcyggdGFyZ2V0Qm91bmRzICkge1xyXG4gICAgdGhpcy5fdGFyZ2V0Qm91bmRzID0gdGFyZ2V0Qm91bmRzO1xyXG4gICAgdGhpcy5jb3JyZWN0UmVwb3NpdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSByZXByZXNlbnRhdGl2ZSBzY2FsZSBvZiB0aGUgdGFyZ2V0IE5vZGUuIElmIHRoZSB0YXJnZXRCb3VuZHMgYXJlIGRpZmZlcmVudCBmcm9tIHRoZSB0YXJnZXROb2RlLmJvdW5kc1xyXG4gICAqIGl0IG1heSBiZSB1c2VmdWwgdG8gY29ycmVjdCBjaGFuZ2VzIHRvIHBhbm5pbmcgYW5kIHpvb21pbmcgYnkgYSBzY2FsZSB0aGF0IGlzIGRpZmZlcmVudCBmcm9tIHRoZVxyXG4gICAqIGFjdHVhbCBzY2FsZSBhcHBsaWVkIHRvIHRoZSB0YXJnZXROb2RlIGR1cmluZyBwYW5uaW5nLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVcclxuICAgKi9cclxuICBzZXRUYXJnZXRTY2FsZSggc2NhbGUgKSB7XHJcbiAgICB0aGlzLl90YXJnZXRTY2FsZSA9IHNjYWxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSB0YXJnZXRCb3VuZHMsIGluIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBmcmFtZS5cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Qm91bmRzMn1cclxuICAgKi9cclxuICBnZXRUYXJnZXRCb3VuZHMoIHRhcmdldEJvdW5kcyApIHtcclxuICAgIHJldHVybiB0aGlzLl90YXJnZXRCb3VuZHM7XHJcbiAgfVxyXG59XHJcblxyXG5zY2VuZXJ5LnJlZ2lzdGVyKCAnUGFuWm9vbUxpc3RlbmVyJywgUGFuWm9vbUxpc3RlbmVyICk7XHJcbmV4cG9ydCBkZWZhdWx0IFBhblpvb21MaXN0ZW5lcjsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFFBQVEsTUFBTSw4QkFBOEI7QUFDbkQsT0FBT0MsT0FBTyxNQUFNLDRCQUE0QjtBQUNoRCxPQUFPQyxPQUFPLE1BQU0sNEJBQTRCO0FBQ2hELE9BQU9DLEtBQUssTUFBTSxnQ0FBZ0M7QUFDbEQsT0FBT0MsbUJBQW1CLE1BQU0sb0RBQW9EO0FBQ3BGLE9BQU9DLE1BQU0sTUFBTSw4QkFBOEI7QUFDakQsU0FBU0MsYUFBYSxFQUFFQyxPQUFPLFFBQVEsZUFBZTs7QUFFdEQ7QUFDQTtBQUNBLE1BQU1DLGNBQWMsR0FBRyxJQUFJTixPQUFPLENBQUMsQ0FBQztBQUVwQyxNQUFNTyxlQUFlLFNBQVNILGFBQWEsQ0FBQztFQUUxQztBQUNGO0FBQ0E7QUFDQTtFQUNFSSxXQUFXQSxDQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRztJQUVqQ0EsT0FBTyxHQUFHVCxLQUFLLENBQUU7TUFFZjtNQUNBVSxTQUFTLEVBQUVaLE9BQU8sQ0FBQ2EsT0FBTztNQUUxQjtNQUNBO01BQ0E7TUFDQTtNQUNBQyxZQUFZLEVBQUUsSUFBSTtNQUVsQjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0FDLFdBQVcsRUFBRSxDQUFDO01BRWQ7TUFDQUMsYUFBYSxFQUFFLEtBQUs7TUFFcEI7TUFDQUMsTUFBTSxFQUFFYixNQUFNLENBQUNjO0lBQ2pCLENBQUMsRUFBRVAsT0FBUSxDQUFDO0lBRVosS0FBSyxDQUFFRCxVQUFVLEVBQUVDLE9B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