// Copyright 2022, University of Colorado Boulder

/**
 * A trait to be mixed into PressListeners for identifying which SpriteInstance of a given Sprites node was interacted
 * with, AND will prevent interactions that are NOT over any SpriteInstances.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import inheritance from '../../../phet-core/js/inheritance.js';
import memoize from '../../../phet-core/js/memoize.js';
import { PressListener, scenery, Sprites } from '../imports.js';
/**
 * @param type - Should be a PressListener-based type
 */
const SpriteListenable = memoize(type => {
  assert && assert(_.includes(inheritance(type), PressListener), 'Only PressListener subtypes should mix SpriteListenable');
  return class extends type {
    spriteInstance = null;
    constructor(...args) {
      super(...args);
    }

    /**
     * @override - see PressListener
     */
    press(event, targetNode, callback) {
      // If pressed, then the press would be exited later AND we wouldn't want to override our spriteInstance anyway.
      if (this.isPressed) {
        return false;
      }

      // Zero it out, so we only respond to Sprites instances.
      this.spriteInstance = null;
      if (event.currentTarget instanceof Sprites) {
        const sprites = event.currentTarget;
        this.spriteInstance = sprites.getSpriteInstanceFromPoint(sprites.globalToLocalPoint(event.pointer.point));
      }

      // If we have no instance, don't super-call (same behavior for never starting a press)
      if (this.spriteInstance) {
        return super.press(event, targetNode, callback);
      } else {
        return false;
      }
    }
  };
});
scenery.register('SpriteListenable', SpriteListenable);
export default SpriteListenable;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpbmhlcml0YW5jZSIsIm1lbW9pemUiLCJQcmVzc0xpc3RlbmVyIiwic2NlbmVyeSIsIlNwcml0ZXMiLCJTcHJpdGVMaXN0ZW5hYmxlIiwidHlwZSIsImFzc2VydCIsIl8iLCJpbmNsdWRlcyIsInNwcml0ZUluc3RhbmNlIiwiY29uc3RydWN0b3IiLCJhcmdzIiwicHJlc3MiLCJldmVudCIsInRhcmdldE5vZGUiLCJjYWxsYmFjayIsImlzUHJlc3NlZCIsImN1cnJlbnRUYXJnZXQiLCJzcHJpdGVzIiwiZ2V0U3ByaXRlSW5zdGFuY2VGcm9tUG9pbnQiLCJnbG9iYWxUb0xvY2FsUG9pbnQiLCJwb2ludGVyIiwicG9pbnQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlNwcml0ZUxpc3RlbmFibGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgdHJhaXQgdG8gYmUgbWl4ZWQgaW50byBQcmVzc0xpc3RlbmVycyBmb3IgaWRlbnRpZnlpbmcgd2hpY2ggU3ByaXRlSW5zdGFuY2Ugb2YgYSBnaXZlbiBTcHJpdGVzIG5vZGUgd2FzIGludGVyYWN0ZWRcclxuICogd2l0aCwgQU5EIHdpbGwgcHJldmVudCBpbnRlcmFjdGlvbnMgdGhhdCBhcmUgTk9UIG92ZXIgYW55IFNwcml0ZUluc3RhbmNlcy5cclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBpbmhlcml0YW5jZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvaW5oZXJpdGFuY2UuanMnO1xyXG5pbXBvcnQgbWVtb2l6ZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvbWVtb2l6ZS5qcyc7XHJcbmltcG9ydCBDb25zdHJ1Y3RvciBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvQ29uc3RydWN0b3IuanMnO1xyXG5pbXBvcnQgeyBQcmVzc0xpc3RlbmVyLCBQcmVzc0xpc3RlbmVyRXZlbnQsIHNjZW5lcnksIFNwcml0ZUluc3RhbmNlLCBTcHJpdGVzLCBOb2RlIH0gZnJvbSAnLi4vaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB0eXBlIC0gU2hvdWxkIGJlIGEgUHJlc3NMaXN0ZW5lci1iYXNlZCB0eXBlXHJcbiAqL1xyXG5jb25zdCBTcHJpdGVMaXN0ZW5hYmxlID0gbWVtb2l6ZSggPFN1cGVyVHlwZSBleHRlbmRzIENvbnN0cnVjdG9yPFByZXNzTGlzdGVuZXI+PiggdHlwZTogU3VwZXJUeXBlICkgPT4ge1xyXG4gIGFzc2VydCAmJiBhc3NlcnQoIF8uaW5jbHVkZXMoIGluaGVyaXRhbmNlKCB0eXBlICksIFByZXNzTGlzdGVuZXIgKSwgJ09ubHkgUHJlc3NMaXN0ZW5lciBzdWJ0eXBlcyBzaG91bGQgbWl4IFNwcml0ZUxpc3RlbmFibGUnICk7XHJcblxyXG4gIHJldHVybiBjbGFzcyBleHRlbmRzIHR5cGUge1xyXG5cclxuICAgIHB1YmxpYyBzcHJpdGVJbnN0YW5jZTogU3ByaXRlSW5zdGFuY2UgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoIC4uLmFyZ3M6IEludGVudGlvbmFsQW55W10gKSB7XHJcbiAgICAgIHN1cGVyKCAuLi5hcmdzICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAb3ZlcnJpZGUgLSBzZWUgUHJlc3NMaXN0ZW5lclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgcHJlc3MoIGV2ZW50OiBQcmVzc0xpc3RlbmVyRXZlbnQsIHRhcmdldE5vZGU/OiBOb2RlLCBjYWxsYmFjaz86ICgpID0+IHZvaWQgKTogYm9vbGVhbiB7XHJcbiAgICAgIC8vIElmIHByZXNzZWQsIHRoZW4gdGhlIHByZXNzIHdvdWxkIGJlIGV4aXRlZCBsYXRlciBBTkQgd2Ugd291bGRuJ3Qgd2FudCB0byBvdmVycmlkZSBvdXIgc3ByaXRlSW5zdGFuY2UgYW55d2F5LlxyXG4gICAgICBpZiAoICggdGhpcyBhcyB1bmtub3duIGFzIFByZXNzTGlzdGVuZXIgKS5pc1ByZXNzZWQgKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAgICAgLy8gWmVybyBpdCBvdXQsIHNvIHdlIG9ubHkgcmVzcG9uZCB0byBTcHJpdGVzIGluc3RhbmNlcy5cclxuICAgICAgdGhpcy5zcHJpdGVJbnN0YW5jZSA9IG51bGw7XHJcblxyXG4gICAgICBpZiAoIGV2ZW50LmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBTcHJpdGVzICkge1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZXMgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xyXG5cclxuICAgICAgICB0aGlzLnNwcml0ZUluc3RhbmNlID0gc3ByaXRlcy5nZXRTcHJpdGVJbnN0YW5jZUZyb21Qb2ludCggc3ByaXRlcy5nbG9iYWxUb0xvY2FsUG9pbnQoIGV2ZW50LnBvaW50ZXIucG9pbnQgKSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB3ZSBoYXZlIG5vIGluc3RhbmNlLCBkb24ndCBzdXBlci1jYWxsIChzYW1lIGJlaGF2aW9yIGZvciBuZXZlciBzdGFydGluZyBhIHByZXNzKVxyXG4gICAgICBpZiAoIHRoaXMuc3ByaXRlSW5zdGFuY2UgKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLnByZXNzKCBldmVudCwgdGFyZ2V0Tm9kZSwgY2FsbGJhY2sgKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59ICk7XHJcblxyXG5zY2VuZXJ5LnJlZ2lzdGVyKCAnU3ByaXRlTGlzdGVuYWJsZScsIFNwcml0ZUxpc3RlbmFibGUgKTtcclxuZXhwb3J0IGRlZmF1bHQgU3ByaXRlTGlzdGVuYWJsZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxXQUFXLE1BQU0sc0NBQXNDO0FBQzlELE9BQU9DLE9BQU8sTUFBTSxrQ0FBa0M7QUFFdEQsU0FBU0MsYUFBYSxFQUFzQkMsT0FBTyxFQUFrQkMsT0FBTyxRQUFjLGVBQWU7QUFHekc7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsZ0JBQWdCLEdBQUdKLE9BQU8sQ0FBa0RLLElBQWUsSUFBTTtFQUNyR0MsTUFBTSxJQUFJQSxNQUFNLENBQUVDLENBQUMsQ0FBQ0MsUUFBUSxDQUFFVCxXQUFXLENBQUVNLElBQUssQ0FBQyxFQUFFSixhQUFjLENBQUMsRUFBRSx5REFBMEQsQ0FBQztFQUUvSCxPQUFPLGNBQWNJLElBQUksQ0FBQztJQUVqQkksY0FBYyxHQUEwQixJQUFJO0lBRTVDQyxXQUFXQSxDQUFFLEdBQUdDLElBQXNCLEVBQUc7TUFDOUMsS0FBSyxDQUFFLEdBQUdBLElBQUssQ0FBQztJQUNsQjs7SUFFQTtBQUNKO0FBQ0E7SUFDb0JDLEtBQUtBLENBQUVDLEtBQXlCLEVBQUVDLFVBQWlCLEVBQUVDLFFBQXFCLEVBQVk7TUFDcEc7TUFDQSxJQUFPLElBQUksQ0FBK0JDLFNBQVMsRUFBRztRQUFFLE9BQU8sS0FBSztNQUFFOztNQUV0RTtNQUNBLElBQUksQ0FBQ1AsY0FBYyxHQUFHLElBQUk7TUFFMUIsSUFBS0ksS0FBSyxDQUFDSSxhQUFhLFlBQVlkLE9BQU8sRUFBRztRQUM1QyxNQUFNZSxPQUFPLEdBQUdMLEtBQUssQ0FBQ0ksYUFBYTtRQUVuQyxJQUFJLENBQUNSLGNBQWMsR0FBR1MsT0FBTyxDQUFDQywwQkFBMEIsQ0FBRUQsT0FBTyxDQUFDRSxrQkFBa0IsQ0FBRVAsS0FBSyxDQUFDUSxPQUFPLENBQUNDLEtBQU0sQ0FBRSxDQUFDO01BQy9HOztNQUVBO01BQ0EsSUFBSyxJQUFJLENBQUNiLGNBQWMsRUFBRztRQUN6QixPQUFPLEtBQUssQ0FBQ0csS0FBSyxDQUFFQyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsUUFBUyxDQUFDO01BQ25ELENBQUMsTUFDSTtRQUNILE9BQU8sS0FBSztNQUNkO0lBQ0Y7RUFDRixDQUFDO0FBQ0gsQ0FBRSxDQUFDO0FBRUhiLE9BQU8sQ0FBQ3FCLFFBQVEsQ0FBRSxrQkFBa0IsRUFBRW5CLGdCQUFpQixDQUFDO0FBQ3hELGVBQWVBLGdCQUFnQiJ9