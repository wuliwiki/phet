// Copyright 2017-2022, University of Colorado Boulder

/**
 * A Node for a focus highlight that takes a shape and creates a Path with the default styling of a focus highlight
 * for a11y. The FocusHighlight has two paths.  The FocusHighlight path is an 'outer' highlight that is a little
 * lighter in color and transparency.  It as a child 'inner' path that is darker and more opaque, which gives the
 * focus highlight the illusion that it fades out.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import Emitter from '../../../axon/js/Emitter.js';
import Vector2 from '../../../dot/js/Vector2.js';
import optionize, { combineOptions } from '../../../phet-core/js/optionize.js';
import { Color, Path, scenery } from '../imports.js';

// constants
// default inner and outer strokes for the focus highlight
const OUTER_FOCUS_COLOR = new Color('rgba(212,19,106,0.5)');
const INNER_FOCUS_COLOR = new Color('rgba(250,40,135,0.9)');

// default inner and outer strokes for the group focus highlight, typically over Displays with lighter backgrounds
const INNER_LIGHT_GROUP_FOCUS_COLOR = new Color('rgba(233,113,166,1.0)');
const OUTER_LIGHT_GROUP_FOCUS_COLOR = new Color('rgba(233,113,166,1.0)');

// default inner and outer strokes for the group  focus highlight, typically over Displays with darker backgrounds
const INNER_DARK_GROUP_FOCUS_COLOR = new Color('rgba(159,15,80,1.0)');
const OUTER_DARK_GROUP_FOCUS_COLOR = new Color('rgba(159,15,80,1.0)');

// Determined by inspection, base widths of focus highlight, transform of shape/bounds will change highlight line width
const INNER_LINE_WIDTH_BASE = 2.5;
const OUTER_LINE_WIDTH_BASE = 4;

// determined by inspection, group focus highlights are thinner than default focus highlights
const GROUP_OUTER_LINE_WIDTH = 2;
const GROUP_INNER_LINE_WIDTH = 2;

// The stroke and linewidth of this path are set with outerLineWidth and outerStroke.

class FocusHighlightPath extends Path {
  // The highlight is composed of an "inner" and "outer" path to look nice. These hold each color.

  // Emits whenever this highlight changes.
  highlightChangedEmitter = new Emitter();

  // See option for documentation.

  // The 'inner' focus highlight, the (by default) slightly darker and more opaque path that is on the inside of the
  // outer path to give the focus highlight a 'fade-out' appearance
  static OUTER_FOCUS_COLOR = OUTER_FOCUS_COLOR;
  static INNER_FOCUS_COLOR = INNER_FOCUS_COLOR;
  static INNER_LIGHT_GROUP_FOCUS_COLOR = INNER_LIGHT_GROUP_FOCUS_COLOR;
  static OUTER_LIGHT_GROUP_FOCUS_COLOR = OUTER_LIGHT_GROUP_FOCUS_COLOR;
  static INNER_DARK_GROUP_FOCUS_COLOR = INNER_DARK_GROUP_FOCUS_COLOR;
  static OUTER_DARK_GROUP_FOCUS_COLOR = OUTER_DARK_GROUP_FOCUS_COLOR;
  static GROUP_OUTER_LINE_WIDTH = GROUP_OUTER_LINE_WIDTH;
  static GROUP_INNER_LINE_WIDTH = GROUP_INNER_LINE_WIDTH;

  /**
   * @param [shape] - the shape for the focus highlight
   * @param [providedOptions]
   */
  constructor(shape, providedOptions) {
    const options = optionize()({
      outerStroke: OUTER_FOCUS_COLOR,
      innerStroke: INNER_FOCUS_COLOR,
      outerLineWidth: null,
      innerLineWidth: null,
      transformSourceNode: null
    }, providedOptions);
    super(shape);
    this._innerHighlightColor = options.innerStroke;
    this._outerHighlightColor = options.outerStroke;
    const pathOptions = _.pick(options, Object.keys(Path.DEFAULT_PATH_OPTIONS));

    // Path cannot take null for lineWidth.
    this.innerLineWidth = options.innerLineWidth;
    this.outerLineWidth = options.outerLineWidth;
    this.transformSourceNode = options.transformSourceNode;

    // Assign the 'outer' specific options, and mutate the whole path for pr
    options.stroke = options.outerStroke;
    this.mutate(options);
    const innerHighlightOptions = combineOptions({}, pathOptions, {
      stroke: options.innerStroke
    });
    this.innerHighlightPath = new Path(shape, innerHighlightOptions);
    this.addChild(this.innerHighlightPath);
    this.updateLineWidth();
  }

  /**
   * Mutating convenience function to mutate both the innerHighlightPath and outerHighlightPath.
   */
  mutateWithInnerHighlight(options) {
    super.mutate(options);
    this.innerHighlightPath && this.innerHighlightPath.mutate(options);
    this.highlightChangedEmitter.emit();
  }

  /**
   * Mutate both inner and outer Paths to make the stroke dashed by using `lineDash`.
   */
  makeDashed() {
    this.mutateWithInnerHighlight({
      lineDash: [7, 7]
    });
  }

  /**
   * Update the shape of the child path (inner highlight) and this path (outer highlight). Note for the purposes
   * of chaining the outer Path (this) is returned, not the inner Path.
   */
  setShape(shape) {
    super.setShape(shape);
    this.innerHighlightPath && this.innerHighlightPath.setShape(shape);
    this.highlightChangedEmitter && this.highlightChangedEmitter.emit();
    return this;
  }

  /**
   * Update the line width of both Paths based on transform of this Path, or another Node passed in (usually the
   * node that is being highlighted). Can be overridden by the options
   * passed in the constructor.
   *
   * @param [node] - if provided, adjust the line width based on the transform of the node argument
   */
  updateLineWidth(node) {
    node = node || this; // update based on node passed in or on self.
    this.lineWidth = this.getOuterLineWidth(node);
    this.innerHighlightPath.lineWidth = this.getInnerLineWidth(node);
    this.highlightChangedEmitter.emit();
  }

  /**
   * Given a node, return the lineWidth of this focus highlight.
   */
  getOuterLineWidth(node) {
    if (this.outerLineWidth) {
      return this.outerLineWidth;
    }
    return FocusHighlightPath.getOuterLineWidthFromNode(node);
  }

  /**
   * Given a node, return the lineWidth of this focus highlight.
   */
  getInnerLineWidth(node) {
    if (this.innerLineWidth) {
      return this.innerLineWidth;
    }
    return FocusHighlightPath.getInnerLineWidthFromNode(node);
  }

  /**
   * Set the inner color of this focus highlight.
   */
  setInnerHighlightColor(color) {
    this._innerHighlightColor = color;
    this.innerHighlightPath.setStroke(color);
    this.highlightChangedEmitter.emit();
  }
  set innerHighlightColor(color) {
    this.setInnerHighlightColor(color);
  }
  get innerHighlightColor() {
    return this.getInnerHighlightColor();
  }

  /**
   * Get the inner color of this focus highlight path.
   */
  getInnerHighlightColor() {
    return this._innerHighlightColor;
  }

  /**
   * Set the outer color of this focus highlight.
   */
  setOuterHighlightColor(color) {
    this._outerHighlightColor = color;
    this.setStroke(color);
    this.highlightChangedEmitter.emit();
  }
  set outerHighlightColor(color) {
    this.setOuterHighlightColor(color);
  }
  get outerHighlightColor() {
    return this.getOuterHighlightColor();
  }

  /**
   * Get the color of the outer highlight for this FocusHighlightPath
   */
  getOuterHighlightColor() {
    return this._outerHighlightColor;
  }

  /**
   * Return the trail to the transform source node being used for this focus highlight. So that we can observe
   * transforms applied to the source node so that the focus highlight can update accordingly.
   * (scenery-internal)
   *
   * @param focusedTrail - Trail to focused Node, to help search unique Trail to the transformSourceNode
   */
  getUniqueHighlightTrail(focusedTrail) {
    assert && assert(this.transformSourceNode, 'getUniqueHighlightTrail requires a transformSourceNode');
    const transformSourceNode = this.transformSourceNode;
    let uniqueTrail = null;

    // if there is only one instance of transformSourceNode we can just grab its unique Trail
    if (transformSourceNode.instances.length <= 1) {
      uniqueTrail = transformSourceNode.getUniqueTrail();
    } else {
      // there are multiple Trails to the focused Node, try to use the one that goes through both the focused trail
      // and the transformSourceNode (a common case).
      const extendedTrails = transformSourceNode.getTrails().filter(trail => trail.isExtensionOf(focusedTrail, true));

      // If the trail to the transformSourceNode is not unique, does not go through the focused Node, or has
      // multiple Trails that go through the focused Node it is impossible to determine the Trail to use for the
      // highlight. Either avoid DAG for the transformSourceNode or use a FocusHighlightPath without
      // transformSourceNode.
      assert && assert(extendedTrails.length === 1, 'No unique trail to highlight, either avoid DAG for transformSourceNode or don\'t use transformSourceNode with FocusHighlightPath');
      uniqueTrail = extendedTrails[0];
    }
    assert && assert(uniqueTrail, 'no unique Trail found for getUniqueHighlightTrail');
    return uniqueTrail;
  }

  /**
   * Get the outer line width of a focus highlight based on the node's scale and rotation transform information.
   */
  static getInnerLineWidthFromNode(node) {
    return INNER_LINE_WIDTH_BASE / FocusHighlightPath.getWidthMagnitudeFromTransform(node);
  }

  /**
   * Get the outer line width of a node, based on its scale and rotation transformation.
   */
  static getOuterLineWidthFromNode(node) {
    return OUTER_LINE_WIDTH_BASE / FocusHighlightPath.getWidthMagnitudeFromTransform(node);
  }

  /**
   * Get a scalar width based on the node's transform excluding position.
   */
  static getWidthMagnitudeFromTransform(node) {
    return node.transform.transformDelta2(Vector2.X_UNIT).magnitude;
  }

  /**
   * Get the coefficient needed to scale the highlights bounds to surround the node being highlighted elegantly.
   * The highlight is based on a Node's bounds, so it should be scaled out a certain amount so that there is white
   * space between the edge of the component and the beginning (inside edge) of the focusHighlight
   */
  static getDilationCoefficient(node) {
    const widthOfFocusHighlight = FocusHighlightPath.getOuterLineWidthFromNode(node);

    // Dilating half of the focus highlight width will make the inner edge of the focus highlight at the bounds
    // of the node being highlighted.
    const scalarToEdgeOfBounds = 0.5;

    // Dilate the focus highlight slightly more to give whitespace in between the node being highlighted's bounds and
    // the inner edge of the highlight.
    const whiteSpaceScalar = 0.25;
    return widthOfFocusHighlight * (scalarToEdgeOfBounds + whiteSpaceScalar);
  }

  /**
   * Get the dilation coefficient for a group focus highlight, which extends even further beyond node bounds
   * than a regular focus highlight. The group focus highlight goes around a node whenever its descendant has focus,
   * so this will always surround the normal focus highlight.
   */
  static getGroupDilationCoefficient(node) {
    const widthOfFocusHighlight = FocusHighlightPath.getOuterLineWidthFromNode(node);

    // Dilating half of the focus highlight width will make the inner edge of the focus highlight at the bounds
    // of the node being highlighted.
    const scalarToEdgeOfBounds = 0.5;

    // Dilate the group focus highlight slightly more to give whitespace in between the node being highlighted's
    // bounds and the inner edge of the highlight.
    const whiteSpaceScalar = 1.4;
    return widthOfFocusHighlight * (scalarToEdgeOfBounds + whiteSpaceScalar);
  }
}
scenery.register('FocusHighlightPath', FocusHighlightPath);
export default FocusHighlightPath;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFbWl0dGVyIiwiVmVjdG9yMiIsIm9wdGlvbml6ZSIsImNvbWJpbmVPcHRpb25zIiwiQ29sb3IiLCJQYXRoIiwic2NlbmVyeSIsIk9VVEVSX0ZPQ1VTX0NPTE9SIiwiSU5ORVJfRk9DVVNfQ09MT1IiLCJJTk5FUl9MSUdIVF9HUk9VUF9GT0NVU19DT0xPUiIsIk9VVEVSX0xJR0hUX0dST1VQX0ZPQ1VTX0NPTE9SIiwiSU5ORVJfREFSS19HUk9VUF9GT0NVU19DT0xPUiIsIk9VVEVSX0RBUktfR1JPVVBfRk9DVVNfQ09MT1IiLCJJTk5FUl9MSU5FX1dJRFRIX0JBU0UiLCJPVVRFUl9MSU5FX1dJRFRIX0JBU0UiLCJHUk9VUF9PVVRFUl9MSU5FX1dJRFRIIiwiR1JPVVBfSU5ORVJfTElORV9XSURUSCIsIkZvY3VzSGlnaGxpZ2h0UGF0aCIsImhpZ2hsaWdodENoYW5nZWRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJzaGFwZSIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJvdXRlclN0cm9rZSIsImlubmVyU3Ryb2tlIiwib3V0ZXJMaW5lV2lkdGgiLCJpbm5lckxpbmVXaWR0aCIsInRyYW5zZm9ybVNvdXJjZU5vZGUiLCJfaW5uZXJIaWdobGlnaHRDb2xvciIsIl9vdXRlckhpZ2hsaWdodENvbG9yIiwicGF0aE9wdGlvbnMiLCJfIiwicGljayIsIk9iamVjdCIsImtleXMiLCJERUZBVUxUX1BBVEhfT1BUSU9OUyIsInN0cm9rZSIsIm11dGF0ZSIsImlubmVySGlnaGxpZ2h0T3B0aW9ucyIsImlubmVySGlnaGxpZ2h0UGF0aCIsImFkZENoaWxkIiwidXBkYXRlTGluZVdpZHRoIiwibXV0YXRlV2l0aElubmVySGlnaGxpZ2h0IiwiZW1pdCIsIm1ha2VEYXNoZWQiLCJsaW5lRGFzaCIsInNldFNoYXBlIiwibm9kZSIsImxpbmVXaWR0aCIsImdldE91dGVyTGluZVdpZHRoIiwiZ2V0SW5uZXJMaW5lV2lkdGgiLCJnZXRPdXRlckxpbmVXaWR0aEZyb21Ob2RlIiwiZ2V0SW5uZXJMaW5lV2lkdGhGcm9tTm9kZSIsInNldElubmVySGlnaGxpZ2h0Q29sb3IiLCJjb2xvciIsInNldFN0cm9rZSIsImlubmVySGlnaGxpZ2h0Q29sb3IiLCJnZXRJbm5lckhpZ2hsaWdodENvbG9yIiwic2V0T3V0ZXJIaWdobGlnaHRDb2xvciIsIm91dGVySGlnaGxpZ2h0Q29sb3IiLCJnZXRPdXRlckhpZ2hsaWdodENvbG9yIiwiZ2V0VW5pcXVlSGlnaGxpZ2h0VHJhaWwiLCJmb2N1c2VkVHJhaWwiLCJhc3NlcnQiLCJ1bmlxdWVUcmFpbCIsImluc3RhbmNlcyIsImxlbmd0aCIsImdldFVuaXF1ZVRyYWlsIiwiZXh0ZW5kZWRUcmFpbHMiLCJnZXRUcmFpbHMiLCJmaWx0ZXIiLCJ0cmFpbCIsImlzRXh0ZW5zaW9uT2YiLCJnZXRXaWR0aE1hZ25pdHVkZUZyb21UcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJ0cmFuc2Zvcm1EZWx0YTIiLCJYX1VOSVQiLCJtYWduaXR1ZGUiLCJnZXREaWxhdGlvbkNvZWZmaWNpZW50Iiwid2lkdGhPZkZvY3VzSGlnaGxpZ2h0Iiwic2NhbGFyVG9FZGdlT2ZCb3VuZHMiLCJ3aGl0ZVNwYWNlU2NhbGFyIiwiZ2V0R3JvdXBEaWxhdGlvbkNvZWZmaWNpZW50IiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJGb2N1c0hpZ2hsaWdodFBhdGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTctMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSBOb2RlIGZvciBhIGZvY3VzIGhpZ2hsaWdodCB0aGF0IHRha2VzIGEgc2hhcGUgYW5kIGNyZWF0ZXMgYSBQYXRoIHdpdGggdGhlIGRlZmF1bHQgc3R5bGluZyBvZiBhIGZvY3VzIGhpZ2hsaWdodFxyXG4gKiBmb3IgYTExeS4gVGhlIEZvY3VzSGlnaGxpZ2h0IGhhcyB0d28gcGF0aHMuICBUaGUgRm9jdXNIaWdobGlnaHQgcGF0aCBpcyBhbiAnb3V0ZXInIGhpZ2hsaWdodCB0aGF0IGlzIGEgbGl0dGxlXHJcbiAqIGxpZ2h0ZXIgaW4gY29sb3IgYW5kIHRyYW5zcGFyZW5jeS4gIEl0IGFzIGEgY2hpbGQgJ2lubmVyJyBwYXRoIHRoYXQgaXMgZGFya2VyIGFuZCBtb3JlIG9wYXF1ZSwgd2hpY2ggZ2l2ZXMgdGhlXHJcbiAqIGZvY3VzIGhpZ2hsaWdodCB0aGUgaWxsdXNpb24gdGhhdCBpdCBmYWRlcyBvdXQuXHJcbiAqXHJcbiAqIEBhdXRob3IgTWljaGFlbCBLYXV6bWFubiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBKZXNzZSBHcmVlbmJlcmcgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9FbWl0dGVyLmpzJztcclxuaW1wb3J0IFN0cmljdE9taXQgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL1N0cmljdE9taXQuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IG9wdGlvbml6ZSwgeyBjb21iaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgeyBDb2xvciwgVFBhaW50LCBOb2RlLCBQYXRoLCBQYXRoT3B0aW9ucywgc2NlbmVyeSwgVHJhaWwgfSBmcm9tICcuLi9pbXBvcnRzLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG4vLyBkZWZhdWx0IGlubmVyIGFuZCBvdXRlciBzdHJva2VzIGZvciB0aGUgZm9jdXMgaGlnaGxpZ2h0XHJcbmNvbnN0IE9VVEVSX0ZPQ1VTX0NPTE9SID0gbmV3IENvbG9yKCAncmdiYSgyMTIsMTksMTA2LDAuNSknICk7XHJcbmNvbnN0IElOTkVSX0ZPQ1VTX0NPTE9SID0gbmV3IENvbG9yKCAncmdiYSgyNTAsNDAsMTM1LDAuOSknICk7XHJcblxyXG4vLyBkZWZhdWx0IGlubmVyIGFuZCBvdXRlciBzdHJva2VzIGZvciB0aGUgZ3JvdXAgZm9jdXMgaGlnaGxpZ2h0LCB0eXBpY2FsbHkgb3ZlciBEaXNwbGF5cyB3aXRoIGxpZ2h0ZXIgYmFja2dyb3VuZHNcclxuY29uc3QgSU5ORVJfTElHSFRfR1JPVVBfRk9DVVNfQ09MT1IgPSBuZXcgQ29sb3IoICdyZ2JhKDIzMywxMTMsMTY2LDEuMCknICk7XHJcbmNvbnN0IE9VVEVSX0xJR0hUX0dST1VQX0ZPQ1VTX0NPTE9SID0gbmV3IENvbG9yKCAncmdiYSgyMzMsMTEzLDE2NiwxLjApJyApO1xyXG5cclxuLy8gZGVmYXVsdCBpbm5lciBhbmQgb3V0ZXIgc3Ryb2tlcyBmb3IgdGhlIGdyb3VwICBmb2N1cyBoaWdobGlnaHQsIHR5cGljYWxseSBvdmVyIERpc3BsYXlzIHdpdGggZGFya2VyIGJhY2tncm91bmRzXHJcbmNvbnN0IElOTkVSX0RBUktfR1JPVVBfRk9DVVNfQ09MT1IgPSBuZXcgQ29sb3IoICdyZ2JhKDE1OSwxNSw4MCwxLjApJyApO1xyXG5jb25zdCBPVVRFUl9EQVJLX0dST1VQX0ZPQ1VTX0NPTE9SID0gbmV3IENvbG9yKCAncmdiYSgxNTksMTUsODAsMS4wKScgKTtcclxuXHJcbi8vIERldGVybWluZWQgYnkgaW5zcGVjdGlvbiwgYmFzZSB3aWR0aHMgb2YgZm9jdXMgaGlnaGxpZ2h0LCB0cmFuc2Zvcm0gb2Ygc2hhcGUvYm91bmRzIHdpbGwgY2hhbmdlIGhpZ2hsaWdodCBsaW5lIHdpZHRoXHJcbmNvbnN0IElOTkVSX0xJTkVfV0lEVEhfQkFTRSA9IDIuNTtcclxuY29uc3QgT1VURVJfTElORV9XSURUSF9CQVNFID0gNDtcclxuXHJcbi8vIGRldGVybWluZWQgYnkgaW5zcGVjdGlvbiwgZ3JvdXAgZm9jdXMgaGlnaGxpZ2h0cyBhcmUgdGhpbm5lciB0aGFuIGRlZmF1bHQgZm9jdXMgaGlnaGxpZ2h0c1xyXG5jb25zdCBHUk9VUF9PVVRFUl9MSU5FX1dJRFRIID0gMjtcclxuY29uc3QgR1JPVVBfSU5ORVJfTElORV9XSURUSCA9IDI7XHJcblxyXG50eXBlIFNlbGZPcHRpb25zID0ge1xyXG5cclxuICAvLyBzdHJva2VzIGZvciBlYWNoIGhpZ2hsaWdodFxyXG4gIG91dGVyU3Ryb2tlPzogVFBhaW50O1xyXG4gIGlubmVyU3Ryb2tlPzogVFBhaW50O1xyXG5cclxuICAvLyBsaW5lV2lkdGggZm9yIGVhY2ggaGlnaGxpZ2h0LiBJZiBudWxsLCB0aGUgbGluZVdpZHRoIHdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSB0cmFuc2Zvcm0gb2ZcclxuICAvLyB0aGUgTm9kZSBvZiB0aGlzIGhpZ2hsaWdodCAob3IgdGhlIHRyYW5zZm9ybVNvdXJjZU5vZGUpLlxyXG4gIG91dGVyTGluZVdpZHRoPzogbnVtYmVyIHwgbnVsbDtcclxuICBpbm5lckxpbmVXaWR0aD86IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIElmIHNwZWNpZmllZCwgdGhpcyBGb2N1c0hpZ2hsaWdodFBhdGggd2lsbCByZXBvc2l0aW9uIHdpdGggdHJhbnNmb3JtIGNoYW5nZXMgYWxvbmcgdGhlIHVuaXF1ZSB0cmFpbCB0byB0aGlzIHNvdXJjZVxyXG4gIC8vIE5vZGUuIE90aGVyd2lzZSB5b3Ugd2lsbCBoYXZlIHRvIHBvc2l0aW9uIHRoaXMgaGlnaGxpZ2h0IG5vZGUgeW91cnNlbGYuXHJcbiAgdHJhbnNmb3JtU291cmNlTm9kZT86IE5vZGUgfCBudWxsO1xyXG59O1xyXG5cclxuLy8gVGhlIHN0cm9rZSBhbmQgbGluZXdpZHRoIG9mIHRoaXMgcGF0aCBhcmUgc2V0IHdpdGggb3V0ZXJMaW5lV2lkdGggYW5kIG91dGVyU3Ryb2tlLlxyXG5leHBvcnQgdHlwZSBGb2N1c0hpZ2hsaWdodFBhdGhPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBTdHJpY3RPbWl0PFBhdGhPcHRpb25zLCAnc3Ryb2tlJyB8ICdsaW5lV2lkdGgnPjtcclxuXHJcbmNsYXNzIEZvY3VzSGlnaGxpZ2h0UGF0aCBleHRlbmRzIFBhdGgge1xyXG5cclxuICAvLyBUaGUgaGlnaGxpZ2h0IGlzIGNvbXBvc2VkIG9mIGFuIFwiaW5uZXJcIiBhbmQgXCJvdXRlclwiIHBhdGggdG8gbG9vayBuaWNlLiBUaGVzZSBob2xkIGVhY2ggY29sb3IuXHJcbiAgcHJpdmF0ZSBfaW5uZXJIaWdobGlnaHRDb2xvcjogVFBhaW50O1xyXG4gIHByaXZhdGUgX291dGVySGlnaGxpZ2h0Q29sb3I6IFRQYWludDtcclxuXHJcbiAgLy8gRW1pdHMgd2hlbmV2ZXIgdGhpcyBoaWdobGlnaHQgY2hhbmdlcy5cclxuICBwdWJsaWMgaGlnaGxpZ2h0Q2hhbmdlZEVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cclxuICAvLyBTZWUgb3B0aW9uIGZvciBkb2N1bWVudGF0aW9uLlxyXG4gIHB1YmxpYyB0cmFuc2Zvcm1Tb3VyY2VOb2RlOiBOb2RlIHwgbnVsbDtcclxuICBwcml2YXRlIHJlYWRvbmx5IG91dGVyTGluZVdpZHRoOiBudW1iZXIgfCBudWxsO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgaW5uZXJMaW5lV2lkdGg6IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIFRoZSAnaW5uZXInIGZvY3VzIGhpZ2hsaWdodCwgdGhlIChieSBkZWZhdWx0KSBzbGlnaHRseSBkYXJrZXIgYW5kIG1vcmUgb3BhcXVlIHBhdGggdGhhdCBpcyBvbiB0aGUgaW5zaWRlIG9mIHRoZVxyXG4gIC8vIG91dGVyIHBhdGggdG8gZ2l2ZSB0aGUgZm9jdXMgaGlnaGxpZ2h0IGEgJ2ZhZGUtb3V0JyBhcHBlYXJhbmNlXHJcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGlubmVySGlnaGxpZ2h0UGF0aDogUGF0aDtcclxuXHJcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBPVVRFUl9GT0NVU19DT0xPUiA9IE9VVEVSX0ZPQ1VTX0NPTE9SO1xyXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSU5ORVJfRk9DVVNfQ09MT1IgPSBJTk5FUl9GT0NVU19DT0xPUjtcclxuXHJcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBJTk5FUl9MSUdIVF9HUk9VUF9GT0NVU19DT0xPUiA9IElOTkVSX0xJR0hUX0dST1VQX0ZPQ1VTX0NPTE9SO1xyXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgT1VURVJfTElHSFRfR1JPVVBfRk9DVVNfQ09MT1IgPSBPVVRFUl9MSUdIVF9HUk9VUF9GT0NVU19DT0xPUjtcclxuXHJcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBJTk5FUl9EQVJLX0dST1VQX0ZPQ1VTX0NPTE9SID0gSU5ORVJfREFSS19HUk9VUF9GT0NVU19DT0xPUjtcclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE9VVEVSX0RBUktfR1JPVVBfRk9DVVNfQ09MT1IgPSBPVVRFUl9EQVJLX0dST1VQX0ZPQ1VTX0NPTE9SO1xyXG5cclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEdST1VQX09VVEVSX0xJTkVfV0lEVEggPSBHUk9VUF9PVVRFUl9MSU5FX1dJRFRIO1xyXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgR1JPVVBfSU5ORVJfTElORV9XSURUSCA9IEdST1VQX0lOTkVSX0xJTkVfV0lEVEg7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBbc2hhcGVdIC0gdGhlIHNoYXBlIGZvciB0aGUgZm9jdXMgaGlnaGxpZ2h0XHJcbiAgICogQHBhcmFtIFtwcm92aWRlZE9wdGlvbnNdXHJcbiAgICovXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBzaGFwZTogU2hhcGUgfCBzdHJpbmcgfCBudWxsLCBwcm92aWRlZE9wdGlvbnM/OiBGb2N1c0hpZ2hsaWdodFBhdGhPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8Rm9jdXNIaWdobGlnaHRQYXRoT3B0aW9ucywgU2VsZk9wdGlvbnMsIFBhdGhPcHRpb25zPigpKCB7XHJcbiAgICAgIG91dGVyU3Ryb2tlOiBPVVRFUl9GT0NVU19DT0xPUixcclxuICAgICAgaW5uZXJTdHJva2U6IElOTkVSX0ZPQ1VTX0NPTE9SLFxyXG4gICAgICBvdXRlckxpbmVXaWR0aDogbnVsbCxcclxuICAgICAgaW5uZXJMaW5lV2lkdGg6IG51bGwsXHJcbiAgICAgIHRyYW5zZm9ybVNvdXJjZU5vZGU6IG51bGxcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIHN1cGVyKCBzaGFwZSApO1xyXG5cclxuICAgIHRoaXMuX2lubmVySGlnaGxpZ2h0Q29sb3IgPSBvcHRpb25zLmlubmVyU3Ryb2tlO1xyXG4gICAgdGhpcy5fb3V0ZXJIaWdobGlnaHRDb2xvciA9IG9wdGlvbnMub3V0ZXJTdHJva2U7XHJcblxyXG4gICAgY29uc3QgcGF0aE9wdGlvbnMgPSBfLnBpY2soIG9wdGlvbnMsIE9iamVjdC5rZXlzKCBQYXRoLkRFRkFVTFRfUEFUSF9PUFRJT05TICkgKSBhcyBQYXRoT3B0aW9ucztcclxuXHJcbiAgICAvLyBQYXRoIGNhbm5vdCB0YWtlIG51bGwgZm9yIGxpbmVXaWR0aC5cclxuICAgIHRoaXMuaW5uZXJMaW5lV2lkdGggPSBvcHRpb25zLmlubmVyTGluZVdpZHRoO1xyXG4gICAgdGhpcy5vdXRlckxpbmVXaWR0aCA9IG9wdGlvbnMub3V0ZXJMaW5lV2lkdGg7XHJcblxyXG4gICAgdGhpcy50cmFuc2Zvcm1Tb3VyY2VOb2RlID0gb3B0aW9ucy50cmFuc2Zvcm1Tb3VyY2VOb2RlO1xyXG5cclxuICAgIC8vIEFzc2lnbiB0aGUgJ291dGVyJyBzcGVjaWZpYyBvcHRpb25zLCBhbmQgbXV0YXRlIHRoZSB3aG9sZSBwYXRoIGZvciBwclxyXG4gICAgb3B0aW9ucy5zdHJva2UgPSBvcHRpb25zLm91dGVyU3Ryb2tlO1xyXG4gICAgdGhpcy5tdXRhdGUoIG9wdGlvbnMgKTtcclxuXHJcbiAgICBjb25zdCBpbm5lckhpZ2hsaWdodE9wdGlvbnMgPSBjb21iaW5lT3B0aW9uczxQYXRoT3B0aW9ucz4oIHt9LCBwYXRoT3B0aW9ucywge1xyXG4gICAgICBzdHJva2U6IG9wdGlvbnMuaW5uZXJTdHJva2VcclxuICAgIH0gKTtcclxuXHJcbiAgICB0aGlzLmlubmVySGlnaGxpZ2h0UGF0aCA9IG5ldyBQYXRoKCBzaGFwZSwgaW5uZXJIaWdobGlnaHRPcHRpb25zICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCB0aGlzLmlubmVySGlnaGxpZ2h0UGF0aCApO1xyXG5cclxuICAgIHRoaXMudXBkYXRlTGluZVdpZHRoKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNdXRhdGluZyBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBtdXRhdGUgYm90aCB0aGUgaW5uZXJIaWdobGlnaHRQYXRoIGFuZCBvdXRlckhpZ2hsaWdodFBhdGguXHJcbiAgICovXHJcbiAgcHVibGljIG11dGF0ZVdpdGhJbm5lckhpZ2hsaWdodCggb3B0aW9uczogUGF0aE9wdGlvbnMgKTogdm9pZCB7XHJcbiAgICBzdXBlci5tdXRhdGUoIG9wdGlvbnMgKTtcclxuICAgIHRoaXMuaW5uZXJIaWdobGlnaHRQYXRoICYmIHRoaXMuaW5uZXJIaWdobGlnaHRQYXRoLm11dGF0ZSggb3B0aW9ucyApO1xyXG4gICAgdGhpcy5oaWdobGlnaHRDaGFuZ2VkRW1pdHRlci5lbWl0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNdXRhdGUgYm90aCBpbm5lciBhbmQgb3V0ZXIgUGF0aHMgdG8gbWFrZSB0aGUgc3Ryb2tlIGRhc2hlZCBieSB1c2luZyBgbGluZURhc2hgLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBtYWtlRGFzaGVkKCk6IHZvaWQge1xyXG4gICAgdGhpcy5tdXRhdGVXaXRoSW5uZXJIaWdobGlnaHQoIHtcclxuICAgICAgbGluZURhc2g6IFsgNywgNyBdXHJcbiAgICB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIHNoYXBlIG9mIHRoZSBjaGlsZCBwYXRoIChpbm5lciBoaWdobGlnaHQpIGFuZCB0aGlzIHBhdGggKG91dGVyIGhpZ2hsaWdodCkuIE5vdGUgZm9yIHRoZSBwdXJwb3Nlc1xyXG4gICAqIG9mIGNoYWluaW5nIHRoZSBvdXRlciBQYXRoICh0aGlzKSBpcyByZXR1cm5lZCwgbm90IHRoZSBpbm5lciBQYXRoLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSBzZXRTaGFwZSggc2hhcGU6IFNoYXBlIHwgc3RyaW5nIHwgbnVsbCApOiB0aGlzIHtcclxuICAgIHN1cGVyLnNldFNoYXBlKCBzaGFwZSApO1xyXG4gICAgdGhpcy5pbm5lckhpZ2hsaWdodFBhdGggJiYgdGhpcy5pbm5lckhpZ2hsaWdodFBhdGguc2V0U2hhcGUoIHNoYXBlICk7XHJcbiAgICB0aGlzLmhpZ2hsaWdodENoYW5nZWRFbWl0dGVyICYmIHRoaXMuaGlnaGxpZ2h0Q2hhbmdlZEVtaXR0ZXIuZW1pdCgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBsaW5lIHdpZHRoIG9mIGJvdGggUGF0aHMgYmFzZWQgb24gdHJhbnNmb3JtIG9mIHRoaXMgUGF0aCwgb3IgYW5vdGhlciBOb2RlIHBhc3NlZCBpbiAodXN1YWxseSB0aGVcclxuICAgKiBub2RlIHRoYXQgaXMgYmVpbmcgaGlnaGxpZ2h0ZWQpLiBDYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgb3B0aW9uc1xyXG4gICAqIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3IuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gW25vZGVdIC0gaWYgcHJvdmlkZWQsIGFkanVzdCB0aGUgbGluZSB3aWR0aCBiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIG9mIHRoZSBub2RlIGFyZ3VtZW50XHJcbiAgICovXHJcbiAgcHVibGljIHVwZGF0ZUxpbmVXaWR0aCggbm9kZT86IE5vZGUgKTogdm9pZCB7XHJcbiAgICBub2RlID0gbm9kZSB8fCB0aGlzOyAvLyB1cGRhdGUgYmFzZWQgb24gbm9kZSBwYXNzZWQgaW4gb3Igb24gc2VsZi5cclxuICAgIHRoaXMubGluZVdpZHRoID0gdGhpcy5nZXRPdXRlckxpbmVXaWR0aCggbm9kZSApO1xyXG4gICAgdGhpcy5pbm5lckhpZ2hsaWdodFBhdGgubGluZVdpZHRoID0gdGhpcy5nZXRJbm5lckxpbmVXaWR0aCggbm9kZSApO1xyXG4gICAgdGhpcy5oaWdobGlnaHRDaGFuZ2VkRW1pdHRlci5lbWl0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHaXZlbiBhIG5vZGUsIHJldHVybiB0aGUgbGluZVdpZHRoIG9mIHRoaXMgZm9jdXMgaGlnaGxpZ2h0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRPdXRlckxpbmVXaWR0aCggbm9kZTogTm9kZSApOiBudW1iZXIge1xyXG4gICAgaWYgKCB0aGlzLm91dGVyTGluZVdpZHRoICkge1xyXG4gICAgICByZXR1cm4gdGhpcy5vdXRlckxpbmVXaWR0aDtcclxuICAgIH1cclxuICAgIHJldHVybiBGb2N1c0hpZ2hsaWdodFBhdGguZ2V0T3V0ZXJMaW5lV2lkdGhGcm9tTm9kZSggbm9kZSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBub2RlLCByZXR1cm4gdGhlIGxpbmVXaWR0aCBvZiB0aGlzIGZvY3VzIGhpZ2hsaWdodC5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0SW5uZXJMaW5lV2lkdGgoIG5vZGU6IE5vZGUgKTogbnVtYmVyIHtcclxuICAgIGlmICggdGhpcy5pbm5lckxpbmVXaWR0aCApIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5uZXJMaW5lV2lkdGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRm9jdXNIaWdobGlnaHRQYXRoLmdldElubmVyTGluZVdpZHRoRnJvbU5vZGUoIG5vZGUgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgaW5uZXIgY29sb3Igb2YgdGhpcyBmb2N1cyBoaWdobGlnaHQuXHJcbiAgICovXHJcbiAgcHVibGljIHNldElubmVySGlnaGxpZ2h0Q29sb3IoIGNvbG9yOiBUUGFpbnQgKTogdm9pZCB7XHJcbiAgICB0aGlzLl9pbm5lckhpZ2hsaWdodENvbG9yID0gY29sb3I7XHJcbiAgICB0aGlzLmlubmVySGlnaGxpZ2h0UGF0aC5zZXRTdHJva2UoIGNvbG9yICk7XHJcbiAgICB0aGlzLmhpZ2hsaWdodENoYW5nZWRFbWl0dGVyLmVtaXQoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXQgaW5uZXJIaWdobGlnaHRDb2xvciggY29sb3I6IFRQYWludCApIHsgdGhpcy5zZXRJbm5lckhpZ2hsaWdodENvbG9yKCBjb2xvciApOyB9XHJcblxyXG4gIHB1YmxpYyBnZXQgaW5uZXJIaWdobGlnaHRDb2xvcigpOiBUUGFpbnQgeyByZXR1cm4gdGhpcy5nZXRJbm5lckhpZ2hsaWdodENvbG9yKCk7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBpbm5lciBjb2xvciBvZiB0aGlzIGZvY3VzIGhpZ2hsaWdodCBwYXRoLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRJbm5lckhpZ2hsaWdodENvbG9yKCk6IFRQYWludCB7XHJcbiAgICByZXR1cm4gdGhpcy5faW5uZXJIaWdobGlnaHRDb2xvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgb3V0ZXIgY29sb3Igb2YgdGhpcyBmb2N1cyBoaWdobGlnaHQuXHJcbiAgICovXHJcbiAgcHVibGljIHNldE91dGVySGlnaGxpZ2h0Q29sb3IoIGNvbG9yOiBUUGFpbnQgKTogdm9pZCB7XHJcbiAgICB0aGlzLl9vdXRlckhpZ2hsaWdodENvbG9yID0gY29sb3I7XHJcbiAgICB0aGlzLnNldFN0cm9rZSggY29sb3IgKTtcclxuICAgIHRoaXMuaGlnaGxpZ2h0Q2hhbmdlZEVtaXR0ZXIuZW1pdCgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldCBvdXRlckhpZ2hsaWdodENvbG9yKCBjb2xvcjogVFBhaW50ICkgeyB0aGlzLnNldE91dGVySGlnaGxpZ2h0Q29sb3IoIGNvbG9yICk7IH1cclxuXHJcbiAgcHVibGljIGdldCBvdXRlckhpZ2hsaWdodENvbG9yKCk6IFRQYWludCB7IHJldHVybiB0aGlzLmdldE91dGVySGlnaGxpZ2h0Q29sb3IoKTsgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGNvbG9yIG9mIHRoZSBvdXRlciBoaWdobGlnaHQgZm9yIHRoaXMgRm9jdXNIaWdobGlnaHRQYXRoXHJcbiAgICovXHJcbiAgcHVibGljIGdldE91dGVySGlnaGxpZ2h0Q29sb3IoKTogVFBhaW50IHtcclxuICAgIHJldHVybiB0aGlzLl9vdXRlckhpZ2hsaWdodENvbG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSB0cmFpbCB0byB0aGUgdHJhbnNmb3JtIHNvdXJjZSBub2RlIGJlaW5nIHVzZWQgZm9yIHRoaXMgZm9jdXMgaGlnaGxpZ2h0LiBTbyB0aGF0IHdlIGNhbiBvYnNlcnZlXHJcbiAgICogdHJhbnNmb3JtcyBhcHBsaWVkIHRvIHRoZSBzb3VyY2Ugbm9kZSBzbyB0aGF0IHRoZSBmb2N1cyBoaWdobGlnaHQgY2FuIHVwZGF0ZSBhY2NvcmRpbmdseS5cclxuICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcclxuICAgKlxyXG4gICAqIEBwYXJhbSBmb2N1c2VkVHJhaWwgLSBUcmFpbCB0byBmb2N1c2VkIE5vZGUsIHRvIGhlbHAgc2VhcmNoIHVuaXF1ZSBUcmFpbCB0byB0aGUgdHJhbnNmb3JtU291cmNlTm9kZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRVbmlxdWVIaWdobGlnaHRUcmFpbCggZm9jdXNlZFRyYWlsOiBUcmFpbCApOiBUcmFpbCB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLnRyYW5zZm9ybVNvdXJjZU5vZGUsICdnZXRVbmlxdWVIaWdobGlnaHRUcmFpbCByZXF1aXJlcyBhIHRyYW5zZm9ybVNvdXJjZU5vZGUnICk7XHJcbiAgICBjb25zdCB0cmFuc2Zvcm1Tb3VyY2VOb2RlID0gdGhpcy50cmFuc2Zvcm1Tb3VyY2VOb2RlITtcclxuXHJcbiAgICBsZXQgdW5pcXVlVHJhaWwgPSBudWxsO1xyXG5cclxuICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGluc3RhbmNlIG9mIHRyYW5zZm9ybVNvdXJjZU5vZGUgd2UgY2FuIGp1c3QgZ3JhYiBpdHMgdW5pcXVlIFRyYWlsXHJcbiAgICBpZiAoIHRyYW5zZm9ybVNvdXJjZU5vZGUuaW5zdGFuY2VzLmxlbmd0aCA8PSAxICkge1xyXG4gICAgICB1bmlxdWVUcmFpbCA9IHRyYW5zZm9ybVNvdXJjZU5vZGUuZ2V0VW5pcXVlVHJhaWwoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgLy8gdGhlcmUgYXJlIG11bHRpcGxlIFRyYWlscyB0byB0aGUgZm9jdXNlZCBOb2RlLCB0cnkgdG8gdXNlIHRoZSBvbmUgdGhhdCBnb2VzIHRocm91Z2ggYm90aCB0aGUgZm9jdXNlZCB0cmFpbFxyXG4gICAgICAvLyBhbmQgdGhlIHRyYW5zZm9ybVNvdXJjZU5vZGUgKGEgY29tbW9uIGNhc2UpLlxyXG4gICAgICBjb25zdCBleHRlbmRlZFRyYWlscyA9IHRyYW5zZm9ybVNvdXJjZU5vZGUuZ2V0VHJhaWxzKCkuZmlsdGVyKCB0cmFpbCA9PiB0cmFpbC5pc0V4dGVuc2lvbk9mKCBmb2N1c2VkVHJhaWwsIHRydWUgKSApO1xyXG5cclxuICAgICAgLy8gSWYgdGhlIHRyYWlsIHRvIHRoZSB0cmFuc2Zvcm1Tb3VyY2VOb2RlIGlzIG5vdCB1bmlxdWUsIGRvZXMgbm90IGdvIHRocm91Z2ggdGhlIGZvY3VzZWQgTm9kZSwgb3IgaGFzXHJcbiAgICAgIC8vIG11bHRpcGxlIFRyYWlscyB0aGF0IGdvIHRocm91Z2ggdGhlIGZvY3VzZWQgTm9kZSBpdCBpcyBpbXBvc3NpYmxlIHRvIGRldGVybWluZSB0aGUgVHJhaWwgdG8gdXNlIGZvciB0aGVcclxuICAgICAgLy8gaGlnaGxpZ2h0LiBFaXRoZXIgYXZvaWQgREFHIGZvciB0aGUgdHJhbnNmb3JtU291cmNlTm9kZSBvciB1c2UgYSBGb2N1c0hpZ2hsaWdodFBhdGggd2l0aG91dFxyXG4gICAgICAvLyB0cmFuc2Zvcm1Tb3VyY2VOb2RlLlxyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBleHRlbmRlZFRyYWlscy5sZW5ndGggPT09IDEsXHJcbiAgICAgICAgJ05vIHVuaXF1ZSB0cmFpbCB0byBoaWdobGlnaHQsIGVpdGhlciBhdm9pZCBEQUcgZm9yIHRyYW5zZm9ybVNvdXJjZU5vZGUgb3IgZG9uXFwndCB1c2UgdHJhbnNmb3JtU291cmNlTm9kZSB3aXRoIEZvY3VzSGlnaGxpZ2h0UGF0aCdcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHVuaXF1ZVRyYWlsID0gZXh0ZW5kZWRUcmFpbHNbIDAgXTtcclxuICAgIH1cclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB1bmlxdWVUcmFpbCwgJ25vIHVuaXF1ZSBUcmFpbCBmb3VuZCBmb3IgZ2V0VW5pcXVlSGlnaGxpZ2h0VHJhaWwnICk7XHJcbiAgICByZXR1cm4gdW5pcXVlVHJhaWw7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBvdXRlciBsaW5lIHdpZHRoIG9mIGEgZm9jdXMgaGlnaGxpZ2h0IGJhc2VkIG9uIHRoZSBub2RlJ3Mgc2NhbGUgYW5kIHJvdGF0aW9uIHRyYW5zZm9ybSBpbmZvcm1hdGlvbi5cclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIGdldElubmVyTGluZVdpZHRoRnJvbU5vZGUoIG5vZGU6IE5vZGUgKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBJTk5FUl9MSU5FX1dJRFRIX0JBU0UgLyBGb2N1c0hpZ2hsaWdodFBhdGguZ2V0V2lkdGhNYWduaXR1ZGVGcm9tVHJhbnNmb3JtKCBub2RlICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIG91dGVyIGxpbmUgd2lkdGggb2YgYSBub2RlLCBiYXNlZCBvbiBpdHMgc2NhbGUgYW5kIHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgZ2V0T3V0ZXJMaW5lV2lkdGhGcm9tTm9kZSggbm9kZTogTm9kZSApOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIE9VVEVSX0xJTkVfV0lEVEhfQkFTRSAvIEZvY3VzSGlnaGxpZ2h0UGF0aC5nZXRXaWR0aE1hZ25pdHVkZUZyb21UcmFuc2Zvcm0oIG5vZGUgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIHNjYWxhciB3aWR0aCBiYXNlZCBvbiB0aGUgbm9kZSdzIHRyYW5zZm9ybSBleGNsdWRpbmcgcG9zaXRpb24uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0V2lkdGhNYWduaXR1ZGVGcm9tVHJhbnNmb3JtKCBub2RlOiBOb2RlICk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gbm9kZS50cmFuc2Zvcm0udHJhbnNmb3JtRGVsdGEyKCBWZWN0b3IyLlhfVU5JVCApLm1hZ25pdHVkZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29lZmZpY2llbnQgbmVlZGVkIHRvIHNjYWxlIHRoZSBoaWdobGlnaHRzIGJvdW5kcyB0byBzdXJyb3VuZCB0aGUgbm9kZSBiZWluZyBoaWdobGlnaHRlZCBlbGVnYW50bHkuXHJcbiAgICogVGhlIGhpZ2hsaWdodCBpcyBiYXNlZCBvbiBhIE5vZGUncyBib3VuZHMsIHNvIGl0IHNob3VsZCBiZSBzY2FsZWQgb3V0IGEgY2VydGFpbiBhbW91bnQgc28gdGhhdCB0aGVyZSBpcyB3aGl0ZVxyXG4gICAqIHNwYWNlIGJldHdlZW4gdGhlIGVkZ2Ugb2YgdGhlIGNvbXBvbmVudCBhbmQgdGhlIGJlZ2lubmluZyAoaW5zaWRlIGVkZ2UpIG9mIHRoZSBmb2N1c0hpZ2hsaWdodFxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RGlsYXRpb25Db2VmZmljaWVudCggbm9kZTogTm9kZSApOiBudW1iZXIge1xyXG4gICAgY29uc3Qgd2lkdGhPZkZvY3VzSGlnaGxpZ2h0ID0gRm9jdXNIaWdobGlnaHRQYXRoLmdldE91dGVyTGluZVdpZHRoRnJvbU5vZGUoIG5vZGUgKTtcclxuXHJcbiAgICAvLyBEaWxhdGluZyBoYWxmIG9mIHRoZSBmb2N1cyBoaWdobGlnaHQgd2lkdGggd2lsbCBtYWtlIHRoZSBpbm5lciBlZGdlIG9mIHRoZSBmb2N1cyBoaWdobGlnaHQgYXQgdGhlIGJvdW5kc1xyXG4gICAgLy8gb2YgdGhlIG5vZGUgYmVpbmcgaGlnaGxpZ2h0ZWQuXHJcbiAgICBjb25zdCBzY2FsYXJUb0VkZ2VPZkJvdW5kcyA9IDAuNTtcclxuXHJcbiAgICAvLyBEaWxhdGUgdGhlIGZvY3VzIGhpZ2hsaWdodCBzbGlnaHRseSBtb3JlIHRvIGdpdmUgd2hpdGVzcGFjZSBpbiBiZXR3ZWVuIHRoZSBub2RlIGJlaW5nIGhpZ2hsaWdodGVkJ3MgYm91bmRzIGFuZFxyXG4gICAgLy8gdGhlIGlubmVyIGVkZ2Ugb2YgdGhlIGhpZ2hsaWdodC5cclxuICAgIGNvbnN0IHdoaXRlU3BhY2VTY2FsYXIgPSAwLjI1O1xyXG5cclxuICAgIHJldHVybiB3aWR0aE9mRm9jdXNIaWdobGlnaHQgKiAoIHNjYWxhclRvRWRnZU9mQm91bmRzICsgd2hpdGVTcGFjZVNjYWxhciApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBkaWxhdGlvbiBjb2VmZmljaWVudCBmb3IgYSBncm91cCBmb2N1cyBoaWdobGlnaHQsIHdoaWNoIGV4dGVuZHMgZXZlbiBmdXJ0aGVyIGJleW9uZCBub2RlIGJvdW5kc1xyXG4gICAqIHRoYW4gYSByZWd1bGFyIGZvY3VzIGhpZ2hsaWdodC4gVGhlIGdyb3VwIGZvY3VzIGhpZ2hsaWdodCBnb2VzIGFyb3VuZCBhIG5vZGUgd2hlbmV2ZXIgaXRzIGRlc2NlbmRhbnQgaGFzIGZvY3VzLFxyXG4gICAqIHNvIHRoaXMgd2lsbCBhbHdheXMgc3Vycm91bmQgdGhlIG5vcm1hbCBmb2N1cyBoaWdobGlnaHQuXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBnZXRHcm91cERpbGF0aW9uQ29lZmZpY2llbnQoIG5vZGU6IE5vZGUgKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IHdpZHRoT2ZGb2N1c0hpZ2hsaWdodCA9IEZvY3VzSGlnaGxpZ2h0UGF0aC5nZXRPdXRlckxpbmVXaWR0aEZyb21Ob2RlKCBub2RlICk7XHJcblxyXG4gICAgLy8gRGlsYXRpbmcgaGFsZiBvZiB0aGUgZm9jdXMgaGlnaGxpZ2h0IHdpZHRoIHdpbGwgbWFrZSB0aGUgaW5uZXIgZWRnZSBvZiB0aGUgZm9jdXMgaGlnaGxpZ2h0IGF0IHRoZSBib3VuZHNcclxuICAgIC8vIG9mIHRoZSBub2RlIGJlaW5nIGhpZ2hsaWdodGVkLlxyXG4gICAgY29uc3Qgc2NhbGFyVG9FZGdlT2ZCb3VuZHMgPSAwLjU7XHJcblxyXG4gICAgLy8gRGlsYXRlIHRoZSBncm91cCBmb2N1cyBoaWdobGlnaHQgc2xpZ2h0bHkgbW9yZSB0byBnaXZlIHdoaXRlc3BhY2UgaW4gYmV0d2VlbiB0aGUgbm9kZSBiZWluZyBoaWdobGlnaHRlZCdzXHJcbiAgICAvLyBib3VuZHMgYW5kIHRoZSBpbm5lciBlZGdlIG9mIHRoZSBoaWdobGlnaHQuXHJcbiAgICBjb25zdCB3aGl0ZVNwYWNlU2NhbGFyID0gMS40O1xyXG5cclxuICAgIHJldHVybiB3aWR0aE9mRm9jdXNIaWdobGlnaHQgKiAoIHNjYWxhclRvRWRnZU9mQm91bmRzICsgd2hpdGVTcGFjZVNjYWxhciApO1xyXG4gIH1cclxufVxyXG5cclxuc2NlbmVyeS5yZWdpc3RlciggJ0ZvY3VzSGlnaGxpZ2h0UGF0aCcsIEZvY3VzSGlnaGxpZ2h0UGF0aCApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRm9jdXNIaWdobGlnaHRQYXRoOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLE9BQU8sTUFBTSw2QkFBNkI7QUFFakQsT0FBT0MsT0FBTyxNQUFNLDRCQUE0QjtBQUVoRCxPQUFPQyxTQUFTLElBQUlDLGNBQWMsUUFBUSxvQ0FBb0M7QUFDOUUsU0FBU0MsS0FBSyxFQUFnQkMsSUFBSSxFQUFlQyxP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