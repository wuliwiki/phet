// Copyright 2017-2022, University of Colorado Boulder

/**
 * A FocusHighlightPath subtype that is based around a Node. The focusHighlight is constructed based on the bounds of
 * the node. The focusHighlight will update as the Node's bounds changes. Handles transformations so that when the
 * source node is transformed, the FocusHighlightFromNode will
 * updated be as well.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import { Shape } from '../../../kite/js/imports.js';
import optionize from '../../../phet-core/js/optionize.js';
import { FocusHighlightPath, scenery } from '../imports.js';

// The transformSourceNode for this highlight will be the provided Node.

class FocusHighlightFromNode extends FocusHighlightPath {
  // See options for documentation.

  // Property for a Node's bounds which are currently being observed with the boundsListener. Referenced so that
  // we can remove the listener later.
  observedBoundsProperty = null;

  // Listener that sets the shape of this highlight when the Node bounds change. Referenced so it can be removed later.
  boundsListener = null;
  constructor(node, providedOptions) {
    const options = optionize()({
      useLocalBounds: true,
      dilationCoefficient: null,
      useGroupDilation: false
    }, providedOptions);
    options.transformSourceNode = node;
    super(null, options);
    this.useLocalBounds = options.useLocalBounds;
    this.useGroupDilation = options.useGroupDilation;
    this.dilationCoefficient = options.dilationCoefficient;
    if (node) {
      this.setShapeFromNode(node);
    }
  }

  /**
   * Update the focusHighlight shape on the path given the node passed in. Depending on options supplied to this
   * FocusHighlightFromNode, the shape will surround the node's bounds or its local bounds, dilated by an amount
   * that is dependent on whether or not this highlight is for group content or for the node itself. See
   * ParallelDOM.setGroupFocusHighlight() for more information on group highlights.
   */
  setShapeFromNode(node) {
    // cleanup the previous listener
    if (this.observedBoundsProperty) {
      assert && assert(this.boundsListener, 'should be a listener if there is a previous focusHighlightNode');
      this.observedBoundsProperty.unlink(this.boundsListener);
    }
    this.observedBoundsProperty = this.useLocalBounds ? node.localBoundsProperty : node.boundsProperty;
    this.boundsListener = bounds => {
      // Ignore setting the shape if we don't yet have finite bounds.
      if (!bounds.isFinite()) {
        return;
      }
      let dilationCoefficient = this.dilationCoefficient;

      // Figure out how much dilation to apply to the focus highlight around the node, calculated unless specified
      // with options
      if (this.dilationCoefficient === null) {
        dilationCoefficient = this.useGroupDilation ? FocusHighlightPath.getGroupDilationCoefficient(node) : FocusHighlightPath.getDilationCoefficient(node);
      }
      const dilatedBounds = bounds.dilated(dilationCoefficient);

      // Update the line width of the focus highlight based on the transform of the node
      this.updateLineWidthFromNode(node);
      this.setShape(Shape.bounds(dilatedBounds));
    };
    this.observedBoundsProperty.link(this.boundsListener);
  }

  /**
   * Update the line width of both inner and outer highlights based on transform of the Node.
   */
  updateLineWidthFromNode(node) {
    // Note that lineWidths provided by options can override width determined from Node transform.
    this.lineWidth = this.getOuterLineWidth(node);
    this.innerHighlightPath.lineWidth = this.getInnerLineWidth(node);
  }
}
scenery.register('FocusHighlightFromNode', FocusHighlightFromNode);
export default FocusHighlightFromNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTaGFwZSIsIm9wdGlvbml6ZSIsIkZvY3VzSGlnaGxpZ2h0UGF0aCIsInNjZW5lcnkiLCJGb2N1c0hpZ2hsaWdodEZyb21Ob2RlIiwib2JzZXJ2ZWRCb3VuZHNQcm9wZXJ0eSIsImJvdW5kc0xpc3RlbmVyIiwiY29uc3RydWN0b3IiLCJub2RlIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsInVzZUxvY2FsQm91bmRzIiwiZGlsYXRpb25Db2VmZmljaWVudCIsInVzZUdyb3VwRGlsYXRpb24iLCJ0cmFuc2Zvcm1Tb3VyY2VOb2RlIiwic2V0U2hhcGVGcm9tTm9kZSIsImFzc2VydCIsInVubGluayIsImxvY2FsQm91bmRzUHJvcGVydHkiLCJib3VuZHNQcm9wZXJ0eSIsImJvdW5kcyIsImlzRmluaXRlIiwiZ2V0R3JvdXBEaWxhdGlvbkNvZWZmaWNpZW50IiwiZ2V0RGlsYXRpb25Db2VmZmljaWVudCIsImRpbGF0ZWRCb3VuZHMiLCJkaWxhdGVkIiwidXBkYXRlTGluZVdpZHRoRnJvbU5vZGUiLCJzZXRTaGFwZSIsImxpbmsiLCJsaW5lV2lkdGgiLCJnZXRPdXRlckxpbmVXaWR0aCIsImlubmVySGlnaGxpZ2h0UGF0aCIsImdldElubmVyTGluZVdpZHRoIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJGb2N1c0hpZ2hsaWdodEZyb21Ob2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE3LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgRm9jdXNIaWdobGlnaHRQYXRoIHN1YnR5cGUgdGhhdCBpcyBiYXNlZCBhcm91bmQgYSBOb2RlLiBUaGUgZm9jdXNIaWdobGlnaHQgaXMgY29uc3RydWN0ZWQgYmFzZWQgb24gdGhlIGJvdW5kcyBvZlxyXG4gKiB0aGUgbm9kZS4gVGhlIGZvY3VzSGlnaGxpZ2h0IHdpbGwgdXBkYXRlIGFzIHRoZSBOb2RlJ3MgYm91bmRzIGNoYW5nZXMuIEhhbmRsZXMgdHJhbnNmb3JtYXRpb25zIHNvIHRoYXQgd2hlbiB0aGVcclxuICogc291cmNlIG5vZGUgaXMgdHJhbnNmb3JtZWQsIHRoZSBGb2N1c0hpZ2hsaWdodEZyb21Ob2RlIHdpbGxcclxuICogdXBkYXRlZCBiZSBhcyB3ZWxsLlxyXG4gKlxyXG4gKiBAYXV0aG9yIE1pY2hhZWwgS2F1em1hbm4gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBUUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9UUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgU3RyaWN0T21pdCBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvU3RyaWN0T21pdC5qcyc7XHJcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcclxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi8uLi8uLi9raXRlL2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgeyBGb2N1c0hpZ2hsaWdodFBhdGgsIE5vZGUsIHNjZW5lcnkgfSBmcm9tICcuLi9pbXBvcnRzLmpzJztcclxuaW1wb3J0IHsgRm9jdXNIaWdobGlnaHRQYXRoT3B0aW9ucyB9IGZyb20gJy4vRm9jdXNIaWdobGlnaHRQYXRoLmpzJztcclxuXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSB7XHJcblxyXG4gIC8vIGlmIHRydWUsIGhpZ2hsaWdodCB3aWxsIHN1cnJvdW5kIGxvY2FsIGJvdW5kcyBpbnN0ZWFkIG9mIHBhcmVudCBib3VuZHNcclxuICB1c2VMb2NhbEJvdW5kcz86IGJvb2xlYW47XHJcblxyXG4gIC8vIGRlZmF1bHQgdmFsdWUgaXMgZnVuY3Rpb24gb2Ygbm9kZSB0cmFuc2Zvcm0gKG1pbnVzIHRyYW5zbGF0aW9uKSwgYnV0IGNhbiBiZSBzZXQgZXhwbGljaXRseS5cclxuICAvLyBzZWUgRm9jdXNIaWdobGlnaHRQYXRoLmdldERpbGF0aW9uQ29lZmZpY2llbnQoKS4gQSBudW1iZXIgaGVyZSByZWZlcnMgdG8gdGhlIGFtb3VudCBpbiBnbG9iYWwgY29vcmRpbmF0ZXMgdG9cclxuICAvLyBkaWxhdGUgdGhlIGZvY3VzIGhpZ2hsaWdodC5cclxuICBkaWxhdGlvbkNvZWZmaWNpZW50PzogbnVtYmVyIHwgbnVsbDtcclxuXHJcbiAgLy8gaWYgdHJ1ZSwgZGlsYXRpb24gZm9yIGJvdW5kcyBhcm91bmQgbm9kZSB3aWxsIGluY3JlYXNlLCBzZWUgc2V0U2hhcGVGcm9tTm9kZSgpXHJcbiAgdXNlR3JvdXBEaWxhdGlvbj86IGJvb2xlYW47XHJcbn07XHJcblxyXG4vLyBUaGUgdHJhbnNmb3JtU291cmNlTm9kZSBmb3IgdGhpcyBoaWdobGlnaHQgd2lsbCBiZSB0aGUgcHJvdmlkZWQgTm9kZS5cclxuZXhwb3J0IHR5cGUgRm9jdXNIaWdobGlnaHRGcm9tTm9kZU9wdGlvbnMgPSBTZWxmT3B0aW9ucyAmIFN0cmljdE9taXQ8Rm9jdXNIaWdobGlnaHRQYXRoT3B0aW9ucywgJ3RyYW5zZm9ybVNvdXJjZU5vZGUnPjtcclxuXHJcbmNsYXNzIEZvY3VzSGlnaGxpZ2h0RnJvbU5vZGUgZXh0ZW5kcyBGb2N1c0hpZ2hsaWdodFBhdGgge1xyXG5cclxuICAvLyBTZWUgb3B0aW9ucyBmb3IgZG9jdW1lbnRhdGlvbi5cclxuICBwcml2YXRlIHJlYWRvbmx5IHVzZUxvY2FsQm91bmRzOiBib29sZWFuO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgdXNlR3JvdXBEaWxhdGlvbjogYm9vbGVhbjtcclxuICBwcml2YXRlIHJlYWRvbmx5IGRpbGF0aW9uQ29lZmZpY2llbnQ6IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIFByb3BlcnR5IGZvciBhIE5vZGUncyBib3VuZHMgd2hpY2ggYXJlIGN1cnJlbnRseSBiZWluZyBvYnNlcnZlZCB3aXRoIHRoZSBib3VuZHNMaXN0ZW5lci4gUmVmZXJlbmNlZCBzbyB0aGF0XHJcbiAgLy8gd2UgY2FuIHJlbW92ZSB0aGUgbGlzdGVuZXIgbGF0ZXIuXHJcbiAgcHJpdmF0ZSBvYnNlcnZlZEJvdW5kc1Byb3BlcnR5OiBudWxsIHwgVFByb3BlcnR5PEJvdW5kczI+ID0gbnVsbDtcclxuXHJcbiAgLy8gTGlzdGVuZXIgdGhhdCBzZXRzIHRoZSBzaGFwZSBvZiB0aGlzIGhpZ2hsaWdodCB3aGVuIHRoZSBOb2RlIGJvdW5kcyBjaGFuZ2UuIFJlZmVyZW5jZWQgc28gaXQgY2FuIGJlIHJlbW92ZWQgbGF0ZXIuXHJcbiAgcHJpdmF0ZSBib3VuZHNMaXN0ZW5lcjogbnVsbCB8ICggKCBib3VuZHM6IEJvdW5kczIgKSA9PiB2b2lkICkgPSBudWxsO1xyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIG5vZGU6IE5vZGUgfCBudWxsLCBwcm92aWRlZE9wdGlvbnM/OiBGb2N1c0hpZ2hsaWdodEZyb21Ob2RlT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPEZvY3VzSGlnaGxpZ2h0RnJvbU5vZGVPcHRpb25zLCBTZWxmT3B0aW9ucywgRm9jdXNIaWdobGlnaHRQYXRoT3B0aW9ucz4oKSgge1xyXG4gICAgICB1c2VMb2NhbEJvdW5kczogdHJ1ZSxcclxuICAgICAgZGlsYXRpb25Db2VmZmljaWVudDogbnVsbCxcclxuICAgICAgdXNlR3JvdXBEaWxhdGlvbjogZmFsc2VcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIG9wdGlvbnMudHJhbnNmb3JtU291cmNlTm9kZSA9IG5vZGU7XHJcblxyXG4gICAgc3VwZXIoIG51bGwsIG9wdGlvbnMgKTtcclxuXHJcbiAgICB0aGlzLnVzZUxvY2FsQm91bmRzID0gb3B0aW9ucy51c2VMb2NhbEJvdW5kcztcclxuICAgIHRoaXMudXNlR3JvdXBEaWxhdGlvbiA9IG9wdGlvbnMudXNlR3JvdXBEaWxhdGlvbjtcclxuICAgIHRoaXMuZGlsYXRpb25Db2VmZmljaWVudCA9IG9wdGlvbnMuZGlsYXRpb25Db2VmZmljaWVudDtcclxuXHJcbiAgICBpZiAoIG5vZGUgKSB7XHJcbiAgICAgIHRoaXMuc2V0U2hhcGVGcm9tTm9kZSggbm9kZSApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgZm9jdXNIaWdobGlnaHQgc2hhcGUgb24gdGhlIHBhdGggZ2l2ZW4gdGhlIG5vZGUgcGFzc2VkIGluLiBEZXBlbmRpbmcgb24gb3B0aW9ucyBzdXBwbGllZCB0byB0aGlzXHJcbiAgICogRm9jdXNIaWdobGlnaHRGcm9tTm9kZSwgdGhlIHNoYXBlIHdpbGwgc3Vycm91bmQgdGhlIG5vZGUncyBib3VuZHMgb3IgaXRzIGxvY2FsIGJvdW5kcywgZGlsYXRlZCBieSBhbiBhbW91bnRcclxuICAgKiB0aGF0IGlzIGRlcGVuZGVudCBvbiB3aGV0aGVyIG9yIG5vdCB0aGlzIGhpZ2hsaWdodCBpcyBmb3IgZ3JvdXAgY29udGVudCBvciBmb3IgdGhlIG5vZGUgaXRzZWxmLiBTZWVcclxuICAgKiBQYXJhbGxlbERPTS5zZXRHcm91cEZvY3VzSGlnaGxpZ2h0KCkgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZ3JvdXAgaGlnaGxpZ2h0cy5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0U2hhcGVGcm9tTm9kZSggbm9kZTogTm9kZSApOiB2b2lkIHtcclxuXHJcbiAgICAvLyBjbGVhbnVwIHRoZSBwcmV2aW91cyBsaXN0ZW5lclxyXG4gICAgaWYgKCB0aGlzLm9ic2VydmVkQm91bmRzUHJvcGVydHkgKSB7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuYm91bmRzTGlzdGVuZXIsICdzaG91bGQgYmUgYSBsaXN0ZW5lciBpZiB0aGVyZSBpcyBhIHByZXZpb3VzIGZvY3VzSGlnaGxpZ2h0Tm9kZScgKTtcclxuICAgICAgdGhpcy5vYnNlcnZlZEJvdW5kc1Byb3BlcnR5LnVubGluayggdGhpcy5ib3VuZHNMaXN0ZW5lciEgKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9ic2VydmVkQm91bmRzUHJvcGVydHkgPSB0aGlzLnVzZUxvY2FsQm91bmRzID8gbm9kZS5sb2NhbEJvdW5kc1Byb3BlcnR5IDogbm9kZS5ib3VuZHNQcm9wZXJ0eTtcclxuXHJcbiAgICB0aGlzLmJvdW5kc0xpc3RlbmVyID0gYm91bmRzID0+IHtcclxuXHJcbiAgICAgIC8vIElnbm9yZSBzZXR0aW5nIHRoZSBzaGFwZSBpZiB3ZSBkb24ndCB5ZXQgaGF2ZSBmaW5pdGUgYm91bmRzLlxyXG4gICAgICBpZiAoICFib3VuZHMuaXNGaW5pdGUoKSApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBkaWxhdGlvbkNvZWZmaWNpZW50ID0gdGhpcy5kaWxhdGlvbkNvZWZmaWNpZW50O1xyXG5cclxuICAgICAgLy8gRmlndXJlIG91dCBob3cgbXVjaCBkaWxhdGlvbiB0byBhcHBseSB0byB0aGUgZm9jdXMgaGlnaGxpZ2h0IGFyb3VuZCB0aGUgbm9kZSwgY2FsY3VsYXRlZCB1bmxlc3Mgc3BlY2lmaWVkXHJcbiAgICAgIC8vIHdpdGggb3B0aW9uc1xyXG4gICAgICBpZiAoIHRoaXMuZGlsYXRpb25Db2VmZmljaWVudCA9PT0gbnVsbCApIHtcclxuICAgICAgICBkaWxhdGlvbkNvZWZmaWNpZW50ID0gKCB0aGlzLnVzZUdyb3VwRGlsYXRpb24gPyBGb2N1c0hpZ2hsaWdodFBhdGguZ2V0R3JvdXBEaWxhdGlvbkNvZWZmaWNpZW50KCBub2RlICkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvY3VzSGlnaGxpZ2h0UGF0aC5nZXREaWxhdGlvbkNvZWZmaWNpZW50KCBub2RlICkgKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkaWxhdGVkQm91bmRzID0gYm91bmRzLmRpbGF0ZWQoIGRpbGF0aW9uQ29lZmZpY2llbnQhICk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIGxpbmUgd2lkdGggb2YgdGhlIGZvY3VzIGhpZ2hsaWdodCBiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIG9mIHRoZSBub2RlXHJcbiAgICAgIHRoaXMudXBkYXRlTGluZVdpZHRoRnJvbU5vZGUoIG5vZGUgKTtcclxuICAgICAgdGhpcy5zZXRTaGFwZSggU2hhcGUuYm91bmRzKCBkaWxhdGVkQm91bmRzICkgKTtcclxuICAgIH07XHJcbiAgICB0aGlzLm9ic2VydmVkQm91bmRzUHJvcGVydHkubGluayggdGhpcy5ib3VuZHNMaXN0ZW5lciApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBsaW5lIHdpZHRoIG9mIGJvdGggaW5uZXIgYW5kIG91dGVyIGhpZ2hsaWdodHMgYmFzZWQgb24gdHJhbnNmb3JtIG9mIHRoZSBOb2RlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgdXBkYXRlTGluZVdpZHRoRnJvbU5vZGUoIG5vZGU6IE5vZGUgKTogdm9pZCB7XHJcblxyXG4gICAgLy8gTm90ZSB0aGF0IGxpbmVXaWR0aHMgcHJvdmlkZWQgYnkgb3B0aW9ucyBjYW4gb3ZlcnJpZGUgd2lkdGggZGV0ZXJtaW5lZCBmcm9tIE5vZGUgdHJhbnNmb3JtLlxyXG4gICAgdGhpcy5saW5lV2lkdGggPSB0aGlzLmdldE91dGVyTGluZVdpZHRoKCBub2RlICk7XHJcbiAgICB0aGlzLmlubmVySGlnaGxpZ2h0UGF0aC5saW5lV2lkdGggPSB0aGlzLmdldElubmVyTGluZVdpZHRoKCBub2RlICk7XHJcbiAgfVxyXG59XHJcblxyXG5zY2VuZXJ5LnJlZ2lzdGVyKCAnRm9jdXNIaWdobGlnaHRGcm9tTm9kZScsIEZvY3VzSGlnaGxpZ2h0RnJvbU5vZGUgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZvY3VzSGlnaGxpZ2h0RnJvbU5vZGU7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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