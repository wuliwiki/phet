// Copyright 2023, University of Colorado Boulder

/**
 * A Property that, if there is a unique path from one Node to another (A => root => B, or A => B, or B => A), will
 * contain the transformation matrix from A to B's coordinate frame (local coordinate frames by default).
 *
 * If there is no unique path, the value will be null.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import TinyProperty from '../../../axon/js/TinyProperty.js';
import Matrix3 from '../../../dot/js/Matrix3.js';
import arrayDifference from '../../../phet-core/js/arrayDifference.js';
import optionize from '../../../phet-core/js/optionize.js';
import { AncestorNodesProperty, scenery } from '../imports.js';
export default class MatrixBetweenProperty extends TinyProperty {
  // When we have a unique connection with trails, this will contain the root node common to both.
  // NOTE: This might be one of the actual nodes itself.
  rootNode = null;

  // When we have a unique connection with trails, these will contain the trail to the root node
  fromTrail = null;
  toTrail = null;
  // A set of nodes where we are listening to whether their transforms change
  listenedNodeSet = new Set();
  constructor(from, to, providedOptions) {
    const options = optionize()({
      fromCoordinateFrame: 'local',
      toCoordinateFrame: 'local'
    }, providedOptions);
    super(Matrix3.IDENTITY);
    this.from = from;
    this.to = to;
    this.fromCoordinateFrame = options.fromCoordinateFrame;
    this.toCoordinateFrame = options.toCoordinateFrame;

    // Identical matrices shouldn't trigger notifications
    this.useDeepEquality = true;
    this.fromAncestorsProperty = new AncestorNodesProperty(from);
    this.toAncestorsProperty = new AncestorNodesProperty(to);
    const updateListener = this.update.bind(this);
    this._nodeTransformListener = this.updateMatrix.bind(this);

    // We'll only trigger a full update when parents/ancestors change anywhere. Otherwise, we'll just do transform
    // changes with updateMatrix()
    this.fromAncestorsProperty.updateEmitter.addListener(updateListener);
    this.toAncestorsProperty.updateEmitter.addListener(updateListener);
    this.update();
  }
  update() {
    // Track nodes (not just ancestors) here, in case one is an ancestor of the other
    // REVIEW: would it be more performant for below opperations if these were Sets?
    const fromNodes = [...this.fromAncestorsProperty.value, this.from];
    const toNodes = [...this.toAncestorsProperty.value, this.to];

    // Intersection (ancestors of from/to)
    const commonNodes = fromNodes.filter(a => toNodes.includes(a));
    let hasDAG = false;

    // We'll want to find all nodes that are common ancestors of both, BUT aren't superfluous (an ancestor of another
    // common ancestor, with no other paths).
    const rootNodes = commonNodes.filter(node => {
      const fromChildren = fromNodes.filter(aNode => node.hasChild(aNode));
      const toChildren = toNodes.filter(bNode => node.hasChild(bNode));
      const fromOnly = [];
      const toOnly = [];
      const both = [];
      arrayDifference(fromChildren, toChildren, fromOnly, toOnly, both);
      const hasMultipleChildren = fromChildren.length > 1 || toChildren.length > 1;
      const hasUnsharedChild = fromOnly.length || toOnly.length;

      // If either has multiple children, AND we're not just a trivial ancestor of the root, we're in a DAG case
      if (hasMultipleChildren && hasUnsharedChild) {
        hasDAG = true;
      }
      const hasFromExclusive = fromOnly.length > 0 || this.from === node;
      const hasToExclusive = toOnly.length > 0 || this.to === node;
      return hasFromExclusive && hasToExclusive;
    });
    if (!hasDAG && rootNodes.length === 1) {
      // We have a root node, and should have unique trails!
      this.rootNode = rootNodes[0];

      // These should assert-error out if there is no unique trail for either
      this.fromTrail = this.from.getUniqueTrailTo(this.rootNode);
      this.toTrail = this.to.getUniqueTrailTo(this.rootNode);
    } else {
      this.rootNode = null;
      this.fromTrail = null;
      this.toTrail = null;
    }

    // Take note of the nodes we are listening to
    const nodeSet = new Set();
    this.fromTrail && this.fromTrail.nodes.forEach(node => nodeSet.add(node));
    this.toTrail && this.toTrail.nodes.forEach(node => nodeSet.add(node));

    // Add in new needed listeners
    nodeSet.forEach(node => {
      if (!this.listenedNodeSet.has(node)) {
        this.addNodeListener(node);
      }
    });

    // Remove listeners not needed anymore
    this.listenedNodeSet.forEach(node => {
      if (!nodeSet.has(node) && node !== this.from && node !== this.to) {
        this.removeNodeListener(node);
      }
    });
    this.updateMatrix();
  }
  updateMatrix() {
    if (this.rootNode && this.fromTrail && this.toTrail) {
      // If one of these is an ancestor of the other AND the ancestor requests a "parent" coordinate frame, we'll need
      // to compute things to the next level up. Otherwise, we can ignore the root node's transform. This is NOT
      // just an optimization, since if we multiply in the root node's transform into both the fromMatrix and toMatrix,
      // we'll lead to numerical imprecision that could be avoided. With this, we can get precise/exact results, even
      // if there is a scale on the rootNode (imagine a ScreenView's transform).
      const fromSelf = this.fromTrail.nodes.length === 1;
      const toSelf = this.toTrail.nodes.length === 1;
      const useAncestorMatrix = fromSelf && this.fromCoordinateFrame === 'parent' || toSelf && this.toCoordinateFrame === 'parent';

      // Instead of switching between 4 different matrix functions, we use the general form.
      const fromMatrix = this.fromTrail.getMatrixConcatenation(useAncestorMatrix ? 0 : 1, this.fromTrail.nodes.length - (this.fromCoordinateFrame === 'parent' ? 1 : 0));
      const toMatrix = this.toTrail.getMatrixConcatenation(useAncestorMatrix ? 0 : 1, this.toTrail.nodes.length - (this.toCoordinateFrame === 'parent' ? 1 : 0));

      // toPoint = toMatrix^-1 * fromMatrix * fromPoint
      this.value = toMatrix.inverted().timesMatrix(fromMatrix);
    } else {
      this.value = null;
    }
  }
  addNodeListener(node) {
    this.listenedNodeSet.add(node);
    node.transformEmitter.addListener(this._nodeTransformListener);
  }
  removeNodeListener(node) {
    this.listenedNodeSet.delete(node);
    node.transformEmitter.removeListener(this._nodeTransformListener);
  }
  dispose() {
    this.fromAncestorsProperty.dispose();
    this.toAncestorsProperty.dispose();
    super.dispose();
  }
}
scenery.register('MatrixBetweenProperty', MatrixBetweenProperty);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUaW55UHJvcGVydHkiLCJNYXRyaXgzIiwiYXJyYXlEaWZmZXJlbmNlIiwib3B0aW9uaXplIiwiQW5jZXN0b3JOb2Rlc1Byb3BlcnR5Iiwic2NlbmVyeSIsIk1hdHJpeEJldHdlZW5Qcm9wZXJ0eSIsInJvb3ROb2RlIiwiZnJvbVRyYWlsIiwidG9UcmFpbCIsImxpc3RlbmVkTm9kZVNldCIsIlNldCIsImNvbnN0cnVjdG9yIiwiZnJvbSIsInRvIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsImZyb21Db29yZGluYXRlRnJhbWUiLCJ0b0Nvb3JkaW5hdGVGcmFtZSIsIklERU5USVRZIiwidXNlRGVlcEVxdWFsaXR5IiwiZnJvbUFuY2VzdG9yc1Byb3BlcnR5IiwidG9BbmNlc3RvcnNQcm9wZXJ0eSIsInVwZGF0ZUxpc3RlbmVyIiwidXBkYXRlIiwiYmluZCIsIl9ub2RlVHJhbnNmb3JtTGlzdGVuZXIiLCJ1cGRhdGVNYXRyaXgiLCJ1cGRhdGVFbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJmcm9tTm9kZXMiLCJ2YWx1ZSIsInRvTm9kZXMiLCJjb21tb25Ob2RlcyIsImZpbHRlciIsImEiLCJpbmNsdWRlcyIsImhhc0RBRyIsInJvb3ROb2RlcyIsIm5vZGUiLCJmcm9tQ2hpbGRyZW4iLCJhTm9kZSIsImhhc0NoaWxkIiwidG9DaGlsZHJlbiIsImJOb2RlIiwiZnJvbU9ubHkiLCJ0b09ubHkiLCJib3RoIiwiaGFzTXVsdGlwbGVDaGlsZHJlbiIsImxlbmd0aCIsImhhc1Vuc2hhcmVkQ2hpbGQiLCJoYXNGcm9tRXhjbHVzaXZlIiwiaGFzVG9FeGNsdXNpdmUiLCJnZXRVbmlxdWVUcmFpbFRvIiwibm9kZVNldCIsIm5vZGVzIiwiZm9yRWFjaCIsImFkZCIsImhhcyIsImFkZE5vZGVMaXN0ZW5lciIsInJlbW92ZU5vZGVMaXN0ZW5lciIsImZyb21TZWxmIiwidG9TZWxmIiwidXNlQW5jZXN0b3JNYXRyaXgiLCJmcm9tTWF0cml4IiwiZ2V0TWF0cml4Q29uY2F0ZW5hdGlvbiIsInRvTWF0cml4IiwiaW52ZXJ0ZWQiLCJ0aW1lc01hdHJpeCIsInRyYW5zZm9ybUVtaXR0ZXIiLCJkZWxldGUiLCJyZW1vdmVMaXN0ZW5lciIsImRpc3Bvc2UiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIk1hdHJpeEJldHdlZW5Qcm9wZXJ0eS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSBQcm9wZXJ0eSB0aGF0LCBpZiB0aGVyZSBpcyBhIHVuaXF1ZSBwYXRoIGZyb20gb25lIE5vZGUgdG8gYW5vdGhlciAoQSA9PiByb290ID0+IEIsIG9yIEEgPT4gQiwgb3IgQiA9PiBBKSwgd2lsbFxyXG4gKiBjb250YWluIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZnJvbSBBIHRvIEIncyBjb29yZGluYXRlIGZyYW1lIChsb2NhbCBjb29yZGluYXRlIGZyYW1lcyBieSBkZWZhdWx0KS5cclxuICpcclxuICogSWYgdGhlcmUgaXMgbm8gdW5pcXVlIHBhdGgsIHRoZSB2YWx1ZSB3aWxsIGJlIG51bGwuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cclxuICovXHJcblxyXG5pbXBvcnQgVGlueVByb3BlcnR5IGZyb20gJy4uLy4uLy4uL2F4b24vanMvVGlueVByb3BlcnR5LmpzJztcclxuaW1wb3J0IE1hdHJpeDMgZnJvbSAnLi4vLi4vLi4vZG90L2pzL01hdHJpeDMuanMnO1xyXG5pbXBvcnQgYXJyYXlEaWZmZXJlbmNlIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9hcnJheURpZmZlcmVuY2UuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgeyBBbmNlc3Rvck5vZGVzUHJvcGVydHksIE5vZGUsIHNjZW5lcnksIFRyYWlsIH0gZnJvbSAnLi4vaW1wb3J0cy5qcyc7XHJcblxyXG50eXBlIENvb3JkaW5hdGVGcmFtZSA9ICdwYXJlbnQnIHwgJ2xvY2FsJztcclxuXHJcbmV4cG9ydCB0eXBlIE1hdHJpeEJldHdlZW5Qcm9wZXJ0eU9wdGlvbnMgPSB7XHJcbiAgLy8gV2hpY2ggY29vcmRpbmF0ZSBmcmFtZXMgd2Ugd2FudCB0byBiZSBjb252ZXJ0aW5nIGZyb20vdG8sIGZvciBlYWNoIG5vZGVcclxuICBmcm9tQ29vcmRpbmF0ZUZyYW1lPzogQ29vcmRpbmF0ZUZyYW1lO1xyXG4gIHRvQ29vcmRpbmF0ZUZyYW1lPzogQ29vcmRpbmF0ZUZyYW1lO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0cml4QmV0d2VlblByb3BlcnR5IGV4dGVuZHMgVGlueVByb3BlcnR5PE1hdHJpeDMgfCBudWxsPiB7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgZnJvbUFuY2VzdG9yc1Byb3BlcnR5OiBBbmNlc3Rvck5vZGVzUHJvcGVydHk7XHJcbiAgcHJpdmF0ZSByZWFkb25seSB0b0FuY2VzdG9yc1Byb3BlcnR5OiBBbmNlc3Rvck5vZGVzUHJvcGVydHk7XHJcblxyXG4gIC8vIFdoZW4gd2UgaGF2ZSBhIHVuaXF1ZSBjb25uZWN0aW9uIHdpdGggdHJhaWxzLCB0aGlzIHdpbGwgY29udGFpbiB0aGUgcm9vdCBub2RlIGNvbW1vbiB0byBib3RoLlxyXG4gIC8vIE5PVEU6IFRoaXMgbWlnaHQgYmUgb25lIG9mIHRoZSBhY3R1YWwgbm9kZXMgaXRzZWxmLlxyXG4gIHByaXZhdGUgcm9vdE5vZGU6IE5vZGUgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgLy8gV2hlbiB3ZSBoYXZlIGEgdW5pcXVlIGNvbm5lY3Rpb24gd2l0aCB0cmFpbHMsIHRoZXNlIHdpbGwgY29udGFpbiB0aGUgdHJhaWwgdG8gdGhlIHJvb3Qgbm9kZVxyXG4gIHByaXZhdGUgZnJvbVRyYWlsOiBUcmFpbCB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgdG9UcmFpbDogVHJhaWwgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgcHJpdmF0ZSByZWFkb25seSBmcm9tQ29vcmRpbmF0ZUZyYW1lOiBDb29yZGluYXRlRnJhbWU7XHJcbiAgcHJpdmF0ZSByZWFkb25seSB0b0Nvb3JkaW5hdGVGcmFtZTogQ29vcmRpbmF0ZUZyYW1lO1xyXG5cclxuICAvLyBBIHNldCBvZiBub2RlcyB3aGVyZSB3ZSBhcmUgbGlzdGVuaW5nIHRvIHdoZXRoZXIgdGhlaXIgdHJhbnNmb3JtcyBjaGFuZ2VcclxuICBwcml2YXRlIHJlYWRvbmx5IGxpc3RlbmVkTm9kZVNldDogU2V0PE5vZGU+ID0gbmV3IFNldDxOb2RlPigpO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX25vZGVUcmFuc2Zvcm1MaXN0ZW5lcjogKCkgPT4gdm9pZDtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBwdWJsaWMgcmVhZG9ubHkgZnJvbTogTm9kZSwgcHVibGljIHJlYWRvbmx5IHRvOiBOb2RlLCBwcm92aWRlZE9wdGlvbnM/OiBNYXRyaXhCZXR3ZWVuUHJvcGVydHlPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8TWF0cml4QmV0d2VlblByb3BlcnR5T3B0aW9ucz4oKSgge1xyXG4gICAgICBmcm9tQ29vcmRpbmF0ZUZyYW1lOiAnbG9jYWwnLFxyXG4gICAgICB0b0Nvb3JkaW5hdGVGcmFtZTogJ2xvY2FsJ1xyXG4gICAgfSwgcHJvdmlkZWRPcHRpb25zICk7XHJcblxyXG4gICAgc3VwZXIoIE1hdHJpeDMuSURFTlRJVFkgKTtcclxuXHJcbiAgICB0aGlzLmZyb21Db29yZGluYXRlRnJhbWUgPSBvcHRpb25zLmZyb21Db29yZGluYXRlRnJhbWU7XHJcbiAgICB0aGlzLnRvQ29vcmRpbmF0ZUZyYW1lID0gb3B0aW9ucy50b0Nvb3JkaW5hdGVGcmFtZTtcclxuXHJcbiAgICAvLyBJZGVudGljYWwgbWF0cmljZXMgc2hvdWxkbid0IHRyaWdnZXIgbm90aWZpY2F0aW9uc1xyXG4gICAgdGhpcy51c2VEZWVwRXF1YWxpdHkgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuZnJvbUFuY2VzdG9yc1Byb3BlcnR5ID0gbmV3IEFuY2VzdG9yTm9kZXNQcm9wZXJ0eSggZnJvbSApO1xyXG4gICAgdGhpcy50b0FuY2VzdG9yc1Byb3BlcnR5ID0gbmV3IEFuY2VzdG9yTm9kZXNQcm9wZXJ0eSggdG8gKTtcclxuXHJcbiAgICBjb25zdCB1cGRhdGVMaXN0ZW5lciA9IHRoaXMudXBkYXRlLmJpbmQoIHRoaXMgKTtcclxuICAgIHRoaXMuX25vZGVUcmFuc2Zvcm1MaXN0ZW5lciA9IHRoaXMudXBkYXRlTWF0cml4LmJpbmQoIHRoaXMgKTtcclxuXHJcbiAgICAvLyBXZSdsbCBvbmx5IHRyaWdnZXIgYSBmdWxsIHVwZGF0ZSB3aGVuIHBhcmVudHMvYW5jZXN0b3JzIGNoYW5nZSBhbnl3aGVyZS4gT3RoZXJ3aXNlLCB3ZSdsbCBqdXN0IGRvIHRyYW5zZm9ybVxyXG4gICAgLy8gY2hhbmdlcyB3aXRoIHVwZGF0ZU1hdHJpeCgpXHJcbiAgICB0aGlzLmZyb21BbmNlc3RvcnNQcm9wZXJ0eS51cGRhdGVFbWl0dGVyLmFkZExpc3RlbmVyKCB1cGRhdGVMaXN0ZW5lciApO1xyXG4gICAgdGhpcy50b0FuY2VzdG9yc1Byb3BlcnR5LnVwZGF0ZUVtaXR0ZXIuYWRkTGlzdGVuZXIoIHVwZGF0ZUxpc3RlbmVyICk7XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlKCk6IHZvaWQge1xyXG4gICAgLy8gVHJhY2sgbm9kZXMgKG5vdCBqdXN0IGFuY2VzdG9ycykgaGVyZSwgaW4gY2FzZSBvbmUgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIG90aGVyXHJcbiAgICAvLyBSRVZJRVc6IHdvdWxkIGl0IGJlIG1vcmUgcGVyZm9ybWFudCBmb3IgYmVsb3cgb3BwZXJhdGlvbnMgaWYgdGhlc2Ugd2VyZSBTZXRzP1xyXG4gICAgY29uc3QgZnJvbU5vZGVzID0gWyAuLi50aGlzLmZyb21BbmNlc3RvcnNQcm9wZXJ0eS52YWx1ZSwgdGhpcy5mcm9tIF07XHJcbiAgICBjb25zdCB0b05vZGVzID0gWyAuLi50aGlzLnRvQW5jZXN0b3JzUHJvcGVydHkudmFsdWUsIHRoaXMudG8gXTtcclxuXHJcbiAgICAvLyBJbnRlcnNlY3Rpb24gKGFuY2VzdG9ycyBvZiBmcm9tL3RvKVxyXG4gICAgY29uc3QgY29tbW9uTm9kZXMgPSBmcm9tTm9kZXMuZmlsdGVyKCBhID0+IHRvTm9kZXMuaW5jbHVkZXMoIGEgKSApO1xyXG5cclxuICAgIGxldCBoYXNEQUcgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBXZSdsbCB3YW50IHRvIGZpbmQgYWxsIG5vZGVzIHRoYXQgYXJlIGNvbW1vbiBhbmNlc3RvcnMgb2YgYm90aCwgQlVUIGFyZW4ndCBzdXBlcmZsdW91cyAoYW4gYW5jZXN0b3Igb2YgYW5vdGhlclxyXG4gICAgLy8gY29tbW9uIGFuY2VzdG9yLCB3aXRoIG5vIG90aGVyIHBhdGhzKS5cclxuICAgIGNvbnN0IHJvb3ROb2RlcyA9IGNvbW1vbk5vZGVzLmZpbHRlciggbm9kZSA9PiB7XHJcbiAgICAgIGNvbnN0IGZyb21DaGlsZHJlbiA9IGZyb21Ob2Rlcy5maWx0ZXIoIGFOb2RlID0+IG5vZGUuaGFzQ2hpbGQoIGFOb2RlICkgKTtcclxuICAgICAgY29uc3QgdG9DaGlsZHJlbiA9IHRvTm9kZXMuZmlsdGVyKCBiTm9kZSA9PiBub2RlLmhhc0NoaWxkKCBiTm9kZSApICk7XHJcblxyXG4gICAgICBjb25zdCBmcm9tT25seTogTm9kZVtdID0gW107XHJcbiAgICAgIGNvbnN0IHRvT25seTogTm9kZVtdID0gW107XHJcbiAgICAgIGNvbnN0IGJvdGg6IE5vZGVbXSA9IFtdO1xyXG4gICAgICBhcnJheURpZmZlcmVuY2UoIGZyb21DaGlsZHJlbiwgdG9DaGlsZHJlbiwgZnJvbU9ubHksIHRvT25seSwgYm90aCApO1xyXG5cclxuICAgICAgY29uc3QgaGFzTXVsdGlwbGVDaGlsZHJlbiA9IGZyb21DaGlsZHJlbi5sZW5ndGggPiAxIHx8IHRvQ2hpbGRyZW4ubGVuZ3RoID4gMTtcclxuICAgICAgY29uc3QgaGFzVW5zaGFyZWRDaGlsZCA9IGZyb21Pbmx5Lmxlbmd0aCB8fCB0b09ubHkubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gSWYgZWl0aGVyIGhhcyBtdWx0aXBsZSBjaGlsZHJlbiwgQU5EIHdlJ3JlIG5vdCBqdXN0IGEgdHJpdmlhbCBhbmNlc3RvciBvZiB0aGUgcm9vdCwgd2UncmUgaW4gYSBEQUcgY2FzZVxyXG4gICAgICBpZiAoIGhhc011bHRpcGxlQ2hpbGRyZW4gJiYgaGFzVW5zaGFyZWRDaGlsZCApIHtcclxuICAgICAgICBoYXNEQUcgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBoYXNGcm9tRXhjbHVzaXZlID0gZnJvbU9ubHkubGVuZ3RoID4gMCB8fCB0aGlzLmZyb20gPT09IG5vZGU7XHJcbiAgICAgIGNvbnN0IGhhc1RvRXhjbHVzaXZlID0gdG9Pbmx5Lmxlbmd0aCA+IDAgfHwgdGhpcy50byA9PT0gbm9kZTtcclxuXHJcbiAgICAgIHJldHVybiBoYXNGcm9tRXhjbHVzaXZlICYmIGhhc1RvRXhjbHVzaXZlO1xyXG4gICAgfSApO1xyXG5cclxuICAgIGlmICggIWhhc0RBRyAmJiByb290Tm9kZXMubGVuZ3RoID09PSAxICkge1xyXG4gICAgICAvLyBXZSBoYXZlIGEgcm9vdCBub2RlLCBhbmQgc2hvdWxkIGhhdmUgdW5pcXVlIHRyYWlscyFcclxuICAgICAgdGhpcy5yb290Tm9kZSA9IHJvb3ROb2Rlc1sgMCBdO1xyXG5cclxuICAgICAgLy8gVGhlc2Ugc2hvdWxkIGFzc2VydC1lcnJvciBvdXQgaWYgdGhlcmUgaXMgbm8gdW5pcXVlIHRyYWlsIGZvciBlaXRoZXJcclxuICAgICAgdGhpcy5mcm9tVHJhaWwgPSB0aGlzLmZyb20uZ2V0VW5pcXVlVHJhaWxUbyggdGhpcy5yb290Tm9kZSApO1xyXG4gICAgICB0aGlzLnRvVHJhaWwgPSB0aGlzLnRvLmdldFVuaXF1ZVRyYWlsVG8oIHRoaXMucm9vdE5vZGUgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICB0aGlzLnJvb3ROb2RlID0gbnVsbDtcclxuICAgICAgdGhpcy5mcm9tVHJhaWwgPSBudWxsO1xyXG4gICAgICB0aGlzLnRvVHJhaWwgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRha2Ugbm90ZSBvZiB0aGUgbm9kZXMgd2UgYXJlIGxpc3RlbmluZyB0b1xyXG4gICAgY29uc3Qgbm9kZVNldCA9IG5ldyBTZXQ8Tm9kZT4oKTtcclxuICAgIHRoaXMuZnJvbVRyYWlsICYmIHRoaXMuZnJvbVRyYWlsLm5vZGVzLmZvckVhY2goIG5vZGUgPT4gbm9kZVNldC5hZGQoIG5vZGUgKSApO1xyXG4gICAgdGhpcy50b1RyYWlsICYmIHRoaXMudG9UcmFpbC5ub2Rlcy5mb3JFYWNoKCBub2RlID0+IG5vZGVTZXQuYWRkKCBub2RlICkgKTtcclxuXHJcbiAgICAvLyBBZGQgaW4gbmV3IG5lZWRlZCBsaXN0ZW5lcnNcclxuICAgIG5vZGVTZXQuZm9yRWFjaCggbm9kZSA9PiB7XHJcbiAgICAgIGlmICggIXRoaXMubGlzdGVuZWROb2RlU2V0Lmhhcyggbm9kZSApICkge1xyXG4gICAgICAgIHRoaXMuYWRkTm9kZUxpc3RlbmVyKCBub2RlICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgbGlzdGVuZXJzIG5vdCBuZWVkZWQgYW55bW9yZVxyXG4gICAgdGhpcy5saXN0ZW5lZE5vZGVTZXQuZm9yRWFjaCggbm9kZSA9PiB7XHJcbiAgICAgIGlmICggIW5vZGVTZXQuaGFzKCBub2RlICkgJiYgbm9kZSAhPT0gdGhpcy5mcm9tICYmIG5vZGUgIT09IHRoaXMudG8gKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVOb2RlTGlzdGVuZXIoIG5vZGUgKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZU1hdHJpeCgpOiB2b2lkIHtcclxuICAgIGlmICggdGhpcy5yb290Tm9kZSAmJiB0aGlzLmZyb21UcmFpbCAmJiB0aGlzLnRvVHJhaWwgKSB7XHJcblxyXG4gICAgICAvLyBJZiBvbmUgb2YgdGhlc2UgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIG90aGVyIEFORCB0aGUgYW5jZXN0b3IgcmVxdWVzdHMgYSBcInBhcmVudFwiIGNvb3JkaW5hdGUgZnJhbWUsIHdlJ2xsIG5lZWRcclxuICAgICAgLy8gdG8gY29tcHV0ZSB0aGluZ3MgdG8gdGhlIG5leHQgbGV2ZWwgdXAuIE90aGVyd2lzZSwgd2UgY2FuIGlnbm9yZSB0aGUgcm9vdCBub2RlJ3MgdHJhbnNmb3JtLiBUaGlzIGlzIE5PVFxyXG4gICAgICAvLyBqdXN0IGFuIG9wdGltaXphdGlvbiwgc2luY2UgaWYgd2UgbXVsdGlwbHkgaW4gdGhlIHJvb3Qgbm9kZSdzIHRyYW5zZm9ybSBpbnRvIGJvdGggdGhlIGZyb21NYXRyaXggYW5kIHRvTWF0cml4LFxyXG4gICAgICAvLyB3ZSdsbCBsZWFkIHRvIG51bWVyaWNhbCBpbXByZWNpc2lvbiB0aGF0IGNvdWxkIGJlIGF2b2lkZWQuIFdpdGggdGhpcywgd2UgY2FuIGdldCBwcmVjaXNlL2V4YWN0IHJlc3VsdHMsIGV2ZW5cclxuICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzY2FsZSBvbiB0aGUgcm9vdE5vZGUgKGltYWdpbmUgYSBTY3JlZW5WaWV3J3MgdHJhbnNmb3JtKS5cclxuICAgICAgY29uc3QgZnJvbVNlbGYgPSB0aGlzLmZyb21UcmFpbC5ub2Rlcy5sZW5ndGggPT09IDE7XHJcbiAgICAgIGNvbnN0IHRvU2VsZiA9IHRoaXMudG9UcmFpbC5ub2Rlcy5sZW5ndGggPT09IDE7XHJcbiAgICAgIGNvbnN0IHVzZUFuY2VzdG9yTWF0cml4ID0gKCBmcm9tU2VsZiAmJiB0aGlzLmZyb21Db29yZGluYXRlRnJhbWUgPT09ICdwYXJlbnQnICkgfHwgKCB0b1NlbGYgJiYgdGhpcy50b0Nvb3JkaW5hdGVGcmFtZSA9PT0gJ3BhcmVudCcgKTtcclxuXHJcbiAgICAgIC8vIEluc3RlYWQgb2Ygc3dpdGNoaW5nIGJldHdlZW4gNCBkaWZmZXJlbnQgbWF0cml4IGZ1bmN0aW9ucywgd2UgdXNlIHRoZSBnZW5lcmFsIGZvcm0uXHJcbiAgICAgIGNvbnN0IGZyb21NYXRyaXggPSB0aGlzLmZyb21UcmFpbC5nZXRNYXRyaXhDb25jYXRlbmF0aW9uKFxyXG4gICAgICAgIHVzZUFuY2VzdG9yTWF0cml4ID8gMCA6IDEsXHJcbiAgICAgICAgdGhpcy5mcm9tVHJhaWwubm9kZXMubGVuZ3RoIC0gKCB0aGlzLmZyb21Db29yZGluYXRlRnJhbWUgPT09ICdwYXJlbnQnID8gMSA6IDAgKVxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCB0b01hdHJpeCA9IHRoaXMudG9UcmFpbC5nZXRNYXRyaXhDb25jYXRlbmF0aW9uKFxyXG4gICAgICAgIHVzZUFuY2VzdG9yTWF0cml4ID8gMCA6IDEsXHJcbiAgICAgICAgdGhpcy50b1RyYWlsLm5vZGVzLmxlbmd0aCAtICggdGhpcy50b0Nvb3JkaW5hdGVGcmFtZSA9PT0gJ3BhcmVudCcgPyAxIDogMCApXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyB0b1BvaW50ID0gdG9NYXRyaXheLTEgKiBmcm9tTWF0cml4ICogZnJvbVBvaW50XHJcbiAgICAgIHRoaXMudmFsdWUgPSB0b01hdHJpeC5pbnZlcnRlZCgpLnRpbWVzTWF0cml4KCBmcm9tTWF0cml4ICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFkZE5vZGVMaXN0ZW5lciggbm9kZTogTm9kZSApOiB2b2lkIHtcclxuICAgIHRoaXMubGlzdGVuZWROb2RlU2V0LmFkZCggbm9kZSApO1xyXG4gICAgbm9kZS50cmFuc2Zvcm1FbWl0dGVyLmFkZExpc3RlbmVyKCB0aGlzLl9ub2RlVHJhbnNmb3JtTGlzdGVuZXIgKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVtb3ZlTm9kZUxpc3RlbmVyKCBub2RlOiBOb2RlICk6IHZvaWQge1xyXG4gICAgdGhpcy5saXN0ZW5lZE5vZGVTZXQuZGVsZXRlKCBub2RlICk7XHJcbiAgICBub2RlLnRyYW5zZm9ybUVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIHRoaXMuX25vZGVUcmFuc2Zvcm1MaXN0ZW5lciApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLmZyb21BbmNlc3RvcnNQcm9wZXJ0eS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLnRvQW5jZXN0b3JzUHJvcGVydHkuZGlzcG9zZSgpO1xyXG5cclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbnNjZW5lcnkucmVnaXN0ZXIoICdNYXRyaXhCZXR3ZWVuUHJvcGVydHknLCBNYXRyaXhCZXR3ZWVuUHJvcGVydHkgKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFlBQVksTUFBTSxrQ0FBa0M7QUFDM0QsT0FBT0MsT0FBTyxNQUFNLDRCQUE0QjtBQUNoRCxPQUFPQyxlQUFlLE1BQU0sMENBQTBDO0FBQ3RFLE9BQU9DLFNBQVMsTUFBTSxvQ0FBb0M7QUFDMUQsU0FBU0MscUJBQXFCLEVBQVFDLE9BQU8sUUFBZSxlQUFlO0FBVTNFLGVBQWUsTUFBTUMscUJBQXFCLFNBQVNOLFlBQVksQ0FBaUI7RUFLOUU7RUFDQTtFQUNRTyxRQUFRLEdBQWdCLElBQUk7O0VBRXBDO0VBQ1FDLFNBQVMsR0FBaUIsSUFBSTtFQUM5QkMsT0FBTyxHQUFpQixJQUFJO0VBS3BDO0VBQ2lCQyxlQUFlLEdBQWMsSUFBSUMsR0FBRyxDQUFPLENBQUM7RUFHdERDLFdBQVdBLENBQWtCQyxJQUFVLEVBQWtCQyxFQUFRLEVBQUVDLGVBQThDLEVBQUc7SUFFekgs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