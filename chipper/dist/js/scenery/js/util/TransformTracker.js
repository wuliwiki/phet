// Copyright 2015-2022, University of Colorado Boulder

/**
 * Used for identifying when any ancestor transform of a node in a trail causes that node's global transform to change.
 * It also provides fast computation of that global matrix, NOT recomputing every matrix, even on most transform
 * changes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Jesse Greenberg
 */

import Matrix3 from '../../../dot/js/Matrix3.js';
import optionize from '../../../phet-core/js/optionize.js';
import { scenery } from '../imports.js';
class TransformTracker {
  // this._matrices[ i ] will be equal to: trail.nodes[ 1 ].matrix * ... * trail.nodes[ i + 1 ].matrix
  // Will be initialized on first need.
  _matrices = null;

  // this._matrices[ i ] where i >= this._dirtyIndex will need to be recomputed
  _dirtyIndex = 0;

  // Listeners added by client, will be called on transform changes.
  _listeners = [];

  // Listeners to each Node in the trail (so we are notified of changes). Will be removed on disposal.
  _nodeTransformListeners = [];
  /**
   * Creates a transform-tracking object, where it can send out updates on transform changes, and also efficiently
   * compute the transform.
   */
  constructor(trail, providedOptions) {
    const options = optionize()({
      isStatic: false
    }, providedOptions);
    this._isStatic = options.isStatic;
    this.trail = trail;

    // Hook up listeners to each Node in the trail
    this._nodeTransformListeners = [];
    for (let j = 1; j < this.trail.length; j++) {
      // Wrapping with closure to prevent changes
      const nodeTransformListener = (index => () => {
        this.onTransformChange(index);
      })(j - 1);
      this._nodeTransformListeners.push(nodeTransformListener);
      trail.nodes[j].transformEmitter.addListener(nodeTransformListener);
    }
  }

  /**
   * Gets rid of all external references and listeners. This object is inoperable afterwards.
   */
  dispose() {
    for (let j = 1; j < this.trail.length; j++) {
      const nodeTransformListener = this._nodeTransformListeners[j - 1];
      if (this.trail.nodes[j].transformEmitter.hasListener(nodeTransformListener)) {
        this.trail.nodes[j].transformEmitter.removeListener(nodeTransformListener);
      }
    }
  }

  /**
   * Adds a listener function that will be synchronously called whenever the transform for this Trail changes.
   */
  addListener(listener) {
    this._listeners.push(listener);
  }

  /**
   * Removes a listener that was previously added with addListener().
   */
  removeListener(listener) {
    const index = _.indexOf(this._listeners, listener);
    assert && assert(index >= 0, 'TransformTracker listener not found');
    this._listeners.splice(index, 1);
  }

  /**
   * Notifies listeners of a transform change.
   */
  notifyListeners() {
    let listeners = this._listeners;
    if (!this._isStatic) {
      listeners = listeners.slice();
    }
    const length = listeners.length;
    for (let i = 0; i < length; i++) {
      listeners[i]();
    }
  }

  /**
   * Called when one of the nodes' transforms is changed.
   *
   * @param matrixIndex - The index into our matrices array, e.g. this._matrices[ matrixIndex ].
   */
  onTransformChange(matrixIndex) {
    this._dirtyIndex = Math.min(this._dirtyIndex, matrixIndex);
    this.notifyListeners();
  }

  /**
   * Returns the local-to-global transformation matrix for the Trail, which transforms its leaf node's local
   * coordinate frame into the global coordinate frame.
   *
   * NOTE: The matrix returned should not be mutated. Please make a copy if needed.
   */
  getMatrix() {
    if (this._matrices === null) {
      this._matrices = [];

      // Start at 1, so that we don't include the root node's transform
      for (let i = 1; i < this.trail.length; i++) {
        this._matrices.push(new Matrix3());
      }
    }

    // If the trail isn't long enough to have a transform, return the identity matrix
    if (this._matrices.length <= 0) {
      return Matrix3.IDENTITY;
    }

    // Starting at the dirty index, recompute matrices.
    const numMatrices = this._matrices.length;
    for (let index = this._dirtyIndex; index < numMatrices; index++) {
      const nodeMatrix = this.trail.nodes[index + 1].matrix;
      if (index === 0) {
        this._matrices[index].set(nodeMatrix);
      } else {
        this._matrices[index].set(this._matrices[index - 1]);
        this._matrices[index].multiplyMatrix(nodeMatrix);
      }
    }

    // Reset the dirty index to mark all matrices as 'clean'.
    this._dirtyIndex = numMatrices;

    // Return the last matrix, which contains our composite transformation.
    return this._matrices[numMatrices - 1];
  }
  get matrix() {
    return this.getMatrix();
  }
}
scenery.register('TransformTracker', TransformTracker);
export default TransformTracker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNYXRyaXgzIiwib3B0aW9uaXplIiwic2NlbmVyeSIsIlRyYW5zZm9ybVRyYWNrZXIiLCJfbWF0cmljZXMiLCJfZGlydHlJbmRleCIsIl9saXN0ZW5lcnMiLCJfbm9kZVRyYW5zZm9ybUxpc3RlbmVycyIsImNvbnN0cnVjdG9yIiwidHJhaWwiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwiaXNTdGF0aWMiLCJfaXNTdGF0aWMiLCJqIiwibGVuZ3RoIiwibm9kZVRyYW5zZm9ybUxpc3RlbmVyIiwiaW5kZXgiLCJvblRyYW5zZm9ybUNoYW5nZSIsInB1c2giLCJub2RlcyIsInRyYW5zZm9ybUVtaXR0ZXIiLCJhZGRMaXN0ZW5lciIsImRpc3Bvc2UiLCJoYXNMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwibGlzdGVuZXIiLCJfIiwiaW5kZXhPZiIsImFzc2VydCIsInNwbGljZSIsIm5vdGlmeUxpc3RlbmVycyIsImxpc3RlbmVycyIsInNsaWNlIiwiaSIsIm1hdHJpeEluZGV4IiwiTWF0aCIsIm1pbiIsImdldE1hdHJpeCIsIklERU5USVRZIiwibnVtTWF0cmljZXMiLCJub2RlTWF0cml4IiwibWF0cml4Iiwic2V0IiwibXVsdGlwbHlNYXRyaXgiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlRyYW5zZm9ybVRyYWNrZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVXNlZCBmb3IgaWRlbnRpZnlpbmcgd2hlbiBhbnkgYW5jZXN0b3IgdHJhbnNmb3JtIG9mIGEgbm9kZSBpbiBhIHRyYWlsIGNhdXNlcyB0aGF0IG5vZGUncyBnbG9iYWwgdHJhbnNmb3JtIHRvIGNoYW5nZS5cclxuICogSXQgYWxzbyBwcm92aWRlcyBmYXN0IGNvbXB1dGF0aW9uIG9mIHRoYXQgZ2xvYmFsIG1hdHJpeCwgTk9UIHJlY29tcHV0aW5nIGV2ZXJ5IG1hdHJpeCwgZXZlbiBvbiBtb3N0IHRyYW5zZm9ybVxyXG4gKiBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbmF0aGFuIE9sc29uIDxqb25hdGhhbi5vbHNvbkBjb2xvcmFkby5lZHU+XHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnXHJcbiAqL1xyXG5cclxuaW1wb3J0IE1hdHJpeDMgZnJvbSAnLi4vLi4vLi4vZG90L2pzL01hdHJpeDMuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgeyBzY2VuZXJ5LCBUcmFpbCB9IGZyb20gJy4uL2ltcG9ydHMuanMnO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuICAvLyBXaGV0aGVyIHRoZSBib3VuZHMgbGlzdGVuZXJzIHNob3VsZCBiZSBhZGRlZCB3aXRoIG9uKCkgb3Igb25TdGF0aWMoKS5cclxuICBpc1N0YXRpYz86IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBUcmFuc2Zvcm1UcmFja2VyT3B0aW9ucyA9IFNlbGZPcHRpb25zO1xyXG5cclxuY2xhc3MgVHJhbnNmb3JtVHJhY2tlciB7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgdHJhaWw6IFRyYWlsO1xyXG5cclxuICAvLyB0aGlzLl9tYXRyaWNlc1sgaSBdIHdpbGwgYmUgZXF1YWwgdG86IHRyYWlsLm5vZGVzWyAxIF0ubWF0cml4ICogLi4uICogdHJhaWwubm9kZXNbIGkgKyAxIF0ubWF0cml4XHJcbiAgLy8gV2lsbCBiZSBpbml0aWFsaXplZCBvbiBmaXJzdCBuZWVkLlxyXG4gIHByaXZhdGUgX21hdHJpY2VzOiBNYXRyaXgzW10gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgLy8gdGhpcy5fbWF0cmljZXNbIGkgXSB3aGVyZSBpID49IHRoaXMuX2RpcnR5SW5kZXggd2lsbCBuZWVkIHRvIGJlIHJlY29tcHV0ZWRcclxuICBwcml2YXRlIF9kaXJ0eUluZGV4ID0gMDtcclxuXHJcbiAgLy8gTGlzdGVuZXJzIGFkZGVkIGJ5IGNsaWVudCwgd2lsbCBiZSBjYWxsZWQgb24gdHJhbnNmb3JtIGNoYW5nZXMuXHJcbiAgcHJpdmF0ZSBfbGlzdGVuZXJzOiAoICgpID0+IHZvaWQgKVtdID0gW107XHJcblxyXG4gIC8vIExpc3RlbmVycyB0byBlYWNoIE5vZGUgaW4gdGhlIHRyYWlsIChzbyB3ZSBhcmUgbm90aWZpZWQgb2YgY2hhbmdlcykuIFdpbGwgYmUgcmVtb3ZlZCBvbiBkaXNwb3NhbC5cclxuICBwcml2YXRlIHJlYWRvbmx5IF9ub2RlVHJhbnNmb3JtTGlzdGVuZXJzOiAoICgpID0+IHZvaWQgKVtdID0gW107XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2lzU3RhdGljOiBib29sZWFuO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgdHJhbnNmb3JtLXRyYWNraW5nIG9iamVjdCwgd2hlcmUgaXQgY2FuIHNlbmQgb3V0IHVwZGF0ZXMgb24gdHJhbnNmb3JtIGNoYW5nZXMsIGFuZCBhbHNvIGVmZmljaWVudGx5XHJcbiAgICogY29tcHV0ZSB0aGUgdHJhbnNmb3JtLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggdHJhaWw6IFRyYWlsLCBwcm92aWRlZE9wdGlvbnM/OiBUcmFuc2Zvcm1UcmFja2VyT3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPFRyYW5zZm9ybVRyYWNrZXJPcHRpb25zLCBTZWxmT3B0aW9ucz4oKSgge1xyXG4gICAgICBpc1N0YXRpYzogZmFsc2VcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMuX2lzU3RhdGljID0gb3B0aW9ucy5pc1N0YXRpYztcclxuICAgIHRoaXMudHJhaWwgPSB0cmFpbDtcclxuXHJcbiAgICAvLyBIb29rIHVwIGxpc3RlbmVycyB0byBlYWNoIE5vZGUgaW4gdGhlIHRyYWlsXHJcbiAgICB0aGlzLl9ub2RlVHJhbnNmb3JtTGlzdGVuZXJzID0gW107XHJcbiAgICBmb3IgKCBsZXQgaiA9IDE7IGogPCB0aGlzLnRyYWlsLmxlbmd0aDsgaisrICkge1xyXG4gICAgICAvLyBXcmFwcGluZyB3aXRoIGNsb3N1cmUgdG8gcHJldmVudCBjaGFuZ2VzXHJcbiAgICAgIGNvbnN0IG5vZGVUcmFuc2Zvcm1MaXN0ZW5lciA9ICggaW5kZXggPT4gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMub25UcmFuc2Zvcm1DaGFuZ2UoIGluZGV4ICk7XHJcbiAgICAgIH0gKSggaiAtIDEgKTtcclxuXHJcbiAgICAgIHRoaXMuX25vZGVUcmFuc2Zvcm1MaXN0ZW5lcnMucHVzaCggbm9kZVRyYW5zZm9ybUxpc3RlbmVyICk7XHJcblxyXG4gICAgICB0cmFpbC5ub2Rlc1sgaiBdLnRyYW5zZm9ybUVtaXR0ZXIuYWRkTGlzdGVuZXIoIG5vZGVUcmFuc2Zvcm1MaXN0ZW5lciApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyByaWQgb2YgYWxsIGV4dGVybmFsIHJlZmVyZW5jZXMgYW5kIGxpc3RlbmVycy4gVGhpcyBvYmplY3QgaXMgaW5vcGVyYWJsZSBhZnRlcndhcmRzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgZm9yICggbGV0IGogPSAxOyBqIDwgdGhpcy50cmFpbC5sZW5ndGg7IGorKyApIHtcclxuICAgICAgY29uc3Qgbm9kZVRyYW5zZm9ybUxpc3RlbmVyID0gdGhpcy5fbm9kZVRyYW5zZm9ybUxpc3RlbmVyc1sgaiAtIDEgXTtcclxuXHJcbiAgICAgIGlmICggdGhpcy50cmFpbC5ub2Rlc1sgaiBdLnRyYW5zZm9ybUVtaXR0ZXIuaGFzTGlzdGVuZXIoIG5vZGVUcmFuc2Zvcm1MaXN0ZW5lciApICkge1xyXG4gICAgICAgIHRoaXMudHJhaWwubm9kZXNbIGogXS50cmFuc2Zvcm1FbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCBub2RlVHJhbnNmb3JtTGlzdGVuZXIgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBzeW5jaHJvbm91c2x5IGNhbGxlZCB3aGVuZXZlciB0aGUgdHJhbnNmb3JtIGZvciB0aGlzIFRyYWlsIGNoYW5nZXMuXHJcbiAgICovXHJcbiAgcHVibGljIGFkZExpc3RlbmVyKCBsaXN0ZW5lcjogKCkgPT4gdm9pZCApOiB2b2lkIHtcclxuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKCBsaXN0ZW5lciApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgYWRkZWQgd2l0aCBhZGRMaXN0ZW5lcigpLlxyXG4gICAqL1xyXG4gIHB1YmxpYyByZW1vdmVMaXN0ZW5lciggbGlzdGVuZXI6ICgpID0+IHZvaWQgKTogdm9pZCB7XHJcbiAgICBjb25zdCBpbmRleCA9IF8uaW5kZXhPZiggdGhpcy5fbGlzdGVuZXJzLCBsaXN0ZW5lciApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggaW5kZXggPj0gMCwgJ1RyYW5zZm9ybVRyYWNrZXIgbGlzdGVuZXIgbm90IGZvdW5kJyApO1xyXG5cclxuICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoIGluZGV4LCAxICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3RpZmllcyBsaXN0ZW5lcnMgb2YgYSB0cmFuc2Zvcm0gY2hhbmdlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgbm90aWZ5TGlzdGVuZXJzKCk6IHZvaWQge1xyXG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHJcbiAgICBpZiAoICF0aGlzLl9pc1N0YXRpYyApIHtcclxuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDtcclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xyXG4gICAgICBsaXN0ZW5lcnNbIGkgXSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gb25lIG9mIHRoZSBub2RlcycgdHJhbnNmb3JtcyBpcyBjaGFuZ2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG1hdHJpeEluZGV4IC0gVGhlIGluZGV4IGludG8gb3VyIG1hdHJpY2VzIGFycmF5LCBlLmcuIHRoaXMuX21hdHJpY2VzWyBtYXRyaXhJbmRleCBdLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgb25UcmFuc2Zvcm1DaGFuZ2UoIG1hdHJpeEluZGV4OiBudW1iZXIgKTogdm9pZCB7XHJcbiAgICB0aGlzLl9kaXJ0eUluZGV4ID0gTWF0aC5taW4oIHRoaXMuX2RpcnR5SW5kZXgsIG1hdHJpeEluZGV4ICk7XHJcbiAgICB0aGlzLm5vdGlmeUxpc3RlbmVycygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbG9jYWwtdG8tZ2xvYmFsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBmb3IgdGhlIFRyYWlsLCB3aGljaCB0cmFuc2Zvcm1zIGl0cyBsZWFmIG5vZGUncyBsb2NhbFxyXG4gICAqIGNvb3JkaW5hdGUgZnJhbWUgaW50byB0aGUgZ2xvYmFsIGNvb3JkaW5hdGUgZnJhbWUuXHJcbiAgICpcclxuICAgKiBOT1RFOiBUaGUgbWF0cml4IHJldHVybmVkIHNob3VsZCBub3QgYmUgbXV0YXRlZC4gUGxlYXNlIG1ha2UgYSBjb3B5IGlmIG5lZWRlZC5cclxuICAgKi9cclxuICBwdWJsaWMgZ2V0TWF0cml4KCk6IE1hdHJpeDMge1xyXG4gICAgaWYgKCB0aGlzLl9tYXRyaWNlcyA9PT0gbnVsbCApIHtcclxuICAgICAgdGhpcy5fbWF0cmljZXMgPSBbXTtcclxuXHJcbiAgICAgIC8vIFN0YXJ0IGF0IDEsIHNvIHRoYXQgd2UgZG9uJ3QgaW5jbHVkZSB0aGUgcm9vdCBub2RlJ3MgdHJhbnNmb3JtXHJcbiAgICAgIGZvciAoIGxldCBpID0gMTsgaSA8IHRoaXMudHJhaWwubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgdGhpcy5fbWF0cmljZXMucHVzaCggbmV3IE1hdHJpeDMoKSApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIHRyYWlsIGlzbid0IGxvbmcgZW5vdWdoIHRvIGhhdmUgYSB0cmFuc2Zvcm0sIHJldHVybiB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAgICBpZiAoIHRoaXMuX21hdHJpY2VzLmxlbmd0aCA8PSAwICkge1xyXG4gICAgICByZXR1cm4gTWF0cml4My5JREVOVElUWTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGFydGluZyBhdCB0aGUgZGlydHkgaW5kZXgsIHJlY29tcHV0ZSBtYXRyaWNlcy5cclxuICAgIGNvbnN0IG51bU1hdHJpY2VzID0gdGhpcy5fbWF0cmljZXMubGVuZ3RoO1xyXG4gICAgZm9yICggbGV0IGluZGV4ID0gdGhpcy5fZGlydHlJbmRleDsgaW5kZXggPCBudW1NYXRyaWNlczsgaW5kZXgrKyApIHtcclxuICAgICAgY29uc3Qgbm9kZU1hdHJpeCA9IHRoaXMudHJhaWwubm9kZXNbIGluZGV4ICsgMSBdLm1hdHJpeDtcclxuXHJcbiAgICAgIGlmICggaW5kZXggPT09IDAgKSB7XHJcbiAgICAgICAgdGhpcy5fbWF0cmljZXNbIGluZGV4IF0uc2V0KCBub2RlTWF0cml4ICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fbWF0cmljZXNbIGluZGV4IF0uc2V0KCB0aGlzLl9tYXRyaWNlc1sgaW5kZXggLSAxIF0gKTtcclxuICAgICAgICB0aGlzLl9tYXRyaWNlc1sgaW5kZXggXS5tdWx0aXBseU1hdHJpeCggbm9kZU1hdHJpeCApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgdGhlIGRpcnR5IGluZGV4IHRvIG1hcmsgYWxsIG1hdHJpY2VzIGFzICdjbGVhbicuXHJcbiAgICB0aGlzLl9kaXJ0eUluZGV4ID0gbnVtTWF0cmljZXM7XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBsYXN0IG1hdHJpeCwgd2hpY2ggY29udGFpbnMgb3VyIGNvbXBvc2l0ZSB0cmFuc2Zvcm1hdGlvbi5cclxuICAgIHJldHVybiB0aGlzLl9tYXRyaWNlc1sgbnVtTWF0cmljZXMgLSAxIF07XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IG1hdHJpeCgpOiBNYXRyaXgzIHsgcmV0dXJuIHRoaXMuZ2V0TWF0cml4KCk7IH1cclxufVxyXG5cclxuc2NlbmVyeS5yZWdpc3RlciggJ1RyYW5zZm9ybVRyYWNrZXInLCBUcmFuc2Zvcm1UcmFja2VyICk7XHJcbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybVRyYWNrZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLE9BQU8sTUFBTSw0QkFBNEI7QUFDaEQsT0FBT0MsU0FBUyxNQUFNLG9DQUFvQztBQUMxRCxTQUFTQyxPQUFPLFFBQWUsZUFBZTtBQVM5QyxNQUFNQyxnQkFBZ0IsQ0FBQztFQUlyQjtFQUNBO0VBQ1FDLFNBQVMsR0FBcUIsSUFBSTs7RUFFMUM7RUFDUUMsV0FBVyxHQUFHLENBQUM7O0VBRXZCO0VBQ1FDLFVBQVUsR0FBcUIsRUFBRTs7RUFFekM7RUFDaUJDLHVCQUF1QixHQUFxQixFQUFFO0VBSS9EO0FBQ0Y7QUFDQTtBQUNBO0VBQ1NDLFdBQVdBLENBQUVDLEtBQVksRUFBRUMsZUFBeUMsRUFBRztJQUU1RSxNQUFNQyxPQUFPLEdBQUdWLFNBQVMsQ0FBdUMsQ0FBQyxDQUFFO01BQ2pFVyxRQUFRLEVBQUU7SUFDWixDQUFDLEVBQUVGLGVBQWdCLENBQUM7SUFFcEIsSUFBSSxDQUFDRyxTQUFTLEdBQUdGLE9BQU8sQ0FBQ0MsUUFBUTtJQUNqQyxJQUFJLENBQUNILEtBQUssR0FBR0EsS0FBSzs7SUFFbEI7SUFDQSxJQUFJLENBQUNGLHVC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