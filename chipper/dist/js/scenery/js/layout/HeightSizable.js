// Copyright 2021-2023, University of Colorado Boulder

/**
 * HeightSizable is a trait that provides a minimum and preferred height. The minimum height is set by the component,
 * so that layout containers could know how "small" the component can be made. The preferred height is set by the
 * layout container, and the component should adjust its size so that it takes up that height.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import TinyProperty from '../../../axon/js/TinyProperty.js';
import memoize from '../../../phet-core/js/memoize.js';
import { DelayedMutate, Node, REQUIRES_BOUNDS_OPTION_KEYS, scenery } from '../imports.js';
// Position changes smaller than this will be ignored
const CHANGE_POSITION_THRESHOLD = 1e-9;
export const HEIGHT_SIZABLE_OPTION_KEYS = ['preferredHeight', 'minimumHeight', 'localPreferredHeight', 'localMinimumHeight', 'heightSizable'];
// IMPORTANT: If you're combining this in, typically don't pass options that HeightSizable would take through the
// constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
// values yet. If you're making something HeightSizable, please use a later mutate() to pass these options through.
// They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
// is yet passing those options through.
const HeightSizable = memoize(type => {
  const HeightSizableTrait = DelayedMutate('HeightSizable', HEIGHT_SIZABLE_OPTION_KEYS, class HeightSizableTrait extends type {
    // parent/local preferred/minimum Properties. See the options above for more documentation
    preferredHeightProperty = new TinyProperty(null);
    minimumHeightProperty = new TinyProperty(null);
    localPreferredHeightProperty = new TinyProperty(null);
    localMinimumHeightProperty = new TinyProperty(null);
    isHeightResizableProperty = new TinyProperty(true);

    // Flags so that we can change one (parent/local) value and not enter an infinite loop changing the others.
    // We want to lock out all other local or non-local preferred minimum sizes, whether in HeightSizable or WidthSizable
    // NOTE: We are merging declarations between HeightSizable and WidthSizable. If Sizable is used these flags
    // will be shared by both HeightSizable and WidthSizable.
    _preferredSizeChanging = false;
    _minimumSizeChanging = false;

    // We'll need to detect reentrancy when setting the dual of the preferred/minimum properties (e.g. local vs parent).
    // If we get a reentrant case, we'll need to detect it and clear things up at the end (updating the minimum size
    // in the parent coordinate frame, and the preferred size in the local coordinate frame).
    // An example is if the minimum size is set, and that triggers a listener that UPDATES something that changes the
    // minimum size, we'll need to make sure that the local minimum size is updated AFTER everything has happened.
    // These locks are used to detect these cases, and then run the appropriate updates afterward to make sure that the
    // local and parent values are in sync (based on the transform used).
    _preferredSizeChangeAttemptDuringLock = false;
    _minimumSizeChangeAttemptDuringLock = false;

    // Expose listeners, so that we'll be able to hook them up to the opposite dimension in Sizable

    // IMPORTANT: If you're combining this in, typically don't pass options that HeightSizable would take through the
    // constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
    // values yet. If you're making something HeightSizable, please use a later mutate() to pass these options through.
    // They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
    // is yet passing those options through.
    constructor(...args) {
      super(...args);
      this._updatePreferredHeightListener = this._updatePreferredHeight.bind(this);
      this._updateLocalPreferredHeightListener = this._updateLocalPreferredHeight.bind(this);
      this._updateMinimumHeightListener = this._updateMinimumHeight.bind(this);
      this._updateLocalMinimumHeightListener = this._updateLocalMinimumHeight.bind(this);

      // Update the opposite of parent/local when one changes
      this.preferredHeightProperty.lazyLink(this._updateLocalPreferredHeightListener);
      this.localPreferredHeightProperty.lazyLink(this._updatePreferredHeightListener);
      this.minimumHeightProperty.lazyLink(this._updateLocalMinimumHeightListener);
      this.localMinimumHeightProperty.lazyLink(this._updateMinimumHeightListener);

      // On a transform change, keep our local minimum (presumably unchanged), and our parent preferred size
      this.transformEmitter.addListener(this._updateLocalPreferredHeightListener);
      // On a transform change this should update the minimum
      this.transformEmitter.addListener(this._updateMinimumHeightListener);
    }
    get preferredHeight() {
      assert && assert(this.preferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      return this.preferredHeightProperty.value;
    }
    set preferredHeight(value) {
      assert && assert(this.preferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'preferredHeight should be null or a non-negative finite number');
      this.preferredHeightProperty.value = value;
    }
    get localPreferredHeight() {
      assert && assert(this.localPreferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      return this.localPreferredHeightProperty.value;
    }
    set localPreferredHeight(value) {
      assert && assert(this.localPreferredHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'localPreferredHeight should be null or a non-negative finite number');
      this.localPreferredHeightProperty.value = value;
    }
    get minimumHeight() {
      assert && assert(this.minimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      return this.minimumHeightProperty.value;
    }
    set minimumHeight(value) {
      assert && assert(this.minimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value));
      this.minimumHeightProperty.value = value;
    }
    get localMinimumHeight() {
      assert && assert(this.localMinimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      return this.localMinimumHeightProperty.value;
    }
    set localMinimumHeight(value) {
      assert && assert(this.localMinimumHeightProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value));
      this.localMinimumHeightProperty.value = value;
    }
    get heightSizable() {
      assert && assert(this.isHeightResizableProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      return this.isHeightResizableProperty.value;
    }
    set heightSizable(value) {
      assert && assert(this.isHeightResizableProperty, 'HeightSizable options should be set from a later mutate() call instead of the super constructor');
      this.isHeightResizableProperty.value = value;
    }
    get extendsHeightSizable() {
      return true;
    }
    validateLocalPreferredHeight() {
      if (assert) {
        const currentHeight = this.localHeight;
        const effectiveMinimumHeight = this.localMinimumHeight === null ? currentHeight : this.localMinimumHeight;
        const idealHeight = this.localPreferredHeight === null ? effectiveMinimumHeight : this.localPreferredHeight;

        // Handle non-finite values with exact equality
        assert(idealHeight === currentHeight || Math.abs(idealHeight - currentHeight) < 1e-7);
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    _calculateLocalPreferredHeight() {
      return this.matrix.isAligned() && this.preferredHeight !== null ? Math.abs(this.transform.inverseDeltaY(this.preferredHeight)) : null;
    }

    // Provides a hook to Sizable, since we'll need to cross-link this to also try updating the opposite dimension
    _onReentrantPreferredHeight() {
      this._updateLocalPreferredHeightListener();
    }
    _updateLocalPreferredHeight() {
      assert && this.auditMaxDimensions();
      if (!this._preferredSizeChanging) {
        this._preferredSizeChanging = true;

        // Since the local "preferred" size is the one that we'll want to continue to update if we experience
        // reentrancy (since we treat the non-local version as the ground truth), we'll loop here until we didn't get
        // an attempt to change it. This will ensure that after changes, we'll have a consistent preferred and
        // localPreferred size.
        do {
          this._preferredSizeChangeAttemptDuringLock = false;
          const localPreferredHeight = this._calculateLocalPreferredHeight();
          if (this.localPreferredHeightProperty.value === null || localPreferredHeight === null || Math.abs(this.localPreferredHeightProperty.value - localPreferredHeight) > CHANGE_POSITION_THRESHOLD) {
            this.localPreferredHeightProperty.value = localPreferredHeight;
          }
        } while (this._preferredSizeChangeAttemptDuringLock);
        this._preferredSizeChanging = false;
      } else {
        this._preferredSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    _calculatePreferredHeight() {
      return this.matrix.isAligned() && this.localPreferredHeight !== null ? Math.abs(this.transform.transformDeltaY(this.localPreferredHeight)) : null;
    }
    _updatePreferredHeight() {
      if (!this._preferredSizeChanging) {
        this._preferredSizeChanging = true;
        this._preferredSizeChangeAttemptDuringLock = false;
        const preferredHeight = this._calculatePreferredHeight();
        if (this.preferredHeightProperty.value === null || preferredHeight === null || Math.abs(this.preferredHeightProperty.value - preferredHeight) > CHANGE_POSITION_THRESHOLD) {
          this.preferredHeightProperty.value = preferredHeight;
        }
        this._preferredSizeChanging = false;

        // Here, in the case of reentrance, we'll actually want to switch to updating the local preferred size, since
        // given any other changes it should be the primary one to change.
        if (this._preferredSizeChangeAttemptDuringLock) {
          this._onReentrantPreferredHeight();
        }
      } else {
        this._preferredSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    _calculateLocalMinimumHeight() {
      return this.matrix.isAligned() && this.minimumHeight !== null ? Math.abs(this.transform.inverseDeltaY(this.minimumHeight)) : null;
    }
    _onReentrantLocalMinimumHeight() {
      this._updateMinimumHeight();
    }
    _updateLocalMinimumHeight() {
      if (!this._minimumSizeChanging) {
        this._minimumSizeChanging = true;
        this._minimumSizeChangeAttemptDuringLock = false;
        const localMinimumHeight = this._calculateLocalMinimumHeight();
        if (this.localMinimumHeightProperty.value === null || localMinimumHeight === null || Math.abs(this.localMinimumHeightProperty.value - localMinimumHeight) > CHANGE_POSITION_THRESHOLD) {
          this.localMinimumHeightProperty.value = localMinimumHeight;
        }
        this._minimumSizeChanging = false;

        // Here, in the case of reentrance, we'll actually want to switch to updating the non-local minimum size, since
        // given any other changes it should be the primary one to change.
        if (this._minimumSizeChangeAttemptDuringLock) {
          this._onReentrantLocalMinimumHeight();
        }
      } else {
        this._minimumSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    _calculateMinimumHeight() {
      return this.matrix.isAligned() && this.localMinimumHeight !== null ? Math.abs(this.transform.transformDeltaY(this.localMinimumHeight)) : null;
    }
    _updateMinimumHeight() {
      if (!this._minimumSizeChanging) {
        this._minimumSizeChanging = true;

        // Since the non-local "minimum" size is the one that we'll want to continue to update if we experience
        // reentrancy (since we treat the local version as the ground truth), we'll loop here until we didn't get
        // an attempt to change it. This will ensure that after changes, we'll have a consistent minimum and
        // localMinimum size.
        do {
          this._minimumSizeChangeAttemptDuringLock = false;
          const minimumHeight = this._calculateMinimumHeight();
          if (this.minimumHeightProperty.value === null || minimumHeight === null || Math.abs(this.minimumHeightProperty.value - minimumHeight) > CHANGE_POSITION_THRESHOLD) {
            this.minimumHeightProperty.value = minimumHeight;
          }
        } while (this._minimumSizeChangeAttemptDuringLock);
        this._minimumSizeChanging = false;
      }
    }
    mutate(options) {
      return super.mutate(options);
    }
  });

  // If we're extending into a Node type, include option keys
  if (type.prototype._mutatorKeys) {
    const existingKeys = type.prototype._mutatorKeys;
    const newKeys = HEIGHT_SIZABLE_OPTION_KEYS;
    const indexOfBoundsBasedOptions = existingKeys.indexOf(REQUIRES_BOUNDS_OPTION_KEYS[0]);
    HeightSizableTrait.prototype._mutatorKeys = [...existingKeys.slice(0, indexOfBoundsBasedOptions), ...newKeys, ...existingKeys.slice(indexOfBoundsBasedOptions)];
  }
  return HeightSizableTrait;
});

// Some typescript gymnastics to provide a user-defined type guard that treats something as HeightSizable.
// We need to define an unused function with a concrete type, so that we can extract the return type of the function
// and provide a type for a Node that extends this type.
const wrapper = () => HeightSizable(Node);
const isHeightSizable = node => {
  return node.heightSizable;
};
const extendsHeightSizable = node => {
  return node.extendsHeightSizable;
};
scenery.register('HeightSizable', HeightSizable);
export default HeightSizable;
export { isHeightSizable, extendsHeightSizable };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUaW55UHJvcGVydHkiLCJtZW1vaXplIiwiRGVsYXllZE11dGF0ZSIsIk5vZGUiLCJSRVFVSVJFU19CT1VORFNfT1BUSU9OX0tFWVMiLCJzY2VuZXJ5IiwiQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCIsIkhFSUdIVF9TSVpBQkxFX09QVElPTl9LRVlTIiwiSGVpZ2h0U2l6YWJsZSIsInR5cGUiLCJIZWlnaHRTaXphYmxlVHJhaXQiLCJwcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eSIsIm1pbmltdW1IZWlnaHRQcm9wZXJ0eSIsImxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHkiLCJsb2NhbE1pbmltdW1IZWlnaHRQcm9wZXJ0eSIsImlzSGVpZ2h0UmVzaXphYmxlUHJvcGVydHkiLCJfcHJlZmVycmVkU2l6ZUNoYW5naW5nIiwiX21pbmltdW1TaXplQ2hhbmdpbmciLCJfcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrIiwiX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2siLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJfdXBkYXRlUHJlZmVycmVkSGVpZ2h0TGlzdGVuZXIiLCJfdXBkYXRlUHJlZmVycmVkSGVpZ2h0IiwiYmluZCIsIl91cGRhdGVMb2NhbFByZWZlcnJlZEhlaWdodExpc3RlbmVyIiwiX3VwZGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0IiwiX3VwZGF0ZU1pbmltdW1IZWlnaHRMaXN0ZW5lciIsIl91cGRhdGVNaW5pbXVtSGVpZ2h0IiwiX3VwZGF0ZUxvY2FsTWluaW11bUhlaWdodExpc3RlbmVyIiwiX3VwZGF0ZUxvY2FsTWluaW11bUhlaWdodCIsImxhenlMaW5rIiwidHJhbnNmb3JtRW1pdHRlciIsImFkZExpc3RlbmVyIiwicHJlZmVycmVkSGVpZ2h0IiwiYXNzZXJ0IiwidmFsdWUiLCJpc0Zpbml0ZSIsImxvY2FsUHJlZmVycmVkSGVpZ2h0IiwibWluaW11bUhlaWdodCIsImxvY2FsTWluaW11bUhlaWdodCIsImhlaWdodFNpemFibGUiLCJleHRlbmRzSGVpZ2h0U2l6YWJsZSIsInZhbGlkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQiLCJjdXJyZW50SGVpZ2h0IiwibG9jYWxIZWlnaHQiLCJlZmZlY3RpdmVNaW5pbXVtSGVpZ2h0IiwiaWRlYWxIZWlnaHQiLCJNYXRoIiwiYWJzIiwiX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0IiwibWF0cml4IiwiaXNBbGlnbmVkIiwidHJhbnNmb3JtIiwiaW52ZXJzZURlbHRhWSIsIl9vblJlZW50cmFudFByZWZlcnJlZEhlaWdodCIsImF1ZGl0TWF4RGltZW5zaW9ucyIsIl9jYWxjdWxhdGVQcmVmZXJyZWRIZWlnaHQiLCJ0cmFuc2Zvcm1EZWx0YVkiLCJfY2FsY3VsYXRlTG9jYWxNaW5pbXVtSGVpZ2h0IiwiX29uUmVlbnRyYW50TG9jYWxNaW5pbXVtSGVpZ2h0IiwiX2NhbGN1bGF0ZU1pbmltdW1IZWlnaHQiLCJtdXRhdGUiLCJvcHRpb25zIiwicHJvdG90eXBlIiwiX211dGF0b3JLZXlzIiwiZXhpc3RpbmdLZXlzIiwibmV3S2V5cyIsImluZGV4T2ZCb3VuZHNCYXNlZE9wdGlvbnMiLCJpbmRleE9mIiwic2xpY2UiLCJ3cmFwcGVyIiwiaXNIZWlnaHRTaXphYmxlIiwibm9kZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiSGVpZ2h0U2l6YWJsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBIZWlnaHRTaXphYmxlIGlzIGEgdHJhaXQgdGhhdCBwcm92aWRlcyBhIG1pbmltdW0gYW5kIHByZWZlcnJlZCBoZWlnaHQuIFRoZSBtaW5pbXVtIGhlaWdodCBpcyBzZXQgYnkgdGhlIGNvbXBvbmVudCxcclxuICogc28gdGhhdCBsYXlvdXQgY29udGFpbmVycyBjb3VsZCBrbm93IGhvdyBcInNtYWxsXCIgdGhlIGNvbXBvbmVudCBjYW4gYmUgbWFkZS4gVGhlIHByZWZlcnJlZCBoZWlnaHQgaXMgc2V0IGJ5IHRoZVxyXG4gKiBsYXlvdXQgY29udGFpbmVyLCBhbmQgdGhlIGNvbXBvbmVudCBzaG91bGQgYWRqdXN0IGl0cyBzaXplIHNvIHRoYXQgaXQgdGFrZXMgdXAgdGhhdCBoZWlnaHQuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cclxuICovXHJcblxyXG5pbXBvcnQgVGlueVByb3BlcnR5IGZyb20gJy4uLy4uLy4uL2F4b24vanMvVGlueVByb3BlcnR5LmpzJztcclxuaW1wb3J0IG1lbW9pemUgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lbW9pemUuanMnO1xyXG5pbXBvcnQgeyBEZWxheWVkTXV0YXRlLCBOb2RlLCBSRVFVSVJFU19CT1VORFNfT1BUSU9OX0tFWVMsIHNjZW5lcnkgfSBmcm9tICcuLi9pbXBvcnRzLmpzJztcclxuaW1wb3J0IENvbnN0cnVjdG9yIGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9Db25zdHJ1Y3Rvci5qcyc7XHJcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvSW50ZW50aW9uYWxBbnkuanMnO1xyXG5cclxuLy8gUG9zaXRpb24gY2hhbmdlcyBzbWFsbGVyIHRoYW4gdGhpcyB3aWxsIGJlIGlnbm9yZWRcclxuY29uc3QgQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCA9IDFlLTk7XHJcblxyXG5leHBvcnQgY29uc3QgSEVJR0hUX1NJWkFCTEVfT1BUSU9OX0tFWVMgPSBbXHJcbiAgJ3ByZWZlcnJlZEhlaWdodCcsXHJcbiAgJ21pbmltdW1IZWlnaHQnLFxyXG4gICdsb2NhbFByZWZlcnJlZEhlaWdodCcsXHJcbiAgJ2xvY2FsTWluaW11bUhlaWdodCcsXHJcbiAgJ2hlaWdodFNpemFibGUnXHJcbl07XHJcblxyXG5leHBvcnQgdHlwZSBIZWlnaHRTaXphYmxlT3B0aW9ucyA9IHtcclxuICAvLyBTZXRzIHRoZSBwcmVmZXJyZWQgaGVpZ2h0IG9mIHRoZSBOb2RlIGluIHRoZSBwYXJlbnQgY29vcmRpbmF0ZSBmcmFtZS4gTm9kZXMgdGhhdCBpbXBsZW1lbnQgdGhpcyB3aWxsIGF0dGVtcHQgdG8ga2VlcFxyXG4gIC8vIHRoZWlyIGBub2RlLmhlaWdodGAgYXQgdGhpcyB2YWx1ZS4gSWYgbnVsbCwgdGhlIG5vZGUgd2lsbCBsaWtlbHkgc2V0IGl0cyBjb25maWd1cmF0aW9uIHRvIHRoZSBtaW5pbXVtIGhlaWdodC5cclxuICAvLyBOT1RFOiBjaGFuZ2luZyB0aGlzIG9yIGxvY2FsUHJlZmVycmVkSGVpZ2h0IHdpbGwgYWRqdXN0IHRoZSBvdGhlci5cclxuICAvLyBOT1RFOiBwcmVmZXJyZWRIZWlnaHQgaXMgbm90IGd1YXJhbnRlZWQgY3VycmVudGx5LiBUaGUgY29tcG9uZW50IG1heSBlbmQgdXAgaGF2aW5nIGEgc21hbGxlciBvciBsYXJnZXIgc2l6ZVxyXG4gIHByZWZlcnJlZEhlaWdodD86IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIFNldHMgdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSBOb2RlIGluIHRoZSBwYXJlbnQgY29vcmRpbmF0ZSBmcmFtZS4gVXN1YWxseSBub3QgZGlyZWN0bHkgc2V0IGJ5IGEgY2xpZW50LlxyXG4gIC8vIFVzdWFsbHkgYSByZXNpemFibGUgTm9kZSB3aWxsIHNldCBpdHMgbG9jYWxNaW5pbXVtSGVpZ2h0IChhbmQgdGhhdCB3aWxsIGdldCB0cmFuc2ZlcnJlZCB0byB0aGlzIHZhbHVlIGluIHRoZVxyXG4gIC8vIHBhcmVudCBjb29yZGluYXRlIGZyYW1lKS5cclxuICAvLyBOT1RFOiBjaGFuZ2luZyB0aGlzIG9yIGxvY2FsTWluaW11bUhlaWdodCB3aWxsIGFkanVzdCB0aGUgb3RoZXIuXHJcbiAgLy8gTk9URTogd2hlbiB0aGUgTm9kZSdzIHRyYW5zZm9ybSBpcyB1cGRhdGVkLCB0aGlzIHZhbHVlIGlzIHJlY29tcHV0ZWQgYmFzZWQgb24gbG9jYWxNaW5pbXVtSGVpZ2h0XHJcbiAgbWluaW11bUhlaWdodD86IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIFNldHMgdGhlIHByZWZlcnJlZCBoZWlnaHQgb2YgdGhlIE5vZGUgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgZnJhbWUuXHJcbiAgLy8gTk9URTogY2hhbmdpbmcgdGhpcyBvciBwcmVmZXJyZWRIZWlnaHQgd2lsbCBhZGp1c3QgdGhlIG90aGVyLlxyXG4gIC8vIE5PVEU6IHdoZW4gdGhlIE5vZGUncyB0cmFuc2Zvcm0gaXMgdXBkYXRlZCwgdGhpcyB2YWx1ZSBpcyByZWNvbXB1dGVkIGJhc2VkIG9uIHByZWZlcnJlZEhlaWdodFxyXG4gIC8vIE5PVEU6IGxvY2FsUHJlZmVycmVkSGVpZ2h0IGlzIG5vdCBndWFyYW50ZWVkIGN1cnJlbnRseS4gVGhlIGNvbXBvbmVudCBtYXkgZW5kIHVwIGhhdmluZyBhIHNtYWxsZXIgb3IgbGFyZ2VyIHNpemVcclxuICBsb2NhbFByZWZlcnJlZEhlaWdodD86IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIFNldHMgdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSBOb2RlIGluIHRoZSBsb2NhbCBjb29yZGluYXRlIGZyYW1lLiBVc3VhbGx5IHNldCBieSB0aGUgcmVzaXphYmxlIE5vZGUgaXRzZWxmIHRvXHJcbiAgLy8gaW5kaWNhdGUgd2hhdCBwcmVmZXJyZWQgc2l6ZXMgYXJlIHBvc3NpYmxlLlxyXG4gIC8vIE5PVEU6IGNoYW5naW5nIHRoaXMgb3IgbWluaW11bUhlaWdodCB3aWxsIGFkanVzdCB0aGUgb3RoZXIuXHJcbiAgbG9jYWxNaW5pbXVtSGVpZ2h0PzogbnVtYmVyIHwgbnVsbDtcclxuXHJcbiAgLy8gV2hldGhlciB0aGlzIGNvbXBvbmVudCB3aWxsIGhhdmUgaXRzIHByZWZlcnJlZCBzaXplIHNldCBieSB0aGluZ3MgbGlrZSBsYXlvdXQgY29udGFpbmVycy4gSWYgdGhpcyBpcyBzZXQgdG8gZmFsc2UsXHJcbiAgLy8gaXQncyByZWNvbW1lbmRlZCB0byBzZXQgc29tZSBzb3J0IG9mIHByZWZlcnJlZCBzaXplIChzbyB0aGF0IGl0IHdvbid0IGdvIHRvIDApXHJcbiAgaGVpZ2h0U2l6YWJsZT86IGJvb2xlYW47XHJcbn07XHJcblxyXG4vLyBJTVBPUlRBTlQ6IElmIHlvdSdyZSBjb21iaW5pbmcgdGhpcyBpbiwgdHlwaWNhbGx5IGRvbid0IHBhc3Mgb3B0aW9ucyB0aGF0IEhlaWdodFNpemFibGUgd291bGQgdGFrZSB0aHJvdWdoIHRoZVxyXG4vLyBjb25zdHJ1Y3Rvci4gSXQgd2lsbCBoaXQgTm9kZSdzIG11dGF0ZSgpIGxpa2VseSwgYW5kIHRoZW4gd2lsbCBmYWlsIGJlY2F1c2Ugd2UgaGF2ZW4ndCBiZWVuIGFibGUgdG8gc2V0IHRoZVxyXG4vLyB2YWx1ZXMgeWV0LiBJZiB5b3UncmUgbWFraW5nIHNvbWV0aGluZyBIZWlnaHRTaXphYmxlLCBwbGVhc2UgdXNlIGEgbGF0ZXIgbXV0YXRlKCkgdG8gcGFzcyB0aGVzZSBvcHRpb25zIHRocm91Z2guXHJcbi8vIFRoZXkgV0lMTCBiZSBjYXVnaHQgYnkgYXNzZXJ0aW9ucyBpZiBzb21lb25lIGFkZHMgb25lIG9mIHRob3NlIG9wdGlvbnMsIGJ1dCBpdCBjb3VsZCBiZSBhIHNpbGVudCBidWcgaWYgbm8gb25lXHJcbi8vIGlzIHlldCBwYXNzaW5nIHRob3NlIG9wdGlvbnMgdGhyb3VnaC5cclxuY29uc3QgSGVpZ2h0U2l6YWJsZSA9IG1lbW9pemUoIDxTdXBlclR5cGUgZXh0ZW5kcyBDb25zdHJ1Y3RvcjxOb2RlPj4oIHR5cGU6IFN1cGVyVHlwZSApID0+IHtcclxuICBjb25zdCBIZWlnaHRTaXphYmxlVHJhaXQgPSBEZWxheWVkTXV0YXRlKCAnSGVpZ2h0U2l6YWJsZScsIEhFSUdIVF9TSVpBQkxFX09QVElPTl9LRVlTLCBjbGFzcyBIZWlnaHRTaXphYmxlVHJhaXQgZXh0ZW5kcyB0eXBlIHtcclxuXHJcbiAgICAvLyBwYXJlbnQvbG9jYWwgcHJlZmVycmVkL21pbmltdW0gUHJvcGVydGllcy4gU2VlIHRoZSBvcHRpb25zIGFib3ZlIGZvciBtb3JlIGRvY3VtZW50YXRpb25cclxuICAgIHB1YmxpYyByZWFkb25seSBwcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+ID0gbmV3IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiggbnVsbCApO1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG1pbmltdW1IZWlnaHRQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+ID0gbmV3IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiggbnVsbCApO1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiA9IG5ldyBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4oIG51bGwgKTtcclxuICAgIHB1YmxpYyByZWFkb25seSBsb2NhbE1pbmltdW1IZWlnaHRQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+ID0gbmV3IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiggbnVsbCApO1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGlzSGVpZ2h0UmVzaXphYmxlUHJvcGVydHk6IFRpbnlQcm9wZXJ0eTxib29sZWFuPiA9IG5ldyBUaW55UHJvcGVydHk8Ym9vbGVhbj4oIHRydWUgKTtcclxuXHJcbiAgICAvLyBGbGFncyBzbyB0aGF0IHdlIGNhbiBjaGFuZ2Ugb25lIChwYXJlbnQvbG9jYWwpIHZhbHVlIGFuZCBub3QgZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBjaGFuZ2luZyB0aGUgb3RoZXJzLlxyXG4gICAgLy8gV2Ugd2FudCB0byBsb2NrIG91dCBhbGwgb3RoZXIgbG9jYWwgb3Igbm9uLWxvY2FsIHByZWZlcnJlZCBtaW5pbXVtIHNpemVzLCB3aGV0aGVyIGluIEhlaWdodFNpemFibGUgb3IgV2lkdGhTaXphYmxlXHJcbiAgICAvLyBOT1RFOiBXZSBhcmUgbWVyZ2luZyBkZWNsYXJhdGlvbnMgYmV0d2VlbiBIZWlnaHRTaXphYmxlIGFuZCBXaWR0aFNpemFibGUuIElmIFNpemFibGUgaXMgdXNlZCB0aGVzZSBmbGFnc1xyXG4gICAgLy8gd2lsbCBiZSBzaGFyZWQgYnkgYm90aCBIZWlnaHRTaXphYmxlIGFuZCBXaWR0aFNpemFibGUuXHJcbiAgICBwcm90ZWN0ZWQgX3ByZWZlcnJlZFNpemVDaGFuZ2luZyA9IGZhbHNlO1xyXG4gICAgcHJvdGVjdGVkIF9taW5pbXVtU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcblxyXG4gICAgLy8gV2UnbGwgbmVlZCB0byBkZXRlY3QgcmVlbnRyYW5jeSB3aGVuIHNldHRpbmcgdGhlIGR1YWwgb2YgdGhlIHByZWZlcnJlZC9taW5pbXVtIHByb3BlcnRpZXMgKGUuZy4gbG9jYWwgdnMgcGFyZW50KS5cclxuICAgIC8vIElmIHdlIGdldCBhIHJlZW50cmFudCBjYXNlLCB3ZSdsbCBuZWVkIHRvIGRldGVjdCBpdCBhbmQgY2xlYXIgdGhpbmdzIHVwIGF0IHRoZSBlbmQgKHVwZGF0aW5nIHRoZSBtaW5pbXVtIHNpemVcclxuICAgIC8vIGluIHRoZSBwYXJlbnQgY29vcmRpbmF0ZSBmcmFtZSwgYW5kIHRoZSBwcmVmZXJyZWQgc2l6ZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBmcmFtZSkuXHJcbiAgICAvLyBBbiBleGFtcGxlIGlzIGlmIHRoZSBtaW5pbXVtIHNpemUgaXMgc2V0LCBhbmQgdGhhdCB0cmlnZ2VycyBhIGxpc3RlbmVyIHRoYXQgVVBEQVRFUyBzb21ldGhpbmcgdGhhdCBjaGFuZ2VzIHRoZVxyXG4gICAgLy8gbWluaW11bSBzaXplLCB3ZSdsbCBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBsb2NhbCBtaW5pbXVtIHNpemUgaXMgdXBkYXRlZCBBRlRFUiBldmVyeXRoaW5nIGhhcyBoYXBwZW5lZC5cclxuICAgIC8vIFRoZXNlIGxvY2tzIGFyZSB1c2VkIHRvIGRldGVjdCB0aGVzZSBjYXNlcywgYW5kIHRoZW4gcnVuIHRoZSBhcHByb3ByaWF0ZSB1cGRhdGVzIGFmdGVyd2FyZCB0byBtYWtlIHN1cmUgdGhhdCB0aGVcclxuICAgIC8vIGxvY2FsIGFuZCBwYXJlbnQgdmFsdWVzIGFyZSBpbiBzeW5jIChiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIHVzZWQpLlxyXG4gICAgcHJvdGVjdGVkIF9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcclxuICAgIHByb3RlY3RlZCBfbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEV4cG9zZSBsaXN0ZW5lcnMsIHNvIHRoYXQgd2UnbGwgYmUgYWJsZSB0byBob29rIHRoZW0gdXAgdG8gdGhlIG9wcG9zaXRlIGRpbWVuc2lvbiBpbiBTaXphYmxlXHJcbiAgICBwcm90ZWN0ZWQgX3VwZGF0ZVByZWZlcnJlZEhlaWdodExpc3RlbmVyOiAoKSA9PiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIF91cGRhdGVMb2NhbFByZWZlcnJlZEhlaWdodExpc3RlbmVyOiAoKSA9PiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIF91cGRhdGVNaW5pbXVtSGVpZ2h0TGlzdGVuZXI6ICgpID0+IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgX3VwZGF0ZUxvY2FsTWluaW11bUhlaWdodExpc3RlbmVyOiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIC8vIElNUE9SVEFOVDogSWYgeW91J3JlIGNvbWJpbmluZyB0aGlzIGluLCB0eXBpY2FsbHkgZG9uJ3QgcGFzcyBvcHRpb25zIHRoYXQgSGVpZ2h0U2l6YWJsZSB3b3VsZCB0YWtlIHRocm91Z2ggdGhlXHJcbiAgICAvLyBjb25zdHJ1Y3Rvci4gSXQgd2lsbCBoaXQgTm9kZSdzIG11dGF0ZSgpIGxpa2VseSwgYW5kIHRoZW4gd2lsbCBmYWlsIGJlY2F1c2Ugd2UgaGF2ZW4ndCBiZWVuIGFibGUgdG8gc2V0IHRoZVxyXG4gICAgLy8gdmFsdWVzIHlldC4gSWYgeW91J3JlIG1ha2luZyBzb21ldGhpbmcgSGVpZ2h0U2l6YWJsZSwgcGxlYXNlIHVzZSBhIGxhdGVyIG11dGF0ZSgpIHRvIHBhc3MgdGhlc2Ugb3B0aW9ucyB0aHJvdWdoLlxyXG4gICAgLy8gVGhleSBXSUxMIGJlIGNhdWdodCBieSBhc3NlcnRpb25zIGlmIHNvbWVvbmUgYWRkcyBvbmUgb2YgdGhvc2Ugb3B0aW9ucywgYnV0IGl0IGNvdWxkIGJlIGEgc2lsZW50IGJ1ZyBpZiBubyBvbmVcclxuICAgIC8vIGlzIHlldCBwYXNzaW5nIHRob3NlIG9wdGlvbnMgdGhyb3VnaC5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvciggLi4uYXJnczogSW50ZW50aW9uYWxBbnlbXSApIHtcclxuICAgICAgc3VwZXIoIC4uLmFyZ3MgKTtcclxuXHJcbiAgICAgIHRoaXMuX3VwZGF0ZVByZWZlcnJlZEhlaWdodExpc3RlbmVyID0gdGhpcy5fdXBkYXRlUHJlZmVycmVkSGVpZ2h0LmJpbmQoIHRoaXMgKTtcclxuICAgICAgdGhpcy5fdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHRMaXN0ZW5lciA9IHRoaXMuX3VwZGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0LmJpbmQoIHRoaXMgKTtcclxuICAgICAgdGhpcy5fdXBkYXRlTWluaW11bUhlaWdodExpc3RlbmVyID0gdGhpcy5fdXBkYXRlTWluaW11bUhlaWdodC5iaW5kKCB0aGlzICk7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsTWluaW11bUhlaWdodExpc3RlbmVyID0gdGhpcy5fdXBkYXRlTG9jYWxNaW5pbXVtSGVpZ2h0LmJpbmQoIHRoaXMgKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgb3Bwb3NpdGUgb2YgcGFyZW50L2xvY2FsIHdoZW4gb25lIGNoYW5nZXNcclxuICAgICAgdGhpcy5wcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHRMaXN0ZW5lciApO1xyXG4gICAgICB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZVByZWZlcnJlZEhlaWdodExpc3RlbmVyICk7XHJcbiAgICAgIHRoaXMubWluaW11bUhlaWdodFByb3BlcnR5LmxhenlMaW5rKCB0aGlzLl91cGRhdGVMb2NhbE1pbmltdW1IZWlnaHRMaXN0ZW5lciApO1xyXG4gICAgICB0aGlzLmxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5LmxhenlMaW5rKCB0aGlzLl91cGRhdGVNaW5pbXVtSGVpZ2h0TGlzdGVuZXIgKTtcclxuXHJcbiAgICAgIC8vIE9uIGEgdHJhbnNmb3JtIGNoYW5nZSwga2VlcCBvdXIgbG9jYWwgbWluaW11bSAocHJlc3VtYWJseSB1bmNoYW5nZWQpLCBhbmQgb3VyIHBhcmVudCBwcmVmZXJyZWQgc2l6ZVxyXG4gICAgICB0aGlzLnRyYW5zZm9ybUVtaXR0ZXIuYWRkTGlzdGVuZXIoIHRoaXMuX3VwZGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0TGlzdGVuZXIgKTtcclxuICAgICAgLy8gT24gYSB0cmFuc2Zvcm0gY2hhbmdlIHRoaXMgc2hvdWxkIHVwZGF0ZSB0aGUgbWluaW11bVxyXG4gICAgICB0aGlzLnRyYW5zZm9ybUVtaXR0ZXIuYWRkTGlzdGVuZXIoIHRoaXMuX3VwZGF0ZU1pbmltdW1IZWlnaHRMaXN0ZW5lciApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgcHJlZmVycmVkSGVpZ2h0KCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLnByZWZlcnJlZEhlaWdodFByb3BlcnR5LFxyXG4gICAgICAgICdIZWlnaHRTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgcmV0dXJuIHRoaXMucHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBwcmVmZXJyZWRIZWlnaHQoIHZhbHVlOiBudW1iZXIgfCBudWxsICkge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLnByZWZlcnJlZEhlaWdodFByb3BlcnR5LFxyXG4gICAgICAgICdIZWlnaHRTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdmFsdWUgPT09IG51bGwgfHwgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKCB2YWx1ZSApICYmIHZhbHVlID49IDAgKSxcclxuICAgICAgICAncHJlZmVycmVkSGVpZ2h0IHNob3VsZCBiZSBudWxsIG9yIGEgbm9uLW5lZ2F0aXZlIGZpbml0ZSBudW1iZXInICk7XHJcblxyXG4gICAgICB0aGlzLnByZWZlcnJlZEhlaWdodFByb3BlcnR5LnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBsb2NhbFByZWZlcnJlZEhlaWdodCgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5LFxyXG4gICAgICAgICdIZWlnaHRTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgcmV0dXJuIHRoaXMubG9jYWxQcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGxvY2FsUHJlZmVycmVkSGVpZ2h0KCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodFByb3BlcnR5LFxyXG4gICAgICAgICdIZWlnaHRTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdmFsdWUgPT09IG51bGwgfHwgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKCB2YWx1ZSApICYmIHZhbHVlID49IDAgKSxcclxuICAgICAgICAnbG9jYWxQcmVmZXJyZWRIZWlnaHQgc2hvdWxkIGJlIG51bGwgb3IgYSBub24tbmVnYXRpdmUgZmluaXRlIG51bWJlcicgKTtcclxuXHJcbiAgICAgIHRoaXMubG9jYWxQcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbWluaW11bUhlaWdodCgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHksXHJcbiAgICAgICAgJ0hlaWdodFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICByZXR1cm4gdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBtaW5pbXVtSGVpZ2h0KCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHksXHJcbiAgICAgICAgJ0hlaWdodFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gbnVsbCB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgKSApO1xyXG5cclxuICAgICAgdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGxvY2FsTWluaW11bUhlaWdodCgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5sb2NhbE1pbmltdW1IZWlnaHRQcm9wZXJ0eSxcclxuICAgICAgICAnSGVpZ2h0U2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XHJcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5LnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgbG9jYWxNaW5pbXVtSGVpZ2h0KCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5sb2NhbE1pbmltdW1IZWlnaHRQcm9wZXJ0eSxcclxuICAgICAgICAnSGVpZ2h0U2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbHVlID09PSBudWxsIHx8ICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSggdmFsdWUgKSApICk7XHJcblxyXG4gICAgICB0aGlzLmxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5LnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG92ZXJyaWRlIGdldCBoZWlnaHRTaXphYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmlzSGVpZ2h0UmVzaXphYmxlUHJvcGVydHksXHJcbiAgICAgICAgJ0hlaWdodFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICByZXR1cm4gdGhpcy5pc0hlaWdodFJlc2l6YWJsZVByb3BlcnR5LnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvdmVycmlkZSBzZXQgaGVpZ2h0U2l6YWJsZSggdmFsdWU6IGJvb2xlYW4gKSB7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaXNIZWlnaHRSZXNpemFibGVQcm9wZXJ0eSxcclxuICAgICAgICAnSGVpZ2h0U2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XHJcbiAgICAgIHRoaXMuaXNIZWlnaHRSZXNpemFibGVQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgZXh0ZW5kc0hlaWdodFNpemFibGUoKTogYm9vbGVhbiB7IHJldHVybiB0cnVlOyB9XHJcblxyXG4gICAgcHVibGljIHZhbGlkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQoKTogdm9pZCB7XHJcbiAgICAgIGlmICggYXNzZXJ0ICkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSB0aGlzLmxvY2FsSGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZU1pbmltdW1IZWlnaHQgPSB0aGlzLmxvY2FsTWluaW11bUhlaWdodCA9PT0gbnVsbCA/IGN1cnJlbnRIZWlnaHQgOiB0aGlzLmxvY2FsTWluaW11bUhlaWdodDtcclxuICAgICAgICBjb25zdCBpZGVhbEhlaWdodCA9IHRoaXMubG9jYWxQcmVmZXJyZWRIZWlnaHQgPT09IG51bGwgPyBlZmZlY3RpdmVNaW5pbXVtSGVpZ2h0IDogdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIG5vbi1maW5pdGUgdmFsdWVzIHdpdGggZXhhY3QgZXF1YWxpdHlcclxuICAgICAgICBhc3NlcnQoIGlkZWFsSGVpZ2h0ID09PSBjdXJyZW50SGVpZ2h0IHx8IE1hdGguYWJzKCBpZGVhbEhlaWdodCAtIGN1cnJlbnRIZWlnaHQgKSA8IDFlLTcgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoaXMgaXMgcHJvdmlkZWQgdG8gaG9vayBpbnRvIHRoZSBTaXphYmxlIHRyYWl0LCBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIG9wcG9zaXRlIGRpbWVuc2lvblxyXG4gICAgcHJvdGVjdGVkIF9jYWxjdWxhdGVMb2NhbFByZWZlcnJlZEhlaWdodCgpOiBudW1iZXIgfCBudWxsIHtcclxuXHJcbiAgICAgIHJldHVybiAoIHRoaXMubWF0cml4LmlzQWxpZ25lZCgpICYmIHRoaXMucHJlZmVycmVkSGVpZ2h0ICE9PSBudWxsIClcclxuICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLmludmVyc2VEZWx0YVkoIHRoaXMucHJlZmVycmVkSGVpZ2h0ICkgKVxyXG4gICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByb3ZpZGVzIGEgaG9vayB0byBTaXphYmxlLCBzaW5jZSB3ZSdsbCBuZWVkIHRvIGNyb3NzLWxpbmsgdGhpcyB0byBhbHNvIHRyeSB1cGRhdGluZyB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uXHJcbiAgICBwcm90ZWN0ZWQgX29uUmVlbnRyYW50UHJlZmVycmVkSGVpZ2h0KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLl91cGRhdGVMb2NhbFByZWZlcnJlZEhlaWdodExpc3RlbmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfdXBkYXRlTG9jYWxQcmVmZXJyZWRIZWlnaHQoKTogdm9pZCB7XHJcbiAgICAgIGFzc2VydCAmJiB0aGlzLmF1ZGl0TWF4RGltZW5zaW9ucygpO1xyXG5cclxuICAgICAgaWYgKCAhdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nICkge1xyXG4gICAgICAgIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIFNpbmNlIHRoZSBsb2NhbCBcInByZWZlcnJlZFwiIHNpemUgaXMgdGhlIG9uZSB0aGF0IHdlJ2xsIHdhbnQgdG8gY29udGludWUgdG8gdXBkYXRlIGlmIHdlIGV4cGVyaWVuY2VcclxuICAgICAgICAvLyByZWVudHJhbmN5IChzaW5jZSB3ZSB0cmVhdCB0aGUgbm9uLWxvY2FsIHZlcnNpb24gYXMgdGhlIGdyb3VuZCB0cnV0aCksIHdlJ2xsIGxvb3AgaGVyZSB1bnRpbCB3ZSBkaWRuJ3QgZ2V0XHJcbiAgICAgICAgLy8gYW4gYXR0ZW1wdCB0byBjaGFuZ2UgaXQuIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBhZnRlciBjaGFuZ2VzLCB3ZSdsbCBoYXZlIGEgY29uc2lzdGVudCBwcmVmZXJyZWQgYW5kXHJcbiAgICAgICAgLy8gbG9jYWxQcmVmZXJyZWQgc2l6ZS5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICBjb25zdCBsb2NhbFByZWZlcnJlZEhlaWdodCA9IHRoaXMuX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkSGVpZ2h0KCk7XHJcblxyXG4gICAgICAgICAgaWYgKCB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudmFsdWUgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgbG9jYWxQcmVmZXJyZWRIZWlnaHQgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgTWF0aC5hYnMoIHRoaXMubG9jYWxQcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS52YWx1ZSAtIGxvY2FsUHJlZmVycmVkSGVpZ2h0ICkgPiBDSEFOR0VfUE9TSVRJT05fVEhSRVNIT0xEICkge1xyXG4gICAgICAgICAgICB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudmFsdWUgPSBsb2NhbFByZWZlcnJlZEhlaWdodDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKCB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgKTtcclxuXHJcbiAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoaXMgaXMgcHJvdmlkZWQgdG8gaG9vayBpbnRvIHRoZSBTaXphYmxlIHRyYWl0LCBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIG9wcG9zaXRlIGRpbWVuc2lvblxyXG4gICAgcHJvdGVjdGVkIF9jYWxjdWxhdGVQcmVmZXJyZWRIZWlnaHQoKTogbnVtYmVyIHwgbnVsbCB7XHJcblxyXG4gICAgICByZXR1cm4gKCB0aGlzLm1hdHJpeC5pc0FsaWduZWQoKSAmJiB0aGlzLmxvY2FsUHJlZmVycmVkSGVpZ2h0ICE9PSBudWxsIClcclxuICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLnRyYW5zZm9ybURlbHRhWSggdGhpcy5sb2NhbFByZWZlcnJlZEhlaWdodCApIClcclxuICAgICAgICAgICAgIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF91cGRhdGVQcmVmZXJyZWRIZWlnaHQoKTogdm9pZCB7XHJcbiAgICAgIGlmICggIXRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyApIHtcclxuICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJlZmVycmVkSGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlUHJlZmVycmVkSGVpZ2h0KCk7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5wcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS52YWx1ZSA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgcHJlZmVycmVkSGVpZ2h0ID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICBNYXRoLmFicyggdGhpcy5wcmVmZXJyZWRIZWlnaHRQcm9wZXJ0eS52YWx1ZSAtIHByZWZlcnJlZEhlaWdodCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcclxuICAgICAgICAgIHRoaXMucHJlZmVycmVkSGVpZ2h0UHJvcGVydHkudmFsdWUgPSBwcmVmZXJyZWRIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBIZXJlLCBpbiB0aGUgY2FzZSBvZiByZWVudHJhbmNlLCB3ZSdsbCBhY3R1YWxseSB3YW50IHRvIHN3aXRjaCB0byB1cGRhdGluZyB0aGUgbG9jYWwgcHJlZmVycmVkIHNpemUsIHNpbmNlXHJcbiAgICAgICAgLy8gZ2l2ZW4gYW55IG90aGVyIGNoYW5nZXMgaXQgc2hvdWxkIGJlIHRoZSBwcmltYXJ5IG9uZSB0byBjaGFuZ2UuXHJcbiAgICAgICAgaWYgKCB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgKSB7XHJcbiAgICAgICAgICB0aGlzLl9vblJlZW50cmFudFByZWZlcnJlZEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBpcyBwcm92aWRlZCB0byBob29rIGludG8gdGhlIFNpemFibGUgdHJhaXQsIHNvIHRoYXQgd2UgY2FuIHVwZGF0ZSB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uXHJcbiAgICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZUxvY2FsTWluaW11bUhlaWdodCgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgcmV0dXJuICggdGhpcy5tYXRyaXguaXNBbGlnbmVkKCkgJiYgdGhpcy5taW5pbXVtSGVpZ2h0ICE9PSBudWxsIClcclxuICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLmludmVyc2VEZWx0YVkoIHRoaXMubWluaW11bUhlaWdodCApIClcclxuICAgICAgICAgICAgIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX29uUmVlbnRyYW50TG9jYWxNaW5pbXVtSGVpZ2h0KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLl91cGRhdGVNaW5pbXVtSGVpZ2h0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfdXBkYXRlTG9jYWxNaW5pbXVtSGVpZ2h0KCk6IHZvaWQge1xyXG4gICAgICBpZiAoICF0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nICkge1xyXG4gICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGNvbnN0IGxvY2FsTWluaW11bUhlaWdodCA9IHRoaXMuX2NhbGN1bGF0ZUxvY2FsTWluaW11bUhlaWdodCgpO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWUgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgIGxvY2FsTWluaW11bUhlaWdodCA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgTWF0aC5hYnMoIHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWUgLSBsb2NhbE1pbmltdW1IZWlnaHQgKSA+IENIQU5HRV9QT1NJVElPTl9USFJFU0hPTEQgKSB7XHJcbiAgICAgICAgICB0aGlzLmxvY2FsTWluaW11bUhlaWdodFByb3BlcnR5LnZhbHVlID0gbG9jYWxNaW5pbXVtSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIEhlcmUsIGluIHRoZSBjYXNlIG9mIHJlZW50cmFuY2UsIHdlJ2xsIGFjdHVhbGx5IHdhbnQgdG8gc3dpdGNoIHRvIHVwZGF0aW5nIHRoZSBub24tbG9jYWwgbWluaW11bSBzaXplLCBzaW5jZVxyXG4gICAgICAgIC8vIGdpdmVuIGFueSBvdGhlciBjaGFuZ2VzIGl0IHNob3VsZCBiZSB0aGUgcHJpbWFyeSBvbmUgdG8gY2hhbmdlLlxyXG4gICAgICAgIGlmICggdGhpcy5fbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayApIHtcclxuICAgICAgICAgIHRoaXMuX29uUmVlbnRyYW50TG9jYWxNaW5pbXVtSGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBpcyBwcm92aWRlZCB0byBob29rIGludG8gdGhlIFNpemFibGUgdHJhaXQsIHNvIHRoYXQgd2UgY2FuIHVwZGF0ZSB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uXHJcbiAgICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZU1pbmltdW1IZWlnaHQoKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICAgIHJldHVybiAoIHRoaXMubWF0cml4LmlzQWxpZ25lZCgpICYmIHRoaXMubG9jYWxNaW5pbXVtSGVpZ2h0ICE9PSBudWxsIClcclxuICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLnRyYW5zZm9ybURlbHRhWSggdGhpcy5sb2NhbE1pbmltdW1IZWlnaHQgKSApXHJcbiAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfdXBkYXRlTWluaW11bUhlaWdodCgpOiB2b2lkIHtcclxuICAgICAgaWYgKCAhdGhpcy5fbWluaW11bVNpemVDaGFuZ2luZyApIHtcclxuICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gU2luY2UgdGhlIG5vbi1sb2NhbCBcIm1pbmltdW1cIiBzaXplIGlzIHRoZSBvbmUgdGhhdCB3ZSdsbCB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSBpZiB3ZSBleHBlcmllbmNlXHJcbiAgICAgICAgLy8gcmVlbnRyYW5jeSAoc2luY2Ugd2UgdHJlYXQgdGhlIGxvY2FsIHZlcnNpb24gYXMgdGhlIGdyb3VuZCB0cnV0aCksIHdlJ2xsIGxvb3AgaGVyZSB1bnRpbCB3ZSBkaWRuJ3QgZ2V0XHJcbiAgICAgICAgLy8gYW4gYXR0ZW1wdCB0byBjaGFuZ2UgaXQuIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBhZnRlciBjaGFuZ2VzLCB3ZSdsbCBoYXZlIGEgY29uc2lzdGVudCBtaW5pbXVtIGFuZFxyXG4gICAgICAgIC8vIGxvY2FsTWluaW11bSBzaXplLlxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICBjb25zdCBtaW5pbXVtSGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlTWluaW11bUhlaWdodCgpO1xyXG5cclxuICAgICAgICAgIGlmICggdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWUgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgbWluaW11bUhlaWdodCA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICBNYXRoLmFicyggdGhpcy5taW5pbXVtSGVpZ2h0UHJvcGVydHkudmFsdWUgLSBtaW5pbXVtSGVpZ2h0ICkgPiBDSEFOR0VfUE9TSVRJT05fVEhSRVNIT0xEICkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbmltdW1IZWlnaHRQcm9wZXJ0eS52YWx1ZSA9IG1pbmltdW1IZWlnaHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICggdGhpcy5fbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayApO1xyXG5cclxuICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgbXV0YXRlKCBvcHRpb25zPzogSGVpZ2h0U2l6YWJsZU9wdGlvbnMgJiBQYXJhbWV0ZXJzPEluc3RhbmNlVHlwZTxTdXBlclR5cGU+WyAnbXV0YXRlJyBdPlsgMCBdICk6IHRoaXMge1xyXG4gICAgICByZXR1cm4gc3VwZXIubXV0YXRlKCBvcHRpb25zICk7XHJcbiAgICB9XHJcbiAgfSApO1xyXG5cclxuICAvLyBJZiB3ZSdyZSBleHRlbmRpbmcgaW50byBhIE5vZGUgdHlwZSwgaW5jbHVkZSBvcHRpb24ga2V5c1xyXG4gIGlmICggdHlwZS5wcm90b3R5cGUuX211dGF0b3JLZXlzICkge1xyXG4gICAgY29uc3QgZXhpc3RpbmdLZXlzID0gdHlwZS5wcm90b3R5cGUuX211dGF0b3JLZXlzO1xyXG4gICAgY29uc3QgbmV3S2V5cyA9IEhFSUdIVF9TSVpBQkxFX09QVElPTl9LRVlTO1xyXG4gICAgY29uc3QgaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyA9IGV4aXN0aW5nS2V5cy5pbmRleE9mKCBSRVFVSVJFU19CT1VORFNfT1BUSU9OX0tFWVNbIDAgXSApO1xyXG4gICAgSGVpZ2h0U2l6YWJsZVRyYWl0LnByb3RvdHlwZS5fbXV0YXRvcktleXMgPSBbXHJcbiAgICAgIC4uLmV4aXN0aW5nS2V5cy5zbGljZSggMCwgaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyApLFxyXG4gICAgICAuLi5uZXdLZXlzLFxyXG4gICAgICAuLi5leGlzdGluZ0tleXMuc2xpY2UoIGluZGV4T2ZCb3VuZHNCYXNlZE9wdGlvbnMgKVxyXG4gICAgXTtcclxuICB9XHJcblxyXG4gIHJldHVybiBIZWlnaHRTaXphYmxlVHJhaXQ7XHJcbn0gKTtcclxuXHJcbi8vIFNvbWUgdHlwZXNjcmlwdCBneW1uYXN0aWNzIHRvIHByb3ZpZGUgYSB1c2VyLWRlZmluZWQgdHlwZSBndWFyZCB0aGF0IHRyZWF0cyBzb21ldGhpbmcgYXMgSGVpZ2h0U2l6YWJsZS5cclxuLy8gV2UgbmVlZCB0byBkZWZpbmUgYW4gdW51c2VkIGZ1bmN0aW9uIHdpdGggYSBjb25jcmV0ZSB0eXBlLCBzbyB0aGF0IHdlIGNhbiBleHRyYWN0IHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgZnVuY3Rpb25cclxuLy8gYW5kIHByb3ZpZGUgYSB0eXBlIGZvciBhIE5vZGUgdGhhdCBleHRlbmRzIHRoaXMgdHlwZS5cclxuY29uc3Qgd3JhcHBlciA9ICgpID0+IEhlaWdodFNpemFibGUoIE5vZGUgKTtcclxuZXhwb3J0IHR5cGUgSGVpZ2h0U2l6YWJsZU5vZGUgPSBJbnN0YW5jZVR5cGU8UmV0dXJuVHlwZTx0eXBlb2Ygd3JhcHBlcj4+O1xyXG5cclxuY29uc3QgaXNIZWlnaHRTaXphYmxlID0gKCBub2RlOiBOb2RlICk6IG5vZGUgaXMgSGVpZ2h0U2l6YWJsZU5vZGUgPT4ge1xyXG4gIHJldHVybiBub2RlLmhlaWdodFNpemFibGU7XHJcbn07XHJcbmNvbnN0IGV4dGVuZHNIZWlnaHRTaXphYmxlID0gKCBub2RlOiBOb2RlICk6IG5vZGUgaXMgSGVpZ2h0U2l6YWJsZU5vZGUgPT4ge1xyXG4gIHJldHVybiBub2RlLmV4dGVuZHNIZWlnaHRTaXphYmxlO1xyXG59O1xyXG5cclxuc2NlbmVyeS5yZWdpc3RlciggJ0hlaWdodFNpemFibGUnLCBIZWlnaHRTaXphYmxlICk7XHJcbmV4cG9ydCBkZWZhdWx0IEhlaWdodFNpemFibGU7XHJcbmV4cG9ydCB7IGlzSGVpZ2h0U2l6YWJsZSwgZXh0ZW5kc0hlaWdodFNpemFibGUgfTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxZQUFZLE1BQU0sa0NBQWtDO0FBQzNELE9BQU9DLE9BQU8sTUFBTSxrQ0FBa0M7QUFDdEQsU0FBU0MsYUFBYSxFQUFFQyxJQUFJLEVBQUVDLDJCQUEyQixFQUFFQyxPQUFPLFFBQVEsZUFBZTtBQUl6RjtBQUNBLE1BQU1DLHlCQUF5QixHQUFHLElBQUk7QUFFdEMsT0FBTyxNQUFNQywwQkFBMEIsR0FBRyxDQUN4QyxpQkFBaUIsRUFDakIsZUFBZSxFQUNmLHNCQUFzQixFQUN0QixvQkFBb0IsRUFDcEIsZUFBZSxDQUNoQjtBQWdDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsYUFBYSxHQUFHUCxPQUFPLENBQXlDUSxJQUFlLElBQU07RUFDekYsTUFBTUMsa0JBQWtCLEdBQUdSLGFBQWEsQ0FBRSxlQUFlLEVBQUVLLDBCQUEwQixFQUFFLE1BQU1HLGtCQUFrQixTQUFTRCxJQUFJLENBQUM7SUFFM0g7SUFDZ0JFLHVCQUF1QixHQUFnQyxJQUFJWCxZQUFZLENBQWlCLElBQUssQ0FBQztJQUM5RlkscUJBQXFCLEdBQWdDLElBQUlaLFlBQVksQ0FBaUIsSUFBSyxDQUFDO0lBQzVGYSw0QkFBNEIsR0FBZ0MsSUFBSWIsWUFBWSxDQUFpQixJQUFLLENBQUM7SUFDbkdjLDBCQUEwQixHQUFnQyxJQUFJZCxZQUFZLENBQWlCLElBQUssQ0FBQztJ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