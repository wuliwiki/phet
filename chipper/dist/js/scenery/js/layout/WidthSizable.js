// Copyright 2021-2023, University of Colorado Boulder

/**
 * WidthSizable is a trait that provides a minimum and preferred width. The minimum width is set by the component,
 * so that layout containers could know how "small" the component can be made. The preferred width is set by the
 * layout container, and the component should adjust its size so that it takes up that width.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import TinyProperty from '../../../axon/js/TinyProperty.js';
import memoize from '../../../phet-core/js/memoize.js';
import { DelayedMutate, Node, REQUIRES_BOUNDS_OPTION_KEYS, scenery } from '../imports.js';
// Position changes smaller than this will be ignored
const CHANGE_POSITION_THRESHOLD = 1e-9;
export const WIDTH_SIZABLE_OPTION_KEYS = ['preferredWidth', 'minimumWidth', 'localPreferredWidth', 'localMinimumWidth', 'widthSizable'];
// IMPORTANT: If you're combining this in, typically don't pass options that WidthSizable would take through the
// constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
// values yet. If you're making something WidthSizable, please use a later mutate() to pass these options through.
// They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
// is yet passing those options through.
const WidthSizable = memoize(type => {
  const WidthSizableTrait = DelayedMutate('WidthSizable', WIDTH_SIZABLE_OPTION_KEYS, class WidthSizableTrait extends type {
    // parent/local preferred/minimum Properties. See the options above for more documentation
    preferredWidthProperty = new TinyProperty(null);
    minimumWidthProperty = new TinyProperty(null);
    localPreferredWidthProperty = new TinyProperty(null);
    localMinimumWidthProperty = new TinyProperty(null);
    isWidthResizableProperty = new TinyProperty(true);

    // Flags so that we can change one (parent/local) value and not enter an infinite loop changing the others.
    // We want to lock out all other local or non-local preferred minimum sizes, whether in HeightSizable or WidthSizable
    // NOTE: We are merging declarations between HeightSizable and WidthSizable. If Sizable is used these flags
    // will be shared by both HeightSizable and WidthSizable.
    _preferredSizeChanging = false;
    _minimumSizeChanging = false;

    // We'll need to detect reentrancy when setting the dual of the preferred/minimum properties (e.g. local vs parent).
    // If we get a reentrant case, we'll need to detect it and clear things up at the end (updating the minimum size
    // in the parent coordinate frame, and the preferred size in the local coordinate frame).
    // An example is if the minimum size is set, and that triggers a listener that UPDATES something that changes the
    // minimum size, we'll need to make sure that the local minimum size is updated AFTER everything has happened.
    // These locks are used to detect these cases, and then run the appropriate updates afterward to make sure that the
    // local and parent values are in sync (based on the transform used).
    _preferredSizeChangeAttemptDuringLock = false;
    _minimumSizeChangeAttemptDuringLock = false;

    // Expose listeners, so that we'll be able to hook them up to the opposite dimension in Sizable

    // IMPORTANT: If you're combining this in, typically don't pass options that WidthSizable would take through the
    // constructor. It will hit Node's mutate() likely, and then will fail because we haven't been able to set the
    // values yet. If you're making something WidthSizable, please use a later mutate() to pass these options through.
    // They WILL be caught by assertions if someone adds one of those options, but it could be a silent bug if no one
    // is yet passing those options through.
    constructor(...args) {
      super(...args);
      this._updatePreferredWidthListener = this._updatePreferredWidth.bind(this);
      this._updateLocalPreferredWidthListener = this._updateLocalPreferredWidth.bind(this);
      this._updateMinimumWidthListener = this._updateMinimumWidth.bind(this);
      this._updateLocalMinimumWidthListener = this._updateLocalMinimumWidth.bind(this);

      // Update the opposite of parent/local when one changes
      this.preferredWidthProperty.lazyLink(this._updateLocalPreferredWidthListener);
      this.localPreferredWidthProperty.lazyLink(this._updatePreferredWidthListener);
      this.minimumWidthProperty.lazyLink(this._updateLocalMinimumWidthListener);
      this.localMinimumWidthProperty.lazyLink(this._updateMinimumWidthListener);

      // On a transform change, keep our local minimum (presumably unchanged), and our parent preferred size
      this.transformEmitter.addListener(this._updateLocalPreferredWidthListener);
      // On a transform change this should update the minimum
      this.transformEmitter.addListener(this._updateMinimumWidthListener);
    }
    get preferredWidth() {
      assert && assert(this.preferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      return this.preferredWidthProperty.value;
    }
    set preferredWidth(value) {
      assert && assert(this.preferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'preferredWidth should be null or a non-negative finite number');
      this.preferredWidthProperty.value = value;
    }
    get localPreferredWidth() {
      assert && assert(this.localPreferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      return this.localPreferredWidthProperty.value;
    }
    set localPreferredWidth(value) {
      assert && assert(this.localPreferredWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0, 'localPreferredWidth should be null or a non-negative finite number');
      this.localPreferredWidthProperty.value = value;
    }
    get minimumWidth() {
      assert && assert(this.minimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      return this.minimumWidthProperty.value;
    }
    set minimumWidth(value) {
      assert && assert(this.minimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value));
      this.minimumWidthProperty.value = value;
    }
    get localMinimumWidth() {
      assert && assert(this.localMinimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      return this.localMinimumWidthProperty.value;
    }
    set localMinimumWidth(value) {
      assert && assert(this.localMinimumWidthProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      assert && assert(value === null || typeof value === 'number' && isFinite(value));
      this.localMinimumWidthProperty.value = value;
    }
    get widthSizable() {
      assert && assert(this.isWidthResizableProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      return this.isWidthResizableProperty.value;
    }
    set widthSizable(value) {
      assert && assert(this.isWidthResizableProperty, 'WidthSizable options should be set from a later mutate() call instead of the super constructor');
      this.isWidthResizableProperty.value = value;
    }
    get extendsWidthSizable() {
      return true;
    }
    validateLocalPreferredWidth() {
      if (assert) {
        const currentWidth = this.localWidth;
        const effectiveMinimumWidth = this.localMinimumWidth === null ? currentWidth : this.localMinimumWidth;
        const idealWidth = this.localPreferredWidth === null ? effectiveMinimumWidth : this.localPreferredWidth;

        // Handle non-finite values with exact equality
        assert(idealWidth === currentWidth || Math.abs(idealWidth - currentWidth) < 1e-7);
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    _calculateLocalPreferredWidth() {
      return this.matrix.isAligned() && this.preferredWidth !== null ? Math.abs(this.transform.inverseDeltaX(this.preferredWidth)) : null;
    }

    // Provides a hook to Sizable, since we'll need to cross-link this to also try updating the opposite dimension
    _onReentrantPreferredWidth() {
      this._updateLocalPreferredWidthListener();
    }
    _updateLocalPreferredWidth() {
      assert && this.auditMaxDimensions();
      if (!this._preferredSizeChanging) {
        this._preferredSizeChanging = true;

        // Since the local "preferred" size is the one that we'll want to continue to update if we experience
        // reentrancy (since we treat the non-local version as the ground truth), we'll loop here until we didn't get
        // an attempt to change it. This will ensure that after changes, we'll have a consistent preferred and
        // localPreferred size.
        do {
          this._preferredSizeChangeAttemptDuringLock = false;
          const localPreferredWidth = this._calculateLocalPreferredWidth();
          if (this.localPreferredWidthProperty.value === null || localPreferredWidth === null || Math.abs(this.localPreferredWidthProperty.value - localPreferredWidth) > CHANGE_POSITION_THRESHOLD) {
            this.localPreferredWidthProperty.value = localPreferredWidth;
          }
        } while (this._preferredSizeChangeAttemptDuringLock);
        this._preferredSizeChanging = false;
      } else {
        this._preferredSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    _calculatePreferredWidth() {
      return this.matrix.isAligned() && this.localPreferredWidth !== null ? Math.abs(this.transform.transformDeltaX(this.localPreferredWidth)) : null;
    }
    _updatePreferredWidth() {
      if (!this._preferredSizeChanging) {
        this._preferredSizeChanging = true;
        this._preferredSizeChangeAttemptDuringLock = false;
        const preferredWidth = this._calculatePreferredWidth();
        if (this.preferredWidthProperty.value === null || preferredWidth === null || Math.abs(this.preferredWidthProperty.value - preferredWidth) > CHANGE_POSITION_THRESHOLD) {
          this.preferredWidthProperty.value = preferredWidth;
        }
        this._preferredSizeChanging = false;

        // Here, in the case of reentrance, we'll actually want to switch to updating the local preferred size, since
        // given any other changes it should be the primary one to change.
        if (this._preferredSizeChangeAttemptDuringLock) {
          this._onReentrantPreferredWidth();
        }
      } else {
        this._preferredSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    _calculateLocalMinimumWidth() {
      return this.matrix.isAligned() && this.minimumWidth !== null ? Math.abs(this.transform.inverseDeltaX(this.minimumWidth)) : null;
    }
    _onReentrantLocalMinimumWidth() {
      this._updateMinimumWidthListener();
    }
    _updateLocalMinimumWidth() {
      if (!this._minimumSizeChanging) {
        this._minimumSizeChanging = true;
        const localMinimumWidth = this._calculateLocalMinimumWidth();
        this._minimumSizeChangeAttemptDuringLock = false;
        if (this.localMinimumWidthProperty.value === null || localMinimumWidth === null || Math.abs(this.localMinimumWidthProperty.value - localMinimumWidth) > CHANGE_POSITION_THRESHOLD) {
          this.localMinimumWidthProperty.value = localMinimumWidth;
        }
        this._minimumSizeChanging = false;

        // Here, in the case of reentrance, we'll actually want to switch to updating the non-local minimum size, since
        // given any other changes it should be the primary one to change.
        if (this._minimumSizeChangeAttemptDuringLock) {
          this._onReentrantLocalMinimumWidth();
        }
      } else {
        this._minimumSizeChangeAttemptDuringLock = true;
      }
    }

    // This is provided to hook into the Sizable trait, so that we can update the opposite dimension
    _calculateMinimumWidth() {
      return this.matrix.isAligned() && this.localMinimumWidth !== null ? Math.abs(this.transform.transformDeltaX(this.localMinimumWidth)) : null;
    }
    _updateMinimumWidth() {
      if (!this._minimumSizeChanging) {
        this._minimumSizeChanging = true;

        // Since the non-local "minimum" size is the one that we'll want to continue to update if we experience
        // reentrancy (since we treat the local version as the ground truth), we'll loop here until we didn't get
        // an attempt to change it. This will ensure that after changes, we'll have a consistent minimum and
        // localMinimum size.
        do {
          this._minimumSizeChangeAttemptDuringLock = false;
          const minimumWidth = this._calculateMinimumWidth();
          if (this.minimumWidthProperty.value === null || minimumWidth === null || Math.abs(this.minimumWidthProperty.value - minimumWidth) > CHANGE_POSITION_THRESHOLD) {
            this.minimumWidthProperty.value = minimumWidth;
          }
        } while (this._minimumSizeChangeAttemptDuringLock);
        this._minimumSizeChanging = false;
      } else {
        this._minimumSizeChangeAttemptDuringLock = true;
      }
    }
    mutate(options) {
      return super.mutate(options);
    }
  });

  // If we're extending into a Node type, include option keys
  if (type.prototype._mutatorKeys) {
    const existingKeys = type.prototype._mutatorKeys;
    const newKeys = WIDTH_SIZABLE_OPTION_KEYS;
    const indexOfBoundsBasedOptions = existingKeys.indexOf(REQUIRES_BOUNDS_OPTION_KEYS[0]);
    WidthSizableTrait.prototype._mutatorKeys = [...existingKeys.slice(0, indexOfBoundsBasedOptions), ...newKeys, ...existingKeys.slice(indexOfBoundsBasedOptions)];
  }
  return WidthSizableTrait;
});

// Some typescript gymnastics to provide a user-defined type guard that treats something as widthSizable
// We need to define an unused function with a concrete type, so that we can extract the return type of the function
// and provide a type for a Node that extends this type.
const wrapper = () => WidthSizable(Node);
const isWidthSizable = node => {
  return node.widthSizable;
};
const extendsWidthSizable = node => {
  return node.extendsWidthSizable;
};
scenery.register('WidthSizable', WidthSizable);
export default WidthSizable;
export { isWidthSizable, extendsWidthSizable };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUaW55UHJvcGVydHkiLCJtZW1vaXplIiwiRGVsYXllZE11dGF0ZSIsIk5vZGUiLCJSRVFVSVJFU19CT1VORFNfT1BUSU9OX0tFWVMiLCJzY2VuZXJ5IiwiQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCIsIldJRFRIX1NJWkFCTEVfT1BUSU9OX0tFWVMiLCJXaWR0aFNpemFibGUiLCJ0eXBlIiwiV2lkdGhTaXphYmxlVHJhaXQiLCJwcmVmZXJyZWRXaWR0aFByb3BlcnR5IiwibWluaW11bVdpZHRoUHJvcGVydHkiLCJsb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkiLCJsb2NhbE1pbmltdW1XaWR0aFByb3BlcnR5IiwiaXNXaWR0aFJlc2l6YWJsZVByb3BlcnR5IiwiX3ByZWZlcnJlZFNpemVDaGFuZ2luZyIsIl9taW5pbXVtU2l6ZUNoYW5naW5nIiwiX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayIsIl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrIiwiY29uc3RydWN0b3IiLCJhcmdzIiwiX3VwZGF0ZVByZWZlcnJlZFdpZHRoTGlzdGVuZXIiLCJfdXBkYXRlUHJlZmVycmVkV2lkdGgiLCJiaW5kIiwiX3VwZGF0ZUxvY2FsUHJlZmVycmVkV2lkdGhMaXN0ZW5lciIsIl91cGRhdGVMb2NhbFByZWZlcnJlZFdpZHRoIiwiX3VwZGF0ZU1pbmltdW1XaWR0aExpc3RlbmVyIiwiX3VwZGF0ZU1pbmltdW1XaWR0aCIsIl91cGRhdGVMb2NhbE1pbmltdW1XaWR0aExpc3RlbmVyIiwiX3VwZGF0ZUxvY2FsTWluaW11bVdpZHRoIiwibGF6eUxpbmsiLCJ0cmFuc2Zvcm1FbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJwcmVmZXJyZWRXaWR0aCIsImFzc2VydCIsInZhbHVlIiwiaXNGaW5pdGUiLCJsb2NhbFByZWZlcnJlZFdpZHRoIiwibWluaW11bVdpZHRoIiwibG9jYWxNaW5pbXVtV2lkdGgiLCJ3aWR0aFNpemFibGUiLCJleHRlbmRzV2lkdGhTaXphYmxlIiwidmFsaWRhdGVMb2NhbFByZWZlcnJlZFdpZHRoIiwiY3VycmVudFdpZHRoIiwibG9jYWxXaWR0aCIsImVmZmVjdGl2ZU1pbmltdW1XaWR0aCIsImlkZWFsV2lkdGgiLCJNYXRoIiwiYWJzIiwiX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgiLCJtYXRyaXgiLCJpc0FsaWduZWQiLCJ0cmFuc2Zvcm0iLCJpbnZlcnNlRGVsdGFYIiwiX29uUmVlbnRyYW50UHJlZmVycmVkV2lkdGgiLCJhdWRpdE1heERpbWVuc2lvbnMiLCJfY2FsY3VsYXRlUHJlZmVycmVkV2lkdGgiLCJ0cmFuc2Zvcm1EZWx0YVgiLCJfY2FsY3VsYXRlTG9jYWxNaW5pbXVtV2lkdGgiLCJfb25SZWVudHJhbnRMb2NhbE1pbmltdW1XaWR0aCIsIl9jYWxjdWxhdGVNaW5pbXVtV2lkdGgiLCJtdXRhdGUiLCJvcHRpb25zIiwicHJvdG90eXBlIiwiX211dGF0b3JLZXlzIiwiZXhpc3RpbmdLZXlzIiwibmV3S2V5cyIsImluZGV4T2ZCb3VuZHNCYXNlZE9wdGlvbnMiLCJpbmRleE9mIiwic2xpY2UiLCJ3cmFwcGVyIiwiaXNXaWR0aFNpemFibGUiLCJub2RlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJXaWR0aFNpemFibGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogV2lkdGhTaXphYmxlIGlzIGEgdHJhaXQgdGhhdCBwcm92aWRlcyBhIG1pbmltdW0gYW5kIHByZWZlcnJlZCB3aWR0aC4gVGhlIG1pbmltdW0gd2lkdGggaXMgc2V0IGJ5IHRoZSBjb21wb25lbnQsXHJcbiAqIHNvIHRoYXQgbGF5b3V0IGNvbnRhaW5lcnMgY291bGQga25vdyBob3cgXCJzbWFsbFwiIHRoZSBjb21wb25lbnQgY2FuIGJlIG1hZGUuIFRoZSBwcmVmZXJyZWQgd2lkdGggaXMgc2V0IGJ5IHRoZVxyXG4gKiBsYXlvdXQgY29udGFpbmVyLCBhbmQgdGhlIGNvbXBvbmVudCBzaG91bGQgYWRqdXN0IGl0cyBzaXplIHNvIHRoYXQgaXQgdGFrZXMgdXAgdGhhdCB3aWR0aC5cclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb25AY29sb3JhZG8uZWR1PlxyXG4gKi9cclxuXHJcbmltcG9ydCBUaW55UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vYXhvbi9qcy9UaW55UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgbWVtb2l6ZSBmcm9tICcuLi8uLi8uLi9waGV0LWNvcmUvanMvbWVtb2l6ZS5qcyc7XHJcbmltcG9ydCB7IERlbGF5ZWRNdXRhdGUsIE5vZGUsIFJFUVVJUkVTX0JPVU5EU19PUFRJT05fS0VZUywgc2NlbmVyeSB9IGZyb20gJy4uL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgQ29uc3RydWN0b3IgZnJvbSAnLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL0NvbnN0cnVjdG9yLmpzJztcclxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9JbnRlbnRpb25hbEFueS5qcyc7XHJcblxyXG4vLyBQb3NpdGlvbiBjaGFuZ2VzIHNtYWxsZXIgdGhhbiB0aGlzIHdpbGwgYmUgaWdub3JlZFxyXG5jb25zdCBDSEFOR0VfUE9TSVRJT05fVEhSRVNIT0xEID0gMWUtOTtcclxuXHJcbmV4cG9ydCBjb25zdCBXSURUSF9TSVpBQkxFX09QVElPTl9LRVlTID0gW1xyXG4gICdwcmVmZXJyZWRXaWR0aCcsXHJcbiAgJ21pbmltdW1XaWR0aCcsXHJcbiAgJ2xvY2FsUHJlZmVycmVkV2lkdGgnLFxyXG4gICdsb2NhbE1pbmltdW1XaWR0aCcsXHJcbiAgJ3dpZHRoU2l6YWJsZSdcclxuXTtcclxuXHJcbmV4cG9ydCB0eXBlIFdpZHRoU2l6YWJsZU9wdGlvbnMgPSB7XHJcbiAgLy8gU2V0cyB0aGUgcHJlZmVycmVkIHdpZHRoIG9mIHRoZSBOb2RlIGluIHRoZSBwYXJlbnQgY29vcmRpbmF0ZSBmcmFtZS4gTm9kZXMgdGhhdCBpbXBsZW1lbnQgdGhpcyB3aWxsIGF0dGVtcHQgdG8ga2VlcFxyXG4gIC8vIHRoZWlyIGBub2RlLndpZHRoYCBhdCB0aGlzIHZhbHVlLiBJZiBudWxsLCB0aGUgbm9kZSB3aWxsIGxpa2VseSBzZXQgaXRzIGNvbmZpZ3VyYXRpb24gdG8gdGhlIG1pbmltdW0gd2lkdGguXHJcbiAgLy8gTk9URTogY2hhbmdpbmcgdGhpcyBvciBsb2NhbFByZWZlcnJlZFdpZHRoIHdpbGwgYWRqdXN0IHRoZSBvdGhlci5cclxuICAvLyBOT1RFOiBwcmVmZXJyZWRXaWR0aCBpcyBub3QgZ3VhcmFudGVlZCBjdXJyZW50bHkuIFRoZSBjb21wb25lbnQgbWF5IGVuZCB1cCBoYXZpbmcgYSBzbWFsbGVyIG9yIGxhcmdlciBzaXplXHJcbiAgcHJlZmVycmVkV2lkdGg/OiBudW1iZXIgfCBudWxsO1xyXG5cclxuICAvLyBTZXRzIHRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSBOb2RlIGluIHRoZSBwYXJlbnQgY29vcmRpbmF0ZSBmcmFtZS4gVXN1YWxseSBub3QgZGlyZWN0bHkgc2V0IGJ5IGEgY2xpZW50LlxyXG4gIC8vIFVzdWFsbHkgYSByZXNpemFibGUgTm9kZSB3aWxsIHNldCBpdHMgbG9jYWxNaW5pbXVtV2lkdGggKGFuZCB0aGF0IHdpbGwgZ2V0IHRyYW5zZmVycmVkIHRvIHRoaXMgdmFsdWUgaW4gdGhlXHJcbiAgLy8gcGFyZW50IGNvb3JkaW5hdGUgZnJhbWUpLlxyXG4gIC8vIE5PVEU6IGNoYW5naW5nIHRoaXMgb3IgbG9jYWxNaW5pbXVtV2lkdGggd2lsbCBhZGp1c3QgdGhlIG90aGVyLlxyXG4gIC8vIE5PVEU6IHdoZW4gdGhlIE5vZGUncyB0cmFuc2Zvcm0gaXMgdXBkYXRlZCwgdGhpcyB2YWx1ZSBpcyByZWNvbXB1dGVkIGJhc2VkIG9uIGxvY2FsTWluaW11bVdpZHRoXHJcbiAgbWluaW11bVdpZHRoPzogbnVtYmVyIHwgbnVsbDtcclxuXHJcbiAgLy8gU2V0cyB0aGUgcHJlZmVycmVkIHdpZHRoIG9mIHRoZSBOb2RlIGluIHRoZSBsb2NhbCBjb29yZGluYXRlIGZyYW1lLlxyXG4gIC8vIE5PVEU6IGNoYW5naW5nIHRoaXMgb3IgcHJlZmVycmVkV2lkdGggd2lsbCBhZGp1c3QgdGhlIG90aGVyLlxyXG4gIC8vIE5PVEU6IHdoZW4gdGhlIE5vZGUncyB0cmFuc2Zvcm0gaXMgdXBkYXRlZCwgdGhpcyB2YWx1ZSBpcyByZWNvbXB1dGVkIGJhc2VkIG9uIHByZWZlcnJlZFdpZHRoXHJcbiAgLy8gTk9URTogbG9jYWxQcmVmZXJyZWRXaWR0aCBpcyBub3QgZ3VhcmFudGVlZCBjdXJyZW50bHkuIFRoZSBjb21wb25lbnQgbWF5IGVuZCB1cCBoYXZpbmcgYSBzbWFsbGVyIG9yIGxhcmdlciBzaXplXHJcbiAgbG9jYWxQcmVmZXJyZWRXaWR0aD86IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIFNldHMgdGhlIG1pbmltdW0gd2lkdGggb2YgdGhlIE5vZGUgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgZnJhbWUuIFVzdWFsbHkgc2V0IGJ5IHRoZSByZXNpemFibGUgTm9kZSBpdHNlbGYgdG9cclxuICAvLyBpbmRpY2F0ZSB3aGF0IHByZWZlcnJlZCBzaXplcyBhcmUgcG9zc2libGUuXHJcbiAgLy8gTk9URTogY2hhbmdpbmcgdGhpcyBvciBtaW5pbXVtV2lkdGggd2lsbCBhZGp1c3QgdGhlIG90aGVyLlxyXG4gIGxvY2FsTWluaW11bVdpZHRoPzogbnVtYmVyIHwgbnVsbDtcclxuXHJcbiAgLy8gV2hldGhlciB0aGlzIGNvbXBvbmVudCB3aWxsIGhhdmUgaXRzIHByZWZlcnJlZCBzaXplIHNldCBieSB0aGluZ3MgbGlrZSBsYXlvdXQgY29udGFpbmVycy4gSWYgdGhpcyBpcyBzZXQgdG8gZmFsc2UsXHJcbiAgLy8gaXQncyByZWNvbW1lbmRlZCB0byBzZXQgc29tZSBzb3J0IG9mIHByZWZlcnJlZCBzaXplIChzbyB0aGF0IGl0IHdvbid0IGdvIHRvIDApXHJcbiAgd2lkdGhTaXphYmxlPzogYm9vbGVhbjtcclxufTtcclxuXHJcbi8vIElNUE9SVEFOVDogSWYgeW91J3JlIGNvbWJpbmluZyB0aGlzIGluLCB0eXBpY2FsbHkgZG9uJ3QgcGFzcyBvcHRpb25zIHRoYXQgV2lkdGhTaXphYmxlIHdvdWxkIHRha2UgdGhyb3VnaCB0aGVcclxuLy8gY29uc3RydWN0b3IuIEl0IHdpbGwgaGl0IE5vZGUncyBtdXRhdGUoKSBsaWtlbHksIGFuZCB0aGVuIHdpbGwgZmFpbCBiZWNhdXNlIHdlIGhhdmVuJ3QgYmVlbiBhYmxlIHRvIHNldCB0aGVcclxuLy8gdmFsdWVzIHlldC4gSWYgeW91J3JlIG1ha2luZyBzb21ldGhpbmcgV2lkdGhTaXphYmxlLCBwbGVhc2UgdXNlIGEgbGF0ZXIgbXV0YXRlKCkgdG8gcGFzcyB0aGVzZSBvcHRpb25zIHRocm91Z2guXHJcbi8vIFRoZXkgV0lMTCBiZSBjYXVnaHQgYnkgYXNzZXJ0aW9ucyBpZiBzb21lb25lIGFkZHMgb25lIG9mIHRob3NlIG9wdGlvbnMsIGJ1dCBpdCBjb3VsZCBiZSBhIHNpbGVudCBidWcgaWYgbm8gb25lXHJcbi8vIGlzIHlldCBwYXNzaW5nIHRob3NlIG9wdGlvbnMgdGhyb3VnaC5cclxuY29uc3QgV2lkdGhTaXphYmxlID0gbWVtb2l6ZSggPFN1cGVyVHlwZSBleHRlbmRzIENvbnN0cnVjdG9yPE5vZGU+PiggdHlwZTogU3VwZXJUeXBlICkgPT4ge1xyXG4gIGNvbnN0IFdpZHRoU2l6YWJsZVRyYWl0ID0gRGVsYXllZE11dGF0ZSggJ1dpZHRoU2l6YWJsZScsIFdJRFRIX1NJWkFCTEVfT1BUSU9OX0tFWVMsIGNsYXNzIFdpZHRoU2l6YWJsZVRyYWl0IGV4dGVuZHMgdHlwZSB7XHJcblxyXG4gICAgLy8gcGFyZW50L2xvY2FsIHByZWZlcnJlZC9taW5pbXVtIFByb3BlcnRpZXMuIFNlZSB0aGUgb3B0aW9ucyBhYm92ZSBmb3IgbW9yZSBkb2N1bWVudGF0aW9uXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHJlZmVycmVkV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+ID0gbmV3IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiggbnVsbCApO1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG1pbmltdW1XaWR0aFByb3BlcnR5OiBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4gPSBuZXcgVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+KCBudWxsICk7XHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5OiBUaW55UHJvcGVydHk8bnVtYmVyIHwgbnVsbD4gPSBuZXcgVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+KCBudWxsICk7XHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxNaW5pbXVtV2lkdGhQcm9wZXJ0eTogVGlueVByb3BlcnR5PG51bWJlciB8IG51bGw+ID0gbmV3IFRpbnlQcm9wZXJ0eTxudW1iZXIgfCBudWxsPiggbnVsbCApO1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGlzV2lkdGhSZXNpemFibGVQcm9wZXJ0eTogVGlueVByb3BlcnR5PGJvb2xlYW4+ID0gbmV3IFRpbnlQcm9wZXJ0eTxib29sZWFuPiggdHJ1ZSApO1xyXG5cclxuICAgIC8vIEZsYWdzIHNvIHRoYXQgd2UgY2FuIGNoYW5nZSBvbmUgKHBhcmVudC9sb2NhbCkgdmFsdWUgYW5kIG5vdCBlbnRlciBhbiBpbmZpbml0ZSBsb29wIGNoYW5naW5nIHRoZSBvdGhlcnMuXHJcbiAgICAvLyBXZSB3YW50IHRvIGxvY2sgb3V0IGFsbCBvdGhlciBsb2NhbCBvciBub24tbG9jYWwgcHJlZmVycmVkIG1pbmltdW0gc2l6ZXMsIHdoZXRoZXIgaW4gSGVpZ2h0U2l6YWJsZSBvciBXaWR0aFNpemFibGVcclxuICAgIC8vIE5PVEU6IFdlIGFyZSBtZXJnaW5nIGRlY2xhcmF0aW9ucyBiZXR3ZWVuIEhlaWdodFNpemFibGUgYW5kIFdpZHRoU2l6YWJsZS4gSWYgU2l6YWJsZSBpcyB1c2VkIHRoZXNlIGZsYWdzXHJcbiAgICAvLyB3aWxsIGJlIHNoYXJlZCBieSBib3RoIEhlaWdodFNpemFibGUgYW5kIFdpZHRoU2l6YWJsZS5cclxuICAgIHByb3RlY3RlZCBfcHJlZmVycmVkU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcbiAgICBwcm90ZWN0ZWQgX21pbmltdW1TaXplQ2hhbmdpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBXZSdsbCBuZWVkIHRvIGRldGVjdCByZWVudHJhbmN5IHdoZW4gc2V0dGluZyB0aGUgZHVhbCBvZiB0aGUgcHJlZmVycmVkL21pbmltdW0gcHJvcGVydGllcyAoZS5nLiBsb2NhbCB2cyBwYXJlbnQpLlxyXG4gICAgLy8gSWYgd2UgZ2V0IGEgcmVlbnRyYW50IGNhc2UsIHdlJ2xsIG5lZWQgdG8gZGV0ZWN0IGl0IGFuZCBjbGVhciB0aGluZ3MgdXAgYXQgdGhlIGVuZCAodXBkYXRpbmcgdGhlIG1pbmltdW0gc2l6ZVxyXG4gICAgLy8gaW4gdGhlIHBhcmVudCBjb29yZGluYXRlIGZyYW1lLCBhbmQgdGhlIHByZWZlcnJlZCBzaXplIGluIHRoZSBsb2NhbCBjb29yZGluYXRlIGZyYW1lKS5cclxuICAgIC8vIEFuIGV4YW1wbGUgaXMgaWYgdGhlIG1pbmltdW0gc2l6ZSBpcyBzZXQsIGFuZCB0aGF0IHRyaWdnZXJzIGEgbGlzdGVuZXIgdGhhdCBVUERBVEVTIHNvbWV0aGluZyB0aGF0IGNoYW5nZXMgdGhlXHJcbiAgICAvLyBtaW5pbXVtIHNpemUsIHdlJ2xsIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGxvY2FsIG1pbmltdW0gc2l6ZSBpcyB1cGRhdGVkIEFGVEVSIGV2ZXJ5dGhpbmcgaGFzIGhhcHBlbmVkLlxyXG4gICAgLy8gVGhlc2UgbG9ja3MgYXJlIHVzZWQgdG8gZGV0ZWN0IHRoZXNlIGNhc2VzLCBhbmQgdGhlbiBydW4gdGhlIGFwcHJvcHJpYXRlIHVwZGF0ZXMgYWZ0ZXJ3YXJkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZVxyXG4gICAgLy8gbG9jYWwgYW5kIHBhcmVudCB2YWx1ZXMgYXJlIGluIHN5bmMgKGJhc2VkIG9uIHRoZSB0cmFuc2Zvcm0gdXNlZCkuXHJcbiAgICBwcm90ZWN0ZWQgX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xyXG4gICAgcHJvdGVjdGVkIF9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gZmFsc2U7XHJcblxyXG4gICAgLy8gRXhwb3NlIGxpc3RlbmVycywgc28gdGhhdCB3ZSdsbCBiZSBhYmxlIHRvIGhvb2sgdGhlbSB1cCB0byB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uIGluIFNpemFibGVcclxuICAgIHByb3RlY3RlZCBfdXBkYXRlUHJlZmVycmVkV2lkdGhMaXN0ZW5lcjogKCkgPT4gdm9pZDtcclxuICAgIHByb3RlY3RlZCBfdXBkYXRlTG9jYWxQcmVmZXJyZWRXaWR0aExpc3RlbmVyOiAoKSA9PiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIF91cGRhdGVNaW5pbXVtV2lkdGhMaXN0ZW5lcjogKCkgPT4gdm9pZDtcclxuICAgIHByb3RlY3RlZCBfdXBkYXRlTG9jYWxNaW5pbXVtV2lkdGhMaXN0ZW5lcjogKCkgPT4gdm9pZDtcclxuXHJcbiAgICAvLyBJTVBPUlRBTlQ6IElmIHlvdSdyZSBjb21iaW5pbmcgdGhpcyBpbiwgdHlwaWNhbGx5IGRvbid0IHBhc3Mgb3B0aW9ucyB0aGF0IFdpZHRoU2l6YWJsZSB3b3VsZCB0YWtlIHRocm91Z2ggdGhlXHJcbiAgICAvLyBjb25zdHJ1Y3Rvci4gSXQgd2lsbCBoaXQgTm9kZSdzIG11dGF0ZSgpIGxpa2VseSwgYW5kIHRoZW4gd2lsbCBmYWlsIGJlY2F1c2Ugd2UgaGF2ZW4ndCBiZWVuIGFibGUgdG8gc2V0IHRoZVxyXG4gICAgLy8gdmFsdWVzIHlldC4gSWYgeW91J3JlIG1ha2luZyBzb21ldGhpbmcgV2lkdGhTaXphYmxlLCBwbGVhc2UgdXNlIGEgbGF0ZXIgbXV0YXRlKCkgdG8gcGFzcyB0aGVzZSBvcHRpb25zIHRocm91Z2guXHJcbiAgICAvLyBUaGV5IFdJTEwgYmUgY2F1Z2h0IGJ5IGFzc2VydGlvbnMgaWYgc29tZW9uZSBhZGRzIG9uZSBvZiB0aG9zZSBvcHRpb25zLCBidXQgaXQgY291bGQgYmUgYSBzaWxlbnQgYnVnIGlmIG5vIG9uZVxyXG4gICAgLy8gaXMgeWV0IHBhc3NpbmcgdGhvc2Ugb3B0aW9ucyB0aHJvdWdoLlxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCAuLi5hcmdzOiBJbnRlbnRpb25hbEFueVtdICkge1xyXG4gICAgICBzdXBlciggLi4uYXJncyApO1xyXG5cclxuICAgICAgdGhpcy5fdXBkYXRlUHJlZmVycmVkV2lkdGhMaXN0ZW5lciA9IHRoaXMuX3VwZGF0ZVByZWZlcnJlZFdpZHRoLmJpbmQoIHRoaXMgKTtcclxuICAgICAgdGhpcy5fdXBkYXRlTG9jYWxQcmVmZXJyZWRXaWR0aExpc3RlbmVyID0gdGhpcy5fdXBkYXRlTG9jYWxQcmVmZXJyZWRXaWR0aC5iaW5kKCB0aGlzICk7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZU1pbmltdW1XaWR0aExpc3RlbmVyID0gdGhpcy5fdXBkYXRlTWluaW11bVdpZHRoLmJpbmQoIHRoaXMgKTtcclxuICAgICAgdGhpcy5fdXBkYXRlTG9jYWxNaW5pbXVtV2lkdGhMaXN0ZW5lciA9IHRoaXMuX3VwZGF0ZUxvY2FsTWluaW11bVdpZHRoLmJpbmQoIHRoaXMgKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgb3Bwb3NpdGUgb2YgcGFyZW50L2xvY2FsIHdoZW4gb25lIGNoYW5nZXNcclxuICAgICAgdGhpcy5wcmVmZXJyZWRXaWR0aFByb3BlcnR5LmxhenlMaW5rKCB0aGlzLl91cGRhdGVMb2NhbFByZWZlcnJlZFdpZHRoTGlzdGVuZXIgKTtcclxuICAgICAgdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZVByZWZlcnJlZFdpZHRoTGlzdGVuZXIgKTtcclxuICAgICAgdGhpcy5taW5pbXVtV2lkdGhQcm9wZXJ0eS5sYXp5TGluayggdGhpcy5fdXBkYXRlTG9jYWxNaW5pbXVtV2lkdGhMaXN0ZW5lciApO1xyXG4gICAgICB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHkubGF6eUxpbmsoIHRoaXMuX3VwZGF0ZU1pbmltdW1XaWR0aExpc3RlbmVyICk7XHJcblxyXG4gICAgICAvLyBPbiBhIHRyYW5zZm9ybSBjaGFuZ2UsIGtlZXAgb3VyIGxvY2FsIG1pbmltdW0gKHByZXN1bWFibHkgdW5jaGFuZ2VkKSwgYW5kIG91ciBwYXJlbnQgcHJlZmVycmVkIHNpemVcclxuICAgICAgdGhpcy50cmFuc2Zvcm1FbWl0dGVyLmFkZExpc3RlbmVyKCB0aGlzLl91cGRhdGVMb2NhbFByZWZlcnJlZFdpZHRoTGlzdGVuZXIgKTtcclxuICAgICAgLy8gT24gYSB0cmFuc2Zvcm0gY2hhbmdlIHRoaXMgc2hvdWxkIHVwZGF0ZSB0aGUgbWluaW11bVxyXG4gICAgICB0aGlzLnRyYW5zZm9ybUVtaXR0ZXIuYWRkTGlzdGVuZXIoIHRoaXMuX3VwZGF0ZU1pbmltdW1XaWR0aExpc3RlbmVyICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBwcmVmZXJyZWRXaWR0aCgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5wcmVmZXJyZWRXaWR0aFByb3BlcnR5LFxyXG4gICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMucHJlZmVycmVkV2lkdGhQcm9wZXJ0eS52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHByZWZlcnJlZFdpZHRoKCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5wcmVmZXJyZWRXaWR0aFByb3BlcnR5LFxyXG4gICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gbnVsbCB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgJiYgdmFsdWUgPj0gMCApLFxyXG4gICAgICAgICdwcmVmZXJyZWRXaWR0aCBzaG91bGQgYmUgbnVsbCBvciBhIG5vbi1uZWdhdGl2ZSBmaW5pdGUgbnVtYmVyJyApO1xyXG5cclxuICAgICAgdGhpcy5wcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBsb2NhbFByZWZlcnJlZFdpZHRoKCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmxvY2FsUHJlZmVycmVkV2lkdGhQcm9wZXJ0eSxcclxuICAgICAgICAnV2lkdGhTaXphYmxlIG9wdGlvbnMgc2hvdWxkIGJlIHNldCBmcm9tIGEgbGF0ZXIgbXV0YXRlKCkgY2FsbCBpbnN0ZWFkIG9mIHRoZSBzdXBlciBjb25zdHJ1Y3RvcicgKTtcclxuICAgICAgcmV0dXJuIHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgbG9jYWxQcmVmZXJyZWRXaWR0aCggdmFsdWU6IG51bWJlciB8IG51bGwgKSB7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5LFxyXG4gICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2YWx1ZSA9PT0gbnVsbCB8fCAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgJiYgdmFsdWUgPj0gMCApLFxyXG4gICAgICAgICdsb2NhbFByZWZlcnJlZFdpZHRoIHNob3VsZCBiZSBudWxsIG9yIGEgbm9uLW5lZ2F0aXZlIGZpbml0ZSBudW1iZXInICk7XHJcblxyXG4gICAgICB0aGlzLmxvY2FsUHJlZmVycmVkV2lkdGhQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbWluaW11bVdpZHRoKCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLm1pbmltdW1XaWR0aFByb3BlcnR5LFxyXG4gICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICByZXR1cm4gdGhpcy5taW5pbXVtV2lkdGhQcm9wZXJ0eS52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IG1pbmltdW1XaWR0aCggdmFsdWU6IG51bWJlciB8IG51bGwgKSB7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMubWluaW11bVdpZHRoUHJvcGVydHksXHJcbiAgICAgICAgJ1dpZHRoU2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbHVlID09PSBudWxsIHx8ICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSggdmFsdWUgKSApICk7XHJcblxyXG4gICAgICB0aGlzLm1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBsb2NhbE1pbmltdW1XaWR0aCgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5sb2NhbE1pbmltdW1XaWR0aFByb3BlcnR5LFxyXG4gICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICByZXR1cm4gdGhpcy5sb2NhbE1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgbG9jYWxNaW5pbXVtV2lkdGgoIHZhbHVlOiBudW1iZXIgfCBudWxsICkge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHksXHJcbiAgICAgICAgJ1dpZHRoU2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbHVlID09PSBudWxsIHx8ICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSggdmFsdWUgKSApICk7XHJcblxyXG4gICAgICB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHkudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IHdpZHRoU2l6YWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5pc1dpZHRoUmVzaXphYmxlUHJvcGVydHksXHJcbiAgICAgICAgJ1dpZHRoU2l6YWJsZSBvcHRpb25zIHNob3VsZCBiZSBzZXQgZnJvbSBhIGxhdGVyIG11dGF0ZSgpIGNhbGwgaW5zdGVhZCBvZiB0aGUgc3VwZXIgY29uc3RydWN0b3InICk7XHJcbiAgICAgIHJldHVybiB0aGlzLmlzV2lkdGhSZXNpemFibGVQcm9wZXJ0eS52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgc2V0IHdpZHRoU2l6YWJsZSggdmFsdWU6IGJvb2xlYW4gKSB7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRoaXMuaXNXaWR0aFJlc2l6YWJsZVByb3BlcnR5LFxyXG4gICAgICAgICdXaWR0aFNpemFibGUgb3B0aW9ucyBzaG91bGQgYmUgc2V0IGZyb20gYSBsYXRlciBtdXRhdGUoKSBjYWxsIGluc3RlYWQgb2YgdGhlIHN1cGVyIGNvbnN0cnVjdG9yJyApO1xyXG4gICAgICB0aGlzLmlzV2lkdGhSZXNpemFibGVQcm9wZXJ0eS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgZXh0ZW5kc1dpZHRoU2l6YWJsZSgpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgICBwdWJsaWMgdmFsaWRhdGVMb2NhbFByZWZlcnJlZFdpZHRoKCk6IHZvaWQge1xyXG4gICAgICBpZiAoIGFzc2VydCApIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50V2lkdGggPSB0aGlzLmxvY2FsV2lkdGg7XHJcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlTWluaW11bVdpZHRoID0gdGhpcy5sb2NhbE1pbmltdW1XaWR0aCA9PT0gbnVsbCA/IGN1cnJlbnRXaWR0aCA6IHRoaXMubG9jYWxNaW5pbXVtV2lkdGg7XHJcbiAgICAgICAgY29uc3QgaWRlYWxXaWR0aCA9IHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aCA9PT0gbnVsbCA/IGVmZmVjdGl2ZU1pbmltdW1XaWR0aCA6IHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aDtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIG5vbi1maW5pdGUgdmFsdWVzIHdpdGggZXhhY3QgZXF1YWxpdHlcclxuICAgICAgICBhc3NlcnQoIGlkZWFsV2lkdGggPT09IGN1cnJlbnRXaWR0aCB8fCBNYXRoLmFicyggaWRlYWxXaWR0aCAtIGN1cnJlbnRXaWR0aCApIDwgMWUtNyApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBpcyBwcm92aWRlZCB0byBob29rIGludG8gdGhlIFNpemFibGUgdHJhaXQsIHNvIHRoYXQgd2UgY2FuIHVwZGF0ZSB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uXHJcbiAgICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgoKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICAgIHJldHVybiAoIHRoaXMubWF0cml4LmlzQWxpZ25lZCgpICYmIHRoaXMucHJlZmVycmVkV2lkdGggIT09IG51bGwgKVxyXG4gICAgICAgICAgICAgPyBNYXRoLmFicyggdGhpcy50cmFuc2Zvcm0uaW52ZXJzZURlbHRhWCggdGhpcy5wcmVmZXJyZWRXaWR0aCApIClcclxuICAgICAgICAgICAgIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm92aWRlcyBhIGhvb2sgdG8gU2l6YWJsZSwgc2luY2Ugd2UnbGwgbmVlZCB0byBjcm9zcy1saW5rIHRoaXMgdG8gYWxzbyB0cnkgdXBkYXRpbmcgdGhlIG9wcG9zaXRlIGRpbWVuc2lvblxyXG4gICAgcHJvdGVjdGVkIF9vblJlZW50cmFudFByZWZlcnJlZFdpZHRoKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLl91cGRhdGVMb2NhbFByZWZlcnJlZFdpZHRoTGlzdGVuZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF91cGRhdGVMb2NhbFByZWZlcnJlZFdpZHRoKCk6IHZvaWQge1xyXG4gICAgICBhc3NlcnQgJiYgdGhpcy5hdWRpdE1heERpbWVuc2lvbnMoKTtcclxuXHJcbiAgICAgIGlmICggIXRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyApIHtcclxuICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBTaW5jZSB0aGUgbG9jYWwgXCJwcmVmZXJyZWRcIiBzaXplIGlzIHRoZSBvbmUgdGhhdCB3ZSdsbCB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSBpZiB3ZSBleHBlcmllbmNlXHJcbiAgICAgICAgLy8gcmVlbnRyYW5jeSAoc2luY2Ugd2UgdHJlYXQgdGhlIG5vbi1sb2NhbCB2ZXJzaW9uIGFzIHRoZSBncm91bmQgdHJ1dGgpLCB3ZSdsbCBsb29wIGhlcmUgdW50aWwgd2UgZGlkbid0IGdldFxyXG4gICAgICAgIC8vIGFuIGF0dGVtcHQgdG8gY2hhbmdlIGl0LiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgYWZ0ZXIgY2hhbmdlcywgd2UnbGwgaGF2ZSBhIGNvbnNpc3RlbnQgcHJlZmVycmVkIGFuZFxyXG4gICAgICAgIC8vIGxvY2FsUHJlZmVycmVkIHNpemUuXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgY29uc3QgbG9jYWxQcmVmZXJyZWRXaWR0aCA9IHRoaXMuX2NhbGN1bGF0ZUxvY2FsUHJlZmVycmVkV2lkdGgoKTtcclxuXHJcbiAgICAgICAgICBpZiAoIHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgIGxvY2FsUHJlZmVycmVkV2lkdGggPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgTWF0aC5hYnMoIHRoaXMubG9jYWxQcmVmZXJyZWRXaWR0aFByb3BlcnR5LnZhbHVlIC0gbG9jYWxQcmVmZXJyZWRXaWR0aCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcclxuICAgICAgICAgICAgdGhpcy5sb2NhbFByZWZlcnJlZFdpZHRoUHJvcGVydHkudmFsdWUgPSBsb2NhbFByZWZlcnJlZFdpZHRoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoIHRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayApO1xyXG5cclxuICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBpcyBwcm92aWRlZCB0byBob29rIGludG8gdGhlIFNpemFibGUgdHJhaXQsIHNvIHRoYXQgd2UgY2FuIHVwZGF0ZSB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uXHJcbiAgICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZVByZWZlcnJlZFdpZHRoKCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICByZXR1cm4gKCB0aGlzLm1hdHJpeC5pc0FsaWduZWQoKSAmJiB0aGlzLmxvY2FsUHJlZmVycmVkV2lkdGggIT09IG51bGwgKVxyXG4gICAgICAgICAgICAgPyBNYXRoLmFicyggdGhpcy50cmFuc2Zvcm0udHJhbnNmb3JtRGVsdGFYKCB0aGlzLmxvY2FsUHJlZmVycmVkV2lkdGggKSApXHJcbiAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfdXBkYXRlUHJlZmVycmVkV2lkdGgoKTogdm9pZCB7XHJcbiAgICAgIGlmICggIXRoaXMuX3ByZWZlcnJlZFNpemVDaGFuZ2luZyApIHtcclxuICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJlZmVycmVkV2lkdGggPSB0aGlzLl9jYWxjdWxhdGVQcmVmZXJyZWRXaWR0aCgpO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMucHJlZmVycmVkV2lkdGhQcm9wZXJ0eS52YWx1ZSA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgcHJlZmVycmVkV2lkdGggPT09IG51bGwgfHxcclxuICAgICAgICAgICAgIE1hdGguYWJzKCB0aGlzLnByZWZlcnJlZFdpZHRoUHJvcGVydHkudmFsdWUgLSBwcmVmZXJyZWRXaWR0aCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcclxuICAgICAgICAgIHRoaXMucHJlZmVycmVkV2lkdGhQcm9wZXJ0eS52YWx1ZSA9IHByZWZlcnJlZFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gSGVyZSwgaW4gdGhlIGNhc2Ugb2YgcmVlbnRyYW5jZSwgd2UnbGwgYWN0dWFsbHkgd2FudCB0byBzd2l0Y2ggdG8gdXBkYXRpbmcgdGhlIGxvY2FsIHByZWZlcnJlZCBzaXplLCBzaW5jZVxyXG4gICAgICAgIC8vIGdpdmVuIGFueSBvdGhlciBjaGFuZ2VzIGl0IHNob3VsZCBiZSB0aGUgcHJpbWFyeSBvbmUgdG8gY2hhbmdlLlxyXG4gICAgICAgIGlmICggdGhpcy5fcHJlZmVycmVkU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrICkge1xyXG4gICAgICAgICAgdGhpcy5fb25SZWVudHJhbnRQcmVmZXJyZWRXaWR0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLl9wcmVmZXJyZWRTaXplQ2hhbmdlQXR0ZW1wdER1cmluZ0xvY2sgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBpcyBwcm92aWRlZCB0byBob29rIGludG8gdGhlIFNpemFibGUgdHJhaXQsIHNvIHRoYXQgd2UgY2FuIHVwZGF0ZSB0aGUgb3Bwb3NpdGUgZGltZW5zaW9uXHJcbiAgICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZUxvY2FsTWluaW11bVdpZHRoKCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICByZXR1cm4gKCB0aGlzLm1hdHJpeC5pc0FsaWduZWQoKSAmJiB0aGlzLm1pbmltdW1XaWR0aCAhPT0gbnVsbCApXHJcbiAgICAgICAgICAgICA/IE1hdGguYWJzKCB0aGlzLnRyYW5zZm9ybS5pbnZlcnNlRGVsdGFYKCB0aGlzLm1pbmltdW1XaWR0aCApIClcclxuICAgICAgICAgICAgIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX29uUmVlbnRyYW50TG9jYWxNaW5pbXVtV2lkdGgoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZU1pbmltdW1XaWR0aExpc3RlbmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfdXBkYXRlTG9jYWxNaW5pbXVtV2lkdGgoKTogdm9pZCB7XHJcbiAgICAgIGlmICggIXRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgKSB7XHJcbiAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2luZyA9IHRydWU7XHJcblxyXG4gICAgICAgIGNvbnN0IGxvY2FsTWluaW11bVdpZHRoID0gdGhpcy5fY2FsY3VsYXRlTG9jYWxNaW5pbXVtV2lkdGgoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMubG9jYWxNaW5pbXVtV2lkdGhQcm9wZXJ0eS52YWx1ZSA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgbG9jYWxNaW5pbXVtV2lkdGggPT09IG51bGwgfHxcclxuICAgICAgICAgICAgIE1hdGguYWJzKCB0aGlzLmxvY2FsTWluaW11bVdpZHRoUHJvcGVydHkudmFsdWUgLSBsb2NhbE1pbmltdW1XaWR0aCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcclxuICAgICAgICAgIHRoaXMubG9jYWxNaW5pbXVtV2lkdGhQcm9wZXJ0eS52YWx1ZSA9IGxvY2FsTWluaW11bVdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5naW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIEhlcmUsIGluIHRoZSBjYXNlIG9mIHJlZW50cmFuY2UsIHdlJ2xsIGFjdHVhbGx5IHdhbnQgdG8gc3dpdGNoIHRvIHVwZGF0aW5nIHRoZSBub24tbG9jYWwgbWluaW11bSBzaXplLCBzaW5jZVxyXG4gICAgICAgIC8vIGdpdmVuIGFueSBvdGhlciBjaGFuZ2VzIGl0IHNob3VsZCBiZSB0aGUgcHJpbWFyeSBvbmUgdG8gY2hhbmdlLlxyXG4gICAgICAgIGlmICggdGhpcy5fbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayApIHtcclxuICAgICAgICAgIHRoaXMuX29uUmVlbnRyYW50TG9jYWxNaW5pbXVtV2lkdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2VBdHRlbXB0RHVyaW5nTG9jayA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGlzIGlzIHByb3ZpZGVkIHRvIGhvb2sgaW50byB0aGUgU2l6YWJsZSB0cmFpdCwgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoZSBvcHBvc2l0ZSBkaW1lbnNpb25cclxuICAgIHByb3RlY3RlZCBfY2FsY3VsYXRlTWluaW11bVdpZHRoKCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgICByZXR1cm4gKCB0aGlzLm1hdHJpeC5pc0FsaWduZWQoKSAmJiB0aGlzLmxvY2FsTWluaW11bVdpZHRoICE9PSBudWxsIClcclxuICAgICAgICAgICAgID8gTWF0aC5hYnMoIHRoaXMudHJhbnNmb3JtLnRyYW5zZm9ybURlbHRhWCggdGhpcy5sb2NhbE1pbmltdW1XaWR0aCApIClcclxuICAgICAgICAgICAgIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF91cGRhdGVNaW5pbXVtV2lkdGgoKTogdm9pZCB7XHJcbiAgICAgIGlmICggIXRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgKSB7XHJcbiAgICAgICAgdGhpcy5fbWluaW11bVNpemVDaGFuZ2luZyA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIFNpbmNlIHRoZSBub24tbG9jYWwgXCJtaW5pbXVtXCIgc2l6ZSBpcyB0aGUgb25lIHRoYXQgd2UnbGwgd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgaWYgd2UgZXhwZXJpZW5jZVxyXG4gICAgICAgIC8vIHJlZW50cmFuY3kgKHNpbmNlIHdlIHRyZWF0IHRoZSBsb2NhbCB2ZXJzaW9uIGFzIHRoZSBncm91bmQgdHJ1dGgpLCB3ZSdsbCBsb29wIGhlcmUgdW50aWwgd2UgZGlkbid0IGdldFxyXG4gICAgICAgIC8vIGFuIGF0dGVtcHQgdG8gY2hhbmdlIGl0LiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgYWZ0ZXIgY2hhbmdlcywgd2UnbGwgaGF2ZSBhIGNvbnNpc3RlbnQgbWluaW11bSBhbmRcclxuICAgICAgICAvLyBsb2NhbE1pbmltdW0gc2l6ZS5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgY29uc3QgbWluaW11bVdpZHRoID0gdGhpcy5fY2FsY3VsYXRlTWluaW11bVdpZHRoKCk7XHJcblxyXG4gICAgICAgICAgaWYgKCB0aGlzLm1pbmltdW1XaWR0aFByb3BlcnR5LnZhbHVlID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgIG1pbmltdW1XaWR0aCA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICBNYXRoLmFicyggdGhpcy5taW5pbXVtV2lkdGhQcm9wZXJ0eS52YWx1ZSAtIG1pbmltdW1XaWR0aCApID4gQ0hBTkdFX1BPU0lUSU9OX1RIUkVTSE9MRCApIHtcclxuICAgICAgICAgICAgdGhpcy5taW5pbXVtV2lkdGhQcm9wZXJ0eS52YWx1ZSA9IG1pbmltdW1XaWR0aDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKCB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrICk7XHJcblxyXG4gICAgICAgIHRoaXMuX21pbmltdW1TaXplQ2hhbmdpbmcgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLl9taW5pbXVtU2l6ZUNoYW5nZUF0dGVtcHREdXJpbmdMb2NrID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvdmVycmlkZSBtdXRhdGUoIG9wdGlvbnM/OiBXaWR0aFNpemFibGVPcHRpb25zICYgUGFyYW1ldGVyczxJbnN0YW5jZVR5cGU8U3VwZXJUeXBlPlsgJ211dGF0ZScgXT5bIDAgXSApOiB0aGlzIHtcclxuICAgICAgcmV0dXJuIHN1cGVyLm11dGF0ZSggb3B0aW9ucyApO1xyXG4gICAgfVxyXG4gIH0gKTtcclxuXHJcbiAgLy8gSWYgd2UncmUgZXh0ZW5kaW5nIGludG8gYSBOb2RlIHR5cGUsIGluY2x1ZGUgb3B0aW9uIGtleXNcclxuICBpZiAoIHR5cGUucHJvdG90eXBlLl9tdXRhdG9yS2V5cyApIHtcclxuICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHR5cGUucHJvdG90eXBlLl9tdXRhdG9yS2V5cztcclxuICAgIGNvbnN0IG5ld0tleXMgPSBXSURUSF9TSVpBQkxFX09QVElPTl9LRVlTO1xyXG4gICAgY29uc3QgaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyA9IGV4aXN0aW5nS2V5cy5pbmRleE9mKCBSRVFVSVJFU19CT1VORFNfT1BUSU9OX0tFWVNbIDAgXSApO1xyXG4gICAgV2lkdGhTaXphYmxlVHJhaXQucHJvdG90eXBlLl9tdXRhdG9yS2V5cyA9IFtcclxuICAgICAgLi4uZXhpc3RpbmdLZXlzLnNsaWNlKCAwLCBpbmRleE9mQm91bmRzQmFzZWRPcHRpb25zICksXHJcbiAgICAgIC4uLm5ld0tleXMsXHJcbiAgICAgIC4uLmV4aXN0aW5nS2V5cy5zbGljZSggaW5kZXhPZkJvdW5kc0Jhc2VkT3B0aW9ucyApXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFdpZHRoU2l6YWJsZVRyYWl0O1xyXG59ICk7XHJcblxyXG4vLyBTb21lIHR5cGVzY3JpcHQgZ3ltbmFzdGljcyB0byBwcm92aWRlIGEgdXNlci1kZWZpbmVkIHR5cGUgZ3VhcmQgdGhhdCB0cmVhdHMgc29tZXRoaW5nIGFzIHdpZHRoU2l6YWJsZVxyXG4vLyBXZSBuZWVkIHRvIGRlZmluZSBhbiB1bnVzZWQgZnVuY3Rpb24gd2l0aCBhIGNvbmNyZXRlIHR5cGUsIHNvIHRoYXQgd2UgY2FuIGV4dHJhY3QgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBmdW5jdGlvblxyXG4vLyBhbmQgcHJvdmlkZSBhIHR5cGUgZm9yIGEgTm9kZSB0aGF0IGV4dGVuZHMgdGhpcyB0eXBlLlxyXG5jb25zdCB3cmFwcGVyID0gKCkgPT4gV2lkdGhTaXphYmxlKCBOb2RlICk7XHJcbmV4cG9ydCB0eXBlIFdpZHRoU2l6YWJsZU5vZGUgPSBJbnN0YW5jZVR5cGU8UmV0dXJuVHlwZTx0eXBlb2Ygd3JhcHBlcj4+O1xyXG5cclxuY29uc3QgaXNXaWR0aFNpemFibGUgPSAoIG5vZGU6IE5vZGUgKTogbm9kZSBpcyBXaWR0aFNpemFibGVOb2RlID0+IHtcclxuICByZXR1cm4gbm9kZS53aWR0aFNpemFibGU7XHJcbn07XHJcbmNvbnN0IGV4dGVuZHNXaWR0aFNpemFibGUgPSAoIG5vZGU6IE5vZGUgKTogbm9kZSBpcyBXaWR0aFNpemFibGVOb2RlID0+IHtcclxuICByZXR1cm4gbm9kZS5leHRlbmRzV2lkdGhTaXphYmxlO1xyXG59O1xyXG5cclxuc2NlbmVyeS5yZWdpc3RlciggJ1dpZHRoU2l6YWJsZScsIFdpZHRoU2l6YWJsZSApO1xyXG5leHBvcnQgZGVmYXVsdCBXaWR0aFNpemFibGU7XHJcbmV4cG9ydCB7IGlzV2lkdGhTaXphYmxlLCBleHRlbmRzV2lkdGhTaXphYmxlIH07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsWUFBWSxNQUFNLGtDQUFrQztBQUMzRCxPQUFPQyxPQUFPLE1BQU0sa0NBQWtDO0FBQ3RELFNBQVNDLGFBQWEsRUFBRUMsSUFBSSxFQUFFQywyQkFBMkIsRUFBRUMsT0FBTyxRQUFRLGVBQWU7QUFJekY7QUFDQSxNQUFNQyx5QkFBeUIsR0FBRyxJQUFJO0FBRXRDLE9BQU8sTUFBTUMseUJBQXlCLEdBQUcsQ0FDdkMsZ0JBQWdCLEVBQ2hCLGNBQWMsRUFDZCxxQkFBcUIsRUFDckIsbUJBQW1CLEVBQ25CLGNBQWMsQ0FDZjtBQWdDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsWUFBWSxHQUFHUCxPQUFPLENBQXlDUSxJQUFlLElBQU07RUFDeEYsTUFBTUMsaUJBQWlCLEdBQUdSLGFBQWEsQ0FBRSxjQUFjLEVBQUVLLHlCQUF5QixFQUFFLE1BQU1HLGlCQUFpQixTQUFTRCxJQUFJLENBQUM7SUFFdkg7SUFDZ0JFLHNCQUFzQixHQUFnQyxJQUFJWCxZQUFZLENBQWlCLElBQUssQ0FBQztJQUM3Rlksb0JBQW9CLEdBQWdDLElBQUlaLFlBQVksQ0FBaUIsSUFBSyxDQUFDO0lBQzNGYSwyQkFBMkIsR0FBZ0MsSUFBSWIsWUFBWSxDQUFpQixJQUFLLENBQUM7SUFDbEdjLHlCQUF5QixHQUFnQyxJQUFJZCxZQUFZLENBQWlCLElBQUssQ0FBQztJQUNoR2Usd0JBQXdCLEdBQTBCLElBQUlmLFlBQVksQ0FBVyxJQUFLLENBQUM7O0lBRW5HO0lBQ0E7SUFDQTtJQUNBO0lBQ1VnQixzQkFBc0IsR0FBRyxLQUFLO0lBQzlCQyxvQkFBb0IsR0FBRyxLQUFLOztJQUV0QztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lB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