// Copyright 2014-2023, University of Colorado Boulder

/**
 * This is a property that can be rewound, and when rewound it goes back to the value that was last set by
 * storeRewindValueNoNotify. In this sim, the rewind value is stored at the initial configuration of a mode, or when a
 * user modifies the position of a body.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Aaron Davis (PhET Interactive Simulations)
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import Property from '../../../../axon/js/Property.js';
import gravityAndOrbits from '../../gravityAndOrbits.js';
import Tandem from '../../../../tandem/js/Tandem.js';
import IOType from '../../../../tandem/js/types/IOType.js';
import { combineOptions } from '../../../../phet-core/js/optionize.js';
class RewindableProperty extends Property {
  /**
   * An observable Property that triggers notifications when the value changes.
   * This caching implementation should be kept in sync with the other parametric IO Type caching implementations.
   */
  static RewindablePropertyIO = parameterType => {
    assert && assert(parameterType, 'RewindablePropertyIO needs parameterType');
    const cacheKey = parameterType;
    if (!cache.has(cacheKey)) {
      const PropertyIOImpl = Property.PropertyIO(parameterType);
      cache.set(cacheKey, new IOType(`RewindablePropertyIO<${parameterType.typeName}>`, {
        valueType: RewindableProperty,
        parameterTypes: [parameterType],
        documentation: 'Observable values that send out notifications when the value changes. This differs from the ' + 'traditional listener pattern in that added listeners also receive a callback with the current value ' + 'when the listeners are registered. This is a widely-used pattern in PhET-iO simulations.',
        supertype: PropertyIOImpl,
        toStateObject: property => {
          const stateObject = PropertyIOImpl.toStateObject(property);
          stateObject.rewindValue = parameterType.toStateObject(property.rewindValue);
          return stateObject;
        },
        applyState: (property, stateObject) => {
          PropertyIOImpl.applyState(property, stateObject);
          property.rewindValue = parameterType.fromStateObject(stateObject.rewindValue);
          property.updateDifferentProperty();
        },
        stateSchema: {
          rewindValue: parameterType
        }
      }));
    }
    return cache.get(cacheKey);
  };

  /**
   * @param changeRewindValueProperty - whether the newly set value should be captured as a rewindable point
   * @param value
   * @param [providedOptions]
   */
  constructor(changeRewindValueProperty, value, providedOptions) {
    const options = combineOptions({
      tandem: Tandem.OPTIONAL,
      phetioOuterType: RewindableProperty.RewindablePropertyIO
    }, providedOptions);
    super(value, options);

    // the "initial condition" the property can be rewound to, different than the overall "reset" value
    this.rewindValue = value;
    this.changeRewindValueProperty = changeRewindValueProperty;

    // (read-only) true when the rewind point value is different than the property's current value
    this.differentProperty = new BooleanProperty(!this.equalsRewindValue(), {
      tandem: options.tandem.createTandem('differentProperty'),
      phetioFeatured: false,
      phetioReadOnly: true,
      phetioDocumentation: 'for internal PhET use only'
    });
    this.link(() => {
      this.updateDifferentProperty();
    });
  }

  /**
   * Reset both the value and the rewind value.
   */
  reset() {
    super.reset();

    // reset the rewind value as well
    this.rewindValue = this.value;
    this.updateDifferentProperty();
  }

  // Whenever the primary value or rewindValue changes, update whether they differ
  updateDifferentProperty() {
    this.differentProperty.set(!this.equalsRewindValue());
  }
  set(value) {
    super.set(value);

    // If the user changed the initial conditions (as opposed to the state changing through model stepping),
    // then store the new initial conditions, which can be rewound to
    if (this.changeRewindValueProperty.get()) {
      this.storeRewindValueNoNotify();
    }
    this.updateDifferentProperty();
    return this;
  }

  /**
   * Store the new value as the initial condition which can be rewound to. We have to skip notifications sometimes
   * or the wrong initial conditions get stored.
   */
  storeRewindValueNoNotify() {
    this.rewindValue = this.get();
    this.updateDifferentProperty();
  }

  /**
   * Check for equality between current and rewind values.  Supported types are number, boolean
   * and Vector2.
   */
  equalsRewindValue() {
    const rewindValue = this.rewindValue;

    // if an object, must call unique function to check for equality
    if (typeof rewindValue !== 'number' && typeof rewindValue !== 'boolean' && typeof rewindValue !== 'string') {
      return rewindValue.equals(this.get());
    } else {
      return this.rewindValue === this.get();
    }
  }

  /**
   * Set the value to match the last recorded rewindValue
   */
  rewind() {
    this.set(this.rewindValue);
  }
}

// {Map.<IOType, IOType>} - Cache each parameterized RewindablePropertyIO so that it is only created once
const cache = new Map();
gravityAndOrbits.register('RewindableProperty', RewindableProperty);
export default RewindableProperty;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJQcm9wZXJ0eSIsImdyYXZpdHlBbmRPcmJpdHMiLCJUYW5kZW0iLCJJT1R5cGUiLCJjb21iaW5lT3B0aW9ucyIsIlJld2luZGFibGVQcm9wZXJ0eSIsIlJld2luZGFibGVQcm9wZXJ0eUlPIiwicGFyYW1ldGVyVHlwZSIsImFzc2VydCIsImNhY2hlS2V5IiwiY2FjaGUiLCJoYXMiLCJQcm9wZXJ0eUlPSW1wbCIsIlByb3BlcnR5SU8iLCJzZXQiLCJ0eXBlTmFtZSIsInZhbHVlVHlwZSIsInBhcmFtZXRlclR5cGVzIiwiZG9jdW1lbnRhdGlvbiIsInN1cGVydHlwZSIsInRvU3RhdGVPYmplY3QiLCJwcm9wZXJ0eSIsInN0YXRlT2JqZWN0IiwicmV3aW5kVmFsdWUiLCJhcHBseVN0YXRlIiwiZnJvbVN0YXRlT2JqZWN0IiwidXBkYXRlRGlmZmVyZW50UHJvcGVydHkiLCJzdGF0ZVNjaGVtYSIsImdldCIsImNvbnN0cnVjdG9yIiwiY2hhbmdlUmV3aW5kVmFsdWVQcm9wZXJ0eSIsInZhbHVlIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsInRhbmRlbSIsIk9QVElPTkFMIiwicGhldGlvT3V0ZXJUeXBlIiwiZGlmZmVyZW50UHJvcGVydHkiLCJlcXVhbHNSZXdpbmRWYWx1ZSIsImNyZWF0ZVRhbmRlbSIsInBoZXRpb0ZlYXR1cmVkIiwicGhldGlvUmVhZE9ubHkiLCJwaGV0aW9Eb2N1bWVudGF0aW9uIiwibGluayIsInJlc2V0Iiwic3RvcmVSZXdpbmRWYWx1ZU5vTm90aWZ5IiwiZXF1YWxzIiwicmV3aW5kIiwiTWFwIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJSZXdpbmRhYmxlUHJvcGVydHkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTQtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVGhpcyBpcyBhIHByb3BlcnR5IHRoYXQgY2FuIGJlIHJld291bmQsIGFuZCB3aGVuIHJld291bmQgaXQgZ29lcyBiYWNrIHRvIHRoZSB2YWx1ZSB0aGF0IHdhcyBsYXN0IHNldCBieVxyXG4gKiBzdG9yZVJld2luZFZhbHVlTm9Ob3RpZnkuIEluIHRoaXMgc2ltLCB0aGUgcmV3aW5kIHZhbHVlIGlzIHN0b3JlZCBhdCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uIG9mIGEgbW9kZSwgb3Igd2hlbiBhXHJcbiAqIHVzZXIgbW9kaWZpZXMgdGhlIHBvc2l0aW9uIG9mIGEgYm9keS5cclxuICpcclxuICogQGF1dGhvciBTYW0gUmVpZCAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBBYXJvbiBEYXZpcyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgQm9vbGVhblByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvQm9vbGVhblByb3BlcnR5LmpzJztcclxuaW1wb3J0IFByb3BlcnR5LCB7IFByb3BlcnR5T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgZ3Jhdml0eUFuZE9yYml0cyBmcm9tICcuLi8uLi9ncmF2aXR5QW5kT3JiaXRzLmpzJztcclxuaW1wb3J0IFRhbmRlbSBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvVGFuZGVtLmpzJztcclxuaW1wb3J0IElPVHlwZSBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvSU9UeXBlLmpzJztcclxuaW1wb3J0IHsgUGhldGlvT2JqZWN0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy9QaGV0aW9PYmplY3QuanMnO1xyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCB7IGNvbWJpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBTdHJpY3RPbWl0IGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9TdHJpY3RPbWl0LmpzJztcclxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9JbnRlbnRpb25hbEFueS5qcyc7XHJcblxyXG50eXBlIFJld2luZGFibGVQcm9wZXJ0eU9wdGlvbnM8VD4gPSB7XHJcbiAgdW5pdHM/OiBzdHJpbmc7XHJcbiAgdGFuZGVtOiBUYW5kZW07XHJcbn0gJiBTdHJpY3RPbWl0PFBoZXRpb09iamVjdE9wdGlvbnMsICdwaGV0aW9UeXBlJz4gJiBQaWNrPFByb3BlcnR5T3B0aW9uczxUPiwgJ3BoZXRpb091dGVyVHlwZScgfCAncGhldGlvVmFsdWVUeXBlJz47XHJcblxyXG5jbGFzcyBSZXdpbmRhYmxlUHJvcGVydHk8VCBleHRlbmRzIHsgZXF1YWxzOiAoIHZhbHVlOiBJbnRlbnRpb25hbEFueSApID0+IGJvb2xlYW4gfSB8IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmc+IGV4dGVuZHMgUHJvcGVydHk8VD4ge1xyXG4gIHByaXZhdGUgcmV3aW5kVmFsdWU6IFQ7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBjaGFuZ2VSZXdpbmRWYWx1ZVByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxib29sZWFuPjtcclxuICBwdWJsaWMgcmVhZG9ubHkgZGlmZmVyZW50UHJvcGVydHk6IEJvb2xlYW5Qcm9wZXJ0eTtcclxuXHJcbiAgLyoqXHJcbiAgICogQW4gb2JzZXJ2YWJsZSBQcm9wZXJ0eSB0aGF0IHRyaWdnZXJzIG5vdGlmaWNhdGlvbnMgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy5cclxuICAgKiBUaGlzIGNhY2hpbmcgaW1wbGVtZW50YXRpb24gc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBvdGhlciBwYXJhbWV0cmljIElPIFR5cGUgY2FjaGluZyBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBSZXdpbmRhYmxlUHJvcGVydHlJTyA9ICggcGFyYW1ldGVyVHlwZTogSU9UeXBlICk6IElPVHlwZSA9PiB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwYXJhbWV0ZXJUeXBlLCAnUmV3aW5kYWJsZVByb3BlcnR5SU8gbmVlZHMgcGFyYW1ldGVyVHlwZScgKTtcclxuXHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHBhcmFtZXRlclR5cGU7XHJcblxyXG4gICAgaWYgKCAhY2FjaGUuaGFzKCBjYWNoZUtleSApICkge1xyXG5cclxuICAgICAgY29uc3QgUHJvcGVydHlJT0ltcGwgPSBQcm9wZXJ0eS5Qcm9wZXJ0eUlPKCBwYXJhbWV0ZXJUeXBlICk7XHJcbiAgICAgIGNhY2hlLnNldCggY2FjaGVLZXksIG5ldyBJT1R5cGUoIGBSZXdpbmRhYmxlUHJvcGVydHlJTzwke3BhcmFtZXRlclR5cGUudHlwZU5hbWV9PmAsIHtcclxuICAgICAgICAgIHZhbHVlVHlwZTogUmV3aW5kYWJsZVByb3BlcnR5LFxyXG4gICAgICAgICAgcGFyYW1ldGVyVHlwZXM6IFsgcGFyYW1ldGVyVHlwZSBdLFxyXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjogJ09ic2VydmFibGUgdmFsdWVzIHRoYXQgc2VuZCBvdXQgbm90aWZpY2F0aW9ucyB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAndHJhZGl0aW9uYWwgbGlzdGVuZXIgcGF0dGVybiBpbiB0aGF0IGFkZGVkIGxpc3RlbmVycyBhbHNvIHJlY2VpdmUgYSBjYWxsYmFjayB3aXRoIHRoZSBjdXJyZW50IHZhbHVlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3doZW4gdGhlIGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZC4gVGhpcyBpcyBhIHdpZGVseS11c2VkIHBhdHRlcm4gaW4gUGhFVC1pTyBzaW11bGF0aW9ucy4nLFxyXG4gICAgICAgICAgc3VwZXJ0eXBlOiBQcm9wZXJ0eUlPSW1wbCxcclxuICAgICAgICAgIHRvU3RhdGVPYmplY3Q6ICggcHJvcGVydHk6IFJld2luZGFibGVQcm9wZXJ0eTxJbnRlbnRpb25hbEFueT4gKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlT2JqZWN0ID0gUHJvcGVydHlJT0ltcGwudG9TdGF0ZU9iamVjdCggcHJvcGVydHkgKTtcclxuICAgICAgICAgICAgc3RhdGVPYmplY3QucmV3aW5kVmFsdWUgPSBwYXJhbWV0ZXJUeXBlLnRvU3RhdGVPYmplY3QoIHByb3BlcnR5LnJld2luZFZhbHVlICk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZU9iamVjdDtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBhcHBseVN0YXRlOiAoIHByb3BlcnR5OiBSZXdpbmRhYmxlUHJvcGVydHk8SW50ZW50aW9uYWxBbnk+LCBzdGF0ZU9iamVjdDogeyByZXdpbmRWYWx1ZTogdW5rbm93biB9ICkgPT4ge1xyXG4gICAgICAgICAgICBQcm9wZXJ0eUlPSW1wbC5hcHBseVN0YXRlKCBwcm9wZXJ0eSwgc3RhdGVPYmplY3QgKTtcclxuICAgICAgICAgICAgcHJvcGVydHkucmV3aW5kVmFsdWUgPSBwYXJhbWV0ZXJUeXBlLmZyb21TdGF0ZU9iamVjdCggc3RhdGVPYmplY3QucmV3aW5kVmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgIHByb3BlcnR5LnVwZGF0ZURpZmZlcmVudFByb3BlcnR5KCk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgc3RhdGVTY2hlbWE6IHtcclxuICAgICAgICAgICAgcmV3aW5kVmFsdWU6IHBhcmFtZXRlclR5cGVcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBjaGFuZ2VSZXdpbmRWYWx1ZVByb3BlcnR5IC0gd2hldGhlciB0aGUgbmV3bHkgc2V0IHZhbHVlIHNob3VsZCBiZSBjYXB0dXJlZCBhcyBhIHJld2luZGFibGUgcG9pbnRcclxuICAgKiBAcGFyYW0gdmFsdWVcclxuICAgKiBAcGFyYW0gW3Byb3ZpZGVkT3B0aW9uc11cclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIGNoYW5nZVJld2luZFZhbHVlUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PGJvb2xlYW4+LCB2YWx1ZTogVCwgcHJvdmlkZWRPcHRpb25zPzogUmV3aW5kYWJsZVByb3BlcnR5T3B0aW9uczxUPiApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gY29tYmluZU9wdGlvbnM8UmV3aW5kYWJsZVByb3BlcnR5T3B0aW9uczxUPj4oIHtcclxuICAgICAgdGFuZGVtOiBUYW5kZW0uT1BUSU9OQUwsXHJcbiAgICAgIHBoZXRpb091dGVyVHlwZTogUmV3aW5kYWJsZVByb3BlcnR5LlJld2luZGFibGVQcm9wZXJ0eUlPXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICBzdXBlciggdmFsdWUsIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyB0aGUgXCJpbml0aWFsIGNvbmRpdGlvblwiIHRoZSBwcm9wZXJ0eSBjYW4gYmUgcmV3b3VuZCB0bywgZGlmZmVyZW50IHRoYW4gdGhlIG92ZXJhbGwgXCJyZXNldFwiIHZhbHVlXHJcbiAgICB0aGlzLnJld2luZFZhbHVlID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5jaGFuZ2VSZXdpbmRWYWx1ZVByb3BlcnR5ID0gY2hhbmdlUmV3aW5kVmFsdWVQcm9wZXJ0eTtcclxuXHJcbiAgICAvLyAocmVhZC1vbmx5KSB0cnVlIHdoZW4gdGhlIHJld2luZCBwb2ludCB2YWx1ZSBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgcHJvcGVydHkncyBjdXJyZW50IHZhbHVlXHJcbiAgICB0aGlzLmRpZmZlcmVudFByb3BlcnR5ID0gbmV3IEJvb2xlYW5Qcm9wZXJ0eSggIXRoaXMuZXF1YWxzUmV3aW5kVmFsdWUoKSwge1xyXG4gICAgICB0YW5kZW06IG9wdGlvbnMudGFuZGVtLmNyZWF0ZVRhbmRlbSggJ2RpZmZlcmVudFByb3BlcnR5JyApLFxyXG4gICAgICBwaGV0aW9GZWF0dXJlZDogZmFsc2UsXHJcbiAgICAgIHBoZXRpb1JlYWRPbmx5OiB0cnVlLFxyXG4gICAgICBwaGV0aW9Eb2N1bWVudGF0aW9uOiAnZm9yIGludGVybmFsIFBoRVQgdXNlIG9ubHknXHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy5saW5rKCAoKSA9PiB7XHJcbiAgICAgIHRoaXMudXBkYXRlRGlmZmVyZW50UHJvcGVydHkoKTtcclxuICAgIH0gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IGJvdGggdGhlIHZhbHVlIGFuZCB0aGUgcmV3aW5kIHZhbHVlLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVycmlkZSByZXNldCgpOiB2b2lkIHtcclxuICAgIHN1cGVyLnJlc2V0KCk7XHJcblxyXG4gICAgLy8gcmVzZXQgdGhlIHJld2luZCB2YWx1ZSBhcyB3ZWxsXHJcbiAgICB0aGlzLnJld2luZFZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgIHRoaXMudXBkYXRlRGlmZmVyZW50UHJvcGVydHkoKTtcclxuICB9XHJcblxyXG4gIC8vIFdoZW5ldmVyIHRoZSBwcmltYXJ5IHZhbHVlIG9yIHJld2luZFZhbHVlIGNoYW5nZXMsIHVwZGF0ZSB3aGV0aGVyIHRoZXkgZGlmZmVyXHJcbiAgcHVibGljIHVwZGF0ZURpZmZlcmVudFByb3BlcnR5KCk6IHZvaWQge1xyXG4gICAgdGhpcy5kaWZmZXJlbnRQcm9wZXJ0eS5zZXQoICF0aGlzLmVxdWFsc1Jld2luZFZhbHVlKCkgKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBvdmVycmlkZSBzZXQoIHZhbHVlOiBUICk6IHRoaXMge1xyXG4gICAgc3VwZXIuc2V0KCB2YWx1ZSApO1xyXG5cclxuICAgIC8vIElmIHRoZSB1c2VyIGNoYW5nZWQgdGhlIGluaXRpYWwgY29uZGl0aW9ucyAoYXMgb3Bwb3NlZCB0byB0aGUgc3RhdGUgY2hhbmdpbmcgdGhyb3VnaCBtb2RlbCBzdGVwcGluZyksXHJcbiAgICAvLyB0aGVuIHN0b3JlIHRoZSBuZXcgaW5pdGlhbCBjb25kaXRpb25zLCB3aGljaCBjYW4gYmUgcmV3b3VuZCB0b1xyXG4gICAgaWYgKCB0aGlzLmNoYW5nZVJld2luZFZhbHVlUHJvcGVydHkuZ2V0KCkgKSB7XHJcbiAgICAgIHRoaXMuc3RvcmVSZXdpbmRWYWx1ZU5vTm90aWZ5KCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZURpZmZlcmVudFByb3BlcnR5KCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9yZSB0aGUgbmV3IHZhbHVlIGFzIHRoZSBpbml0aWFsIGNvbmRpdGlvbiB3aGljaCBjYW4gYmUgcmV3b3VuZCB0by4gV2UgaGF2ZSB0byBza2lwIG5vdGlmaWNhdGlvbnMgc29tZXRpbWVzXHJcbiAgICogb3IgdGhlIHdyb25nIGluaXRpYWwgY29uZGl0aW9ucyBnZXQgc3RvcmVkLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdG9yZVJld2luZFZhbHVlTm9Ob3RpZnkoKTogdm9pZCB7XHJcbiAgICB0aGlzLnJld2luZFZhbHVlID0gdGhpcy5nZXQoKTtcclxuICAgIHRoaXMudXBkYXRlRGlmZmVyZW50UHJvcGVydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGZvciBlcXVhbGl0eSBiZXR3ZWVuIGN1cnJlbnQgYW5kIHJld2luZCB2YWx1ZXMuICBTdXBwb3J0ZWQgdHlwZXMgYXJlIG51bWJlciwgYm9vbGVhblxyXG4gICAqIGFuZCBWZWN0b3IyLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBlcXVhbHNSZXdpbmRWYWx1ZSgpOiBib29sZWFuIHtcclxuXHJcbiAgICBjb25zdCByZXdpbmRWYWx1ZSA9IHRoaXMucmV3aW5kVmFsdWU7XHJcblxyXG4gICAgLy8gaWYgYW4gb2JqZWN0LCBtdXN0IGNhbGwgdW5pcXVlIGZ1bmN0aW9uIHRvIGNoZWNrIGZvciBlcXVhbGl0eVxyXG4gICAgaWYgKCB0eXBlb2YgcmV3aW5kVmFsdWUgIT09ICdudW1iZXInICYmIHR5cGVvZiByZXdpbmRWYWx1ZSAhPT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiByZXdpbmRWYWx1ZSAhPT0gJ3N0cmluZycgKSB7XHJcbiAgICAgIHJldHVybiByZXdpbmRWYWx1ZS5lcXVhbHMoIHRoaXMuZ2V0KCkgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZXdpbmRWYWx1ZSA9PT0gdGhpcy5nZXQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgdmFsdWUgdG8gbWF0Y2ggdGhlIGxhc3QgcmVjb3JkZWQgcmV3aW5kVmFsdWVcclxuICAgKi9cclxuICBwdWJsaWMgcmV3aW5kKCk6IHZvaWQge1xyXG4gICAgdGhpcy5zZXQoIHRoaXMucmV3aW5kVmFsdWUgKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyB7TWFwLjxJT1R5cGUsIElPVHlwZT59IC0gQ2FjaGUgZWFjaCBwYXJhbWV0ZXJpemVkIFJld2luZGFibGVQcm9wZXJ0eUlPIHNvIHRoYXQgaXQgaXMgb25seSBjcmVhdGVkIG9uY2VcclxuY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XHJcblxyXG5cclxuZ3Jhdml0eUFuZE9yYml0cy5yZWdpc3RlciggJ1Jld2luZGFibGVQcm9wZXJ0eScsIFJld2luZGFibGVQcm9wZXJ0eSApO1xyXG5leHBvcnQgZGVmYXVsdCBSZXdpbmRhYmxlUHJvcGVydHk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGVBQWUsTUFBTSx3Q0FBd0M7QUFDcEUsT0FBT0MsUUFBUSxNQUEyQixpQ0FBaUM7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