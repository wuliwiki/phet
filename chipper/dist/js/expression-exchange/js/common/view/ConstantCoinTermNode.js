// Copyright 2016-2023, University of Colorado Boulder

/**
 * a Scenery node that represents a coin term whose underlying value can vary in the view
 *
 * @author John Blanco
 */

import Multilink from '../../../../axon/js/Multilink.js';
import PhetFont from '../../../../scenery-phet/js/PhetFont.js';
import { Text } from '../../../../scenery/js/imports.js';
import expressionExchange from '../../expressionExchange.js';
import ViewMode from '../enum/ViewMode.js';
import AbstractCoinTermNode from './AbstractCoinTermNode.js';

// constants
const VALUE_FONT = new PhetFont({
  size: 34
});
const MIN_RELATIVE_BOUNDS_WIDTH = 45; // empirically determined to be similar to variable coin term widths

// The following constants control how the pointer areas (mouse and touch) are set up for the textual representation
// of the coin term.  These are empirically determined such that they are easy for users to grab but the don't
// protrude from expressions.
const POINTER_AREA_X_DILATION_AMOUNT = 15; // in screen coords
const POINTER_AREA_Y_DILATION_AMOUNT = 8; // in screen coords, less than X amt to avoid protruding out of expression
const POINTER_AREA_DOWN_SHIFT = 3; // in screen coords

class ConstantCoinTermNode extends AbstractCoinTermNode {
  /**
   * @param {CoinTerm} constantCoinTerm - model of a coin
   * @param {Property.<ViewMode>} viewModeProperty - controls whether to show the coin or the term
   * @param {Object} [options]
   */
  constructor(constantCoinTerm, viewModeProperty, options) {
    assert && assert(constantCoinTerm.isConstant, 'must use a constant coin term with this node');
    super(constantCoinTerm, options);

    // As of this writing, constant coin terms are never used on a screen where a coin is shown.  There is no
    // fundamental reason why not, that's just how the design worked out.  This node therefore does not support
    // depicting constant coin terms as coins, so it throws an error if the view mode gets set to "COINS".
    const handleViewModeChanged = viewMode => {
      if (viewMode === ViewMode.COINS) {
        throw new Error('coin view mode not supported');
      }
    };
    viewModeProperty.link(handleViewModeChanged);

    // add the value text
    const valueText = new Text('', {
      font: VALUE_FONT
    });
    this.coinAndTextRootNode.addChild(valueText);

    // helper function to take the view bounds information and communicate it to the model
    const updateBoundsInModel = () => {
      // make the bounds relative to (0,0), which is where the center of this node is maintained
      let relativeVisibleBounds = this.coinAndTextRootNode.visibleLocalBounds;

      // In order to be consistent with the behavior of the variable coin terms, the bounds need to be a minimum width,
      // see https://github.com/phetsims/expression-exchange/issues/10.
      const minBoundsWidth = MIN_RELATIVE_BOUNDS_WIDTH * constantCoinTerm.scaleProperty.get();
      if (relativeVisibleBounds.width < minBoundsWidth) {
        relativeVisibleBounds = relativeVisibleBounds.dilatedX((minBoundsWidth - relativeVisibleBounds.width) / 2);
      }

      // only update if the bounds have changed in order to avoid unnecessary updates in other portions of the code
      if (!constantCoinTerm.localViewBoundsProperty.get() || !constantCoinTerm.localViewBoundsProperty.get().equals(relativeVisibleBounds)) {
        constantCoinTerm.localViewBoundsProperty.set(relativeVisibleBounds);
      }
    };

    // update the representation when model properties that affect it change
    const updateRepresentationMultilink = Multilink.multilink([constantCoinTerm.totalCountProperty, constantCoinTerm.showMinusSignWhenNegativeProperty, constantCoinTerm.cardOpacityProperty, constantCoinTerm.scaleProperty], () => {
      // update value text
      valueText.setScaleMagnitude(constantCoinTerm.scaleProperty.get());
      if (constantCoinTerm.showMinusSignWhenNegativeProperty.get()) {
        valueText.string = constantCoinTerm.valueProperty.value * constantCoinTerm.totalCountProperty.value;
      } else {
        valueText.string = Math.abs(constantCoinTerm.valueProperty.value * constantCoinTerm.totalCountProperty.value);
      }

      // update relative position
      valueText.centerX = 0;
      valueText.y = AbstractCoinTermNode.TEXT_BASELINE_Y_OFFSET * constantCoinTerm.scaleProperty.get();

      // update pointer areas
      valueText.mouseArea = valueText.localBounds.dilatedXY(POINTER_AREA_X_DILATION_AMOUNT, POINTER_AREA_Y_DILATION_AMOUNT).shiftedY(POINTER_AREA_DOWN_SHIFT);
      valueText.touchArea = valueText.mouseArea;

      // update the card background
      this.cardLikeBackground.setRectBounds(this.coinAndTextRootNode.visibleLocalBounds.dilatedXY(AbstractCoinTermNode.BACKGROUND_CARD_X_MARGIN, (AbstractCoinTermNode.BACKGROUND_CARD_HEIGHT_TEXT_MODE - this.coinAndTextRootNode.visibleLocalBounds.height) / 2));
      this.cardLikeBackground.visible = constantCoinTerm.cardOpacityProperty.get() > 0;
      this.cardLikeBackground.opacity = constantCoinTerm.cardOpacityProperty.get();

      // update the bounds that are registered with the model
      updateBoundsInModel();
    });
    this.disposeConstantCoinTermNode = () => {
      viewModeProperty.unlink(handleViewModeChanged);
      updateRepresentationMultilink.dispose();
    };
  }

  // @public
  dispose() {
    this.disposeConstantCoinTermNode();
    super.dispose();
  }
}
expressionExchange.register('ConstantCoinTermNode', ConstantCoinTermNode);
export default ConstantCoinTermNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNdWx0aWxpbmsiLCJQaGV0Rm9udCIsIlRleHQiLCJleHByZXNzaW9uRXhjaGFuZ2UiLCJWaWV3TW9kZSIsIkFic3RyYWN0Q29pblRlcm1Ob2RlIiwiVkFMVUVfRk9OVCIsInNpemUiLCJNSU5fUkVMQVRJVkVfQk9VTkRTX1dJRFRIIiwiUE9JTlRFUl9BUkVBX1hfRElMQVRJT05fQU1PVU5UIiwiUE9JTlRFUl9BUkVBX1lfRElMQVRJT05fQU1PVU5UIiwiUE9JTlRFUl9BUkVBX0RPV05fU0hJRlQiLCJDb25zdGFudENvaW5UZXJtTm9kZSIsImNvbnN0cnVjdG9yIiwiY29uc3RhbnRDb2luVGVybSIsInZpZXdNb2RlUHJvcGVydHkiLCJvcHRpb25zIiwiYXNzZXJ0IiwiaXNDb25zdGFudCIsImhhbmRsZVZpZXdNb2RlQ2hhbmdlZCIsInZpZXdNb2RlIiwiQ09JTlMiLCJFcnJvciIsImxpbmsiLCJ2YWx1ZVRleHQiLCJmb250IiwiY29pbkFuZFRleHRSb290Tm9kZSIsImFkZENoaWxkIiwidXBkYXRlQm91bmRzSW5Nb2RlbCIsInJlbGF0aXZlVmlzaWJsZUJvdW5kcyIsInZpc2libGVMb2NhbEJvdW5kcyIsIm1pbkJvdW5kc1dpZHRoIiwic2NhbGVQcm9wZXJ0eSIsImdldCIsIndpZHRoIiwiZGlsYXRlZFgiLCJsb2NhbFZpZXdCb3VuZHNQcm9wZXJ0eSIsImVxdWFscyIsInNldCIsInVwZGF0ZVJlcHJlc2VudGF0aW9uTXVsdGlsaW5rIiwibXVsdGlsaW5rIiwidG90YWxDb3VudFByb3BlcnR5Iiwic2hvd01pbnVzU2lnbldoZW5OZWdhdGl2ZVByb3BlcnR5IiwiY2FyZE9wYWNpdHlQcm9wZXJ0eSIsInNldFNjYWxlTWFnbml0dWRlIiwic3RyaW5nIiwidmFsdWVQcm9wZXJ0eSIsInZhbHVlIiwiTWF0aCIsImFicyIsImNlbnRlclgiLCJ5IiwiVEVYVF9CQVNFTElORV9ZX09GRlNFVCIsIm1vdXNlQXJlYSIsImxvY2FsQm91bmRzIiwiZGlsYXRlZFhZIiwic2hpZnRlZFkiLCJ0b3VjaEFyZWEiLCJjYXJkTGlrZUJhY2tncm91bmQiLCJzZXRSZWN0Qm91bmRzIiwiQkFDS0dST1VORF9DQVJEX1hfTUFSR0lOIiwiQkFDS0dST1VORF9DQVJEX0hFSUdIVF9URVhUX01PREUiLCJoZWlnaHQiLCJ2aXNpYmxlIiwib3BhY2l0eSIsImRpc3Bvc2VDb25zdGFudENvaW5UZXJtTm9kZSIsInVubGluayIsImRpc3Bvc2UiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkNvbnN0YW50Q29pblRlcm1Ob2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE2LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIGEgU2NlbmVyeSBub2RlIHRoYXQgcmVwcmVzZW50cyBhIGNvaW4gdGVybSB3aG9zZSB1bmRlcmx5aW5nIHZhbHVlIGNhbiB2YXJ5IGluIHRoZSB2aWV3XHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICovXHJcblxyXG5pbXBvcnQgTXVsdGlsaW5rIGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvTXVsdGlsaW5rLmpzJztcclxuaW1wb3J0IFBoZXRGb250IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9QaGV0Rm9udC5qcyc7XHJcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgZXhwcmVzc2lvbkV4Y2hhbmdlIGZyb20gJy4uLy4uL2V4cHJlc3Npb25FeGNoYW5nZS5qcyc7XHJcbmltcG9ydCBWaWV3TW9kZSBmcm9tICcuLi9lbnVtL1ZpZXdNb2RlLmpzJztcclxuaW1wb3J0IEFic3RyYWN0Q29pblRlcm1Ob2RlIGZyb20gJy4vQWJzdHJhY3RDb2luVGVybU5vZGUuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IFZBTFVFX0ZPTlQgPSBuZXcgUGhldEZvbnQoIHsgc2l6ZTogMzQgfSApO1xyXG5jb25zdCBNSU5fUkVMQVRJVkVfQk9VTkRTX1dJRFRIID0gNDU7IC8vIGVtcGlyaWNhbGx5IGRldGVybWluZWQgdG8gYmUgc2ltaWxhciB0byB2YXJpYWJsZSBjb2luIHRlcm0gd2lkdGhzXHJcblxyXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBjb250cm9sIGhvdyB0aGUgcG9pbnRlciBhcmVhcyAobW91c2UgYW5kIHRvdWNoKSBhcmUgc2V0IHVwIGZvciB0aGUgdGV4dHVhbCByZXByZXNlbnRhdGlvblxyXG4vLyBvZiB0aGUgY29pbiB0ZXJtLiAgVGhlc2UgYXJlIGVtcGlyaWNhbGx5IGRldGVybWluZWQgc3VjaCB0aGF0IHRoZXkgYXJlIGVhc3kgZm9yIHVzZXJzIHRvIGdyYWIgYnV0IHRoZSBkb24ndFxyXG4vLyBwcm90cnVkZSBmcm9tIGV4cHJlc3Npb25zLlxyXG5jb25zdCBQT0lOVEVSX0FSRUFfWF9ESUxBVElPTl9BTU9VTlQgPSAxNTsgLy8gaW4gc2NyZWVuIGNvb3Jkc1xyXG5jb25zdCBQT0lOVEVSX0FSRUFfWV9ESUxBVElPTl9BTU9VTlQgPSA4OyAvLyBpbiBzY3JlZW4gY29vcmRzLCBsZXNzIHRoYW4gWCBhbXQgdG8gYXZvaWQgcHJvdHJ1ZGluZyBvdXQgb2YgZXhwcmVzc2lvblxyXG5jb25zdCBQT0lOVEVSX0FSRUFfRE9XTl9TSElGVCA9IDM7IC8vIGluIHNjcmVlbiBjb29yZHNcclxuXHJcbmNsYXNzIENvbnN0YW50Q29pblRlcm1Ob2RlIGV4dGVuZHMgQWJzdHJhY3RDb2luVGVybU5vZGUge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0NvaW5UZXJtfSBjb25zdGFudENvaW5UZXJtIC0gbW9kZWwgb2YgYSBjb2luXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eS48Vmlld01vZGU+fSB2aWV3TW9kZVByb3BlcnR5IC0gY29udHJvbHMgd2hldGhlciB0byBzaG93IHRoZSBjb2luIG9yIHRoZSB0ZXJtXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBjb25zdGFudENvaW5UZXJtLCB2aWV3TW9kZVByb3BlcnR5LCBvcHRpb25zICkge1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGNvbnN0YW50Q29pblRlcm0uaXNDb25zdGFudCwgJ211c3QgdXNlIGEgY29uc3RhbnQgY29pbiB0ZXJtIHdpdGggdGhpcyBub2RlJyApO1xyXG5cclxuICAgIHN1cGVyKCBjb25zdGFudENvaW5UZXJtLCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gQXMgb2YgdGhpcyB3cml0aW5nLCBjb25zdGFudCBjb2luIHRlcm1zIGFyZSBuZXZlciB1c2VkIG9uIGEgc2NyZWVuIHdoZXJlIGEgY29pbiBpcyBzaG93bi4gIFRoZXJlIGlzIG5vXHJcbiAgICAvLyBmdW5kYW1lbnRhbCByZWFzb24gd2h5IG5vdCwgdGhhdCdzIGp1c3QgaG93IHRoZSBkZXNpZ24gd29ya2VkIG91dC4gIFRoaXMgbm9kZSB0aGVyZWZvcmUgZG9lcyBub3Qgc3VwcG9ydFxyXG4gICAgLy8gZGVwaWN0aW5nIGNvbnN0YW50IGNvaW4gdGVybXMgYXMgY29pbnMsIHNvIGl0IHRocm93cyBhbiBlcnJvciBpZiB0aGUgdmlldyBtb2RlIGdldHMgc2V0IHRvIFwiQ09JTlNcIi5cclxuICAgIGNvbnN0IGhhbmRsZVZpZXdNb2RlQ2hhbmdlZCA9IHZpZXdNb2RlID0+IHtcclxuICAgICAgaWYgKCB2aWV3TW9kZSA9PT0gVmlld01vZGUuQ09JTlMgKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnY29pbiB2aWV3IG1vZGUgbm90IHN1cHBvcnRlZCcgKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2aWV3TW9kZVByb3BlcnR5LmxpbmsoIGhhbmRsZVZpZXdNb2RlQ2hhbmdlZCApO1xyXG5cclxuICAgIC8vIGFkZCB0aGUgdmFsdWUgdGV4dFxyXG4gICAgY29uc3QgdmFsdWVUZXh0ID0gbmV3IFRleHQoICcnLCB7IGZvbnQ6IFZBTFVFX0ZPTlQgfSApO1xyXG4gICAgdGhpcy5jb2luQW5kVGV4dFJvb3ROb2RlLmFkZENoaWxkKCB2YWx1ZVRleHQgKTtcclxuXHJcbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gdGFrZSB0aGUgdmlldyBib3VuZHMgaW5mb3JtYXRpb24gYW5kIGNvbW11bmljYXRlIGl0IHRvIHRoZSBtb2RlbFxyXG4gICAgY29uc3QgdXBkYXRlQm91bmRzSW5Nb2RlbCA9ICgpID0+IHtcclxuXHJcbiAgICAgIC8vIG1ha2UgdGhlIGJvdW5kcyByZWxhdGl2ZSB0byAoMCwwKSwgd2hpY2ggaXMgd2hlcmUgdGhlIGNlbnRlciBvZiB0aGlzIG5vZGUgaXMgbWFpbnRhaW5lZFxyXG4gICAgICBsZXQgcmVsYXRpdmVWaXNpYmxlQm91bmRzID0gdGhpcy5jb2luQW5kVGV4dFJvb3ROb2RlLnZpc2libGVMb2NhbEJvdW5kcztcclxuXHJcbiAgICAgIC8vIEluIG9yZGVyIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0aGUgYmVoYXZpb3Igb2YgdGhlIHZhcmlhYmxlIGNvaW4gdGVybXMsIHRoZSBib3VuZHMgbmVlZCB0byBiZSBhIG1pbmltdW0gd2lkdGgsXHJcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvZXhwcmVzc2lvbi1leGNoYW5nZS9pc3N1ZXMvMTAuXHJcbiAgICAgIGNvbnN0IG1pbkJvdW5kc1dpZHRoID0gTUlOX1JFTEFUSVZFX0JPVU5EU19XSURUSCAqIGNvbnN0YW50Q29pblRlcm0uc2NhbGVQcm9wZXJ0eS5nZXQoKTtcclxuICAgICAgaWYgKCByZWxhdGl2ZVZpc2libGVCb3VuZHMud2lkdGggPCBtaW5Cb3VuZHNXaWR0aCApIHtcclxuICAgICAgICByZWxhdGl2ZVZpc2libGVCb3VuZHMgPSByZWxhdGl2ZVZpc2libGVCb3VuZHMuZGlsYXRlZFgoICggbWluQm91bmRzV2lkdGggLSByZWxhdGl2ZVZpc2libGVCb3VuZHMud2lkdGggKSAvIDIgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gb25seSB1cGRhdGUgaWYgdGhlIGJvdW5kcyBoYXZlIGNoYW5nZWQgaW4gb3JkZXIgdG8gYXZvaWQgdW5uZWNlc3NhcnkgdXBkYXRlcyBpbiBvdGhlciBwb3J0aW9ucyBvZiB0aGUgY29kZVxyXG4gICAgICBpZiAoICFjb25zdGFudENvaW5UZXJtLmxvY2FsVmlld0JvdW5kc1Byb3BlcnR5LmdldCgpIHx8ICFjb25zdGFudENvaW5UZXJtLmxvY2FsVmlld0JvdW5kc1Byb3BlcnR5LmdldCgpLmVxdWFscyggcmVsYXRpdmVWaXNpYmxlQm91bmRzICkgKSB7XHJcbiAgICAgICAgY29uc3RhbnRDb2luVGVybS5sb2NhbFZpZXdCb3VuZHNQcm9wZXJ0eS5zZXQoIHJlbGF0aXZlVmlzaWJsZUJvdW5kcyApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHVwZGF0ZSB0aGUgcmVwcmVzZW50YXRpb24gd2hlbiBtb2RlbCBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IGl0IGNoYW5nZVxyXG4gICAgY29uc3QgdXBkYXRlUmVwcmVzZW50YXRpb25NdWx0aWxpbmsgPSBNdWx0aWxpbmsubXVsdGlsaW5rKFxyXG4gICAgICBbXHJcbiAgICAgICAgY29uc3RhbnRDb2luVGVybS50b3RhbENvdW50UHJvcGVydHksXHJcbiAgICAgICAgY29uc3RhbnRDb2luVGVybS5zaG93TWludXNTaWduV2hlbk5lZ2F0aXZlUHJvcGVydHksXHJcbiAgICAgICAgY29uc3RhbnRDb2luVGVybS5jYXJkT3BhY2l0eVByb3BlcnR5LFxyXG4gICAgICAgIGNvbnN0YW50Q29pblRlcm0uc2NhbGVQcm9wZXJ0eVxyXG4gICAgICBdLFxyXG4gICAgICAoKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZSB0ZXh0XHJcbiAgICAgICAgdmFsdWVUZXh0LnNldFNjYWxlTWFnbml0dWRlKCBjb25zdGFudENvaW5UZXJtLnNjYWxlUHJvcGVydHkuZ2V0KCkgKTtcclxuICAgICAgICBpZiAoIGNvbnN0YW50Q29pblRlcm0uc2hvd01pbnVzU2lnbldoZW5OZWdhdGl2ZVByb3BlcnR5LmdldCgpICkge1xyXG4gICAgICAgICAgdmFsdWVUZXh0LnN0cmluZyA9IGNvbnN0YW50Q29pblRlcm0udmFsdWVQcm9wZXJ0eS52YWx1ZSAqIGNvbnN0YW50Q29pblRlcm0udG90YWxDb3VudFByb3BlcnR5LnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHZhbHVlVGV4dC5zdHJpbmcgPSBNYXRoLmFicyggY29uc3RhbnRDb2luVGVybS52YWx1ZVByb3BlcnR5LnZhbHVlICogY29uc3RhbnRDb2luVGVybS50b3RhbENvdW50UHJvcGVydHkudmFsdWUgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSByZWxhdGl2ZSBwb3NpdGlvblxyXG4gICAgICAgIHZhbHVlVGV4dC5jZW50ZXJYID0gMDtcclxuICAgICAgICB2YWx1ZVRleHQueSA9IEFic3RyYWN0Q29pblRlcm1Ob2RlLlRFWFRfQkFTRUxJTkVfWV9PRkZTRVQgKiBjb25zdGFudENvaW5UZXJtLnNjYWxlUHJvcGVydHkuZ2V0KCk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBwb2ludGVyIGFyZWFzXHJcbiAgICAgICAgdmFsdWVUZXh0Lm1vdXNlQXJlYSA9IHZhbHVlVGV4dC5sb2NhbEJvdW5kc1xyXG4gICAgICAgICAgLmRpbGF0ZWRYWSggUE9JTlRFUl9BUkVBX1hfRElMQVRJT05fQU1PVU5ULCBQT0lOVEVSX0FSRUFfWV9ESUxBVElPTl9BTU9VTlQgKVxyXG4gICAgICAgICAgLnNoaWZ0ZWRZKCBQT0lOVEVSX0FSRUFfRE9XTl9TSElGVCApO1xyXG4gICAgICAgIHZhbHVlVGV4dC50b3VjaEFyZWEgPSB2YWx1ZVRleHQubW91c2VBcmVhO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgdGhlIGNhcmQgYmFja2dyb3VuZFxyXG4gICAgICAgIHRoaXMuY2FyZExpa2VCYWNrZ3JvdW5kLnNldFJlY3RCb3VuZHMoIHRoaXMuY29pbkFuZFRleHRSb290Tm9kZS52aXNpYmxlTG9jYWxCb3VuZHMuZGlsYXRlZFhZKFxyXG4gICAgICAgICAgQWJzdHJhY3RDb2luVGVybU5vZGUuQkFDS0dST1VORF9DQVJEX1hfTUFSR0lOLFxyXG4gICAgICAgICAgKCBBYnN0cmFjdENvaW5UZXJtTm9kZS5CQUNLR1JPVU5EX0NBUkRfSEVJR0hUX1RFWFRfTU9ERSAtIHRoaXMuY29pbkFuZFRleHRSb290Tm9kZS52aXNpYmxlTG9jYWxCb3VuZHMuaGVpZ2h0ICkgLyAyXHJcbiAgICAgICAgKSApO1xyXG4gICAgICAgIHRoaXMuY2FyZExpa2VCYWNrZ3JvdW5kLnZpc2libGUgPSBjb25zdGFudENvaW5UZXJtLmNhcmRPcGFjaXR5UHJvcGVydHkuZ2V0KCkgPiAwO1xyXG4gICAgICAgIHRoaXMuY2FyZExpa2VCYWNrZ3JvdW5kLm9wYWNpdHkgPSBjb25zdGFudENvaW5UZXJtLmNhcmRPcGFjaXR5UHJvcGVydHkuZ2V0KCk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgYXJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgbW9kZWxcclxuICAgICAgICB1cGRhdGVCb3VuZHNJbk1vZGVsKCk7XHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5kaXNwb3NlQ29uc3RhbnRDb2luVGVybU5vZGUgPSAoKSA9PiB7XHJcbiAgICAgIHZpZXdNb2RlUHJvcGVydHkudW5saW5rKCBoYW5kbGVWaWV3TW9kZUNoYW5nZWQgKTtcclxuICAgICAgdXBkYXRlUmVwcmVzZW50YXRpb25NdWx0aWxpbmsuZGlzcG9zZSgpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEBwdWJsaWNcclxuICBkaXNwb3NlKCkge1xyXG4gICAgdGhpcy5kaXNwb3NlQ29uc3RhbnRDb2luVGVybU5vZGUoKTtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cHJlc3Npb25FeGNoYW5nZS5yZWdpc3RlciggJ0NvbnN0YW50Q29pblRlcm1Ob2RlJywgQ29uc3RhbnRDb2luVGVybU5vZGUgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvbnN0YW50Q29pblRlcm1Ob2RlOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxTQUFTLE1BQU0sa0NBQWtDO0FBQ3hELE9BQU9DLFFBQVEsTUFBTSx5Q0FBeUM7QUFDOUQsU0FBU0MsSUFBSSxRQUFRLG1DQUFtQztBQUN4RCxPQUFPQyxrQkFBa0IsTUFBTSw2QkFBNkI7QUFDNUQsT0FBT0MsUUFBUSxNQUFNLHFCQUFxQjtBQUMxQyxPQUFPQyxvQkFBb0IsTUFBTSwyQkFBMkI7O0FBRTVEO0FBQ0EsTUFBTUMsVUFBVSxHQUFHLElBQUlMLFFBQVEsQ0FBRTtFQUFFTSxJQUFJLEVBQUU7QUFBRyxDQUFFLENBQUM7QUFDL0MsTUFBTUMseUJBQXlCLEdBQUcsRUFBRSxDQUFDLENBQUM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLDhCQUE4QixHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQzNDLE1BQU1DLDhCQUE4QixHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzFDLE1BQU1DLHVCQUF1QixHQUFHLENBQUMsQ0FBQyxDQUFDOztBQUVuQyxNQUFNQyxvQkFBb0IsU0FBU1Asb0JBQW9CLENBQUM7RUFFdEQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFUSxXQUFXQSxDQUFFQyxnQkFBZ0IsRUFBRUMsZ0JBQWdCLEVBQUVDLE9BQU8sRUFBRztJQUV6REMsTUFBTSxJQUFJQSxNQUFNLENBQUVILGdCQUFnQixDQUFDSSxVQUFVLEVBQUUsOENBQStDLENBQUM7SUFFL0YsS0FBSyxDQUFFSixnQkFBZ0IsRUFBRUUsT0FBUSxDQUFDOztJQUVsQztJQUNBO0lBQ0E7SUFDQSxNQUFNRyxxQkFBcUIsR0FBR0MsUUFBUSxJQUFJO01BQ3hDLElBQUtBLFFBQVEsS0FBS2hCLFFBQVEsQ0FBQ2lCLEtBQUssRUFBRztRQUNqQyxNQUFNLElB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