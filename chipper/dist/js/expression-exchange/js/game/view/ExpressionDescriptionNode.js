// Copyright 2017-2022, University of Colorado Boulder

/**
 * a Scenery node that represents a visual description of an expression, used in the game to describe what the user
 * should attempt to construct
 *
 * Note the expression description string is re-parsed in this object because the expression description is in the
 * reduced form (no parens) and we need to handle subscripts and superscripts.
 */

import MathSymbolFont from '../../../../scenery-phet/js/MathSymbolFont.js';
import MathSymbols from '../../../../scenery-phet/js/MathSymbols.js';
import PhetFont from '../../../../scenery-phet/js/PhetFont.js';
import { HBox, RichText, Text } from '../../../../scenery/js/imports.js';
import ViewMode from '../../common/enum/ViewMode.js';
import CoinNodeFactory from '../../common/view/CoinNodeFactory.js';
import expressionExchange from '../../expressionExchange.js';

// constants
const COIN_ICON_RADIUS = 10;
const COIN_EXPRESSION_FONT = new PhetFont(22);
const EXPRESSION_FONT_FOR_NON_VARIABLE = new PhetFont(22);
const EXPRESSION_FONT_FOR_VARIABLES = new MathSymbolFont(24);
const SUP_SCALE = 0.65; // empirically determined to look good on the most platforms
const SUB_SUP_OPTIONS = {
  font: EXPRESSION_FONT_FOR_VARIABLES,
  supScale: SUP_SCALE
};
class ExpressionDescriptionNode extends HBox {
  /**
   * @param {ExpressionDescription} expressionDescription
   * @param {ViewMode} viewMode
   * @param {Object} [options]
   */
  constructor(expressionDescription, viewMode, options) {
    super({
      align: 'bottom'
    });
    if (viewMode === ViewMode.COINS) {
      this.setAlign('center');
      expressionDescription.terms.forEach((expressionTerm, index) => {
        // add coefficient if needed
        if (expressionTerm.coefficient > 1) {
          const coefficientNode = new Text(expressionTerm.coefficient, {
            font: COIN_EXPRESSION_FONT
          });
          this.addChild(coefficientNode);
        }

        // add coin icon
        const coinIconNode = CoinNodeFactory.createIconNode(expressionTerm.coinTermTypeID, COIN_ICON_RADIUS);
        this.addChild(coinIconNode);

        // add plus symbol if not at end of expression
        if (index < expressionDescription.terms.length - 1) {
          const plusSign = new Text(` ${MathSymbols.PLUS} `, {
            font: COIN_EXPRESSION_FONT
          });
          this.addChild(plusSign);
        }
      });
    } else if (viewMode === ViewMode.VARIABLES) {
      this.setAlign('bottom');

      // Go through the expression string, turning the various pieces into nodes.  The 'terms' field of the expression
      // description can't be used here because it is the returned version of the expression.
      let expressionStringIndex = 0;
      while (expressionStringIndex < expressionDescription.expressionString.length) {
        const expressionFragmentInfo = createExpressionFragment(expressionDescription.expressionString, expressionStringIndex);
        this.addChild(expressionFragmentInfo.node);
        expressionStringIndex += expressionFragmentInfo.charsUsed;
      }
    } else {
      assert && assert(false, 'unrecognized representation type');
    }
    this.mutate(options);
  }
}

/*
 * helper function that creates an object that consists of a node that represents a variable and the number of
 * characters from the expression string that the node represents
 */
function createVariableExpressionFragment(expressionString, startIndex) {
  // error checking
  const firstChar = expressionString.charAt(startIndex);
  assert && assert(firstChar === 'x' || firstChar === 'y' || firstChar === 'z', 'unexpected first char of string');
  let node = null;
  let charsUsed = 0;

  // identify the expression to be created based on a finite set of those supported
  if (expressionString.indexOf('x^2', startIndex) === startIndex) {
    node = new RichText('x<sup>2</sup>', SUB_SUP_OPTIONS);
    charsUsed = 3;
  } else if (expressionString.indexOf('y^2', startIndex) === startIndex) {
    node = new RichText('y<sup>2</sup>', SUB_SUP_OPTIONS);
    charsUsed = 3;
  } else if (expressionString.indexOf('xy', startIndex) === startIndex) {
    node = new Text('xy', {
      font: EXPRESSION_FONT_FOR_VARIABLES
    });
    charsUsed = 2;
  } else if (expressionString.indexOf('x', startIndex) === startIndex) {
    node = new Text('x', {
      font: EXPRESSION_FONT_FOR_VARIABLES
    });
    charsUsed = 1;
  } else if (expressionString.indexOf('y', startIndex) === startIndex) {
    node = new Text('y', {
      font: EXPRESSION_FONT_FOR_VARIABLES
    });
    charsUsed = 1;
  } else if (expressionString.indexOf('z', startIndex) === startIndex) {
    node = new Text('z', {
      font: EXPRESSION_FONT_FOR_VARIABLES
    });
    charsUsed = 1;
  } else {
    assert && assert(false, 'unsupported expression');
  }
  return {
    node: node,
    charsUsed: charsUsed
  };
}
function createNonVariableExpressionFragment(expressionString, startIndex) {
  let fragmentString = '';
  let index = startIndex;
  while (expressionString.charAt(index) !== 'x' && expressionString.charAt(index) !== 'y' && expressionString.charAt(index) !== 'z' && index < expressionString.length) {
    fragmentString += expressionString.charAt(index);
    index++;
  }
  assert && assert(fragmentString.length, 'no expression fragment found, method should not have been called');

  // replace the minus sign used in subtraction operations with the unicode character
  fragmentString = fragmentString.replace(/ - /g, ` ${MathSymbols.MINUS} `);
  return {
    node: new Text(fragmentString, {
      font: EXPRESSION_FONT_FOR_NON_VARIABLE
    }),
    charsUsed: index - startIndex
  };
}

/*
 * helper function for creating nodes to represent pieces of the expression spec - this is limited to the format
 * expected for expression descriptions in this sim, and is not very general
 */
function createExpressionFragment(expressionString, index) {
  let expressionFragment;
  const nextChar = expressionString.charAt(index);
  if (nextChar === 'x' || nextChar === 'y' || nextChar === 'z') {
    expressionFragment = createVariableExpressionFragment(expressionString, index);
  } else {
    expressionFragment = createNonVariableExpressionFragment(expressionString, index);
  }
  return expressionFragment;
}
expressionExchange.register('ExpressionDescriptionNode', ExpressionDescriptionNode);
export default ExpressionDescriptionNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNYXRoU3ltYm9sRm9udCIsIk1hdGhTeW1ib2xzIiwiUGhldEZvbnQiLCJIQm94IiwiUmljaFRleHQiLCJUZXh0IiwiVmlld01vZGUiLCJDb2luTm9kZUZhY3RvcnkiLCJleHByZXNzaW9uRXhjaGFuZ2UiLCJDT0lOX0lDT05fUkFESVVTIiwiQ09JTl9FWFBSRVNTSU9OX0ZPTlQiLCJFWFBSRVNTSU9OX0ZPTlRfRk9SX05PTl9WQVJJQUJMRSIsIkVYUFJFU1NJT05fRk9OVF9GT1JfVkFSSUFCTEVTIiwiU1VQX1NDQUxFIiwiU1VCX1NVUF9PUFRJT05TIiwiZm9udCIsInN1cFNjYWxlIiwiRXhwcmVzc2lvbkRlc2NyaXB0aW9uTm9kZSIsImNvbnN0cnVjdG9yIiwiZXhwcmVzc2lvbkRlc2NyaXB0aW9uIiwidmlld01vZGUiLCJvcHRpb25zIiwiYWxpZ24iLCJDT0lOUyIsInNldEFsaWduIiwidGVybXMiLCJmb3JFYWNoIiwiZXhwcmVzc2lvblRlcm0iLCJpbmRleCIsImNvZWZmaWNpZW50IiwiY29lZmZpY2llbnROb2RlIiwiYWRkQ2hpbGQiLCJjb2luSWNvbk5vZGUiLCJjcmVhdGVJY29uTm9kZSIsImNvaW5UZXJtVHlwZUlEIiwibGVuZ3RoIiwicGx1c1NpZ24iLCJQTFVTIiwiVkFSSUFCTEVTIiwiZXhwcmVzc2lvblN0cmluZ0luZGV4IiwiZXhwcmVzc2lvblN0cmluZyIsImV4cHJlc3Npb25GcmFnbWVudEluZm8iLCJjcmVhdGVFeHByZXNzaW9uRnJhZ21lbnQiLCJub2RlIiwiY2hhcnNVc2VkIiwiYXNzZXJ0IiwibXV0YXRlIiwiY3JlYXRlVmFyaWFibGVFeHByZXNzaW9uRnJhZ21lbnQiLCJzdGFydEluZGV4IiwiZmlyc3RDaGFyIiwiY2hhckF0IiwiaW5kZXhPZiIsImNyZWF0ZU5vblZhcmlhYmxlRXhwcmVzc2lvbkZyYWdtZW50IiwiZnJhZ21lbnRTdHJpbmciLCJyZXBsYWNlIiwiTUlOVVMiLCJleHByZXNzaW9uRnJhZ21lbnQiLCJuZXh0Q2hhciIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRXhwcmVzc2lvbkRlc2NyaXB0aW9uTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNy0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBhIFNjZW5lcnkgbm9kZSB0aGF0IHJlcHJlc2VudHMgYSB2aXN1YWwgZGVzY3JpcHRpb24gb2YgYW4gZXhwcmVzc2lvbiwgdXNlZCBpbiB0aGUgZ2FtZSB0byBkZXNjcmliZSB3aGF0IHRoZSB1c2VyXHJcbiAqIHNob3VsZCBhdHRlbXB0IHRvIGNvbnN0cnVjdFxyXG4gKlxyXG4gKiBOb3RlIHRoZSBleHByZXNzaW9uIGRlc2NyaXB0aW9uIHN0cmluZyBpcyByZS1wYXJzZWQgaW4gdGhpcyBvYmplY3QgYmVjYXVzZSB0aGUgZXhwcmVzc2lvbiBkZXNjcmlwdGlvbiBpcyBpbiB0aGVcclxuICogcmVkdWNlZCBmb3JtIChubyBwYXJlbnMpIGFuZCB3ZSBuZWVkIHRvIGhhbmRsZSBzdWJzY3JpcHRzIGFuZCBzdXBlcnNjcmlwdHMuXHJcbiAqL1xyXG5cclxuaW1wb3J0IE1hdGhTeW1ib2xGb250IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9NYXRoU3ltYm9sRm9udC5qcyc7XHJcbmltcG9ydCBNYXRoU3ltYm9scyBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvTWF0aFN5bWJvbHMuanMnO1xyXG5pbXBvcnQgUGhldEZvbnQgZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS1waGV0L2pzL1BoZXRGb250LmpzJztcclxuaW1wb3J0IHsgSEJveCwgUmljaFRleHQsIFRleHQgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgVmlld01vZGUgZnJvbSAnLi4vLi4vY29tbW9uL2VudW0vVmlld01vZGUuanMnO1xyXG5pbXBvcnQgQ29pbk5vZGVGYWN0b3J5IGZyb20gJy4uLy4uL2NvbW1vbi92aWV3L0NvaW5Ob2RlRmFjdG9yeS5qcyc7XHJcbmltcG9ydCBleHByZXNzaW9uRXhjaGFuZ2UgZnJvbSAnLi4vLi4vZXhwcmVzc2lvbkV4Y2hhbmdlLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBDT0lOX0lDT05fUkFESVVTID0gMTA7XHJcbmNvbnN0IENPSU5fRVhQUkVTU0lPTl9GT05UID0gbmV3IFBoZXRGb250KCAyMiApO1xyXG5jb25zdCBFWFBSRVNTSU9OX0ZPTlRfRk9SX05PTl9WQVJJQUJMRSA9IG5ldyBQaGV0Rm9udCggMjIgKTtcclxuY29uc3QgRVhQUkVTU0lPTl9GT05UX0ZPUl9WQVJJQUJMRVMgPSBuZXcgTWF0aFN5bWJvbEZvbnQoIDI0ICk7XHJcbmNvbnN0IFNVUF9TQ0FMRSA9IDAuNjU7IC8vIGVtcGlyaWNhbGx5IGRldGVybWluZWQgdG8gbG9vayBnb29kIG9uIHRoZSBtb3N0IHBsYXRmb3Jtc1xyXG5jb25zdCBTVUJfU1VQX09QVElPTlMgPSB7IGZvbnQ6IEVYUFJFU1NJT05fRk9OVF9GT1JfVkFSSUFCTEVTLCBzdXBTY2FsZTogU1VQX1NDQUxFIH07XHJcblxyXG5jbGFzcyBFeHByZXNzaW9uRGVzY3JpcHRpb25Ob2RlIGV4dGVuZHMgSEJveCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7RXhwcmVzc2lvbkRlc2NyaXB0aW9ufSBleHByZXNzaW9uRGVzY3JpcHRpb25cclxuICAgKiBAcGFyYW0ge1ZpZXdNb2RlfSB2aWV3TW9kZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggZXhwcmVzc2lvbkRlc2NyaXB0aW9uLCB2aWV3TW9kZSwgb3B0aW9ucyApIHtcclxuXHJcbiAgICBzdXBlciggeyBhbGlnbjogJ2JvdHRvbScgfSApO1xyXG5cclxuICAgIGlmICggdmlld01vZGUgPT09IFZpZXdNb2RlLkNPSU5TICkge1xyXG5cclxuICAgICAgdGhpcy5zZXRBbGlnbiggJ2NlbnRlcicgKTtcclxuXHJcbiAgICAgIGV4cHJlc3Npb25EZXNjcmlwdGlvbi50ZXJtcy5mb3JFYWNoKCAoIGV4cHJlc3Npb25UZXJtLCBpbmRleCApID0+IHtcclxuXHJcbiAgICAgICAgLy8gYWRkIGNvZWZmaWNpZW50IGlmIG5lZWRlZFxyXG4gICAgICAgIGlmICggZXhwcmVzc2lvblRlcm0uY29lZmZpY2llbnQgPiAxICkge1xyXG4gICAgICAgICAgY29uc3QgY29lZmZpY2llbnROb2RlID0gbmV3IFRleHQoIGV4cHJlc3Npb25UZXJtLmNvZWZmaWNpZW50LCB7IGZvbnQ6IENPSU5fRVhQUkVTU0lPTl9GT05UIH0gKTtcclxuICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoIGNvZWZmaWNpZW50Tm9kZSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYWRkIGNvaW4gaWNvblxyXG4gICAgICAgIGNvbnN0IGNvaW5JY29uTm9kZSA9IENvaW5Ob2RlRmFjdG9yeS5jcmVhdGVJY29uTm9kZShcclxuICAgICAgICAgIGV4cHJlc3Npb25UZXJtLmNvaW5UZXJtVHlwZUlELFxyXG4gICAgICAgICAgQ09JTl9JQ09OX1JBRElVU1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCggY29pbkljb25Ob2RlICk7XHJcblxyXG4gICAgICAgIC8vIGFkZCBwbHVzIHN5bWJvbCBpZiBub3QgYXQgZW5kIG9mIGV4cHJlc3Npb25cclxuICAgICAgICBpZiAoIGluZGV4IDwgZXhwcmVzc2lvbkRlc2NyaXB0aW9uLnRlcm1zLmxlbmd0aCAtIDEgKSB7XHJcbiAgICAgICAgICBjb25zdCBwbHVzU2lnbiA9IG5ldyBUZXh0KCBgICR7TWF0aFN5bWJvbHMuUExVU30gYCwgeyBmb250OiBDT0lOX0VYUFJFU1NJT05fRk9OVCB9ICk7XHJcbiAgICAgICAgICB0aGlzLmFkZENoaWxkKCBwbHVzU2lnbiApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCB2aWV3TW9kZSA9PT0gVmlld01vZGUuVkFSSUFCTEVTICkge1xyXG5cclxuICAgICAgdGhpcy5zZXRBbGlnbiggJ2JvdHRvbScgKTtcclxuXHJcbiAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGV4cHJlc3Npb24gc3RyaW5nLCB0dXJuaW5nIHRoZSB2YXJpb3VzIHBpZWNlcyBpbnRvIG5vZGVzLiAgVGhlICd0ZXJtcycgZmllbGQgb2YgdGhlIGV4cHJlc3Npb25cclxuICAgICAgLy8gZGVzY3JpcHRpb24gY2FuJ3QgYmUgdXNlZCBoZXJlIGJlY2F1c2UgaXQgaXMgdGhlIHJldHVybmVkIHZlcnNpb24gb2YgdGhlIGV4cHJlc3Npb24uXHJcbiAgICAgIGxldCBleHByZXNzaW9uU3RyaW5nSW5kZXggPSAwO1xyXG5cclxuICAgICAgd2hpbGUgKCBleHByZXNzaW9uU3RyaW5nSW5kZXggPCBleHByZXNzaW9uRGVzY3JpcHRpb24uZXhwcmVzc2lvblN0cmluZy5sZW5ndGggKSB7XHJcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbkZyYWdtZW50SW5mbyA9IGNyZWF0ZUV4cHJlc3Npb25GcmFnbWVudChcclxuICAgICAgICAgIGV4cHJlc3Npb25EZXNjcmlwdGlvbi5leHByZXNzaW9uU3RyaW5nLFxyXG4gICAgICAgICAgZXhwcmVzc2lvblN0cmluZ0luZGV4XHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLmFkZENoaWxkKCBleHByZXNzaW9uRnJhZ21lbnRJbmZvLm5vZGUgKTtcclxuICAgICAgICBleHByZXNzaW9uU3RyaW5nSW5kZXggKz0gZXhwcmVzc2lvbkZyYWdtZW50SW5mby5jaGFyc1VzZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ3VucmVjb2duaXplZCByZXByZXNlbnRhdGlvbiB0eXBlJyApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubXV0YXRlKCBvcHRpb25zICk7XHJcbiAgfVxyXG59XHJcblxyXG4vKlxyXG4gKiBoZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFuIG9iamVjdCB0aGF0IGNvbnNpc3RzIG9mIGEgbm9kZSB0aGF0IHJlcHJlc2VudHMgYSB2YXJpYWJsZSBhbmQgdGhlIG51bWJlciBvZlxyXG4gKiBjaGFyYWN0ZXJzIGZyb20gdGhlIGV4cHJlc3Npb24gc3RyaW5nIHRoYXQgdGhlIG5vZGUgcmVwcmVzZW50c1xyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlVmFyaWFibGVFeHByZXNzaW9uRnJhZ21lbnQoIGV4cHJlc3Npb25TdHJpbmcsIHN0YXJ0SW5kZXggKSB7XHJcblxyXG4gIC8vIGVycm9yIGNoZWNraW5nXHJcbiAgY29uc3QgZmlyc3RDaGFyID0gZXhwcmVzc2lvblN0cmluZy5jaGFyQXQoIHN0YXJ0SW5kZXggKTtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBmaXJzdENoYXIgPT09ICd4JyB8fCBmaXJzdENoYXIgPT09ICd5JyB8fCBmaXJzdENoYXIgPT09ICd6JywgJ3VuZXhwZWN0ZWQgZmlyc3QgY2hhciBvZiBzdHJpbmcnICk7XHJcblxyXG4gIGxldCBub2RlID0gbnVsbDtcclxuICBsZXQgY2hhcnNVc2VkID0gMDtcclxuXHJcbiAgLy8gaWRlbnRpZnkgdGhlIGV4cHJlc3Npb24gdG8gYmUgY3JlYXRlZCBiYXNlZCBvbiBhIGZpbml0ZSBzZXQgb2YgdGhvc2Ugc3VwcG9ydGVkXHJcbiAgaWYgKCBleHByZXNzaW9uU3RyaW5nLmluZGV4T2YoICd4XjInLCBzdGFydEluZGV4ICkgPT09IHN0YXJ0SW5kZXggKSB7XHJcbiAgICBub2RlID0gbmV3IFJpY2hUZXh0KCAneDxzdXA+Mjwvc3VwPicsIFNVQl9TVVBfT1BUSU9OUyApO1xyXG4gICAgY2hhcnNVc2VkID0gMztcclxuICB9XHJcbiAgZWxzZSBpZiAoIGV4cHJlc3Npb25TdHJpbmcuaW5kZXhPZiggJ3leMicsIHN0YXJ0SW5kZXggKSA9PT0gc3RhcnRJbmRleCApIHtcclxuICAgIG5vZGUgPSBuZXcgUmljaFRleHQoICd5PHN1cD4yPC9zdXA+JywgU1VCX1NVUF9PUFRJT05TICk7XHJcbiAgICBjaGFyc1VzZWQgPSAzO1xyXG4gIH1cclxuICBlbHNlIGlmICggZXhwcmVzc2lvblN0cmluZy5pbmRleE9mKCAneHknLCBzdGFydEluZGV4ICkgPT09IHN0YXJ0SW5kZXggKSB7XHJcbiAgICBub2RlID0gbmV3IFRleHQoICd4eScsIHtcclxuICAgICAgZm9udDogRVhQUkVTU0lPTl9GT05UX0ZPUl9WQVJJQUJMRVNcclxuICAgIH0gKTtcclxuICAgIGNoYXJzVXNlZCA9IDI7XHJcbiAgfVxyXG4gIGVsc2UgaWYgKCBleHByZXNzaW9uU3RyaW5nLmluZGV4T2YoICd4Jywgc3RhcnRJbmRleCApID09PSBzdGFydEluZGV4ICkge1xyXG4gICAgbm9kZSA9IG5ldyBUZXh0KCAneCcsIHtcclxuICAgICAgZm9udDogRVhQUkVTU0lPTl9GT05UX0ZPUl9WQVJJQUJMRVNcclxuICAgIH0gKTtcclxuICAgIGNoYXJzVXNlZCA9IDE7XHJcbiAgfVxyXG4gIGVsc2UgaWYgKCBleHByZXNzaW9uU3RyaW5nLmluZGV4T2YoICd5Jywgc3RhcnRJbmRleCApID09PSBzdGFydEluZGV4ICkge1xyXG4gICAgbm9kZSA9IG5ldyBUZXh0KCAneScsIHtcclxuICAgICAgZm9udDogRVhQUkVTU0lPTl9GT05UX0ZPUl9WQVJJQUJMRVNcclxuICAgIH0gKTtcclxuICAgIGNoYXJzVXNlZCA9IDE7XHJcbiAgfVxyXG4gIGVsc2UgaWYgKCBleHByZXNzaW9uU3RyaW5nLmluZGV4T2YoICd6Jywgc3RhcnRJbmRleCApID09PSBzdGFydEluZGV4ICkge1xyXG4gICAgbm9kZSA9IG5ldyBUZXh0KCAneicsIHtcclxuICAgICAgZm9udDogRVhQUkVTU0lPTl9GT05UX0ZPUl9WQVJJQUJMRVNcclxuICAgIH0gKTtcclxuICAgIGNoYXJzVXNlZCA9IDE7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsICd1bnN1cHBvcnRlZCBleHByZXNzaW9uJyApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5vZGU6IG5vZGUsXHJcbiAgICBjaGFyc1VzZWQ6IGNoYXJzVXNlZFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU5vblZhcmlhYmxlRXhwcmVzc2lvbkZyYWdtZW50KCBleHByZXNzaW9uU3RyaW5nLCBzdGFydEluZGV4ICkge1xyXG4gIGxldCBmcmFnbWVudFN0cmluZyA9ICcnO1xyXG4gIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XHJcbiAgd2hpbGUgKCBleHByZXNzaW9uU3RyaW5nLmNoYXJBdCggaW5kZXggKSAhPT0gJ3gnICYmXHJcbiAgICAgICAgICBleHByZXNzaW9uU3RyaW5nLmNoYXJBdCggaW5kZXggKSAhPT0gJ3knICYmXHJcbiAgICAgICAgICBleHByZXNzaW9uU3RyaW5nLmNoYXJBdCggaW5kZXggKSAhPT0gJ3onICYmXHJcbiAgICAgICAgICBpbmRleCA8IGV4cHJlc3Npb25TdHJpbmcubGVuZ3RoICkge1xyXG4gICAgZnJhZ21lbnRTdHJpbmcgKz0gZXhwcmVzc2lvblN0cmluZy5jaGFyQXQoIGluZGV4ICk7XHJcbiAgICBpbmRleCsrO1xyXG4gIH1cclxuXHJcbiAgYXNzZXJ0ICYmIGFzc2VydCggZnJhZ21lbnRTdHJpbmcubGVuZ3RoLCAnbm8gZXhwcmVzc2lvbiBmcmFnbWVudCBmb3VuZCwgbWV0aG9kIHNob3VsZCBub3QgaGF2ZSBiZWVuIGNhbGxlZCcgKTtcclxuXHJcbiAgLy8gcmVwbGFjZSB0aGUgbWludXMgc2lnbiB1c2VkIGluIHN1YnRyYWN0aW9uIG9wZXJhdGlvbnMgd2l0aCB0aGUgdW5pY29kZSBjaGFyYWN0ZXJcclxuICBmcmFnbWVudFN0cmluZyA9IGZyYWdtZW50U3RyaW5nLnJlcGxhY2UoIC8gLSAvZywgYCAke01hdGhTeW1ib2xzLk1JTlVTfSBgICk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBub2RlOiBuZXcgVGV4dCggZnJhZ21lbnRTdHJpbmcsIHsgZm9udDogRVhQUkVTU0lPTl9GT05UX0ZPUl9OT05fVkFSSUFCTEUgfSApLFxyXG4gICAgY2hhcnNVc2VkOiBpbmRleCAtIHN0YXJ0SW5kZXhcclxuICB9O1xyXG59XHJcblxyXG4vKlxyXG4gKiBoZWxwZXIgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIG5vZGVzIHRvIHJlcHJlc2VudCBwaWVjZXMgb2YgdGhlIGV4cHJlc3Npb24gc3BlYyAtIHRoaXMgaXMgbGltaXRlZCB0byB0aGUgZm9ybWF0XHJcbiAqIGV4cGVjdGVkIGZvciBleHByZXNzaW9uIGRlc2NyaXB0aW9ucyBpbiB0aGlzIHNpbSwgYW5kIGlzIG5vdCB2ZXJ5IGdlbmVyYWxcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUV4cHJlc3Npb25GcmFnbWVudCggZXhwcmVzc2lvblN0cmluZywgaW5kZXggKSB7XHJcblxyXG4gIGxldCBleHByZXNzaW9uRnJhZ21lbnQ7XHJcbiAgY29uc3QgbmV4dENoYXIgPSBleHByZXNzaW9uU3RyaW5nLmNoYXJBdCggaW5kZXggKTtcclxuICBpZiAoIG5leHRDaGFyID09PSAneCcgfHwgbmV4dENoYXIgPT09ICd5JyB8fCBuZXh0Q2hhciA9PT0gJ3onICkge1xyXG4gICAgZXhwcmVzc2lvbkZyYWdtZW50ID0gY3JlYXRlVmFyaWFibGVFeHByZXNzaW9uRnJhZ21lbnQoIGV4cHJlc3Npb25TdHJpbmcsIGluZGV4ICk7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgZXhwcmVzc2lvbkZyYWdtZW50ID0gY3JlYXRlTm9uVmFyaWFibGVFeHByZXNzaW9uRnJhZ21lbnQoIGV4cHJlc3Npb25TdHJpbmcsIGluZGV4ICk7XHJcbiAgfVxyXG4gIHJldHVybiBleHByZXNzaW9uRnJhZ21lbnQ7XHJcbn1cclxuXHJcbmV4cHJlc3Npb25FeGNoYW5nZS5yZWdpc3RlciggJ0V4cHJlc3Npb25EZXNjcmlwdGlvbk5vZGUnLCBFeHByZXNzaW9uRGVzY3JpcHRpb25Ob2RlICk7XHJcblxyXG5leHBvcnQgZGVmYXVs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