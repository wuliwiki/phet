// Copyright 2017-2022, University of Colorado Boulder

/**
 * A description of a mathematical expression using coin term types and operations, used in the game.   This is limited
 * to handling only the expressions needed for the ExpressionExchange simulation.  In other words, it isn't a general
 * expression parser, though it could probably be generalized with some effort.
 *
 * @author John Blanco
 */

import CoinTermTypeID from '../../common/enum/CoinTermTypeID.js';
import expressionExchange from '../../expressionExchange.js';
import Term from './Term.js';
class ExpressionDescription {
  /**
   * @param {string} expressionString
   */
  constructor(expressionString) {
    // @public (read-only) {string} - the string that describes this expression
    this.expressionString = expressionString;

    // remove all spaces from the expression
    const noWhitespaceExpressionString = expressionString.replace(/\s/g, '');

    // @public (read-only) {Array.<Term>} - Description of the expression as an ordered set of terms that contain the
    // coefficient and the coin term ID
    this.terms = interpretExpression(noWhitespaceExpressionString, 0).terms;
  }

  /**
   * compares the content of a user-created expression with this description, returns true if they are equivalent
   * @param {Expression} expression
   * @returns {boolean}
   * @public
   */
  expressionMatches(expression) {
    // count the totals of the coin term types in the provided expression

    const expressionCoinTermCounts = {}; // maps coin term types (CoinTermTypeID) to numbers of each in the expression
    expression.coinTerms.forEach(coinTerm => {
      if (expressionCoinTermCounts[coinTerm.typeID]) {
        expressionCoinTermCounts[coinTerm.typeID] += coinTerm.totalCountProperty.get();
      } else {
        expressionCoinTermCounts[coinTerm.typeID] = coinTerm.totalCountProperty.get();
      }
    });

    // remove any terms that were present in the equation but were ultimately cancelled out
    _.keys(expressionCoinTermCounts).forEach(key => {
      if (expressionCoinTermCounts[key] === 0) {
        delete expressionCoinTermCounts[key];
      }
    });
    const expressionCoinTermCountKeys = Object.keys(expressionCoinTermCounts);

    // Does the expression have the same number of coin term types as the description?
    if (this.terms.length !== expressionCoinTermCountKeys.length) {
      return false;
    }

    // Do the counts match?  Note that this assumes the expression description is reduced.
    for (let i = 0; i < this.terms.length; i++) {
      const termDescriptor = this.terms[i];
      const expressionCount = expressionCoinTermCounts[termDescriptor.coinTermTypeID];
      if (!expressionCount || expressionCount !== termDescriptor.coefficient) {
        return false;
      }
    }

    // if we made it to here, the expression matches the description
    return true;
  }

  /**
   * compares a coin term with this description, returns true if they are equivalent
   * @param {CoinTerm} coinTerm
   * @returns {boolean}
   * @public
   */
  coinTermMatches(coinTerm) {
    // there must be only a single coin term in the description for this to be a match
    return this.terms.length === 1 && this.terms[0].matchesCoinTerm(coinTerm);
  }
}

// helper function to identify one of the supported operators
function isOperator(char) {
  return char === '+' || char === '-';
}

/**
 * A helper function that takes an expression string and an index and returns the terms, used recursively to handle
 * parentheses.  This is not a perfectly general expression interpreter - it only handles the specific cases needed
 * by the Expression Exchange simulation.
 * @param {String} expressionString - description of string with no white space or multiplication symbols, e.g.
 * 2x-1 or x(y+2)
 * @param {number} currentIndex
 * @returns {Array.<Term>}
 */
function interpretExpression(expressionString, currentIndex) {
  let terms = [];
  let termExtractionResult = null;
  let subExpressionInterpretationResult = null;
  while (currentIndex < expressionString.length) {
    termExtractionResult = extractTerm(expressionString, currentIndex);
    currentIndex = termExtractionResult.newIndex;

    // the logic below was left unsimplified to make it explicit and clear what cases are being handled
    if (currentIndex >= expressionString.length) {
      // the end of the expression or sub-expression has been reached, add this term
      terms.push(termExtractionResult.term);
    } else if (expressionString.charAt(currentIndex) === ')') {
      // the end of the sub-expression has been reached, add this term
      terms.push(termExtractionResult.term);
      currentIndex++;

      // force exit of the loop
      break;
    } else if (isOperator(expressionString.charAt(currentIndex))) {
      // this is a standalone term (not a multiplier for a sub-expression) so add it to the array and bump the index
      terms.push(termExtractionResult.term);
    } else if (expressionString.charAt(currentIndex) === '(') {
      // this is the beginning of a sub-expression, so recursively invoke this function to extract it
      currentIndex++;
      subExpressionInterpretationResult = interpretExpression(expressionString, currentIndex);

      // the previously extracted term is now used to multiply the extracted expression (distributive property)
      const multipliedSubExpression = _.map(subExpressionInterpretationResult.terms, term => term.times(termExtractionResult.term));

      // add the new terms to the terms array or consolidate it with existing therms, and then update the index
      multipliedSubExpression.forEach(multipliedSubExpressionTerm => {
        // extract terms from the term array that match this one - there should be zero or one, no more
        const matchingTermsArray = _.filter(terms, term => term.coinTermTypeID === multipliedSubExpressionTerm.coinTermTypeID);

        // test that the terms array was properly reduced before reaching this point
        assert && assert(matchingTermsArray.length <= 1, 'error - terms array was not properly reduced');
        if (matchingTermsArray.length === 1) {
          const matchingTerm = matchingTermsArray[0];
          matchingTerm.coefficient += multipliedSubExpressionTerm.coefficient;
          if (matchingTerm.coefficient === 0) {
            // this term has cancelled, so remove it from the array
            terms = _.without(terms, matchingTerm);
          }
        } else {
          // this is a new term, so simply add it to the array of terms
          terms.push(multipliedSubExpressionTerm);
        }
      });
      currentIndex = subExpressionInterpretationResult.newIndex;
    } else {
      assert && assert(false, `error occurred while interpreting expression string, string = ${expressionString}`);
    }
  }
  return {
    terms: terms,
    newIndex: currentIndex
  };
}
const stringToTermTypeMap = {
  '': CoinTermTypeID.CONSTANT,
  'x^2*y2': CoinTermTypeID.X_SQUARED_TIMES_Y_SQUARED,
  'x^2': CoinTermTypeID.X_SQUARED,
  'y^2': CoinTermTypeID.Y_SQUARED,
  xy: CoinTermTypeID.X_TIMES_Y,
  x: CoinTermTypeID.X,
  y: CoinTermTypeID.Y,
  z: CoinTermTypeID.Z
};

/**
 * helper function to extract a term from the equation string and also increase the index to the next token in the
 * string
 * @param {string} expressionString
 * @param {number} index
 * @returns {{term: {Term}, newIndex: {number}}}
 */
function extractTerm(expressionString, index) {
  // handle the sign in front of the coefficient, if present
  let signMultiplier = 1;
  if (expressionString[index] === '-') {
    signMultiplier = -1;
    index++;
  } else if (expressionString[index] === '+') {
    index++;
  }
  let coefficientString = '';

  // pull out any numbers, and note that this assumes only integers are used as coefficients
  while (!isNaN(Number(expressionString[index]))) {
    coefficientString += expressionString.charAt(index++);
  }

  // determine the numerical value of the coefficient
  const coefficient = (coefficientString.length > 0 ? Number(coefficientString) : 1) * signMultiplier;

  // determine where the term ends within the expression string
  const nextPlusSignIndex = expressionString.indexOf('+', index);
  const nextMinusSignIndex = expressionString.indexOf('-', index);
  const nextOpenParenIndex = expressionString.indexOf('(', index);
  const nextCloseParenIndex = expressionString.indexOf(')', index);
  const termEndIndex = Math.min(nextPlusSignIndex > 0 ? nextPlusSignIndex : Number.POSITIVE_INFINITY, nextMinusSignIndex > 0 ? nextMinusSignIndex : Number.POSITIVE_INFINITY, nextOpenParenIndex > 0 ? nextOpenParenIndex : Number.POSITIVE_INFINITY, nextCloseParenIndex > 0 ? nextCloseParenIndex : Number.POSITIVE_INFINITY, expressionString.length);

  // extract the string that represents the term
  const termString = expressionString.substring(index, termEndIndex).toLowerCase();

  // get the coin term type
  const coinTermTypeID = stringToTermTypeMap[termString];
  return {
    term: new Term(coefficient, coinTermTypeID),
    newIndex: index + termString.length
  };
}
expressionExchange.register('ExpressionDescription', ExpressionDescription);
export default ExpressionDescription;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJDb2luVGVybVR5cGVJRCIsImV4cHJlc3Npb25FeGNoYW5nZSIsIlRlcm0iLCJFeHByZXNzaW9uRGVzY3JpcHRpb24iLCJjb25zdHJ1Y3RvciIsImV4cHJlc3Npb25TdHJpbmciLCJub1doaXRlc3BhY2VFeHByZXNzaW9uU3RyaW5nIiwicmVwbGFjZSIsInRlcm1zIiwiaW50ZXJwcmV0RXhwcmVzc2lvbiIsImV4cHJlc3Npb25NYXRjaGVzIiwiZXhwcmVzc2lvbiIsImV4cHJlc3Npb25Db2luVGVybUNvdW50cyIsImNvaW5UZXJtcyIsImZvckVhY2giLCJjb2luVGVybSIsInR5cGVJRCIsInRvdGFsQ291bnRQcm9wZXJ0eSIsImdldCIsIl8iLCJrZXlzIiwia2V5IiwiZXhwcmVzc2lvbkNvaW5UZXJtQ291bnRLZXlzIiwiT2JqZWN0IiwibGVuZ3RoIiwiaSIsInRlcm1EZXNjcmlwdG9yIiwiZXhwcmVzc2lvbkNvdW50IiwiY29pblRlcm1UeXBlSUQiLCJjb2VmZmljaWVudCIsImNvaW5UZXJtTWF0Y2hlcyIsIm1hdGNoZXNDb2luVGVybSIsImlzT3BlcmF0b3IiLCJjaGFyIiwiY3VycmVudEluZGV4IiwidGVybUV4dHJhY3Rpb25SZXN1bHQiLCJzdWJFeHByZXNzaW9uSW50ZXJwcmV0YXRpb25SZXN1bHQiLCJleHRyYWN0VGVybSIsIm5ld0luZGV4IiwicHVzaCIsInRlcm0iLCJjaGFyQXQiLCJtdWx0aXBsaWVkU3ViRXhwcmVzc2lvbiIsIm1hcCIsInRpbWVzIiwibXVsdGlwbGllZFN1YkV4cHJlc3Npb25UZXJtIiwibWF0Y2hpbmdUZXJtc0FycmF5IiwiZmlsdGVyIiwiYXNzZXJ0IiwibWF0Y2hpbmdUZXJtIiwid2l0aG91dCIsInN0cmluZ1RvVGVybVR5cGVNYXAiLCJDT05TVEFOVCIsIlhfU1FVQVJFRF9USU1FU19ZX1NRVUFSRUQiLCJYX1NRVUFSRUQiLCJZX1NRVUFSRUQiLCJ4eSIsIlhfVElNRVNfWSIsIngiLCJYIiwieSIsIlkiLCJ6IiwiWiIsImluZGV4Iiwic2lnbk11bHRpcGxpZXIiLCJjb2VmZmljaWVudFN0cmluZyIsImlzTmFOIiwiTnVtYmVyIiwibmV4dFBsdXNTaWduSW5kZXgiLCJpbmRleE9mIiwibmV4dE1pbnVzU2lnbkluZGV4IiwibmV4dE9wZW5QYXJlbkluZGV4IiwibmV4dENsb3NlUGFyZW5JbmRleCIsInRlcm1FbmRJbmRleCIsIk1hdGgiLCJtaW4iLCJQT1NJVElWRV9JTkZJTklUWSIsInRlcm1TdHJpbmciLCJzdWJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRXhwcmVzc2lvbkRlc2NyaXB0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE3LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgZGVzY3JpcHRpb24gb2YgYSBtYXRoZW1hdGljYWwgZXhwcmVzc2lvbiB1c2luZyBjb2luIHRlcm0gdHlwZXMgYW5kIG9wZXJhdGlvbnMsIHVzZWQgaW4gdGhlIGdhbWUuICAgVGhpcyBpcyBsaW1pdGVkXHJcbiAqIHRvIGhhbmRsaW5nIG9ubHkgdGhlIGV4cHJlc3Npb25zIG5lZWRlZCBmb3IgdGhlIEV4cHJlc3Npb25FeGNoYW5nZSBzaW11bGF0aW9uLiAgSW4gb3RoZXIgd29yZHMsIGl0IGlzbid0IGEgZ2VuZXJhbFxyXG4gKiBleHByZXNzaW9uIHBhcnNlciwgdGhvdWdoIGl0IGNvdWxkIHByb2JhYmx5IGJlIGdlbmVyYWxpemVkIHdpdGggc29tZSBlZmZvcnQuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICovXHJcblxyXG5pbXBvcnQgQ29pblRlcm1UeXBlSUQgZnJvbSAnLi4vLi4vY29tbW9uL2VudW0vQ29pblRlcm1UeXBlSUQuanMnO1xyXG5pbXBvcnQgZXhwcmVzc2lvbkV4Y2hhbmdlIGZyb20gJy4uLy4uL2V4cHJlc3Npb25FeGNoYW5nZS5qcyc7XHJcbmltcG9ydCBUZXJtIGZyb20gJy4vVGVybS5qcyc7XHJcblxyXG5jbGFzcyBFeHByZXNzaW9uRGVzY3JpcHRpb24ge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvblN0cmluZ1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBleHByZXNzaW9uU3RyaW5nICkge1xyXG5cclxuICAgIC8vIEBwdWJsaWMgKHJlYWQtb25seSkge3N0cmluZ30gLSB0aGUgc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoaXMgZXhwcmVzc2lvblxyXG4gICAgdGhpcy5leHByZXNzaW9uU3RyaW5nID0gZXhwcmVzc2lvblN0cmluZztcclxuXHJcbiAgICAvLyByZW1vdmUgYWxsIHNwYWNlcyBmcm9tIHRoZSBleHByZXNzaW9uXHJcbiAgICBjb25zdCBub1doaXRlc3BhY2VFeHByZXNzaW9uU3RyaW5nID0gZXhwcmVzc2lvblN0cmluZy5yZXBsYWNlKCAvXFxzL2csICcnICk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyAocmVhZC1vbmx5KSB7QXJyYXkuPFRlcm0+fSAtIERlc2NyaXB0aW9uIG9mIHRoZSBleHByZXNzaW9uIGFzIGFuIG9yZGVyZWQgc2V0IG9mIHRlcm1zIHRoYXQgY29udGFpbiB0aGVcclxuICAgIC8vIGNvZWZmaWNpZW50IGFuZCB0aGUgY29pbiB0ZXJtIElEXHJcbiAgICB0aGlzLnRlcm1zID0gaW50ZXJwcmV0RXhwcmVzc2lvbiggbm9XaGl0ZXNwYWNlRXhwcmVzc2lvblN0cmluZywgMCApLnRlcm1zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY29tcGFyZXMgdGhlIGNvbnRlbnQgb2YgYSB1c2VyLWNyZWF0ZWQgZXhwcmVzc2lvbiB3aXRoIHRoaXMgZGVzY3JpcHRpb24sIHJldHVybnMgdHJ1ZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50XHJcbiAgICogQHBhcmFtIHtFeHByZXNzaW9ufSBleHByZXNzaW9uXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGV4cHJlc3Npb25NYXRjaGVzKCBleHByZXNzaW9uICkge1xyXG5cclxuICAgIC8vIGNvdW50IHRoZSB0b3RhbHMgb2YgdGhlIGNvaW4gdGVybSB0eXBlcyBpbiB0aGUgcHJvdmlkZWQgZXhwcmVzc2lvblxyXG5cclxuICAgIGNvbnN0IGV4cHJlc3Npb25Db2luVGVybUNvdW50cyA9IHt9OyAvLyBtYXBzIGNvaW4gdGVybSB0eXBlcyAoQ29pblRlcm1UeXBlSUQpIHRvIG51bWJlcnMgb2YgZWFjaCBpbiB0aGUgZXhwcmVzc2lvblxyXG4gICAgZXhwcmVzc2lvbi5jb2luVGVybXMuZm9yRWFjaCggY29pblRlcm0gPT4ge1xyXG4gICAgICBpZiAoIGV4cHJlc3Npb25Db2luVGVybUNvdW50c1sgY29pblRlcm0udHlwZUlEIF0gKSB7XHJcbiAgICAgICAgZXhwcmVzc2lvbkNvaW5UZXJtQ291bnRzWyBjb2luVGVybS50eXBlSUQgXSArPSBjb2luVGVybS50b3RhbENvdW50UHJvcGVydHkuZ2V0KCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgZXhwcmVzc2lvbkNvaW5UZXJtQ291bnRzWyBjb2luVGVybS50eXBlSUQgXSA9IGNvaW5UZXJtLnRvdGFsQ291bnRQcm9wZXJ0eS5nZXQoKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIHJlbW92ZSBhbnkgdGVybXMgdGhhdCB3ZXJlIHByZXNlbnQgaW4gdGhlIGVxdWF0aW9uIGJ1dCB3ZXJlIHVsdGltYXRlbHkgY2FuY2VsbGVkIG91dFxyXG4gICAgXy5rZXlzKCBleHByZXNzaW9uQ29pblRlcm1Db3VudHMgKS5mb3JFYWNoKCBrZXkgPT4ge1xyXG4gICAgICBpZiAoIGV4cHJlc3Npb25Db2luVGVybUNvdW50c1sga2V5IF0gPT09IDAgKSB7XHJcbiAgICAgICAgZGVsZXRlIGV4cHJlc3Npb25Db2luVGVybUNvdW50c1sga2V5IF07XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICBjb25zdCBleHByZXNzaW9uQ29pblRlcm1Db3VudEtleXMgPSBPYmplY3Qua2V5cyggZXhwcmVzc2lvbkNvaW5UZXJtQ291bnRzICk7XHJcblxyXG4gICAgLy8gRG9lcyB0aGUgZXhwcmVzc2lvbiBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBjb2luIHRlcm0gdHlwZXMgYXMgdGhlIGRlc2NyaXB0aW9uP1xyXG4gICAgaWYgKCB0aGlzLnRlcm1zLmxlbmd0aCAhPT0gZXhwcmVzc2lvbkNvaW5UZXJtQ291bnRLZXlzLmxlbmd0aCApIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHRoZSBjb3VudHMgbWF0Y2g/ICBOb3RlIHRoYXQgdGhpcyBhc3N1bWVzIHRoZSBleHByZXNzaW9uIGRlc2NyaXB0aW9uIGlzIHJlZHVjZWQuXHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLnRlcm1zLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICBjb25zdCB0ZXJtRGVzY3JpcHRvciA9IHRoaXMudGVybXNbIGkgXTtcclxuICAgICAgY29uc3QgZXhwcmVzc2lvbkNvdW50ID0gZXhwcmVzc2lvbkNvaW5UZXJtQ291bnRzWyB0ZXJtRGVzY3JpcHRvci5jb2luVGVybVR5cGVJRCBdO1xyXG4gICAgICBpZiAoICFleHByZXNzaW9uQ291bnQgfHwgZXhwcmVzc2lvbkNvdW50ICE9PSB0ZXJtRGVzY3JpcHRvci5jb2VmZmljaWVudCApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB3ZSBtYWRlIGl0IHRvIGhlcmUsIHRoZSBleHByZXNzaW9uIG1hdGNoZXMgdGhlIGRlc2NyaXB0aW9uXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNvbXBhcmVzIGEgY29pbiB0ZXJtIHdpdGggdGhpcyBkZXNjcmlwdGlvbiwgcmV0dXJucyB0cnVlIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnRcclxuICAgKiBAcGFyYW0ge0NvaW5UZXJtfSBjb2luVGVybVxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBjb2luVGVybU1hdGNoZXMoIGNvaW5UZXJtICkge1xyXG5cclxuICAgIC8vIHRoZXJlIG11c3QgYmUgb25seSBhIHNpbmdsZSBjb2luIHRlcm0gaW4gdGhlIGRlc2NyaXB0aW9uIGZvciB0aGlzIHRvIGJlIGEgbWF0Y2hcclxuICAgIHJldHVybiB0aGlzLnRlcm1zLmxlbmd0aCA9PT0gMSAmJiB0aGlzLnRlcm1zWyAwIF0ubWF0Y2hlc0NvaW5UZXJtKCBjb2luVGVybSApO1xyXG4gIH1cclxufVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGlkZW50aWZ5IG9uZSBvZiB0aGUgc3VwcG9ydGVkIG9wZXJhdG9yc1xyXG5mdW5jdGlvbiBpc09wZXJhdG9yKCBjaGFyICkge1xyXG4gIHJldHVybiBjaGFyID09PSAnKycgfHwgY2hhciA9PT0gJy0nO1xyXG59XHJcblxyXG4vKipcclxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBleHByZXNzaW9uIHN0cmluZyBhbmQgYW4gaW5kZXggYW5kIHJldHVybnMgdGhlIHRlcm1zLCB1c2VkIHJlY3Vyc2l2ZWx5IHRvIGhhbmRsZVxyXG4gKiBwYXJlbnRoZXNlcy4gIFRoaXMgaXMgbm90IGEgcGVyZmVjdGx5IGdlbmVyYWwgZXhwcmVzc2lvbiBpbnRlcnByZXRlciAtIGl0IG9ubHkgaGFuZGxlcyB0aGUgc3BlY2lmaWMgY2FzZXMgbmVlZGVkXHJcbiAqIGJ5IHRoZSBFeHByZXNzaW9uIEV4Y2hhbmdlIHNpbXVsYXRpb24uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uU3RyaW5nIC0gZGVzY3JpcHRpb24gb2Ygc3RyaW5nIHdpdGggbm8gd2hpdGUgc3BhY2Ugb3IgbXVsdGlwbGljYXRpb24gc3ltYm9scywgZS5nLlxyXG4gKiAyeC0xIG9yIHgoeSsyKVxyXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEluZGV4XHJcbiAqIEByZXR1cm5zIHtBcnJheS48VGVybT59XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnRlcnByZXRFeHByZXNzaW9uKCBleHByZXNzaW9uU3RyaW5nLCBjdXJyZW50SW5kZXggKSB7XHJcbiAgbGV0IHRlcm1zID0gW107XHJcbiAgbGV0IHRlcm1FeHRyYWN0aW9uUmVzdWx0ID0gbnVsbDtcclxuICBsZXQgc3ViRXhwcmVzc2lvbkludGVycHJldGF0aW9uUmVzdWx0ID0gbnVsbDtcclxuICB3aGlsZSAoIGN1cnJlbnRJbmRleCA8IGV4cHJlc3Npb25TdHJpbmcubGVuZ3RoICkge1xyXG4gICAgdGVybUV4dHJhY3Rpb25SZXN1bHQgPSBleHRyYWN0VGVybSggZXhwcmVzc2lvblN0cmluZywgY3VycmVudEluZGV4ICk7XHJcbiAgICBjdXJyZW50SW5kZXggPSB0ZXJtRXh0cmFjdGlvblJlc3VsdC5uZXdJbmRleDtcclxuXHJcbiAgICAvLyB0aGUgbG9naWMgYmVsb3cgd2FzIGxlZnQgdW5zaW1wbGlmaWVkIHRvIG1ha2UgaXQgZXhwbGljaXQgYW5kIGNsZWFyIHdoYXQgY2FzZXMgYXJlIGJlaW5nIGhhbmRsZWRcclxuICAgIGlmICggY3VycmVudEluZGV4ID49IGV4cHJlc3Npb25TdHJpbmcubGVuZ3RoICkge1xyXG5cclxuICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvbiBvciBzdWItZXhwcmVzc2lvbiBoYXMgYmVlbiByZWFjaGVkLCBhZGQgdGhpcyB0ZXJtXHJcbiAgICAgIHRlcm1zLnB1c2goIHRlcm1FeHRyYWN0aW9uUmVzdWx0LnRlcm0gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCBleHByZXNzaW9uU3RyaW5nLmNoYXJBdCggY3VycmVudEluZGV4ICkgPT09ICcpJyApIHtcclxuXHJcbiAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHN1Yi1leHByZXNzaW9uIGhhcyBiZWVuIHJlYWNoZWQsIGFkZCB0aGlzIHRlcm1cclxuICAgICAgdGVybXMucHVzaCggdGVybUV4dHJhY3Rpb25SZXN1bHQudGVybSApO1xyXG4gICAgICBjdXJyZW50SW5kZXgrKztcclxuXHJcbiAgICAgIC8vIGZvcmNlIGV4aXQgb2YgdGhlIGxvb3BcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggaXNPcGVyYXRvciggZXhwcmVzc2lvblN0cmluZy5jaGFyQXQoIGN1cnJlbnRJbmRleCApICkgKSB7XHJcblxyXG4gICAgICAvLyB0aGlzIGlzIGEgc3RhbmRhbG9uZSB0ZXJtIChub3QgYSBtdWx0aXBsaWVyIGZvciBhIHN1Yi1leHByZXNzaW9uKSBzbyBhZGQgaXQgdG8gdGhlIGFycmF5IGFuZCBidW1wIHRoZSBpbmRleFxyXG4gICAgICB0ZXJtcy5wdXNoKCB0ZXJtRXh0cmFjdGlvblJlc3VsdC50ZXJtICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggZXhwcmVzc2lvblN0cmluZy5jaGFyQXQoIGN1cnJlbnRJbmRleCApID09PSAnKCcgKSB7XHJcblxyXG4gICAgICAvLyB0aGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgYSBzdWItZXhwcmVzc2lvbiwgc28gcmVjdXJzaXZlbHkgaW52b2tlIHRoaXMgZnVuY3Rpb24gdG8gZXh0cmFjdCBpdFxyXG4gICAgICBjdXJyZW50SW5kZXgrKztcclxuICAgICAgc3ViRXhwcmVzc2lvbkludGVycHJldGF0aW9uUmVzdWx0ID0gaW50ZXJwcmV0RXhwcmVzc2lvbiggZXhwcmVzc2lvblN0cmluZywgY3VycmVudEluZGV4ICk7XHJcblxyXG4gICAgICAvLyB0aGUgcHJldmlvdXNseSBleHRyYWN0ZWQgdGVybSBpcyBub3cgdXNlZCB0byBtdWx0aXBseSB0aGUgZXh0cmFjdGVkIGV4cHJlc3Npb24gKGRpc3RyaWJ1dGl2ZSBwcm9wZXJ0eSlcclxuICAgICAgY29uc3QgbXVsdGlwbGllZFN1YkV4cHJlc3Npb24gPSBfLm1hcCggc3ViRXhwcmVzc2lvbkludGVycHJldGF0aW9uUmVzdWx0LnRlcm1zLCB0ZXJtID0+IHRlcm0udGltZXMoIHRlcm1FeHRyYWN0aW9uUmVzdWx0LnRlcm0gKSApO1xyXG5cclxuICAgICAgLy8gYWRkIHRoZSBuZXcgdGVybXMgdG8gdGhlIHRlcm1zIGFycmF5IG9yIGNvbnNvbGlkYXRlIGl0IHdpdGggZXhpc3RpbmcgdGhlcm1zLCBhbmQgdGhlbiB1cGRhdGUgdGhlIGluZGV4XHJcbiAgICAgIG11bHRpcGxpZWRTdWJFeHByZXNzaW9uLmZvckVhY2goIG11bHRpcGxpZWRTdWJFeHByZXNzaW9uVGVybSA9PiB7XHJcblxyXG4gICAgICAgIC8vIGV4dHJhY3QgdGVybXMgZnJvbSB0aGUgdGVybSBhcnJheSB0aGF0IG1hdGNoIHRoaXMgb25lIC0gdGhlcmUgc2hvdWxkIGJlIHplcm8gb3Igb25lLCBubyBtb3JlXHJcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdUZXJtc0FycmF5ID0gXy5maWx0ZXIoIHRlcm1zLCB0ZXJtID0+IHRlcm0uY29pblRlcm1UeXBlSUQgPT09IG11bHRpcGxpZWRTdWJFeHByZXNzaW9uVGVybS5jb2luVGVybVR5cGVJRCApO1xyXG5cclxuICAgICAgICAvLyB0ZXN0IHRoYXQgdGhlIHRlcm1zIGFycmF5IHdhcyBwcm9wZXJseSByZWR1Y2VkIGJlZm9yZSByZWFjaGluZyB0aGlzIHBvaW50XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggbWF0Y2hpbmdUZXJtc0FycmF5Lmxlbmd0aCA8PSAxLCAnZXJyb3IgLSB0ZXJtcyBhcnJheSB3YXMgbm90IHByb3Blcmx5IHJlZHVjZWQnICk7XHJcblxyXG4gICAgICAgIGlmICggbWF0Y2hpbmdUZXJtc0FycmF5Lmxlbmd0aCA9PT0gMSApIHtcclxuICAgICAgICAgIGNvbnN0IG1hdGNoaW5nVGVybSA9IG1hdGNoaW5nVGVybXNBcnJheVsgMCBdO1xyXG5cclxuICAgICAgICAgIG1hdGNoaW5nVGVybS5jb2VmZmljaWVudCArPSBtdWx0aXBsaWVkU3ViRXhwcmVzc2lvblRlcm0uY29lZmZpY2llbnQ7XHJcbiAgICAgICAgICBpZiAoIG1hdGNoaW5nVGVybS5jb2VmZmljaWVudCA9PT0gMCApIHtcclxuICAgICAgICAgICAgLy8gdGhpcyB0ZXJtIGhhcyBjYW5jZWxsZWQsIHNvIHJlbW92ZSBpdCBmcm9tIHRoZSBhcnJheVxyXG4gICAgICAgICAgICB0ZXJtcyA9IF8ud2l0aG91dCggdGVybXMsIG1hdGNoaW5nVGVybSApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgbmV3IHRlcm0sIHNvIHNpbXBseSBhZGQgaXQgdG8gdGhlIGFycmF5IG9mIHRlcm1zXHJcbiAgICAgICAgICB0ZXJtcy5wdXNoKCBtdWx0aXBsaWVkU3ViRXhwcmVzc2lvblRlcm0gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gKTtcclxuICAgICAgY3VycmVudEluZGV4ID0gc3ViRXhwcmVzc2lvbkludGVycHJldGF0aW9uUmVzdWx0Lm5ld0luZGV4O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCBgZXJyb3Igb2NjdXJyZWQgd2hpbGUgaW50ZXJwcmV0aW5nIGV4cHJlc3Npb24gc3RyaW5nLCBzdHJpbmcgPSAke2V4cHJlc3Npb25TdHJpbmd9YCApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHRlcm1zOiB0ZXJtcyxcclxuICAgIG5ld0luZGV4OiBjdXJyZW50SW5kZXhcclxuICB9O1xyXG59XHJcblxyXG5jb25zdCBzdHJpbmdUb1Rlcm1UeXBlTWFwID0ge1xyXG4gICcnOiBDb2luVGVybVR5cGVJRC5DT05TVEFOVCxcclxuICAneF4yKnkyJzogQ29pblRlcm1UeXBlSUQuWF9TUVVBUkVEX1RJTUVTX1lfU1FVQVJFRCxcclxuICAneF4yJzogQ29pblRlcm1UeXBlSUQuWF9TUVVBUkVELFxyXG4gICd5XjInOiBDb2luVGVybVR5cGVJRC5ZX1NRVUFSRUQsXHJcbiAgeHk6IENvaW5UZXJtVHlwZUlELlhfVElNRVNfWSxcclxuICB4OiBDb2luVGVybVR5cGVJRC5YLFxyXG4gIHk6IENvaW5UZXJtVHlwZUlELlksXHJcbiAgejogQ29pblRlcm1UeXBlSUQuWlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGhlbHBlciBmdW5jdGlvbiB0byBleHRyYWN0IGEgdGVybSBmcm9tIHRoZSBlcXVhdGlvbiBzdHJpbmcgYW5kIGFsc28gaW5jcmVhc2UgdGhlIGluZGV4IHRvIHRoZSBuZXh0IHRva2VuIGluIHRoZVxyXG4gKiBzdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb25TdHJpbmdcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAqIEByZXR1cm5zIHt7dGVybToge1Rlcm19LCBuZXdJbmRleDoge251bWJlcn19fVxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdFRlcm0oIGV4cHJlc3Npb25TdHJpbmcsIGluZGV4ICkge1xyXG5cclxuICAvLyBoYW5kbGUgdGhlIHNpZ24gaW4gZnJvbnQgb2YgdGhlIGNvZWZmaWNpZW50LCBpZiBwcmVzZW50XHJcbiAgbGV0IHNpZ25NdWx0aXBsaWVyID0gMTtcclxuICBpZiAoIGV4cHJlc3Npb25TdHJpbmdbIGluZGV4IF0gPT09ICctJyApIHtcclxuICAgIHNpZ25NdWx0aXBsaWVyID0gLTE7XHJcbiAgICBpbmRleCsrO1xyXG4gIH1cclxuICBlbHNlIGlmICggZXhwcmVzc2lvblN0cmluZ1sgaW5kZXggXSA9PT0gJysnICkge1xyXG4gICAgaW5kZXgrKztcclxuICB9XHJcblxyXG4gIGxldCBjb2VmZmljaWVudFN0cmluZyA9ICcnO1xyXG5cclxuICAvLyBwdWxsIG91dCBhbnkgbnVtYmVycywgYW5kIG5vdGUgdGhhdCB0aGlzIGFzc3VtZXMgb25seSBpbnRlZ2VycyBhcmUgdXNlZCBhcyBjb2VmZmljaWVudHNcclxuICB3aGlsZSAoICFpc05hTiggTnVtYmVyKCBleHByZXNzaW9uU3RyaW5nWyBpbmRleCBdICkgKSApIHtcclxuICAgIGNvZWZmaWNpZW50U3RyaW5nICs9IGV4cHJlc3Npb25TdHJpbmcuY2hhckF0KCBpbmRleCsrICk7XHJcbiAgfVxyXG5cclxuICAvLyBkZXRlcm1pbmUgdGhlIG51bWVyaWNhbCB2YWx1ZSBvZiB0aGUgY29lZmZpY2llbnRcclxuICBjb25zdCBjb2VmZmljaWVudCA9ICggY29lZmZpY2llbnRTdHJpbmcubGVuZ3RoID4gMCA/IE51bWJlciggY29lZmZpY2llbnRTdHJpbmcgKSA6IDEgKSAqIHNpZ25NdWx0aXBsaWVyO1xyXG5cclxuICAvLyBkZXRlcm1pbmUgd2hlcmUgdGhlIHRlcm0gZW5kcyB3aXRoaW4gdGhlIGV4cHJlc3Npb24gc3RyaW5nXHJcbiAgY29uc3QgbmV4dFBsdXNTaWduSW5kZXggPSBleHByZXNzaW9uU3RyaW5nLmluZGV4T2YoICcrJywgaW5kZXggKTtcclxuICBjb25zdCBuZXh0TWludXNTaWduSW5kZXggPSBleHByZXNzaW9uU3RyaW5nLmluZGV4T2YoICctJywgaW5kZXggKTtcclxuICBjb25zdCBuZXh0T3BlblBhcmVuSW5kZXggPSBleHByZXNzaW9uU3RyaW5nLmluZGV4T2YoICcoJywgaW5kZXggKTtcclxuICBjb25zdCBuZXh0Q2xvc2VQYXJlbkluZGV4ID0gZXhwcmVzc2lvblN0cmluZy5pbmRleE9mKCAnKScsIGluZGV4ICk7XHJcbiAgY29uc3QgdGVybUVuZEluZGV4ID0gTWF0aC5taW4oXHJcbiAgICBuZXh0UGx1c1NpZ25JbmRleCA+IDAgPyBuZXh0UGx1c1NpZ25JbmRleCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcclxuICAgIG5leHRNaW51c1NpZ25JbmRleCA+IDAgPyBuZXh0TWludXNTaWduSW5kZXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXHJcbiAgICBuZXh0T3BlblBhcmVuSW5kZXggPiAwID8gbmV4dE9wZW5QYXJlbkluZGV4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxyXG4gICAgbmV4dENsb3NlUGFyZW5JbmRleCA+IDAgPyBuZXh0Q2xvc2VQYXJlbkluZGV4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxyXG4gICAgZXhwcmVzc2lvblN0cmluZy5sZW5ndGhcclxuICApO1xyXG5cclxuICAvLyBleHRyYWN0IHRoZSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSB0ZXJtXHJcbiAgY29uc3QgdGVybVN0cmluZyA9IGV4cHJlc3Npb25TdHJpbmcuc3Vic3RyaW5nKCBpbmRleCwgdGVybUVuZEluZGV4ICkudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgLy8gZ2V0IHRoZSBjb2luIHRlcm0gdHlwZVxyXG4gIGNvbnN0IGNvaW5UZXJtVHlwZUlEID0gc3RyaW5nVG9UZXJtVHlwZU1hcFsgdGVybVN0cmluZyBdO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgdGVybTogbmV3IFRlcm0oIGNvZWZmaWNpZW50LCBjb2luVGVybVR5cGVJRCApLFxyXG4gICAgbmV3SW5kZXg6IGluZGV4ICsgdGVybVN0cmluZy5sZW5ndGhcclxuICB9O1xyXG59XHJcblxyXG5leHByZXNzaW9uRXhjaGFuZ2UucmVnaXN0ZXIoICdFeHByZXNzaW9uRGVzY3JpcHRpb24nLCBFeHByZXNzaW9uRGVzY3JpcHRpb24gKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEV4cHJlc3Npb25EZXNjcmlwdGlvbjsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGNBQWMsTUFBTSxxQ0FBcUM7QUFDaEUsT0FBT0Msa0JBQWtCLE1BQU0sNkJBQTZCO0FBQzVELE9BQU9DLElBQUksTUFBTSxXQUFXO0FBRTVCLE1BQU1DLHFCQUFxQixDQUFDO0VBRTFCO0FBQ0Y7QUFDQTtFQUNFQyxXQUFXQSxDQUFFQyxnQkFBZ0IsRUFBRztJQUU5QjtJQUNBLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUdBLGdCQUFnQjs7SUFFeEM7SUFDQSxNQUFNQyw0QkFBNEIsR0FBR0QsZ0JBQWdCLENBQUNF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