// Copyright 2015-2022, University of Colorado Boulder

/**
 * Simple model of a DC battery.  Origin is at the geometric center of the battery's body.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */

import NumberProperty from '../../../../axon/js/NumberProperty.js';
import Property from '../../../../axon/js/Property.js';
import Dimension2 from '../../../../dot/js/Dimension2.js';
import Vector3 from '../../../../dot/js/Vector3.js';
import CapacitorConstants from '../../../../scenery-phet/js/capacitor/CapacitorConstants.js';
import EnumerationIO from '../../../../tandem/js/types/EnumerationIO.js';
import capacitorLabBasics from '../../capacitorLabBasics.js';
import CLBConstants from '../CLBConstants.js';
import BatteryShapeCreator from './shapes/BatteryShapeCreator.js';

// constants
// size of the associated image file, determined by visual inspection
const BODY_SIZE = new Dimension2(0.0065, 0.01425); // dimensions of the rectangle that bounds the battery image

/*
 * Positive terminal is part of the image file.
 * The terminal is a cylinder, whose dimensions were determined by visual inspection.
 * The origin of the terminal is at the center of the cylinder's top.
 */
const POSITIVE_TERMINAL_ELLIPSE_SIZE = new Dimension2(0.0025, 0.0005);
const POSITIVE_TERMINAL_CYLINDER_HEIGHT = 0.0009;
const POSITIVE_TERMINAL_Y_OFFSET = -(BODY_SIZE.height / 2) - 0.00012;

/*
 * Negative terminal is part of the image file.
 * The terminal is an ellipse, whose dimension were determined by visual inspection.
 * The origin of the terminal is at the center of the ellipse.
 */
const NEGATIVE_TERMINAL_ELLIPSE_SIZE = new Dimension2(0.0035, 0.0009); // Ellipse axes defining the negative terminal
const NEGATIVE_TERMINAL_Y_OFFSET = -(BODY_SIZE.height / 2) + 0.0006; // center of negative terminal when at the top

class Battery {
  /**
   * @param {Vector3} position
   * @param {number} voltage
   * @param {YawPitchModelViewTransform3} modelViewTransform
   * @param {Tandem} tandem
   */
  constructor(position, voltage, modelViewTransform, tandem) {
    assert && assert(position instanceof Vector3);

    // @public {Property.<number>}
    this.voltageProperty = new NumberProperty(voltage, {
      tandem: tandem.createTandem('voltageProperty'),
      units: 'V',
      range: CLBConstants.BATTERY_VOLTAGE_RANGE
    });

    // Value type: enumeration (string)
    // @public {Property.<string>} - 'POSITIVE' or 'NEGATIVE'
    // TODO: use EnumerationDeprecatedProperty
    this.polarityProperty = new Property(CapacitorConstants.POLARITY.POSITIVE, {
      validValues: CapacitorConstants.POLARITY.VALUES,
      tandem: tandem.createTandem('polarityProperty'),
      phetioValueType: EnumerationIO(CapacitorConstants.POLARITY)
    });

    // @public {Dimension2}
    this.positiveTerminalEllipseSize = POSITIVE_TERMINAL_ELLIPSE_SIZE;
    this.negativeTerminalEllipseSize = NEGATIVE_TERMINAL_ELLIPSE_SIZE;

    // @public {number}
    this.positiveTerminalCylinderHeight = POSITIVE_TERMINAL_CYLINDER_HEIGHT;

    // @public {Vector3}
    this.position = position; // @public (read-only)
    this.shapeCreator = new BatteryShapeCreator(this, modelViewTransform); // @private

    // @private {Shape}
    this.positiveTerminalShape = this.shapeCreator.createPositiveTerminalShape();
    this.negativeTerminalShape = this.shapeCreator.createNegativeTerminalShape();
    this.voltageProperty.link(() => {
      this.polarityProperty.set(this.getPolarity(this.voltageProperty.value));
    });
  }

  /**
   * Convenience function to get the polarity from the object literal based on the voltage.
   * @private
   *
   * @param {number} voltage
   * @returns {string}
   */
  getPolarity(voltage) {
    return voltage >= 0 ? CapacitorConstants.POLARITY.POSITIVE : CapacitorConstants.POLARITY.NEGATIVE;
  }

  /**
   * Determine if the probe tip shape contacts a battery terminal.
   * Since the bottom terminal is hidden in the 3D perspective, there is only
   * one contact region to check, which is the top terminal.
   * @public
   *
   * @param {Shape} probe - voltmeter probe tip shape
   * @returns {boolean}
   */
  contacts(probe) {
    let shape;
    if (this.polarityProperty.value === CapacitorConstants.POLARITY.POSITIVE) {
      shape = this.positiveTerminalShape;
    } else {
      shape = this.negativeTerminalShape;
    }
    return probe.bounds.intersectsBounds(shape.bounds) && probe.shapeIntersection(shape).getNonoverlappingArea() > 0;
  }

  /**
   * Gets the offset of the bottom terminal from the battery's origin, in model coordinates (meters).
   * We don't need to account for the polarity since the bottom terminal is never visible.
   * @public
   *
   * @returns {number}
   */
  getBottomTerminalYOffset() {
    return BODY_SIZE.height / 2;
  }

  /**
   * Gets the offset of the top terminal from the battery's origin, in model coordinates (meters).
   * This offset depends on the polarity.
   * @public
   *
   * @returns {number}
   */
  getTopTerminalYOffset() {
    if (this.polarityProperty.value === CapacitorConstants.POLARITY.POSITIVE) {
      return POSITIVE_TERMINAL_Y_OFFSET;
    } else {
      return NEGATIVE_TERMINAL_Y_OFFSET;
    }
  }

  // @public
  reset() {
    this.voltageProperty.reset();
    this.polarityProperty.reset();
  }
}
capacitorLabBasics.register('Battery', Battery);
export default Battery;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJOdW1iZXJQcm9wZXJ0eSIsIlByb3BlcnR5IiwiRGltZW5zaW9uMiIsIlZlY3RvcjMiLCJDYXBhY2l0b3JDb25zdGFudHMiLCJFbnVtZXJhdGlvbklPIiwiY2FwYWNpdG9yTGFiQmFzaWNzIiwiQ0xCQ29uc3RhbnRzIiwiQmF0dGVyeVNoYXBlQ3JlYXRvciIsIkJPRFlfU0laRSIsIlBPU0lUSVZFX1RFUk1JTkFMX0VMTElQU0VfU0laRSIsIlBPU0lUSVZFX1RFUk1JTkFMX0NZTElOREVSX0hFSUdIVCIsIlBPU0lUSVZFX1RFUk1JTkFMX1lfT0ZGU0VUIiwiaGVpZ2h0IiwiTkVHQVRJVkVfVEVSTUlOQUxfRUxMSVBTRV9TSVpFIiwiTkVHQVRJVkVfVEVSTUlOQUxfWV9PRkZTRVQiLCJCYXR0ZXJ5IiwiY29uc3RydWN0b3IiLCJwb3NpdGlvbiIsInZvbHRhZ2UiLCJtb2RlbFZpZXdUcmFuc2Zvcm0iLCJ0YW5kZW0iLCJhc3NlcnQiLCJ2b2x0YWdlUHJvcGVydHkiLCJjcmVhdGVUYW5kZW0iLCJ1bml0cyIsInJhbmdlIiwiQkFUVEVSWV9WT0xUQUdFX1JBTkdFIiwicG9sYXJpdHlQcm9wZXJ0eSIsIlBPTEFSSVRZIiwiUE9TSVRJVkUiLCJ2YWxpZFZhbHVlcyIsIlZBTFVFUyIsInBoZXRpb1ZhbHVlVHlwZSIsInBvc2l0aXZlVGVybWluYWxFbGxpcHNlU2l6ZSIsIm5lZ2F0aXZlVGVybWluYWxFbGxpcHNlU2l6ZSIsInBvc2l0aXZlVGVybWluYWxDeWxpbmRlckhlaWdodCIsInNoYXBlQ3JlYXRvciIsInBvc2l0aXZlVGVybWluYWxTaGFwZSIsImNyZWF0ZVBvc2l0aXZlVGVybWluYWxTaGFwZSIsIm5lZ2F0aXZlVGVybWluYWxTaGFwZSIsImNyZWF0ZU5lZ2F0aXZlVGVybWluYWxTaGFwZSIsImxpbmsiLCJzZXQiLCJnZXRQb2xhcml0eSIsInZhbHVlIiwiTkVHQVRJVkUiLCJjb250YWN0cyIsInByb2JlIiwic2hhcGUiLCJib3VuZHMiLCJpbnRlcnNlY3RzQm91bmRzIiwic2hhcGVJbnRlcnNlY3Rpb24iLCJnZXROb25vdmVybGFwcGluZ0FyZWEiLCJnZXRCb3R0b21UZXJtaW5hbFlPZmZzZXQiLCJnZXRUb3BUZXJtaW5hbFlPZmZzZXQiLCJyZXNldCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQmF0dGVyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNS0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBTaW1wbGUgbW9kZWwgb2YgYSBEQyBiYXR0ZXJ5LiAgT3JpZ2luIGlzIGF0IHRoZSBnZW9tZXRyaWMgY2VudGVyIG9mIHRoZSBiYXR0ZXJ5J3MgYm9keS5cclxuICpcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICogQGF1dGhvciBKZXNzZSBHcmVlbmJlcmcgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqIEBhdXRob3IgQW5kcmV3IEFkYXJlIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBOdW1iZXJQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL051bWJlclByb3BlcnR5LmpzJztcclxuaW1wb3J0IFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgRGltZW5zaW9uMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvRGltZW5zaW9uMi5qcyc7XHJcbmltcG9ydCBWZWN0b3IzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IzLmpzJztcclxuaW1wb3J0IENhcGFjaXRvckNvbnN0YW50cyBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvY2FwYWNpdG9yL0NhcGFjaXRvckNvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBFbnVtZXJhdGlvbklPIGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy90eXBlcy9FbnVtZXJhdGlvbklPLmpzJztcclxuaW1wb3J0IGNhcGFjaXRvckxhYkJhc2ljcyBmcm9tICcuLi8uLi9jYXBhY2l0b3JMYWJCYXNpY3MuanMnO1xyXG5pbXBvcnQgQ0xCQ29uc3RhbnRzIGZyb20gJy4uL0NMQkNvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBCYXR0ZXJ5U2hhcGVDcmVhdG9yIGZyb20gJy4vc2hhcGVzL0JhdHRlcnlTaGFwZUNyZWF0b3IuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbi8vIHNpemUgb2YgdGhlIGFzc29jaWF0ZWQgaW1hZ2UgZmlsZSwgZGV0ZXJtaW5lZCBieSB2aXN1YWwgaW5zcGVjdGlvblxyXG5jb25zdCBCT0RZX1NJWkUgPSBuZXcgRGltZW5zaW9uMiggMC4wMDY1LCAwLjAxNDI1ICk7IC8vIGRpbWVuc2lvbnMgb2YgdGhlIHJlY3RhbmdsZSB0aGF0IGJvdW5kcyB0aGUgYmF0dGVyeSBpbWFnZVxyXG5cclxuLypcclxuICogUG9zaXRpdmUgdGVybWluYWwgaXMgcGFydCBvZiB0aGUgaW1hZ2UgZmlsZS5cclxuICogVGhlIHRlcm1pbmFsIGlzIGEgY3lsaW5kZXIsIHdob3NlIGRpbWVuc2lvbnMgd2VyZSBkZXRlcm1pbmVkIGJ5IHZpc3VhbCBpbnNwZWN0aW9uLlxyXG4gKiBUaGUgb3JpZ2luIG9mIHRoZSB0ZXJtaW5hbCBpcyBhdCB0aGUgY2VudGVyIG9mIHRoZSBjeWxpbmRlcidzIHRvcC5cclxuICovXHJcbmNvbnN0IFBPU0lUSVZFX1RFUk1JTkFMX0VMTElQU0VfU0laRSA9IG5ldyBEaW1lbnNpb24yKCAwLjAwMjUsIDAuMDAwNSApO1xyXG5jb25zdCBQT1NJVElWRV9URVJNSU5BTF9DWUxJTkRFUl9IRUlHSFQgPSAwLjAwMDk7XHJcbmNvbnN0IFBPU0lUSVZFX1RFUk1JTkFMX1lfT0ZGU0VUID0gLSggQk9EWV9TSVpFLmhlaWdodCAvIDIgKSAtIDAuMDAwMTI7XHJcblxyXG4vKlxyXG4gKiBOZWdhdGl2ZSB0ZXJtaW5hbCBpcyBwYXJ0IG9mIHRoZSBpbWFnZSBmaWxlLlxyXG4gKiBUaGUgdGVybWluYWwgaXMgYW4gZWxsaXBzZSwgd2hvc2UgZGltZW5zaW9uIHdlcmUgZGV0ZXJtaW5lZCBieSB2aXN1YWwgaW5zcGVjdGlvbi5cclxuICogVGhlIG9yaWdpbiBvZiB0aGUgdGVybWluYWwgaXMgYXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cclxuICovXHJcbmNvbnN0IE5FR0FUSVZFX1RFUk1JTkFMX0VMTElQU0VfU0laRSA9IG5ldyBEaW1lbnNpb24yKCAwLjAwMzUsIDAuMDAwOSApOyAvLyBFbGxpcHNlIGF4ZXMgZGVmaW5pbmcgdGhlIG5lZ2F0aXZlIHRlcm1pbmFsXHJcbmNvbnN0IE5FR0FUSVZFX1RFUk1JTkFMX1lfT0ZGU0VUID0gLSggQk9EWV9TSVpFLmhlaWdodCAvIDIgKSArIDAuMDAwNjsgLy8gY2VudGVyIG9mIG5lZ2F0aXZlIHRlcm1pbmFsIHdoZW4gYXQgdGhlIHRvcFxyXG5cclxuY2xhc3MgQmF0dGVyeSB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x0YWdlXHJcbiAgICogQHBhcmFtIHtZYXdQaXRjaE1vZGVsVmlld1RyYW5zZm9ybTN9IG1vZGVsVmlld1RyYW5zZm9ybVxyXG4gICAqIEBwYXJhbSB7VGFuZGVtfSB0YW5kZW1cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggcG9zaXRpb24sIHZvbHRhZ2UsIG1vZGVsVmlld1RyYW5zZm9ybSwgdGFuZGVtICkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggcG9zaXRpb24gaW5zdGFuY2VvZiBWZWN0b3IzICk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyB7UHJvcGVydHkuPG51bWJlcj59XHJcbiAgICB0aGlzLnZvbHRhZ2VQcm9wZXJ0eSA9IG5ldyBOdW1iZXJQcm9wZXJ0eSggdm9sdGFnZSwge1xyXG4gICAgICB0YW5kZW06IHRhbmRlbS5jcmVhdGVUYW5kZW0oICd2b2x0YWdlUHJvcGVydHknICksXHJcbiAgICAgIHVuaXRzOiAnVicsXHJcbiAgICAgIHJhbmdlOiBDTEJDb25zdGFudHMuQkFUVEVSWV9WT0xUQUdFX1JBTkdFXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gVmFsdWUgdHlwZTogZW51bWVyYXRpb24gKHN0cmluZylcclxuICAgIC8vIEBwdWJsaWMge1Byb3BlcnR5LjxzdHJpbmc+fSAtICdQT1NJVElWRScgb3IgJ05FR0FUSVZFJ1xyXG4gICAgLy8gVE9ETzogdXNlIEVudW1lcmF0aW9uRGVwcmVjYXRlZFByb3BlcnR5XHJcbiAgICB0aGlzLnBvbGFyaXR5UHJvcGVydHkgPSBuZXcgUHJvcGVydHkoIENhcGFjaXRvckNvbnN0YW50cy5QT0xBUklUWS5QT1NJVElWRSwge1xyXG4gICAgICB2YWxpZFZhbHVlczogQ2FwYWNpdG9yQ29uc3RhbnRzLlBPTEFSSVRZLlZBTFVFUyxcclxuICAgICAgdGFuZGVtOiB0YW5kZW0uY3JlYXRlVGFuZGVtKCAncG9sYXJpdHlQcm9wZXJ0eScgKSxcclxuICAgICAgcGhldGlvVmFsdWVUeXBlOiBFbnVtZXJhdGlvbklPKCBDYXBhY2l0b3JDb25zdGFudHMuUE9MQVJJVFkgKVxyXG4gICAgfSApO1xyXG5cclxuXHJcbiAgICAvLyBAcHVibGljIHtEaW1lbnNpb24yfVxyXG4gICAgdGhpcy5wb3NpdGl2ZVRlcm1pbmFsRWxsaXBzZVNpemUgPSBQT1NJVElWRV9URVJNSU5BTF9FTExJUFNFX1NJWkU7XHJcbiAgICB0aGlzLm5lZ2F0aXZlVGVybWluYWxFbGxpcHNlU2l6ZSA9IE5FR0FUSVZFX1RFUk1JTkFMX0VMTElQU0VfU0laRTtcclxuXHJcbiAgICAvLyBAcHVibGljIHtudW1iZXJ9XHJcbiAgICB0aGlzLnBvc2l0aXZlVGVybWluYWxDeWxpbmRlckhlaWdodCA9IFBPU0lUSVZFX1RFUk1JTkFMX0NZTElOREVSX0hFSUdIVDtcclxuXHJcbiAgICAvLyBAcHVibGljIHtWZWN0b3IzfVxyXG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uOyAvLyBAcHVibGljIChyZWFkLW9ubHkpXHJcbiAgICB0aGlzLnNoYXBlQ3JlYXRvciA9IG5ldyBCYXR0ZXJ5U2hhcGVDcmVhdG9yKCB0aGlzLCBtb2RlbFZpZXdUcmFuc2Zvcm0gKTsgLy8gQHByaXZhdGVcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7U2hhcGV9XHJcbiAgICB0aGlzLnBvc2l0aXZlVGVybWluYWxTaGFwZSA9IHRoaXMuc2hhcGVDcmVhdG9yLmNyZWF0ZVBvc2l0aXZlVGVybWluYWxTaGFwZSgpO1xyXG4gICAgdGhpcy5uZWdhdGl2ZVRlcm1pbmFsU2hhcGUgPSB0aGlzLnNoYXBlQ3JlYXRvci5jcmVhdGVOZWdhdGl2ZVRlcm1pbmFsU2hhcGUoKTtcclxuXHJcbiAgICB0aGlzLnZvbHRhZ2VQcm9wZXJ0eS5saW5rKCAoKSA9PiB7XHJcbiAgICAgIHRoaXMucG9sYXJpdHlQcm9wZXJ0eS5zZXQoIHRoaXMuZ2V0UG9sYXJpdHkoIHRoaXMudm9sdGFnZVByb3BlcnR5LnZhbHVlICkgKTtcclxuICAgIH0gKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgdGhlIHBvbGFyaXR5IGZyb20gdGhlIG9iamVjdCBsaXRlcmFsIGJhc2VkIG9uIHRoZSB2b2x0YWdlLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdGFnZVxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0UG9sYXJpdHkoIHZvbHRhZ2UgKSB7XHJcbiAgICByZXR1cm4gKCB2b2x0YWdlID49IDAgKSA/IENhcGFjaXRvckNvbnN0YW50cy5QT0xBUklUWS5QT1NJVElWRSA6IENhcGFjaXRvckNvbnN0YW50cy5QT0xBUklUWS5ORUdBVElWRTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZSBpZiB0aGUgcHJvYmUgdGlwIHNoYXBlIGNvbnRhY3RzIGEgYmF0dGVyeSB0ZXJtaW5hbC5cclxuICAgKiBTaW5jZSB0aGUgYm90dG9tIHRlcm1pbmFsIGlzIGhpZGRlbiBpbiB0aGUgM0QgcGVyc3BlY3RpdmUsIHRoZXJlIGlzIG9ubHlcclxuICAgKiBvbmUgY29udGFjdCByZWdpb24gdG8gY2hlY2ssIHdoaWNoIGlzIHRoZSB0b3AgdGVybWluYWwuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaGFwZX0gcHJvYmUgLSB2b2x0bWV0ZXIgcHJvYmUgdGlwIHNoYXBlXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgY29udGFjdHMoIHByb2JlICkge1xyXG4gICAgbGV0IHNoYXBlO1xyXG4gICAgaWYgKCB0aGlzLnBvbGFyaXR5UHJvcGVydHkudmFsdWUgPT09IENhcGFjaXRvckNvbnN0YW50cy5QT0xBUklUWS5QT1NJVElWRSApIHtcclxuICAgICAgc2hhcGUgPSB0aGlzLnBvc2l0aXZlVGVybWluYWxTaGFwZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBzaGFwZSA9IHRoaXMubmVnYXRpdmVUZXJtaW5hbFNoYXBlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb2JlLmJvdW5kcy5pbnRlcnNlY3RzQm91bmRzKCBzaGFwZS5ib3VuZHMgKSAmJlxyXG4gICAgICAgICAgIHByb2JlLnNoYXBlSW50ZXJzZWN0aW9uKCBzaGFwZSApLmdldE5vbm92ZXJsYXBwaW5nQXJlYSgpID4gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIG9mZnNldCBvZiB0aGUgYm90dG9tIHRlcm1pbmFsIGZyb20gdGhlIGJhdHRlcnkncyBvcmlnaW4sIGluIG1vZGVsIGNvb3JkaW5hdGVzIChtZXRlcnMpLlxyXG4gICAqIFdlIGRvbid0IG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvbGFyaXR5IHNpbmNlIHRoZSBib3R0b20gdGVybWluYWwgaXMgbmV2ZXIgdmlzaWJsZS5cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldEJvdHRvbVRlcm1pbmFsWU9mZnNldCgpIHtcclxuICAgIHJldHVybiBCT0RZX1NJWkUuaGVpZ2h0IC8gMjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIG9mZnNldCBvZiB0aGUgdG9wIHRlcm1pbmFsIGZyb20gdGhlIGJhdHRlcnkncyBvcmlnaW4sIGluIG1vZGVsIGNvb3JkaW5hdGVzIChtZXRlcnMpLlxyXG4gICAqIFRoaXMgb2Zmc2V0IGRlcGVuZHMgb24gdGhlIHBvbGFyaXR5LlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0VG9wVGVybWluYWxZT2Zmc2V0KCkge1xyXG4gICAgaWYgKCB0aGlzLnBvbGFyaXR5UHJvcGVydHkudmFsdWUgPT09IENhcGFjaXRvckNvbnN0YW50cy5QT0xBUklUWS5QT1NJVElWRSApIHtcclxuICAgICAgcmV0dXJuIFBPU0lUSVZFX1RFUk1JTkFMX1lfT0ZGU0VUO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldHVybiBORUdBVElWRV9URVJNSU5BTF9ZX09GRlNFVDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEBwdWJsaWNcclxuICByZXNldCgpIHtcclxuICAgIHRoaXMudm9sdGFnZVByb3BlcnR5LnJlc2V0KCk7XHJcbiAgICB0aGlzLnBvbGFyaXR5UHJvcGVydHkucmVzZXQoKTtcclxuICB9XHJcbn1cclxuXHJcbmNhcGFjaXRvckxhYkJhc2ljcy5yZWdpc3RlciggJ0JhdHRlcnknLCBCYXR0ZXJ5ICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCYXR0ZXJ5O1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGNBQWMsTUFBTSx1Q0FBdUM7QUFDbEUsT0FBT0MsUUFBUSxNQUFNLGlDQUFp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