// Copyright 2015-2022, University of Colorado Boulder

/**
 * Wire that connects a probe to the body of a meter. The wire is a cubic curve.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import Vector2 from '../../../../../dot/js/Vector2.js';
import { Shape } from '../../../../../kite/js/imports.js';
import PhetColorScheme from '../../../../../scenery-phet/js/PhetColorScheme.js';
import { Path } from '../../../../../scenery/js/imports.js';
import capacitorLabBasics from '../../../capacitorLabBasics.js';

// constants
// wire is a cubic curve, these are the control point offsets
const BODY_CONTROL_POINT_OFFSET = new Vector2(0, 100);
const PROBE_CONTROL_POINT_OFFSET = new Vector2(-80, 100);
const POSITIVE_WIRE_COLOR = PhetColorScheme.RED_COLORBLIND;
const NEGATIVE_WIRE_COLOR = 'black';
class ProbeWireNode extends Path {
  /**
   * @param {VoltmeterBodyNode} bodyNode
   * @param {VoltmeterProbeNode} probeNode
   * @param {boolean} isPositive
   */
  constructor(bodyNode, probeNode, isPositive) {
    // supertype constructor with lazily passed wire shape.
    super(null, {
      stroke: isPositive ? POSITIVE_WIRE_COLOR : NEGATIVE_WIRE_COLOR,
      lineWidth: 3
    });

    // @private {VoltmeterBodyNode}
    this.bodyNode = bodyNode;

    // @private {VoltmeterProbeNode}
    this.probeNode = probeNode;

    // @private {Vector2}
    this.bodyControlPointOffset = BODY_CONTROL_POINT_OFFSET;
    this.probeControlPointOffset = PROBE_CONTROL_POINT_OFFSET;

    // @private {Vector2}
    this.bodyConnectionOffset = isPositive ? bodyNode.positiveConnectionOffset : bodyNode.negativeConnectionOffset;
    this.probeConnectionOffset = probeNode.connectionOffset;

    // update wire when body or probe moves
    probeNode.positionProperty.link(position => {
      this.update();
    });
    bodyNode.bodyPositionProperty.link(position => {
      this.update();
    });
  }

  /**
   * Update the wire path.
   * @public
   */
  update() {
    const pBody = this.getConnectionPoint(this.bodyNode, this.bodyConnectionOffset);
    const pProbe = this.getConnectionPoint(this.probeNode, this.probeConnectionOffset);

    // control points
    const ctrl1 = new Vector2(pBody.x + this.bodyControlPointOffset.x, pBody.y + this.bodyControlPointOffset.y);
    const ctrl2 = new Vector2(pProbe.x + this.probeControlPointOffset.x, pProbe.y + this.probeControlPointOffset.y);
    this.setShape(new Shape().moveToPoint(pBody).cubicCurveToPoint(ctrl1, ctrl2, pProbe));
  }

  /**
   * Get the connection point for either the voltmeter body or probe.  Adds the node position to the offset connection
   * point vector for a given node.
   * @public
   *
   * @param {VoltmeterBodyNode|VoltmeterProbeNode} node
   * @param {Vector2} connectionOffset
   * @returns {Vector2}
   */
  getConnectionPoint(node, connectionOffset) {
    return node.translation.plus(connectionOffset);
  }
}
capacitorLabBasics.register('ProbeWireNode', ProbeWireNode);
export default ProbeWireNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiU2hhcGUiLCJQaGV0Q29sb3JTY2hlbWUiLCJQYXRoIiwiY2FwYWNpdG9yTGFiQmFzaWNzIiwiQk9EWV9DT05UUk9MX1BPSU5UX09GRlNFVCIsIlBST0JFX0NPTlRST0xfUE9JTlRfT0ZGU0VUIiwiUE9TSVRJVkVfV0lSRV9DT0xPUiIsIlJFRF9DT0xPUkJMSU5EIiwiTkVHQVRJVkVfV0lSRV9DT0xPUiIsIlByb2JlV2lyZU5vZGUiLCJjb25zdHJ1Y3RvciIsImJvZHlOb2RlIiwicHJvYmVOb2RlIiwiaXNQb3NpdGl2ZSIsInN0cm9rZSIsImxpbmVXaWR0aCIsImJvZHlDb250cm9sUG9pbnRPZmZzZXQiLCJwcm9iZUNvbnRyb2xQb2ludE9mZnNldCIsImJvZHlDb25uZWN0aW9uT2Zmc2V0IiwicG9zaXRpdmVDb25uZWN0aW9uT2Zmc2V0IiwibmVnYXRpdmVDb25uZWN0aW9uT2Zmc2V0IiwicHJvYmVDb25uZWN0aW9uT2Zmc2V0IiwiY29ubmVjdGlvbk9mZnNldCIsInBvc2l0aW9uUHJvcGVydHkiLCJsaW5rIiwicG9zaXRpb24iLCJ1cGRhdGUiLCJib2R5UG9zaXRpb25Qcm9wZXJ0eSIsInBCb2R5IiwiZ2V0Q29ubmVjdGlvblBvaW50IiwicFByb2JlIiwiY3RybDEiLCJ4IiwieSIsImN0cmwyIiwic2V0U2hhcGUiLCJtb3ZlVG9Qb2ludCIsImN1YmljQ3VydmVUb1BvaW50Iiwibm9kZSIsInRyYW5zbGF0aW9uIiwicGx1cyIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiUHJvYmVXaXJlTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNS0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBXaXJlIHRoYXQgY29ubmVjdHMgYSBwcm9iZSB0byB0aGUgYm9keSBvZiBhIG1ldGVyLiBUaGUgd2lyZSBpcyBhIGN1YmljIGN1cnZlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIENocmlzIE1hbGxleSAoUGl4ZWxab29tLCBJbmMuKVxyXG4gKiBAYXV0aG9yIEplc3NlIEdyZWVuYmVyZyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IFBoZXRDb2xvclNjaGVtZSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvUGhldENvbG9yU2NoZW1lLmpzJztcclxuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBjYXBhY2l0b3JMYWJCYXNpY3MgZnJvbSAnLi4vLi4vLi4vY2FwYWNpdG9yTGFiQmFzaWNzLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG4vLyB3aXJlIGlzIGEgY3ViaWMgY3VydmUsIHRoZXNlIGFyZSB0aGUgY29udHJvbCBwb2ludCBvZmZzZXRzXHJcbmNvbnN0IEJPRFlfQ09OVFJPTF9QT0lOVF9PRkZTRVQgPSBuZXcgVmVjdG9yMiggMCwgMTAwICk7XHJcbmNvbnN0IFBST0JFX0NPTlRST0xfUE9JTlRfT0ZGU0VUID0gbmV3IFZlY3RvcjIoIC04MCwgMTAwICk7XHJcbmNvbnN0IFBPU0lUSVZFX1dJUkVfQ09MT1IgPSBQaGV0Q29sb3JTY2hlbWUuUkVEX0NPTE9SQkxJTkQ7XHJcbmNvbnN0IE5FR0FUSVZFX1dJUkVfQ09MT1IgPSAnYmxhY2snO1xyXG5cclxuY2xhc3MgUHJvYmVXaXJlTm9kZSBleHRlbmRzIFBhdGgge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Vm9sdG1ldGVyQm9keU5vZGV9IGJvZHlOb2RlXHJcbiAgICogQHBhcmFtIHtWb2x0bWV0ZXJQcm9iZU5vZGV9IHByb2JlTm9kZVxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQb3NpdGl2ZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBib2R5Tm9kZSwgcHJvYmVOb2RlLCBpc1Bvc2l0aXZlICkge1xyXG5cclxuICAgIC8vIHN1cGVydHlwZSBjb25zdHJ1Y3RvciB3aXRoIGxhemlseSBwYXNzZWQgd2lyZSBzaGFwZS5cclxuICAgIHN1cGVyKCBudWxsLCB7XHJcbiAgICAgIHN0cm9rZTogaXNQb3NpdGl2ZSA/IFBPU0lUSVZFX1dJUkVfQ09MT1IgOiBORUdBVElWRV9XSVJFX0NPTE9SLFxyXG4gICAgICBsaW5lV2lkdGg6IDNcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7Vm9sdG1ldGVyQm9keU5vZGV9XHJcbiAgICB0aGlzLmJvZHlOb2RlID0gYm9keU5vZGU7XHJcblxyXG4gICAgLy8gQHByaXZhdGUge1ZvbHRtZXRlclByb2JlTm9kZX1cclxuICAgIHRoaXMucHJvYmVOb2RlID0gcHJvYmVOb2RlO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtWZWN0b3IyfVxyXG4gICAgdGhpcy5ib2R5Q29udHJvbFBvaW50T2Zmc2V0ID0gQk9EWV9DT05UUk9MX1BPSU5UX09GRlNFVDtcclxuICAgIHRoaXMucHJvYmVDb250cm9sUG9pbnRPZmZzZXQgPSBQUk9CRV9DT05UUk9MX1BPSU5UX09GRlNFVDtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7VmVjdG9yMn1cclxuICAgIHRoaXMuYm9keUNvbm5lY3Rpb25PZmZzZXQgPSBpc1Bvc2l0aXZlID8gYm9keU5vZGUucG9zaXRpdmVDb25uZWN0aW9uT2Zmc2V0IDogYm9keU5vZGUubmVnYXRpdmVDb25uZWN0aW9uT2Zmc2V0O1xyXG4gICAgdGhpcy5wcm9iZUNvbm5lY3Rpb25PZmZzZXQgPSBwcm9iZU5vZGUuY29ubmVjdGlvbk9mZnNldDtcclxuXHJcblxyXG4gICAgLy8gdXBkYXRlIHdpcmUgd2hlbiBib2R5IG9yIHByb2JlIG1vdmVzXHJcbiAgICBwcm9iZU5vZGUucG9zaXRpb25Qcm9wZXJ0eS5saW5rKCBwb3NpdGlvbiA9PiB7XHJcbiAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgYm9keU5vZGUuYm9keVBvc2l0aW9uUHJvcGVydHkubGluayggcG9zaXRpb24gPT4ge1xyXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgd2lyZSBwYXRoLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICB1cGRhdGUoKSB7XHJcblxyXG4gICAgY29uc3QgcEJvZHkgPSB0aGlzLmdldENvbm5lY3Rpb25Qb2ludCggdGhpcy5ib2R5Tm9kZSwgdGhpcy5ib2R5Q29ubmVjdGlvbk9mZnNldCApO1xyXG4gICAgY29uc3QgcFByb2JlID0gdGhpcy5nZXRDb25uZWN0aW9uUG9pbnQoIHRoaXMucHJvYmVOb2RlLCB0aGlzLnByb2JlQ29ubmVjdGlvbk9mZnNldCApO1xyXG5cclxuICAgIC8vIGNvbnRyb2wgcG9pbnRzXHJcbiAgICBjb25zdCBjdHJsMSA9IG5ldyBWZWN0b3IyKCBwQm9keS54ICsgdGhpcy5ib2R5Q29udHJvbFBvaW50T2Zmc2V0LngsIHBCb2R5LnkgKyB0aGlzLmJvZHlDb250cm9sUG9pbnRPZmZzZXQueSApO1xyXG4gICAgY29uc3QgY3RybDIgPSBuZXcgVmVjdG9yMiggcFByb2JlLnggKyB0aGlzLnByb2JlQ29udHJvbFBvaW50T2Zmc2V0LngsIHBQcm9iZS55ICsgdGhpcy5wcm9iZUNvbnRyb2xQb2ludE9mZnNldC55ICk7XHJcblxyXG4gICAgdGhpcy5zZXRTaGFwZSggbmV3IFNoYXBlKCkubW92ZVRvUG9pbnQoIHBCb2R5ICkuY3ViaWNDdXJ2ZVRvUG9pbnQoIGN0cmwxLCBjdHJsMiwgcFByb2JlICkgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29ubmVjdGlvbiBwb2ludCBmb3IgZWl0aGVyIHRoZSB2b2x0bWV0ZXIgYm9keSBvciBwcm9iZS4gIEFkZHMgdGhlIG5vZGUgcG9zaXRpb24gdG8gdGhlIG9mZnNldCBjb25uZWN0aW9uXHJcbiAgICogcG9pbnQgdmVjdG9yIGZvciBhIGdpdmVuIG5vZGUuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWb2x0bWV0ZXJCb2R5Tm9kZXxWb2x0bWV0ZXJQcm9iZU5vZGV9IG5vZGVcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IGNvbm5lY3Rpb25PZmZzZXRcclxuICAgKiBAcmV0dXJucyB7VmVjdG9yMn1cclxuICAgKi9cclxuICBnZXRDb25uZWN0aW9uUG9pbnQoIG5vZGUsIGNvbm5lY3Rpb25PZmZzZXQgKSB7XHJcbiAgICByZXR1cm4gbm9kZS50cmFuc2xhdGlvbi5wbHVzKCBjb25uZWN0aW9uT2Zmc2V0ICk7XHJcbiAgfVxyXG59XHJcblxyXG5jYXBhY2l0b3JMYWJCYXNpY3MucmVnaXN0ZXIoICdQcm9iZVdpcmVOb2RlJywgUHJvYmVXaXJlTm9kZSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUHJvYmVXaXJlTm9kZTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFNLGtDQUFrQztBQUN0RCxTQUFTQyxLQUFLLFFBQVEsbUNBQW1DO0FBQ3pELE9BQU9DLGVBQWUsTUFBTSxtREFBbUQ7QUFDL0UsU0FBU0MsSUFBSSxRQUFRLHNDQUFzQztBQUMzRCxPQUFPQyxrQkFBa0IsTUFBTSxnQ0FBZ0M7O0FBRS9EO0FBQ0E7QUFDQSxNQUFNQyx5QkFBeUIsR0FBRyxJQUFJTCxPQUFPLENBQUUsQ0FBQyxFQUFFLEdBQUksQ0FBQztBQUN2RCxNQUFNTSwwQkFBMEIsR0FBRyxJQUFJTixPQUFPLENBQUUsQ0FBQyxFQUFFLEVBQUUsR0FBSSxDQUFDO0FBQzFELE1BQU1PLG1CQUFtQixHQUFHTCxlQUFlLENBQUNNLGNBQWM7QUFDMUQsTUFBTUMsbUJBQW1CLEdBQUcsT0FBTztBQUVuQyxN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