// Copyright 2015-2023, University of Colorado Boulder

/**
 * Visual representation of a switch.  A switch consists of a line that connects a hinge point and at least two other
 * connection points.
 *
 * @author Jesse Greenberg (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import PhetColorScheme from '../../../../scenery-phet/js/PhetColorScheme.js';
import ShadedSphereNode from '../../../../scenery-phet/js/ShadedSphereNode.js';
import { Circle, Image, Node } from '../../../../scenery/js/imports.js';
import switchCueArrow_png from '../../../images/switchCueArrow_png.js';
import capacitorLabBasics from '../../capacitorLabBasics.js';
import CLBConstants from '../CLBConstants.js';
import CircuitState from '../model/CircuitState.js';
import ConnectionNode from './ConnectionNode.js';
import CircuitSwitchDragHandler from './drag/CircuitSwitchDragHandler.js';
import HingePointNode from './HingePointNode.js';
import WireNode from './WireNode.js';

// Images

// Constants
const SWITCH_CUE_ARROW_WIDTH = 25;
const SWITCH_CUE_ARROW_OFFSET = new Vector2(-80, -250); // View coords

class SwitchNode extends Node {
  /**
   * @param {CircuitSwitch} circuitSwitch
   * @param {YawPitchModelViewTransform3} modelViewTransform
   * @param {Property.<boolean>} switchLockedProperty
   * @param {Tandem} tandem
   */
  constructor(circuitSwitch, modelViewTransform, switchLockedProperty, tandem) {
    assert && assert(circuitSwitch.connections.length === 2 || circuitSwitch.connections.length === 3, 'circuitSwitch should have 2 or three connections only');
    super({
      tandem: tandem
    });

    // @public {CircuitSwitch}
    this.circuitSwitch = circuitSwitch;

    // @private {YawPitchModelViewTransform3}
    this.modelViewTransform = modelViewTransform;

    // @private {WireNode}
    this.wireSwitchNode = new WireNode(circuitSwitch.switchWire, tandem.createTandem('wireSwitchNode'));
    this.wireSwitchNode.cursor = 'pointer';

    // add a shaded sphere to the end of the wire node to represent a connection point at the end of the switch.
    const shadedSphereNode = new ShadedSphereNode(2 * CLBConstants.CONNECTION_POINT_RADIUS); // Diameter

    // Dashed circle on tip of switch used as a contact indicator
    const tipCircle = new Circle(CLBConstants.CONNECTION_POINT_RADIUS, {
      lineWidth: 2,
      lineDash: [3, 3],
      stroke: PhetColorScheme.RED_COLORBLIND
    });
    const endPoint = circuitSwitch.switchSegment.endPointProperty.value;
    shadedSphereNode.translation = modelViewTransform.modelToViewPosition(endPoint);
    this.wireSwitchNode.addChild(shadedSphereNode);
    tipCircle.translation = modelViewTransform.modelToViewPosition(endPoint);
    this.wireSwitchNode.addChild(tipCircle);

    // add the hinge
    const hingeNode = new HingePointNode();
    hingeNode.translation = modelViewTransform.modelToViewPosition(circuitSwitch.hingePoint);

    // @public {Node} create connection points and clickable areas
    this.connectionAreaNodes = [];
    const userControlledProperty = new BooleanProperty(false);
    userControlledProperty.link(controlled => {
      tipCircle.fill = controlled ? 'yellow' : null;
    });
    const dragHandler = new CircuitSwitchDragHandler(this, switchLockedProperty, userControlledProperty, tandem.createTandem('dragListener'));

    // prefixes for tandem IDs
    const connectionLabels = ['battery', 'open', 'lightBulb'];
    circuitSwitch.connections.forEach((connection, index) => {
      const connectionTandem = tandem.createTandem(`${connectionLabels[index]}ConnectionNode`);

      // add the clickable area for the connection point
      this.connectionAreaNodes.push(new ConnectionNode(connection, circuitSwitch, modelViewTransform, connectionTandem, dragHandler, switchLockedProperty));
    });
    circuitSwitch.angleProperty.link(angle => {
      // Endpoint, hinge point, and a vector between them
      const hingePoint = circuitSwitch.switchSegment.hingePoint;
      const delta = Vector2.createPolar(CLBConstants.SWITCH_WIRE_LENGTH, angle).toVector3();

      // Make sure that the shaded sphere snaps to the correct position when connection property changes.
      shadedSphereNode.translation = modelViewTransform.modelToViewPosition(hingePoint.plus(delta));
      tipCircle.translation = modelViewTransform.modelToViewPosition(hingePoint.plus(delta));
    });

    // Circuit connection change listener
    circuitSwitch.circuitConnectionProperty.link(circuitConnection => {
      // Solder joint visibility
      if (circuitConnection === CircuitState.SWITCH_IN_TRANSIT || circuitConnection === CircuitState.OPEN_CIRCUIT) {
        shadedSphereNode.setVisible(false);
        tipCircle.radius = CLBConstants.CONNECTION_POINT_RADIUS;
      } else {
        shadedSphereNode.setVisible(true);
        tipCircle.radius = CLBConstants.CONNECTION_POINT_RADIUS;
      }

      // Connection circle color
      if (circuitConnection === CircuitState.SWITCH_IN_TRANSIT) {
        tipCircle.stroke = PhetColorScheme.RED_COLORBLIND;
      } else {
        tipCircle.stroke = 'rgb(0,0,0)'; // black when not in transit
      }
    });

    // Add arrow for a visual cue
    const switchCueArrow = new Image(switchCueArrow_png);
    switchCueArrow.scale(SWITCH_CUE_ARROW_WIDTH / switchCueArrow.bounds.height);
    switchCueArrow.leftTop = this.wireSwitchNode.center;

    // Reflect bottom arrow about the horizontal axis.
    const segment = circuitSwitch.switchSegment;
    if (segment.endPointProperty.value.y > segment.hingePoint.y) {
      switchCueArrow.scale(1, -1);
    }

    // Since the y-coordinate for the bottom switch is now inverted, a single translation
    // offset conveniently moves the top arrow up and the bottom arrow down.
    switchCueArrow.translate(SWITCH_CUE_ARROW_OFFSET);

    // @public {Image}
    this.switchCueArrow = switchCueArrow;
    this.addChild(switchCueArrow);

    // rendering order important for behavior of click areas and drag handlers
    _.each(this.connectionAreaNodes, connectionAreaNode => {
      this.addChild(connectionAreaNode.backStrokeNode);
    });
    this.addChild(this.wireSwitchNode);
    this.addChild(hingeNode);
    _.each(this.connectionAreaNodes, connectionAreaNode => {
      this.addChild(connectionAreaNode.highlightNode);
    });
  }
}
capacitorLabBasics.register('SwitchNode', SwitchNode);
export default SwitchNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJWZWN0b3IyIiwiUGhldENvbG9yU2NoZW1lIiwiU2hhZGVkU3BoZXJlTm9kZSIsIkNpcmNsZSIsIkltYWdlIiwiTm9kZSIsInN3aXRjaEN1ZUFycm93X3BuZyIsImNhcGFjaXRvckxhYkJhc2ljcyIsIkNMQkNvbnN0YW50cyIsIkNpcmN1aXRTdGF0ZSIsIkNvbm5lY3Rpb25Ob2RlIiwiQ2lyY3VpdFN3aXRjaERyYWdIYW5kbGVyIiwiSGluZ2VQb2ludE5vZGUiLCJXaXJlTm9kZSIsIlNXSVRDSF9DVUVfQVJST1dfV0lEVEgiLCJTV0lUQ0hfQ1VFX0FSUk9XX09GRlNFVCIsIlN3aXRjaE5vZGUiLCJjb25zdHJ1Y3RvciIsImNpcmN1aXRTd2l0Y2giLCJtb2RlbFZpZXdUcmFuc2Zvcm0iLCJzd2l0Y2hMb2NrZWRQcm9wZXJ0eSIsInRhbmRlbSIsImFzc2VydCIsImNvbm5lY3Rpb25zIiwibGVuZ3RoIiwid2lyZVN3aXRjaE5vZGUiLCJzd2l0Y2hXaXJlIiwiY3JlYXRlVGFuZGVtIiwiY3Vyc29yIiwic2hhZGVkU3BoZXJlTm9kZSIsIkNPTk5FQ1RJT05fUE9JTlRfUkFESVVTIiwidGlwQ2lyY2xlIiwibGluZVdpZHRoIiwibGluZURhc2giLCJzdHJva2UiLCJSRURfQ09MT1JCTElORCIsImVuZFBvaW50Iiwic3dpdGNoU2VnbWVudCIsImVuZFBvaW50UHJvcGVydHkiLCJ2YWx1ZSIsInRyYW5zbGF0aW9uIiwibW9kZWxUb1ZpZXdQb3NpdGlvbiIsImFkZENoaWxkIiwiaGluZ2VOb2RlIiwiaGluZ2VQb2ludCIsImNvbm5lY3Rpb25BcmVhTm9kZXMiLCJ1c2VyQ29udHJvbGxlZFByb3BlcnR5IiwibGluayIsImNvbnRyb2xsZWQiLCJmaWxsIiwiZHJhZ0hhbmRsZXIiLCJjb25uZWN0aW9uTGFiZWxzIiwiZm9yRWFjaCIsImNvbm5lY3Rpb24iLCJpbmRleCIsImNvbm5lY3Rpb25UYW5kZW0iLCJwdXNoIiwiYW5nbGVQcm9wZXJ0eSIsImFuZ2xlIiwiZGVsdGEiLCJjcmVhdGVQb2xhciIsIlNXSVRDSF9XSVJFX0xFTkdUSCIsInRvVmVjdG9yMyIsInBsdXMiLCJjaXJjdWl0Q29ubmVjdGlvblByb3BlcnR5IiwiY2lyY3VpdENvbm5lY3Rpb24iLCJTV0lUQ0hfSU5fVFJBTlNJVCIsIk9QRU5fQ0lSQ1VJVCIsInNldFZpc2libGUiLCJyYWRpdXMiLCJzd2l0Y2hDdWVBcnJvdyIsInNjYWxlIiwiYm91bmRzIiwiaGVpZ2h0IiwibGVmdFRvcCIsImNlbnRlciIsInNlZ21lbnQiLCJ5IiwidHJhbnNsYXRlIiwiXyIsImVhY2giLCJjb25uZWN0aW9uQXJlYU5vZGUiLCJiYWNrU3Ryb2tlTm9kZSIsImhpZ2hsaWdodE5vZGUiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlN3aXRjaE5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgc3dpdGNoLiAgQSBzd2l0Y2ggY29uc2lzdHMgb2YgYSBsaW5lIHRoYXQgY29ubmVjdHMgYSBoaW5nZSBwb2ludCBhbmQgYXQgbGVhc3QgdHdvIG90aGVyXHJcbiAqIGNvbm5lY3Rpb24gcG9pbnRzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEplc3NlIEdyZWVuYmVyZyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBBbmRyZXcgQWRhcmUgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IEJvb2xlYW5Qcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0Jvb2xlYW5Qcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IFBoZXRDb2xvclNjaGVtZSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvUGhldENvbG9yU2NoZW1lLmpzJztcclxuaW1wb3J0IFNoYWRlZFNwaGVyZU5vZGUgZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS1waGV0L2pzL1NoYWRlZFNwaGVyZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBDaXJjbGUsIEltYWdlLCBOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IHN3aXRjaEN1ZUFycm93X3BuZyBmcm9tICcuLi8uLi8uLi9pbWFnZXMvc3dpdGNoQ3VlQXJyb3dfcG5nLmpzJztcclxuaW1wb3J0IGNhcGFjaXRvckxhYkJhc2ljcyBmcm9tICcuLi8uLi9jYXBhY2l0b3JMYWJCYXNpY3MuanMnO1xyXG5pbXBvcnQgQ0xCQ29uc3RhbnRzIGZyb20gJy4uL0NMQkNvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBDaXJjdWl0U3RhdGUgZnJvbSAnLi4vbW9kZWwvQ2lyY3VpdFN0YXRlLmpzJztcclxuaW1wb3J0IENvbm5lY3Rpb25Ob2RlIGZyb20gJy4vQ29ubmVjdGlvbk5vZGUuanMnO1xyXG5pbXBvcnQgQ2lyY3VpdFN3aXRjaERyYWdIYW5kbGVyIGZyb20gJy4vZHJhZy9DaXJjdWl0U3dpdGNoRHJhZ0hhbmRsZXIuanMnO1xyXG5pbXBvcnQgSGluZ2VQb2ludE5vZGUgZnJvbSAnLi9IaW5nZVBvaW50Tm9kZS5qcyc7XHJcbmltcG9ydCBXaXJlTm9kZSBmcm9tICcuL1dpcmVOb2RlLmpzJztcclxuXHJcbi8vIEltYWdlc1xyXG5cclxuLy8gQ29uc3RhbnRzXHJcbmNvbnN0IFNXSVRDSF9DVUVfQVJST1dfV0lEVEggPSAyNTtcclxuY29uc3QgU1dJVENIX0NVRV9BUlJPV19PRkZTRVQgPSBuZXcgVmVjdG9yMiggLTgwLCAtMjUwICk7IC8vIFZpZXcgY29vcmRzXHJcblxyXG5jbGFzcyBTd2l0Y2hOb2RlIGV4dGVuZHMgTm9kZSB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtDaXJjdWl0U3dpdGNofSBjaXJjdWl0U3dpdGNoXHJcbiAgICogQHBhcmFtIHtZYXdQaXRjaE1vZGVsVmlld1RyYW5zZm9ybTN9IG1vZGVsVmlld1RyYW5zZm9ybVxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHkuPGJvb2xlYW4+fSBzd2l0Y2hMb2NrZWRQcm9wZXJ0eVxyXG4gICAqIEBwYXJhbSB7VGFuZGVtfSB0YW5kZW1cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggY2lyY3VpdFN3aXRjaCwgbW9kZWxWaWV3VHJhbnNmb3JtLCBzd2l0Y2hMb2NrZWRQcm9wZXJ0eSwgdGFuZGVtICkge1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGNpcmN1aXRTd2l0Y2guY29ubmVjdGlvbnMubGVuZ3RoID09PSAyIHx8IGNpcmN1aXRTd2l0Y2guY29ubmVjdGlvbnMubGVuZ3RoID09PSAzLFxyXG4gICAgICAnY2lyY3VpdFN3aXRjaCBzaG91bGQgaGF2ZSAyIG9yIHRocmVlIGNvbm5lY3Rpb25zIG9ubHknICk7XHJcblxyXG4gICAgc3VwZXIoIHsgdGFuZGVtOiB0YW5kZW0gfSApO1xyXG5cclxuICAgIC8vIEBwdWJsaWMge0NpcmN1aXRTd2l0Y2h9XHJcbiAgICB0aGlzLmNpcmN1aXRTd2l0Y2ggPSBjaXJjdWl0U3dpdGNoO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtZYXdQaXRjaE1vZGVsVmlld1RyYW5zZm9ybTN9XHJcbiAgICB0aGlzLm1vZGVsVmlld1RyYW5zZm9ybSA9IG1vZGVsVmlld1RyYW5zZm9ybTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7V2lyZU5vZGV9XHJcbiAgICB0aGlzLndpcmVTd2l0Y2hOb2RlID0gbmV3IFdpcmVOb2RlKCBjaXJjdWl0U3dpdGNoLnN3aXRjaFdpcmUsIHRhbmRlbS5jcmVhdGVUYW5kZW0oICd3aXJlU3dpdGNoTm9kZScgKSApO1xyXG4gICAgdGhpcy53aXJlU3dpdGNoTm9kZS5jdXJzb3IgPSAncG9pbnRlcic7XHJcblxyXG4gICAgLy8gYWRkIGEgc2hhZGVkIHNwaGVyZSB0byB0aGUgZW5kIG9mIHRoZSB3aXJlIG5vZGUgdG8gcmVwcmVzZW50IGEgY29ubmVjdGlvbiBwb2ludCBhdCB0aGUgZW5kIG9mIHRoZSBzd2l0Y2guXHJcbiAgICBjb25zdCBzaGFkZWRTcGhlcmVOb2RlID0gbmV3IFNoYWRlZFNwaGVyZU5vZGUoIDIgKiBDTEJDb25zdGFudHMuQ09OTkVDVElPTl9QT0lOVF9SQURJVVMgKTsgLy8gRGlhbWV0ZXJcclxuXHJcbiAgICAvLyBEYXNoZWQgY2lyY2xlIG9uIHRpcCBvZiBzd2l0Y2ggdXNlZCBhcyBhIGNvbnRhY3QgaW5kaWNhdG9yXHJcbiAgICBjb25zdCB0aXBDaXJjbGUgPSBuZXcgQ2lyY2xlKCBDTEJDb25zdGFudHMuQ09OTkVDVElPTl9QT0lOVF9SQURJVVMsIHtcclxuICAgICAgbGluZVdpZHRoOiAyLFxyXG4gICAgICBsaW5lRGFzaDogWyAzLCAzIF0sXHJcbiAgICAgIHN0cm9rZTogUGhldENvbG9yU2NoZW1lLlJFRF9DT0xPUkJMSU5EXHJcbiAgICB9ICk7XHJcblxyXG4gICAgY29uc3QgZW5kUG9pbnQgPSBjaXJjdWl0U3dpdGNoLnN3aXRjaFNlZ21lbnQuZW5kUG9pbnRQcm9wZXJ0eS52YWx1ZTtcclxuXHJcbiAgICBzaGFkZWRTcGhlcmVOb2RlLnRyYW5zbGF0aW9uID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3UG9zaXRpb24oIGVuZFBvaW50ICk7XHJcbiAgICB0aGlzLndpcmVTd2l0Y2hOb2RlLmFkZENoaWxkKCBzaGFkZWRTcGhlcmVOb2RlICk7XHJcblxyXG4gICAgdGlwQ2lyY2xlLnRyYW5zbGF0aW9uID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3UG9zaXRpb24oIGVuZFBvaW50ICk7XHJcbiAgICB0aGlzLndpcmVTd2l0Y2hOb2RlLmFkZENoaWxkKCB0aXBDaXJjbGUgKTtcclxuXHJcbiAgICAvLyBhZGQgdGhlIGhpbmdlXHJcbiAgICBjb25zdCBoaW5nZU5vZGUgPSBuZXcgSGluZ2VQb2ludE5vZGUoKTtcclxuICAgIGhpbmdlTm9kZS50cmFuc2xhdGlvbiA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1Bvc2l0aW9uKCBjaXJjdWl0U3dpdGNoLmhpbmdlUG9pbnQgKTtcclxuXHJcbiAgICAvLyBAcHVibGljIHtOb2RlfSBjcmVhdGUgY29ubmVjdGlvbiBwb2ludHMgYW5kIGNsaWNrYWJsZSBhcmVhc1xyXG4gICAgdGhpcy5jb25uZWN0aW9uQXJlYU5vZGVzID0gW107XHJcblxyXG4gICAgY29uc3QgdXNlckNvbnRyb2xsZWRQcm9wZXJ0eSA9IG5ldyBCb29sZWFuUHJvcGVydHkoIGZhbHNlICk7XHJcblxyXG4gICAgdXNlckNvbnRyb2xsZWRQcm9wZXJ0eS5saW5rKCBjb250cm9sbGVkID0+IHtcclxuICAgICAgdGlwQ2lyY2xlLmZpbGwgPSBjb250cm9sbGVkID8gJ3llbGxvdycgOiBudWxsO1xyXG4gICAgfSApO1xyXG5cclxuICAgIGNvbnN0IGRyYWdIYW5kbGVyID0gbmV3IENpcmN1aXRTd2l0Y2hEcmFnSGFuZGxlciggdGhpcywgc3dpdGNoTG9ja2VkUHJvcGVydHksIHVzZXJDb250cm9sbGVkUHJvcGVydHksIHRhbmRlbS5jcmVhdGVUYW5kZW0oICdkcmFnTGlzdGVuZXInICkgKTtcclxuXHJcbiAgICAvLyBwcmVmaXhlcyBmb3IgdGFuZGVtIElEc1xyXG4gICAgY29uc3QgY29ubmVjdGlvbkxhYmVscyA9IFsgJ2JhdHRlcnknLCAnb3BlbicsICdsaWdodEJ1bGInIF07XHJcblxyXG4gICAgY2lyY3VpdFN3aXRjaC5jb25uZWN0aW9ucy5mb3JFYWNoKCAoIGNvbm5lY3Rpb24sIGluZGV4ICkgPT4ge1xyXG4gICAgICBjb25zdCBjb25uZWN0aW9uVGFuZGVtID0gdGFuZGVtLmNyZWF0ZVRhbmRlbSggYCR7Y29ubmVjdGlvbkxhYmVsc1sgaW5kZXggXX1Db25uZWN0aW9uTm9kZWAgKTtcclxuXHJcbiAgICAgIC8vIGFkZCB0aGUgY2xpY2thYmxlIGFyZWEgZm9yIHRoZSBjb25uZWN0aW9uIHBvaW50XHJcbiAgICAgIHRoaXMuY29ubmVjdGlvbkFyZWFOb2Rlcy5wdXNoKCBuZXcgQ29ubmVjdGlvbk5vZGUoIGNvbm5lY3Rpb24sIGNpcmN1aXRTd2l0Y2gsIG1vZGVsVmlld1RyYW5zZm9ybSwgY29ubmVjdGlvblRhbmRlbSwgZHJhZ0hhbmRsZXIsIHN3aXRjaExvY2tlZFByb3BlcnR5ICkgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICBjaXJjdWl0U3dpdGNoLmFuZ2xlUHJvcGVydHkubGluayggYW5nbGUgPT4ge1xyXG5cclxuICAgICAgLy8gRW5kcG9pbnQsIGhpbmdlIHBvaW50LCBhbmQgYSB2ZWN0b3IgYmV0d2VlbiB0aGVtXHJcbiAgICAgIGNvbnN0IGhpbmdlUG9pbnQgPSBjaXJjdWl0U3dpdGNoLnN3aXRjaFNlZ21lbnQuaGluZ2VQb2ludDtcclxuICAgICAgY29uc3QgZGVsdGEgPSBWZWN0b3IyLmNyZWF0ZVBvbGFyKCBDTEJDb25zdGFudHMuU1dJVENIX1dJUkVfTEVOR1RILCBhbmdsZSApLnRvVmVjdG9yMygpO1xyXG5cclxuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHNoYWRlZCBzcGhlcmUgc25hcHMgdG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gd2hlbiBjb25uZWN0aW9uIHByb3BlcnR5IGNoYW5nZXMuXHJcbiAgICAgIHNoYWRlZFNwaGVyZU5vZGUudHJhbnNsYXRpb24gPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdQb3NpdGlvbiggaGluZ2VQb2ludC5wbHVzKCBkZWx0YSApICk7XHJcbiAgICAgIHRpcENpcmNsZS50cmFuc2xhdGlvbiA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1Bvc2l0aW9uKCBoaW5nZVBvaW50LnBsdXMoIGRlbHRhICkgKTtcclxuXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gQ2lyY3VpdCBjb25uZWN0aW9uIGNoYW5nZSBsaXN0ZW5lclxyXG4gICAgY2lyY3VpdFN3aXRjaC5jaXJjdWl0Q29ubmVjdGlvblByb3BlcnR5LmxpbmsoIGNpcmN1aXRDb25uZWN0aW9uID0+IHtcclxuXHJcbiAgICAgIC8vIFNvbGRlciBqb2ludCB2aXNpYmlsaXR5XHJcbiAgICAgIGlmICggY2lyY3VpdENvbm5lY3Rpb24gPT09IENpcmN1aXRTdGF0ZS5TV0lUQ0hfSU5fVFJBTlNJVCB8fFxyXG4gICAgICAgICAgIGNpcmN1aXRDb25uZWN0aW9uID09PSBDaXJjdWl0U3RhdGUuT1BFTl9DSVJDVUlUICkge1xyXG4gICAgICAgIHNoYWRlZFNwaGVyZU5vZGUuc2V0VmlzaWJsZSggZmFsc2UgKTtcclxuICAgICAgICB0aXBDaXJjbGUucmFkaXVzID0gQ0xCQ29uc3RhbnRzLkNPTk5FQ1RJT05fUE9JTlRfUkFESVVTO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHNoYWRlZFNwaGVyZU5vZGUuc2V0VmlzaWJsZSggdHJ1ZSApO1xyXG4gICAgICAgIHRpcENpcmNsZS5yYWRpdXMgPSBDTEJDb25zdGFudHMuQ09OTkVDVElPTl9QT0lOVF9SQURJVVM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbm5lY3Rpb24gY2lyY2xlIGNvbG9yXHJcbiAgICAgIGlmICggY2lyY3VpdENvbm5lY3Rpb24gPT09IENpcmN1aXRTdGF0ZS5TV0lUQ0hfSU5fVFJBTlNJVCApIHtcclxuICAgICAgICB0aXBDaXJjbGUuc3Ryb2tlID0gUGhldENvbG9yU2NoZW1lLlJFRF9DT0xPUkJMSU5EO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRpcENpcmNsZS5zdHJva2UgPSAncmdiKDAsMCwwKSc7IC8vIGJsYWNrIHdoZW4gbm90IGluIHRyYW5zaXRcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIEFkZCBhcnJvdyBmb3IgYSB2aXN1YWwgY3VlXHJcbiAgICBjb25zdCBzd2l0Y2hDdWVBcnJvdyA9IG5ldyBJbWFnZSggc3dpdGNoQ3VlQXJyb3dfcG5nICk7XHJcbiAgICBzd2l0Y2hDdWVBcnJvdy5zY2FsZSggU1dJVENIX0NVRV9BUlJPV19XSURUSCAvIHN3aXRjaEN1ZUFycm93LmJvdW5kcy5oZWlnaHQgKTtcclxuICAgIHN3aXRjaEN1ZUFycm93LmxlZnRUb3AgPSB0aGlzLndpcmVTd2l0Y2hOb2RlLmNlbnRlcjtcclxuXHJcbiAgICAvLyBSZWZsZWN0IGJvdHRvbSBhcnJvdyBhYm91dCB0aGUgaG9yaXpvbnRhbCBheGlzLlxyXG4gICAgY29uc3Qgc2VnbWVudCA9IGNpcmN1aXRTd2l0Y2guc3dpdGNoU2VnbWVudDtcclxuICAgIGlmICggc2VnbWVudC5lbmRQb2ludFByb3BlcnR5LnZhbHVlLnkgPiBzZWdtZW50LmhpbmdlUG9pbnQueSApIHtcclxuICAgICAgc3dpdGNoQ3VlQXJyb3cuc2NhbGUoIDEsIC0xICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2luY2UgdGhlIHktY29vcmRpbmF0ZSBmb3IgdGhlIGJvdHRvbSBzd2l0Y2ggaXMgbm93IGludmVydGVkLCBhIHNpbmdsZSB0cmFuc2xhdGlvblxyXG4gICAgLy8gb2Zmc2V0IGNvbnZlbmllbnRseSBtb3ZlcyB0aGUgdG9wIGFycm93IHVwIGFuZCB0aGUgYm90dG9tIGFycm93IGRvd24uXHJcbiAgICBzd2l0Y2hDdWVBcnJvdy50cmFuc2xhdGUoIFNXSVRDSF9DVUVfQVJST1dfT0ZGU0VUICk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyB7SW1hZ2V9XHJcbiAgICB0aGlzLnN3aXRjaEN1ZUFycm93ID0gc3dpdGNoQ3VlQXJyb3c7XHJcblxyXG4gICAgdGhpcy5hZGRDaGlsZCggc3dpdGNoQ3VlQXJyb3cgKTtcclxuXHJcbiAgICAvLyByZW5kZXJpbmcgb3JkZXIgaW1wb3J0YW50IGZvciBiZWhhdmlvciBvZiBjbGljayBhcmVhcyBhbmQgZHJhZyBoYW5kbGVyc1xyXG4gICAgXy5lYWNoKCB0aGlzLmNvbm5lY3Rpb25BcmVhTm9kZXMsIGNvbm5lY3Rpb25BcmVhTm9kZSA9PiB7XHJcbiAgICAgIHRoaXMuYWRkQ2hpbGQoIGNvbm5lY3Rpb25BcmVhTm9kZS5iYWNrU3Ryb2tlTm9kZSApO1xyXG4gICAgfSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggdGhpcy53aXJlU3dpdGNoTm9kZSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggaGluZ2VOb2RlICk7XHJcbiAgICBfLmVhY2goIHRoaXMuY29ubmVjdGlvbkFyZWFOb2RlcywgY29ubmVjdGlvbkFyZWFOb2RlID0+IHtcclxuICAgICAgdGhpcy5hZGRDaGlsZCggY29ubmVjdGlvbkFyZWFOb2RlLmhpZ2hsaWdodE5vZGUgKTtcclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcbmNhcGFjaXRvckxhYkJhc2ljcy5yZWdpc3RlciggJ1N3aXRjaE5vZGUnLCBTd2l0Y2hOb2RlICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTd2l0Y2hOb2RlOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsZUFBZSxNQUFNLHdDQUF3QztBQUNwRSxPQUFPQyxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLGVBQWUsTUFBTSxnREFBZ0Q7QUFDNUUsT0FBT0MsZ0JBQWdCLE1BQU0saURBQWlEO0FBQzlFLFNBQVNDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxJQUFJLFFBQVEsbUNBQW1DO0FBQ3ZFLE9BQU9DLGtCQUFrQixNQUFNLHVDQUF1QztBQUN0RSxPQUFPQyxrQkFBa0IsTUFBTSw2QkFBNkI7QUFDNUQsT0FBT0MsWUFBWSxNQUFNLG9CQUFvQjtBQUM3QyxPQUFPQyxZQUFZLE1BQU0sMEJBQTBCO0FBQ25ELE9BQU9DLGNBQWMsTUFBTSxxQkFBcUI7QUFDaEQsT0FBT0Msd0JBQXdCLE1BQU0sb0NBQW9DO0FBQ3pFLE9BQU9DLGNBQWMsTUFBTSxxQkFBcUI7QUFDaEQsT0FBT0MsUUFBUSxNQUFNLGVBQWU7O0FBRXBDOztBQUVBO0FBQ0EsTUFBTUMsc0JBQXNCLEdBQUcsRUFBRTtBQUNqQyxNQUFNQyx1QkFBdUIsR0FBRyxJQUFJZixP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