// Copyright 2015-2021, University of Colorado Boulder

/**
 * Drag handler for capacitor plate area property.
 * This drag handle is attached to the front-left corner of the capacitor plate, and its
 * drag axis is the diagonal line from the front-left corner to the back-right corner of the plate.
 *
 * Dragging on a diagonal is tricky; all computations are based on the x axis, ignoring other axes.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import LinearFunction from '../../../../../dot/js/LinearFunction.js';
import Utils from '../../../../../dot/js/Utils.js';
import Vector2 from '../../../../../dot/js/Vector2.js';
import { DragListener } from '../../../../../scenery/js/imports.js';
import capacitorLabBasics from '../../../capacitorLabBasics.js';
class PlateAreaDragHandler extends DragListener {
  /**
   * @param {Capacitor} capacitor
   * @param {CLModelViewTransform3D} modelViewTransform
   * @param {Range} valueRange
   * @param {Tandem} tandem
   */
  constructor(capacitor, modelViewTransform, valueRange, tandem) {
    super({
      allowTouchSnag: false,
      tandem: tandem,
      start: event => {
        const width = capacitor.plateSizeProperty.value.width;
        const pMouse = event.pointer.point;
        const pOrigin = modelViewTransform.modelToViewDeltaXYZ(width / 2, 0, width / 2);
        this.clickXOffset = pMouse.x - pOrigin.x;
      },
      drag: event => {
        const pMouse = event.pointer.point;
        const plateWidth = this.getPlateWidth(pMouse);

        // Discretize the plate area to round values by scaling m -> mm, rounding, then scaling back.
        // Plate area drags should then snap only in steps of 10 mm^2.
        const plateArea = Utils.roundSymmetric(1e5 * plateWidth * plateWidth) / 1e5;
        capacitor.setPlateWidth(Math.sqrt(plateArea));
      }
    });

    // @private
    this.modelViewTransform = modelViewTransform;
    this.valueRange = valueRange;

    // @private {Vector2}
    this.clickXOffset = new Vector2(0, 0);
  }

  /**
   * Determines the plateWidth for a specific mouse position.  This effectively accounts for the z-axis dimension.
   *
   * @param {Vector2} pMouse
   * return {number}
   * @public
   */
  getPlateWidth(pMouse) {
    // pick any 2 view values
    const xView1 = 0;
    const xView2 = 1;

    // compute corresponding model values
    const xModel1 = this.getModelX(pMouse, xView1);
    const xModel2 = this.getModelX(pMouse, xView2);
    const linearFunction = new LinearFunction(xView1, xView2, xModel1, xModel2);
    return Utils.clamp(linearFunction.inverse(0), this.valueRange.min, this.valueRange.max);
  }

  /**
   * Determines how far the mouse is from where we grabbed the arrow, for a hypothetical capacitor plate width.
   *
   * @param {Vector2} pMouse
   * @param {number} samplePlateWidth
   * @returns {number}
   * @public
   */
  getModelX(pMouse, samplePlateWidth) {
    const pBackRightCorner = this.modelViewTransform.modelToViewXYZ(samplePlateWidth / 2, 0, samplePlateWidth / 2);
    return pMouse.x - pBackRightCorner.x - this.clickXOffset;
  }
}
capacitorLabBasics.register('PlateAreaDragHandler', PlateAreaDragHandler);
export default PlateAreaDragHandler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJMaW5lYXJGdW5jdGlvbiIsIlV0aWxzIiwiVmVjdG9yMiIsIkRyYWdMaXN0ZW5lciIsImNhcGFjaXRvckxhYkJhc2ljcyIsIlBsYXRlQXJlYURyYWdIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJjYXBhY2l0b3IiLCJtb2RlbFZpZXdUcmFuc2Zvcm0iLCJ2YWx1ZVJhbmdlIiwidGFuZGVtIiwiYWxsb3dUb3VjaFNuYWciLCJzdGFydCIsImV2ZW50Iiwid2lkdGgiLCJwbGF0ZVNpemVQcm9wZXJ0eSIsInZhbHVlIiwicE1vdXNlIiwicG9pbnRlciIsInBvaW50IiwicE9yaWdpbiIsIm1vZGVsVG9WaWV3RGVsdGFYWVoiLCJjbGlja1hPZmZzZXQiLCJ4IiwiZHJhZyIsInBsYXRlV2lkdGgiLCJnZXRQbGF0ZVdpZHRoIiwicGxhdGVBcmVhIiwicm91bmRTeW1tZXRyaWMiLCJzZXRQbGF0ZVdpZHRoIiwiTWF0aCIsInNxcnQiLCJ4VmlldzEiLCJ4VmlldzIiLCJ4TW9kZWwxIiwiZ2V0TW9kZWxYIiwieE1vZGVsMiIsImxpbmVhckZ1bmN0aW9uIiwiY2xhbXAiLCJpbnZlcnNlIiwibWluIiwibWF4Iiwic2FtcGxlUGxhdGVXaWR0aCIsInBCYWNrUmlnaHRDb3JuZXIiLCJtb2RlbFRvVmlld1hZWiIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiUGxhdGVBcmVhRHJhZ0hhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUtMjAyMSwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogRHJhZyBoYW5kbGVyIGZvciBjYXBhY2l0b3IgcGxhdGUgYXJlYSBwcm9wZXJ0eS5cclxuICogVGhpcyBkcmFnIGhhbmRsZSBpcyBhdHRhY2hlZCB0byB0aGUgZnJvbnQtbGVmdCBjb3JuZXIgb2YgdGhlIGNhcGFjaXRvciBwbGF0ZSwgYW5kIGl0c1xyXG4gKiBkcmFnIGF4aXMgaXMgdGhlIGRpYWdvbmFsIGxpbmUgZnJvbSB0aGUgZnJvbnQtbGVmdCBjb3JuZXIgdG8gdGhlIGJhY2stcmlnaHQgY29ybmVyIG9mIHRoZSBwbGF0ZS5cclxuICpcclxuICogRHJhZ2dpbmcgb24gYSBkaWFnb25hbCBpcyB0cmlja3k7IGFsbCBjb21wdXRhdGlvbnMgYXJlIGJhc2VkIG9uIHRoZSB4IGF4aXMsIGlnbm9yaW5nIG90aGVyIGF4ZXMuXHJcbiAqXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqIEBhdXRob3IgSmVzc2UgR3JlZW5iZXJnIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCBMaW5lYXJGdW5jdGlvbiBmcm9tICcuLi8uLi8uLi8uLi8uLi9kb3QvanMvTGluZWFyRnVuY3Rpb24uanMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBEcmFnTGlzdGVuZXIgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgY2FwYWNpdG9yTGFiQmFzaWNzIGZyb20gJy4uLy4uLy4uL2NhcGFjaXRvckxhYkJhc2ljcy5qcyc7XHJcblxyXG5jbGFzcyBQbGF0ZUFyZWFEcmFnSGFuZGxlciBleHRlbmRzIERyYWdMaXN0ZW5lciB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtDYXBhY2l0b3J9IGNhcGFjaXRvclxyXG4gICAqIEBwYXJhbSB7Q0xNb2RlbFZpZXdUcmFuc2Zvcm0zRH0gbW9kZWxWaWV3VHJhbnNmb3JtXHJcbiAgICogQHBhcmFtIHtSYW5nZX0gdmFsdWVSYW5nZVxyXG4gICAqIEBwYXJhbSB7VGFuZGVtfSB0YW5kZW1cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggY2FwYWNpdG9yLCBtb2RlbFZpZXdUcmFuc2Zvcm0sIHZhbHVlUmFuZ2UsIHRhbmRlbSApIHtcclxuICAgIHN1cGVyKCB7XHJcbiAgICAgIGFsbG93VG91Y2hTbmFnOiBmYWxzZSxcclxuICAgICAgdGFuZGVtOiB0YW5kZW0sXHJcbiAgICAgIHN0YXJ0OiBldmVudCA9PiB7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBjYXBhY2l0b3IucGxhdGVTaXplUHJvcGVydHkudmFsdWUud2lkdGg7XHJcbiAgICAgICAgY29uc3QgcE1vdXNlID0gZXZlbnQucG9pbnRlci5wb2ludDtcclxuICAgICAgICBjb25zdCBwT3JpZ2luID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3RGVsdGFYWVooIHdpZHRoIC8gMiwgMCwgd2lkdGggLyAyICk7XHJcbiAgICAgICAgdGhpcy5jbGlja1hPZmZzZXQgPSBwTW91c2UueCAtIHBPcmlnaW4ueDtcclxuICAgICAgfSxcclxuICAgICAgZHJhZzogZXZlbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBNb3VzZSA9IGV2ZW50LnBvaW50ZXIucG9pbnQ7XHJcbiAgICAgICAgY29uc3QgcGxhdGVXaWR0aCA9IHRoaXMuZ2V0UGxhdGVXaWR0aCggcE1vdXNlICk7XHJcblxyXG4gICAgICAgIC8vIERpc2NyZXRpemUgdGhlIHBsYXRlIGFyZWEgdG8gcm91bmQgdmFsdWVzIGJ5IHNjYWxpbmcgbSAtPiBtbSwgcm91bmRpbmcsIHRoZW4gc2NhbGluZyBiYWNrLlxyXG4gICAgICAgIC8vIFBsYXRlIGFyZWEgZHJhZ3Mgc2hvdWxkIHRoZW4gc25hcCBvbmx5IGluIHN0ZXBzIG9mIDEwIG1tXjIuXHJcbiAgICAgICAgY29uc3QgcGxhdGVBcmVhID0gVXRpbHMucm91bmRTeW1tZXRyaWMoIDFlNSAqIHBsYXRlV2lkdGggKiBwbGF0ZVdpZHRoICkgLyAxZTU7XHJcbiAgICAgICAgY2FwYWNpdG9yLnNldFBsYXRlV2lkdGgoIE1hdGguc3FydCggcGxhdGVBcmVhICkgKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIEBwcml2YXRlXHJcbiAgICB0aGlzLm1vZGVsVmlld1RyYW5zZm9ybSA9IG1vZGVsVmlld1RyYW5zZm9ybTtcclxuICAgIHRoaXMudmFsdWVSYW5nZSA9IHZhbHVlUmFuZ2U7XHJcblxyXG4gICAgLy8gQHByaXZhdGUge1ZlY3RvcjJ9XHJcbiAgICB0aGlzLmNsaWNrWE9mZnNldCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHRoZSBwbGF0ZVdpZHRoIGZvciBhIHNwZWNpZmljIG1vdXNlIHBvc2l0aW9uLiAgVGhpcyBlZmZlY3RpdmVseSBhY2NvdW50cyBmb3IgdGhlIHotYXhpcyBkaW1lbnNpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHBNb3VzZVxyXG4gICAqIHJldHVybiB7bnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBnZXRQbGF0ZVdpZHRoKCBwTW91c2UgKSB7XHJcbiAgICAvLyBwaWNrIGFueSAyIHZpZXcgdmFsdWVzXHJcbiAgICBjb25zdCB4VmlldzEgPSAwO1xyXG4gICAgY29uc3QgeFZpZXcyID0gMTtcclxuXHJcbiAgICAvLyBjb21wdXRlIGNvcnJlc3BvbmRpbmcgbW9kZWwgdmFsdWVzXHJcbiAgICBjb25zdCB4TW9kZWwxID0gdGhpcy5nZXRNb2RlbFgoIHBNb3VzZSwgeFZpZXcxICk7XHJcbiAgICBjb25zdCB4TW9kZWwyID0gdGhpcy5nZXRNb2RlbFgoIHBNb3VzZSwgeFZpZXcyICk7XHJcblxyXG4gICAgY29uc3QgbGluZWFyRnVuY3Rpb24gPSBuZXcgTGluZWFyRnVuY3Rpb24oIHhWaWV3MSwgeFZpZXcyLCB4TW9kZWwxLCB4TW9kZWwyICk7XHJcbiAgICByZXR1cm4gVXRpbHMuY2xhbXAoIGxpbmVhckZ1bmN0aW9uLmludmVyc2UoIDAgKSwgdGhpcy52YWx1ZVJhbmdlLm1pbiwgdGhpcy52YWx1ZVJhbmdlLm1heCApO1xyXG5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgaG93IGZhciB0aGUgbW91c2UgaXMgZnJvbSB3aGVyZSB3ZSBncmFiYmVkIHRoZSBhcnJvdywgZm9yIGEgaHlwb3RoZXRpY2FsIGNhcGFjaXRvciBwbGF0ZSB3aWR0aC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gcE1vdXNlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZVBsYXRlV2lkdGhcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBnZXRNb2RlbFgoIHBNb3VzZSwgc2FtcGxlUGxhdGVXaWR0aCApIHtcclxuICAgIGNvbnN0IHBCYWNrUmlnaHRDb3JuZXIgPSB0aGlzLm1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1hZWiggc2FtcGxlUGxhdGVXaWR0aCAvIDIsIDAsIHNhbXBsZVBsYXRlV2lkdGggLyAyICk7XHJcbiAgICByZXR1cm4gcE1vdXNlLnggLSBwQmFja1JpZ2h0Q29ybmVyLnggLSB0aGlzLmNsaWNrWE9mZnNldDtcclxuICB9XHJcbn1cclxuXHJcbmNhcGFjaXRvckxhYkJhc2ljcy5yZWdpc3RlciggJ1BsYXRlQXJlYURyYWdIYW5kbGVyJywgUGxhdGVBcmVhRHJhZ0hhbmRsZXIgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBsYXRlQXJlYURyYWdIYW5kbGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsY0FBYyxNQUFNLHlDQUF5QztBQUNwRSxPQUFPQyxLQUFLLE1BQU0sZ0NBQWdDO0FBQ2xELE9BQU9DLE9BQU8sTUFBTSxrQ0FBa0M7QUFDdEQsU0FBU0MsWUFBWSxRQUFRLHNDQUFzQztBQUNuRSxPQUFPQyxrQkFBa0IsTUFBTSxnQ0FBZ0M7QUFFL0QsTUFBTUMsb0JBQW9CLFNBQVNGLFlBQVksQ0FBQztFQUM5QztBQUNGO0FBQ0E7QUFDQTtBQUNB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