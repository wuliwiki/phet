// Copyright 2015-2023, University of Colorado Boulder

/**
 * A model element that is movable.
 * It has a current position and a desired destination.
 * When the user drags the model element, it moves immediately to the desired destination.
 * When the destination is set programmatically, it animates to the desired destination.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import Vector2Property from '../../../../dot/js/Vector2Property.js';
import merge from '../../../../phet-core/js/merge.js';
import functionBuilder from '../../functionBuilder.js';
export default class FBMovable {
  /**
   * @param {Object} [options]
   */
  constructor(options) {
    options = merge({
      position: new Vector2(0, 0),
      // {Vector2} initial position
      dragging: false,
      // {boolean} is this instance being dragged by the user?
      animationSpeed: 100 // {number} distance/second when animating
    }, options);

    // @public (read-only) DO NOT set this directly! Use moveTo or animateTo.
    this.positionProperty = new Vector2Property(options.position);

    // @public
    this.dragging = options.dragging;

    // @private
    this.animationSpeed = options.animationSpeed;

    // @private {Vector2} destination to animate to, set using animateTo
    this.destination = options.position.copy();

    // @private {function|null} called when animation to destination completes, set using animateTo
    this.animationCompletedCallback = null;
  }

  // @public
  dispose() {
    assert && assert(false, 'dispose is not supported, exists for the lifetime of the sim');
  }

  // @public
  reset() {
    // call moveTo instead of positionProperty.set, so that any animation in progress is cancelled
    this.moveTo(this.positionProperty.initialValue);
  }

  /**
   * Moves immediately to the specified position, without animation.
   *
   * @param {Vector2} position
   * @public
   */
  moveTo(position) {
    this.animationCompletedCallback = null; // cancels any pending callback
    this.destination = position;
    this.positionProperty.set(position);
  }

  /**
   * Animates to the specified position. When animation is completed, call optional callback.
   *
   * @param {Vector2} destination
   * @param {function} [animationCompletedCallback]
   * @public
   */
  animateTo(destination, animationCompletedCallback) {
    this.destination = destination;
    this.animationCompletedCallback = animationCompletedCallback || null;
  }

  /**
   * Is the FBMovable animating?
   *
   * @returns {boolean}
   * @public
   */
  isAnimating() {
    return !this.dragging && (!this.positionProperty.get().equals(this.destination) || this.animationCompletedCallback);
  }

  /**
   * Animates position, when not being dragged by the user.
   *
   * @param {number} dt - time since the previous step, in seconds
   * @public
   */
  step(dt) {
    if (this.isAnimating()) {
      // distance from destination
      const totalDistance = this.positionProperty.get().distance(this.destination);

      // distance to move on this step
      const stepDistance = this.animationSpeed * dt;
      if (totalDistance <= stepDistance) {
        // move directly to the destination
        this.positionProperty.set(this.destination);

        // callback, which may set a new callback
        const saveAnimationCompletedCallback = this.animationCompletedCallback;
        this.animationCompletedCallback && this.animationCompletedCallback();
        if (saveAnimationCompletedCallback === this.animationCompletedCallback) {
          this.animationCompletedCallback = null;
        }
      } else {
        // move one step towards the destination
        const stepAngle = Math.atan2(this.destination.y - this.positionProperty.get().y, this.destination.x - this.positionProperty.get().x);
        const stepVector = Vector2.createPolar(stepDistance, stepAngle);
        this.positionProperty.set(this.positionProperty.get().plus(stepVector));
      }
    }
  }
}
functionBuilder.register('FBMovable', FBMovable);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiVmVjdG9yMlByb3BlcnR5IiwibWVyZ2UiLCJmdW5jdGlvbkJ1aWxkZXIiLCJGQk1vdmFibGUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJwb3NpdGlvbiIsImRyYWdnaW5nIiwiYW5pbWF0aW9uU3BlZWQiLCJwb3NpdGlvblByb3BlcnR5IiwiZGVzdGluYXRpb24iLCJjb3B5IiwiYW5pbWF0aW9uQ29tcGxldGVkQ2FsbGJhY2siLCJkaXNwb3NlIiwiYXNzZXJ0IiwicmVzZXQiLCJtb3ZlVG8iLCJpbml0aWFsVmFsdWUiLCJzZXQiLCJhbmltYXRlVG8iLCJpc0FuaW1hdGluZyIsImdldCIsImVxdWFscyIsInN0ZXAiLCJkdCIsInRvdGFsRGlzdGFuY2UiLCJkaXN0YW5jZSIsInN0ZXBEaXN0YW5jZSIsInNhdmVBbmltYXRpb25Db21wbGV0ZWRDYWxsYmFjayIsInN0ZXBBbmdsZSIsIk1hdGgiLCJhdGFuMiIsInkiLCJ4Iiwic3RlcFZlY3RvciIsImNyZWF0ZVBvbGFyIiwicGx1cyIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRkJNb3ZhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgbW9kZWwgZWxlbWVudCB0aGF0IGlzIG1vdmFibGUuXHJcbiAqIEl0IGhhcyBhIGN1cnJlbnQgcG9zaXRpb24gYW5kIGEgZGVzaXJlZCBkZXN0aW5hdGlvbi5cclxuICogV2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW9kZWwgZWxlbWVudCwgaXQgbW92ZXMgaW1tZWRpYXRlbHkgdG8gdGhlIGRlc2lyZWQgZGVzdGluYXRpb24uXHJcbiAqIFdoZW4gdGhlIGRlc3RpbmF0aW9uIGlzIHNldCBwcm9ncmFtbWF0aWNhbGx5LCBpdCBhbmltYXRlcyB0byB0aGUgZGVzaXJlZCBkZXN0aW5hdGlvbi5cclxuICpcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBWZWN0b3IyUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjJQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgZnVuY3Rpb25CdWlsZGVyIGZyb20gJy4uLy4uL2Z1bmN0aW9uQnVpbGRlci5qcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGQk1vdmFibGUge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgb3B0aW9ucyA9IG1lcmdlKCB7XHJcbiAgICAgIHBvc2l0aW9uOiBuZXcgVmVjdG9yMiggMCwgMCApLCAvLyB7VmVjdG9yMn0gaW5pdGlhbCBwb3NpdGlvblxyXG4gICAgICBkcmFnZ2luZzogZmFsc2UsIC8vIHtib29sZWFufSBpcyB0aGlzIGluc3RhbmNlIGJlaW5nIGRyYWdnZWQgYnkgdGhlIHVzZXI/XHJcbiAgICAgIGFuaW1hdGlvblNwZWVkOiAxMDAgLy8ge251bWJlcn0gZGlzdGFuY2Uvc2Vjb25kIHdoZW4gYW5pbWF0aW5nXHJcbiAgICB9LCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyAocmVhZC1vbmx5KSBETyBOT1Qgc2V0IHRoaXMgZGlyZWN0bHkhIFVzZSBtb3ZlVG8gb3IgYW5pbWF0ZVRvLlxyXG4gICAgdGhpcy5wb3NpdGlvblByb3BlcnR5ID0gbmV3IFZlY3RvcjJQcm9wZXJ0eSggb3B0aW9ucy5wb3NpdGlvbiApO1xyXG5cclxuICAgIC8vIEBwdWJsaWNcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBvcHRpb25zLmRyYWdnaW5nO1xyXG5cclxuICAgIC8vIEBwcml2YXRlXHJcbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gb3B0aW9ucy5hbmltYXRpb25TcGVlZDtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7VmVjdG9yMn0gZGVzdGluYXRpb24gdG8gYW5pbWF0ZSB0bywgc2V0IHVzaW5nIGFuaW1hdGVUb1xyXG4gICAgdGhpcy5kZXN0aW5hdGlvbiA9IG9wdGlvbnMucG9zaXRpb24uY29weSgpO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtmdW5jdGlvbnxudWxsfSBjYWxsZWQgd2hlbiBhbmltYXRpb24gdG8gZGVzdGluYXRpb24gY29tcGxldGVzLCBzZXQgdXNpbmcgYW5pbWF0ZVRvXHJcbiAgICB0aGlzLmFuaW1hdGlvbkNvbXBsZXRlZENhbGxiYWNrID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIEBwdWJsaWNcclxuICBkaXNwb3NlKCkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsICdkaXNwb3NlIGlzIG5vdCBzdXBwb3J0ZWQsIGV4aXN0cyBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0nICk7XHJcbiAgfVxyXG5cclxuICAvLyBAcHVibGljXHJcbiAgcmVzZXQoKSB7XHJcblxyXG4gICAgLy8gY2FsbCBtb3ZlVG8gaW5zdGVhZCBvZiBwb3NpdGlvblByb3BlcnR5LnNldCwgc28gdGhhdCBhbnkgYW5pbWF0aW9uIGluIHByb2dyZXNzIGlzIGNhbmNlbGxlZFxyXG4gICAgdGhpcy5tb3ZlVG8oIHRoaXMucG9zaXRpb25Qcm9wZXJ0eS5pbml0aWFsVmFsdWUgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmVzIGltbWVkaWF0ZWx5IHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24sIHdpdGhvdXQgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBwb3NpdGlvblxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBtb3ZlVG8oIHBvc2l0aW9uICkge1xyXG4gICAgdGhpcy5hbmltYXRpb25Db21wbGV0ZWRDYWxsYmFjayA9IG51bGw7IC8vIGNhbmNlbHMgYW55IHBlbmRpbmcgY2FsbGJhY2tcclxuICAgIHRoaXMuZGVzdGluYXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMucG9zaXRpb25Qcm9wZXJ0eS5zZXQoIHBvc2l0aW9uICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbmltYXRlcyB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLiBXaGVuIGFuaW1hdGlvbiBpcyBjb21wbGV0ZWQsIGNhbGwgb3B0aW9uYWwgY2FsbGJhY2suXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IGRlc3RpbmF0aW9uXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2FuaW1hdGlvbkNvbXBsZXRlZENhbGxiYWNrXVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBhbmltYXRlVG8oIGRlc3RpbmF0aW9uLCBhbmltYXRpb25Db21wbGV0ZWRDYWxsYmFjayApIHtcclxuICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcclxuICAgIHRoaXMuYW5pbWF0aW9uQ29tcGxldGVkQ2FsbGJhY2sgPSBhbmltYXRpb25Db21wbGV0ZWRDYWxsYmFjayB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSXMgdGhlIEZCTW92YWJsZSBhbmltYXRpbmc/XHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgaXNBbmltYXRpbmcoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZHJhZ2dpbmcgJiYgKCAhdGhpcy5wb3NpdGlvblByb3BlcnR5LmdldCgpLmVxdWFscyggdGhpcy5kZXN0aW5hdGlvbiApIHx8IHRoaXMuYW5pbWF0aW9uQ29tcGxldGVkQ2FsbGJhY2sgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuaW1hdGVzIHBvc2l0aW9uLCB3aGVuIG5vdCBiZWluZyBkcmFnZ2VkIGJ5IHRoZSB1c2VyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR0IC0gdGltZSBzaW5jZSB0aGUgcHJldmlvdXMgc3RlcCwgaW4gc2Vjb25kc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzdGVwKCBkdCApIHtcclxuICAgIGlmICggdGhpcy5pc0FuaW1hdGluZygpICkge1xyXG5cclxuICAgICAgLy8gZGlzdGFuY2UgZnJvbSBkZXN0aW5hdGlvblxyXG4gICAgICBjb25zdCB0b3RhbERpc3RhbmNlID0gdGhpcy5wb3NpdGlvblByb3BlcnR5LmdldCgpLmRpc3RhbmNlKCB0aGlzLmRlc3RpbmF0aW9uICk7XHJcblxyXG4gICAgICAvLyBkaXN0YW5jZSB0byBtb3ZlIG9uIHRoaXMgc3RlcFxyXG4gICAgICBjb25zdCBzdGVwRGlzdGFuY2UgPSB0aGlzLmFuaW1hdGlvblNwZWVkICogZHQ7XHJcblxyXG4gICAgICBpZiAoIHRvdGFsRGlzdGFuY2UgPD0gc3RlcERpc3RhbmNlICkge1xyXG5cclxuICAgICAgICAvLyBtb3ZlIGRpcmVjdGx5IHRvIHRoZSBkZXN0aW5hdGlvblxyXG4gICAgICAgIHRoaXMucG9zaXRpb25Qcm9wZXJ0eS5zZXQoIHRoaXMuZGVzdGluYXRpb24gKTtcclxuXHJcbiAgICAgICAgLy8gY2FsbGJhY2ssIHdoaWNoIG1heSBzZXQgYSBuZXcgY2FsbGJhY2tcclxuICAgICAgICBjb25zdCBzYXZlQW5pbWF0aW9uQ29tcGxldGVkQ2FsbGJhY2sgPSB0aGlzLmFuaW1hdGlvbkNvbXBsZXRlZENhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ29tcGxldGVkQ2FsbGJhY2sgJiYgdGhpcy5hbmltYXRpb25Db21wbGV0ZWRDYWxsYmFjaygpO1xyXG4gICAgICAgIGlmICggc2F2ZUFuaW1hdGlvbkNvbXBsZXRlZENhbGxiYWNrID09PSB0aGlzLmFuaW1hdGlvbkNvbXBsZXRlZENhbGxiYWNrICkge1xyXG4gICAgICAgICAgdGhpcy5hbmltYXRpb25Db21wbGV0ZWRDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBtb3ZlIG9uZSBzdGVwIHRvd2FyZHMgdGhlIGRlc3RpbmF0aW9uXHJcbiAgICAgICAgY29uc3Qgc3RlcEFuZ2xlID0gTWF0aC5hdGFuMihcclxuICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ueSAtIHRoaXMucG9zaXRpb25Qcm9wZXJ0eS5nZXQoKS55LFxyXG4gICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi54IC0gdGhpcy5wb3NpdGlvblByb3BlcnR5LmdldCgpLnggKTtcclxuICAgICAgICBjb25zdCBzdGVwVmVjdG9yID0gVmVjdG9yMi5jcmVhdGVQb2xhciggc3RlcERpc3RhbmNlLCBzdGVwQW5nbGUgKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uUHJvcGVydHkuc2V0KCB0aGlzLnBvc2l0aW9uUHJvcGVydHkuZ2V0KCkucGx1cyggc3RlcFZlY3RvciApICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uQnVpbGRlci5yZWdpc3RlciggJ0ZCTW92YWJsZScsIEZCTW92YWJsZSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLGVBQWUsTUFBTSx1Q0FBdUM7QUFDbkUsT0FBT0MsS0FBSyxNQUFNLG1DQUFtQztBQUNyRCxPQUFPQyxlQUFlLE1BQU0sMEJBQTBCO0FBRXRELGVBQWUsTUFBTUMsU0FBUyxDQUFDO0VBRTdCO0FBQ0Y7QUFDQTtFQUNFQyxXQUFXQSxDQUFFQyxPQUFPLEVBQUc7SUFFckJBLE9BQU8sR0FBR0osS0FBSyxDQUFFO01BQ2ZLLFFBQVEsRUFBRSxJQUFJUCxPQUFPLENBQUUsQ0FBQyxFQUFFLENBQUUsQ0FBQztNQUFF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