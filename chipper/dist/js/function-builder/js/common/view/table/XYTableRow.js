// Copyright 2016-2023, University of Colorado Boulder

/**
 * A row in the XY table.
 * Each row is associated with an instance of a card, and contains an input and output cell.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Dimension2 from '../../../../../dot/js/Dimension2.js';
import merge from '../../../../../phet-core/js/merge.js';
import { Node, Rectangle } from '../../../../../scenery/js/imports.js';
import functionBuilder from '../../../functionBuilder.js';
import EquationCard from '../../model/cards/EquationCard.js';
import NumberCard from '../../model/cards/NumberCard.js';
import SlopeInterceptEquation from '../../model/equations/SlopeInterceptEquation.js';
import SlopeInterceptEquationNode from '../equations/SlopeInterceptEquationNode.js';
import RationalNumberNode from '../RationalNumberNode.js';
export default class XYTableRow extends Node {
  /**
   * @param {NumberCard|EquationCard} card - card that's associated with the row
   * @param {Builder} builder
   * @param options
   */
  constructor(card, builder, options) {
    assert && assert(card instanceof NumberCard || card instanceof EquationCard);
    options = merge({
      size: new Dimension2(100, 10),
      cellXMargin: 15,
      cellYMargin: 3,
      updateEnabled: true // {boolean} does this node update when the model changes?
    }, options);
    super();

    // @private
    this.card = card;
    this.builder = builder;
    this.size = options.size;
    this._updateEnabled = options.updateEnabled;
    this.dirty = true; // {boolean} does this node need to be updated?

    // don't stroke the cells, grid is drawn by XYTableNode
    const rowNode = new Rectangle(0, 0, options.size.width, options.size.height);
    this.addChild(rowNode);

    // @private constrain values to cells
    this.valueMaxWidth = options.size.width / 2 - 2 * options.cellXMargin;
    this.valueMaxHeight = options.size.height - 2 * options.cellYMargin;

    // input value, static
    const inputValueNode = createCellValueNode(card, builder, {
      numberOfFunctions: 0,
      // apply no functions for the input value
      maxWidth: this.valueMaxWidth,
      maxHeight: this.valueMaxHeight,
      centerX: 0.25 * options.size.width,
      centerY: options.size.height / 2
    });
    this.addChild(inputValueNode);

    // @private output value, correct node is created by updateOutputValue
    this.outputValueNode = null;

    // Update the output value when functions change
    const functionChangedListener = () => {
      this.dirty = true;
      if (this.updateEnabled) {
        this.updateOutputValue();
      }
    };
    builder.functionChangedEmitter.addListener(functionChangedListener); // removeListener required by dispose

    // initial state of output cell
    if (this.updateEnabled) {
      this.updateOutputValue();
    } else {
      // non-null placeholder for output value
      this.outputValueNode = new Rectangle(0, 0, 1, 1, {
        visible: options.updateEnabled
      });
      this.addChild(this.outputValueNode);
    }
    this.mutate(options);

    // @private
    this.disposeXYTableRow = () => {
      builder.functionChangedEmitter.removeListener(functionChangedListener);
      builder = null; // so things fail if we try to use this instance after dispose is called
    };
  }

  // @public
  dispose() {
    this.disposeXYTableRow();
    super.dispose();
  }

  /**
   * Updates the value in the output cell.
   *
   * @private
   */
  updateOutputValue() {
    assert && assert(this.updateEnabled && this.dirty);

    // remove previous node
    let outputValueNodeWasVisible = false;
    if (this.outputValueNode) {
      outputValueNodeWasVisible = this.outputValueNode.visible;
      this.removeChild(this.outputValueNode);
    }

    // add new node
    this.outputValueNode = createCellValueNode(this.card, this.builder, {
      numberOfFunctions: this.builder.numberOfSlots,
      // apply all functions for the output value
      visible: outputValueNodeWasVisible,
      maxWidth: this.valueMaxWidth,
      maxHeight: this.valueMaxHeight,
      centerX: 0.75 * this.size.width,
      centerY: this.size.height / 2
    });
    this.addChild(this.outputValueNode);
    this.dirty = false;
  }

  /**
   * Sets the visibility ofthe row's output cell.
   *
   * @param visible
   * @public
   */
  setOutputCellVisible(visible) {
    this.outputValueNode.visible = visible;
  }

  /**
   * Determines whether updating of this node is enabled.
   *
   * @param {boolean} updateEnabled
   * @public
   *
   */
  setUpdateEnabled(updateEnabled) {
    const wasUpdateEnabled = this._updateEnabled;
    this._updateEnabled = updateEnabled;
    if (this.dirty && !wasUpdateEnabled && updateEnabled) {
      this.updateOutputValue();
    }
  }
  set updateEnabled(value) {
    this.setUpdateEnabled(value);
  }

  /**
   * Is updating of this node enabled?
   *
   * @returns {boolean}
   * @public
   */
  getUpdateEnabled() {
    return this._updateEnabled;
  }
  get updateEnabled() {
    return this.getUpdateEnabled();
  }
}

/**
 * Creates the value for a specified card.
 *
 * @param {NumberCard|EquationCard} card
 * @param {Builder} builder
 * @param {Object} [options]
 * @returns {Node}
 */
function createCellValueNode(card, builder, options) {
  options = merge({
    numberOfFunctions: 0,
    // number of functions to apply
    showLeftHandSide: false // don't show the left-hand side (y =) of equations
  }, options);
  assert && assert(options.numberOfFunctions <= builder.numberOfSlots);
  let valueNode = null;
  if (card instanceof NumberCard) {
    const rationalNumber = builder.applyFunctions(card.rationalNumber, options.numberOfFunctions);
    valueNode = new RationalNumberNode(rationalNumber, options);
  } else if (card instanceof EquationCard) {
    const mathFunctions = builder.applyFunctions([], options.numberOfFunctions); // {MathFunction[]}
    const equation = new SlopeInterceptEquation(mathFunctions);
    valueNode = new SlopeInterceptEquationNode(equation.slope, equation.intercept, options);
  } else {
    throw new Error('invalid card type');
  }
  return valueNode;
}
functionBuilder.register('XYTableRow', XYTableRow);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEaW1lbnNpb24yIiwibWVyZ2UiLCJOb2RlIiwiUmVjdGFuZ2xlIiwiZnVuY3Rpb25CdWlsZGVyIiwiRXF1YXRpb25DYXJkIiwiTnVtYmVyQ2FyZCIsIlNsb3BlSW50ZXJjZXB0RXF1YXRpb24iLCJTbG9wZUludGVyY2VwdEVxdWF0aW9uTm9kZSIsIlJhdGlvbmFsTnVtYmVyTm9kZSIsIlhZVGFibGVSb3ciLCJjb25zdHJ1Y3RvciIsImNhcmQiLCJidWlsZGVyIiwib3B0aW9ucyIsImFzc2VydCIsInNpemUiLCJjZWxsWE1hcmdpbiIsImNlbGxZTWFyZ2luIiwidXBkYXRlRW5hYmxlZCIsIl91cGRhdGVFbmFibGVkIiwiZGlydHkiLCJyb3dOb2RlIiwid2lkdGgiLCJoZWlnaHQiLCJhZGRDaGlsZCIsInZhbHVlTWF4V2lkdGgiLCJ2YWx1ZU1heEhlaWdodCIsImlucHV0VmFsdWVOb2RlIiwiY3JlYXRlQ2VsbFZhbHVlTm9kZSIsIm51bWJlck9mRnVuY3Rpb25zIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJjZW50ZXJYIiwiY2VudGVyWSIsIm91dHB1dFZhbHVlTm9kZSIsImZ1bmN0aW9uQ2hhbmdlZExpc3RlbmVyIiwidXBkYXRlT3V0cHV0VmFsdWUiLCJmdW5jdGlvbkNoYW5nZWRFbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJ2aXNpYmxlIiwibXV0YXRlIiwiZGlzcG9zZVhZVGFibGVSb3ciLCJyZW1vdmVMaXN0ZW5lciIsImRpc3Bvc2UiLCJvdXRwdXRWYWx1ZU5vZGVXYXNWaXNpYmxlIiwicmVtb3ZlQ2hpbGQiLCJudW1iZXJPZlNsb3RzIiwic2V0T3V0cHV0Q2VsbFZpc2libGUiLCJzZXRVcGRhdGVFbmFibGVkIiwid2FzVXBkYXRlRW5hYmxlZCIsInZhbHVlIiwiZ2V0VXBkYXRlRW5hYmxlZCIsInNob3dMZWZ0SGFuZFNpZGUiLCJ2YWx1ZU5vZGUiLCJyYXRpb25hbE51bWJlciIsImFwcGx5RnVuY3Rpb25zIiwibWF0aEZ1bmN0aW9ucyIsImVxdWF0aW9uIiwic2xvcGUiLCJpbnRlcmNlcHQiLCJFcnJvciIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiWFlUYWJsZVJvdy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNi0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBBIHJvdyBpbiB0aGUgWFkgdGFibGUuXHJcbiAqIEVhY2ggcm93IGlzIGFzc29jaWF0ZWQgd2l0aCBhbiBpbnN0YW5jZSBvZiBhIGNhcmQsIGFuZCBjb250YWlucyBhbiBpbnB1dCBhbmQgb3V0cHV0IGNlbGwuXHJcbiAqXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqL1xyXG5cclxuaW1wb3J0IERpbWVuc2lvbjIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vZG90L2pzL0RpbWVuc2lvbjIuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi4vLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lcmdlLmpzJztcclxuaW1wb3J0IHsgTm9kZSwgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IGZ1bmN0aW9uQnVpbGRlciBmcm9tICcuLi8uLi8uLi9mdW5jdGlvbkJ1aWxkZXIuanMnO1xyXG5pbXBvcnQgRXF1YXRpb25DYXJkIGZyb20gJy4uLy4uL21vZGVsL2NhcmRzL0VxdWF0aW9uQ2FyZC5qcyc7XHJcbmltcG9ydCBOdW1iZXJDYXJkIGZyb20gJy4uLy4uL21vZGVsL2NhcmRzL051bWJlckNhcmQuanMnO1xyXG5pbXBvcnQgU2xvcGVJbnRlcmNlcHRFcXVhdGlvbiBmcm9tICcuLi8uLi9tb2RlbC9lcXVhdGlvbnMvU2xvcGVJbnRlcmNlcHRFcXVhdGlvbi5qcyc7XHJcbmltcG9ydCBTbG9wZUludGVyY2VwdEVxdWF0aW9uTm9kZSBmcm9tICcuLi9lcXVhdGlvbnMvU2xvcGVJbnRlcmNlcHRFcXVhdGlvbk5vZGUuanMnO1xyXG5pbXBvcnQgUmF0aW9uYWxOdW1iZXJOb2RlIGZyb20gJy4uL1JhdGlvbmFsTnVtYmVyTm9kZS5qcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBYWVRhYmxlUm93IGV4dGVuZHMgTm9kZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyQ2FyZHxFcXVhdGlvbkNhcmR9IGNhcmQgLSBjYXJkIHRoYXQncyBhc3NvY2lhdGVkIHdpdGggdGhlIHJvd1xyXG4gICAqIEBwYXJhbSB7QnVpbGRlcn0gYnVpbGRlclxyXG4gICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGNhcmQsIGJ1aWxkZXIsIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggY2FyZCBpbnN0YW5jZW9mIE51bWJlckNhcmQgfHwgY2FyZCBpbnN0YW5jZW9mIEVxdWF0aW9uQ2FyZCApO1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG4gICAgICBzaXplOiBuZXcgRGltZW5zaW9uMiggMTAwLCAxMCApLFxyXG4gICAgICBjZWxsWE1hcmdpbjogMTUsXHJcbiAgICAgIGNlbGxZTWFyZ2luOiAzLFxyXG4gICAgICB1cGRhdGVFbmFibGVkOiB0cnVlIC8vIHtib29sZWFufSBkb2VzIHRoaXMgbm9kZSB1cGRhdGUgd2hlbiB0aGUgbW9kZWwgY2hhbmdlcz9cclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8vIEBwcml2YXRlXHJcbiAgICB0aGlzLmNhcmQgPSBjYXJkO1xyXG4gICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcclxuICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcclxuICAgIHRoaXMuX3VwZGF0ZUVuYWJsZWQgPSBvcHRpb25zLnVwZGF0ZUVuYWJsZWQ7XHJcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsgLy8ge2Jvb2xlYW59IGRvZXMgdGhpcyBub2RlIG5lZWQgdG8gYmUgdXBkYXRlZD9cclxuXHJcbiAgICAvLyBkb24ndCBzdHJva2UgdGhlIGNlbGxzLCBncmlkIGlzIGRyYXduIGJ5IFhZVGFibGVOb2RlXHJcbiAgICBjb25zdCByb3dOb2RlID0gbmV3IFJlY3RhbmdsZSggMCwgMCwgb3B0aW9ucy5zaXplLndpZHRoLCBvcHRpb25zLnNpemUuaGVpZ2h0ICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCByb3dOb2RlICk7XHJcblxyXG4gICAgLy8gQHByaXZhdGUgY29uc3RyYWluIHZhbHVlcyB0byBjZWxsc1xyXG4gICAgdGhpcy52YWx1ZU1heFdpZHRoID0gKCBvcHRpb25zLnNpemUud2lkdGggLyAyICkgLSAoIDIgKiBvcHRpb25zLmNlbGxYTWFyZ2luICk7XHJcbiAgICB0aGlzLnZhbHVlTWF4SGVpZ2h0ID0gb3B0aW9ucy5zaXplLmhlaWdodCAtICggMiAqIG9wdGlvbnMuY2VsbFlNYXJnaW4gKTtcclxuXHJcbiAgICAvLyBpbnB1dCB2YWx1ZSwgc3RhdGljXHJcbiAgICBjb25zdCBpbnB1dFZhbHVlTm9kZSA9IGNyZWF0ZUNlbGxWYWx1ZU5vZGUoIGNhcmQsIGJ1aWxkZXIsIHtcclxuICAgICAgbnVtYmVyT2ZGdW5jdGlvbnM6IDAsIC8vIGFwcGx5IG5vIGZ1bmN0aW9ucyBmb3IgdGhlIGlucHV0IHZhbHVlXHJcbiAgICAgIG1heFdpZHRoOiB0aGlzLnZhbHVlTWF4V2lkdGgsXHJcbiAgICAgIG1heEhlaWdodDogdGhpcy52YWx1ZU1heEhlaWdodCxcclxuICAgICAgY2VudGVyWDogMC4yNSAqIG9wdGlvbnMuc2l6ZS53aWR0aCxcclxuICAgICAgY2VudGVyWTogb3B0aW9ucy5zaXplLmhlaWdodCAvIDJcclxuICAgIH0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIGlucHV0VmFsdWVOb2RlICk7XHJcblxyXG4gICAgLy8gQHByaXZhdGUgb3V0cHV0IHZhbHVlLCBjb3JyZWN0IG5vZGUgaXMgY3JlYXRlZCBieSB1cGRhdGVPdXRwdXRWYWx1ZVxyXG4gICAgdGhpcy5vdXRwdXRWYWx1ZU5vZGUgPSBudWxsO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgb3V0cHV0IHZhbHVlIHdoZW4gZnVuY3Rpb25zIGNoYW5nZVxyXG4gICAgY29uc3QgZnVuY3Rpb25DaGFuZ2VkTGlzdGVuZXIgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICBpZiAoIHRoaXMudXBkYXRlRW5hYmxlZCApIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZU91dHB1dFZhbHVlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBidWlsZGVyLmZ1bmN0aW9uQ2hhbmdlZEVtaXR0ZXIuYWRkTGlzdGVuZXIoIGZ1bmN0aW9uQ2hhbmdlZExpc3RlbmVyICk7IC8vIHJlbW92ZUxpc3RlbmVyIHJlcXVpcmVkIGJ5IGRpc3Bvc2VcclxuXHJcbiAgICAvLyBpbml0aWFsIHN0YXRlIG9mIG91dHB1dCBjZWxsXHJcbiAgICBpZiAoIHRoaXMudXBkYXRlRW5hYmxlZCApIHtcclxuICAgICAgdGhpcy51cGRhdGVPdXRwdXRWYWx1ZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIG5vbi1udWxsIHBsYWNlaG9sZGVyIGZvciBvdXRwdXQgdmFsdWVcclxuICAgICAgdGhpcy5vdXRwdXRWYWx1ZU5vZGUgPSBuZXcgUmVjdGFuZ2xlKCAwLCAwLCAxLCAxLCB7XHJcbiAgICAgICAgdmlzaWJsZTogb3B0aW9ucy51cGRhdGVFbmFibGVkXHJcbiAgICAgIH0gKTtcclxuICAgICAgdGhpcy5hZGRDaGlsZCggdGhpcy5vdXRwdXRWYWx1ZU5vZGUgKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm11dGF0ZSggb3B0aW9ucyApO1xyXG5cclxuICAgIC8vIEBwcml2YXRlXHJcbiAgICB0aGlzLmRpc3Bvc2VYWVRhYmxlUm93ID0gKCkgPT4ge1xyXG4gICAgICBidWlsZGVyLmZ1bmN0aW9uQ2hhbmdlZEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIGZ1bmN0aW9uQ2hhbmdlZExpc3RlbmVyICk7XHJcbiAgICAgIGJ1aWxkZXIgPSBudWxsOyAvLyBzbyB0aGluZ3MgZmFpbCBpZiB3ZSB0cnkgdG8gdXNlIHRoaXMgaW5zdGFuY2UgYWZ0ZXIgZGlzcG9zZSBpcyBjYWxsZWRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBAcHVibGljXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHRoaXMuZGlzcG9zZVhZVGFibGVSb3coKTtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHZhbHVlIGluIHRoZSBvdXRwdXQgY2VsbC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgdXBkYXRlT3V0cHV0VmFsdWUoKSB7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy51cGRhdGVFbmFibGVkICYmIHRoaXMuZGlydHkgKTtcclxuXHJcbiAgICAvLyByZW1vdmUgcHJldmlvdXMgbm9kZVxyXG4gICAgbGV0IG91dHB1dFZhbHVlTm9kZVdhc1Zpc2libGUgPSBmYWxzZTtcclxuICAgIGlmICggdGhpcy5vdXRwdXRWYWx1ZU5vZGUgKSB7XHJcbiAgICAgIG91dHB1dFZhbHVlTm9kZVdhc1Zpc2libGUgPSB0aGlzLm91dHB1dFZhbHVlTm9kZS52aXNpYmxlO1xyXG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKCB0aGlzLm91dHB1dFZhbHVlTm9kZSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCBuZXcgbm9kZVxyXG4gICAgdGhpcy5vdXRwdXRWYWx1ZU5vZGUgPSBjcmVhdGVDZWxsVmFsdWVOb2RlKCB0aGlzLmNhcmQsIHRoaXMuYnVpbGRlciwge1xyXG4gICAgICBudW1iZXJPZkZ1bmN0aW9uczogdGhpcy5idWlsZGVyLm51bWJlck9mU2xvdHMsIC8vIGFwcGx5IGFsbCBmdW5jdGlvbnMgZm9yIHRoZSBvdXRwdXQgdmFsdWVcclxuICAgICAgdmlzaWJsZTogb3V0cHV0VmFsdWVOb2RlV2FzVmlzaWJsZSxcclxuICAgICAgbWF4V2lkdGg6IHRoaXMudmFsdWVNYXhXaWR0aCxcclxuICAgICAgbWF4SGVpZ2h0OiB0aGlzLnZhbHVlTWF4SGVpZ2h0LFxyXG4gICAgICBjZW50ZXJYOiAwLjc1ICogdGhpcy5zaXplLndpZHRoLFxyXG4gICAgICBjZW50ZXJZOiB0aGlzLnNpemUuaGVpZ2h0IC8gMlxyXG4gICAgfSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggdGhpcy5vdXRwdXRWYWx1ZU5vZGUgKTtcclxuXHJcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mdGhlIHJvdydzIG91dHB1dCBjZWxsLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHZpc2libGVcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgc2V0T3V0cHV0Q2VsbFZpc2libGUoIHZpc2libGUgKSB7XHJcbiAgICB0aGlzLm91dHB1dFZhbHVlTm9kZS52aXNpYmxlID0gdmlzaWJsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgd2hldGhlciB1cGRhdGluZyBvZiB0aGlzIG5vZGUgaXMgZW5hYmxlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBkYXRlRW5hYmxlZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqL1xyXG4gIHNldFVwZGF0ZUVuYWJsZWQoIHVwZGF0ZUVuYWJsZWQgKSB7XHJcbiAgICBjb25zdCB3YXNVcGRhdGVFbmFibGVkID0gdGhpcy5fdXBkYXRlRW5hYmxlZDtcclxuICAgIHRoaXMuX3VwZGF0ZUVuYWJsZWQgPSB1cGRhdGVFbmFibGVkO1xyXG4gICAgaWYgKCB0aGlzLmRpcnR5ICYmICF3YXNVcGRhdGVFbmFibGVkICYmIHVwZGF0ZUVuYWJsZWQgKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlT3V0cHV0VmFsdWUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldCB1cGRhdGVFbmFibGVkKCB2YWx1ZSApIHsgdGhpcy5zZXRVcGRhdGVFbmFibGVkKCB2YWx1ZSApOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIElzIHVwZGF0aW5nIG9mIHRoaXMgbm9kZSBlbmFibGVkP1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGdldFVwZGF0ZUVuYWJsZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRW5hYmxlZDtcclxuICB9XHJcblxyXG4gIGdldCB1cGRhdGVFbmFibGVkKCkgeyByZXR1cm4gdGhpcy5nZXRVcGRhdGVFbmFibGVkKCk7IH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgdGhlIHZhbHVlIGZvciBhIHNwZWNpZmllZCBjYXJkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlckNhcmR8RXF1YXRpb25DYXJkfSBjYXJkXHJcbiAqIEBwYXJhbSB7QnVpbGRlcn0gYnVpbGRlclxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIEByZXR1cm5zIHtOb2RlfVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQ2VsbFZhbHVlTm9kZSggY2FyZCwgYnVpbGRlciwgb3B0aW9ucyApIHtcclxuXHJcbiAgb3B0aW9ucyA9IG1lcmdlKCB7XHJcbiAgICBudW1iZXJPZkZ1bmN0aW9uczogMCwgLy8gbnVtYmVyIG9mIGZ1bmN0aW9ucyB0byBhcHBseVxyXG4gICAgc2hvd0xlZnRIYW5kU2lkZTogZmFsc2UgLy8gZG9uJ3Qgc2hvdyB0aGUgbGVmdC1oYW5kIHNpZGUgKHkgPSkgb2YgZXF1YXRpb25zXHJcbiAgfSwgb3B0aW9ucyApO1xyXG4gIGFzc2VydCAmJiBhc3NlcnQoIG9wdGlvbnMubnVtYmVyT2ZGdW5jdGlvbnMgPD0gYnVpbGRlci5udW1iZXJPZlNsb3RzICk7XHJcblxyXG4gIGxldCB2YWx1ZU5vZGUgPSBudWxsO1xyXG4gIGlmICggY2FyZCBpbnN0YW5jZW9mIE51bWJlckNhcmQgKSB7XHJcbiAgICBjb25zdCByYXRpb25hbE51bWJlciA9IGJ1aWxkZXIuYXBwbHlGdW5jdGlvbnMoIGNhcmQucmF0aW9uYWxOdW1iZXIsIG9wdGlvbnMubnVtYmVyT2ZGdW5jdGlvbnMgKTtcclxuICAgIHZhbHVlTm9kZSA9IG5ldyBSYXRpb25hbE51bWJlck5vZGUoIHJhdGlvbmFsTnVtYmVyLCBvcHRpb25zICk7XHJcbiAgfVxyXG4gIGVsc2UgaWYgKCBjYXJkIGluc3RhbmNlb2YgRXF1YXRpb25DYXJkICkge1xyXG4gICAgY29uc3QgbWF0aEZ1bmN0aW9ucyA9IGJ1aWxkZXIuYXBwbHlGdW5jdGlvbnMoIFtdLCBvcHRpb25zLm51bWJlck9mRnVuY3Rpb25zICk7IC8vIHtNYXRoRnVuY3Rpb25bXX1cclxuICAgIGNvbnN0IGVxdWF0aW9uID0gbmV3IFNsb3BlSW50ZXJjZXB0RXF1YXRpb24oIG1hdGhGdW5jdGlvbnMgKTtcclxuICAgIHZhbHVlTm9kZSA9IG5ldyBTbG9wZUludGVyY2VwdEVxdWF0aW9uTm9kZSggZXF1YXRpb24uc2xvcGUsIGVxdWF0aW9uLmludGVyY2VwdCwgb3B0aW9ucyApO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvciggJ2ludmFsaWQgY2FyZCB0eXBlJyApO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWVOb2RlO1xyXG59XHJcblxyXG5mdW5jdGlvbkJ1aWxkZXIucmVnaXN0ZXIoICdYWVRhYmxlUm93JywgWFlUYWJsZVJvdyApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFVBQVUsTUFBTSxxQ0FBcUM7QUFDNUQsT0FBT0MsS0FBSyxNQUFNLHNDQUFzQztBQUN4RCxTQUFTQyxJQUFJLEVBQUVDLFNBQVMsUUFBUSxzQ0FBc0M7QUFDdEUsT0FBT0MsZUFBZSxNQUFNLDZCQUE2QjtBQUN6RCxPQUFPQyxZQUFZLE1BQU0sbUNBQW1DO0FBQzVELE9BQU9DLFVBQVUs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