// Copyright 2015-2023, University of Colorado Boulder

/**
 * Applies a 'Warhol effect' to an image.
 * The basic approach is described at http://chennanni.com/archives/1111.
 *
 * Steps to 'Warhol' an image:
 *
 * 1. Scale the image by 50%.
 * 2. Convert the image to grayscale.
 * 3. Use intensity of pixels in the grayscale image to map pixels to colors.
 * 4. Draw the color-mapped image into 1 of the 4 quadrants.
 * 5. Repeat steps 3 & 4 for each quadrant, using a different color map.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import { Color, Image } from '../../../../../scenery/js/imports.js';
import warhol_png from '../../../../mipmaps/functions/warhol_png.js';
import FBConstants from '../../../common/FBConstants.js';
import ImageFunction from '../../../common/model/functions/ImageFunction.js';
import functionBuilder from '../../../functionBuilder.js';
import FBCanvasUtils from '../FBCanvasUtils.js';
import Grayscale from './Grayscale.js';
import Identity from './Identity.js';
import Shrink from './Shrink.js';

/**
 * Color maps, for mapping grayscale intensity to RGB.
 *
 * Intensity range is [0,255], where 0 is darkest, 255 is brightest. For the purposes of color mapping, the intensity
 * range is divided into equal 'bands', based on the number of colors in the map. Each pixel in the grayscale image
 * is examined, its intensity is computed, and the corresponding color is used from the color map.
 *
 * For example, if COLOR_MAP has 4 colors, then there will be 4 intensity bands (0-64, 65-127, 128-192, 193-255)
 * which map to indices 0-3 (respectively) of the map.  If a pixel's intensity is 68, then COLOR_MAP[1] will
 * be used as the color for the pixel.
 *
 * @type {Color[]}
 */
const LEFT_TOP_COLOR_MAP = [new Color(0, 0, 255), new Color(0, 255, 0), new Color(255, 0, 0), new Color(255, 255, 0)];
const RIGHT_TOP_COLOR_MAP = [Color.YELLOW, Color.RED, Color.GREEN, new Color(40, 40, 255)];
const LEFT_BOTTOM_COLOR_MAP = [new Color(19, 31, 24), new Color(76, 76, 76), Color.YELLOW, Color.MAGENTA];
const RIGHT_BOTTOM_COLOR_MAP = [new Color(0, 100, 255), new Color(165, 255, 0), new Color(255, 0, 132), new Color(255, 215, 140)];
export default class Warhol extends ImageFunction {
  /**
   * @param {Object} [options]
   */
  constructor(options) {
    options = options || {};
    options.name = 'Warhol';
    options.fill = 'rgb( 250, 186, 75 )';
    options.invertible = false; // grayscale conversion and intensity mapping are both lossy

    const iconNode = new Image(warhol_png, {
      scale: FBConstants.PATTERNS_FUNCTION_ICON_SCALE
    });
    super(iconNode, options);

    // @private
    this.shrink = new Shrink({
      scale: 0.5
    });
    this.grayscale = new Grayscale();
    this.identity = new Identity();
  }

  /**
   * Applies this function.
   *
   * @param {HTMLCanvasElement} inputCanvas
   * @returns {HTMLCanvasElement}
   * @public
   * @override
   */
  applyFunction(inputCanvas) {
    assert && assert(this.shrink !== undefined, 'apply was called before constructor completed');
    let outputCanvas = null;
    if (FBCanvasUtils.isBlank(inputCanvas)) {
      // The input canvas is blank, apply Identity instead of Warhol.
      outputCanvas = this.identity.applyFunction(inputCanvas);
    } else {
      // Shrink the image by 50%.
      // Do this first so that we're processing fewer pixels in subsequent operations.
      const halfCanvas = this.shrink.applyFunction(inputCanvas);

      // Put the image on an opaque background, so we have no transparent pixels.
      const opaqueCanvas = FBCanvasUtils.createCanvasWithImage(halfCanvas, {
        fillStyle: 'white'
      });

      // Convert the image to grayscale
      const grayscaleCanvas = this.grayscale.applyFunction(opaqueCanvas);
      const grayscaleData = FBCanvasUtils.getImageData(grayscaleCanvas);

      // Create the output canvas, with same dimensions as inputCanvas
      outputCanvas = FBCanvasUtils.createCanvas(inputCanvas.width, inputCanvas.height);
      const outputContext = outputCanvas.getContext('2d');

      // Create a 'scratch' ImageData that will hold the result of mapping grayscale to colors.
      // This gets reused for each color mapping, so be sure to draw the data to the output canvas
      // before proceeding with the next mapping.
      const scratchData = halfCanvas.getContext('2d').createImageData(halfCanvas.width, halfCanvas.height);

      // Draw a color-mapped image to each quadrant of the output canvas, using a different map in each quadrant.
      outputContext.putImageData(applyColorMap(grayscaleData, scratchData, LEFT_TOP_COLOR_MAP), 0, 0);
      outputContext.putImageData(applyColorMap(grayscaleData, scratchData, RIGHT_TOP_COLOR_MAP), outputCanvas.width / 2, 0);
      outputContext.putImageData(applyColorMap(grayscaleData, scratchData, LEFT_BOTTOM_COLOR_MAP), 0, outputCanvas.height / 2);
      outputContext.putImageData(applyColorMap(grayscaleData, scratchData, RIGHT_BOTTOM_COLOR_MAP), outputCanvas.width / 2, outputCanvas.height / 2);
    }
    return outputCanvas;
  }
}

/**
 * Applies a color map, based on intensity of the pixels in the input.
 * While it's tempting to implement this as a subtype of ImageFunction,
 * doing so would increase the number of Canvases created when applying Warhol.
 *
 * @param {ImageData} inputData
 * @param {ImageData} outputData
 * @param {Color[]} colorMap
 * @returns {ImageData}
 */
function applyColorMap(inputData, outputData, colorMap) {
  assert && assert(inputData.data.length === outputData.data.length);
  for (let i = 0; i < inputData.data.length - 4; i += 4) {
    // Convert RGB (0-255) to intensity (0-255), using the non-linear luma coding scheme employed in video systems
    // (e.g. NTSC, PAL, SECAM).  See https://en.wikipedia.org/wiki/Grayscale or the NTSC CCIR 601 specification.
    const intensity = 0.2989 * inputData.data[i] + 0.5870 * inputData.data[i + 1] + 0.1140 * inputData.data[i + 2];
    assert && assert(intensity >= 0 && intensity <= 255, `intensity out of range: ${intensity}`);

    // map intensity to a color map
    const colorIndex = Math.floor(intensity / (256 / colorMap.length));
    assert && assert(colorIndex >= 0 && colorIndex < colorMap.length, `colorIndex out of range: ${colorIndex}`);

    // apply the color map
    const color = colorMap[colorIndex];
    FBCanvasUtils.setPixelRGBA(outputData, i, color.red, color.green, color.blue, inputData.data[i + 3]);
  }
  return outputData;
}

// @public for use by FBIconFactory.createPatternsScreenIcon
Warhol.LEFT_TOP_COLOR_MAP = LEFT_TOP_COLOR_MAP;
Warhol.RIGHT_TOP_COLOR_MAP = RIGHT_TOP_COLOR_MAP;
Warhol.LEFT_BOTTOM_COLOR_MAP = LEFT_BOTTOM_COLOR_MAP;
Warhol.RIGHT_BOTTOM_COLOR_MAP = RIGHT_BOTTOM_COLOR_MAP;
functionBuilder.register('Warhol', Warhol);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJDb2xvciIsIkltYWdlIiwid2FyaG9sX3BuZyIsIkZCQ29uc3RhbnRzIiwiSW1hZ2VGdW5jdGlvbiIsImZ1bmN0aW9uQnVpbGRlciIsIkZCQ2FudmFzVXRpbHMiLCJHcmF5c2NhbGUiLCJJZGVudGl0eSIsIlNocmluayIsIkxFRlRfVE9QX0NPTE9SX01BUCIsIlJJR0hUX1RPUF9DT0xPUl9NQVAiLCJZRUxMT1ciLCJSRUQiLCJHUkVFTiIsIkxFRlRfQk9UVE9NX0NPTE9SX01BUCIsIk1BR0VOVEEiLCJSSUdIVF9CT1RUT01fQ09MT1JfTUFQIiwiV2FyaG9sIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwibmFtZSIsImZpbGwiLCJpbnZlcnRpYmxlIiwiaWNvbk5vZGUiLCJzY2FsZSIsIlBBVFRFUk5TX0ZVTkNUSU9OX0lDT05fU0NBTEUiLCJzaHJpbmsiLCJncmF5c2NhbGUiLCJpZGVudGl0eSIsImFwcGx5RnVuY3Rpb24iLCJpbnB1dENhbnZhcyIsImFzc2VydCIsInVuZGVmaW5lZCIsIm91dHB1dENhbnZhcyIsImlzQmxhbmsiLCJoYWxmQ2FudmFzIiwib3BhcXVlQ2FudmFzIiwiY3JlYXRlQ2FudmFzV2l0aEltYWdlIiwiZmlsbFN0eWxlIiwiZ3JheXNjYWxlQ2FudmFzIiwiZ3JheXNjYWxlRGF0YSIsImdldEltYWdlRGF0YSIsImNyZWF0ZUNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0Iiwib3V0cHV0Q29udGV4dCIsImdldENvbnRleHQiLCJzY3JhdGNoRGF0YSIsImNyZWF0ZUltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsImFwcGx5Q29sb3JNYXAiLCJpbnB1dERhdGEiLCJvdXRwdXREYXRhIiwiY29sb3JNYXAiLCJkYXRhIiwibGVuZ3RoIiwiaSIsImludGVuc2l0eSIsImNvbG9ySW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJjb2xvciIsInNldFBpeGVsUkdCQSIsInJlZCIsImdyZWVuIiwiYmx1ZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiV2FyaG9sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSAnV2FyaG9sIGVmZmVjdCcgdG8gYW4gaW1hZ2UuXHJcbiAqIFRoZSBiYXNpYyBhcHByb2FjaCBpcyBkZXNjcmliZWQgYXQgaHR0cDovL2NoZW5uYW5uaS5jb20vYXJjaGl2ZXMvMTExMS5cclxuICpcclxuICogU3RlcHMgdG8gJ1dhcmhvbCcgYW4gaW1hZ2U6XHJcbiAqXHJcbiAqIDEuIFNjYWxlIHRoZSBpbWFnZSBieSA1MCUuXHJcbiAqIDIuIENvbnZlcnQgdGhlIGltYWdlIHRvIGdyYXlzY2FsZS5cclxuICogMy4gVXNlIGludGVuc2l0eSBvZiBwaXhlbHMgaW4gdGhlIGdyYXlzY2FsZSBpbWFnZSB0byBtYXAgcGl4ZWxzIHRvIGNvbG9ycy5cclxuICogNC4gRHJhdyB0aGUgY29sb3ItbWFwcGVkIGltYWdlIGludG8gMSBvZiB0aGUgNCBxdWFkcmFudHMuXHJcbiAqIDUuIFJlcGVhdCBzdGVwcyAzICYgNCBmb3IgZWFjaCBxdWFkcmFudCwgdXNpbmcgYSBkaWZmZXJlbnQgY29sb3IgbWFwLlxyXG4gKlxyXG4gKiBAYXV0aG9yIENocmlzIE1hbGxleSAoUGl4ZWxab29tLCBJbmMuKVxyXG4gKi9cclxuXHJcbmltcG9ydCB7IENvbG9yLCBJbWFnZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCB3YXJob2xfcG5nIGZyb20gJy4uLy4uLy4uLy4uL21pcG1hcHMvZnVuY3Rpb25zL3dhcmhvbF9wbmcuanMnO1xyXG5pbXBvcnQgRkJDb25zdGFudHMgZnJvbSAnLi4vLi4vLi4vY29tbW9uL0ZCQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IEltYWdlRnVuY3Rpb24gZnJvbSAnLi4vLi4vLi4vY29tbW9uL21vZGVsL2Z1bmN0aW9ucy9JbWFnZUZ1bmN0aW9uLmpzJztcclxuaW1wb3J0IGZ1bmN0aW9uQnVpbGRlciBmcm9tICcuLi8uLi8uLi9mdW5jdGlvbkJ1aWxkZXIuanMnO1xyXG5pbXBvcnQgRkJDYW52YXNVdGlscyBmcm9tICcuLi9GQkNhbnZhc1V0aWxzLmpzJztcclxuaW1wb3J0IEdyYXlzY2FsZSBmcm9tICcuL0dyYXlzY2FsZS5qcyc7XHJcbmltcG9ydCBJZGVudGl0eSBmcm9tICcuL0lkZW50aXR5LmpzJztcclxuaW1wb3J0IFNocmluayBmcm9tICcuL1Nocmluay5qcyc7XHJcblxyXG4vKipcclxuICogQ29sb3IgbWFwcywgZm9yIG1hcHBpbmcgZ3JheXNjYWxlIGludGVuc2l0eSB0byBSR0IuXHJcbiAqXHJcbiAqIEludGVuc2l0eSByYW5nZSBpcyBbMCwyNTVdLCB3aGVyZSAwIGlzIGRhcmtlc3QsIDI1NSBpcyBicmlnaHRlc3QuIEZvciB0aGUgcHVycG9zZXMgb2YgY29sb3IgbWFwcGluZywgdGhlIGludGVuc2l0eVxyXG4gKiByYW5nZSBpcyBkaXZpZGVkIGludG8gZXF1YWwgJ2JhbmRzJywgYmFzZWQgb24gdGhlIG51bWJlciBvZiBjb2xvcnMgaW4gdGhlIG1hcC4gRWFjaCBwaXhlbCBpbiB0aGUgZ3JheXNjYWxlIGltYWdlXHJcbiAqIGlzIGV4YW1pbmVkLCBpdHMgaW50ZW5zaXR5IGlzIGNvbXB1dGVkLCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgY29sb3IgaXMgdXNlZCBmcm9tIHRoZSBjb2xvciBtYXAuXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCBpZiBDT0xPUl9NQVAgaGFzIDQgY29sb3JzLCB0aGVuIHRoZXJlIHdpbGwgYmUgNCBpbnRlbnNpdHkgYmFuZHMgKDAtNjQsIDY1LTEyNywgMTI4LTE5MiwgMTkzLTI1NSlcclxuICogd2hpY2ggbWFwIHRvIGluZGljZXMgMC0zIChyZXNwZWN0aXZlbHkpIG9mIHRoZSBtYXAuICBJZiBhIHBpeGVsJ3MgaW50ZW5zaXR5IGlzIDY4LCB0aGVuIENPTE9SX01BUFsxXSB3aWxsXHJcbiAqIGJlIHVzZWQgYXMgdGhlIGNvbG9yIGZvciB0aGUgcGl4ZWwuXHJcbiAqXHJcbiAqIEB0eXBlIHtDb2xvcltdfVxyXG4gKi9cclxuY29uc3QgTEVGVF9UT1BfQ09MT1JfTUFQID0gWyBuZXcgQ29sb3IoIDAsIDAsIDI1NSApLCBuZXcgQ29sb3IoIDAsIDI1NSwgMCApLCBuZXcgQ29sb3IoIDI1NSwgMCwgMCApLCBuZXcgQ29sb3IoIDI1NSwgMjU1LCAwICkgXTtcclxuY29uc3QgUklHSFRfVE9QX0NPTE9SX01BUCA9IFsgQ29sb3IuWUVMTE9XLCBDb2xvci5SRUQsIENvbG9yLkdSRUVOLCBuZXcgQ29sb3IoIDQwLCA0MCwgMjU1ICkgXTtcclxuY29uc3QgTEVGVF9CT1RUT01fQ09MT1JfTUFQID0gWyBuZXcgQ29sb3IoIDE5LCAzMSwgMjQgKSwgbmV3IENvbG9yKCA3NiwgNzYsIDc2ICksIENvbG9yLllFTExPVywgQ29sb3IuTUFHRU5UQSBdO1xyXG5jb25zdCBSSUdIVF9CT1RUT01fQ09MT1JfTUFQID0gWyBuZXcgQ29sb3IoIDAsIDEwMCwgMjU1ICksIG5ldyBDb2xvciggMTY1LCAyNTUsIDAgKSwgbmV3IENvbG9yKCAyNTUsIDAsIDEzMiApLCBuZXcgQ29sb3IoIDI1NSwgMjE1LCAxNDAgKSBdO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2FyaG9sIGV4dGVuZHMgSW1hZ2VGdW5jdGlvbiB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvciggb3B0aW9ucyApIHtcclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIG9wdGlvbnMubmFtZSA9ICdXYXJob2wnO1xyXG4gICAgb3B0aW9ucy5maWxsID0gJ3JnYiggMjUwLCAxODYsIDc1ICknO1xyXG4gICAgb3B0aW9ucy5pbnZlcnRpYmxlID0gZmFsc2U7IC8vIGdyYXlzY2FsZSBjb252ZXJzaW9uIGFuZCBpbnRlbnNpdHkgbWFwcGluZyBhcmUgYm90aCBsb3NzeVxyXG5cclxuICAgIGNvbnN0IGljb25Ob2RlID0gbmV3IEltYWdlKCB3YXJob2xfcG5nLCB7IHNjYWxlOiBGQkNvbnN0YW50cy5QQVRURVJOU19GVU5DVElPTl9JQ09OX1NDQUxFIH0gKTtcclxuXHJcbiAgICBzdXBlciggaWNvbk5vZGUsIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy5zaHJpbmsgPSBuZXcgU2hyaW5rKCB7IHNjYWxlOiAwLjUgfSApO1xyXG4gICAgdGhpcy5ncmF5c2NhbGUgPSBuZXcgR3JheXNjYWxlKCk7XHJcbiAgICB0aGlzLmlkZW50aXR5ID0gbmV3IElkZW50aXR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBsaWVzIHRoaXMgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBpbnB1dENhbnZhc1xyXG4gICAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH1cclxuICAgKiBAcHVibGljXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXHJcbiAgYXBwbHlGdW5jdGlvbiggaW5wdXRDYW52YXMgKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLnNocmluayAhPT0gdW5kZWZpbmVkLCAnYXBwbHkgd2FzIGNhbGxlZCBiZWZvcmUgY29uc3RydWN0b3IgY29tcGxldGVkJyApO1xyXG5cclxuICAgIGxldCBvdXRwdXRDYW52YXMgPSBudWxsO1xyXG5cclxuICAgIGlmICggRkJDYW52YXNVdGlscy5pc0JsYW5rKCBpbnB1dENhbnZhcyApICkge1xyXG5cclxuICAgICAgLy8gVGhlIGlucHV0IGNhbnZhcyBpcyBibGFuaywgYXBwbHkgSWRlbnRpdHkgaW5zdGVhZCBvZiBXYXJob2wuXHJcbiAgICAgIG91dHB1dENhbnZhcyA9IHRoaXMuaWRlbnRpdHkuYXBwbHlGdW5jdGlvbiggaW5wdXRDYW52YXMgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgLy8gU2hyaW5rIHRoZSBpbWFnZSBieSA1MCUuXHJcbiAgICAgIC8vIERvIHRoaXMgZmlyc3Qgc28gdGhhdCB3ZSdyZSBwcm9jZXNzaW5nIGZld2VyIHBpeGVscyBpbiBzdWJzZXF1ZW50IG9wZXJhdGlvbnMuXHJcbiAgICAgIGNvbnN0IGhhbGZDYW52YXMgPSB0aGlzLnNocmluay5hcHBseUZ1bmN0aW9uKCBpbnB1dENhbnZhcyApO1xyXG5cclxuICAgICAgLy8gUHV0IHRoZSBpbWFnZSBvbiBhbiBvcGFxdWUgYmFja2dyb3VuZCwgc28gd2UgaGF2ZSBubyB0cmFuc3BhcmVudCBwaXhlbHMuXHJcbiAgICAgIGNvbnN0IG9wYXF1ZUNhbnZhcyA9IEZCQ2FudmFzVXRpbHMuY3JlYXRlQ2FudmFzV2l0aEltYWdlKCBoYWxmQ2FudmFzLCB7XHJcbiAgICAgICAgZmlsbFN0eWxlOiAnd2hpdGUnXHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICAgIC8vIENvbnZlcnQgdGhlIGltYWdlIHRvIGdyYXlzY2FsZVxyXG4gICAgICBjb25zdCBncmF5c2NhbGVDYW52YXMgPSB0aGlzLmdyYXlzY2FsZS5hcHBseUZ1bmN0aW9uKCBvcGFxdWVDYW52YXMgKTtcclxuICAgICAgY29uc3QgZ3JheXNjYWxlRGF0YSA9IEZCQ2FudmFzVXRpbHMuZ2V0SW1hZ2VEYXRhKCBncmF5c2NhbGVDYW52YXMgKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgb3V0cHV0IGNhbnZhcywgd2l0aCBzYW1lIGRpbWVuc2lvbnMgYXMgaW5wdXRDYW52YXNcclxuICAgICAgb3V0cHV0Q2FudmFzID0gRkJDYW52YXNVdGlscy5jcmVhdGVDYW52YXMoIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQgKTtcclxuICAgICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dENhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgYSAnc2NyYXRjaCcgSW1hZ2VEYXRhIHRoYXQgd2lsbCBob2xkIHRoZSByZXN1bHQgb2YgbWFwcGluZyBncmF5c2NhbGUgdG8gY29sb3JzLlxyXG4gICAgICAvLyBUaGlzIGdldHMgcmV1c2VkIGZvciBlYWNoIGNvbG9yIG1hcHBpbmcsIHNvIGJlIHN1cmUgdG8gZHJhdyB0aGUgZGF0YSB0byB0aGUgb3V0cHV0IGNhbnZhc1xyXG4gICAgICAvLyBiZWZvcmUgcHJvY2VlZGluZyB3aXRoIHRoZSBuZXh0IG1hcHBpbmcuXHJcbiAgICAgIGNvbnN0IHNjcmF0Y2hEYXRhID0gaGFsZkNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICkuY3JlYXRlSW1hZ2VEYXRhKCBoYWxmQ2FudmFzLndpZHRoLCBoYWxmQ2FudmFzLmhlaWdodCApO1xyXG5cclxuICAgICAgLy8gRHJhdyBhIGNvbG9yLW1hcHBlZCBpbWFnZSB0byBlYWNoIHF1YWRyYW50IG9mIHRoZSBvdXRwdXQgY2FudmFzLCB1c2luZyBhIGRpZmZlcmVudCBtYXAgaW4gZWFjaCBxdWFkcmFudC5cclxuICAgICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoIGFwcGx5Q29sb3JNYXAoIGdyYXlzY2FsZURhdGEsIHNjcmF0Y2hEYXRhLCBMRUZUX1RPUF9DT0xPUl9NQVAgKSxcclxuICAgICAgICAwLCAwICk7XHJcbiAgICAgIG91dHB1dENvbnRleHQucHV0SW1hZ2VEYXRhKCBhcHBseUNvbG9yTWFwKCBncmF5c2NhbGVEYXRhLCBzY3JhdGNoRGF0YSwgUklHSFRfVE9QX0NPTE9SX01BUCApLFxyXG4gICAgICAgIG91dHB1dENhbnZhcy53aWR0aCAvIDIsIDAgKTtcclxuICAgICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoIGFwcGx5Q29sb3JNYXAoIGdyYXlzY2FsZURhdGEsIHNjcmF0Y2hEYXRhLCBMRUZUX0JPVFRPTV9DT0xPUl9NQVAgKSxcclxuICAgICAgICAwLCBvdXRwdXRDYW52YXMuaGVpZ2h0IC8gMiApO1xyXG4gICAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YSggYXBwbHlDb2xvck1hcCggZ3JheXNjYWxlRGF0YSwgc2NyYXRjaERhdGEsIFJJR0hUX0JPVFRPTV9DT0xPUl9NQVAgKSxcclxuICAgICAgICBvdXRwdXRDYW52YXMud2lkdGggLyAyLCBvdXRwdXRDYW52YXMuaGVpZ2h0IC8gMiApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXRDYW52YXM7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQXBwbGllcyBhIGNvbG9yIG1hcCwgYmFzZWQgb24gaW50ZW5zaXR5IG9mIHRoZSBwaXhlbHMgaW4gdGhlIGlucHV0LlxyXG4gKiBXaGlsZSBpdCdzIHRlbXB0aW5nIHRvIGltcGxlbWVudCB0aGlzIGFzIGEgc3VidHlwZSBvZiBJbWFnZUZ1bmN0aW9uLFxyXG4gKiBkb2luZyBzbyB3b3VsZCBpbmNyZWFzZSB0aGUgbnVtYmVyIG9mIENhbnZhc2VzIGNyZWF0ZWQgd2hlbiBhcHBseWluZyBXYXJob2wuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBpbnB1dERhdGFcclxuICogQHBhcmFtIHtJbWFnZURhdGF9IG91dHB1dERhdGFcclxuICogQHBhcmFtIHtDb2xvcltdfSBjb2xvck1hcFxyXG4gKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxyXG4gKi9cclxuZnVuY3Rpb24gYXBwbHlDb2xvck1hcCggaW5wdXREYXRhLCBvdXRwdXREYXRhLCBjb2xvck1hcCApIHtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBpbnB1dERhdGEuZGF0YS5sZW5ndGggPT09IG91dHB1dERhdGEuZGF0YS5sZW5ndGggKTtcclxuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBpbnB1dERhdGEuZGF0YS5sZW5ndGggLSA0OyBpICs9IDQgKSB7XHJcblxyXG4gICAgLy8gQ29udmVydCBSR0IgKDAtMjU1KSB0byBpbnRlbnNpdHkgKDAtMjU1KSwgdXNpbmcgdGhlIG5vbi1saW5lYXIgbHVtYSBjb2Rpbmcgc2NoZW1lIGVtcGxveWVkIGluIHZpZGVvIHN5c3RlbXNcclxuICAgIC8vIChlLmcuIE5UU0MsIFBBTCwgU0VDQU0pLiAgU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXlzY2FsZSBvciB0aGUgTlRTQyBDQ0lSIDYwMSBzcGVjaWZpY2F0aW9uLlxyXG4gICAgY29uc3QgaW50ZW5zaXR5ID0gMC4yOTg5ICogaW5wdXREYXRhLmRhdGFbIGkgXSArIDAuNTg3MCAqIGlucHV0RGF0YS5kYXRhWyBpICsgMSBdICsgMC4xMTQwICogaW5wdXREYXRhLmRhdGFbIGkgKyAyIF07XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBpbnRlbnNpdHkgPj0gMCAmJiBpbnRlbnNpdHkgPD0gMjU1LCBgaW50ZW5zaXR5IG91dCBvZiByYW5nZTogJHtpbnRlbnNpdHl9YCApO1xyXG5cclxuICAgIC8vIG1hcCBpbnRlbnNpdHkgdG8gYSBjb2xvciBtYXBcclxuICAgIGNvbnN0IGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKCBpbnRlbnNpdHkgLyAoIDI1NiAvIGNvbG9yTWFwLmxlbmd0aCApICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBjb2xvckluZGV4ID49IDAgJiYgY29sb3JJbmRleCA8IGNvbG9yTWFwLmxlbmd0aCwgYGNvbG9ySW5kZXggb3V0IG9mIHJhbmdlOiAke2NvbG9ySW5kZXh9YCApO1xyXG5cclxuICAgIC8vIGFwcGx5IHRoZSBjb2xvciBtYXBcclxuICAgIGNvbnN0IGNvbG9yID0gY29sb3JNYXBbIGNvbG9ySW5kZXggXTtcclxuICAgIEZCQ2FudmFzVXRpbHMuc2V0UGl4ZWxSR0JBKCBvdXRwdXREYXRhLCBpLCBjb2xvci5yZWQsIGNvbG9yLmdyZWVuLCBjb2xvci5ibHVlLCBpbnB1dERhdGEuZGF0YVsgaSArIDMgXSApO1xyXG4gIH1cclxuICByZXR1cm4gb3V0cHV0RGF0YTtcclxufVxyXG5cclxuLy8gQHB1YmxpYyBmb3IgdXNlIGJ5IEZCSWNvbkZhY3RvcnkuY3JlYXRlUGF0dGVybnNTY3JlZW5JY29uXHJcbldhcmhvbC5MRUZUX1RPUF9DT0xPUl9NQVAgPSBMRUZUX1RPUF9DT0xPUl9NQVA7XHJcbldhcmhvbC5SSUdIVF9UT1BfQ09MT1JfTUFQID0gUklHSFRfVE9QX0NPTE9SX01BUDtcclxuV2FyaG9sLkxFRlRfQk9UVE9NX0NPTE9SX01BUCA9IExFRlRfQk9UVE9NX0NPTE9SX01BUDtcclxuV2FyaG9sLlJJR0hUX0JPVFRPTV9DT0xPUl9NQVAgPSBSSUdIVF9CT1RUT01fQ09MT1JfTUFQO1xyXG5cclxuZnVuY3Rpb25CdWlsZGVyLnJlZ2lzdGVyKCAnV2FyaG9sJywgV2FyaG9sICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVNBLEtBQUssRUFBRUMsS0FBSyxRQUFRLHNDQUFzQztBQUNuRSxPQUFPQyxVQUFVLE1BQU0sNkNBQTZDO0FBQ3BFLE9BQU9DLFdBQVcsTUFBTSxnQ0FBZ0M7QUFDeEQsT0FBT0MsYUFBYSxNQUFNLGtEQUFrRDtBQUM1RSxPQUFPQyxlQUFlLE1BQU0sNkJBQTZCO0FBQ3pELE9BQU9DLGFBQWEsTUFBTSxxQkFBcUI7QUFDL0MsT0FBT0MsU0FBUyxNQUFNLGdCQUFnQjtBQUN0QyxPQUFPQyxRQUFRLE1BQU0sZUFBZTtBQUNwQyxPQUFPQyxNQUFNLE1BQU0sYUFBYTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxrQkFBa0IsR0FBRyxDQUFFLElBQUlWLEtBQUssQ0FBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUksQ0FBQyxFQUFFLElBQUlBLEtBQUssQ0FBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUUsQ0FBQyxFQUFFLElBQUlBLEtBQUssQ0FBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUUsQ0FBQyxFQUFFLElBQUlBLEtBQUssQ0FBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUUsQ0FBQyxDQUFFO0FBQy9ILE1B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