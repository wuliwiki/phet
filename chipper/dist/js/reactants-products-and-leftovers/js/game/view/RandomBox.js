// Copyright 2014-2023, University of Colorado Boulder

/**
 * Displays substances at random positions in a box.
 * This is used for the 'Before' and 'After' boxes in the Game screen.
 *
 * To improve performance:
 * - Nodes are created as needed.
 * - Nodes are never removed; they remain as children for the lifetime of this node.
 * - The visibility of nodes is adjusted to show the correct quantity of the substance.
 * - When a node becomes visible, it is assigned a position in the grid.
 */

import Dimension2 from '../../../../dot/js/Dimension2.js';
import dotRandom from '../../../../dot/js/dotRandom.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import optionize from '../../../../phet-core/js/optionize.js';
import { Node, Rectangle } from '../../../../scenery/js/imports.js';
import RPALColors from '../../common/RPALColors.js';
import SubstanceIcon from '../../common/view/SubstanceIcon.js';
import reactantsProductsAndLeftovers from '../../reactantsProductsAndLeftovers.js';
const DEFAULT_BOX_SIZE = new Dimension2(100, 100);
export default class RandomBox extends Node {
  constructor(substances, providedOptions) {
    const options = optionize()({
      // SelfOptions
      boxSize: DEFAULT_BOX_SIZE,
      maxQuantity: 4,
      cornerRadius: 3,
      fill: RPALColors.BOX_FILL,
      stroke: RPALColors.BOX_STROKE,
      margin: 5,
      randomOffset: 8
    }, providedOptions);

    /*
     * Compute the size of the grid needed to accommodate the maximum number of nodes.
     * Assume that the box is square-ish, so can have the same number of rows and columns.
     */
    const rows = Utils.roundSymmetric(Math.sqrt(substances.length * options.maxQuantity));
    const columns = rows;

    // Compute positions in the grid, this is our 'pool' of positions.
    const positions = [];
    const dx = Math.floor((options.boxSize.width - 2 * options.margin - 2 * options.randomOffset) / columns);
    const dy = Math.floor((options.boxSize.height - 2 * options.margin - 2 * options.randomOffset) / rows);
    for (let column = 0; column < columns; column++) {
      for (let row = 0; row < rows; row++) {
        const x = options.margin + options.randomOffset + dx / 2 + column * dx;
        const y = options.margin + options.randomOffset + dy / 2 + row * dy;
        positions.push(new Vector2(x, y));
      }
    }
    assert && assert(positions.length === rows * columns);

    // Chooses a random position and remove it from the pool of positions.
    const choosePosition = () => {
      assert && assert(positions.length > 0);
      const index = dotRandom.nextIntBetween(0, positions.length - 1);
      const position = positions[index];
      positions.splice(index, 1);
      return position;
    };

    // Puts a position back in the pool of positions.
    const releasePosition = position => positions.push(position);

    // the box
    const boxNode = new Rectangle(0, 0, options.boxSize.width, options.boxSize.height, options.cornerRadius, options.cornerRadius, {
      fill: options.fill,
      stroke: options.stroke
    });

    // substances inside the box
    const substanceLayers = [];
    const parent = new Node();
    substances.forEach(substance => {
      const substanceLayer = new SubstanceLayer(substance.iconProperty, substance.quantityProperty, options.randomOffset, choosePosition, releasePosition);
      parent.addChild(substanceLayer);
      substanceLayers.push(substanceLayer);
    });
    options.children = [boxNode, parent];
    super(options);
    this.disposeRandomBox = () => {
      substanceLayers.forEach(node => node.dispose());
      substanceLayers.length = 0;
    };
  }
  dispose() {
    this.disposeRandomBox();
    super.dispose();
  }
}

/**
 * Responsible for managing all nodes for one substance type.
 */
class SubstanceLayer extends Node {
  constructor(iconProperty, quantityProperty, randomOffset, choosePosition, releasePosition) {
    super();
    const cellNodes = [];
    const quantityPropertyObserver = quantity => {
      const count = Math.max(quantity, cellNodes.length);
      for (let i = 0; i < count; i++) {
        if (i < this.getChildrenCount()) {
          // node already exists
          const node = cellNodes[i];
          const nodeWasVisible = node.visible;
          node.visible = i < quantity;
          if (node.visible && !nodeWasVisible) {
            // when an existing node becomes visible, choose a new position for it
            node.setGridPosition(choosePosition());
          } else if (!node.visible && nodeWasVisible) {
            // when a visible node becomes invisible, make its position available
            releasePosition(node.getGridPosition());
          }
        } else {
          // add a node
          const cellNode = new CellNode(iconProperty, choosePosition(), randomOffset);
          this.addChild(cellNode);
          cellNodes.push(cellNode);
        }
      }
    };
    quantityProperty.link(quantityPropertyObserver); // must be unlinked in dispose

    this.disposeSubstanceLayer = () => {
      cellNodes.forEach(node => node.dispose()); // also does removeChild
      cellNodes.length = 0;
      quantityProperty.unlink(quantityPropertyObserver);
    };
  }
  dispose() {
    this.disposeSubstanceLayer();
    super.dispose();
  }
}

/**
 * Icon that occupies a cell in the grid, randomizes its position to make the grid look less regular.
 */
class CellNode extends SubstanceIcon {
  constructor(iconProperty, gridPosition, randomOffset) {
    super(iconProperty);
    this.gridPosition = gridPosition;
    this.randomOffset = randomOffset;
    this.setGridPosition(gridPosition); // initialize position
  }

  /**
   * Gets the grid position.
   */
  getGridPosition() {
    return this.gridPosition;
  }

  /**
   * Sets the grid position.
   */
  setGridPosition(gridPosition) {
    this.gridPosition = gridPosition;
    // Move this node to the specified grid position, with some randomized offset.
    this.centerX = gridPosition.x + dotRandom.nextIntBetween(-this.randomOffset, this.randomOffset);
    this.centerY = gridPosition.y + dotRandom.nextIntBetween(-this.randomOffset, this.randomOffset);
  }
}
reactantsProductsAndLeftovers.register('RandomBox', RandomBox);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEaW1lbnNpb24yIiwiZG90UmFuZG9tIiwiVXRpbHMiLCJWZWN0b3IyIiwib3B0aW9uaXplIiwiTm9kZSIsIlJlY3RhbmdsZSIsIlJQQUxDb2xvcnMiLCJTdWJzdGFuY2VJY29uIiwicmVhY3RhbnRzUHJvZHVjdHNBbmRMZWZ0b3ZlcnMiLCJERUZBVUxUX0JPWF9TSVpFIiwiUmFuZG9tQm94IiwiY29uc3RydWN0b3IiLCJzdWJzdGFuY2VzIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsImJveFNpemUiLCJtYXhRdWFudGl0eSIsImNvcm5lclJhZGl1cyIsImZpbGwiLCJCT1hfRklMTCIsInN0cm9rZSIsIkJPWF9TVFJPS0UiLCJtYXJnaW4iLCJyYW5kb21PZmZzZXQiLCJyb3dzIiwicm91bmRTeW1tZXRyaWMiLCJNYXRoIiwic3FydCIsImxlbmd0aCIsImNvbHVtbnMiLCJwb3NpdGlvbnMiLCJkeCIsImZsb29yIiwid2lkdGgiLCJkeSIsImhlaWdodCIsImNvbHVtbiIsInJvdyIsIngiLCJ5IiwicHVzaCIsImFzc2VydCIsImNob29zZVBvc2l0aW9uIiwiaW5kZXgiLCJuZXh0SW50QmV0d2VlbiIsInBvc2l0aW9uIiwic3BsaWNlIiwicmVsZWFzZVBvc2l0aW9uIiwiYm94Tm9kZSIsInN1YnN0YW5jZUxheWVycyIsInBhcmVudCIsImZvckVhY2giLCJzdWJzdGFuY2UiLCJzdWJzdGFuY2VMYXllciIsIlN1YnN0YW5jZUxheWVyIiwiaWNvblByb3BlcnR5IiwicXVhbnRpdHlQcm9wZXJ0eSIsImFkZENoaWxkIiwiY2hpbGRyZW4iLCJkaXNwb3NlUmFuZG9tQm94Iiwibm9kZSIsImRpc3Bvc2UiLCJjZWxsTm9kZXMiLCJxdWFudGl0eVByb3BlcnR5T2JzZXJ2ZXIiLCJxdWFudGl0eSIsImNvdW50IiwibWF4IiwiaSIsImdldENoaWxkcmVuQ291bnQiLCJub2RlV2FzVmlzaWJsZSIsInZpc2libGUiLCJzZXRHcmlkUG9zaXRpb24iLCJnZXRHcmlkUG9zaXRpb24iLCJjZWxsTm9kZSIsIkNlbGxOb2RlIiwibGluayIsImRpc3Bvc2VTdWJzdGFuY2VMYXllciIsInVubGluayIsImdyaWRQb3NpdGlvbiIsImNlbnRlclgiLCJjZW50ZXJZIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJSYW5kb21Cb3gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTQtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogRGlzcGxheXMgc3Vic3RhbmNlcyBhdCByYW5kb20gcG9zaXRpb25zIGluIGEgYm94LlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIHRoZSAnQmVmb3JlJyBhbmQgJ0FmdGVyJyBib3hlcyBpbiB0aGUgR2FtZSBzY3JlZW4uXHJcbiAqXHJcbiAqIFRvIGltcHJvdmUgcGVyZm9ybWFuY2U6XHJcbiAqIC0gTm9kZXMgYXJlIGNyZWF0ZWQgYXMgbmVlZGVkLlxyXG4gKiAtIE5vZGVzIGFyZSBuZXZlciByZW1vdmVkOyB0aGV5IHJlbWFpbiBhcyBjaGlsZHJlbiBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoaXMgbm9kZS5cclxuICogLSBUaGUgdmlzaWJpbGl0eSBvZiBub2RlcyBpcyBhZGp1c3RlZCB0byBzaG93IHRoZSBjb3JyZWN0IHF1YW50aXR5IG9mIHRoZSBzdWJzdGFuY2UuXHJcbiAqIC0gV2hlbiBhIG5vZGUgYmVjb21lcyB2aXNpYmxlLCBpdCBpcyBhc3NpZ25lZCBhIHBvc2l0aW9uIGluIHRoZSBncmlkLlxyXG4gKi9cclxuXHJcbmltcG9ydCBUUmVhZE9ubHlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1RSZWFkT25seVByb3BlcnR5LmpzJztcclxuaW1wb3J0IERpbWVuc2lvbjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL0RpbWVuc2lvbjIuanMnO1xyXG5pbXBvcnQgZG90UmFuZG9tIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9kb3RSYW5kb20uanMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgeyBOb2RlLCBOb2RlT3B0aW9ucywgTm9kZVRyYW5zbGF0aW9uT3B0aW9ucywgUmVjdGFuZ2xlLCBUQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgU3Vic3RhbmNlIGZyb20gJy4uLy4uL2NvbW1vbi9tb2RlbC9TdWJzdGFuY2UuanMnO1xyXG5pbXBvcnQgUlBBTENvbG9ycyBmcm9tICcuLi8uLi9jb21tb24vUlBBTENvbG9ycy5qcyc7XHJcbmltcG9ydCBTdWJzdGFuY2VJY29uIGZyb20gJy4uLy4uL2NvbW1vbi92aWV3L1N1YnN0YW5jZUljb24uanMnO1xyXG5pbXBvcnQgcmVhY3RhbnRzUHJvZHVjdHNBbmRMZWZ0b3ZlcnMgZnJvbSAnLi4vLi4vcmVhY3RhbnRzUHJvZHVjdHNBbmRMZWZ0b3ZlcnMuanMnO1xyXG5cclxuY29uc3QgREVGQVVMVF9CT1hfU0laRSA9IG5ldyBEaW1lbnNpb24yKCAxMDAsIDEwMCApO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuICBib3hTaXplPzogRGltZW5zaW9uMjtcclxuICBtYXhRdWFudGl0eT86IG51bWJlcjsgLy8gdGhlIG1heGltdW0gcXVhbnRpdHkgb2YgZWFjaCBzdWJzdGFuY2UgaW4gdGhlIGJveFxyXG4gIGNvcm5lclJhZGl1cz86IG51bWJlcjtcclxuICBmaWxsPzogVENvbG9yO1xyXG4gIHN0cm9rZT86IFRDb2xvcjtcclxuICBtYXJnaW4/OiBudW1iZXI7IC8vIG1hcmdpbiBhcm91bmQgdGhlIGluc2lkZSBlZGdlIG9mIHRoZSBib3hcclxuXHJcbiAgLy8gTW9sZWN1bGVzIGluIHRoZSBib3ggYXJlIGFycmFuZ2VkIGluIGEgZ3JpZC4gVGhpcyBvcHRpb24gY29udHJvbHMgaG93IG11Y2ggdGhlIG1vbGVjdWxlcyBhcmUgcmFuZG9tbHkgb2Zmc2V0XHJcbiAgLy8gZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBncmlkJ3MgY2VsbHMuIEhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgbGF5b3V0IGxvb2sgbGVzcyBncmlkLWxpa2UsIGJ1dCByZXN1bHQgaW4gbW9yZVxyXG4gIC8vIG92ZXJsYXAgb2YgbW9sZWN1bGVzIChhIHRyYWRlLW9mZikuXHJcbiAgcmFuZG9tT2Zmc2V0PzogbnVtYmVyO1xyXG59O1xyXG5cclxudHlwZSBSYW5kb21Cb3hPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBOb2RlVHJhbnNsYXRpb25PcHRpb25zO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFuZG9tQm94IGV4dGVuZHMgTm9kZSB7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgZGlzcG9zZVJhbmRvbUJveDogKCkgPT4gdm9pZDtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBzdWJzdGFuY2VzOiBTdWJzdGFuY2VbXSwgcHJvdmlkZWRPcHRpb25zPzogUmFuZG9tQm94T3B0aW9ucyApIHtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uaXplPFJhbmRvbUJveE9wdGlvbnMsIFNlbGZPcHRpb25zLCBOb2RlT3B0aW9ucz4oKSgge1xyXG5cclxuICAgICAgLy8gU2VsZk9wdGlvbnNcclxuICAgICAgYm94U2l6ZTogREVGQVVMVF9CT1hfU0laRSxcclxuICAgICAgbWF4UXVhbnRpdHk6IDQsXHJcbiAgICAgIGNvcm5lclJhZGl1czogMyxcclxuICAgICAgZmlsbDogUlBBTENvbG9ycy5CT1hfRklMTCxcclxuICAgICAgc3Ryb2tlOiBSUEFMQ29sb3JzLkJPWF9TVFJPS0UsXHJcbiAgICAgIG1hcmdpbjogNSxcclxuICAgICAgcmFuZG9tT2Zmc2V0OiA4XHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgc2l6ZSBvZiB0aGUgZ3JpZCBuZWVkZWQgdG8gYWNjb21tb2RhdGUgdGhlIG1heGltdW0gbnVtYmVyIG9mIG5vZGVzLlxyXG4gICAgICogQXNzdW1lIHRoYXQgdGhlIGJveCBpcyBzcXVhcmUtaXNoLCBzbyBjYW4gaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucy5cclxuICAgICAqL1xyXG4gICAgY29uc3Qgcm93cyA9IFV0aWxzLnJvdW5kU3ltbWV0cmljKCBNYXRoLnNxcnQoIHN1YnN0YW5jZXMubGVuZ3RoICogb3B0aW9ucy5tYXhRdWFudGl0eSApICk7XHJcbiAgICBjb25zdCBjb2x1bW5zID0gcm93cztcclxuXHJcbiAgICAvLyBDb21wdXRlIHBvc2l0aW9ucyBpbiB0aGUgZ3JpZCwgdGhpcyBpcyBvdXIgJ3Bvb2wnIG9mIHBvc2l0aW9ucy5cclxuICAgIGNvbnN0IHBvc2l0aW9uczogVmVjdG9yMltdID0gW107XHJcbiAgICBjb25zdCBkeCA9IE1hdGguZmxvb3IoICggb3B0aW9ucy5ib3hTaXplLndpZHRoIC0gKCAyICogb3B0aW9ucy5tYXJnaW4gKSAtICggMiAqIG9wdGlvbnMucmFuZG9tT2Zmc2V0ICkgKSAvIGNvbHVtbnMgKTtcclxuICAgIGNvbnN0IGR5ID0gTWF0aC5mbG9vciggKCBvcHRpb25zLmJveFNpemUuaGVpZ2h0IC0gKCAyICogb3B0aW9ucy5tYXJnaW4gKSAtICggMiAqIG9wdGlvbnMucmFuZG9tT2Zmc2V0ICkgKSAvIHJvd3MgKTtcclxuICAgIGZvciAoIGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCBjb2x1bW5zOyBjb2x1bW4rKyApIHtcclxuICAgICAgZm9yICggbGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7IHJvdysrICkge1xyXG4gICAgICAgIGNvbnN0IHggPSBvcHRpb25zLm1hcmdpbiArIG9wdGlvbnMucmFuZG9tT2Zmc2V0ICsgKCBkeCAvIDIgKSArICggY29sdW1uICogZHggKTtcclxuICAgICAgICBjb25zdCB5ID0gb3B0aW9ucy5tYXJnaW4gKyBvcHRpb25zLnJhbmRvbU9mZnNldCArICggZHkgLyAyICkgKyAoIHJvdyAqIGR5ICk7XHJcbiAgICAgICAgcG9zaXRpb25zLnB1c2goIG5ldyBWZWN0b3IyKCB4LCB5ICkgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggcG9zaXRpb25zLmxlbmd0aCA9PT0gcm93cyAqIGNvbHVtbnMgKTtcclxuXHJcbiAgICAvLyBDaG9vc2VzIGEgcmFuZG9tIHBvc2l0aW9uIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcG9vbCBvZiBwb3NpdGlvbnMuXHJcbiAgICBjb25zdCBjaG9vc2VQb3NpdGlvbiA9ICgpID0+IHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggcG9zaXRpb25zLmxlbmd0aCA+IDAgKTtcclxuICAgICAgY29uc3QgaW5kZXggPSBkb3RSYW5kb20ubmV4dEludEJldHdlZW4oIDAsIHBvc2l0aW9ucy5sZW5ndGggLSAxICk7XHJcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25zWyBpbmRleCBdO1xyXG4gICAgICBwb3NpdGlvbnMuc3BsaWNlKCBpbmRleCwgMSApO1xyXG4gICAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFB1dHMgYSBwb3NpdGlvbiBiYWNrIGluIHRoZSBwb29sIG9mIHBvc2l0aW9ucy5cclxuICAgIGNvbnN0IHJlbGVhc2VQb3NpdGlvbiA9ICggcG9zaXRpb246IFZlY3RvcjIgKSA9PiBwb3NpdGlvbnMucHVzaCggcG9zaXRpb24gKTtcclxuXHJcbiAgICAvLyB0aGUgYm94XHJcbiAgICBjb25zdCBib3hOb2RlID0gbmV3IFJlY3RhbmdsZSggMCwgMCwgb3B0aW9ucy5ib3hTaXplLndpZHRoLCBvcHRpb25zLmJveFNpemUuaGVpZ2h0LCBvcHRpb25zLmNvcm5lclJhZGl1cywgb3B0aW9ucy5jb3JuZXJSYWRpdXMsIHtcclxuICAgICAgZmlsbDogb3B0aW9ucy5maWxsLFxyXG4gICAgICBzdHJva2U6IG9wdGlvbnMuc3Ryb2tlXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gc3Vic3RhbmNlcyBpbnNpZGUgdGhlIGJveFxyXG4gICAgY29uc3Qgc3Vic3RhbmNlTGF5ZXJzOiBTdWJzdGFuY2VMYXllcltdID0gW107XHJcbiAgICBjb25zdCBwYXJlbnQgPSBuZXcgTm9kZSgpO1xyXG4gICAgc3Vic3RhbmNlcy5mb3JFYWNoKCBzdWJzdGFuY2UgPT4ge1xyXG4gICAgICBjb25zdCBzdWJzdGFuY2VMYXllciA9IG5ldyBTdWJzdGFuY2VMYXllciggc3Vic3RhbmNlLmljb25Qcm9wZXJ0eSwgc3Vic3RhbmNlLnF1YW50aXR5UHJvcGVydHksXHJcbiAgICAgICAgb3B0aW9ucy5yYW5kb21PZmZzZXQsIGNob29zZVBvc2l0aW9uLCByZWxlYXNlUG9zaXRpb24gKTtcclxuICAgICAgcGFyZW50LmFkZENoaWxkKCBzdWJzdGFuY2VMYXllciApO1xyXG4gICAgICBzdWJzdGFuY2VMYXllcnMucHVzaCggc3Vic3RhbmNlTGF5ZXIgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICBvcHRpb25zLmNoaWxkcmVuID0gWyBib3hOb2RlLCBwYXJlbnQgXTtcclxuXHJcbiAgICBzdXBlciggb3B0aW9ucyApO1xyXG5cclxuICAgIHRoaXMuZGlzcG9zZVJhbmRvbUJveCA9ICgpID0+IHtcclxuICAgICAgc3Vic3RhbmNlTGF5ZXJzLmZvckVhY2goIG5vZGUgPT4gbm9kZS5kaXNwb3NlKCkgKTtcclxuICAgICAgc3Vic3RhbmNlTGF5ZXJzLmxlbmd0aCA9IDA7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLmRpc3Bvc2VSYW5kb21Cb3goKTtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgYWxsIG5vZGVzIGZvciBvbmUgc3Vic3RhbmNlIHR5cGUuXHJcbiAqL1xyXG5jbGFzcyBTdWJzdGFuY2VMYXllciBleHRlbmRzIE5vZGUge1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGRpc3Bvc2VTdWJzdGFuY2VMYXllcjogKCkgPT4gdm9pZDtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBpY29uUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PE5vZGU+LCBxdWFudGl0eVByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxudW1iZXI+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgcmFuZG9tT2Zmc2V0OiBudW1iZXIsIGNob29zZVBvc2l0aW9uOiAoKSA9PiBWZWN0b3IyLCByZWxlYXNlUG9zaXRpb246ICggcG9zaXRpb246IFZlY3RvcjIgKSA9PiB2b2lkICkge1xyXG5cclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgY29uc3QgY2VsbE5vZGVzOiBDZWxsTm9kZVtdID0gW107XHJcblxyXG4gICAgY29uc3QgcXVhbnRpdHlQcm9wZXJ0eU9ic2VydmVyID0gKCBxdWFudGl0eTogbnVtYmVyICkgPT4ge1xyXG5cclxuICAgICAgY29uc3QgY291bnQgPSBNYXRoLm1heCggcXVhbnRpdHksIGNlbGxOb2Rlcy5sZW5ndGggKTtcclxuXHJcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGNvdW50OyBpKysgKSB7XHJcblxyXG4gICAgICAgIGlmICggaSA8IHRoaXMuZ2V0Q2hpbGRyZW5Db3VudCgpICkge1xyXG5cclxuICAgICAgICAgIC8vIG5vZGUgYWxyZWFkeSBleGlzdHNcclxuICAgICAgICAgIGNvbnN0IG5vZGUgPSBjZWxsTm9kZXNbIGkgXTtcclxuICAgICAgICAgIGNvbnN0IG5vZGVXYXNWaXNpYmxlID0gbm9kZS52aXNpYmxlO1xyXG4gICAgICAgICAgbm9kZS52aXNpYmxlID0gKCBpIDwgcXVhbnRpdHkgKTtcclxuXHJcbiAgICAgICAgICBpZiAoIG5vZGUudmlzaWJsZSAmJiAhbm9kZVdhc1Zpc2libGUgKSB7XHJcbiAgICAgICAgICAgIC8vIHdoZW4gYW4gZXhpc3Rpbmcgbm9kZSBiZWNvbWVzIHZpc2libGUsIGNob29zZSBhIG5ldyBwb3NpdGlvbiBmb3IgaXRcclxuICAgICAgICAgICAgbm9kZS5zZXRHcmlkUG9zaXRpb24oIGNob29zZVBvc2l0aW9uKCkgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKCAhbm9kZS52aXNpYmxlICYmIG5vZGVXYXNWaXNpYmxlICkge1xyXG4gICAgICAgICAgICAvLyB3aGVuIGEgdmlzaWJsZSBub2RlIGJlY29tZXMgaW52aXNpYmxlLCBtYWtlIGl0cyBwb3NpdGlvbiBhdmFpbGFibGVcclxuICAgICAgICAgICAgcmVsZWFzZVBvc2l0aW9uKCBub2RlLmdldEdyaWRQb3NpdGlvbigpICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIGFkZCBhIG5vZGVcclxuICAgICAgICAgIGNvbnN0IGNlbGxOb2RlID0gbmV3IENlbGxOb2RlKCBpY29uUHJvcGVydHksIGNob29zZVBvc2l0aW9uKCksIHJhbmRvbU9mZnNldCApO1xyXG4gICAgICAgICAgdGhpcy5hZGRDaGlsZCggY2VsbE5vZGUgKTtcclxuICAgICAgICAgIGNlbGxOb2Rlcy5wdXNoKCBjZWxsTm9kZSApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHF1YW50aXR5UHJvcGVydHkubGluayggcXVhbnRpdHlQcm9wZXJ0eU9ic2VydmVyICk7IC8vIG11c3QgYmUgdW5saW5rZWQgaW4gZGlzcG9zZVxyXG5cclxuICAgIHRoaXMuZGlzcG9zZVN1YnN0YW5jZUxheWVyID0gKCkgPT4ge1xyXG4gICAgICBjZWxsTm9kZXMuZm9yRWFjaCggbm9kZSA9PiBub2RlLmRpc3Bvc2UoKSApOyAvLyBhbHNvIGRvZXMgcmVtb3ZlQ2hpbGRcclxuICAgICAgY2VsbE5vZGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgIHF1YW50aXR5UHJvcGVydHkudW5saW5rKCBxdWFudGl0eVByb3BlcnR5T2JzZXJ2ZXIgKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgb3ZlcnJpZGUgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuZGlzcG9zZVN1YnN0YW5jZUxheWVyKCk7XHJcbiAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSWNvbiB0aGF0IG9jY3VwaWVzIGEgY2VsbCBpbiB0aGUgZ3JpZCwgcmFuZG9taXplcyBpdHMgcG9zaXRpb24gdG8gbWFrZSB0aGUgZ3JpZCBsb29rIGxlc3MgcmVndWxhci5cclxuICovXHJcbmNsYXNzIENlbGxOb2RlIGV4dGVuZHMgU3Vic3RhbmNlSWNvbiB7XHJcblxyXG4gIHByaXZhdGUgZ3JpZFBvc2l0aW9uOiBWZWN0b3IyO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgcmFuZG9tT2Zmc2V0OiBudW1iZXI7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciggaWNvblByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxOb2RlPiwgZ3JpZFBvc2l0aW9uOiBWZWN0b3IyLCByYW5kb21PZmZzZXQ6IG51bWJlciApIHtcclxuXHJcbiAgICBzdXBlciggaWNvblByb3BlcnR5ICk7XHJcblxyXG4gICAgdGhpcy5ncmlkUG9zaXRpb24gPSBncmlkUG9zaXRpb247XHJcbiAgICB0aGlzLnJhbmRvbU9mZnNldCA9IHJhbmRvbU9mZnNldDtcclxuXHJcbiAgICB0aGlzLnNldEdyaWRQb3NpdGlvbiggZ3JpZFBvc2l0aW9uICk7IC8vIGluaXRpYWxpemUgcG9zaXRpb25cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGdyaWQgcG9zaXRpb24uXHJcbiAgICovXHJcbiAgcHVibGljIGdldEdyaWRQb3NpdGlvbigpOiBWZWN0b3IyIHtcclxuICAgIHJldHVybiB0aGlzLmdyaWRQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGdyaWQgcG9zaXRpb24uXHJcbiAgICovXHJcbiAgcHVibGljIHNldEdyaWRQb3NpdGlvbiggZ3JpZFBvc2l0aW9uOiBWZWN0b3IyICk6IHZvaWQge1xyXG4gICAgdGhpcy5ncmlkUG9zaXRpb24gPSBncmlkUG9zaXRpb247XHJcbiAgICAvLyBNb3ZlIHRoaXMgbm9kZSB0byB0aGUgc3BlY2lmaWVkIGdyaWQgcG9zaXRpb24sIHdpdGggc29tZSByYW5kb21pemVkIG9mZnNldC5cclxuICAgIHRoaXMuY2VudGVyWCA9IGdyaWRQb3NpdGlvbi54ICsgZG90UmFuZG9tLm5leHRJbnRCZXR3ZWVuKCAtdGhpcy5yYW5kb21PZmZzZXQsIHRoaXMucmFuZG9tT2Zmc2V0ICk7XHJcbiAgICB0aGlzLmNlbnRlclkgPSBncmlkUG9zaXRpb24ueSArIGRvdFJhbmRvbS5uZXh0SW50QmV0d2VlbiggLXRoaXMucmFuZG9tT2Zmc2V0LCB0aGlzLnJhbmRvbU9mZnNldCApO1xyXG4gIH1cclxufVxyXG5cclxucmVhY3RhbnRzUHJvZHVjdHNBbmRMZWZ0b3ZlcnMucmVnaXN0ZXIoICdSYW5kb21Cb3gnLCBSYW5kb21Cb3ggKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBLE9BQU9BLFVBQVUsTUFBTSxrQ0FBa0M7QUFDekQsT0FBT0MsU0FBUyxNQUFNLGlDQUFpQztBQUN2RCxPQUFPQyxLQUFLLE1BQU0sNkJBQTZCO0FBQy9DLE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsU0FBUyxNQUFNLHVDQUF1QztBQUM3RCxTQUFTQyxJQUFJLEVBQXVDQyxTQUFTLFFBQWdCLG1DQUFtQztBQUVoSCxPQUFPQyxVQUFVLE1BQU0sNEJBQTRCO0FBQ25ELE9BQU9DLGFBQWEsTUFBTSxvQ0FBb0M7QUFDOUQsT0FBT0Ms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