// Copyright 2018-2021, University of Colorado Boulder

/**
 * Draw the dots in the wire with a CanvasNode as a performance enhancement. This is much faster than drawing
 * each dot as a Circle node and updating their visibility. Dots are redrawn whenever model Properties change that
 * might change the shape of the wire or add or remove dots (length, area, resistivity).
 *
 * @author Jesse Greenberg
 */

import Bounds2 from '../../../../dot/js/Bounds2.js';
import dotRandom from '../../../../dot/js/dotRandom.js';
import LinearFunction from '../../../../dot/js/LinearFunction.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import merge from '../../../../phet-core/js/merge.js';
import { CanvasNode } from '../../../../scenery/js/imports.js';
import resistanceInAWire from '../../resistanceInAWire.js';
import ResistanceInAWireConstants from '../ResistanceInAWireConstants.js';
import WireShapeConstants from './WireShapeConstants.js';

// constants
// to calculate the number of dots
const MAX_WIDTH_INCLUDING_ROUNDED_ENDS = WireShapeConstants.WIRE_VIEW_WIDTH_RANGE.max + 2 * WireShapeConstants.WIRE_VIEW_HEIGHT_RANGE.max * WireShapeConstants.PERSPECTIVE_FACTOR;
const AREA_PER_DOT = 200; // Adjust this to control the density of the dots.
const NUMBER_OF_DOTS = MAX_WIDTH_INCLUDING_ROUNDED_ENDS * WireShapeConstants.WIRE_VIEW_HEIGHT_RANGE.max / AREA_PER_DOT;

// Function to map resistivity to number of dots.
const resistivityToNumberOfDots = new LinearFunction(ResistanceInAWireConstants.RESISTIVITY_RANGE.min, ResistanceInAWireConstants.RESISTIVITY_RANGE.max, NUMBER_OF_DOTS * 0.05, NUMBER_OF_DOTS, true);
class DotsCanvasNode extends CanvasNode {
  /**
   * @param {Bounds2} bounds - total bounds for the canvas
   * @param {Object} [options]
   */
  constructor(model, options) {
    options = merge({
      preventFit: true // don't recompute bounds as a performance enhancement
    }, options);

    // calculate bounds for the canvas - wire center is at (0, 0)
    const height = WireShapeConstants.areaToHeight(ResistanceInAWireConstants.AREA_RANGE.max);
    const width = WireShapeConstants.lengthToWidth.evaluate(ResistanceInAWireConstants.LENGTH_RANGE.max);
    const dotsBounds = new Bounds2(-width / 2 - WireShapeConstants.PERSPECTIVE_FACTOR * height / 2, -height / 2, width / 2 + WireShapeConstants.PERSPECTIVE_FACTOR * height / 2, height / 2);
    super(options);

    // @private - Positions for dots randomly on the wire. Density is based on AREA_PER_DOT.
    this.dotCenters = [];
    for (let i = 0; i < NUMBER_OF_DOTS; i++) {
      const centerX = (dotRandom.nextDouble() - 0.5) * MAX_WIDTH_INCLUDING_ROUNDED_ENDS;
      const centerY = (dotRandom.nextDouble() - 0.5) * WireShapeConstants.WIRE_VIEW_HEIGHT_RANGE.max;
      this.dotCenters.push(new Vector2(centerX, centerY));
    }

    // @private - just for use in paintCanvas
    this.resistivityProperty = model.resistivityProperty;
    this.areaProperty = model.areaProperty;
    this.lengthProperty = model.lengthProperty;
    this.setCanvasBounds(dotsBounds);
    this.invalidatePaint();
  }

  /**
   * Draw the required dots.
   *
   * @param {CanvasRenderingContext2D} context
   * @override
   * @public
   */
  paintCanvas(context) {
    // Height of the wire in view coordinates
    const height = WireShapeConstants.areaToHeight(this.areaProperty.get());

    // Width of the wire (as measured from the top of the wire, that is excluding the rounding bits in the middle).
    const width = WireShapeConstants.lengthToWidth.evaluate(this.lengthProperty.get());

    // for readability, these are relative to the rectangular body
    const top = -height / 2;
    const bottom = height / 2;
    const left = -width / 2;
    const right = width / 2;

    // Rectangular shape of the body, used as the clip area. Using and changing clip area that includes the ends
    // of the wire with Shape.ellipticalArc is too slow. But approximating arcs with fewer segments is much faster.
    // See https://github.com/phetsims/resistance-in-a-wire/issues/170 and approxEllipticalArc()
    context.beginPath();
    context.moveTo(left, bottom);

    // arc around the left side of the wire
    approxEllipticalArc(context, height, left, Math.PI / 2, 3 * Math.PI / 2);
    context.lineTo(right, top);

    // arc around the right side of the wire
    approxEllipticalArc(context, height, right, 3 * Math.PI / 2, 5 * Math.PI / 2);
    context.lineTo(left, bottom);

    // use this shape with "arcs" as the clip shape
    context.clip();

    // fillstyle required for dots to show up in screenshot feature, see
    // https://github.com/phetsims/resistance-in-a-wire/issues/171
    // NOTE: Maybe this can be removed once https://github.com/phetsims/scenery/issues/848 is sorted?
    context.fillStyle = 'black';

    // draw the dots, number depending on the resistivity Property
    const numDotsToShow = resistivityToNumberOfDots.evaluate(this.resistivityProperty.get());
    for (let i = 0; i < this.dotCenters.length; i++) {
      if (i < numDotsToShow) {
        context.beginPath();
        context.arc(this.dotCenters[i].x, this.dotCenters[i].y, WireShapeConstants.DOT_RADIUS, 0, 2 * Math.PI, true);
        context.fill();
      }
    }
  }
}
resistanceInAWire.register('DotsCanvasNode', DotsCanvasNode);

/**
 * Using Shape.ellipticalArc for the clip area is too slow, so we approximate ellipcitcal arcs with segments.
 * The 'segments' variable can be increased to get more accurate elliptical shapes, or reduced for (possibly)
 * faster drawing.
 *
 * @param {CanvasContext2D} context - canvas context to draw to
 * @param {number} height - height of the wire
 * @param {number} centerX - centerX offset for the ellipse
 * @param {number} startAngle - start angle for the ellipse
 * @param {number} endAngle - end angle for the ellipse
 */
function approxEllipticalArc(context, height, centerX, startAngle, endAngle) {
  // with 9 segments, the elliptical shape is almost perfect
  const segments = 9;
  const delta = (endAngle - startAngle) / segments;
  const xRadius = WireShapeConstants.PERSPECTIVE_FACTOR * height / 2;
  const yRadius = height / 2;
  let t = startAngle;
  while (t <= endAngle) {
    const x = centerX + xRadius * Math.cos(t);
    const y = yRadius * Math.sin(t);
    context.lineTo(x, y);
    t += delta;
  }
}
export default DotsCanvasNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiZG90UmFuZG9tIiwiTGluZWFyRnVuY3Rpb24iLCJWZWN0b3IyIiwibWVyZ2UiLCJDYW52YXNOb2RlIiwicmVzaXN0YW5jZUluQVdpcmUiLCJSZXNpc3RhbmNlSW5BV2lyZUNvbnN0YW50cyIsIldpcmVTaGFwZUNvbnN0YW50cyIsIk1BWF9XSURUSF9JTkNMVURJTkdfUk9VTkRFRF9FTkRTIiwiV0lSRV9WSUVXX1dJRFRIX1JBTkdFIiwibWF4IiwiV0lSRV9WSUVXX0hFSUdIVF9SQU5HRSIsIlBFUlNQRUNUSVZFX0ZBQ1RPUiIsIkFSRUFfUEVSX0RPVCIsIk5VTUJFUl9PRl9ET1RTIiwicmVzaXN0aXZpdHlUb051bWJlck9mRG90cyIsIlJFU0lTVElWSVRZX1JBTkdFIiwibWluIiwiRG90c0NhbnZhc05vZGUiLCJjb25zdHJ1Y3RvciIsIm1vZGVsIiwib3B0aW9ucyIsInByZXZlbnRGaXQiLCJoZWlnaHQiLCJhcmVhVG9IZWlnaHQiLCJBUkVBX1JBTkdFIiwid2lkdGgiLCJsZW5ndGhUb1dpZHRoIiwiZXZhbHVhdGUiLCJMRU5HVEhfUkFOR0UiLCJkb3RzQm91bmRzIiwiZG90Q2VudGVycyIsImkiLCJjZW50ZXJYIiwibmV4dERvdWJsZSIsImNlbnRlclkiLCJwdXNoIiwicmVzaXN0aXZpdHlQcm9wZXJ0eSIsImFyZWFQcm9wZXJ0eSIsImxlbmd0aFByb3BlcnR5Iiwic2V0Q2FudmFzQm91bmRzIiwiaW52YWxpZGF0ZVBhaW50IiwicGFpbnRDYW52YXMiLCJjb250ZXh0IiwiZ2V0IiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiYmVnaW5QYXRoIiwibW92ZVRvIiwiYXBwcm94RWxsaXB0aWNhbEFyYyIsIk1hdGgiLCJQSSIsImxpbmVUbyIsImNsaXAiLCJmaWxsU3R5bGUiLCJudW1Eb3RzVG9TaG93IiwibGVuZ3RoIiwiYXJjIiwieCIsInkiLCJET1RfUkFESVVTIiwiZmlsbCIsInJlZ2lzdGVyIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwic2VnbWVudHMiLCJkZWx0YSIsInhSYWRpdXMiLCJ5UmFkaXVzIiwidCIsImNvcyIsInNpbiJdLCJzb3VyY2VzIjpbIkRvdHNDYW52YXNOb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4LTIwMjEsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIERyYXcgdGhlIGRvdHMgaW4gdGhlIHdpcmUgd2l0aCBhIENhbnZhc05vZGUgYXMgYSBwZXJmb3JtYW5jZSBlbmhhbmNlbWVudC4gVGhpcyBpcyBtdWNoIGZhc3RlciB0aGFuIGRyYXdpbmdcclxuICogZWFjaCBkb3QgYXMgYSBDaXJjbGUgbm9kZSBhbmQgdXBkYXRpbmcgdGhlaXIgdmlzaWJpbGl0eS4gRG90cyBhcmUgcmVkcmF3biB3aGVuZXZlciBtb2RlbCBQcm9wZXJ0aWVzIGNoYW5nZSB0aGF0XHJcbiAqIG1pZ2h0IGNoYW5nZSB0aGUgc2hhcGUgb2YgdGhlIHdpcmUgb3IgYWRkIG9yIHJlbW92ZSBkb3RzIChsZW5ndGgsIGFyZWEsIHJlc2lzdGl2aXR5KS5cclxuICpcclxuICogQGF1dGhvciBKZXNzZSBHcmVlbmJlcmdcclxuICovXHJcblxyXG5pbXBvcnQgQm91bmRzMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvQm91bmRzMi5qcyc7XHJcbmltcG9ydCBkb3RSYW5kb20gZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL2RvdFJhbmRvbS5qcyc7XHJcbmltcG9ydCBMaW5lYXJGdW5jdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvTGluZWFyRnVuY3Rpb24uanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgeyBDYW52YXNOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IHJlc2lzdGFuY2VJbkFXaXJlIGZyb20gJy4uLy4uL3Jlc2lzdGFuY2VJbkFXaXJlLmpzJztcclxuaW1wb3J0IFJlc2lzdGFuY2VJbkFXaXJlQ29uc3RhbnRzIGZyb20gJy4uL1Jlc2lzdGFuY2VJbkFXaXJlQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IFdpcmVTaGFwZUNvbnN0YW50cyBmcm9tICcuL1dpcmVTaGFwZUNvbnN0YW50cy5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuLy8gdG8gY2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgZG90c1xyXG5jb25zdCBNQVhfV0lEVEhfSU5DTFVESU5HX1JPVU5ERURfRU5EUyA9IFdpcmVTaGFwZUNvbnN0YW50cy5XSVJFX1ZJRVdfV0lEVEhfUkFOR0UubWF4ICsgMiAqIFdpcmVTaGFwZUNvbnN0YW50cy5XSVJFX1ZJRVdfSEVJR0hUX1JBTkdFLm1heCAqIFdpcmVTaGFwZUNvbnN0YW50cy5QRVJTUEVDVElWRV9GQUNUT1I7XHJcbmNvbnN0IEFSRUFfUEVSX0RPVCA9IDIwMDsgLy8gQWRqdXN0IHRoaXMgdG8gY29udHJvbCB0aGUgZGVuc2l0eSBvZiB0aGUgZG90cy5cclxuY29uc3QgTlVNQkVSX09GX0RPVFMgPSBNQVhfV0lEVEhfSU5DTFVESU5HX1JPVU5ERURfRU5EUyAqIFdpcmVTaGFwZUNvbnN0YW50cy5XSVJFX1ZJRVdfSEVJR0hUX1JBTkdFLm1heCAvIEFSRUFfUEVSX0RPVDtcclxuXHJcbi8vIEZ1bmN0aW9uIHRvIG1hcCByZXNpc3Rpdml0eSB0byBudW1iZXIgb2YgZG90cy5cclxuY29uc3QgcmVzaXN0aXZpdHlUb051bWJlck9mRG90cyA9IG5ldyBMaW5lYXJGdW5jdGlvbihcclxuICBSZXNpc3RhbmNlSW5BV2lyZUNvbnN0YW50cy5SRVNJU1RJVklUWV9SQU5HRS5taW4sXHJcbiAgUmVzaXN0YW5jZUluQVdpcmVDb25zdGFudHMuUkVTSVNUSVZJVFlfUkFOR0UubWF4LFxyXG4gIE5VTUJFUl9PRl9ET1RTICogMC4wNSxcclxuICBOVU1CRVJfT0ZfRE9UUyxcclxuICB0cnVlXHJcbik7XHJcblxyXG5jbGFzcyBEb3RzQ2FudmFzTm9kZSBleHRlbmRzIENhbnZhc05vZGUge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Qm91bmRzMn0gYm91bmRzIC0gdG90YWwgYm91bmRzIGZvciB0aGUgY2FudmFzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBtb2RlbCwgb3B0aW9ucyApIHtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuICAgICAgcHJldmVudEZpdDogdHJ1ZSAvLyBkb24ndCByZWNvbXB1dGUgYm91bmRzIGFzIGEgcGVyZm9ybWFuY2UgZW5oYW5jZW1lbnRcclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgYm91bmRzIGZvciB0aGUgY2FudmFzIC0gd2lyZSBjZW50ZXIgaXMgYXQgKDAsIDApXHJcbiAgICBjb25zdCBoZWlnaHQgPSBXaXJlU2hhcGVDb25zdGFudHMuYXJlYVRvSGVpZ2h0KCBSZXNpc3RhbmNlSW5BV2lyZUNvbnN0YW50cy5BUkVBX1JBTkdFLm1heCApO1xyXG4gICAgY29uc3Qgd2lkdGggPSBXaXJlU2hhcGVDb25zdGFudHMubGVuZ3RoVG9XaWR0aC5ldmFsdWF0ZSggUmVzaXN0YW5jZUluQVdpcmVDb25zdGFudHMuTEVOR1RIX1JBTkdFLm1heCApO1xyXG4gICAgY29uc3QgZG90c0JvdW5kcyA9IG5ldyBCb3VuZHMyKCAtd2lkdGggLyAyIC0gV2lyZVNoYXBlQ29uc3RhbnRzLlBFUlNQRUNUSVZFX0ZBQ1RPUiAqIGhlaWdodCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCAvIDIgKyBXaXJlU2hhcGVDb25zdGFudHMuUEVSU1BFQ1RJVkVfRkFDVE9SICogaGVpZ2h0IC8gMiwgaGVpZ2h0IC8gMiApO1xyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gQHByaXZhdGUgLSBQb3NpdGlvbnMgZm9yIGRvdHMgcmFuZG9tbHkgb24gdGhlIHdpcmUuIERlbnNpdHkgaXMgYmFzZWQgb24gQVJFQV9QRVJfRE9ULlxyXG4gICAgdGhpcy5kb3RDZW50ZXJzID0gW107XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBOVU1CRVJfT0ZfRE9UUzsgaSsrICkge1xyXG4gICAgICBjb25zdCBjZW50ZXJYID0gKCBkb3RSYW5kb20ubmV4dERvdWJsZSgpIC0gMC41ICkgKiBNQVhfV0lEVEhfSU5DTFVESU5HX1JPVU5ERURfRU5EUztcclxuICAgICAgY29uc3QgY2VudGVyWSA9ICggZG90UmFuZG9tLm5leHREb3VibGUoKSAtIDAuNSApICogV2lyZVNoYXBlQ29uc3RhbnRzLldJUkVfVklFV19IRUlHSFRfUkFOR0UubWF4O1xyXG4gICAgICB0aGlzLmRvdENlbnRlcnMucHVzaCggbmV3IFZlY3RvcjIoIGNlbnRlclgsIGNlbnRlclkgKSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBwcml2YXRlIC0ganVzdCBmb3IgdXNlIGluIHBhaW50Q2FudmFzXHJcbiAgICB0aGlzLnJlc2lzdGl2aXR5UHJvcGVydHkgPSBtb2RlbC5yZXNpc3Rpdml0eVByb3BlcnR5O1xyXG4gICAgdGhpcy5hcmVhUHJvcGVydHkgPSBtb2RlbC5hcmVhUHJvcGVydHk7XHJcbiAgICB0aGlzLmxlbmd0aFByb3BlcnR5ID0gbW9kZWwubGVuZ3RoUHJvcGVydHk7XHJcblxyXG4gICAgdGhpcy5zZXRDYW52YXNCb3VuZHMoIGRvdHNCb3VuZHMgKTtcclxuICAgIHRoaXMuaW52YWxpZGF0ZVBhaW50KCk7XHJcblxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIERyYXcgdGhlIHJlcXVpcmVkIGRvdHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBwYWludENhbnZhcyggY29udGV4dCApIHtcclxuXHJcbiAgICAvLyBIZWlnaHQgb2YgdGhlIHdpcmUgaW4gdmlldyBjb29yZGluYXRlc1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gV2lyZVNoYXBlQ29uc3RhbnRzLmFyZWFUb0hlaWdodCggdGhpcy5hcmVhUHJvcGVydHkuZ2V0KCkgKTtcclxuXHJcbiAgICAvLyBXaWR0aCBvZiB0aGUgd2lyZSAoYXMgbWVhc3VyZWQgZnJvbSB0aGUgdG9wIG9mIHRoZSB3aXJlLCB0aGF0IGlzIGV4Y2x1ZGluZyB0aGUgcm91bmRpbmcgYml0cyBpbiB0aGUgbWlkZGxlKS5cclxuICAgIGNvbnN0IHdpZHRoID0gV2lyZVNoYXBlQ29uc3RhbnRzLmxlbmd0aFRvV2lkdGguZXZhbHVhdGUoIHRoaXMubGVuZ3RoUHJvcGVydHkuZ2V0KCkgKTtcclxuXHJcbiAgICAvLyBmb3IgcmVhZGFiaWxpdHksIHRoZXNlIGFyZSByZWxhdGl2ZSB0byB0aGUgcmVjdGFuZ3VsYXIgYm9keVxyXG4gICAgY29uc3QgdG9wID0gLWhlaWdodCAvIDI7XHJcbiAgICBjb25zdCBib3R0b20gPSBoZWlnaHQgLyAyO1xyXG4gICAgY29uc3QgbGVmdCA9IC13aWR0aCAvIDI7XHJcbiAgICBjb25zdCByaWdodCA9IHdpZHRoIC8gMjtcclxuXHJcbiAgICAvLyBSZWN0YW5ndWxhciBzaGFwZSBvZiB0aGUgYm9keSwgdXNlZCBhcyB0aGUgY2xpcCBhcmVhLiBVc2luZyBhbmQgY2hhbmdpbmcgY2xpcCBhcmVhIHRoYXQgaW5jbHVkZXMgdGhlIGVuZHNcclxuICAgIC8vIG9mIHRoZSB3aXJlIHdpdGggU2hhcGUuZWxsaXB0aWNhbEFyYyBpcyB0b28gc2xvdy4gQnV0IGFwcHJveGltYXRpbmcgYXJjcyB3aXRoIGZld2VyIHNlZ21lbnRzIGlzIG11Y2ggZmFzdGVyLlxyXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9yZXNpc3RhbmNlLWluLWEtd2lyZS9pc3N1ZXMvMTcwIGFuZCBhcHByb3hFbGxpcHRpY2FsQXJjKClcclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICBjb250ZXh0Lm1vdmVUbyggbGVmdCwgYm90dG9tICk7XHJcblxyXG4gICAgLy8gYXJjIGFyb3VuZCB0aGUgbGVmdCBzaWRlIG9mIHRoZSB3aXJlXHJcbiAgICBhcHByb3hFbGxpcHRpY2FsQXJjKCBjb250ZXh0LCBoZWlnaHQsIGxlZnQsIE1hdGguUEkgLyAyLCAzICogTWF0aC5QSSAvIDIgKTtcclxuICAgIGNvbnRleHQubGluZVRvKCByaWdodCwgdG9wICk7XHJcblxyXG4gICAgLy8gYXJjIGFyb3VuZCB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgd2lyZVxyXG4gICAgYXBwcm94RWxsaXB0aWNhbEFyYyggY29udGV4dCwgaGVpZ2h0LCByaWdodCwgMyAqIE1hdGguUEkgLyAyLCA1ICogTWF0aC5QSSAvIDIgKTtcclxuICAgIGNvbnRleHQubGluZVRvKCBsZWZ0LCBib3R0b20gKTtcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBzaGFwZSB3aXRoIFwiYXJjc1wiIGFzIHRoZSBjbGlwIHNoYXBlXHJcbiAgICBjb250ZXh0LmNsaXAoKTtcclxuXHJcbiAgICAvLyBmaWxsc3R5bGUgcmVxdWlyZWQgZm9yIGRvdHMgdG8gc2hvdyB1cCBpbiBzY3JlZW5zaG90IGZlYXR1cmUsIHNlZVxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3Jlc2lzdGFuY2UtaW4tYS13aXJlL2lzc3Vlcy8xNzFcclxuICAgIC8vIE5PVEU6IE1heWJlIHRoaXMgY2FuIGJlIHJlbW92ZWQgb25jZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvc2NlbmVyeS9pc3N1ZXMvODQ4IGlzIHNvcnRlZD9cclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ2JsYWNrJztcclxuXHJcbiAgICAvLyBkcmF3IHRoZSBkb3RzLCBudW1iZXIgZGVwZW5kaW5nIG9uIHRoZSByZXNpc3Rpdml0eSBQcm9wZXJ0eVxyXG4gICAgY29uc3QgbnVtRG90c1RvU2hvdyA9IHJlc2lzdGl2aXR5VG9OdW1iZXJPZkRvdHMuZXZhbHVhdGUoIHRoaXMucmVzaXN0aXZpdHlQcm9wZXJ0eS5nZXQoKSApO1xyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5kb3RDZW50ZXJzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICBpZiAoIGkgPCBudW1Eb3RzVG9TaG93ICkge1xyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5hcmMoIHRoaXMuZG90Q2VudGVyc1sgaSBdLngsIHRoaXMuZG90Q2VudGVyc1sgaSBdLnksIFdpcmVTaGFwZUNvbnN0YW50cy5ET1RfUkFESVVTLCAwLCAyICogTWF0aC5QSSwgdHJ1ZSApO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5yZXNpc3RhbmNlSW5BV2lyZS5yZWdpc3RlciggJ0RvdHNDYW52YXNOb2RlJywgRG90c0NhbnZhc05vZGUgKTtcclxuXHJcbi8qKlxyXG4gKiBVc2luZyBTaGFwZS5lbGxpcHRpY2FsQXJjIGZvciB0aGUgY2xpcCBhcmVhIGlzIHRvbyBzbG93LCBzbyB3ZSBhcHByb3hpbWF0ZSBlbGxpcGNpdGNhbCBhcmNzIHdpdGggc2VnbWVudHMuXHJcbiAqIFRoZSAnc2VnbWVudHMnIHZhcmlhYmxlIGNhbiBiZSBpbmNyZWFzZWQgdG8gZ2V0IG1vcmUgYWNjdXJhdGUgZWxsaXB0aWNhbCBzaGFwZXMsIG9yIHJlZHVjZWQgZm9yIChwb3NzaWJseSlcclxuICogZmFzdGVyIGRyYXdpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q2FudmFzQ29udGV4dDJEfSBjb250ZXh0IC0gY2FudmFzIGNvbnRleHQgdG8gZHJhdyB0b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSB3aXJlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXJYIC0gY2VudGVyWCBvZmZzZXQgZm9yIHRoZSBlbGxpcHNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlIC0gc3RhcnQgYW5nbGUgZm9yIHRoZSBlbGxpcHNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZSAtIGVuZCBhbmdsZSBmb3IgdGhlIGVsbGlwc2VcclxuICovXHJcbmZ1bmN0aW9uIGFwcHJveEVsbGlwdGljYWxBcmMoIGNvbnRleHQsIGhlaWdodCwgY2VudGVyWCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUgKSB7XHJcblxyXG4gIC8vIHdpdGggOSBzZWdtZW50cywgdGhlIGVsbGlwdGljYWwgc2hhcGUgaXMgYWxtb3N0IHBlcmZlY3RcclxuICBjb25zdCBzZWdtZW50cyA9IDk7XHJcbiAgY29uc3QgZGVsdGEgPSAoIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSApIC8gc2VnbWVudHM7XHJcblxyXG4gIGNvbnN0IHhSYWRpdXMgPSBXaXJlU2hhcGVDb25zdGFudHMuUEVSU1BFQ1RJVkVfRkFDVE9SICogaGVpZ2h0IC8gMjtcclxuICBjb25zdCB5UmFkaXVzID0gaGVpZ2h0IC8gMjtcclxuXHJcbiAgbGV0IHQgPSBzdGFydEFuZ2xlO1xyXG4gIHdoaWxlICggdCA8PSBlbmRBbmdsZSApIHtcclxuICAgIGNvbnN0IHggPSBjZW50ZXJYICsgeFJhZGl1cyAqIE1hdGguY29zKCB0ICk7XHJcbiAgICBjb25zdCB5ID0geVJhZGl1cyAqIE1hdGguc2luKCB0ICk7XHJcbiAgICBjb250ZXh0LmxpbmVUbyggeCwgeSApO1xyXG5cclxuICAgIHQgKz0gZGVsdGE7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEb3RzQ2FudmFzTm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsU0FBUyxNQUFNLGlDQUFpQztBQUN2RCxPQUFPQyxjQUFjLE1BQU0sc0NBQXNDO0FBQ2pFLE9BQU9D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