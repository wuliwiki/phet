// Copyright 2019-2023, University of Colorado Boulder

/**
 * EquationsSumVector is a specialization of SumVector for the 'Equations' screen.  It computes the 'sum' differently
 * depending on the equation type.  Instances exist for the lifetime of the sim and do not need to be disposed.
 *
 * @author Brandon Li
 * @author Chris Malley (PixelZoom, Inc.)
 */

import EnumerationProperty from '../../../../axon/js/EnumerationProperty.js';
import Multilink from '../../../../axon/js/Multilink.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import merge from '../../../../phet-core/js/merge.js';
import SumVector from '../../common/model/SumVector.js';
import vectorAddition from '../../vectorAddition.js';
import EquationTypes from './EquationTypes.js';

// constants
const EQUATIONS_SUM_TAIL_POSITION = new Vector2(25, 5);
export default class EquationsSumVector extends SumVector {
  /**
   * @param {Graph} graph - graph the sum vector belongs to
   * @param {VectorSet} vectorSet - the vector set that the sum vector represents
   * @param {EnumerationProperty.<EquationTypes>} equationTypeProperty
   * @param {string|null} symbol - the symbol for the vector (i.e. 'a', 'b', 'c', ...)
   */
  constructor(graph, vectorSet, equationTypeProperty, symbol) {
    assert && assert(equationTypeProperty instanceof EnumerationProperty && EquationTypes.enumeration.includes(equationTypeProperty.value), `invalid equationTypeProperty: ${equationTypeProperty}`);
    super(EQUATIONS_SUM_TAIL_POSITION, graph, vectorSet, symbol);

    // @private
    this.vectorSet = vectorSet;
    this.equationTypeProperty = equationTypeProperty;

    // Observe when each vector changes and/or when the equationType changes to calculate the sum.
    // unmultilink is unnecessary, exists for the lifetime of the sim.
    const dependencies = [];
    vectorSet.vectors.forEach(vector => {
      dependencies.push(vector.vectorComponentsProperty);
    });
    Multilink.multilink(_.concat([equationTypeProperty], dependencies), () => {
      this.updateSum(vectorSet.vectors);
    });
  }

  /**
   * Calculate the sum vector for the Equations screen.
   * @param {ObservableArrayDef.<Vector>} vectors
   * @public
   * @override
   */
  updateSum(vectors) {
    const equationType = this.equationTypeProperty.value;

    // Denoted by 'a' + 'b' = 'c'
    if (equationType === EquationTypes.ADDITION) {
      const sum = new Vector2(0, 0);
      vectors.forEach(vector => {
        sum.add(vector.vectorComponents);
      });
      this.vectorComponents = sum;
    } else if (equationType === EquationTypes.SUBTRACTION) {
      const calculatedComponents = vectors.get(0).vectorComponents.copy();

      // Subtract from the first vector
      _.drop(vectors).forEach(vector => {
        calculatedComponents.subtract(vector.vectorComponents);
      });
      this.vectorComponents = calculatedComponents;
    } else if (equationType === EquationTypes.NEGATION) {
      // Same as addition but negated  : a + b = -c or a + b + c = 0
      const sum = new Vector2(0, 0);
      vectors.forEach(vector => {
        sum.add(vector.vectorComponents);
      });
      this.vectorComponents = sum.negate();
    }
  }

  /**
   * Gets the label content information to be displayed on the vector.
   * See RootVector.getLabelContent for details.
   * @override
   * @public
   * @param {boolean} valuesVisible - whether the values are visible
   * @returns {Object} see RootVector.getLabelContent
   */
  getLabelContent(valuesVisible) {
    return merge(super.getLabelContent(valuesVisible), {
      symbol: this.symbol
    });
  }

  /**
   * @public
   * @override
   */
  reset() {
    super.reset();

    // In the Equations screen, vectors are never removed, so we need to explicitly call updateSum.
    // See https://github.com/phetsims/vector-addition/issues/129
    this.updateSum(this.vectorSet.vectors);
  }
}
vectorAddition.register('EquationsSumVector', EquationsSumVector);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFbnVtZXJhdGlvblByb3BlcnR5IiwiTXVsdGlsaW5rIiwiVmVjdG9yMiIsIm1lcmdlIiwiU3VtVmVjdG9yIiwidmVjdG9yQWRkaXRpb24iLCJFcXVhdGlvblR5cGVzIiwiRVFVQVRJT05TX1NVTV9UQUlMX1BPU0lUSU9OIiwiRXF1YXRpb25zU3VtVmVjdG9yIiwiY29uc3RydWN0b3IiLCJncmFwaCIsInZlY3RvclNldCIsImVxdWF0aW9uVHlwZVByb3BlcnR5Iiwic3ltYm9sIiwiYXNzZXJ0IiwiZW51bWVyYXRpb24iLCJpbmNsdWRlcyIsInZhbHVlIiwiZGVwZW5kZW5jaWVzIiwidmVjdG9ycyIsImZvckVhY2giLCJ2ZWN0b3IiLCJwdXNoIiwidmVjdG9yQ29tcG9uZW50c1Byb3BlcnR5IiwibXVsdGlsaW5rIiwiXyIsImNvbmNhdCIsInVwZGF0ZVN1bSIsImVxdWF0aW9uVHlwZSIsIkFERElUSU9OIiwic3VtIiwiYWRkIiwidmVjdG9yQ29tcG9uZW50cyIsIlNVQlRSQUNUSU9OIiwiY2FsY3VsYXRlZENvbXBvbmVudHMiLCJnZXQiLCJjb3B5IiwiZHJvcCIsInN1YnRyYWN0IiwiTkVHQVRJT04iLCJuZWdhdGUiLCJnZXRMYWJlbENvbnRlbnQiLCJ2YWx1ZXNWaXNpYmxlIiwicmVzZXQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkVxdWF0aW9uc1N1bVZlY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOS0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBFcXVhdGlvbnNTdW1WZWN0b3IgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBTdW1WZWN0b3IgZm9yIHRoZSAnRXF1YXRpb25zJyBzY3JlZW4uICBJdCBjb21wdXRlcyB0aGUgJ3N1bScgZGlmZmVyZW50bHlcclxuICogZGVwZW5kaW5nIG9uIHRoZSBlcXVhdGlvbiB0eXBlLiAgSW5zdGFuY2VzIGV4aXN0IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbSBhbmQgZG8gbm90IG5lZWQgdG8gYmUgZGlzcG9zZWQuXHJcbiAqXHJcbiAqIEBhdXRob3IgQnJhbmRvbiBMaVxyXG4gKiBAYXV0aG9yIENocmlzIE1hbGxleSAoUGl4ZWxab29tLCBJbmMuKVxyXG4gKi9cclxuXHJcbmltcG9ydCBFbnVtZXJhdGlvblByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvRW51bWVyYXRpb25Qcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBNdWx0aWxpbmsgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9NdWx0aWxpbmsuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgU3VtVmVjdG9yIGZyb20gJy4uLy4uL2NvbW1vbi9tb2RlbC9TdW1WZWN0b3IuanMnO1xyXG5pbXBvcnQgdmVjdG9yQWRkaXRpb24gZnJvbSAnLi4vLi4vdmVjdG9yQWRkaXRpb24uanMnO1xyXG5pbXBvcnQgRXF1YXRpb25UeXBlcyBmcm9tICcuL0VxdWF0aW9uVHlwZXMuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IEVRVUFUSU9OU19TVU1fVEFJTF9QT1NJVElPTiA9IG5ldyBWZWN0b3IyKCAyNSwgNSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXF1YXRpb25zU3VtVmVjdG9yIGV4dGVuZHMgU3VtVmVjdG9yIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtHcmFwaH0gZ3JhcGggLSBncmFwaCB0aGUgc3VtIHZlY3RvciBiZWxvbmdzIHRvXHJcbiAgICogQHBhcmFtIHtWZWN0b3JTZXR9IHZlY3RvclNldCAtIHRoZSB2ZWN0b3Igc2V0IHRoYXQgdGhlIHN1bSB2ZWN0b3IgcmVwcmVzZW50c1xyXG4gICAqIEBwYXJhbSB7RW51bWVyYXRpb25Qcm9wZXJ0eS48RXF1YXRpb25UeXBlcz59IGVxdWF0aW9uVHlwZVByb3BlcnR5XHJcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gc3ltYm9sIC0gdGhlIHN5bWJvbCBmb3IgdGhlIHZlY3RvciAoaS5lLiAnYScsICdiJywgJ2MnLCAuLi4pXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGdyYXBoLCB2ZWN0b3JTZXQsIGVxdWF0aW9uVHlwZVByb3BlcnR5LCBzeW1ib2wgKSB7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZXF1YXRpb25UeXBlUHJvcGVydHkgaW5zdGFuY2VvZiBFbnVtZXJhdGlvblByb3BlcnR5ICYmIEVxdWF0aW9uVHlwZXMuZW51bWVyYXRpb24uaW5jbHVkZXMoIGVxdWF0aW9uVHlwZVByb3BlcnR5LnZhbHVlICksXHJcbiAgICAgIGBpbnZhbGlkIGVxdWF0aW9uVHlwZVByb3BlcnR5OiAke2VxdWF0aW9uVHlwZVByb3BlcnR5fWAgKTtcclxuXHJcbiAgICBzdXBlciggRVFVQVRJT05TX1NVTV9UQUlMX1BPU0lUSU9OLCBncmFwaCwgdmVjdG9yU2V0LCBzeW1ib2wgKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy52ZWN0b3JTZXQgPSB2ZWN0b3JTZXQ7XHJcbiAgICB0aGlzLmVxdWF0aW9uVHlwZVByb3BlcnR5ID0gZXF1YXRpb25UeXBlUHJvcGVydHk7XHJcblxyXG4gICAgLy8gT2JzZXJ2ZSB3aGVuIGVhY2ggdmVjdG9yIGNoYW5nZXMgYW5kL29yIHdoZW4gdGhlIGVxdWF0aW9uVHlwZSBjaGFuZ2VzIHRvIGNhbGN1bGF0ZSB0aGUgc3VtLlxyXG4gICAgLy8gdW5tdWx0aWxpbmsgaXMgdW5uZWNlc3NhcnksIGV4aXN0cyBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0uXHJcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBbXTtcclxuICAgIHZlY3RvclNldC52ZWN0b3JzLmZvckVhY2goIHZlY3RvciA9PiB7XHJcbiAgICAgIGRlcGVuZGVuY2llcy5wdXNoKCB2ZWN0b3IudmVjdG9yQ29tcG9uZW50c1Byb3BlcnR5ICk7XHJcbiAgICB9ICk7XHJcbiAgICBNdWx0aWxpbmsubXVsdGlsaW5rKCBfLmNvbmNhdCggWyBlcXVhdGlvblR5cGVQcm9wZXJ0eSBdLCBkZXBlbmRlbmNpZXMgKSxcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudXBkYXRlU3VtKCB2ZWN0b3JTZXQudmVjdG9ycyApO1xyXG4gICAgICB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIHN1bSB2ZWN0b3IgZm9yIHRoZSBFcXVhdGlvbnMgc2NyZWVuLlxyXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZUFycmF5RGVmLjxWZWN0b3I+fSB2ZWN0b3JzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xyXG4gIHVwZGF0ZVN1bSggdmVjdG9ycyApIHtcclxuXHJcbiAgICBjb25zdCBlcXVhdGlvblR5cGUgPSB0aGlzLmVxdWF0aW9uVHlwZVByb3BlcnR5LnZhbHVlO1xyXG5cclxuICAgIC8vIERlbm90ZWQgYnkgJ2EnICsgJ2InID0gJ2MnXHJcbiAgICBpZiAoIGVxdWF0aW9uVHlwZSA9PT0gRXF1YXRpb25UeXBlcy5BRERJVElPTiApIHtcclxuICAgICAgY29uc3Qgc3VtID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcclxuXHJcbiAgICAgIHZlY3RvcnMuZm9yRWFjaCggdmVjdG9yID0+IHtcclxuICAgICAgICBzdW0uYWRkKCB2ZWN0b3IudmVjdG9yQ29tcG9uZW50cyApO1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICB0aGlzLnZlY3RvckNvbXBvbmVudHMgPSBzdW07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggZXF1YXRpb25UeXBlID09PSBFcXVhdGlvblR5cGVzLlNVQlRSQUNUSU9OICkge1xyXG4gICAgICBjb25zdCBjYWxjdWxhdGVkQ29tcG9uZW50cyA9IHZlY3RvcnMuZ2V0KCAwICkudmVjdG9yQ29tcG9uZW50cy5jb3B5KCk7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCBmcm9tIHRoZSBmaXJzdCB2ZWN0b3JcclxuICAgICAgXy5kcm9wKCB2ZWN0b3JzICkuZm9yRWFjaCggdmVjdG9yID0+IHtcclxuICAgICAgICBjYWxjdWxhdGVkQ29tcG9uZW50cy5zdWJ0cmFjdCggdmVjdG9yLnZlY3RvckNvbXBvbmVudHMgKTtcclxuICAgICAgfSApO1xyXG5cclxuICAgICAgdGhpcy52ZWN0b3JDb21wb25lbnRzID0gY2FsY3VsYXRlZENvbXBvbmVudHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggZXF1YXRpb25UeXBlID09PSBFcXVhdGlvblR5cGVzLk5FR0FUSU9OICkge1xyXG5cclxuICAgICAgLy8gU2FtZSBhcyBhZGRpdGlvbiBidXQgbmVnYXRlZCAgOiBhICsgYiA9IC1jIG9yIGEgKyBiICsgYyA9IDBcclxuICAgICAgY29uc3Qgc3VtID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcclxuXHJcbiAgICAgIHZlY3RvcnMuZm9yRWFjaCggdmVjdG9yID0+IHtcclxuICAgICAgICBzdW0uYWRkKCB2ZWN0b3IudmVjdG9yQ29tcG9uZW50cyApO1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICB0aGlzLnZlY3RvckNvbXBvbmVudHMgPSBzdW0ubmVnYXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBsYWJlbCBjb250ZW50IGluZm9ybWF0aW9uIHRvIGJlIGRpc3BsYXllZCBvbiB0aGUgdmVjdG9yLlxyXG4gICAqIFNlZSBSb290VmVjdG9yLmdldExhYmVsQ29udGVudCBmb3IgZGV0YWlscy5cclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZXNWaXNpYmxlIC0gd2hldGhlciB0aGUgdmFsdWVzIGFyZSB2aXNpYmxlXHJcbiAgICogQHJldHVybnMge09iamVjdH0gc2VlIFJvb3RWZWN0b3IuZ2V0TGFiZWxDb250ZW50XHJcbiAgICovXHJcbiAgZ2V0TGFiZWxDb250ZW50KCB2YWx1ZXNWaXNpYmxlICkge1xyXG4gICAgcmV0dXJuIG1lcmdlKCBzdXBlci5nZXRMYWJlbENvbnRlbnQoIHZhbHVlc1Zpc2libGUgKSwge1xyXG4gICAgICBzeW1ib2w6IHRoaXMuc3ltYm9sXHJcbiAgICB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXHJcbiAgcmVzZXQoKSB7XHJcbiAgICBzdXBlci5yZXNldCgpO1xyXG5cclxuICAgIC8vIEluIHRoZSBFcXVhdGlvbnMgc2NyZWVuLCB2ZWN0b3JzIGFyZSBuZXZlciByZW1vdmVkLCBzbyB3ZSBuZWVkIHRvIGV4cGxpY2l0bHkgY2FsbCB1cGRhdGVTdW0uXHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3ZlY3Rvci1hZGRpdGlvbi9pc3N1ZXMvMTI5XHJcbiAgICB0aGlzLnVwZGF0ZVN1bSggdGhpcy52ZWN0b3JTZXQudmVjdG9ycyApO1xyXG4gIH1cclxufVxyXG5cclxudmVjdG9yQWRkaXRpb24ucmVnaXN0ZXIoICdFcXVhdGlvbnNTdW1WZWN0b3InLCBFcXVhdGlvbnNTdW1WZWN0b3IgKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLG1CQUFtQixNQUFNLDRDQUE0QztBQUM1RSxPQUFPQyxTQUFTLE1BQU0sa0NBQWtDO0FBQ3hELE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsS0FBSyxNQUFNLG1DQUFtQztBQUNyRCxPQUFPQyxTQUFTLE1BQU0saUNBQWlDO0FBQ3ZELE9BQU9DLGNBQWMsTUFBTSx5QkFBeUI7QUFDcEQsT0FBT0MsYUFBYSxNQUFNLG9CQUFvQjs7QUFFOUM7QUFDQSxNQUFNQywyQkFBMkIsR0FBRyxJQUFJTCxPQUFPLENBQUUsRUFBRSxFQUFFLENBQUUs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