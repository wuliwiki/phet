// Copyright 2019-2023, University of Colorado Boulder

/**
 * EquationsVector is a specialization of Vector for the 'Equations' screen.  It adds mutable coefficient and base vector.
 * Instances exist for the lifetime of the sim and do not need to be disposed.
 *
 * @author Brandon Li
 * @author Chris Malley (PixelZoom, Inc.)
 */

import Multilink from '../../../../axon/js/Multilink.js';
import NumberProperty from '../../../../axon/js/NumberProperty.js';
import Range from '../../../../dot/js/Range.js';
import merge from '../../../../phet-core/js/merge.js';
import CartesianBaseVector from '../../common/model/CartesianBaseVector.js';
import CoordinateSnapModes from '../../common/model/CoordinateSnapModes.js';
import PolarBaseVector from '../../common/model/PolarBaseVector.js';
import Vector from '../../common/model/Vector.js';
import vectorAddition from '../../vectorAddition.js';

// constants

// initial coefficient and range
const DEFAULT_COEFFICIENT = 1;
const COEFFICIENT_RANGE = new Range(-5, 5);

// super class options
const OPTIONS = {
  isRemovable: false,
  // Equations vectors are not removable
  isTipDraggable: false,
  // Equations vectors are not draggable by the tip
  isOnGraphInitially: true // Equations vectors are always on the graph
};

export default class EquationsVector extends Vector {
  /**
   * @param {Vector2} initialTailPosition - starting tail position of the vector
   * @param {Vector2} initialComponents - starting components of the vector
   * @param {Vector2} baseVectorTailPosition - starting tail position of the base vector
   * @param {EquationsGraph} graph - the graph the vector belongs to
   * @param {EquationsVectorSet} vectorSet - the VectorSet that the vector belongs to
   * @param {string|null} symbol - the symbol for the vector (i.e. 'a', 'b', 'c', ...)
   */
  constructor(initialTailPosition, initialComponents, baseVectorTailPosition, graph, vectorSet, symbol) {
    super(initialTailPosition, initialComponents, graph, vectorSet, symbol, OPTIONS);

    // @public (read-only)
    this.coefficientProperty = new NumberProperty(DEFAULT_COEFFICIENT, {
      range: COEFFICIENT_RANGE
    });

    // Set the tip to itself to ensure Invariants for Polar/Cartesian is satisfied.
    this.setTipWithInvariants(this.tip);

    // @public (read-only) {BaseVector} instantiate a base vector based on snap mode
    this.baseVector = null;
    if (graph.coordinateSnapMode === CoordinateSnapModes.CARTESIAN) {
      this.baseVector = new CartesianBaseVector(baseVectorTailPosition, this.vectorComponents.dividedScalar(DEFAULT_COEFFICIENT), graph, vectorSet, symbol);
    } else {
      this.baseVector = new PolarBaseVector(baseVectorTailPosition, this.vectorComponents.dividedScalar(DEFAULT_COEFFICIENT), graph, vectorSet, symbol);
    }

    // Observe when the base vector changes, or when the coefficient Property changes and update the vector.
    // unmultilink is unnecessary, exists for the lifetime of the sim.
    Multilink.multilink([this.baseVector.vectorComponentsProperty, this.coefficientProperty], (baseVector, coefficient) => {
      this.vectorComponents = baseVector.timesScalar(coefficient);
    });
  }

  /**
   * @public
   * @override
   */
  dispose() {
    assert && assert(false, 'EquationsVector is not intended to be disposed');
  }

  /**
   * Resets the vector.
   * @public
   * @override
   */
  reset() {
    super.reset();
    this.coefficientProperty.reset();
    this.baseVector.reset();
  }

  /**
   * Gets the label content information to be displayed on the vector.
   * See RootVector.getLabelContent for details.
   * @override
   * @public
   * @param {boolean} valuesVisible - whether the values are visible
   * @returns {Object} see RootVector.getLabelContent
   */
  getLabelContent(valuesVisible) {
    return merge(super.getLabelContent(valuesVisible), {
      coefficient: this.coefficientProperty.value
    });
  }
}
vectorAddition.register('EquationsVector', EquationsVector);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNdWx0aWxpbmsiLCJOdW1iZXJQcm9wZXJ0eSIsIlJhbmdlIiwibWVyZ2UiLCJDYXJ0ZXNpYW5CYXNlVmVjdG9yIiwiQ29vcmRpbmF0ZVNuYXBNb2RlcyIsIlBvbGFyQmFzZVZlY3RvciIsIlZlY3RvciIsInZlY3RvckFkZGl0aW9uIiwiREVGQVVMVF9DT0VGRklDSUVOVCIsIkNPRUZGSUNJRU5UX1JBTkdFIiwiT1BUSU9OUyIsImlzUmVtb3ZhYmxlIiwiaXNUaXBEcmFnZ2FibGUiLCJpc09uR3JhcGhJbml0aWFsbHkiLCJFcXVhdGlvbnNWZWN0b3IiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxUYWlsUG9zaXRpb24iLCJpbml0aWFsQ29tcG9uZW50cyIsImJhc2VWZWN0b3JUYWlsUG9zaXRpb24iLCJncmFwaCIsInZlY3RvclNldCIsInN5bWJvbCIsImNvZWZmaWNpZW50UHJvcGVydHkiLCJyYW5nZSIsInNldFRpcFdpdGhJbnZhcmlhbnRzIiwidGlwIiwiYmFzZVZlY3RvciIsImNvb3JkaW5hdGVTbmFwTW9kZSIsIkNBUlRFU0lBTiIsInZlY3RvckNvbXBvbmVudHMiLCJkaXZpZGVkU2NhbGFyIiwibXVsdGlsaW5rIiwidmVjdG9yQ29tcG9uZW50c1Byb3BlcnR5IiwiY29lZmZpY2llbnQiLCJ0aW1lc1NjYWxhciIsImRpc3Bvc2UiLCJhc3NlcnQiLCJyZXNldCIsImdldExhYmVsQ29udGVudCIsInZhbHVlc1Zpc2libGUiLCJ2YWx1ZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRXF1YXRpb25zVmVjdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE5LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEVxdWF0aW9uc1ZlY3RvciBpcyBhIHNwZWNpYWxpemF0aW9uIG9mIFZlY3RvciBmb3IgdGhlICdFcXVhdGlvbnMnIHNjcmVlbi4gIEl0IGFkZHMgbXV0YWJsZSBjb2VmZmljaWVudCBhbmQgYmFzZSB2ZWN0b3IuXHJcbiAqIEluc3RhbmNlcyBleGlzdCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0gYW5kIGRvIG5vdCBuZWVkIHRvIGJlIGRpc3Bvc2VkLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEJyYW5kb24gTGlcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgTXVsdGlsaW5rIGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvTXVsdGlsaW5rLmpzJztcclxuaW1wb3J0IE51bWJlclByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvTnVtYmVyUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1JhbmdlLmpzJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCBDYXJ0ZXNpYW5CYXNlVmVjdG9yIGZyb20gJy4uLy4uL2NvbW1vbi9tb2RlbC9DYXJ0ZXNpYW5CYXNlVmVjdG9yLmpzJztcclxuaW1wb3J0IENvb3JkaW5hdGVTbmFwTW9kZXMgZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL0Nvb3JkaW5hdGVTbmFwTW9kZXMuanMnO1xyXG5pbXBvcnQgUG9sYXJCYXNlVmVjdG9yIGZyb20gJy4uLy4uL2NvbW1vbi9tb2RlbC9Qb2xhckJhc2VWZWN0b3IuanMnO1xyXG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uLy4uL2NvbW1vbi9tb2RlbC9WZWN0b3IuanMnO1xyXG5pbXBvcnQgdmVjdG9yQWRkaXRpb24gZnJvbSAnLi4vLi4vdmVjdG9yQWRkaXRpb24uanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcblxyXG4vLyBpbml0aWFsIGNvZWZmaWNpZW50IGFuZCByYW5nZVxyXG5jb25zdCBERUZBVUxUX0NPRUZGSUNJRU5UID0gMTtcclxuY29uc3QgQ09FRkZJQ0lFTlRfUkFOR0UgPSBuZXcgUmFuZ2UoIC01LCA1ICk7XHJcblxyXG4vLyBzdXBlciBjbGFzcyBvcHRpb25zXHJcbmNvbnN0IE9QVElPTlMgPSB7XHJcbiAgaXNSZW1vdmFibGU6IGZhbHNlLCAgICAgICAvLyBFcXVhdGlvbnMgdmVjdG9ycyBhcmUgbm90IHJlbW92YWJsZVxyXG4gIGlzVGlwRHJhZ2dhYmxlOiBmYWxzZSwgICAgLy8gRXF1YXRpb25zIHZlY3RvcnMgYXJlIG5vdCBkcmFnZ2FibGUgYnkgdGhlIHRpcFxyXG4gIGlzT25HcmFwaEluaXRpYWxseTogdHJ1ZSAgLy8gRXF1YXRpb25zIHZlY3RvcnMgYXJlIGFsd2F5cyBvbiB0aGUgZ3JhcGhcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVxdWF0aW9uc1ZlY3RvciBleHRlbmRzIFZlY3RvciB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gaW5pdGlhbFRhaWxQb3NpdGlvbiAtIHN0YXJ0aW5nIHRhaWwgcG9zaXRpb24gb2YgdGhlIHZlY3RvclxyXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gaW5pdGlhbENvbXBvbmVudHMgLSBzdGFydGluZyBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IGJhc2VWZWN0b3JUYWlsUG9zaXRpb24gLSBzdGFydGluZyB0YWlsIHBvc2l0aW9uIG9mIHRoZSBiYXNlIHZlY3RvclxyXG4gICAqIEBwYXJhbSB7RXF1YXRpb25zR3JhcGh9IGdyYXBoIC0gdGhlIGdyYXBoIHRoZSB2ZWN0b3IgYmVsb25ncyB0b1xyXG4gICAqIEBwYXJhbSB7RXF1YXRpb25zVmVjdG9yU2V0fSB2ZWN0b3JTZXQgLSB0aGUgVmVjdG9yU2V0IHRoYXQgdGhlIHZlY3RvciBiZWxvbmdzIHRvXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gc3ltYm9sIC0gdGhlIHN5bWJvbCBmb3IgdGhlIHZlY3RvciAoaS5lLiAnYScsICdiJywgJ2MnLCAuLi4pXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGluaXRpYWxUYWlsUG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgIGluaXRpYWxDb21wb25lbnRzLFxyXG4gICAgICAgICAgICAgICBiYXNlVmVjdG9yVGFpbFBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICBncmFwaCxcclxuICAgICAgICAgICAgICAgdmVjdG9yU2V0LFxyXG4gICAgICAgICAgICAgICBzeW1ib2xcclxuICApIHtcclxuXHJcblxyXG4gICAgc3VwZXIoIGluaXRpYWxUYWlsUG9zaXRpb24sIGluaXRpYWxDb21wb25lbnRzLCBncmFwaCwgdmVjdG9yU2V0LCBzeW1ib2wsIE9QVElPTlMgKTtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpXHJcbiAgICB0aGlzLmNvZWZmaWNpZW50UHJvcGVydHkgPSBuZXcgTnVtYmVyUHJvcGVydHkoIERFRkFVTFRfQ09FRkZJQ0lFTlQsIHtcclxuICAgICAgcmFuZ2U6IENPRUZGSUNJRU5UX1JBTkdFXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gU2V0IHRoZSB0aXAgdG8gaXRzZWxmIHRvIGVuc3VyZSBJbnZhcmlhbnRzIGZvciBQb2xhci9DYXJ0ZXNpYW4gaXMgc2F0aXNmaWVkLlxyXG4gICAgdGhpcy5zZXRUaXBXaXRoSW52YXJpYW50cyggdGhpcy50aXAgKTtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpIHtCYXNlVmVjdG9yfSBpbnN0YW50aWF0ZSBhIGJhc2UgdmVjdG9yIGJhc2VkIG9uIHNuYXAgbW9kZVxyXG4gICAgdGhpcy5iYXNlVmVjdG9yID0gbnVsbDtcclxuICAgIGlmICggZ3JhcGguY29vcmRpbmF0ZVNuYXBNb2RlID09PSBDb29yZGluYXRlU25hcE1vZGVzLkNBUlRFU0lBTiApIHtcclxuICAgICAgdGhpcy5iYXNlVmVjdG9yID0gbmV3IENhcnRlc2lhbkJhc2VWZWN0b3IoIGJhc2VWZWN0b3JUYWlsUG9zaXRpb24sXHJcbiAgICAgICAgdGhpcy52ZWN0b3JDb21wb25lbnRzLmRpdmlkZWRTY2FsYXIoIERFRkFVTFRfQ09FRkZJQ0lFTlQgKSwgZ3JhcGgsIHZlY3RvclNldCwgc3ltYm9sICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5iYXNlVmVjdG9yID0gbmV3IFBvbGFyQmFzZVZlY3RvciggYmFzZVZlY3RvclRhaWxQb3NpdGlvbixcclxuICAgICAgICB0aGlzLnZlY3RvckNvbXBvbmVudHMuZGl2aWRlZFNjYWxhciggREVGQVVMVF9DT0VGRklDSUVOVCApLCBncmFwaCwgdmVjdG9yU2V0LCBzeW1ib2wgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPYnNlcnZlIHdoZW4gdGhlIGJhc2UgdmVjdG9yIGNoYW5nZXMsIG9yIHdoZW4gdGhlIGNvZWZmaWNpZW50IFByb3BlcnR5IGNoYW5nZXMgYW5kIHVwZGF0ZSB0aGUgdmVjdG9yLlxyXG4gICAgLy8gdW5tdWx0aWxpbmsgaXMgdW5uZWNlc3NhcnksIGV4aXN0cyBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0uXHJcbiAgICBNdWx0aWxpbmsubXVsdGlsaW5rKCBbIHRoaXMuYmFzZVZlY3Rvci52ZWN0b3JDb21wb25lbnRzUHJvcGVydHksIHRoaXMuY29lZmZpY2llbnRQcm9wZXJ0eSBdLFxyXG4gICAgICAoIGJhc2VWZWN0b3IsIGNvZWZmaWNpZW50ICkgPT4ge1xyXG4gICAgICAgIHRoaXMudmVjdG9yQ29tcG9uZW50cyA9IGJhc2VWZWN0b3IudGltZXNTY2FsYXIoIGNvZWZmaWNpZW50ICk7XHJcbiAgICAgIH0gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cclxuICBkaXNwb3NlKCkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsICdFcXVhdGlvbnNWZWN0b3IgaXMgbm90IGludGVuZGVkIHRvIGJlIGRpc3Bvc2VkJyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXRzIHRoZSB2ZWN0b3IuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xyXG4gIHJlc2V0KCkge1xyXG4gICAgc3VwZXIucmVzZXQoKTtcclxuICAgIHRoaXMuY29lZmZpY2llbnRQcm9wZXJ0eS5yZXNldCgpO1xyXG4gICAgdGhpcy5iYXNlVmVjdG9yLnJlc2V0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBsYWJlbCBjb250ZW50IGluZm9ybWF0aW9uIHRvIGJlIGRpc3BsYXllZCBvbiB0aGUgdmVjdG9yLlxyXG4gICAqIFNlZSBSb290VmVjdG9yLmdldExhYmVsQ29udGVudCBmb3IgZGV0YWlscy5cclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZXNWaXNpYmxlIC0gd2hldGhlciB0aGUgdmFsdWVzIGFyZSB2aXNpYmxlXHJcbiAgICogQHJldHVybnMge09iamVjdH0gc2VlIFJvb3RWZWN0b3IuZ2V0TGFiZWxDb250ZW50XHJcbiAgICovXHJcbiAgZ2V0TGFiZWxDb250ZW50KCB2YWx1ZXNWaXNpYmxlICkge1xyXG4gICAgcmV0dXJuIG1lcmdlKCBzdXBlci5nZXRMYWJlbENvbnRlbnQoIHZhbHVlc1Zpc2libGUgKSwge1xyXG4gICAgICBjb2VmZmljaWVudDogdGhpcy5jb2VmZmljaWVudFByb3BlcnR5LnZhbHVlXHJcbiAgICB9ICk7XHJcbiAgfVxyXG59XHJcblxyXG52ZWN0b3JBZGRpdGlvbi5yZWdpc3RlciggJ0VxdWF0aW9uc1ZlY3RvcicsIEVxdWF0aW9uc1ZlY3RvciApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsU0FBUyxNQUFNLGtDQUFrQztBQUN4RCxPQUFPQyxjQUFjLE1BQU0sdUNBQXVDO0FBQ2xFLE9BQU9DLEtBQUssTUFBTSw2QkFBNkI7QUFDL0MsT0FBT0MsS0FBSyxNQUFNLG1DQUFtQztBQUNyRCxPQUFPQyxt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