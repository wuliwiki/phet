// Copyright 2019-2023, University of Colorado Boulder

/**
 * VectorSet is the model for a related set of vectors, and contains:
 *
 *  - an ObservableArrayDef of vectors
 *  - a sum vector of those vectors
 *  - a color palette that is common to all vectors
 *
 * A Graph can support multiple VectorSets. (e.g. Lab screen has 2 VectorSets per Graph)
 *
 * @author Brandon Li
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import createObservableArray from '../../../../axon/js/createObservableArray.js';
import EnumerationProperty from '../../../../axon/js/EnumerationProperty.js';
import merge from '../../../../phet-core/js/merge.js';
import vectorAddition from '../../vectorAddition.js';
import VectorAdditionConstants from '../VectorAdditionConstants.js';
import ComponentVectorStyles from './ComponentVectorStyles.js';
import SumVector from './SumVector.js';
import VectorColorPalette from './VectorColorPalette.js';

// The symbol for the sum vector.
// The reason this isn't translatable is https://github.com/phetsims/vector-addition/issues/10.
const SUM_SYMBOL = 's';
export default class VectorSet {
  /**
   * @param {Graph} graph - the graph the VectorSet belongs to
   * @param {EnumerationProperty.<ComponentVectorStyles>} componentStyleProperty - component style for all vectors
   * @param {BooleanProperty} sumVisibleProperty - controls whether the sum vector is visible
   * @param {VectorColorPalette} vectorColorPalette - color palette for vectors in this set
   * @param {Object} [options]
   */
  constructor(graph, componentStyleProperty, sumVisibleProperty, vectorColorPalette, options) {
    // Compute values for the options that are related to the PROJECTION style component vectors.
    // See https://github.com/phetsims/vector-addition/issues/225
    const viewHeadWidth = VectorAdditionConstants.COMPONENT_VECTOR_ARROW_OPTIONS.headWidth;
    assert && assert(viewHeadWidth !== undefined, 'viewHeadWidth must be defined');
    const modelHeadWidth = graph.modelViewTransformProperty.value.viewToModelDeltaX(viewHeadWidth);
    const axisSpacing = graph.modelViewTransformProperty.value.viewToModelDeltaX(1.5);
    const offsetStart = modelHeadWidth / 2 + axisSpacing;
    const offsetDelta = modelHeadWidth;
    options = merge({
      // {boolean} false means that the default SumVector will not be created, and a subclass is responsible
      // for initializing this.sumVector.
      initializeSum: true,
      // {Vector2} initial tail position of the sum. Only used if options.initializeSum = true
      initialSumTailPosition: graph.graphModelBounds.center,
      // Offsets for primary component vectors in PROJECTION style
      projectionXOffsetStart: -offsetStart,
      projectionYOffsetStart: -offsetStart,
      projectionXOffsetDelta: -offsetDelta,
      projectionYOffsetDelta: -offsetDelta,
      // Offsets for sum component vectors in PROJECTION style
      sumProjectionXOffset: offsetStart,
      sumProjectionYOffset: offsetStart
    }, options);
    assert && assert(componentStyleProperty instanceof EnumerationProperty && ComponentVectorStyles.enumeration.includes(componentStyleProperty.value), `invalid componentStyleProperty: ${componentStyleProperty}`);
    assert && assert(sumVisibleProperty instanceof BooleanProperty, `invalid sumVisibleProperty: ${sumVisibleProperty}`);
    assert && assert(vectorColorPalette instanceof VectorColorPalette, `invalid vectorColorPalette: ${vectorColorPalette}`);

    // @public {ObservableArrayDef.<Vector>} the vectors in the VectorSet
    // This array contains only what is referred to as main or parent vectors. It does not contain sum vectors,
    // component vectors, or base vectors.
    this.vectors = createObservableArray();

    // @public (read-only) {VectorColorPalette}
    this.vectorColorPalette = vectorColorPalette;

    // @public (read-only) {BooleanProperty} sumVisibleProperty
    this.sumVisibleProperty = sumVisibleProperty;

    // @public (read-only) {componentStyleProperty} componentStyleProperty
    this.componentStyleProperty = componentStyleProperty;

    // @public (read-only)
    this.projectionXOffsetStart = options.projectionXOffsetStart;
    this.projectionYOffsetStart = options.projectionYOffsetStart;
    this.sumProjectionXOffset = options.sumProjectionXOffset;
    this.sumProjectionYOffset = options.sumProjectionYOffset;
    if (options.initializeSum) {
      // @public (read-only)
      this.sumVector = new SumVector(options.initialSumTailPosition, graph, this, SUM_SYMBOL);
      this.sumVector.setProjectionOffsets(options.sumProjectionXOffset, options.sumProjectionYOffset);
    }

    // Whenever a vector is added or removed, adjust the offsets of all component vectors for PROJECTION style.
    // See https://github.com/phetsims/vector-addition/issues/225
    // unlink is unnecessary, since VectorSet own this.vectors.
    this.vectors.lengthProperty.link(length => {
      for (let i = 0; i < length; i++) {
        const xOffset = options.projectionXOffsetStart + i * options.projectionXOffsetDelta;
        const yOffset = options.projectionYOffsetStart + i * options.projectionYOffsetDelta;
        this.vectors.get(i).setProjectionOffsets(xOffset, yOffset);
      }
    });
  }

  /**
   * @public
   */
  dispose() {
    assert && assert(false, 'VectorSet is not intended to be disposed');
  }

  /**
   * Resets the VectorSet.  Called when the Reset All button is pressed.
   * @public
   */
  reset() {
    this.erase();
    assert && assert(this.sumVector, 'sumVector was never initialized');
    this.sumVector.reset();
  }

  /**
   * Erases all vectors (except the sum) from the VectorSet. Called when the eraser button is pressed.
   * @public
   */
  erase() {
    while (this.vectors.length) {
      this.vectors.pop().dispose();
    }
  }
}
vectorAddition.register('VectorSet', VectorSet);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJjcmVhdGVPYnNlcnZhYmxlQXJyYXkiLCJFbnVtZXJhdGlvblByb3BlcnR5IiwibWVyZ2UiLCJ2ZWN0b3JBZGRpdGlvbiIsIlZlY3RvckFkZGl0aW9uQ29uc3RhbnRzIiwiQ29tcG9uZW50VmVjdG9yU3R5bGVzIiwiU3VtVmVjdG9yIiwiVmVjdG9yQ29sb3JQYWxldHRlIiwiU1VNX1NZTUJPTCIsIlZlY3RvclNldCIsImNvbnN0cnVjdG9yIiwiZ3JhcGgiLCJjb21wb25lbnRTdHlsZVByb3BlcnR5Iiwic3VtVmlzaWJsZVByb3BlcnR5IiwidmVjdG9yQ29sb3JQYWxldHRlIiwib3B0aW9ucyIsInZpZXdIZWFkV2lkdGgiLCJDT01QT05FTlRfVkVDVE9SX0FSUk9XX09QVElPTlMiLCJoZWFkV2lkdGgiLCJhc3NlcnQiLCJ1bmRlZmluZWQiLCJtb2RlbEhlYWRXaWR0aCIsIm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5IiwidmFsdWUiLCJ2aWV3VG9Nb2RlbERlbHRhWCIsImF4aXNTcGFjaW5nIiwib2Zmc2V0U3RhcnQiLCJvZmZzZXREZWx0YSIsImluaXRpYWxpemVTdW0iLCJpbml0aWFsU3VtVGFpbFBvc2l0aW9uIiwiZ3JhcGhNb2RlbEJvdW5kcyIsImNlbnRlciIsInByb2plY3Rpb25YT2Zmc2V0U3RhcnQiLCJwcm9qZWN0aW9uWU9mZnNldFN0YXJ0IiwicHJvamVjdGlvblhPZmZzZXREZWx0YSIsInByb2plY3Rpb25ZT2Zmc2V0RGVsdGEiLCJzdW1Qcm9qZWN0aW9uWE9mZnNldCIsInN1bVByb2plY3Rpb25ZT2Zmc2V0IiwiZW51bWVyYXRpb24iLCJpbmNsdWRlcyIsInZlY3RvcnMiLCJzdW1WZWN0b3IiLCJzZXRQcm9qZWN0aW9uT2Zmc2V0cyIsImxlbmd0aFByb3BlcnR5IiwibGluayIsImxlbmd0aCIsImkiLCJ4T2Zmc2V0IiwieU9mZnNldCIsImdldCIsImRpc3Bvc2UiLCJyZXNldCIsImVyYXNlIiwicG9wIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJWZWN0b3JTZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVmVjdG9yU2V0IGlzIHRoZSBtb2RlbCBmb3IgYSByZWxhdGVkIHNldCBvZiB2ZWN0b3JzLCBhbmQgY29udGFpbnM6XHJcbiAqXHJcbiAqICAtIGFuIE9ic2VydmFibGVBcnJheURlZiBvZiB2ZWN0b3JzXHJcbiAqICAtIGEgc3VtIHZlY3RvciBvZiB0aG9zZSB2ZWN0b3JzXHJcbiAqICAtIGEgY29sb3IgcGFsZXR0ZSB0aGF0IGlzIGNvbW1vbiB0byBhbGwgdmVjdG9yc1xyXG4gKlxyXG4gKiBBIEdyYXBoIGNhbiBzdXBwb3J0IG11bHRpcGxlIFZlY3RvclNldHMuIChlLmcuIExhYiBzY3JlZW4gaGFzIDIgVmVjdG9yU2V0cyBwZXIgR3JhcGgpXHJcbiAqXHJcbiAqIEBhdXRob3IgQnJhbmRvbiBMaVxyXG4gKi9cclxuXHJcbmltcG9ydCBCb29sZWFuUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9Cb29sZWFuUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgY3JlYXRlT2JzZXJ2YWJsZUFycmF5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvY3JlYXRlT2JzZXJ2YWJsZUFycmF5LmpzJztcclxuaW1wb3J0IEVudW1lcmF0aW9uUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9FbnVtZXJhdGlvblByb3BlcnR5LmpzJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCB2ZWN0b3JBZGRpdGlvbiBmcm9tICcuLi8uLi92ZWN0b3JBZGRpdGlvbi5qcyc7XHJcbmltcG9ydCBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cyBmcm9tICcuLi9WZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBDb21wb25lbnRWZWN0b3JTdHlsZXMgZnJvbSAnLi9Db21wb25lbnRWZWN0b3JTdHlsZXMuanMnO1xyXG5pbXBvcnQgU3VtVmVjdG9yIGZyb20gJy4vU3VtVmVjdG9yLmpzJztcclxuaW1wb3J0IFZlY3RvckNvbG9yUGFsZXR0ZSBmcm9tICcuL1ZlY3RvckNvbG9yUGFsZXR0ZS5qcyc7XHJcblxyXG4vLyBUaGUgc3ltYm9sIGZvciB0aGUgc3VtIHZlY3Rvci5cclxuLy8gVGhlIHJlYXNvbiB0aGlzIGlzbid0IHRyYW5zbGF0YWJsZSBpcyBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdmVjdG9yLWFkZGl0aW9uL2lzc3Vlcy8xMC5cclxuY29uc3QgU1VNX1NZTUJPTCA9ICdzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvclNldCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7R3JhcGh9IGdyYXBoIC0gdGhlIGdyYXBoIHRoZSBWZWN0b3JTZXQgYmVsb25ncyB0b1xyXG4gICAqIEBwYXJhbSB7RW51bWVyYXRpb25Qcm9wZXJ0eS48Q29tcG9uZW50VmVjdG9yU3R5bGVzPn0gY29tcG9uZW50U3R5bGVQcm9wZXJ0eSAtIGNvbXBvbmVudCBzdHlsZSBmb3IgYWxsIHZlY3RvcnNcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW5Qcm9wZXJ0eX0gc3VtVmlzaWJsZVByb3BlcnR5IC0gY29udHJvbHMgd2hldGhlciB0aGUgc3VtIHZlY3RvciBpcyB2aXNpYmxlXHJcbiAgICogQHBhcmFtIHtWZWN0b3JDb2xvclBhbGV0dGV9IHZlY3RvckNvbG9yUGFsZXR0ZSAtIGNvbG9yIHBhbGV0dGUgZm9yIHZlY3RvcnMgaW4gdGhpcyBzZXRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGdyYXBoLCBjb21wb25lbnRTdHlsZVByb3BlcnR5LCBzdW1WaXNpYmxlUHJvcGVydHksIHZlY3RvckNvbG9yUGFsZXR0ZSwgb3B0aW9ucyApIHtcclxuXHJcbiAgICAvLyBDb21wdXRlIHZhbHVlcyBmb3IgdGhlIG9wdGlvbnMgdGhhdCBhcmUgcmVsYXRlZCB0byB0aGUgUFJPSkVDVElPTiBzdHlsZSBjb21wb25lbnQgdmVjdG9ycy5cclxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdmVjdG9yLWFkZGl0aW9uL2lzc3Vlcy8yMjVcclxuICAgIGNvbnN0IHZpZXdIZWFkV2lkdGggPSBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5DT01QT05FTlRfVkVDVE9SX0FSUk9XX09QVElPTlMuaGVhZFdpZHRoO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdmlld0hlYWRXaWR0aCAhPT0gdW5kZWZpbmVkLCAndmlld0hlYWRXaWR0aCBtdXN0IGJlIGRlZmluZWQnICk7XHJcbiAgICBjb25zdCBtb2RlbEhlYWRXaWR0aCA9IGdyYXBoLm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5LnZhbHVlLnZpZXdUb01vZGVsRGVsdGFYKCB2aWV3SGVhZFdpZHRoICk7XHJcbiAgICBjb25zdCBheGlzU3BhY2luZyA9IGdyYXBoLm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5LnZhbHVlLnZpZXdUb01vZGVsRGVsdGFYKCAxLjUgKTtcclxuICAgIGNvbnN0IG9mZnNldFN0YXJ0ID0gKCBtb2RlbEhlYWRXaWR0aCAvIDIgKSArIGF4aXNTcGFjaW5nO1xyXG4gICAgY29uc3Qgb2Zmc2V0RGVsdGEgPSBtb2RlbEhlYWRXaWR0aDtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuXHJcbiAgICAgIC8vIHtib29sZWFufSBmYWxzZSBtZWFucyB0aGF0IHRoZSBkZWZhdWx0IFN1bVZlY3RvciB3aWxsIG5vdCBiZSBjcmVhdGVkLCBhbmQgYSBzdWJjbGFzcyBpcyByZXNwb25zaWJsZVxyXG4gICAgICAvLyBmb3IgaW5pdGlhbGl6aW5nIHRoaXMuc3VtVmVjdG9yLlxyXG4gICAgICBpbml0aWFsaXplU3VtOiB0cnVlLFxyXG5cclxuICAgICAgLy8ge1ZlY3RvcjJ9IGluaXRpYWwgdGFpbCBwb3NpdGlvbiBvZiB0aGUgc3VtLiBPbmx5IHVzZWQgaWYgb3B0aW9ucy5pbml0aWFsaXplU3VtID0gdHJ1ZVxyXG4gICAgICBpbml0aWFsU3VtVGFpbFBvc2l0aW9uOiBncmFwaC5ncmFwaE1vZGVsQm91bmRzLmNlbnRlcixcclxuXHJcbiAgICAgIC8vIE9mZnNldHMgZm9yIHByaW1hcnkgY29tcG9uZW50IHZlY3RvcnMgaW4gUFJPSkVDVElPTiBzdHlsZVxyXG4gICAgICBwcm9qZWN0aW9uWE9mZnNldFN0YXJ0OiAtb2Zmc2V0U3RhcnQsXHJcbiAgICAgIHByb2plY3Rpb25ZT2Zmc2V0U3RhcnQ6IC1vZmZzZXRTdGFydCxcclxuICAgICAgcHJvamVjdGlvblhPZmZzZXREZWx0YTogLW9mZnNldERlbHRhLFxyXG4gICAgICBwcm9qZWN0aW9uWU9mZnNldERlbHRhOiAtb2Zmc2V0RGVsdGEsXHJcblxyXG4gICAgICAvLyBPZmZzZXRzIGZvciBzdW0gY29tcG9uZW50IHZlY3RvcnMgaW4gUFJPSkVDVElPTiBzdHlsZVxyXG4gICAgICBzdW1Qcm9qZWN0aW9uWE9mZnNldDogb2Zmc2V0U3RhcnQsXHJcbiAgICAgIHN1bVByb2plY3Rpb25ZT2Zmc2V0OiBvZmZzZXRTdGFydFxyXG5cclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBjb21wb25lbnRTdHlsZVByb3BlcnR5IGluc3RhbmNlb2YgRW51bWVyYXRpb25Qcm9wZXJ0eSAmJiBDb21wb25lbnRWZWN0b3JTdHlsZXMuZW51bWVyYXRpb24uaW5jbHVkZXMoIGNvbXBvbmVudFN0eWxlUHJvcGVydHkudmFsdWUgKSxcclxuICAgICAgYGludmFsaWQgY29tcG9uZW50U3R5bGVQcm9wZXJ0eTogJHtjb21wb25lbnRTdHlsZVByb3BlcnR5fWAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHN1bVZpc2libGVQcm9wZXJ0eSBpbnN0YW5jZW9mIEJvb2xlYW5Qcm9wZXJ0eSwgYGludmFsaWQgc3VtVmlzaWJsZVByb3BlcnR5OiAke3N1bVZpc2libGVQcm9wZXJ0eX1gICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB2ZWN0b3JDb2xvclBhbGV0dGUgaW5zdGFuY2VvZiBWZWN0b3JDb2xvclBhbGV0dGUsIGBpbnZhbGlkIHZlY3RvckNvbG9yUGFsZXR0ZTogJHt2ZWN0b3JDb2xvclBhbGV0dGV9YCApO1xyXG5cclxuICAgIC8vIEBwdWJsaWMge09ic2VydmFibGVBcnJheURlZi48VmVjdG9yPn0gdGhlIHZlY3RvcnMgaW4gdGhlIFZlY3RvclNldFxyXG4gICAgLy8gVGhpcyBhcnJheSBjb250YWlucyBvbmx5IHdoYXQgaXMgcmVmZXJyZWQgdG8gYXMgbWFpbiBvciBwYXJlbnQgdmVjdG9ycy4gSXQgZG9lcyBub3QgY29udGFpbiBzdW0gdmVjdG9ycyxcclxuICAgIC8vIGNvbXBvbmVudCB2ZWN0b3JzLCBvciBiYXNlIHZlY3RvcnMuXHJcbiAgICB0aGlzLnZlY3RvcnMgPSBjcmVhdGVPYnNlcnZhYmxlQXJyYXkoKTtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpIHtWZWN0b3JDb2xvclBhbGV0dGV9XHJcbiAgICB0aGlzLnZlY3RvckNvbG9yUGFsZXR0ZSA9IHZlY3RvckNvbG9yUGFsZXR0ZTtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpIHtCb29sZWFuUHJvcGVydHl9IHN1bVZpc2libGVQcm9wZXJ0eVxyXG4gICAgdGhpcy5zdW1WaXNpYmxlUHJvcGVydHkgPSBzdW1WaXNpYmxlUHJvcGVydHk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyAocmVhZC1vbmx5KSB7Y29tcG9uZW50U3R5bGVQcm9wZXJ0eX0gY29tcG9uZW50U3R5bGVQcm9wZXJ0eVxyXG4gICAgdGhpcy5jb21wb25lbnRTdHlsZVByb3BlcnR5ID0gY29tcG9uZW50U3R5bGVQcm9wZXJ0eTtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpXHJcbiAgICB0aGlzLnByb2plY3Rpb25YT2Zmc2V0U3RhcnQgPSBvcHRpb25zLnByb2plY3Rpb25YT2Zmc2V0U3RhcnQ7XHJcbiAgICB0aGlzLnByb2plY3Rpb25ZT2Zmc2V0U3RhcnQgPSBvcHRpb25zLnByb2plY3Rpb25ZT2Zmc2V0U3RhcnQ7XHJcbiAgICB0aGlzLnN1bVByb2plY3Rpb25YT2Zmc2V0ID0gb3B0aW9ucy5zdW1Qcm9qZWN0aW9uWE9mZnNldDtcclxuICAgIHRoaXMuc3VtUHJvamVjdGlvbllPZmZzZXQgPSBvcHRpb25zLnN1bVByb2plY3Rpb25ZT2Zmc2V0O1xyXG5cclxuICAgIGlmICggb3B0aW9ucy5pbml0aWFsaXplU3VtICkge1xyXG5cclxuICAgICAgLy8gQHB1YmxpYyAocmVhZC1vbmx5KVxyXG4gICAgICB0aGlzLnN1bVZlY3RvciA9IG5ldyBTdW1WZWN0b3IoIG9wdGlvbnMuaW5pdGlhbFN1bVRhaWxQb3NpdGlvbiwgZ3JhcGgsIHRoaXMsIFNVTV9TWU1CT0wgKTtcclxuICAgICAgdGhpcy5zdW1WZWN0b3Iuc2V0UHJvamVjdGlvbk9mZnNldHMoIG9wdGlvbnMuc3VtUHJvamVjdGlvblhPZmZzZXQsIG9wdGlvbnMuc3VtUHJvamVjdGlvbllPZmZzZXQgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXaGVuZXZlciBhIHZlY3RvciBpcyBhZGRlZCBvciByZW1vdmVkLCBhZGp1c3QgdGhlIG9mZnNldHMgb2YgYWxsIGNvbXBvbmVudCB2ZWN0b3JzIGZvciBQUk9KRUNUSU9OIHN0eWxlLlxyXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy92ZWN0b3ItYWRkaXRpb24vaXNzdWVzLzIyNVxyXG4gICAgLy8gdW5saW5rIGlzIHVubmVjZXNzYXJ5LCBzaW5jZSBWZWN0b3JTZXQgb3duIHRoaXMudmVjdG9ycy5cclxuICAgIHRoaXMudmVjdG9ycy5sZW5ndGhQcm9wZXJ0eS5saW5rKCBsZW5ndGggPT4ge1xyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcclxuICAgICAgICBjb25zdCB4T2Zmc2V0ID0gb3B0aW9ucy5wcm9qZWN0aW9uWE9mZnNldFN0YXJ0ICsgaSAqIG9wdGlvbnMucHJvamVjdGlvblhPZmZzZXREZWx0YTtcclxuICAgICAgICBjb25zdCB5T2Zmc2V0ID0gb3B0aW9ucy5wcm9qZWN0aW9uWU9mZnNldFN0YXJ0ICsgaSAqIG9wdGlvbnMucHJvamVjdGlvbllPZmZzZXREZWx0YTtcclxuICAgICAgICB0aGlzLnZlY3RvcnMuZ2V0KCBpICkuc2V0UHJvamVjdGlvbk9mZnNldHMoIHhPZmZzZXQsIHlPZmZzZXQgKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ1ZlY3RvclNldCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgZGlzcG9zZWQnICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldHMgdGhlIFZlY3RvclNldC4gIENhbGxlZCB3aGVuIHRoZSBSZXNldCBBbGwgYnV0dG9uIGlzIHByZXNzZWQuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHJlc2V0KCkge1xyXG5cclxuICAgIHRoaXMuZXJhc2UoKTtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0aGlzLnN1bVZlY3RvciwgJ3N1bVZlY3RvciB3YXMgbmV2ZXIgaW5pdGlhbGl6ZWQnICk7XHJcbiAgICB0aGlzLnN1bVZlY3Rvci5yZXNldCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXJhc2VzIGFsbCB2ZWN0b3JzIChleGNlcHQgdGhlIHN1bSkgZnJvbSB0aGUgVmVjdG9yU2V0LiBDYWxsZWQgd2hlbiB0aGUgZXJhc2VyIGJ1dHRvbiBpcyBwcmVzc2VkLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBlcmFzZSgpIHtcclxuICAgIHdoaWxlICggdGhpcy52ZWN0b3JzLmxlbmd0aCApIHtcclxuICAgICAgdGhpcy52ZWN0b3JzLnBvcCgpLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZlY3RvckFkZGl0aW9uLnJlZ2lzdGVyKCAnVmVjdG9yU2V0JywgVmVjdG9yU2V0ICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLGVBQWUsTUFBTSx3Q0FBd0M7QUFDcEUsT0FBT0MscUJBQXFCLE1BQU0sOENBQThDO0FBQ2hGLE9BQU9DLG1CQUFtQixNQUFNLDRDQUE0QztBQUM1RSxPQUFPQyxLQUFLLE1BQU0sbUNBQW1DO0FBQ3JELE9BQU9DLGNBQWMsTUFBTSx5QkFBeUI7QUFDcEQsT0FBT0MsdUJBQXVCLE1BQU0sK0JBQStCO0FBQ25FLE9BQU9DLHFCQUFxQixNQUFNLDRCQUE0QjtBQUM5RCxPQUFPQyxTQUFTLE1BQU0sZ0JBQWdCO0FBQ3RDLE9BQU9DLGtCQUFrQixNQUFNLHlCQUF5Qjs7QUFFeEQ7QUFDQTtBQUNBLE1BQU1DLFVBQVUsR0FBRyxHQUFHO0FBRXRCLGVBQWUsTUFBTUMsU0FBUyxDQUFDO0VBRTdCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VDLFdBQVdBLENBQUVDLEtBQUssRUFBRUMsc0JBQXNCLEVBQUVDLGtCQUFrQixFQUFFQyxrQkFBa0IsRUFBRUMsT0FBTyxFQUFHO0lBRTVGO0lBQ0E7SUFDQSxNQUFNQyxhQUFhLEdBQUdaLHVCQUF1QixDQUFDYSw4QkFBOEIsQ0FBQ0MsU0FBUztJQUN0RkMsTUFBTSxJQUFJQSxNQUFNLENBQUVILGFBQWEsS0FBS0ksU0FBUyxFQUFFLCtCQUFnQyxDQUFDO0lBQ2hGLE1BQU1DLGNBQWMsR0FBR1YsS0FBSyxDQUFDVywwQkFBMEIsQ0FBQ0MsS0FBSyxDQUFDQyxpQkFBaUIsQ0FBRVIsYUFBYyxDQUFDO0lBQ2hHLE1BQU1TLFdBQVcsR0FBR2QsS0FBSyxD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