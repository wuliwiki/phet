// Copyright 2019-2023, University of Colorado Boulder

/**
 * Graph is the base class for graphs, intended to be sub-classed. A screen can have multiple graphs.
 *
 * Graphs are responsible for:
 *   - Keeping track of where the origin is dragged and updating a modelViewTransformProperty.
 *   - Keeping track of the active (selected) vector on a graph.
 *   - Managing one or more VectorSets
 *
 * @author Brandon Li
 */

import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import Property from '../../../../axon/js/Property.js';
import Bounds2 from '../../../../dot/js/Bounds2.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import merge from '../../../../phet-core/js/merge.js';
import ModelViewTransform2 from '../../../../phetcommon/js/view/ModelViewTransform2.js';
import vectorAddition from '../../vectorAddition.js';
import VectorAdditionConstants from '../VectorAdditionConstants.js';
import CoordinateSnapModes from './CoordinateSnapModes.js';
import GraphOrientations from './GraphOrientations.js';
import Vector from './Vector.js';

//----------------------------------------------------------------------------------------
// constants

// Since the origin is being dragged, modelViewTransform is in the model. That being said, it is necessary to know the
// view coordinates of the graph node's bottom-left to calculate the model view transform.
// Calculate the default for the grid's bottom-left, in view coordinates.
const DEFAULT_BOTTOM_LEFT = new Vector2(VectorAdditionConstants.SCREEN_VIEW_BOUNDS.minX + VectorAdditionConstants.AXES_ARROW_X_EXTENSION + 10, VectorAdditionConstants.SCREEN_VIEW_BOUNDS.maxY - VectorAdditionConstants.AXES_ARROW_Y_EXTENSION - 45);

// scale of the coordinate transformation of model coordinates to view coordinates
const MODEL_TO_VIEW_SCALE = 14.5;
export default class Graph {
  /**
   * @param {Bounds2} initialGraphBounds - the model bounds of the graph at the start of the sim
   * @param {CoordinateSnapModes} coordinateSnapMode - the coordinate snap mode of the graph. A graph is either
   *                                                   strictly polar or Cartesian.
   * @param {Object} [options]
   */
  constructor(initialGraphBounds, coordinateSnapMode, options) {
    assert && assert(initialGraphBounds instanceof Bounds2, `invalid initialGraphBounds: ${initialGraphBounds}`);
    assert && assert(CoordinateSnapModes.enumeration.includes(coordinateSnapMode), `invalid coordinateSnapMode: ${coordinateSnapMode}`);
    options = merge({
      orientation: GraphOrientations.TWO_DIMENSIONAL,
      bottomLeft: DEFAULT_BOTTOM_LEFT // bottom left corner of the graph, in view coordinates
    }, options);

    //----------------------------------------------------------------------------------------

    // @public {VectorSet[]} the vectorSets for this graph
    this.vectorSets = [];

    // @public (read-only) {GraphOrientations} orientation of the graph
    this.orientation = options.orientation;

    // @public (read-only) {CoordinateSnapModes} coordinate snap mode for the graph, Cartesian or polar
    this.coordinateSnapMode = coordinateSnapMode;

    // @private {Property.<Bounds2>} bounds of the graph, in model coordinates.
    // Use graphModelBounds() to read this.
    this.graphModelBoundsProperty = new Property(initialGraphBounds, {
      valueType: Bounds2
    });

    // @public (read-only) bounds of the graph in view coordinates, constant for the lifetime of the sim.
    this.graphViewBounds = new Bounds2(options.bottomLeft.x, options.bottomLeft.y - MODEL_TO_VIEW_SCALE * initialGraphBounds.height, options.bottomLeft.x + MODEL_TO_VIEW_SCALE * initialGraphBounds.width, options.bottomLeft.y);

    // @public (read-only) {DerivedProperty.<ModelViewTransform2>} maps graph coordinates between model and view
    // dispose is unnecessary, exists for the lifetime of the sim.
    this.modelViewTransformProperty = new DerivedProperty([this.graphModelBoundsProperty], graphModelBounds => ModelViewTransform2.createRectangleInvertedYMapping(graphModelBounds, this.graphViewBounds), {
      valueType: ModelViewTransform2
    });

    // @public {Property.<Vector|null>} activeVectorProperty - the active (selected) vector.
    // A graph has at most one active vector. If null, there is no active vector.
    this.activeVectorProperty = new Property(null, {
      isValidValue: value => {
        return value === null || value instanceof Vector;
      }
    });
  }

  /**
   * @public
   */
  dispose() {
    assert && assert(false, 'Graph is not intended to be disposed');
  }

  /**
   * Resets the graph.
   * @public
   */
  reset() {
    this.graphModelBoundsProperty.reset();
    this.vectorSets.forEach(vectorSet => vectorSet.reset());
    this.activeVectorProperty.reset();
  }

  /**
   * Erases the graph.
   * @public
   */
  erase() {
    this.vectorSets.forEach(vectorSet => vectorSet.erase());
    this.activeVectorProperty.reset();
  }

  /**
   * Moves the origin to a specified point on the graph.
   * @public
   * @param {Vector2} point
   */
  moveOriginToPoint(point) {
    assert && assert(point instanceof Vector2 && this.graphModelBoundsProperty.value.containsPoint(point), `invalid point: ${point}`);

    // Round to integer
    const roundedPoint = point.roundSymmetric();
    this.graphModelBoundsProperty.value = this.graphModelBounds.shiftedXY(-roundedPoint.x, -roundedPoint.y);
  }

  /**
   * Gets the bounds of the graph
   * @public
   * @returns {Bounds2}
   */
  get graphModelBounds() {
    return this.graphModelBoundsProperty.value;
  }
}
Graph.DEFAULT_BOTTOM_LEFT = DEFAULT_BOTTOM_LEFT;
vectorAddition.register('Graph', Graph);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEZXJpdmVkUHJvcGVydHkiLCJQcm9wZXJ0eSIsIkJvdW5kczIiLCJWZWN0b3IyIiwibWVyZ2UiLCJNb2RlbFZpZXdUcmFuc2Zvcm0yIiwidmVjdG9yQWRkaXRpb24iLCJWZWN0b3JBZGRpdGlvbkNvbnN0YW50cyIsIkNvb3JkaW5hdGVTbmFwTW9kZXMiLCJHcmFwaE9yaWVudGF0aW9ucyIsIlZlY3RvciIsIkRFRkFVTFRfQk9UVE9NX0xFRlQiLCJTQ1JFRU5fVklFV19CT1VORFMiLCJtaW5YIiwiQVhFU19BUlJPV19YX0VYVEVOU0lPTiIsIm1heFkiLCJBWEVTX0FSUk9XX1lfRVhURU5TSU9OIiwiTU9ERUxfVE9fVklFV19TQ0FMRSIsIkdyYXBoIiwiY29uc3RydWN0b3IiLCJpbml0aWFsR3JhcGhCb3VuZHMiLCJjb29yZGluYXRlU25hcE1vZGUiLCJvcHRpb25zIiwiYXNzZXJ0IiwiZW51bWVyYXRpb24iLCJpbmNsdWRlcyIsIm9yaWVudGF0aW9uIiwiVFdPX0RJTUVOU0lPTkFMIiwiYm90dG9tTGVmdCIsInZlY3RvclNldHMiLCJncmFwaE1vZGVsQm91bmRzUHJvcGVydHkiLCJ2YWx1ZVR5cGUiLCJncmFwaFZpZXdCb3VuZHMiLCJ4IiwieSIsImhlaWdodCIsIndpZHRoIiwibW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkiLCJncmFwaE1vZGVsQm91bmRzIiwiY3JlYXRlUmVjdGFuZ2xlSW52ZXJ0ZWRZTWFwcGluZyIsImFjdGl2ZVZlY3RvclByb3BlcnR5IiwiaXNWYWxpZFZhbHVlIiwidmFsdWUiLCJkaXNwb3NlIiwicmVzZXQiLCJmb3JFYWNoIiwidmVjdG9yU2V0IiwiZXJhc2UiLCJtb3ZlT3JpZ2luVG9Qb2ludCIsInBvaW50IiwiY29udGFpbnNQb2ludCIsInJvdW5kZWRQb2ludCIsInJvdW5kU3ltbWV0cmljIiwic2hpZnRlZFhZIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJHcmFwaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOS0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBHcmFwaCBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgZ3JhcGhzLCBpbnRlbmRlZCB0byBiZSBzdWItY2xhc3NlZC4gQSBzY3JlZW4gY2FuIGhhdmUgbXVsdGlwbGUgZ3JhcGhzLlxyXG4gKlxyXG4gKiBHcmFwaHMgYXJlIHJlc3BvbnNpYmxlIGZvcjpcclxuICogICAtIEtlZXBpbmcgdHJhY2sgb2Ygd2hlcmUgdGhlIG9yaWdpbiBpcyBkcmFnZ2VkIGFuZCB1cGRhdGluZyBhIG1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5LlxyXG4gKiAgIC0gS2VlcGluZyB0cmFjayBvZiB0aGUgYWN0aXZlIChzZWxlY3RlZCkgdmVjdG9yIG9uIGEgZ3JhcGguXHJcbiAqICAgLSBNYW5hZ2luZyBvbmUgb3IgbW9yZSBWZWN0b3JTZXRzXHJcbiAqXHJcbiAqIEBhdXRob3IgQnJhbmRvbiBMaVxyXG4gKi9cclxuXHJcbmltcG9ydCBEZXJpdmVkUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9EZXJpdmVkUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9Qcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lcmdlLmpzJztcclxuaW1wb3J0IE1vZGVsVmlld1RyYW5zZm9ybTIgZnJvbSAnLi4vLi4vLi4vLi4vcGhldGNvbW1vbi9qcy92aWV3L01vZGVsVmlld1RyYW5zZm9ybTIuanMnO1xyXG5pbXBvcnQgdmVjdG9yQWRkaXRpb24gZnJvbSAnLi4vLi4vdmVjdG9yQWRkaXRpb24uanMnO1xyXG5pbXBvcnQgVmVjdG9yQWRkaXRpb25Db25zdGFudHMgZnJvbSAnLi4vVmVjdG9yQWRkaXRpb25Db25zdGFudHMuanMnO1xyXG5pbXBvcnQgQ29vcmRpbmF0ZVNuYXBNb2RlcyBmcm9tICcuL0Nvb3JkaW5hdGVTbmFwTW9kZXMuanMnO1xyXG5pbXBvcnQgR3JhcGhPcmllbnRhdGlvbnMgZnJvbSAnLi9HcmFwaE9yaWVudGF0aW9ucy5qcyc7XHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi9WZWN0b3IuanMnO1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIGNvbnN0YW50c1xyXG5cclxuLy8gU2luY2UgdGhlIG9yaWdpbiBpcyBiZWluZyBkcmFnZ2VkLCBtb2RlbFZpZXdUcmFuc2Zvcm0gaXMgaW4gdGhlIG1vZGVsLiBUaGF0IGJlaW5nIHNhaWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBrbm93IHRoZVxyXG4vLyB2aWV3IGNvb3JkaW5hdGVzIG9mIHRoZSBncmFwaCBub2RlJ3MgYm90dG9tLWxlZnQgdG8gY2FsY3VsYXRlIHRoZSBtb2RlbCB2aWV3IHRyYW5zZm9ybS5cclxuLy8gQ2FsY3VsYXRlIHRoZSBkZWZhdWx0IGZvciB0aGUgZ3JpZCdzIGJvdHRvbS1sZWZ0LCBpbiB2aWV3IGNvb3JkaW5hdGVzLlxyXG5jb25zdCBERUZBVUxUX0JPVFRPTV9MRUZUID0gbmV3IFZlY3RvcjIoXHJcbiAgVmVjdG9yQWRkaXRpb25Db25zdGFudHMuU0NSRUVOX1ZJRVdfQk9VTkRTLm1pblggKyBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5BWEVTX0FSUk9XX1hfRVhURU5TSU9OICsgMTAsXHJcbiAgVmVjdG9yQWRkaXRpb25Db25zdGFudHMuU0NSRUVOX1ZJRVdfQk9VTkRTLm1heFkgLSBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5BWEVTX0FSUk9XX1lfRVhURU5TSU9OIC0gNDVcclxuKTtcclxuXHJcbi8vIHNjYWxlIG9mIHRoZSBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uIG9mIG1vZGVsIGNvb3JkaW5hdGVzIHRvIHZpZXcgY29vcmRpbmF0ZXNcclxuY29uc3QgTU9ERUxfVE9fVklFV19TQ0FMRSA9IDE0LjU7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Qm91bmRzMn0gaW5pdGlhbEdyYXBoQm91bmRzIC0gdGhlIG1vZGVsIGJvdW5kcyBvZiB0aGUgZ3JhcGggYXQgdGhlIHN0YXJ0IG9mIHRoZSBzaW1cclxuICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVTbmFwTW9kZXN9IGNvb3JkaW5hdGVTbmFwTW9kZSAtIHRoZSBjb29yZGluYXRlIHNuYXAgbW9kZSBvZiB0aGUgZ3JhcGguIEEgZ3JhcGggaXMgZWl0aGVyXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RseSBwb2xhciBvciBDYXJ0ZXNpYW4uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBpbml0aWFsR3JhcGhCb3VuZHMsIGNvb3JkaW5hdGVTbmFwTW9kZSwgb3B0aW9ucyApIHtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBpbml0aWFsR3JhcGhCb3VuZHMgaW5zdGFuY2VvZiBCb3VuZHMyLCBgaW52YWxpZCBpbml0aWFsR3JhcGhCb3VuZHM6ICR7aW5pdGlhbEdyYXBoQm91bmRzfWAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIENvb3JkaW5hdGVTbmFwTW9kZXMuZW51bWVyYXRpb24uaW5jbHVkZXMoIGNvb3JkaW5hdGVTbmFwTW9kZSApLCBgaW52YWxpZCBjb29yZGluYXRlU25hcE1vZGU6ICR7Y29vcmRpbmF0ZVNuYXBNb2RlfWAgKTtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuICAgICAgb3JpZW50YXRpb246IEdyYXBoT3JpZW50YXRpb25zLlRXT19ESU1FTlNJT05BTCxcclxuICAgICAgYm90dG9tTGVmdDogREVGQVVMVF9CT1RUT01fTEVGVCAvLyBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIGdyYXBoLCBpbiB2aWV3IGNvb3JkaW5hdGVzXHJcbiAgICB9LCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLy8gQHB1YmxpYyB7VmVjdG9yU2V0W119IHRoZSB2ZWN0b3JTZXRzIGZvciB0aGlzIGdyYXBoXHJcbiAgICB0aGlzLnZlY3RvclNldHMgPSBbXTtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpIHtHcmFwaE9yaWVudGF0aW9uc30gb3JpZW50YXRpb24gb2YgdGhlIGdyYXBoXHJcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvbjtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpIHtDb29yZGluYXRlU25hcE1vZGVzfSBjb29yZGluYXRlIHNuYXAgbW9kZSBmb3IgdGhlIGdyYXBoLCBDYXJ0ZXNpYW4gb3IgcG9sYXJcclxuICAgIHRoaXMuY29vcmRpbmF0ZVNuYXBNb2RlID0gY29vcmRpbmF0ZVNuYXBNb2RlO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtQcm9wZXJ0eS48Qm91bmRzMj59IGJvdW5kcyBvZiB0aGUgZ3JhcGgsIGluIG1vZGVsIGNvb3JkaW5hdGVzLlxyXG4gICAgLy8gVXNlIGdyYXBoTW9kZWxCb3VuZHMoKSB0byByZWFkIHRoaXMuXHJcbiAgICB0aGlzLmdyYXBoTW9kZWxCb3VuZHNQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eSggaW5pdGlhbEdyYXBoQm91bmRzLCB7XHJcbiAgICAgIHZhbHVlVHlwZTogQm91bmRzMlxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIEBwdWJsaWMgKHJlYWQtb25seSkgYm91bmRzIG9mIHRoZSBncmFwaCBpbiB2aWV3IGNvb3JkaW5hdGVzLCBjb25zdGFudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0uXHJcbiAgICB0aGlzLmdyYXBoVmlld0JvdW5kcyA9IG5ldyBCb3VuZHMyKCBvcHRpb25zLmJvdHRvbUxlZnQueCxcclxuICAgICAgb3B0aW9ucy5ib3R0b21MZWZ0LnkgLSBNT0RFTF9UT19WSUVXX1NDQUxFICogaW5pdGlhbEdyYXBoQm91bmRzLmhlaWdodCxcclxuICAgICAgb3B0aW9ucy5ib3R0b21MZWZ0LnggKyBNT0RFTF9UT19WSUVXX1NDQUxFICogaW5pdGlhbEdyYXBoQm91bmRzLndpZHRoLFxyXG4gICAgICBvcHRpb25zLmJvdHRvbUxlZnQueSApO1xyXG5cclxuICAgIC8vIEBwdWJsaWMgKHJlYWQtb25seSkge0Rlcml2ZWRQcm9wZXJ0eS48TW9kZWxWaWV3VHJhbnNmb3JtMj59IG1hcHMgZ3JhcGggY29vcmRpbmF0ZXMgYmV0d2VlbiBtb2RlbCBhbmQgdmlld1xyXG4gICAgLy8gZGlzcG9zZSBpcyB1bm5lY2Vzc2FyeSwgZXhpc3RzIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbS5cclxuICAgIHRoaXMubW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkgPSBuZXcgRGVyaXZlZFByb3BlcnR5KFxyXG4gICAgICBbIHRoaXMuZ3JhcGhNb2RlbEJvdW5kc1Byb3BlcnR5IF0sXHJcbiAgICAgIGdyYXBoTW9kZWxCb3VuZHMgPT4gTW9kZWxWaWV3VHJhbnNmb3JtMi5jcmVhdGVSZWN0YW5nbGVJbnZlcnRlZFlNYXBwaW5nKCBncmFwaE1vZGVsQm91bmRzLCB0aGlzLmdyYXBoVmlld0JvdW5kcyApLFxyXG4gICAgICB7IHZhbHVlVHlwZTogTW9kZWxWaWV3VHJhbnNmb3JtMiB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vIEBwdWJsaWMge1Byb3BlcnR5LjxWZWN0b3J8bnVsbD59IGFjdGl2ZVZlY3RvclByb3BlcnR5IC0gdGhlIGFjdGl2ZSAoc2VsZWN0ZWQpIHZlY3Rvci5cclxuICAgIC8vIEEgZ3JhcGggaGFzIGF0IG1vc3Qgb25lIGFjdGl2ZSB2ZWN0b3IuIElmIG51bGwsIHRoZXJlIGlzIG5vIGFjdGl2ZSB2ZWN0b3IuXHJcbiAgICB0aGlzLmFjdGl2ZVZlY3RvclByb3BlcnR5ID0gbmV3IFByb3BlcnR5KCBudWxsLCB7XHJcbiAgICAgIGlzVmFsaWRWYWx1ZTogdmFsdWUgPT4ge1xyXG4gICAgICAgIHJldHVybiAoIHZhbHVlID09PSBudWxsIHx8IHZhbHVlIGluc3RhbmNlb2YgVmVjdG9yICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBkaXNwb3NlKCkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsICdHcmFwaCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgZGlzcG9zZWQnICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldHMgdGhlIGdyYXBoLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICByZXNldCgpIHtcclxuICAgIHRoaXMuZ3JhcGhNb2RlbEJvdW5kc1Byb3BlcnR5LnJlc2V0KCk7XHJcbiAgICB0aGlzLnZlY3RvclNldHMuZm9yRWFjaCggdmVjdG9yU2V0ID0+IHZlY3RvclNldC5yZXNldCgpICk7XHJcbiAgICB0aGlzLmFjdGl2ZVZlY3RvclByb3BlcnR5LnJlc2V0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFcmFzZXMgdGhlIGdyYXBoLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBlcmFzZSgpIHtcclxuICAgIHRoaXMudmVjdG9yU2V0cy5mb3JFYWNoKCB2ZWN0b3JTZXQgPT4gdmVjdG9yU2V0LmVyYXNlKCkgKTtcclxuICAgIHRoaXMuYWN0aXZlVmVjdG9yUHJvcGVydHkucmVzZXQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmVzIHRoZSBvcmlnaW4gdG8gYSBzcGVjaWZpZWQgcG9pbnQgb24gdGhlIGdyYXBoLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHBvaW50XHJcbiAgICovXHJcbiAgbW92ZU9yaWdpblRvUG9pbnQoIHBvaW50ICkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggcG9pbnQgaW5zdGFuY2VvZiBWZWN0b3IyICYmIHRoaXMuZ3JhcGhNb2RlbEJvdW5kc1Byb3BlcnR5LnZhbHVlLmNvbnRhaW5zUG9pbnQoIHBvaW50ICksXHJcbiAgICAgIGBpbnZhbGlkIHBvaW50OiAke3BvaW50fWAgKTtcclxuXHJcbiAgICAvLyBSb3VuZCB0byBpbnRlZ2VyXHJcbiAgICBjb25zdCByb3VuZGVkUG9pbnQgPSBwb2ludC5yb3VuZFN5bW1ldHJpYygpO1xyXG4gICAgdGhpcy5ncmFwaE1vZGVsQm91bmRzUHJvcGVydHkudmFsdWUgPSB0aGlzLmdyYXBoTW9kZWxCb3VuZHMuc2hpZnRlZFhZKCAtcm91bmRlZFBvaW50LngsIC1yb3VuZGVkUG9pbnQueSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgYm91bmRzIG9mIHRoZSBncmFwaFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7Qm91bmRzMn1cclxuICAgKi9cclxuICBnZXQgZ3JhcGhNb2RlbEJvdW5kcygpIHtcclxuICAgIHJldHVybiB0aGlzLmdyYXBoTW9kZWxCb3VuZHNQcm9wZXJ0eS52YWx1ZTtcclxuICB9XHJcbn1cclxuXHJcbkdyYXBoLkRFRkFVTFRfQk9UVE9NX0xFRlQgPSBERUZBVUxUX0JPVFRPTV9MRUZUO1xyXG5cclxudmVjdG9yQWRkaXRpb24ucmVnaXN0ZXIoICdHcmFwaCcsIEdyYXBoICk7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxlQUFl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