// Copyright 2019-2023, University of Colorado Boulder

/**
 * GraphNode draws the graph, including its grid, axes, ticks, and origin manipulator.
 *
 * @author Martin Veillette
 * @author Chris Malley (PixelZoom, Inc.)
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import merge from '../../../../phet-core/js/merge.js';
import ArrowNode from '../../../../scenery-phet/js/ArrowNode.js';
import { Color, Node, Path, Rectangle, Text } from '../../../../scenery/js/imports.js';
import vectorAddition from '../../vectorAddition.js';
import VectorAdditionStrings from '../../VectorAdditionStrings.js';
import Graph from '../model/Graph.js';
import GraphOrientations from '../model/GraphOrientations.js';
import VectorAdditionColors from '../VectorAdditionColors.js';
import VectorAdditionConstants from '../VectorAdditionConstants.js';
import OriginManipulator from './OriginManipulator.js';

//----------------------------------------------------------------------------------------
// constants

// grid
const MAJOR_GRID_LINE_WIDTH = 1.5; // view units
const MINOR_GRID_LINE_WIDTH = 1; // view units

// axes
const AXES_ARROW_X_EXTENSION = VectorAdditionConstants.AXES_ARROW_X_EXTENSION;
const AXES_ARROW_Y_EXTENSION = VectorAdditionConstants.AXES_ARROW_Y_EXTENSION;

// tick marks
const MAJOR_TICK_SPACING = 5; // model units
const MINOR_TICK_SPACING = 1; // model units
const TICK_LENGTH = 1; // model units
const ORIGIN_TICK_LENGTH = 2; // model units
const TICK_MARK_OPTIONS = {
  lineWidth: 1,
  stroke: Color.BLACK
};

// tick labels
const TICK_LABEL_OPTIONS = {
  font: VectorAdditionConstants.TICK_LABEL_FONT,
  fill: 'rgb( 130, 130, 130 )',
  maxWidth: 30
};
const TICK_LABEL_SPACING = 10; // model units
const TICK_LABEL_X_OFFSET = 15; // from x = 0, view units
const TICK_LABEL_Y_OFFSET = 15; // from y = 0, view units

//----------------------------------------------------------------------------------------

export default class GraphNode extends Node {
  /**
   * @param {Graph} graph - the model graph for the node
   * @param {BooleanProperty} gridVisibilityProperty
   */
  constructor(graph, gridVisibilityProperty) {
    assert && assert(graph instanceof Graph, `invalid graph: ${graph}`);
    assert && assert(gridVisibilityProperty instanceof BooleanProperty, `invalid gridVisibilityProperty: ${gridVisibilityProperty}`);
    const graphViewBounds = graph.graphViewBounds;
    const background = new Rectangle(graphViewBounds, {
      fill: VectorAdditionColors.GRAPH_BACKGROUND_COLOR,
      stroke: VectorAdditionColors.GRAPH_MINOR_LINE_COLOR,
      lineWidth: MINOR_GRID_LINE_WIDTH
    });
    const children = [background, new MajorAndMinorGridLines(graph, graphViewBounds, gridVisibilityProperty), new TicksNode(graph)];

    // Create axes as needed, based on graph orientation
    if (graph.orientation !== GraphOrientations.VERTICAL) {
      children.push(new XAxisNode(graph, graphViewBounds));
    }
    children.push(new OriginManipulator(graph));
    super({
      children: children
    });

    // Clicking in the graph clears the active (selected) vector.
    // Use a raw 'down' listener so that this doesn't impact the ability to touch snag vectors and origin manipulator.
    // See https://github.com/phetsims/vector-addition/issues/243
    // No need to remove, exists for the lifetime of the sim.
    background.addInputListener({
      down: () => {
        graph.activeVectorProperty.value = null;
      }
    });
  }

  /**
   * @public
   * @override
   */
  dispose() {
    assert && assert(false, 'GraphNode is not intended to be disposed');
  }
}

/**
 * Draws the major and minor grid lines.  Handles visibility of the grid.
 */
class MajorAndMinorGridLines extends Node {
  /**
   * @param {Graph} graph - the model graph for the node
   * @param {Bounds2} graphViewBounds
   * @param {BooleanProperty} gridVisibilityProperty
   */
  constructor(graph, graphViewBounds, gridVisibilityProperty) {
    assert && assert(graph instanceof Graph, `invalid graph: ${graph}`);
    assert && assert(gridVisibilityProperty instanceof BooleanProperty, `invalid gridVisibilityProperty: ${gridVisibilityProperty}`);
    const majorGridLines = new GridLines(graph, graphViewBounds, {
      spacing: MAJOR_TICK_SPACING,
      lineWidth: MAJOR_GRID_LINE_WIDTH,
      stroke: VectorAdditionColors.GRAPH_MAJOR_LINE_COLOR
    });
    const minorGridLinesPath = new GridLines(graph, graphViewBounds, {
      spacing: MINOR_TICK_SPACING,
      lineWidth: MINOR_GRID_LINE_WIDTH,
      stroke: VectorAdditionColors.GRAPH_MINOR_LINE_COLOR
    });
    super({
      children: [minorGridLinesPath, majorGridLines],
      pickable: false
    });

    // Observe changes to the grid visibility Property, and update visibility.
    // No need to unlink since GraphNodes exist for the lifetime of the sim.
    gridVisibilityProperty.linkAttribute(this, 'visible');
  }
}

/**
 * Draws grid lines at some spacing. Used to draw one type of grid line (major or minor).
 * Updates when the origin changes. Optimized to take advantage of constant view bounds.
 */
class GridLines extends Path {
  /**
   * @param {Graph} graph - the model graph for the node
   * @param {Bounds2} graphViewBounds
   * @param {Object} [options]
   */
  constructor(graph, graphViewBounds, options) {
    options = merge({
      spacing: 1,
      lineWidth: 1,
      stroke: 'black'
    }, options);
    super(new Shape(), options);

    // @private
    this.graphViewBounds = graphViewBounds;

    // Update when the modelViewTransform changes, triggered when the origin is moved.
    // unlink is unnecessary, exists for the lifetime of the sim.
    graph.modelViewTransformProperty.link(modelViewTransform => {
      // Convenience variables
      const graphMinX = graph.graphModelBounds.minX;
      const graphMaxX = graph.graphModelBounds.maxX;
      const graphMinY = graph.graphModelBounds.minY;
      const graphMaxY = graph.graphModelBounds.maxY;
      const shape = new Shape();

      // Vertical lines
      const firstX = graphMinX - graphMinX % options.spacing;
      for (let xValue = firstX; xValue <= graphMaxX; xValue += options.spacing) {
        shape.moveTo(xValue, graphMinY).verticalLineTo(graphMaxY);
      }

      // Horizontal lines
      const firstY = graphMinY - graphMinY % options.spacing;
      for (let yValue = firstY; yValue <= graphMaxY; yValue += options.spacing) {
        shape.moveTo(graphMinX, yValue).horizontalLineTo(graphMaxX);
      }
      this.setShape(modelViewTransform.modelToViewShape(shape));
    });
  }

  /**
   * Performance optimization, since the grid's view bounds are constant.
   * @public
   * @override
   * @returns {Bounds2}
   */
  computeShapeBounds() {
    return this.graphViewBounds;
  }
}

/**
 * Draws the x axis.
 */
class XAxisNode extends Node {
  /**
   * @param {Graph} graph
   * @param {Bounds2} graphViewBounds
   */
  constructor(graph, graphViewBounds) {
    const arrowNode = new ArrowNode(graphViewBounds.minX - AXES_ARROW_X_EXTENSION, 0, graphViewBounds.maxX + AXES_ARROW_X_EXTENSION, 0, VectorAdditionConstants.AXES_ARROW_OPTIONS);
    const axisLabel = new Text(VectorAdditionStrings.symbol.x, {
      font: VectorAdditionConstants.AXIS_LABEL_FONT,
      maxWidth: 22,
      left: arrowNode.right + 6,
      centerY: arrowNode.centerY
    });
    super({
      children: [arrowNode, axisLabel],
      pickable: false
    });

    // When the origin moves, adjust the position of the axis.
    // unlink is unnecessary, exists for the lifetime of the sim.
    graph.modelViewTransformProperty.link(modelViewTransform => {
      this.y = modelViewTransform.modelToViewY(0);
    });
  }
}

/**
 * Draws the tick marks and labels.
 */
class TicksNode extends Node {
  /**
   * @param {Graph} graph
   */
  constructor(graph) {
    const tickMarksPath = new Path(new Shape(), TICK_MARK_OPTIONS);
    const tickLabelsParent = new Node();
    const originLabel = new Text('0', TICK_LABEL_OPTIONS);
    super({
      children: [tickMarksPath, tickLabelsParent],
      pickable: false
    });

    // Update ticks when the graph's origin moves.
    // unlink is unnecessary, exists for the lifetime of the sim.
    graph.modelViewTransformProperty.link(modelViewTransform => {
      const viewOrigin = modelViewTransform.modelToViewPosition(Vector2.ZERO);
      const tickMarksShape = new Shape();
      const tickLabels = [];
      if (graph.orientation !== GraphOrientations.VERTICAL) {
        // x tick marks
        const firstXTick = graph.graphModelBounds.minX - graph.graphModelBounds.minX % MAJOR_TICK_SPACING;
        for (let xValue = firstXTick; xValue <= graph.graphModelBounds.maxX; xValue = xValue + MAJOR_TICK_SPACING) {
          const tickLength = xValue === 0 ? ORIGIN_TICK_LENGTH : TICK_LENGTH; // origin tick is different
          tickMarksShape.moveTo(xValue, -tickLength / 2).verticalLineTo(tickLength / 2);
        }

        // x tick labels
        const firstXLabel = graph.graphModelBounds.minX - graph.graphModelBounds.minX % TICK_LABEL_SPACING;
        for (let xValue = firstXLabel; xValue <= graph.graphModelBounds.maxX; xValue = xValue + TICK_LABEL_SPACING) {
          if (xValue !== 0) {
            const tickLabel = new Text(xValue, TICK_LABEL_OPTIONS);
            tickLabel.centerX = modelViewTransform.modelToViewX(xValue);
            tickLabel.top = viewOrigin.y + TICK_LABEL_Y_OFFSET;
            tickLabels.push(tickLabel);
          }
        }
      }
      if (graph.orientation !== GraphOrientations.HORIZONTAL) {
        // y tick marks
        const firstYTick = graph.graphModelBounds.minY - graph.graphModelBounds.minY % MAJOR_TICK_SPACING;
        for (let yValue = firstYTick; yValue <= graph.graphModelBounds.maxY; yValue = yValue + MAJOR_TICK_SPACING) {
          const tickLength = yValue === 0 ? ORIGIN_TICK_LENGTH : TICK_LENGTH; // origin tick is different
          tickMarksShape.moveTo(-tickLength / 2, yValue).horizontalLineTo(tickLength / 2);
        }

        // y tick labels
        const firstYLabel = graph.graphModelBounds.minY - graph.graphModelBounds.minY % TICK_LABEL_SPACING;
        for (let yValue = firstYLabel; yValue <= graph.graphModelBounds.maxY; yValue = yValue + TICK_LABEL_SPACING) {
          if (yValue !== 0) {
            const tickLabel = new Text(yValue, TICK_LABEL_OPTIONS);
            tickLabel.right = viewOrigin.x - TICK_LABEL_X_OFFSET;
            tickLabel.centerY = modelViewTransform.modelToViewY(yValue);
            tickLabels.push(tickLabel);
          }
        }
      }

      // Origin tick label
      if (graph.orientation !== GraphOrientations.TWO_DIMENSIONAL) {
        tickLabels.push(originLabel);
        if (graph.orientation === GraphOrientations.HORIZONTAL) {
          originLabel.centerX = viewOrigin.x;
          originLabel.top = viewOrigin.y + TICK_LABEL_Y_OFFSET;
        } else {
          originLabel.right = viewOrigin.x - TICK_LABEL_X_OFFSET;
          originLabel.centerY = viewOrigin.y;
        }
      }
      tickMarksPath.shape = modelViewTransform.modelToViewShape(tickMarksShape);
      tickLabelsParent.children = tickLabels;
    });
  }
}
vectorAddition.register('GraphNode', GraphNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJWZWN0b3IyIiwiU2hhcGUiLCJtZXJnZSIsIkFycm93Tm9kZSIsIkNvbG9yIiwiTm9kZSIsIlBhdGgiLCJSZWN0YW5nbGUiLCJUZXh0IiwidmVjdG9yQWRkaXRpb24iLCJWZWN0b3JBZGRpdGlvblN0cmluZ3MiLCJHcmFwaCIsIkdyYXBoT3JpZW50YXRpb25zIiwiVmVjdG9yQWRkaXRpb25Db2xvcnMiLCJWZWN0b3JBZGRpdGlvbkNvbnN0YW50cyIsIk9yaWdpbk1hbmlwdWxhdG9yIiwiTUFKT1JfR1JJRF9MSU5FX1dJRFRIIiwiTUlOT1JfR1JJRF9MSU5FX1dJRFRIIiwiQVhFU19BUlJPV19YX0VYVEVOU0lPTiIsIkFYRVNfQVJST1dfWV9FWFRFTlNJT04iLCJNQUpPUl9USUNLX1NQQUNJTkciLCJNSU5PUl9USUNLX1NQQUNJTkciLCJUSUNLX0xFTkdUSCIsIk9SSUdJTl9USUNLX0xFTkdUSCIsIlRJQ0tfTUFSS19PUFRJT05TIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiQkxBQ0siLCJUSUNLX0xBQkVMX09QVElPTlMiLCJmb250IiwiVElDS19MQUJFTF9GT05UIiwiZmlsbCIsIm1heFdpZHRoIiwiVElDS19MQUJFTF9TUEFDSU5HIiwiVElDS19MQUJFTF9YX09GRlNFVCIsIlRJQ0tfTEFCRUxfWV9PRkZTRVQiLCJHcmFwaE5vZGUiLCJjb25zdHJ1Y3RvciIsImdyYXBoIiwiZ3JpZFZpc2liaWxpdHlQcm9wZXJ0eSIsImFzc2VydCIsImdyYXBoVmlld0JvdW5kcyIsImJhY2tncm91bmQiLCJHUkFQSF9CQUNLR1JPVU5EX0NPTE9SIiwiR1JBUEhfTUlOT1JfTElORV9DT0xPUiIsImNoaWxkcmVuIiwiTWFqb3JBbmRNaW5vckdyaWRMaW5lcyIsIlRpY2tzTm9kZSIsIm9yaWVudGF0aW9uIiwiVkVSVElDQUwiLCJwdXNoIiwiWEF4aXNOb2RlIiwiYWRkSW5wdXRMaXN0ZW5lciIsImRvd24iLCJhY3RpdmVWZWN0b3JQcm9wZXJ0eSIsInZhbHVlIiwiZGlzcG9zZSIsIm1ham9yR3JpZExpbmVzIiwiR3JpZExpbmVzIiwic3BhY2luZyIsIkdSQVBIX01BSk9SX0xJTkVfQ09MT1IiLCJtaW5vckdyaWRMaW5lc1BhdGgiLCJwaWNrYWJsZSIsImxpbmtBdHRyaWJ1dGUiLCJvcHRpb25zIiwibW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkiLCJsaW5rIiwibW9kZWxWaWV3VHJhbnNmb3JtIiwiZ3JhcGhNaW5YIiwiZ3JhcGhNb2RlbEJvdW5kcyIsIm1pblgiLCJncmFwaE1heFgiLCJtYXhYIiwiZ3JhcGhNaW5ZIiwibWluWSIsImdyYXBoTWF4WSIsIm1heFkiLCJzaGFwZSIsImZpcnN0WCIsInhWYWx1ZSIsIm1vdmVUbyIsInZlcnRpY2FsTGluZVRvIiwiZmlyc3RZIiwieVZhbHVlIiwiaG9yaXpvbnRhbExpbmVUbyIsInNldFNoYXBlIiwibW9kZWxUb1ZpZXdTaGFwZSIsImNvbXB1dGVTaGFwZUJvdW5kcyIsImFycm93Tm9kZSIsIkFYRVNfQVJST1dfT1BUSU9OUyIsImF4aXNMYWJlbCIsInN5bWJvbCIsIngiLCJBWElTX0xBQkVMX0ZPTlQiLCJsZWZ0IiwicmlnaHQiLCJjZW50ZXJZIiwieSIsIm1vZGVsVG9WaWV3WSIsInRpY2tNYXJrc1BhdGgiLCJ0aWNrTGFiZWxzUGFyZW50Iiwib3JpZ2luTGFiZWwiLCJ2aWV3T3JpZ2luIiwibW9kZWxUb1ZpZXdQb3NpdGlvbiIsIlpFUk8iLCJ0aWNrTWFya3NTaGFwZSIsInRpY2tMYWJlbHMiLCJmaXJzdFhUaWNrIiwidGlja0xlbmd0aCIsImZpcnN0WExhYmVsIiwidGlja0xhYmVsIiwiY2VudGVyWCIsIm1vZGVsVG9WaWV3WCIsInRvcCIsIkhPUklaT05UQUwiLCJmaXJzdFlUaWNrIiwiZmlyc3RZTGFiZWwiLCJUV09fRElNRU5TSU9OQUwiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkdyYXBoTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOS0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBHcmFwaE5vZGUgZHJhd3MgdGhlIGdyYXBoLCBpbmNsdWRpbmcgaXRzIGdyaWQsIGF4ZXMsIHRpY2tzLCBhbmQgb3JpZ2luIG1hbmlwdWxhdG9yLlxyXG4gKlxyXG4gKiBAYXV0aG9yIE1hcnRpbiBWZWlsbGV0dGVcclxuICogQGF1dGhvciBDaHJpcyBNYWxsZXkgKFBpeGVsWm9vbSwgSW5jLilcclxuICovXHJcblxyXG5pbXBvcnQgQm9vbGVhblByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvQm9vbGVhblByb3BlcnR5LmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgQXJyb3dOb2RlIGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9BcnJvd05vZGUuanMnO1xyXG5pbXBvcnQgeyBDb2xvciwgTm9kZSwgUGF0aCwgUmVjdGFuZ2xlLCBUZXh0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IHZlY3RvckFkZGl0aW9uIGZyb20gJy4uLy4uL3ZlY3RvckFkZGl0aW9uLmpzJztcclxuaW1wb3J0IFZlY3RvckFkZGl0aW9uU3RyaW5ncyBmcm9tICcuLi8uLi9WZWN0b3JBZGRpdGlvblN0cmluZ3MuanMnO1xyXG5pbXBvcnQgR3JhcGggZnJvbSAnLi4vbW9kZWwvR3JhcGguanMnO1xyXG5pbXBvcnQgR3JhcGhPcmllbnRhdGlvbnMgZnJvbSAnLi4vbW9kZWwvR3JhcGhPcmllbnRhdGlvbnMuanMnO1xyXG5pbXBvcnQgVmVjdG9yQWRkaXRpb25Db2xvcnMgZnJvbSAnLi4vVmVjdG9yQWRkaXRpb25Db2xvcnMuanMnO1xyXG5pbXBvcnQgVmVjdG9yQWRkaXRpb25Db25zdGFudHMgZnJvbSAnLi4vVmVjdG9yQWRkaXRpb25Db25zdGFudHMuanMnO1xyXG5pbXBvcnQgT3JpZ2luTWFuaXB1bGF0b3IgZnJvbSAnLi9PcmlnaW5NYW5pcHVsYXRvci5qcyc7XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gY29uc3RhbnRzXHJcblxyXG4vLyBncmlkXHJcbmNvbnN0IE1BSk9SX0dSSURfTElORV9XSURUSCA9IDEuNTsgLy8gdmlldyB1bml0c1xyXG5jb25zdCBNSU5PUl9HUklEX0xJTkVfV0lEVEggPSAxOyAvLyB2aWV3IHVuaXRzXHJcblxyXG4vLyBheGVzXHJcbmNvbnN0IEFYRVNfQVJST1dfWF9FWFRFTlNJT04gPSBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5BWEVTX0FSUk9XX1hfRVhURU5TSU9OO1xyXG5jb25zdCBBWEVTX0FSUk9XX1lfRVhURU5TSU9OID0gVmVjdG9yQWRkaXRpb25Db25zdGFudHMuQVhFU19BUlJPV19ZX0VYVEVOU0lPTjtcclxuXHJcbi8vIHRpY2sgbWFya3NcclxuY29uc3QgTUFKT1JfVElDS19TUEFDSU5HID0gNTsgLy8gbW9kZWwgdW5pdHNcclxuY29uc3QgTUlOT1JfVElDS19TUEFDSU5HID0gMTsgLy8gbW9kZWwgdW5pdHNcclxuY29uc3QgVElDS19MRU5HVEggPSAxOyAvLyBtb2RlbCB1bml0c1xyXG5jb25zdCBPUklHSU5fVElDS19MRU5HVEggPSAyOyAvLyBtb2RlbCB1bml0c1xyXG5jb25zdCBUSUNLX01BUktfT1BUSU9OUyA9IHtcclxuICBsaW5lV2lkdGg6IDEsXHJcbiAgc3Ryb2tlOiBDb2xvci5CTEFDS1xyXG59O1xyXG5cclxuLy8gdGljayBsYWJlbHNcclxuY29uc3QgVElDS19MQUJFTF9PUFRJT05TID0ge1xyXG4gIGZvbnQ6IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlRJQ0tfTEFCRUxfRk9OVCxcclxuICBmaWxsOiAncmdiKCAxMzAsIDEzMCwgMTMwICknLFxyXG4gIG1heFdpZHRoOiAzMFxyXG59O1xyXG5jb25zdCBUSUNLX0xBQkVMX1NQQUNJTkcgPSAxMDsgLy8gbW9kZWwgdW5pdHNcclxuY29uc3QgVElDS19MQUJFTF9YX09GRlNFVCA9IDE1OyAvLyBmcm9tIHggPSAwLCB2aWV3IHVuaXRzXHJcbmNvbnN0IFRJQ0tfTEFCRUxfWV9PRkZTRVQgPSAxNTsgLy8gZnJvbSB5ID0gMCwgdmlldyB1bml0c1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaE5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtHcmFwaH0gZ3JhcGggLSB0aGUgbW9kZWwgZ3JhcGggZm9yIHRoZSBub2RlXHJcbiAgICogQHBhcmFtIHtCb29sZWFuUHJvcGVydHl9IGdyaWRWaXNpYmlsaXR5UHJvcGVydHlcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggZ3JhcGgsIGdyaWRWaXNpYmlsaXR5UHJvcGVydHkgKSB7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZ3JhcGggaW5zdGFuY2VvZiBHcmFwaCwgYGludmFsaWQgZ3JhcGg6ICR7Z3JhcGh9YCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZ3JpZFZpc2liaWxpdHlQcm9wZXJ0eSBpbnN0YW5jZW9mIEJvb2xlYW5Qcm9wZXJ0eSwgYGludmFsaWQgZ3JpZFZpc2liaWxpdHlQcm9wZXJ0eTogJHtncmlkVmlzaWJpbGl0eVByb3BlcnR5fWAgKTtcclxuXHJcbiAgICBjb25zdCBncmFwaFZpZXdCb3VuZHMgPSBncmFwaC5ncmFwaFZpZXdCb3VuZHM7XHJcblxyXG4gICAgY29uc3QgYmFja2dyb3VuZCA9IG5ldyBSZWN0YW5nbGUoIGdyYXBoVmlld0JvdW5kcywge1xyXG4gICAgICBmaWxsOiBWZWN0b3JBZGRpdGlvbkNvbG9ycy5HUkFQSF9CQUNLR1JPVU5EX0NPTE9SLFxyXG4gICAgICBzdHJva2U6IFZlY3RvckFkZGl0aW9uQ29sb3JzLkdSQVBIX01JTk9SX0xJTkVfQ09MT1IsXHJcbiAgICAgIGxpbmVXaWR0aDogTUlOT1JfR1JJRF9MSU5FX1dJRFRIXHJcbiAgICB9ICk7XHJcblxyXG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXHJcbiAgICAgIGJhY2tncm91bmQsXHJcbiAgICAgIG5ldyBNYWpvckFuZE1pbm9yR3JpZExpbmVzKCBncmFwaCwgZ3JhcGhWaWV3Qm91bmRzLCBncmlkVmlzaWJpbGl0eVByb3BlcnR5ICksXHJcbiAgICAgIG5ldyBUaWNrc05vZGUoIGdyYXBoIClcclxuICAgIF07XHJcblxyXG4gICAgLy8gQ3JlYXRlIGF4ZXMgYXMgbmVlZGVkLCBiYXNlZCBvbiBncmFwaCBvcmllbnRhdGlvblxyXG4gICAgaWYgKCBncmFwaC5vcmllbnRhdGlvbiAhPT0gR3JhcGhPcmllbnRhdGlvbnMuVkVSVElDQUwgKSB7XHJcbiAgICAgIGNoaWxkcmVuLnB1c2goIG5ldyBYQXhpc05vZGUoIGdyYXBoLCBncmFwaFZpZXdCb3VuZHMgKSApO1xyXG4gICAgfVxyXG5cclxuICAgIGNoaWxkcmVuLnB1c2goIG5ldyBPcmlnaW5NYW5pcHVsYXRvciggZ3JhcGggKSApO1xyXG5cclxuICAgIHN1cGVyKCB7XHJcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIENsaWNraW5nIGluIHRoZSBncmFwaCBjbGVhcnMgdGhlIGFjdGl2ZSAoc2VsZWN0ZWQpIHZlY3Rvci5cclxuICAgIC8vIFVzZSBhIHJhdyAnZG93bicgbGlzdGVuZXIgc28gdGhhdCB0aGlzIGRvZXNuJ3QgaW1wYWN0IHRoZSBhYmlsaXR5IHRvIHRvdWNoIHNuYWcgdmVjdG9ycyBhbmQgb3JpZ2luIG1hbmlwdWxhdG9yLlxyXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy92ZWN0b3ItYWRkaXRpb24vaXNzdWVzLzI0M1xyXG4gICAgLy8gTm8gbmVlZCB0byByZW1vdmUsIGV4aXN0cyBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0uXHJcbiAgICBiYWNrZ3JvdW5kLmFkZElucHV0TGlzdGVuZXIoIHtcclxuICAgICAgZG93bjogKCkgPT4geyBncmFwaC5hY3RpdmVWZWN0b3JQcm9wZXJ0eS52YWx1ZSA9IG51bGw7IH1cclxuICAgIH0gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cclxuICBkaXNwb3NlKCkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZmFsc2UsICdHcmFwaE5vZGUgaXMgbm90IGludGVuZGVkIHRvIGJlIGRpc3Bvc2VkJyApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERyYXdzIHRoZSBtYWpvciBhbmQgbWlub3IgZ3JpZCBsaW5lcy4gIEhhbmRsZXMgdmlzaWJpbGl0eSBvZiB0aGUgZ3JpZC5cclxuICovXHJcbmNsYXNzIE1ham9yQW5kTWlub3JHcmlkTGluZXMgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtHcmFwaH0gZ3JhcGggLSB0aGUgbW9kZWwgZ3JhcGggZm9yIHRoZSBub2RlXHJcbiAgICogQHBhcmFtIHtCb3VuZHMyfSBncmFwaFZpZXdCb3VuZHNcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW5Qcm9wZXJ0eX0gZ3JpZFZpc2liaWxpdHlQcm9wZXJ0eVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBncmFwaCwgZ3JhcGhWaWV3Qm91bmRzLCBncmlkVmlzaWJpbGl0eVByb3BlcnR5ICkge1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGdyYXBoIGluc3RhbmNlb2YgR3JhcGgsIGBpbnZhbGlkIGdyYXBoOiAke2dyYXBofWAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGdyaWRWaXNpYmlsaXR5UHJvcGVydHkgaW5zdGFuY2VvZiBCb29sZWFuUHJvcGVydHksXHJcbiAgICAgIGBpbnZhbGlkIGdyaWRWaXNpYmlsaXR5UHJvcGVydHk6ICR7Z3JpZFZpc2liaWxpdHlQcm9wZXJ0eX1gICk7XHJcblxyXG4gICAgY29uc3QgbWFqb3JHcmlkTGluZXMgPSBuZXcgR3JpZExpbmVzKCBncmFwaCwgZ3JhcGhWaWV3Qm91bmRzLCB7XHJcbiAgICAgIHNwYWNpbmc6IE1BSk9SX1RJQ0tfU1BBQ0lORyxcclxuICAgICAgbGluZVdpZHRoOiBNQUpPUl9HUklEX0xJTkVfV0lEVEgsXHJcbiAgICAgIHN0cm9rZTogVmVjdG9yQWRkaXRpb25Db2xvcnMuR1JBUEhfTUFKT1JfTElORV9DT0xPUlxyXG4gICAgfSApO1xyXG5cclxuICAgIGNvbnN0IG1pbm9yR3JpZExpbmVzUGF0aCA9IG5ldyBHcmlkTGluZXMoIGdyYXBoLCBncmFwaFZpZXdCb3VuZHMsIHtcclxuICAgICAgc3BhY2luZzogTUlOT1JfVElDS19TUEFDSU5HLFxyXG4gICAgICBsaW5lV2lkdGg6IE1JTk9SX0dSSURfTElORV9XSURUSCxcclxuICAgICAgc3Ryb2tlOiBWZWN0b3JBZGRpdGlvbkNvbG9ycy5HUkFQSF9NSU5PUl9MSU5FX0NPTE9SXHJcbiAgICB9ICk7XHJcblxyXG4gICAgc3VwZXIoIHtcclxuICAgICAgY2hpbGRyZW46IFsgbWlub3JHcmlkTGluZXNQYXRoLCBtYWpvckdyaWRMaW5lcyBdLFxyXG4gICAgICBwaWNrYWJsZTogZmFsc2VcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBPYnNlcnZlIGNoYW5nZXMgdG8gdGhlIGdyaWQgdmlzaWJpbGl0eSBQcm9wZXJ0eSwgYW5kIHVwZGF0ZSB2aXNpYmlsaXR5LlxyXG4gICAgLy8gTm8gbmVlZCB0byB1bmxpbmsgc2luY2UgR3JhcGhOb2RlcyBleGlzdCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0uXHJcbiAgICBncmlkVmlzaWJpbGl0eVByb3BlcnR5LmxpbmtBdHRyaWJ1dGUoIHRoaXMsICd2aXNpYmxlJyApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERyYXdzIGdyaWQgbGluZXMgYXQgc29tZSBzcGFjaW5nLiBVc2VkIHRvIGRyYXcgb25lIHR5cGUgb2YgZ3JpZCBsaW5lIChtYWpvciBvciBtaW5vcikuXHJcbiAqIFVwZGF0ZXMgd2hlbiB0aGUgb3JpZ2luIGNoYW5nZXMuIE9wdGltaXplZCB0byB0YWtlIGFkdmFudGFnZSBvZiBjb25zdGFudCB2aWV3IGJvdW5kcy5cclxuICovXHJcbmNsYXNzIEdyaWRMaW5lcyBleHRlbmRzIFBhdGgge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0dyYXBofSBncmFwaCAtIHRoZSBtb2RlbCBncmFwaCBmb3IgdGhlIG5vZGVcclxuICAgKiBAcGFyYW0ge0JvdW5kczJ9IGdyYXBoVmlld0JvdW5kc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggZ3JhcGgsIGdyYXBoVmlld0JvdW5kcywgb3B0aW9ucyApIHtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuICAgICAgc3BhY2luZzogMSxcclxuICAgICAgbGluZVdpZHRoOiAxLFxyXG4gICAgICBzdHJva2U6ICdibGFjaydcclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICBzdXBlciggbmV3IFNoYXBlKCksIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy5ncmFwaFZpZXdCb3VuZHMgPSBncmFwaFZpZXdCb3VuZHM7XHJcblxyXG4gICAgLy8gVXBkYXRlIHdoZW4gdGhlIG1vZGVsVmlld1RyYW5zZm9ybSBjaGFuZ2VzLCB0cmlnZ2VyZWQgd2hlbiB0aGUgb3JpZ2luIGlzIG1vdmVkLlxyXG4gICAgLy8gdW5saW5rIGlzIHVubmVjZXNzYXJ5LCBleGlzdHMgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgc2ltLlxyXG4gICAgZ3JhcGgubW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkubGluayggbW9kZWxWaWV3VHJhbnNmb3JtID0+IHtcclxuXHJcbiAgICAgIC8vIENvbnZlbmllbmNlIHZhcmlhYmxlc1xyXG4gICAgICBjb25zdCBncmFwaE1pblggPSBncmFwaC5ncmFwaE1vZGVsQm91bmRzLm1pblg7XHJcbiAgICAgIGNvbnN0IGdyYXBoTWF4WCA9IGdyYXBoLmdyYXBoTW9kZWxCb3VuZHMubWF4WDtcclxuICAgICAgY29uc3QgZ3JhcGhNaW5ZID0gZ3JhcGguZ3JhcGhNb2RlbEJvdW5kcy5taW5ZO1xyXG4gICAgICBjb25zdCBncmFwaE1heFkgPSBncmFwaC5ncmFwaE1vZGVsQm91bmRzLm1heFk7XHJcblxyXG4gICAgICBjb25zdCBzaGFwZSA9IG5ldyBTaGFwZSgpO1xyXG5cclxuICAgICAgLy8gVmVydGljYWwgbGluZXNcclxuICAgICAgY29uc3QgZmlyc3RYID0gZ3JhcGhNaW5YIC0gKCBncmFwaE1pblggJSBvcHRpb25zLnNwYWNpbmcgKTtcclxuICAgICAgZm9yICggbGV0IHhWYWx1ZSA9IGZpcnN0WDsgeFZhbHVlIDw9IGdyYXBoTWF4WDsgeFZhbHVlICs9IG9wdGlvbnMuc3BhY2luZyApIHtcclxuICAgICAgICBzaGFwZS5tb3ZlVG8oIHhWYWx1ZSwgZ3JhcGhNaW5ZICkudmVydGljYWxMaW5lVG8oIGdyYXBoTWF4WSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBIb3Jpem9udGFsIGxpbmVzXHJcbiAgICAgIGNvbnN0IGZpcnN0WSA9IGdyYXBoTWluWSAtICggZ3JhcGhNaW5ZICUgb3B0aW9ucy5zcGFjaW5nICk7XHJcbiAgICAgIGZvciAoIGxldCB5VmFsdWUgPSBmaXJzdFk7IHlWYWx1ZSA8PSBncmFwaE1heFk7IHlWYWx1ZSArPSBvcHRpb25zLnNwYWNpbmcgKSB7XHJcbiAgICAgICAgc2hhcGUubW92ZVRvKCBncmFwaE1pblgsIHlWYWx1ZSApLmhvcml6b250YWxMaW5lVG8oIGdyYXBoTWF4WCApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnNldFNoYXBlKCBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdTaGFwZSggc2hhcGUgKSApO1xyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBzaW5jZSB0aGUgZ3JpZCdzIHZpZXcgYm91bmRzIGFyZSBjb25zdGFudC5cclxuICAgKiBAcHVibGljXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQHJldHVybnMge0JvdW5kczJ9XHJcbiAgICovXHJcbiAgY29tcHV0ZVNoYXBlQm91bmRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ3JhcGhWaWV3Qm91bmRzO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERyYXdzIHRoZSB4IGF4aXMuXHJcbiAqL1xyXG5jbGFzcyBYQXhpc05vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtHcmFwaH0gZ3JhcGhcclxuICAgKiBAcGFyYW0ge0JvdW5kczJ9IGdyYXBoVmlld0JvdW5kc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBncmFwaCwgZ3JhcGhWaWV3Qm91bmRzICkge1xyXG5cclxuICAgIGNvbnN0IGFycm93Tm9kZSA9IG5ldyBBcnJvd05vZGUoXHJcbiAgICAgIGdyYXBoVmlld0JvdW5kcy5taW5YIC0gQVhFU19BUlJPV19YX0VYVEVOU0lPTiwgMCxcclxuICAgICAgZ3JhcGhWaWV3Qm91bmRzLm1heFggKyBBWEVTX0FSUk9XX1hfRVhURU5TSU9OLCAwLFxyXG4gICAgICBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5BWEVTX0FSUk9XX09QVElPTlNcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgYXhpc0xhYmVsID0gbmV3IFRleHQoIFZlY3RvckFkZGl0aW9uU3RyaW5ncy5zeW1ib2wueCwge1xyXG4gICAgICBmb250OiBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5BWElTX0xBQkVMX0ZPTlQsXHJcbiAgICAgIG1heFdpZHRoOiAyMixcclxuICAgICAgbGVmdDogYXJyb3dOb2RlLnJpZ2h0ICsgNixcclxuICAgICAgY2VudGVyWTogYXJyb3dOb2RlLmNlbnRlcllcclxuICAgIH0gKTtcclxuXHJcbiAgICBzdXBlcigge1xyXG4gICAgICBjaGlsZHJlbjogWyBhcnJvd05vZGUsIGF4aXNMYWJlbCBdLFxyXG4gICAgICBwaWNrYWJsZTogZmFsc2VcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBXaGVuIHRoZSBvcmlnaW4gbW92ZXMsIGFkanVzdCB0aGUgcG9zaXRpb24gb2YgdGhlIGF4aXMuXHJcbiAgICAvLyB1bmxpbmsgaXMgdW5uZWNlc3NhcnksIGV4aXN0cyBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW0uXHJcbiAgICBncmFwaC5tb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eS5saW5rKCBtb2RlbFZpZXdUcmFuc2Zvcm0gPT4ge1xyXG4gICAgICB0aGlzLnkgPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdZKCAwICk7XHJcbiAgICB9ICk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRHJhd3MgdGhlIHRpY2sgbWFya3MgYW5kIGxhYmVscy5cclxuICovXHJcbmNsYXNzIFRpY2tzTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0dyYXBofSBncmFwaFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBncmFwaCApIHtcclxuXHJcbiAgICBjb25zdCB0aWNrTWFya3NQYXRoID0gbmV3IFBhdGgoIG5ldyBTaGFwZSgpLCBUSUNLX01BUktfT1BUSU9OUyApO1xyXG4gICAgY29uc3QgdGlja0xhYmVsc1BhcmVudCA9IG5ldyBOb2RlKCk7XHJcbiAgICBjb25zdCBvcmlnaW5MYWJlbCA9IG5ldyBUZXh0KCAnMCcsIFRJQ0tfTEFCRUxfT1BUSU9OUyApO1xyXG5cclxuICAgIHN1cGVyKCB7XHJcbiAgICAgIGNoaWxkcmVuOiBbIHRpY2tNYXJrc1BhdGgsIHRpY2tMYWJlbHNQYXJlbnQgXSxcclxuICAgICAgcGlja2FibGU6IGZhbHNlXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRpY2tzIHdoZW4gdGhlIGdyYXBoJ3Mgb3JpZ2luIG1vdmVzLlxyXG4gICAgLy8gdW5saW5rIGlzIHVubmVjZXNzYXJ5LCBleGlzdHMgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgc2ltLlxyXG4gICAgZ3JhcGgubW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkubGluayggbW9kZWxWaWV3VHJhbnNmb3JtID0+IHtcclxuXHJcbiAgICAgIGNvbnN0IHZpZXdPcmlnaW4gPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdQb3NpdGlvbiggVmVjdG9yMi5aRVJPICk7XHJcbiAgICAgIGNvbnN0IHRpY2tNYXJrc1NoYXBlID0gbmV3IFNoYXBlKCk7XHJcbiAgICAgIGNvbnN0IHRpY2tMYWJlbHMgPSBbXTtcclxuXHJcbiAgICAgIGlmICggZ3JhcGgub3JpZW50YXRpb24gIT09IEdyYXBoT3JpZW50YXRpb25zLlZFUlRJQ0FMICkge1xyXG5cclxuICAgICAgICAvLyB4IHRpY2sgbWFya3NcclxuICAgICAgICBjb25zdCBmaXJzdFhUaWNrID0gZ3JhcGguZ3JhcGhNb2RlbEJvdW5kcy5taW5YIC0gKCBncmFwaC5ncmFwaE1vZGVsQm91bmRzLm1pblggJSBNQUpPUl9USUNLX1NQQUNJTkcgKTtcclxuICAgICAgICBmb3IgKCBsZXQgeFZhbHVlID0gZmlyc3RYVGljazsgeFZhbHVlIDw9IGdyYXBoLmdyYXBoTW9kZWxCb3VuZHMubWF4WDsgeFZhbHVlID0geFZhbHVlICsgTUFKT1JfVElDS19TUEFDSU5HICkge1xyXG4gICAgICAgICAgY29uc3QgdGlja0xlbmd0aCA9ICggeFZhbHVlID09PSAwICkgPyBPUklHSU5fVElDS19MRU5HVEggOiBUSUNLX0xFTkdUSDsgLy8gb3JpZ2luIHRpY2sgaXMgZGlmZmVyZW50XHJcbiAgICAgICAgICB0aWNrTWFya3NTaGFwZS5tb3ZlVG8oIHhWYWx1ZSwgLXRpY2tMZW5ndGggLyAyICkudmVydGljYWxMaW5lVG8oIHRpY2tMZW5ndGggLyAyICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4IHRpY2sgbGFiZWxzXHJcbiAgICAgICAgY29uc3QgZmlyc3RYTGFiZWwgPSBncmFwaC5ncmFwaE1vZGVsQm91bmRzLm1pblggLSAoIGdyYXBoLmdyYXBoTW9kZWxCb3VuZHMubWluWCAlIFRJQ0tfTEFCRUxfU1BBQ0lORyApO1xyXG4gICAgICAgIGZvciAoIGxldCB4VmFsdWUgPSBmaXJzdFhMYWJlbDsgeFZhbHVlIDw9IGdyYXBoLmdyYXBoTW9kZWxCb3VuZHMubWF4WDsgeFZhbHVlID0geFZhbHVlICsgVElDS19MQUJFTF9TUEFDSU5HICkge1xyXG4gICAgICAgICAgaWYgKCB4VmFsdWUgIT09IDAgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpY2tMYWJlbCA9IG5ldyBUZXh0KCB4VmFsdWUsIFRJQ0tfTEFCRUxfT1BUSU9OUyApO1xyXG4gICAgICAgICAgICB0aWNrTGFiZWwuY2VudGVyWCA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1goIHhWYWx1ZSApO1xyXG4gICAgICAgICAgICB0aWNrTGFiZWwudG9wID0gdmlld09yaWdpbi55ICsgVElDS19MQUJFTF9ZX09GRlNFVDtcclxuICAgICAgICAgICAgdGlja0xhYmVscy5wdXNoKCB0aWNrTGFiZWwgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICggZ3JhcGgub3JpZW50YXRpb24gIT09IEdyYXBoT3JpZW50YXRpb25zLkhPUklaT05UQUwgKSB7XHJcblxyXG4gICAgICAgIC8vIHkgdGljayBtYXJrc1xyXG4gICAgICAgIGNvbnN0IGZpcnN0WVRpY2sgPSBncmFwaC5ncmFwaE1vZGVsQm91bmRzLm1pblkgLSAoIGdyYXBoLmdyYXBoTW9kZWxCb3VuZHMubWluWSAlIE1BSk9SX1RJQ0tfU1BBQ0lORyApO1xyXG4gICAgICAgIGZvciAoIGxldCB5VmFsdWUgPSBmaXJzdFlUaWNrOyB5VmFsdWUgPD0gZ3JhcGguZ3JhcGhNb2RlbEJvdW5kcy5tYXhZOyB5VmFsdWUgPSB5VmFsdWUgKyBNQUpPUl9USUNLX1NQQUNJTkcgKSB7XHJcbiAgICAgICAgICBjb25zdCB0aWNrTGVuZ3RoID0gKCB5VmFsdWUgPT09IDAgKSA/IE9SSUdJTl9USUNLX0xFTkdUSCA6IFRJQ0tfTEVOR1RIOyAvLyBvcmlnaW4gdGljayBpcyBkaWZmZXJlbnRcclxuICAgICAgICAgIHRpY2tNYXJrc1NoYXBlLm1vdmVUbyggLXRpY2tMZW5ndGggLyAyLCB5VmFsdWUgKS5ob3Jpem9udGFsTGluZVRvKCB0aWNrTGVuZ3RoIC8gMiApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geSB0aWNrIGxhYmVsc1xyXG4gICAgICAgIGNvbnN0IGZpcnN0WUxhYmVsID0gZ3JhcGguZ3JhcGhNb2RlbEJvdW5kcy5taW5ZIC0gKCBncmFwaC5ncmFwaE1vZGVsQm91bmRzLm1pblkgJSBUSUNLX0xBQkVMX1NQQUNJTkcgKTtcclxuICAgICAgICBmb3IgKCBsZXQgeVZhbHVlID0gZmlyc3RZTGFiZWw7IHlWYWx1ZSA8PSBncmFwaC5ncmFwaE1vZGVsQm91bmRzLm1heFk7IHlWYWx1ZSA9IHlWYWx1ZSArIFRJQ0tfTEFCRUxfU1BBQ0lORyApIHtcclxuICAgICAgICAgIGlmICggeVZhbHVlICE9PSAwICkge1xyXG4gICAgICAgICAgICBjb25zdCB0aWNrTGFiZWwgPSBuZXcgVGV4dCggeVZhbHVlLCBUSUNLX0xBQkVMX09QVElPTlMgKTtcclxuICAgICAgICAgICAgdGlja0xhYmVsLnJpZ2h0ID0gdmlld09yaWdpbi54IC0gVElDS19MQUJFTF9YX09GRlNFVDtcclxuICAgICAgICAgICAgdGlja0xhYmVsLmNlbnRlclkgPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdZKCB5VmFsdWUgKTtcclxuICAgICAgICAgICAgdGlja0xhYmVscy5wdXNoKCB0aWNrTGFiZWwgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9yaWdpbiB0aWNrIGxhYmVsXHJcbiAgICAgIGlmICggZ3JhcGgub3JpZW50YXRpb24gIT09IEdyYXBoT3JpZW50YXRpb25zLlRXT19ESU1FTlNJT05BTCApIHtcclxuXHJcbiAgICAgICAgdGlja0xhYmVscy5wdXNoKCBvcmlnaW5MYWJlbCApO1xyXG5cclxuICAgICAgICBpZiAoIGdyYXBoLm9yaWVudGF0aW9uID09PSBHcmFwaE9yaWVudGF0aW9ucy5IT1JJWk9OVEFMICkge1xyXG4gICAgICAgICAgb3JpZ2luTGFiZWwuY2VudGVyWCA9IHZpZXdPcmlnaW4ueDtcclxuICAgICAgICAgIG9yaWdpbkxhYmVsLnRvcCA9IHZpZXdPcmlnaW4ueSArIFRJQ0tfTEFCRUxfWV9PRkZTRVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgb3JpZ2luTGFiZWwucmlnaHQgPSB2aWV3T3JpZ2luLnggLSBUSUNLX0xBQkVMX1hfT0ZGU0VUO1xyXG4gICAgICAgICAgb3JpZ2luTGFiZWwuY2VudGVyWSA9IHZpZXdPcmlnaW4ueTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRpY2tNYXJrc1BhdGguc2hhcGUgPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdTaGFwZSggdGlja01hcmtzU2hhcGUgKTtcclxuICAgICAgdGlja0xhYmVsc1BhcmVudC5jaGlsZHJlbiA9IHRpY2tMYWJlbHM7XHJcbiAgICB9ICk7XHJcbiAgfVxyXG59XHJcblxyXG52ZWN0b3JBZGRpdGlvbi5yZWdpc3RlciggJ0dyYXBoTm9kZScsIEdyYXBoTm9kZSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7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