// Copyright 2019-2023, University of Colorado Boulder

/**
 * Base class for vector views for all types of vectors (sum, component, etc.).
 * Primarily responsibilities are:
 *  - Create an ArrowNode or DashedArrowNode that displays a vector's tail/tip position
 *  - Create other Nodes that ALL vectors in the sim have (i.e. labels etc.)
 *
 * For an overview of the class hierarchy,
 * see https://github.com/phetsims/vector-addition/blob/master/doc/implementation-notes.md
 *
 * @author Brandon Li
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import Multilink from '../../../../axon/js/Multilink.js';
import Property from '../../../../axon/js/Property.js';
import ReadOnlyProperty from '../../../../axon/js/ReadOnlyProperty.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import merge from '../../../../phet-core/js/merge.js';
import ModelViewTransform2 from '../../../../phetcommon/js/view/ModelViewTransform2.js';
import ArrowNode from '../../../../scenery-phet/js/ArrowNode.js';
import { Node } from '../../../../scenery/js/imports.js';
import vectorAddition from '../../vectorAddition.js';
import RootVector from '../model/RootVector.js';
import VectorAdditionConstants from '../VectorAdditionConstants.js';
import DashedArrowNode from './DashedArrowNode.js';
import VectorLabelNode from './VectorLabelNode.js';

// constants

// Used to prevent vector label from going off-screen. This is the magnitude of a vector that fills the
// graph along a diagonal, minus the margin that constrains dragging of the vector's tail.
// See https://github.com/phetsims/vector-addition/issues/212#issuecomment-537628386 for a screenshot.
const MAX_LABEL_VECTOR_MAGNITUDE = new Vector2(VectorAdditionConstants.DEFAULT_GRAPH_BOUNDS.width - VectorAdditionConstants.VECTOR_TAIL_DRAG_MARGIN, VectorAdditionConstants.DEFAULT_GRAPH_BOUNDS.height - VectorAdditionConstants.VECTOR_TAIL_DRAG_MARGIN).magnitude;
export default class RootVectorNode extends Node {
  /**
   * @param {RootVector} rootVector - the vector model
   * @param {ReadOnlyProperty.<ModelViewTransform2>} modelViewTransformProperty
   * @param {BooleanProperty} valuesVisibleProperty
   * @param {Property.<RootVector>|null} activeVectorProperty
   * @param {Object} [options]
   */
  constructor(rootVector, modelViewTransformProperty, valuesVisibleProperty, activeVectorProperty, options) {
    assert && assert(rootVector instanceof RootVector, `invalid rootVector: ${rootVector}`);
    assert && assert(modelViewTransformProperty instanceof ReadOnlyProperty && modelViewTransformProperty.value instanceof ModelViewTransform2, `invalid modelViewTransformProperty: ${modelViewTransformProperty}`);
    assert && assert(valuesVisibleProperty instanceof BooleanProperty, `invalid valuesVisibleProperty: ${valuesVisibleProperty}`);
    assert && assert(activeVectorProperty instanceof Property && activeVectorProperty.value instanceof RootVector || activeVectorProperty.value === null, `invalid activeVectorProperty: ${activeVectorProperty}`);
    assert && assert(!options || Object.getPrototypeOf(options) === Object.prototype, `Extra prototype on options: ${options}`);
    options = merge({
      arrowType: 'solid',
      // options passed to ArrowNode or DashedArrowNode
      arrowOptions: {
        cursor: 'move'
      }
    }, options);

    //----------------------------------------------------------------------------------------

    super(options);

    // Define a vector node in which the tail position (view coordinates) is (0, 0). Get the tip position in view
    // coordinates
    const tipDeltaPosition = modelViewTransformProperty.value.modelToViewDelta(rootVector.vectorComponents);

    // @protected {ArrowNode} arrowNode - Create an arrow node that represents an actual vector.
    if (options.arrowType === 'solid') {
      this.arrowNode = new ArrowNode(0, 0, tipDeltaPosition.x, tipDeltaPosition.y, options.arrowOptions);
    } else {
      this.arrowNode = new DashedArrowNode(0, 0, tipDeltaPosition.x, tipDeltaPosition.y, options.arrowOptions);
    }

    // @protected {VectorLabelNode} labelNode - Create a label for the vector that is displayed 'next' to the arrow.
    // The position of this depends on the angle of the vector. Since the positioning of 'next' is different for every
    // vector, use an overridable method to position it. ( updateLabelPositioning() )
    // dispose is required because this observes the Properties that are passed to it.
    this.labelNode = new VectorLabelNode(rootVector, valuesVisibleProperty, activeVectorProperty, {
      cursor: 'move'
    });

    // Add children to this node
    this.setChildren([this.arrowNode, this.labelNode]);

    //----------------------------------------------------------------------------------------
    // Update the tail/tip position when the vector's tail/tip position changes

    // Observe changes to the tail/tip and mirror the positioning. If the values visibility changes, update the
    // view as well.  unmultilink is required on dispose.
    const updateMultilink = Multilink.multilink([valuesVisibleProperty, rootVector.tailPositionProperty, rootVector.tipPositionProperty, activeVectorProperty], valuesVisible => {
      // Update the appearance of the vector
      this.updateVector(rootVector, modelViewTransformProperty.value);

      // Update the appearance of the label
      this.updateLabelPositioning(rootVector, modelViewTransformProperty.value, valuesVisible);
    });

    // @private
    this.disposeRootVectorNode = () => {
      this.labelNode.dispose();
      Multilink.unmultilink(updateMultilink);
    };
  }

  /**
   * @public
   * @override
   */
  dispose() {
    this.disposeRootVectorNode();
    super.dispose();
  }

  /**
   * Updates the tail and tip position of the view. Called when the model changes tail/tip.
   * @param {RootVector} rootVector
   * @param {ModelViewTransform2} modelViewTransform
   * @protected
   */
  updateVector(rootVector, modelViewTransform) {
    // Since the tail is defined at (0, 0) for the vector, the vector must be translated.
    this.translation = modelViewTransform.modelToViewPosition(rootVector.tail);

    // Get the tip position in view coordinates
    const tipDeltaPosition = modelViewTransform.modelToViewDelta(rootVector.vectorComponents);
    this.arrowNode.setTip(tipDeltaPosition.x, tipDeltaPosition.y);

    // Make the arrow easier to grab by setting pointer areas
    if (rootVector.magnitude > VectorAdditionConstants.ZERO_THRESHOLD && this.arrowNode.shape) {
      this.arrowNode.mouseArea = this.arrowNode.shape.getOffsetShape(VectorAdditionConstants.VECTOR_MOUSE_AREA_DILATION);
      this.arrowNode.touchArea = this.arrowNode.shape.getOffsetShape(VectorAdditionConstants.VECTOR_TOUCH_AREA_DILATION);
    }

    // See https://github.com/phetsims/vector-addition/issues/252
    this.arrowNode.visible = rootVector.magnitude > VectorAdditionConstants.ZERO_THRESHOLD;
  }

  /**
   * Updates the label positioning, called when the vector is changing or the value checkbox is clicked.
   * This can be overridden if the positioning isn't appropriate (e.g. component nodes have different positioning)
   * @param {RootVector} rootVector
   * @param {ModelViewTransform2} modelViewTransform
   * @param {boolean} valuesVisible
   * @protected
   */
  updateLabelPositioning(rootVector, modelViewTransform, valuesVisible) {
    // Reset the rotation
    this.labelNode.setRotation(0);

    // If the magnitude is effectively 0, center the label on the vector's position.
    // See https://github.com/phetsims/vector-addition/issues/260
    if (rootVector.magnitude < VectorAdditionConstants.ZERO_THRESHOLD) {
      this.labelNode.center = modelViewTransform.modelToViewDelta(Vector2.ZERO);
      return;
    }

    // Angle of the vector in radians (ranging from -Pi to Pi)
    const modelAngle = rootVector.angle;

    //----------------------------------------------------------------------------------------
    // Determine how the labels should be positioned.

    // Add a flip if x is negative
    const xFlip = rootVector.xComponent < 0 ? Math.PI : 0;

    // Add a flip if y is negative
    const yFlip = rootVector.yComponent < 0 ? Math.PI : 0;

    //----------------------------------------------------------------------------------------
    // Add extra offset to consider the size of the label. The offset is the margin between the arrow and the label

    const labelSize = rootVector.yComponent >= 0 ? modelViewTransform.viewToModelDeltaX(this.labelNode.height / 2) : -modelViewTransform.viewToModelDeltaY(this.labelNode.height / 2);

    //----------------------------------------------------------------------------------------
    if (valuesVisible) {
      // Since the y-axis is inverted, the angle is the view is opposite to the model
      const viewAngle = -modelAngle;

      // Rotate label along the angle if x is positive, but flipped if x is negative
      this.labelNode.setRotation(viewAngle + xFlip);
    }

    // Create an offset that is perpendicular to the vector
    const offset = Vector2.createPolar(VectorAdditionConstants.VECTOR_LABEL_OFFSET + labelSize, modelAngle + Math.PI / 2 + yFlip);

    // Position the label
    this.labelNode.center = RootVectorNode.computeLabelCenter(rootVector, modelViewTransform, offset);
  }

  /**
   * Computes the center position for the label.
   * See https://github.com/phetsims/vector-addition/issues/212
   *
   * @param {RootVector} vector
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Vector2} offset - perpendicular offset
   * @returns {Vector2}
   * @public
   */
  static computeLabelCenter(vector, modelViewTransform, offset) {
    assert && assert(vector instanceof RootVector, 'invalid vector');
    assert && assert(modelViewTransform instanceof ModelViewTransform2, 'invalid modelViewTransform');
    assert && assert(offset instanceof Vector2, 'invalid offset');

    // Create a vector parallel to rootVector that determines where the label will be placed.
    let labelVector = null;
    if (vector.vectorComponents.magnitude < MAX_LABEL_VECTOR_MAGNITUDE) {
      labelVector = vector.vectorComponents;
    } else {
      labelVector = vector.vectorComponents.normalized().timesScalar(MAX_LABEL_VECTOR_MAGNITUDE);
    }
    return modelViewTransform.modelToViewDelta(labelVector.timesScalar(0.5).plus(offset));
  }
}
vectorAddition.register('RootVectorNode', RootVectorNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJNdWx0aWxpbmsiLCJQcm9wZXJ0eSIsIlJlYWRPbmx5UHJvcGVydHkiLCJWZWN0b3IyIiwibWVyZ2UiLCJNb2RlbFZpZXdUcmFuc2Zvcm0yIiwiQXJyb3dOb2RlIiwiTm9kZSIsInZlY3RvckFkZGl0aW9uIiwiUm9vdFZlY3RvciIsIlZlY3RvckFkZGl0aW9uQ29uc3RhbnRzIiwiRGFzaGVkQXJyb3dOb2RlIiwiVmVjdG9yTGFiZWxOb2RlIiwiTUFYX0xBQkVMX1ZFQ1RPUl9NQUdOSVRVREUiLCJERUZBVUxUX0dSQVBIX0JPVU5EUyIsIndpZHRoIiwiVkVDVE9SX1RBSUxfRFJBR19NQVJHSU4iLCJoZWlnaHQiLCJtYWduaXR1ZGUiLCJSb290VmVjdG9yTm9kZSIsImNvbnN0cnVjdG9yIiwicm9vdFZlY3RvciIsIm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5IiwidmFsdWVzVmlzaWJsZVByb3BlcnR5IiwiYWN0aXZlVmVjdG9yUHJvcGVydHkiLCJvcHRpb25zIiwiYXNzZXJ0IiwidmFsdWUiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImFycm93VHlwZSIsImFycm93T3B0aW9ucyIsImN1cnNvciIsInRpcERlbHRhUG9zaXRpb24iLCJtb2RlbFRvVmlld0RlbHRhIiwidmVjdG9yQ29tcG9uZW50cyIsImFycm93Tm9kZSIsIngiLCJ5IiwibGFiZWxOb2RlIiwic2V0Q2hpbGRyZW4iLCJ1cGRhdGVNdWx0aWxpbmsiLCJtdWx0aWxpbmsiLCJ0YWlsUG9zaXRpb25Qcm9wZXJ0eSIsInRpcFBvc2l0aW9uUHJvcGVydHkiLCJ2YWx1ZXNWaXNpYmxlIiwidXBkYXRlVmVjdG9yIiwidXBkYXRlTGFiZWxQb3NpdGlvbmluZyIsImRpc3Bvc2VSb290VmVjdG9yTm9kZSIsImRpc3Bvc2UiLCJ1bm11bHRpbGluayIsIm1vZGVsVmlld1RyYW5zZm9ybSIsInRyYW5zbGF0aW9uIiwibW9kZWxUb1ZpZXdQb3NpdGlvbiIsInRhaWwiLCJzZXRUaXAiLCJaRVJPX1RIUkVTSE9MRCIsInNoYXBlIiwibW91c2VBcmVhIiwiZ2V0T2Zmc2V0U2hhcGUiLCJWRUNUT1JfTU9VU0VfQVJFQV9ESUxBVElPTiIsInRvdWNoQXJlYSIsIlZFQ1RPUl9UT1VDSF9BUkVBX0RJTEFUSU9OIiwidmlzaWJsZSIsInNldFJvdGF0aW9uIiwiY2VudGVyIiwiWkVSTyIsIm1vZGVsQW5nbGUiLCJhbmdsZSIsInhGbGlwIiwieENvbXBvbmVudCIsIk1hdGgiLCJQSSIsInlGbGlwIiwieUNvbXBvbmVudCIsImxhYmVsU2l6ZSIsInZpZXdUb01vZGVsRGVsdGFYIiwidmlld1RvTW9kZWxEZWx0YVkiLCJ2aWV3QW5nbGUiLCJvZmZzZXQiLCJjcmVhdGVQb2xhciIsIlZFQ1RPUl9MQUJFTF9PRkZTRVQiLCJjb21wdXRlTGFiZWxDZW50ZXIiLCJ2ZWN0b3IiLCJsYWJlbFZlY3RvciIsIm5vcm1hbGl6ZWQiLCJ0aW1lc1NjYWxhciIsInBsdXMiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlJvb3RWZWN0b3JOb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE5LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciB2aWV3cyBmb3IgYWxsIHR5cGVzIG9mIHZlY3RvcnMgKHN1bSwgY29tcG9uZW50LCBldGMuKS5cclxuICogUHJpbWFyaWx5IHJlc3BvbnNpYmlsaXRpZXMgYXJlOlxyXG4gKiAgLSBDcmVhdGUgYW4gQXJyb3dOb2RlIG9yIERhc2hlZEFycm93Tm9kZSB0aGF0IGRpc3BsYXlzIGEgdmVjdG9yJ3MgdGFpbC90aXAgcG9zaXRpb25cclxuICogIC0gQ3JlYXRlIG90aGVyIE5vZGVzIHRoYXQgQUxMIHZlY3RvcnMgaW4gdGhlIHNpbSBoYXZlIChpLmUuIGxhYmVscyBldGMuKVxyXG4gKlxyXG4gKiBGb3IgYW4gb3ZlcnZpZXcgb2YgdGhlIGNsYXNzIGhpZXJhcmNoeSxcclxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy92ZWN0b3ItYWRkaXRpb24vYmxvYi9tYXN0ZXIvZG9jL2ltcGxlbWVudGF0aW9uLW5vdGVzLm1kXHJcbiAqXHJcbiAqIEBhdXRob3IgQnJhbmRvbiBMaVxyXG4gKi9cclxuXHJcbmltcG9ydCBCb29sZWFuUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9Cb29sZWFuUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgTXVsdGlsaW5rIGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvTXVsdGlsaW5rLmpzJztcclxuaW1wb3J0IFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgUmVhZE9ubHlQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1JlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgTW9kZWxWaWV3VHJhbnNmb3JtMiBmcm9tICcuLi8uLi8uLi8uLi9waGV0Y29tbW9uL2pzL3ZpZXcvTW9kZWxWaWV3VHJhbnNmb3JtMi5qcyc7XHJcbmltcG9ydCBBcnJvd05vZGUgZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS1waGV0L2pzL0Fycm93Tm9kZS5qcyc7XHJcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgdmVjdG9yQWRkaXRpb24gZnJvbSAnLi4vLi4vdmVjdG9yQWRkaXRpb24uanMnO1xyXG5pbXBvcnQgUm9vdFZlY3RvciBmcm9tICcuLi9tb2RlbC9Sb290VmVjdG9yLmpzJztcclxuaW1wb3J0IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzIGZyb20gJy4uL1ZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IERhc2hlZEFycm93Tm9kZSBmcm9tICcuL0Rhc2hlZEFycm93Tm9kZS5qcyc7XHJcbmltcG9ydCBWZWN0b3JMYWJlbE5vZGUgZnJvbSAnLi9WZWN0b3JMYWJlbE5vZGUuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcblxyXG4vLyBVc2VkIHRvIHByZXZlbnQgdmVjdG9yIGxhYmVsIGZyb20gZ29pbmcgb2ZmLXNjcmVlbi4gVGhpcyBpcyB0aGUgbWFnbml0dWRlIG9mIGEgdmVjdG9yIHRoYXQgZmlsbHMgdGhlXHJcbi8vIGdyYXBoIGFsb25nIGEgZGlhZ29uYWwsIG1pbnVzIHRoZSBtYXJnaW4gdGhhdCBjb25zdHJhaW5zIGRyYWdnaW5nIG9mIHRoZSB2ZWN0b3IncyB0YWlsLlxyXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3ZlY3Rvci1hZGRpdGlvbi9pc3N1ZXMvMjEyI2lzc3VlY29tbWVudC01Mzc2MjgzODYgZm9yIGEgc2NyZWVuc2hvdC5cclxuY29uc3QgTUFYX0xBQkVMX1ZFQ1RPUl9NQUdOSVRVREUgPSBuZXcgVmVjdG9yMihcclxuICBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5ERUZBVUxUX0dSQVBIX0JPVU5EUy53aWR0aCAtIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlZFQ1RPUl9UQUlMX0RSQUdfTUFSR0lOLFxyXG4gIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLkRFRkFVTFRfR1JBUEhfQk9VTkRTLmhlaWdodCAtIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlZFQ1RPUl9UQUlMX0RSQUdfTUFSR0lOXHJcbikubWFnbml0dWRlO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm9vdFZlY3Rvck5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtSb290VmVjdG9yfSByb290VmVjdG9yIC0gdGhlIHZlY3RvciBtb2RlbFxyXG4gICAqIEBwYXJhbSB7UmVhZE9ubHlQcm9wZXJ0eS48TW9kZWxWaWV3VHJhbnNmb3JtMj59IG1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5XHJcbiAgICogQHBhcmFtIHtCb29sZWFuUHJvcGVydHl9IHZhbHVlc1Zpc2libGVQcm9wZXJ0eVxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHkuPFJvb3RWZWN0b3I+fG51bGx9IGFjdGl2ZVZlY3RvclByb3BlcnR5XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCByb290VmVjdG9yLCBtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eSwgdmFsdWVzVmlzaWJsZVByb3BlcnR5LCBhY3RpdmVWZWN0b3JQcm9wZXJ0eSwgb3B0aW9ucyApIHtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCByb290VmVjdG9yIGluc3RhbmNlb2YgUm9vdFZlY3RvciwgYGludmFsaWQgcm9vdFZlY3RvcjogJHtyb290VmVjdG9yfWAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5IGluc3RhbmNlb2YgUmVhZE9ubHlQcm9wZXJ0eSAmJiBtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eS52YWx1ZSBpbnN0YW5jZW9mIE1vZGVsVmlld1RyYW5zZm9ybTIsXHJcbiAgICAgIGBpbnZhbGlkIG1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5OiAke21vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5fWAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHZhbHVlc1Zpc2libGVQcm9wZXJ0eSBpbnN0YW5jZW9mIEJvb2xlYW5Qcm9wZXJ0eSwgYGludmFsaWQgdmFsdWVzVmlzaWJsZVByb3BlcnR5OiAke3ZhbHVlc1Zpc2libGVQcm9wZXJ0eX1gICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBhY3RpdmVWZWN0b3JQcm9wZXJ0eSBpbnN0YW5jZW9mIFByb3BlcnR5ICYmIGFjdGl2ZVZlY3RvclByb3BlcnR5LnZhbHVlIGluc3RhbmNlb2YgUm9vdFZlY3RvciB8fCBhY3RpdmVWZWN0b3JQcm9wZXJ0eS52YWx1ZSA9PT0gbnVsbCxcclxuICAgICAgYGludmFsaWQgYWN0aXZlVmVjdG9yUHJvcGVydHk6ICR7YWN0aXZlVmVjdG9yUHJvcGVydHl9YCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggIW9wdGlvbnMgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKCBvcHRpb25zICkgPT09IE9iamVjdC5wcm90b3R5cGUsXHJcbiAgICAgIGBFeHRyYSBwcm90b3R5cGUgb24gb3B0aW9uczogJHtvcHRpb25zfWAgKTtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuXHJcbiAgICAgIGFycm93VHlwZTogJ3NvbGlkJyxcclxuXHJcbiAgICAgIC8vIG9wdGlvbnMgcGFzc2VkIHRvIEFycm93Tm9kZSBvciBEYXNoZWRBcnJvd05vZGVcclxuICAgICAgYXJyb3dPcHRpb25zOiB7XHJcbiAgICAgICAgY3Vyc29yOiAnbW92ZSdcclxuICAgICAgfVxyXG4gICAgfSwgb3B0aW9ucyApO1xyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gRGVmaW5lIGEgdmVjdG9yIG5vZGUgaW4gd2hpY2ggdGhlIHRhaWwgcG9zaXRpb24gKHZpZXcgY29vcmRpbmF0ZXMpIGlzICgwLCAwKS4gR2V0IHRoZSB0aXAgcG9zaXRpb24gaW4gdmlld1xyXG4gICAgLy8gY29vcmRpbmF0ZXNcclxuICAgIGNvbnN0IHRpcERlbHRhUG9zaXRpb24gPSBtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eS52YWx1ZS5tb2RlbFRvVmlld0RlbHRhKCByb290VmVjdG9yLnZlY3RvckNvbXBvbmVudHMgKTtcclxuXHJcbiAgICAvLyBAcHJvdGVjdGVkIHtBcnJvd05vZGV9IGFycm93Tm9kZSAtIENyZWF0ZSBhbiBhcnJvdyBub2RlIHRoYXQgcmVwcmVzZW50cyBhbiBhY3R1YWwgdmVjdG9yLlxyXG4gICAgaWYgKCBvcHRpb25zLmFycm93VHlwZSA9PT0gJ3NvbGlkJyApIHtcclxuICAgICAgdGhpcy5hcnJvd05vZGUgPSBuZXcgQXJyb3dOb2RlKCAwLCAwLCB0aXBEZWx0YVBvc2l0aW9uLngsIHRpcERlbHRhUG9zaXRpb24ueSwgb3B0aW9ucy5hcnJvd09wdGlvbnMgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICB0aGlzLmFycm93Tm9kZSA9IG5ldyBEYXNoZWRBcnJvd05vZGUoIDAsIDAsIHRpcERlbHRhUG9zaXRpb24ueCwgdGlwRGVsdGFQb3NpdGlvbi55LCBvcHRpb25zLmFycm93T3B0aW9ucyApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBwcm90ZWN0ZWQge1ZlY3RvckxhYmVsTm9kZX0gbGFiZWxOb2RlIC0gQ3JlYXRlIGEgbGFiZWwgZm9yIHRoZSB2ZWN0b3IgdGhhdCBpcyBkaXNwbGF5ZWQgJ25leHQnIHRvIHRoZSBhcnJvdy5cclxuICAgIC8vIFRoZSBwb3NpdGlvbiBvZiB0aGlzIGRlcGVuZHMgb24gdGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3IuIFNpbmNlIHRoZSBwb3NpdGlvbmluZyBvZiAnbmV4dCcgaXMgZGlmZmVyZW50IGZvciBldmVyeVxyXG4gICAgLy8gdmVjdG9yLCB1c2UgYW4gb3ZlcnJpZGFibGUgbWV0aG9kIHRvIHBvc2l0aW9uIGl0LiAoIHVwZGF0ZUxhYmVsUG9zaXRpb25pbmcoKSApXHJcbiAgICAvLyBkaXNwb3NlIGlzIHJlcXVpcmVkIGJlY2F1c2UgdGhpcyBvYnNlcnZlcyB0aGUgUHJvcGVydGllcyB0aGF0IGFyZSBwYXNzZWQgdG8gaXQuXHJcbiAgICB0aGlzLmxhYmVsTm9kZSA9IG5ldyBWZWN0b3JMYWJlbE5vZGUoIHJvb3RWZWN0b3IsIHZhbHVlc1Zpc2libGVQcm9wZXJ0eSwgYWN0aXZlVmVjdG9yUHJvcGVydHksIHtcclxuICAgICAgY3Vyc29yOiAnbW92ZSdcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBBZGQgY2hpbGRyZW4gdG8gdGhpcyBub2RlXHJcbiAgICB0aGlzLnNldENoaWxkcmVuKCBbIHRoaXMuYXJyb3dOb2RlLCB0aGlzLmxhYmVsTm9kZSBdICk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBVcGRhdGUgdGhlIHRhaWwvdGlwIHBvc2l0aW9uIHdoZW4gdGhlIHZlY3RvcidzIHRhaWwvdGlwIHBvc2l0aW9uIGNoYW5nZXNcclxuXHJcbiAgICAvLyBPYnNlcnZlIGNoYW5nZXMgdG8gdGhlIHRhaWwvdGlwIGFuZCBtaXJyb3IgdGhlIHBvc2l0aW9uaW5nLiBJZiB0aGUgdmFsdWVzIHZpc2liaWxpdHkgY2hhbmdlcywgdXBkYXRlIHRoZVxyXG4gICAgLy8gdmlldyBhcyB3ZWxsLiAgdW5tdWx0aWxpbmsgaXMgcmVxdWlyZWQgb24gZGlzcG9zZS5cclxuICAgIGNvbnN0IHVwZGF0ZU11bHRpbGluayA9IE11bHRpbGluay5tdWx0aWxpbmsoXHJcbiAgICAgIFsgdmFsdWVzVmlzaWJsZVByb3BlcnR5LCByb290VmVjdG9yLnRhaWxQb3NpdGlvblByb3BlcnR5LCByb290VmVjdG9yLnRpcFBvc2l0aW9uUHJvcGVydHksIGFjdGl2ZVZlY3RvclByb3BlcnR5IF0sXHJcbiAgICAgIHZhbHVlc1Zpc2libGUgPT4ge1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHZlY3RvclxyXG4gICAgICAgIHRoaXMudXBkYXRlVmVjdG9yKCByb290VmVjdG9yLCBtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eS52YWx1ZSApO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxhYmVsXHJcbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbFBvc2l0aW9uaW5nKCByb290VmVjdG9yLCBtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eS52YWx1ZSwgdmFsdWVzVmlzaWJsZSApO1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgLy8gQHByaXZhdGVcclxuICAgIHRoaXMuZGlzcG9zZVJvb3RWZWN0b3JOb2RlID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLmxhYmVsTm9kZS5kaXNwb3NlKCk7XHJcbiAgICAgIE11bHRpbGluay51bm11bHRpbGluayggdXBkYXRlTXVsdGlsaW5rICk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLmRpc3Bvc2VSb290VmVjdG9yTm9kZSgpO1xyXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgdGFpbCBhbmQgdGlwIHBvc2l0aW9uIG9mIHRoZSB2aWV3LiBDYWxsZWQgd2hlbiB0aGUgbW9kZWwgY2hhbmdlcyB0YWlsL3RpcC5cclxuICAgKiBAcGFyYW0ge1Jvb3RWZWN0b3J9IHJvb3RWZWN0b3JcclxuICAgKiBAcGFyYW0ge01vZGVsVmlld1RyYW5zZm9ybTJ9IG1vZGVsVmlld1RyYW5zZm9ybVxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICB1cGRhdGVWZWN0b3IoIHJvb3RWZWN0b3IsIG1vZGVsVmlld1RyYW5zZm9ybSApIHtcclxuXHJcbiAgICAvLyBTaW5jZSB0aGUgdGFpbCBpcyBkZWZpbmVkIGF0ICgwLCAwKSBmb3IgdGhlIHZlY3RvciwgdGhlIHZlY3RvciBtdXN0IGJlIHRyYW5zbGF0ZWQuXHJcbiAgICB0aGlzLnRyYW5zbGF0aW9uID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3UG9zaXRpb24oIHJvb3RWZWN0b3IudGFpbCApO1xyXG5cclxuICAgIC8vIEdldCB0aGUgdGlwIHBvc2l0aW9uIGluIHZpZXcgY29vcmRpbmF0ZXNcclxuICAgIGNvbnN0IHRpcERlbHRhUG9zaXRpb24gPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdEZWx0YSggcm9vdFZlY3Rvci52ZWN0b3JDb21wb25lbnRzICk7XHJcbiAgICB0aGlzLmFycm93Tm9kZS5zZXRUaXAoIHRpcERlbHRhUG9zaXRpb24ueCwgdGlwRGVsdGFQb3NpdGlvbi55ICk7XHJcblxyXG4gICAgLy8gTWFrZSB0aGUgYXJyb3cgZWFzaWVyIHRvIGdyYWIgYnkgc2V0dGluZyBwb2ludGVyIGFyZWFzXHJcbiAgICBpZiAoIHJvb3RWZWN0b3IubWFnbml0dWRlID4gVmVjdG9yQWRkaXRpb25Db25zdGFudHMuWkVST19USFJFU0hPTEQgJiYgdGhpcy5hcnJvd05vZGUuc2hhcGUgKSB7XHJcbiAgICAgIHRoaXMuYXJyb3dOb2RlLm1vdXNlQXJlYSA9IHRoaXMuYXJyb3dOb2RlLnNoYXBlLmdldE9mZnNldFNoYXBlKCBWZWN0b3JBZGRpdGlvbkNvbnN0YW50cy5WRUNUT1JfTU9VU0VfQVJFQV9ESUxBVElPTiApO1xyXG4gICAgICB0aGlzLmFycm93Tm9kZS50b3VjaEFyZWEgPSB0aGlzLmFycm93Tm9kZS5zaGFwZS5nZXRPZmZzZXRTaGFwZSggVmVjdG9yQWRkaXRpb25Db25zdGFudHMuVkVDVE9SX1RPVUNIX0FSRUFfRElMQVRJT04gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3ZlY3Rvci1hZGRpdGlvbi9pc3N1ZXMvMjUyXHJcbiAgICB0aGlzLmFycm93Tm9kZS52aXNpYmxlID0gKCByb290VmVjdG9yLm1hZ25pdHVkZSA+IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlpFUk9fVEhSRVNIT0xEICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBsYWJlbCBwb3NpdGlvbmluZywgY2FsbGVkIHdoZW4gdGhlIHZlY3RvciBpcyBjaGFuZ2luZyBvciB0aGUgdmFsdWUgY2hlY2tib3ggaXMgY2xpY2tlZC5cclxuICAgKiBUaGlzIGNhbiBiZSBvdmVycmlkZGVuIGlmIHRoZSBwb3NpdGlvbmluZyBpc24ndCBhcHByb3ByaWF0ZSAoZS5nLiBjb21wb25lbnQgbm9kZXMgaGF2ZSBkaWZmZXJlbnQgcG9zaXRpb25pbmcpXHJcbiAgICogQHBhcmFtIHtSb290VmVjdG9yfSByb290VmVjdG9yXHJcbiAgICogQHBhcmFtIHtNb2RlbFZpZXdUcmFuc2Zvcm0yfSBtb2RlbFZpZXdUcmFuc2Zvcm1cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlc1Zpc2libGVcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXHJcbiAgdXBkYXRlTGFiZWxQb3NpdGlvbmluZyggcm9vdFZlY3RvciwgbW9kZWxWaWV3VHJhbnNmb3JtLCB2YWx1ZXNWaXNpYmxlICkge1xyXG5cclxuICAgIC8vIFJlc2V0IHRoZSByb3RhdGlvblxyXG4gICAgdGhpcy5sYWJlbE5vZGUuc2V0Um90YXRpb24oIDAgKTtcclxuXHJcbiAgICAvLyBJZiB0aGUgbWFnbml0dWRlIGlzIGVmZmVjdGl2ZWx5IDAsIGNlbnRlciB0aGUgbGFiZWwgb24gdGhlIHZlY3RvcidzIHBvc2l0aW9uLlxyXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy92ZWN0b3ItYWRkaXRpb24vaXNzdWVzLzI2MFxyXG4gICAgaWYgKCByb290VmVjdG9yLm1hZ25pdHVkZSA8IFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlpFUk9fVEhSRVNIT0xEICkge1xyXG4gICAgICB0aGlzLmxhYmVsTm9kZS5jZW50ZXIgPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdEZWx0YSggVmVjdG9yMi5aRVJPICk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbmdsZSBvZiB0aGUgdmVjdG9yIGluIHJhZGlhbnMgKHJhbmdpbmcgZnJvbSAtUGkgdG8gUGkpXHJcbiAgICBjb25zdCBtb2RlbEFuZ2xlID0gcm9vdFZlY3Rvci5hbmdsZTtcclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIERldGVybWluZSBob3cgdGhlIGxhYmVscyBzaG91bGQgYmUgcG9zaXRpb25lZC5cclxuXHJcbiAgICAvLyBBZGQgYSBmbGlwIGlmIHggaXMgbmVnYXRpdmVcclxuICAgIGNvbnN0IHhGbGlwID0gKCByb290VmVjdG9yLnhDb21wb25lbnQgPCAwICkgPyBNYXRoLlBJIDogMDtcclxuXHJcbiAgICAvLyBBZGQgYSBmbGlwIGlmIHkgaXMgbmVnYXRpdmVcclxuICAgIGNvbnN0IHlGbGlwID0gKCByb290VmVjdG9yLnlDb21wb25lbnQgPCAwICkgPyBNYXRoLlBJIDogMDtcclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIEFkZCBleHRyYSBvZmZzZXQgdG8gY29uc2lkZXIgdGhlIHNpemUgb2YgdGhlIGxhYmVsLiBUaGUgb2Zmc2V0IGlzIHRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgYXJyb3cgYW5kIHRoZSBsYWJlbFxyXG5cclxuICAgIGNvbnN0IGxhYmVsU2l6ZSA9ICggcm9vdFZlY3Rvci55Q29tcG9uZW50ID49IDAgKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICBtb2RlbFZpZXdUcmFuc2Zvcm0udmlld1RvTW9kZWxEZWx0YVgoIHRoaXMubGFiZWxOb2RlLmhlaWdodCAvIDIgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAtbW9kZWxWaWV3VHJhbnNmb3JtLnZpZXdUb01vZGVsRGVsdGFZKCB0aGlzLmxhYmVsTm9kZS5oZWlnaHQgLyAyICk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBpZiAoIHZhbHVlc1Zpc2libGUgKSB7XHJcblxyXG4gICAgICAvLyBTaW5jZSB0aGUgeS1heGlzIGlzIGludmVydGVkLCB0aGUgYW5nbGUgaXMgdGhlIHZpZXcgaXMgb3Bwb3NpdGUgdG8gdGhlIG1vZGVsXHJcbiAgICAgIGNvbnN0IHZpZXdBbmdsZSA9IC1tb2RlbEFuZ2xlO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGxhYmVsIGFsb25nIHRoZSBhbmdsZSBpZiB4IGlzIHBvc2l0aXZlLCBidXQgZmxpcHBlZCBpZiB4IGlzIG5lZ2F0aXZlXHJcbiAgICAgIHRoaXMubGFiZWxOb2RlLnNldFJvdGF0aW9uKCB2aWV3QW5nbGUgKyB4RmxpcCApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhbiBvZmZzZXQgdGhhdCBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSB2ZWN0b3JcclxuICAgIGNvbnN0IG9mZnNldCA9IFZlY3RvcjIuY3JlYXRlUG9sYXIoIFZlY3RvckFkZGl0aW9uQ29uc3RhbnRzLlZFQ1RPUl9MQUJFTF9PRkZTRVQgKyBsYWJlbFNpemUsIG1vZGVsQW5nbGUgKyBNYXRoLlBJIC8gMiArIHlGbGlwICk7XHJcblxyXG4gICAgLy8gUG9zaXRpb24gdGhlIGxhYmVsXHJcbiAgICB0aGlzLmxhYmVsTm9kZS5jZW50ZXIgPSBSb290VmVjdG9yTm9kZS5jb21wdXRlTGFiZWxDZW50ZXIoIHJvb3RWZWN0b3IsIG1vZGVsVmlld1RyYW5zZm9ybSwgb2Zmc2V0ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlcyB0aGUgY2VudGVyIHBvc2l0aW9uIGZvciB0aGUgbGFiZWwuXHJcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy92ZWN0b3ItYWRkaXRpb24vaXNzdWVzLzIxMlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSb290VmVjdG9yfSB2ZWN0b3JcclxuICAgKiBAcGFyYW0ge01vZGVsVmlld1RyYW5zZm9ybTJ9IG1vZGVsVmlld1RyYW5zZm9ybVxyXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gb2Zmc2V0IC0gcGVycGVuZGljdWxhciBvZmZzZXRcclxuICAgKiBAcmV0dXJucyB7VmVjdG9yMn1cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgc3RhdGljIGNvbXB1dGVMYWJlbENlbnRlciggdmVjdG9yLCBtb2RlbFZpZXdUcmFuc2Zvcm0sIG9mZnNldCApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHZlY3RvciBpbnN0YW5jZW9mIFJvb3RWZWN0b3IsICdpbnZhbGlkIHZlY3RvcicgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG1vZGVsVmlld1RyYW5zZm9ybSBpbnN0YW5jZW9mIE1vZGVsVmlld1RyYW5zZm9ybTIsICdpbnZhbGlkIG1vZGVsVmlld1RyYW5zZm9ybScgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIG9mZnNldCBpbnN0YW5jZW9mIFZlY3RvcjIsICdpbnZhbGlkIG9mZnNldCcgKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSB2ZWN0b3IgcGFyYWxsZWwgdG8gcm9vdFZlY3RvciB0aGF0IGRldGVybWluZXMgd2hlcmUgdGhlIGxhYmVsIHdpbGwgYmUgcGxhY2VkLlxyXG4gICAgbGV0IGxhYmVsVmVjdG9yID0gbnVsbDtcclxuICAgIGlmICggdmVjdG9yLnZlY3RvckNvbXBvbmVudHMubWFnbml0dWRlIDwgTUFYX0xBQkVMX1ZFQ1RPUl9NQUdOSVRVREUgKSB7XHJcbiAgICAgIGxhYmVsVmVjdG9yID0gdmVjdG9yLnZlY3RvckNvbXBvbmVudHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgbGFiZWxWZWN0b3IgPSB2ZWN0b3IudmVjdG9yQ29tcG9uZW50cy5ub3JtYWxpemVkKCkudGltZXNTY2FsYXIoIE1BWF9MQUJFTF9WRUNUT1JfTUFHTklUVURFICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhKCBsYWJlbFZlY3Rvci50aW1lc1NjYWxhciggMC41ICkucGx1cyggb2Zmc2V0ICkgKTtcclxuICB9XHJcbn1cclxuXHJcbnZlY3RvckFkZGl0aW9uLnJlZ2lzdGVyKCAnUm9vdFZlY3Rvck5vZGUnLCBSb290VmVjdG9yTm9kZSApOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxlQUFlLE1BQU0sd0NBQXdDO0FBQ3BFLE9BQU9DLFNBQVMsTUFBTSxrQ0FBa0M7QUFDeEQsT0FBT0MsUUFBUSxNQUFNLGlDQUFpQztBQUN0RCxPQUFPQyxnQkFBZ0IsTUFBTSx5Q0FBeUM7QUFDdEUsT0FBT0MsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxPQUFPQyxLQUFLLE1BQU0sbUNBQW1DO0FBQ3JELE9BQU9DLG1CQUFtQixNQUFNLHVEQUF1RDtBQUN2RixPQUFPQyxTQUFTLE1BQU0sMENBQTBDO0FBQ2hFLFNBQVNDLElBQUksUUFBUSxtQ0FBbUM7QUFDeEQsT0FBT0MsY0FBYyxNQUFNLHlCQUF5QjtBQUNwRCxPQUFPQyxVQUFVLE1BQU0sd0JBQXdCO0FBQy9DLE9BQU9DLHVCQUF1QixNQUFNLCtCQUErQjtBQUNuRSxPQUFPQyxlQUFlLE1BQU0sc0JBQXNCO0FBQ2xELE9BQU9DLGVBQWUsTUFBTSxzQkFBc0I7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLDBCQUEwQixHQUFHLElBQUlWLE9BQU8sQ0FDNUNPLHVCQUF1QixDQUFDSSxvQkFBb0IsQ0FBQ0MsS0FBSyxHQUFHTCx1QkFBdUIsQ0FBQ00sdUJBQXVCLEVBQ3BHTix1QkFBdUIsQ0FBQ0ksb0JBQW9CLENBQUNHLE1BQU0sR0FBR1AsdUJBQXVCLENBQUNNLHVCQUNoRixD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