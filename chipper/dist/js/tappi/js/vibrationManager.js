// Copyright 2019-2022, University of Colorado Boulder

/**
 * A singleton that manages vibration feedback through the web vibration API. navigator.vibrate is required
 * to use this file. See https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate for more
 * information and a list of supported platforms. If not defined, this file will do nothing.
 *
 * Vibration can be started with vibrationManager.startVibrate() to begin continuous vibration. Stop with
 * vibrationManager.stopVibrate.
 *
 * Vibration patterns can also be defined similarly to navigator.vibrate(). vibrationManager.startVibrate()
 * can take an array of intervals that define the uptime/downtime of the vibration motor. See that function
 * for more information.
 *
 * Since the manager works with intervals of time, it must be stepped every animation frame with
 * vibrationManager.step().
 *
 * @author Jesse Greenberg
 */

import BooleanProperty from '../../axon/js/BooleanProperty.js';
import Multilink from '../../axon/js/Multilink.js';
import stepTimer from '../../axon/js/stepTimer.js';
import tappi from './tappi.js';
import EnumerationValue from '../../phet-core/js/EnumerationValue.js';
import Enumeration from '../../phet-core/js/Enumeration.js';
import EnumerationProperty from '../../axon/js/EnumerationProperty.js';
// constants
const LOW_INTENSITY_PATTERN = [8, 8];
const HIGH_INTENSITY_PATTERN = [Number.MAX_SAFE_INTEGER, 0];
const REPEATING_PATTERN_CYCLE_TIME = 5; // in seconds

// enum for intensity levels
export class Intensity extends EnumerationValue {
  static HIGH = new Intensity();
  static LOW = new Intensity();

  // Gets a list of keys, values and mapping between them.  For use in EnumerationProperty and PhET-iO
  static enumeration = new Enumeration(Intensity);
}
const NOOP_TIME_LISTENER = _.noop;

// by default, vibration will be continuous vibration without interruption
const DEFAULT_VIBRATION_PATTERN = [Number.MAX_SAFE_INTEGER];
class VibrationManager {
  enabledProperty = new BooleanProperty(true);

  // Indicates whether the motor should be vibrating. This accurately reflects whether the motor is running during
  // uptime/downtime during a vibration pattern.
  vibratingProperty = new BooleanProperty(false);

  // Indicates the current value of vibration intensity. Either HIGH or LOW, vibration can be one of these two (at this
  // time) while still providing continuous vibration.  The vibration motor is either on or off, and we mimic "low"
  // intensity vibration by turning the motor on and off rapidly.
  intensityProperty = new EnumerationProperty(Intensity.HIGH);

  // Whether a vibration pattern is running, may not indicate whether the device is actually vibrating as this could be
  // true during a vibration pattern downtime.
  _runningVibration = false;

  // Pattern of vibration and pause intervals, each value indicates number of milliseconds to vibrate or pause in
  // alternation. Unlike the Navigator API, single value is not allowed, and any pattern here will proceed until
  // stopVibrate is called.
  _vibrationPattern = DEFAULT_VIBRATION_PATTERN;

  // The duration of active intensity pattern, only used to produce one of intensity feedback during active vibration.
  _intensityDuration = 0;

  // Tracks how long we have been vibrating at the current interval of the specified vibrationPattern. Increments even
  // during downtime "off" interval in a pattern.
  _timeRunningCurrentInterval = 0;

  // Limitation for the active vibration, vibration pattern will run until this time runs out. Includes pattern
  // downtime. By default, vibration patterns will run forever.
  _patternTimeLimit = Number.POSITIVE_INFINITY;

  // How much time has passed since we started to vibrate with a particular pattern, will still increment during
  // vibration pattern downtime.
  _timeRunningCurrentPattern = 0;

  // index of the vibrationPattern that is currently 'active' in the sequence
  _currentIntervalIndex = 0;
  _vibrationIntensityPattern = HIGH_INTENSITY_PATTERN;

  // Reference to the callback added to timer that keeps the vibrating motor running until stopVibrate. This will
  // eventually call navigator.vibrate.
  _navigatorVibrationCallback = NOOP_TIME_LISTENER;
  expandedPatternInterval = NOOP_TIME_LISTENER;

  /**
   * Initialize the vibrationManager by setting initial state variables and attaching listeners.
   * NOTE: This should eventually be called in Sim.js (or other framework) only when vibration is required.
   */
  initialize(simVisibleProperty, simActiveProperty) {
    this.setVibrationIntensity(this.intensityProperty.get());

    // if either vibration or intensity changes we need to stop/start vibration or change timeouts for intensity
    Multilink.multilink([this.vibratingProperty, this.intensityProperty], (vibrating, intensity) => {
      this.controlNavigator();
    });

    // stop all vibration when the sim is invisible or inactive
    Multilink.multilink([this.enabledProperty, simVisibleProperty, simActiveProperty], (enabled, simVisible, simActive) => {
      if (enabled && simVisible && simActive) {
        this.stopVibrate();
      }
    });
  }

  /**
   * Initiate vibration with navigator.vibrate at the correct intervals for vibration intensity.
   */
  controlNavigator() {
    if (this._navigatorVibrationCallback) {
      stepTimer.clearInterval(this._navigatorVibrationCallback);
      this._navigatorVibrationCallback = NOOP_TIME_LISTENER;

      // stop any previous vibration
      navigator.vibrate(0);
    }
    if (this.vibratingProperty.get()) {
      // referenced so that it can be called eagerly without waiting for intensityDuration for first call
      const intervalFunction = () => {
        navigator.vibrate(this._vibrationIntensityPattern);
      };
      this._navigatorVibrationCallback = stepTimer.setInterval(intervalFunction, this._intensityDuration);
      intervalFunction();
    }
  }

  /**
   * Begins vibration. Optionally provide a pattern sequence for the vibration. Vibration will continue with the pattern
   * sequence until stopVibrate is called.
   */
  startVibrate(pattern) {
    this.resetTimingVariables();
    this._runningVibration = true;
    this._vibrationPattern = pattern ? pattern : DEFAULT_VIBRATION_PATTERN;
  }

  /**
   * Stops all vibration immediately.
   */
  stopVibrate() {
    this._runningVibration = false;
    this.vibratingProperty.set(false);
  }

  /**
   * Start a vibration. Optionally provide a pattern sequence for the vibration. Vibration will proceed for
   * time in ms and then stop.
   * @param time - in ms, how long the vibration should run
   * @param pattern - optional, pattern for the vibration, uses default vibration pattern if not defined
   */
  startTimedVibrate(time, pattern) {
    this.resetTimingVariables();
    this._patternTimeLimit = time;
    this._runningVibration = true;
    this._vibrationPattern = pattern ? pattern : DEFAULT_VIBRATION_PATTERN;
  }

  /**
   * Start a vibration using the specified pattern.
   * @param pattern - An array of integer values where even indexes represent on time and odd represent off times.
   *                  Times are in milliseconds.
   * TODO: This is an experimental method that expands a pattern in order to take advantage of the HTML5 vibration API,
   *       and not have to do as much pattern timing in our own code.  See https://github.com/phetsims/tappi/issues/13.
   */
  startRepeatingVibrationPattern(pattern) {
    // parameter checking
    assert && assert(pattern.length > 0, 'zero-length patterns are not allowed');
    assert && assert(pattern.length % 2 === 0, 'pattern must be an even length so that it ends with an off time');

    // Cancel any in-progress vibration and related timers.  This has no effect if no pattern is being played.
    this.stopRepeatingVibrationPattern();

    // Calculate the duration of the provided pattern in milliseconds.
    const providedPatternDuration = pattern.reduce((previousValue, currentValue) => previousValue + currentValue, 0);
    phet.log && phet.log(`providedPatternDuration = ${providedPatternDuration}`);

    // Calculate how many times to repeat this pattern before starting to play it again.
    const repeatCount = Math.floor(1000 * REPEATING_PATTERN_CYCLE_TIME / providedPatternDuration) + 1;
    phet.log && phet.log(`repeatCount = ${repeatCount}`);

    // Create an expanded version of the pattern that repeats the provided one a number of times.
    const expandedPattern = [];
    let totalPatternTime = 0;
    _.times(repeatCount, () => {
      pattern.forEach(timeValue => {
        expandedPattern.push(timeValue);
        totalPatternTime += timeValue;
      });
    });
    phet.log && phet.log(`expandedPattern = ${expandedPattern}`);
    phet.log && phet.log(`expandedPattern.length = ${expandedPattern.length}`);
    phet.log && phet.log(`totalPatternTime = ${totalPatternTime}`);

    // Play the expanded pattern.
    navigator.vibrate(expandedPattern);

    // Create a timer to restart the expanded pattern once it completes.
    this.expandedPatternInterval = stepTimer.setInterval(() => {
      navigator.vibrate(expandedPattern);
      phet.log && phet.log('restarting pattern');
    }, totalPatternTime);
  }

  /**
   * Stop a current repeating-pattern vibration.
   * TODO: This is an experimental method that stops patterns started using startRepeatingVibrationPattern, and not
   *       other vibrational patterns.  See https://github.com/phetsims/tappi/issues/13.
   */
  stopRepeatingVibrationPattern() {
    navigator.vibrate(0);
    if (this.expandedPatternInterval !== NOOP_TIME_LISTENER) {
      stepTimer.clearInterval(this.expandedPatternInterval);
      this.expandedPatternInterval = NOOP_TIME_LISTENER;
    }
  }

  /**
   * Shortcut to determine whether we are currently vibrating. This should accurately indicate whether the device is
   * actually vibrating.
   */
  isVibrating() {
    return this.vibratingProperty.get();
  }

  /**
   * Returns true if the VibrationManager is active with a vibration pattern. The device may or may not be actually
   * vibrating as this will return true even during downtime within a pattern.
   */
  isRunningPattern() {
    return this._runningVibration;
  }

  /**
   * Set the intensity of vibration. Will change intensity of the running vibration if there is one, or set the
   * intensity for the next time startVibrate is called.
   */
  setVibrationIntensity(intensity) {
    if (intensity === Intensity.LOW) {
      this._vibrationIntensityPattern = LOW_INTENSITY_PATTERN;
    } else if (intensity === Intensity.HIGH) {
      this._vibrationIntensityPattern = HIGH_INTENSITY_PATTERN;
    }
    const intensityDuration = _.reduce(this._vibrationIntensityPattern, (sum, value) => {
      return sum + value;
    });
    this._intensityDuration = typeof intensityDuration === 'number' ? intensityDuration : 0;

    // set after updating state
    this.intensityProperty.set(intensity);
  }

  /**
   * Reset all variables tracking time and where we are in the vibration sequence.
   */
  resetTimingVariables() {
    this._timeRunningCurrentInterval = 0;
    this._timeRunningCurrentPattern = 0;
    this._currentIntervalIndex = 0;
    this._patternTimeLimit = Number.POSITIVE_INFINITY;
  }

  /**
   * Vibrate at the intervals and intensity specified. To be called on the animation frame.
   */
  step(dt) {
    // navigator.vibrate works in milliseconds
    dt = dt * 1000;

    // running a vibration, vibrate with navigator
    if (this._runningVibration) {
      assert && assert(this._currentIntervalIndex < this._vibrationPattern.length, 'index out of interval length');
      const currentInterval = this._vibrationPattern[this._currentIntervalIndex];
      if (this._timeRunningCurrentInterval > currentInterval) {
        // move on to the next interval (or back to beginning if next index is out of array)
        const nextIndex = this._currentIntervalIndex + 1;
        this._currentIntervalIndex = nextIndex < this._vibrationPattern.length ? nextIndex : 0;
        this._timeRunningCurrentInterval = 0;
      } else {
        // proceed with vibration (or not) - even indices in the series are uptime
        if (this._currentIntervalIndex % 2 === 0) {
          this.vibratingProperty.set(true);
        } else {
          this.vibratingProperty.set(false);
        }
      }

      // increment timing variables for the whole pattern and individual pattern intervals
      this._timeRunningCurrentInterval += dt;
      this._timeRunningCurrentPattern += dt;
      if (this._timeRunningCurrentPattern >= this._patternTimeLimit) {
        this.stopVibrate();
      }
    }
  }
}

// create the singleton instance
const vibrationManager = new VibrationManager();
tappi.register('vibrationManager', vibrationManager);
export default vibrationManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJNdWx0aWxpbmsiLCJzdGVwVGltZXIiLCJ0YXBwaSIsIkVudW1lcmF0aW9uVmFsdWUiLCJFbnVtZXJhdGlvbiIsIkVudW1lcmF0aW9uUHJvcGVydHkiLCJMT1dfSU5URU5TSVRZX1BBVFRFUk4iLCJISUdIX0lOVEVOU0lUWV9QQVRURVJOIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIlJFUEVBVElOR19QQVRURVJOX0NZQ0xFX1RJTUUiLCJJbnRlbnNpdHkiLCJISUdIIiwiTE9XIiwiZW51bWVyYXRpb24iLCJOT09QX1RJTUVfTElTVEVORVIiLCJfIiwibm9vcCIsIkRFRkFVTFRfVklCUkFUSU9OX1BBVFRFUk4iLCJWaWJyYXRpb25NYW5hZ2VyIiwiZW5hYmxlZFByb3BlcnR5IiwidmlicmF0aW5nUHJvcGVydHkiLCJpbnRlbnNpdHlQcm9wZXJ0eSIsIl9ydW5uaW5nVmlicmF0aW9uIiwiX3ZpYnJhdGlvblBhdHRlcm4iLCJfaW50ZW5zaXR5RHVyYXRpb24iLCJfdGltZVJ1bm5pbmdDdXJyZW50SW50ZXJ2YWwiLCJfcGF0dGVyblRpbWVMaW1pdCIsIlBPU0lUSVZFX0lORklOSVRZIiwiX3RpbWVSdW5uaW5nQ3VycmVudFBhdHRlcm4iLCJfY3VycmVudEludGVydmFsSW5kZXgiLCJfdmlicmF0aW9uSW50ZW5zaXR5UGF0dGVybiIsIl9uYXZpZ2F0b3JWaWJyYXRpb25DYWxsYmFjayIsImV4cGFuZGVkUGF0dGVybkludGVydmFsIiwiaW5pdGlhbGl6ZSIsInNpbVZpc2libGVQcm9wZXJ0eSIsInNpbUFjdGl2ZVByb3BlcnR5Iiwic2V0VmlicmF0aW9uSW50ZW5zaXR5IiwiZ2V0IiwibXVsdGlsaW5rIiwidmlicmF0aW5nIiwiaW50ZW5zaXR5IiwiY29udHJvbE5hdmlnYXRvciIsImVuYWJsZWQiLCJzaW1WaXNpYmxlIiwic2ltQWN0aXZlIiwic3RvcFZpYnJhdGUiLCJjbGVhckludGVydmFsIiwibmF2aWdhdG9yIiwidmlicmF0ZSIsImludGVydmFsRnVuY3Rpb24iLCJzZXRJbnRlcnZhbCIsInN0YXJ0VmlicmF0ZSIsInBhdHRlcm4iLCJyZXNldFRpbWluZ1ZhcmlhYmxlcyIsInNldCIsInN0YXJ0VGltZWRWaWJyYXRlIiwidGltZSIsInN0YXJ0UmVwZWF0aW5nVmlicmF0aW9uUGF0dGVybiIsImFzc2VydCIsImxlbmd0aCIsInN0b3BSZXBlYXRpbmdWaWJyYXRpb25QYXR0ZXJuIiwicHJvdmlkZWRQYXR0ZXJuRHVyYXRpb24iLCJyZWR1Y2UiLCJwcmV2aW91c1ZhbHVlIiwiY3VycmVudFZhbHVlIiwicGhldCIsImxvZyIsInJlcGVhdENvdW50IiwiTWF0aCIsImZsb29yIiwiZXhwYW5kZWRQYXR0ZXJuIiwidG90YWxQYXR0ZXJuVGltZSIsInRpbWVzIiwiZm9yRWFjaCIsInRpbWVWYWx1ZSIsInB1c2giLCJpc1ZpYnJhdGluZyIsImlzUnVubmluZ1BhdHRlcm4iLCJpbnRlbnNpdHlEdXJhdGlvbiIsInN1bSIsInZhbHVlIiwic3RlcCIsImR0IiwiY3VycmVudEludGVydmFsIiwibmV4dEluZGV4IiwidmlicmF0aW9uTWFuYWdlciIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsidmlicmF0aW9uTWFuYWdlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOS0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBBIHNpbmdsZXRvbiB0aGF0IG1hbmFnZXMgdmlicmF0aW9uIGZlZWRiYWNrIHRocm91Z2ggdGhlIHdlYiB2aWJyYXRpb24gQVBJLiBuYXZpZ2F0b3IudmlicmF0ZSBpcyByZXF1aXJlZFxyXG4gKiB0byB1c2UgdGhpcyBmaWxlLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hdmlnYXRvci92aWJyYXRlIGZvciBtb3JlXHJcbiAqIGluZm9ybWF0aW9uIGFuZCBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHBsYXRmb3Jtcy4gSWYgbm90IGRlZmluZWQsIHRoaXMgZmlsZSB3aWxsIGRvIG5vdGhpbmcuXHJcbiAqXHJcbiAqIFZpYnJhdGlvbiBjYW4gYmUgc3RhcnRlZCB3aXRoIHZpYnJhdGlvbk1hbmFnZXIuc3RhcnRWaWJyYXRlKCkgdG8gYmVnaW4gY29udGludW91cyB2aWJyYXRpb24uIFN0b3Agd2l0aFxyXG4gKiB2aWJyYXRpb25NYW5hZ2VyLnN0b3BWaWJyYXRlLlxyXG4gKlxyXG4gKiBWaWJyYXRpb24gcGF0dGVybnMgY2FuIGFsc28gYmUgZGVmaW5lZCBzaW1pbGFybHkgdG8gbmF2aWdhdG9yLnZpYnJhdGUoKS4gdmlicmF0aW9uTWFuYWdlci5zdGFydFZpYnJhdGUoKVxyXG4gKiBjYW4gdGFrZSBhbiBhcnJheSBvZiBpbnRlcnZhbHMgdGhhdCBkZWZpbmUgdGhlIHVwdGltZS9kb3dudGltZSBvZiB0aGUgdmlicmF0aW9uIG1vdG9yLiBTZWUgdGhhdCBmdW5jdGlvblxyXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogU2luY2UgdGhlIG1hbmFnZXIgd29ya3Mgd2l0aCBpbnRlcnZhbHMgb2YgdGltZSwgaXQgbXVzdCBiZSBzdGVwcGVkIGV2ZXJ5IGFuaW1hdGlvbiBmcmFtZSB3aXRoXHJcbiAqIHZpYnJhdGlvbk1hbmFnZXIuc3RlcCgpLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEplc3NlIEdyZWVuYmVyZ1xyXG4gKi9cclxuXHJcbmltcG9ydCBCb29sZWFuUHJvcGVydHkgZnJvbSAnLi4vLi4vYXhvbi9qcy9Cb29sZWFuUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgTXVsdGlsaW5rIGZyb20gJy4uLy4uL2F4b24vanMvTXVsdGlsaW5rLmpzJztcclxuaW1wb3J0IHN0ZXBUaW1lciBmcm9tICcuLi8uLi9heG9uL2pzL3N0ZXBUaW1lci5qcyc7XHJcbmltcG9ydCB0YXBwaSBmcm9tICcuL3RhcHBpLmpzJztcclxuaW1wb3J0IEVudW1lcmF0aW9uVmFsdWUgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL0VudW1lcmF0aW9uVmFsdWUuanMnO1xyXG5pbXBvcnQgRW51bWVyYXRpb24gZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL0VudW1lcmF0aW9uLmpzJztcclxuaW1wb3J0IEVudW1lcmF0aW9uUHJvcGVydHkgZnJvbSAnLi4vLi4vYXhvbi9qcy9FbnVtZXJhdGlvblByb3BlcnR5LmpzJztcclxuaW1wb3J0IHsgVGltZXJMaXN0ZW5lciB9IGZyb20gJy4uLy4uL2F4b24vanMvVGltZXIuanMnO1xyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgTE9XX0lOVEVOU0lUWV9QQVRURVJOID0gWyA4LCA4IF07XHJcbmNvbnN0IEhJR0hfSU5URU5TSVRZX1BBVFRFUk4gPSBbIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCAwIF07XHJcbmNvbnN0IFJFUEVBVElOR19QQVRURVJOX0NZQ0xFX1RJTUUgPSA1OyAvLyBpbiBzZWNvbmRzXHJcblxyXG4vLyBlbnVtIGZvciBpbnRlbnNpdHkgbGV2ZWxzXHJcbmV4cG9ydCBjbGFzcyBJbnRlbnNpdHkgZXh0ZW5kcyBFbnVtZXJhdGlvblZhbHVlIHtcclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEhJR0ggPSBuZXcgSW50ZW5zaXR5KCk7XHJcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBMT1cgPSBuZXcgSW50ZW5zaXR5KCk7XHJcblxyXG4gIC8vIEdldHMgYSBsaXN0IG9mIGtleXMsIHZhbHVlcyBhbmQgbWFwcGluZyBiZXR3ZWVuIHRoZW0uICBGb3IgdXNlIGluIEVudW1lcmF0aW9uUHJvcGVydHkgYW5kIFBoRVQtaU9cclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGVudW1lcmF0aW9uID0gbmV3IEVudW1lcmF0aW9uKCBJbnRlbnNpdHkgKTtcclxufVxyXG5cclxuY29uc3QgTk9PUF9USU1FX0xJU1RFTkVSID0gXy5ub29wO1xyXG5cclxuLy8gYnkgZGVmYXVsdCwgdmlicmF0aW9uIHdpbGwgYmUgY29udGludW91cyB2aWJyYXRpb24gd2l0aG91dCBpbnRlcnJ1cHRpb25cclxuY29uc3QgREVGQVVMVF9WSUJSQVRJT05fUEFUVEVSTiA9IFsgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgXTtcclxuXHJcbmNsYXNzIFZpYnJhdGlvbk1hbmFnZXIge1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGVuYWJsZWRQcm9wZXJ0eSA9IG5ldyBCb29sZWFuUHJvcGVydHkoIHRydWUgKTtcclxuXHJcbiAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1vdG9yIHNob3VsZCBiZSB2aWJyYXRpbmcuIFRoaXMgYWNjdXJhdGVseSByZWZsZWN0cyB3aGV0aGVyIHRoZSBtb3RvciBpcyBydW5uaW5nIGR1cmluZ1xyXG4gIC8vIHVwdGltZS9kb3dudGltZSBkdXJpbmcgYSB2aWJyYXRpb24gcGF0dGVybi5cclxuICBwcml2YXRlIHJlYWRvbmx5IHZpYnJhdGluZ1Byb3BlcnR5ID0gbmV3IEJvb2xlYW5Qcm9wZXJ0eSggZmFsc2UgKTtcclxuXHJcbiAgLy8gSW5kaWNhdGVzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHZpYnJhdGlvbiBpbnRlbnNpdHkuIEVpdGhlciBISUdIIG9yIExPVywgdmlicmF0aW9uIGNhbiBiZSBvbmUgb2YgdGhlc2UgdHdvIChhdCB0aGlzXHJcbiAgLy8gdGltZSkgd2hpbGUgc3RpbGwgcHJvdmlkaW5nIGNvbnRpbnVvdXMgdmlicmF0aW9uLiAgVGhlIHZpYnJhdGlvbiBtb3RvciBpcyBlaXRoZXIgb24gb3Igb2ZmLCBhbmQgd2UgbWltaWMgXCJsb3dcIlxyXG4gIC8vIGludGVuc2l0eSB2aWJyYXRpb24gYnkgdHVybmluZyB0aGUgbW90b3Igb24gYW5kIG9mZiByYXBpZGx5LlxyXG4gIHByaXZhdGUgcmVhZG9ubHkgaW50ZW5zaXR5UHJvcGVydHkgPSBuZXcgRW51bWVyYXRpb25Qcm9wZXJ0eSggSW50ZW5zaXR5LkhJR0ggKTtcclxuXHJcbiAgLy8gV2hldGhlciBhIHZpYnJhdGlvbiBwYXR0ZXJuIGlzIHJ1bm5pbmcsIG1heSBub3QgaW5kaWNhdGUgd2hldGhlciB0aGUgZGV2aWNlIGlzIGFjdHVhbGx5IHZpYnJhdGluZyBhcyB0aGlzIGNvdWxkIGJlXHJcbiAgLy8gdHJ1ZSBkdXJpbmcgYSB2aWJyYXRpb24gcGF0dGVybiBkb3dudGltZS5cclxuICBwcml2YXRlIF9ydW5uaW5nVmlicmF0aW9uID0gZmFsc2U7XHJcblxyXG4gIC8vIFBhdHRlcm4gb2YgdmlicmF0aW9uIGFuZCBwYXVzZSBpbnRlcnZhbHMsIGVhY2ggdmFsdWUgaW5kaWNhdGVzIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdmlicmF0ZSBvciBwYXVzZSBpblxyXG4gIC8vIGFsdGVybmF0aW9uLiBVbmxpa2UgdGhlIE5hdmlnYXRvciBBUEksIHNpbmdsZSB2YWx1ZSBpcyBub3QgYWxsb3dlZCwgYW5kIGFueSBwYXR0ZXJuIGhlcmUgd2lsbCBwcm9jZWVkIHVudGlsXHJcbiAgLy8gc3RvcFZpYnJhdGUgaXMgY2FsbGVkLlxyXG4gIHByaXZhdGUgX3ZpYnJhdGlvblBhdHRlcm4gPSBERUZBVUxUX1ZJQlJBVElPTl9QQVRURVJOO1xyXG5cclxuICAvLyBUaGUgZHVyYXRpb24gb2YgYWN0aXZlIGludGVuc2l0eSBwYXR0ZXJuLCBvbmx5IHVzZWQgdG8gcHJvZHVjZSBvbmUgb2YgaW50ZW5zaXR5IGZlZWRiYWNrIGR1cmluZyBhY3RpdmUgdmlicmF0aW9uLlxyXG4gIHByaXZhdGUgX2ludGVuc2l0eUR1cmF0aW9uID0gMDtcclxuXHJcbiAgLy8gVHJhY2tzIGhvdyBsb25nIHdlIGhhdmUgYmVlbiB2aWJyYXRpbmcgYXQgdGhlIGN1cnJlbnQgaW50ZXJ2YWwgb2YgdGhlIHNwZWNpZmllZCB2aWJyYXRpb25QYXR0ZXJuLiBJbmNyZW1lbnRzIGV2ZW5cclxuICAvLyBkdXJpbmcgZG93bnRpbWUgXCJvZmZcIiBpbnRlcnZhbCBpbiBhIHBhdHRlcm4uXHJcbiAgcHJpdmF0ZSBfdGltZVJ1bm5pbmdDdXJyZW50SW50ZXJ2YWwgPSAwO1xyXG5cclxuICAvLyBMaW1pdGF0aW9uIGZvciB0aGUgYWN0aXZlIHZpYnJhdGlvbiwgdmlicmF0aW9uIHBhdHRlcm4gd2lsbCBydW4gdW50aWwgdGhpcyB0aW1lIHJ1bnMgb3V0LiBJbmNsdWRlcyBwYXR0ZXJuXHJcbiAgLy8gZG93bnRpbWUuIEJ5IGRlZmF1bHQsIHZpYnJhdGlvbiBwYXR0ZXJucyB3aWxsIHJ1biBmb3JldmVyLlxyXG4gIHByaXZhdGUgX3BhdHRlcm5UaW1lTGltaXQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblxyXG4gIC8vIEhvdyBtdWNoIHRpbWUgaGFzIHBhc3NlZCBzaW5jZSB3ZSBzdGFydGVkIHRvIHZpYnJhdGUgd2l0aCBhIHBhcnRpY3VsYXIgcGF0dGVybiwgd2lsbCBzdGlsbCBpbmNyZW1lbnQgZHVyaW5nXHJcbiAgLy8gdmlicmF0aW9uIHBhdHRlcm4gZG93bnRpbWUuXHJcbiAgcHJpdmF0ZSBfdGltZVJ1bm5pbmdDdXJyZW50UGF0dGVybiA9IDA7XHJcblxyXG4gIC8vIGluZGV4IG9mIHRoZSB2aWJyYXRpb25QYXR0ZXJuIHRoYXQgaXMgY3VycmVudGx5ICdhY3RpdmUnIGluIHRoZSBzZXF1ZW5jZVxyXG4gIHByaXZhdGUgX2N1cnJlbnRJbnRlcnZhbEluZGV4ID0gMDtcclxuXHJcbiAgcHJpdmF0ZSBfdmlicmF0aW9uSW50ZW5zaXR5UGF0dGVybiA9IEhJR0hfSU5URU5TSVRZX1BBVFRFUk47XHJcblxyXG4gIC8vIFJlZmVyZW5jZSB0byB0aGUgY2FsbGJhY2sgYWRkZWQgdG8gdGltZXIgdGhhdCBrZWVwcyB0aGUgdmlicmF0aW5nIG1vdG9yIHJ1bm5pbmcgdW50aWwgc3RvcFZpYnJhdGUuIFRoaXMgd2lsbFxyXG4gIC8vIGV2ZW50dWFsbHkgY2FsbCBuYXZpZ2F0b3IudmlicmF0ZS5cclxuICBwcml2YXRlIF9uYXZpZ2F0b3JWaWJyYXRpb25DYWxsYmFjazogVGltZXJMaXN0ZW5lciA9IE5PT1BfVElNRV9MSVNURU5FUjtcclxuXHJcbiAgcHJpdmF0ZSBleHBhbmRlZFBhdHRlcm5JbnRlcnZhbDogVGltZXJMaXN0ZW5lciA9IE5PT1BfVElNRV9MSVNURU5FUjtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgdmlicmF0aW9uTWFuYWdlciBieSBzZXR0aW5nIGluaXRpYWwgc3RhdGUgdmFyaWFibGVzIGFuZCBhdHRhY2hpbmcgbGlzdGVuZXJzLlxyXG4gICAqIE5PVEU6IFRoaXMgc2hvdWxkIGV2ZW50dWFsbHkgYmUgY2FsbGVkIGluIFNpbS5qcyAob3Igb3RoZXIgZnJhbWV3b3JrKSBvbmx5IHdoZW4gdmlicmF0aW9uIGlzIHJlcXVpcmVkLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBpbml0aWFsaXplKCBzaW1WaXNpYmxlUHJvcGVydHk6IFRSZWFkT25seVByb3BlcnR5PGJvb2xlYW4+LCBzaW1BY3RpdmVQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8Ym9vbGVhbj4gKTogdm9pZCB7XHJcbiAgICB0aGlzLnNldFZpYnJhdGlvbkludGVuc2l0eSggdGhpcy5pbnRlbnNpdHlQcm9wZXJ0eS5nZXQoKSApO1xyXG5cclxuICAgIC8vIGlmIGVpdGhlciB2aWJyYXRpb24gb3IgaW50ZW5zaXR5IGNoYW5nZXMgd2UgbmVlZCB0byBzdG9wL3N0YXJ0IHZpYnJhdGlvbiBvciBjaGFuZ2UgdGltZW91dHMgZm9yIGludGVuc2l0eVxyXG4gICAgTXVsdGlsaW5rLm11bHRpbGluayggWyB0aGlzLnZpYnJhdGluZ1Byb3BlcnR5LCB0aGlzLmludGVuc2l0eVByb3BlcnR5IF0sICggdmlicmF0aW5nLCBpbnRlbnNpdHkgKSA9PiB7XHJcbiAgICAgIHRoaXMuY29udHJvbE5hdmlnYXRvcigpO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIHN0b3AgYWxsIHZpYnJhdGlvbiB3aGVuIHRoZSBzaW0gaXMgaW52aXNpYmxlIG9yIGluYWN0aXZlXHJcbiAgICBNdWx0aWxpbmsubXVsdGlsaW5rKCBbIHRoaXMuZW5hYmxlZFByb3BlcnR5LCBzaW1WaXNpYmxlUHJvcGVydHksIHNpbUFjdGl2ZVByb3BlcnR5IF0sICggZW5hYmxlZCwgc2ltVmlzaWJsZSwgc2ltQWN0aXZlICkgPT4ge1xyXG4gICAgICBpZiAoIGVuYWJsZWQgJiYgc2ltVmlzaWJsZSAmJiBzaW1BY3RpdmUgKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wVmlicmF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWF0ZSB2aWJyYXRpb24gd2l0aCBuYXZpZ2F0b3IudmlicmF0ZSBhdCB0aGUgY29ycmVjdCBpbnRlcnZhbHMgZm9yIHZpYnJhdGlvbiBpbnRlbnNpdHkuXHJcbiAgICovXHJcbiAgcHVibGljIGNvbnRyb2xOYXZpZ2F0b3IoKTogdm9pZCB7XHJcbiAgICBpZiAoIHRoaXMuX25hdmlnYXRvclZpYnJhdGlvbkNhbGxiYWNrICkge1xyXG4gICAgICBzdGVwVGltZXIuY2xlYXJJbnRlcnZhbCggdGhpcy5fbmF2aWdhdG9yVmlicmF0aW9uQ2FsbGJhY2sgKTtcclxuICAgICAgdGhpcy5fbmF2aWdhdG9yVmlicmF0aW9uQ2FsbGJhY2sgPSBOT09QX1RJTUVfTElTVEVORVI7XHJcblxyXG4gICAgICAvLyBzdG9wIGFueSBwcmV2aW91cyB2aWJyYXRpb25cclxuICAgICAgbmF2aWdhdG9yLnZpYnJhdGUoIDAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIHRoaXMudmlicmF0aW5nUHJvcGVydHkuZ2V0KCkgKSB7XHJcblxyXG4gICAgICAvLyByZWZlcmVuY2VkIHNvIHRoYXQgaXQgY2FuIGJlIGNhbGxlZCBlYWdlcmx5IHdpdGhvdXQgd2FpdGluZyBmb3IgaW50ZW5zaXR5RHVyYXRpb24gZm9yIGZpcnN0IGNhbGxcclxuICAgICAgY29uc3QgaW50ZXJ2YWxGdW5jdGlvbiA9ICgpID0+IHtcclxuICAgICAgICBuYXZpZ2F0b3IudmlicmF0ZSggdGhpcy5fdmlicmF0aW9uSW50ZW5zaXR5UGF0dGVybiApO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9uYXZpZ2F0b3JWaWJyYXRpb25DYWxsYmFjayA9IHN0ZXBUaW1lci5zZXRJbnRlcnZhbCggaW50ZXJ2YWxGdW5jdGlvbiwgdGhpcy5faW50ZW5zaXR5RHVyYXRpb24gKTtcclxuICAgICAgaW50ZXJ2YWxGdW5jdGlvbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmVnaW5zIHZpYnJhdGlvbi4gT3B0aW9uYWxseSBwcm92aWRlIGEgcGF0dGVybiBzZXF1ZW5jZSBmb3IgdGhlIHZpYnJhdGlvbi4gVmlicmF0aW9uIHdpbGwgY29udGludWUgd2l0aCB0aGUgcGF0dGVyblxyXG4gICAqIHNlcXVlbmNlIHVudGlsIHN0b3BWaWJyYXRlIGlzIGNhbGxlZC5cclxuICAgKi9cclxuICBwdWJsaWMgc3RhcnRWaWJyYXRlKCBwYXR0ZXJuOiBudW1iZXJbXSApOiB2b2lkIHtcclxuICAgIHRoaXMucmVzZXRUaW1pbmdWYXJpYWJsZXMoKTtcclxuICAgIHRoaXMuX3J1bm5pbmdWaWJyYXRpb24gPSB0cnVlO1xyXG4gICAgdGhpcy5fdmlicmF0aW9uUGF0dGVybiA9IHBhdHRlcm4gPyBwYXR0ZXJuIDogREVGQVVMVF9WSUJSQVRJT05fUEFUVEVSTjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3BzIGFsbCB2aWJyYXRpb24gaW1tZWRpYXRlbHkuXHJcbiAgICovXHJcbiAgcHVibGljIHN0b3BWaWJyYXRlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fcnVubmluZ1ZpYnJhdGlvbiA9IGZhbHNlO1xyXG4gICAgdGhpcy52aWJyYXRpbmdQcm9wZXJ0eS5zZXQoIGZhbHNlICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBhIHZpYnJhdGlvbi4gT3B0aW9uYWxseSBwcm92aWRlIGEgcGF0dGVybiBzZXF1ZW5jZSBmb3IgdGhlIHZpYnJhdGlvbi4gVmlicmF0aW9uIHdpbGwgcHJvY2VlZCBmb3JcclxuICAgKiB0aW1lIGluIG1zIGFuZCB0aGVuIHN0b3AuXHJcbiAgICogQHBhcmFtIHRpbWUgLSBpbiBtcywgaG93IGxvbmcgdGhlIHZpYnJhdGlvbiBzaG91bGQgcnVuXHJcbiAgICogQHBhcmFtIHBhdHRlcm4gLSBvcHRpb25hbCwgcGF0dGVybiBmb3IgdGhlIHZpYnJhdGlvbiwgdXNlcyBkZWZhdWx0IHZpYnJhdGlvbiBwYXR0ZXJuIGlmIG5vdCBkZWZpbmVkXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXJ0VGltZWRWaWJyYXRlKCB0aW1lOiBudW1iZXIsIHBhdHRlcm46IG51bWJlcltdICk6IHZvaWQge1xyXG4gICAgdGhpcy5yZXNldFRpbWluZ1ZhcmlhYmxlcygpO1xyXG5cclxuICAgIHRoaXMuX3BhdHRlcm5UaW1lTGltaXQgPSB0aW1lO1xyXG4gICAgdGhpcy5fcnVubmluZ1ZpYnJhdGlvbiA9IHRydWU7XHJcbiAgICB0aGlzLl92aWJyYXRpb25QYXR0ZXJuID0gcGF0dGVybiA/IHBhdHRlcm4gOiBERUZBVUxUX1ZJQlJBVElPTl9QQVRURVJOO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgYSB2aWJyYXRpb24gdXNpbmcgdGhlIHNwZWNpZmllZCBwYXR0ZXJuLlxyXG4gICAqIEBwYXJhbSBwYXR0ZXJuIC0gQW4gYXJyYXkgb2YgaW50ZWdlciB2YWx1ZXMgd2hlcmUgZXZlbiBpbmRleGVzIHJlcHJlc2VudCBvbiB0aW1lIGFuZCBvZGQgcmVwcmVzZW50IG9mZiB0aW1lcy5cclxuICAgKiAgICAgICAgICAgICAgICAgIFRpbWVzIGFyZSBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICogVE9ETzogVGhpcyBpcyBhbiBleHBlcmltZW50YWwgbWV0aG9kIHRoYXQgZXhwYW5kcyBhIHBhdHRlcm4gaW4gb3JkZXIgdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhlIEhUTUw1IHZpYnJhdGlvbiBBUEksXHJcbiAgICogICAgICAgYW5kIG5vdCBoYXZlIHRvIGRvIGFzIG11Y2ggcGF0dGVybiB0aW1pbmcgaW4gb3VyIG93biBjb2RlLiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy90YXBwaS9pc3N1ZXMvMTMuXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXJ0UmVwZWF0aW5nVmlicmF0aW9uUGF0dGVybiggcGF0dGVybjogbnVtYmVyW10gKTogdm9pZCB7XHJcblxyXG4gICAgLy8gcGFyYW1ldGVyIGNoZWNraW5nXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwYXR0ZXJuLmxlbmd0aCA+IDAsICd6ZXJvLWxlbmd0aCBwYXR0ZXJucyBhcmUgbm90IGFsbG93ZWQnICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwYXR0ZXJuLmxlbmd0aCAlIDIgPT09IDAsICdwYXR0ZXJuIG11c3QgYmUgYW4gZXZlbiBsZW5ndGggc28gdGhhdCBpdCBlbmRzIHdpdGggYW4gb2ZmIHRpbWUnICk7XHJcblxyXG4gICAgLy8gQ2FuY2VsIGFueSBpbi1wcm9ncmVzcyB2aWJyYXRpb24gYW5kIHJlbGF0ZWQgdGltZXJzLiAgVGhpcyBoYXMgbm8gZWZmZWN0IGlmIG5vIHBhdHRlcm4gaXMgYmVpbmcgcGxheWVkLlxyXG4gICAgdGhpcy5zdG9wUmVwZWF0aW5nVmlicmF0aW9uUGF0dGVybigpO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZHVyYXRpb24gb2YgdGhlIHByb3ZpZGVkIHBhdHRlcm4gaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgY29uc3QgcHJvdmlkZWRQYXR0ZXJuRHVyYXRpb24gPSBwYXR0ZXJuLnJlZHVjZSggKCAoIHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSApID0+IHByZXZpb3VzVmFsdWUgKyBjdXJyZW50VmFsdWUgKSwgMCApO1xyXG4gICAgcGhldC5sb2cgJiYgcGhldC5sb2coIGBwcm92aWRlZFBhdHRlcm5EdXJhdGlvbiA9ICR7cHJvdmlkZWRQYXR0ZXJuRHVyYXRpb259YCApO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBob3cgbWFueSB0aW1lcyB0byByZXBlYXQgdGhpcyBwYXR0ZXJuIGJlZm9yZSBzdGFydGluZyB0byBwbGF5IGl0IGFnYWluLlxyXG4gICAgY29uc3QgcmVwZWF0Q291bnQgPSBNYXRoLmZsb29yKCAxMDAwICogUkVQRUFUSU5HX1BBVFRFUk5fQ1lDTEVfVElNRSAvIHByb3ZpZGVkUGF0dGVybkR1cmF0aW9uICkgKyAxO1xyXG5cclxuICAgIHBoZXQubG9nICYmIHBoZXQubG9nKCBgcmVwZWF0Q291bnQgPSAke3JlcGVhdENvdW50fWAgKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYW4gZXhwYW5kZWQgdmVyc2lvbiBvZiB0aGUgcGF0dGVybiB0aGF0IHJlcGVhdHMgdGhlIHByb3ZpZGVkIG9uZSBhIG51bWJlciBvZiB0aW1lcy5cclxuICAgIGNvbnN0IGV4cGFuZGVkUGF0dGVybjogbnVtYmVyW10gPSBbXTtcclxuICAgIGxldCB0b3RhbFBhdHRlcm5UaW1lID0gMDtcclxuICAgIF8udGltZXMoIHJlcGVhdENvdW50LCAoKSA9PiB7XHJcbiAgICAgIHBhdHRlcm4uZm9yRWFjaCggdGltZVZhbHVlID0+IHtcclxuICAgICAgICBleHBhbmRlZFBhdHRlcm4ucHVzaCggdGltZVZhbHVlICk7XHJcbiAgICAgICAgdG90YWxQYXR0ZXJuVGltZSArPSB0aW1lVmFsdWU7XHJcbiAgICAgIH0gKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICBwaGV0LmxvZyAmJiBwaGV0LmxvZyggYGV4cGFuZGVkUGF0dGVybiA9ICR7ZXhwYW5kZWRQYXR0ZXJufWAgKTtcclxuICAgIHBoZXQubG9nICYmIHBoZXQubG9nKCBgZXhwYW5kZWRQYXR0ZXJuLmxlbmd0aCA9ICR7ZXhwYW5kZWRQYXR0ZXJuLmxlbmd0aH1gICk7XHJcbiAgICBwaGV0LmxvZyAmJiBwaGV0LmxvZyggYHRvdGFsUGF0dGVyblRpbWUgPSAke3RvdGFsUGF0dGVyblRpbWV9YCApO1xyXG5cclxuICAgIC8vIFBsYXkgdGhlIGV4cGFuZGVkIHBhdHRlcm4uXHJcbiAgICBuYXZpZ2F0b3IudmlicmF0ZSggZXhwYW5kZWRQYXR0ZXJuICk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgdGltZXIgdG8gcmVzdGFydCB0aGUgZXhwYW5kZWQgcGF0dGVybiBvbmNlIGl0IGNvbXBsZXRlcy5cclxuICAgIHRoaXMuZXhwYW5kZWRQYXR0ZXJuSW50ZXJ2YWwgPSBzdGVwVGltZXIuc2V0SW50ZXJ2YWwoXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICBuYXZpZ2F0b3IudmlicmF0ZSggZXhwYW5kZWRQYXR0ZXJuICk7XHJcbiAgICAgICAgcGhldC5sb2cgJiYgcGhldC5sb2coICdyZXN0YXJ0aW5nIHBhdHRlcm4nICk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHRvdGFsUGF0dGVyblRpbWVcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIGEgY3VycmVudCByZXBlYXRpbmctcGF0dGVybiB2aWJyYXRpb24uXHJcbiAgICogVE9ETzogVGhpcyBpcyBhbiBleHBlcmltZW50YWwgbWV0aG9kIHRoYXQgc3RvcHMgcGF0dGVybnMgc3RhcnRlZCB1c2luZyBzdGFydFJlcGVhdGluZ1ZpYnJhdGlvblBhdHRlcm4sIGFuZCBub3RcclxuICAgKiAgICAgICBvdGhlciB2aWJyYXRpb25hbCBwYXR0ZXJucy4gIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdGFwcGkvaXNzdWVzLzEzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdG9wUmVwZWF0aW5nVmlicmF0aW9uUGF0dGVybigpOiB2b2lkIHtcclxuICAgIG5hdmlnYXRvci52aWJyYXRlKCAwICk7XHJcbiAgICBpZiAoIHRoaXMuZXhwYW5kZWRQYXR0ZXJuSW50ZXJ2YWwgIT09IE5PT1BfVElNRV9MSVNURU5FUiApIHtcclxuICAgICAgc3RlcFRpbWVyLmNsZWFySW50ZXJ2YWwoIHRoaXMuZXhwYW5kZWRQYXR0ZXJuSW50ZXJ2YWwgKTtcclxuICAgICAgdGhpcy5leHBhbmRlZFBhdHRlcm5JbnRlcnZhbCA9IE5PT1BfVElNRV9MSVNURU5FUjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3J0Y3V0IHRvIGRldGVybWluZSB3aGV0aGVyIHdlIGFyZSBjdXJyZW50bHkgdmlicmF0aW5nLiBUaGlzIHNob3VsZCBhY2N1cmF0ZWx5IGluZGljYXRlIHdoZXRoZXIgdGhlIGRldmljZSBpc1xyXG4gICAqIGFjdHVhbGx5IHZpYnJhdGluZy5cclxuICAgKi9cclxuICBwdWJsaWMgaXNWaWJyYXRpbmcoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy52aWJyYXRpbmdQcm9wZXJ0eS5nZXQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVmlicmF0aW9uTWFuYWdlciBpcyBhY3RpdmUgd2l0aCBhIHZpYnJhdGlvbiBwYXR0ZXJuLiBUaGUgZGV2aWNlIG1heSBvciBtYXkgbm90IGJlIGFjdHVhbGx5XHJcbiAgICogdmlicmF0aW5nIGFzIHRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBldmVuIGR1cmluZyBkb3dudGltZSB3aXRoaW4gYSBwYXR0ZXJuLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBpc1J1bm5pbmdQYXR0ZXJuKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3J1bm5pbmdWaWJyYXRpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIGludGVuc2l0eSBvZiB2aWJyYXRpb24uIFdpbGwgY2hhbmdlIGludGVuc2l0eSBvZiB0aGUgcnVubmluZyB2aWJyYXRpb24gaWYgdGhlcmUgaXMgb25lLCBvciBzZXQgdGhlXHJcbiAgICogaW50ZW5zaXR5IGZvciB0aGUgbmV4dCB0aW1lIHN0YXJ0VmlicmF0ZSBpcyBjYWxsZWQuXHJcbiAgICovXHJcbiAgcHVibGljIHNldFZpYnJhdGlvbkludGVuc2l0eSggaW50ZW5zaXR5OiBJbnRlbnNpdHkgKTogdm9pZCB7XHJcblxyXG4gICAgaWYgKCBpbnRlbnNpdHkgPT09IEludGVuc2l0eS5MT1cgKSB7XHJcbiAgICAgIHRoaXMuX3ZpYnJhdGlvbkludGVuc2l0eVBhdHRlcm4gPSBMT1dfSU5URU5TSVRZX1BBVFRFUk47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggaW50ZW5zaXR5ID09PSBJbnRlbnNpdHkuSElHSCApIHtcclxuICAgICAgdGhpcy5fdmlicmF0aW9uSW50ZW5zaXR5UGF0dGVybiA9IEhJR0hfSU5URU5TSVRZX1BBVFRFUk47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW50ZW5zaXR5RHVyYXRpb24gPSBfLnJlZHVjZSggdGhpcy5fdmlicmF0aW9uSW50ZW5zaXR5UGF0dGVybiwgKCBzdW0sIHZhbHVlICkgPT4ge1xyXG4gICAgICByZXR1cm4gc3VtICsgdmFsdWU7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy5faW50ZW5zaXR5RHVyYXRpb24gPSB0eXBlb2YgaW50ZW5zaXR5RHVyYXRpb24gPT09ICdudW1iZXInID8gaW50ZW5zaXR5RHVyYXRpb24gOiAwO1xyXG5cclxuICAgIC8vIHNldCBhZnRlciB1cGRhdGluZyBzdGF0ZVxyXG4gICAgdGhpcy5pbnRlbnNpdHlQcm9wZXJ0eS5zZXQoIGludGVuc2l0eSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgYWxsIHZhcmlhYmxlcyB0cmFja2luZyB0aW1lIGFuZCB3aGVyZSB3ZSBhcmUgaW4gdGhlIHZpYnJhdGlvbiBzZXF1ZW5jZS5cclxuICAgKi9cclxuICBwcml2YXRlIHJlc2V0VGltaW5nVmFyaWFibGVzKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fdGltZVJ1bm5pbmdDdXJyZW50SW50ZXJ2YWwgPSAwO1xyXG4gICAgdGhpcy5fdGltZVJ1bm5pbmdDdXJyZW50UGF0dGVybiA9IDA7XHJcbiAgICB0aGlzLl9jdXJyZW50SW50ZXJ2YWxJbmRleCA9IDA7XHJcbiAgICB0aGlzLl9wYXR0ZXJuVGltZUxpbWl0ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmlicmF0ZSBhdCB0aGUgaW50ZXJ2YWxzIGFuZCBpbnRlbnNpdHkgc3BlY2lmaWVkLiBUbyBiZSBjYWxsZWQgb24gdGhlIGFuaW1hdGlvbiBmcmFtZS5cclxuICAgKi9cclxuICBwdWJsaWMgc3RlcCggZHQ6IG51bWJlciApOiB2b2lkIHtcclxuXHJcbiAgICAvLyBuYXZpZ2F0b3IudmlicmF0ZSB3b3JrcyBpbiBtaWxsaXNlY29uZHNcclxuICAgIGR0ID0gZHQgKiAxMDAwO1xyXG5cclxuICAgIC8vIHJ1bm5pbmcgYSB2aWJyYXRpb24sIHZpYnJhdGUgd2l0aCBuYXZpZ2F0b3JcclxuICAgIGlmICggdGhpcy5fcnVubmluZ1ZpYnJhdGlvbiApIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5fY3VycmVudEludGVydmFsSW5kZXggPCB0aGlzLl92aWJyYXRpb25QYXR0ZXJuLmxlbmd0aCwgJ2luZGV4IG91dCBvZiBpbnRlcnZhbCBsZW5ndGgnICk7XHJcblxyXG4gICAgICBjb25zdCBjdXJyZW50SW50ZXJ2YWwgPSB0aGlzLl92aWJyYXRpb25QYXR0ZXJuWyB0aGlzLl9jdXJyZW50SW50ZXJ2YWxJbmRleCBdO1xyXG4gICAgICBpZiAoIHRoaXMuX3RpbWVSdW5uaW5nQ3VycmVudEludGVydmFsID4gY3VycmVudEludGVydmFsICkge1xyXG5cclxuICAgICAgICAvLyBtb3ZlIG9uIHRvIHRoZSBuZXh0IGludGVydmFsIChvciBiYWNrIHRvIGJlZ2lubmluZyBpZiBuZXh0IGluZGV4IGlzIG91dCBvZiBhcnJheSlcclxuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLl9jdXJyZW50SW50ZXJ2YWxJbmRleCArIDE7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEludGVydmFsSW5kZXggPSBuZXh0SW5kZXggPCB0aGlzLl92aWJyYXRpb25QYXR0ZXJuLmxlbmd0aCA/IG5leHRJbmRleCA6IDA7XHJcbiAgICAgICAgdGhpcy5fdGltZVJ1bm5pbmdDdXJyZW50SW50ZXJ2YWwgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBwcm9jZWVkIHdpdGggdmlicmF0aW9uIChvciBub3QpIC0gZXZlbiBpbmRpY2VzIGluIHRoZSBzZXJpZXMgYXJlIHVwdGltZVxyXG4gICAgICAgIGlmICggdGhpcy5fY3VycmVudEludGVydmFsSW5kZXggJSAyID09PSAwICkge1xyXG4gICAgICAgICAgdGhpcy52aWJyYXRpbmdQcm9wZXJ0eS5zZXQoIHRydWUgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnZpYnJhdGluZ1Byb3BlcnR5LnNldCggZmFsc2UgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGluY3JlbWVudCB0aW1pbmcgdmFyaWFibGVzIGZvciB0aGUgd2hvbGUgcGF0dGVybiBhbmQgaW5kaXZpZHVhbCBwYXR0ZXJuIGludGVydmFsc1xyXG4gICAgICB0aGlzLl90aW1lUnVubmluZ0N1cnJlbnRJbnRlcnZhbCArPSBkdDtcclxuICAgICAgdGhpcy5fdGltZVJ1bm5pbmdDdXJyZW50UGF0dGVybiArPSBkdDtcclxuXHJcbiAgICAgIGlmICggdGhpcy5fdGltZVJ1bm5pbmdDdXJyZW50UGF0dGVybiA+PSB0aGlzLl9wYXR0ZXJuVGltZUxpbWl0ICkge1xyXG4gICAgICAgIHRoaXMuc3RvcFZpYnJhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gY3JlYXRlIHRoZSBzaW5nbGV0b24gaW5zdGFuY2VcclxuY29uc3QgdmlicmF0aW9uTWFuYWdlciA9IG5ldyBWaWJyYXRpb25NYW5hZ2VyKCk7XHJcblxyXG50YXBwaS5yZWdpc3RlciggJ3ZpYnJhdGlvbk1hbmFnZXInLCB2aWJyYXRpb25NYW5hZ2VyICk7XHJcbmV4cG9ydCBkZWZhdWx0IHZpYnJhdGlvbk1hbmFnZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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