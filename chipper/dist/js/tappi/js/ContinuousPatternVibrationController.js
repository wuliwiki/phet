// Copyright 2020-2023, University of Colorado Boulder

/**
 * Controls and supports continuous vibration patterns and smooth transition from pattern to pattern.
 * Instead of requesting a new vibration pattern immediately, this controller waits until
 * the end of an "active" vibration pattern. The result is that the user cannot feel the change in
 * pattern as we smoothly transition, which is what would happen if we requested a new pattern
 * while in the middle of an 'on' phase of the current pattern.
 *
 * And so this class as both an "active" pattern, which is currently running and a "pending" pattern,
 * which will become the "active" pattern as soon as the previous "active" pattern finishes.
 *
 * NOTE: Instead of waiting until the end of a pattern to request a new one, it may be useful
 * to request a new pattern at the end of an 'off' portion of the current pattern. May be
 * important for long patterns where we want to transition to new pattern quickly but don't want to
 * wait until the old one finishes.
 *
 * @author Jesse Greenberg
 */

import optionize from '../../phet-core/js/optionize.js';
import tappi from './tappi.js';
class ContinuousPatternVibrationController {
  // sends requests to the iOS app to begin/stop vibration

  // current index of the active vibration pattern
  patternIndex = 0;

  // current interval value of the active vibration pattern
  patternValue = 0;

  // current interval value of the active vibration pattern, in seconds
  valueTime = 0;

  // whether we are currently running the vibration pattern
  runningPattern = false;

  // the pattern that we are going to transition to at the end of the currently active pattern

  constructor(vibrationManageriOS, providedOptions) {
    const options = optionize()({
      repeat: true,
      sharpness: 1,
      intensity: 1,
      activePattern: []
    }, providedOptions);
    this.vibrationManageriOS = vibrationManageriOS;
    this.activePattern = options.activePattern;
    this.repeat = options.repeat;
    this.intensity = options.intensity;
    this.sharpness = options.sharpness;
    this.pendingPattern = this.activePattern;
  }

  /**
   * Step forward in time, updates patterns.
   */
  step(dt) {
    if (this.runningPattern) {
      this.valueTime += dt;
      if (this.valueTime >= this.patternValue) {
        this.valueTime = 0;
        this.patternIndex++;
        if (this.patternIndex < this.activePattern.length) {
          this.patternValue = this.activePattern[this.patternIndex];
          if (this.patternIndex % 2 === 0) {
            // even index, indicating 'on' time for vibration
            this.vibrationManageriOS.vibrateContinuous({
              intensity: this.intensity,
              sharpness: this.sharpness
            });
          } else {
            // odd index, indicating 'off' time for vibration
            this.vibrationManageriOS.stop();
          }
        } else if (this.repeat) {
          // before looping the pattern, check to see if the pattern has changed
          if (!_.isEqual(this.pendingPattern, this.activePattern)) {
            this.setNewActivePattern(this.pendingPattern);
          }

          // restart the pattern, and start again from the beginning
          this.start();
        } else {
          // not looping, stop vibration at end of pattern
          this.stop();
        }
      }
    }
  }

  /**
   * Transition from the previous pattern to the next pattern, which will start to play when start() is called.
   */
  setNewActivePattern(pattern) {
    assert && assert(pattern.length > 0, 'pattern must have some length');
    this.activePattern = pattern;

    // reset variables tracking where we are running the pattern, we will start over when we set a new active pattern
    this.resetPattern();
  }

  /**
   * Set the new pattern for the controller. If we are running, this will be the pending pattern
   * which we will request at the end of the current pattern to avoid stutter during rapid changes.
   * If a pattern is not running, this will be set as the active pattern right away, and can begin
   * ass soon as start() is called.
   */
  setPattern(pattern) {
    assert && assert(pattern.length > 0, 'pattern must have some values');
    this.pendingPattern = pattern;
    if (!this.runningPattern) {
      this.setNewActivePattern(this.pendingPattern);
    }
  }

  /**
   * Set the intensity for the vibration pattern, for both the active and pending patterns.
   */
  setIntensity(intensity) {
    this.intensity = intensity;
  }

  /**
   * Set the sharpness for the vibration pattern, for both the active and pending patterns.
   */
  setSharpness(sharpness) {
    this.sharpness = sharpness;
  }

  /**
   * Set whether or not the active pattern will repeat.
   */
  setRepeat(repeat) {
    this.repeat = repeat;
  }

  /**
   * Start vibrating with the active pattern. Calling this will reset where we are in the active vibration pattern.
   */
  start() {
    this.runningPattern = true;
    this.resetPattern();
    this.vibrationManageriOS.vibrateContinuous({
      intensity: this.intensity,
      sharpness: this.sharpness
    });
  }

  /**
   * Stop all vibration and play of the active pattern if we are running.
   */
  stop() {
    if (this.runningPattern) {
      this.vibrationManageriOS.stop();
      this.runningPattern = false;
      this.resetPattern();
    }
  }

  /**
   * Reset the active pattern, and where we are in its playthrough.
   */
  resetPattern() {
    this.patternIndex = 0;
    this.patternValue = this.activePattern[this.patternIndex];
    this.valueTime = 0;
  }
}
tappi.register('ContinuousPatternVibrationController', ContinuousPatternVibrationController);
export default ContinuousPatternVibrationController;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJvcHRpb25pemUiLCJ0YXBwaSIsIkNvbnRpbnVvdXNQYXR0ZXJuVmlicmF0aW9uQ29udHJvbGxlciIsInBhdHRlcm5JbmRleCIsInBhdHRlcm5WYWx1ZSIsInZhbHVlVGltZSIsInJ1bm5pbmdQYXR0ZXJuIiwiY29uc3RydWN0b3IiLCJ2aWJyYXRpb25NYW5hZ2VyaU9TIiwicHJvdmlkZWRPcHRpb25zIiwib3B0aW9ucyIsInJlcGVhdCIsInNoYXJwbmVzcyIsImludGVuc2l0eSIsImFjdGl2ZVBhdHRlcm4iLCJwZW5kaW5nUGF0dGVybiIsInN0ZXAiLCJkdCIsImxlbmd0aCIsInZpYnJhdGVDb250aW51b3VzIiwic3RvcCIsIl8iLCJpc0VxdWFsIiwic2V0TmV3QWN0aXZlUGF0dGVybiIsInN0YXJ0IiwicGF0dGVybiIsImFzc2VydCIsInJlc2V0UGF0dGVybiIsInNldFBhdHRlcm4iLCJzZXRJbnRlbnNpdHkiLCJzZXRTaGFycG5lc3MiLCJzZXRSZXBlYXQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkNvbnRpbnVvdXNQYXR0ZXJuVmlicmF0aW9uQ29udHJvbGxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMC0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBDb250cm9scyBhbmQgc3VwcG9ydHMgY29udGludW91cyB2aWJyYXRpb24gcGF0dGVybnMgYW5kIHNtb290aCB0cmFuc2l0aW9uIGZyb20gcGF0dGVybiB0byBwYXR0ZXJuLlxyXG4gKiBJbnN0ZWFkIG9mIHJlcXVlc3RpbmcgYSBuZXcgdmlicmF0aW9uIHBhdHRlcm4gaW1tZWRpYXRlbHksIHRoaXMgY29udHJvbGxlciB3YWl0cyB1bnRpbFxyXG4gKiB0aGUgZW5kIG9mIGFuIFwiYWN0aXZlXCIgdmlicmF0aW9uIHBhdHRlcm4uIFRoZSByZXN1bHQgaXMgdGhhdCB0aGUgdXNlciBjYW5ub3QgZmVlbCB0aGUgY2hhbmdlIGluXHJcbiAqIHBhdHRlcm4gYXMgd2Ugc21vb3RobHkgdHJhbnNpdGlvbiwgd2hpY2ggaXMgd2hhdCB3b3VsZCBoYXBwZW4gaWYgd2UgcmVxdWVzdGVkIGEgbmV3IHBhdHRlcm5cclxuICogd2hpbGUgaW4gdGhlIG1pZGRsZSBvZiBhbiAnb24nIHBoYXNlIG9mIHRoZSBjdXJyZW50IHBhdHRlcm4uXHJcbiAqXHJcbiAqIEFuZCBzbyB0aGlzIGNsYXNzIGFzIGJvdGggYW4gXCJhY3RpdmVcIiBwYXR0ZXJuLCB3aGljaCBpcyBjdXJyZW50bHkgcnVubmluZyBhbmQgYSBcInBlbmRpbmdcIiBwYXR0ZXJuLFxyXG4gKiB3aGljaCB3aWxsIGJlY29tZSB0aGUgXCJhY3RpdmVcIiBwYXR0ZXJuIGFzIHNvb24gYXMgdGhlIHByZXZpb3VzIFwiYWN0aXZlXCIgcGF0dGVybiBmaW5pc2hlcy5cclxuICpcclxuICogTk9URTogSW5zdGVhZCBvZiB3YWl0aW5nIHVudGlsIHRoZSBlbmQgb2YgYSBwYXR0ZXJuIHRvIHJlcXVlc3QgYSBuZXcgb25lLCBpdCBtYXkgYmUgdXNlZnVsXHJcbiAqIHRvIHJlcXVlc3QgYSBuZXcgcGF0dGVybiBhdCB0aGUgZW5kIG9mIGFuICdvZmYnIHBvcnRpb24gb2YgdGhlIGN1cnJlbnQgcGF0dGVybi4gTWF5IGJlXHJcbiAqIGltcG9ydGFudCBmb3IgbG9uZyBwYXR0ZXJucyB3aGVyZSB3ZSB3YW50IHRvIHRyYW5zaXRpb24gdG8gbmV3IHBhdHRlcm4gcXVpY2tseSBidXQgZG9uJ3Qgd2FudCB0b1xyXG4gKiB3YWl0IHVudGlsIHRoZSBvbGQgb25lIGZpbmlzaGVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEplc3NlIEdyZWVuYmVyZ1xyXG4gKi9cclxuXHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCB0YXBwaSBmcm9tICcuL3RhcHBpLmpzJztcclxuaW1wb3J0IFZpYnJhdGlvbk1hbmFnZXJpT1MgZnJvbSAnLi9WaWJyYXRpb25NYW5hZ2VyaU9TLmpzJztcclxuXHJcbmV4cG9ydCB0eXBlIENvbnRpbnVvdXNQYXR0ZXJuVmlicmF0aW9uQ29udHJvbGxlck9wdGlvbnMgPSB7XHJcblxyXG4gIC8vIFNob3VsZCB0aGUgYWN0aXZlIHBhdHRlcm4gbG9vcD9cclxuICByZXBlYXQ/OiBib29sZWFuO1xyXG5cclxuICBzaGFycG5lc3M/OiAxO1xyXG4gIGludGVuc2l0eT86IDE7XHJcblxyXG4gIC8vIEluaXRpYWwgcGF0dGVybiBmb3IgdGhlIHZpYnJhdGlvbiBjb250cm9sbGVyLCBhIHNlcXVlbmNlIG9mIG9uL29mZiBpbnRlcnZhbHMgaW4gc2Vjb25kcyAtIHdvbid0IHN0YXJ0IHZpYnJhdGluZ1xyXG4gIC8vIHVudGlsIGNhbGxpbmcgc3RhcnQoKS5cclxuICBhY3RpdmVQYXR0ZXJuPzogbnVtYmVyW107XHJcbn07XHJcblxyXG5jbGFzcyBDb250aW51b3VzUGF0dGVyblZpYnJhdGlvbkNvbnRyb2xsZXIge1xyXG5cclxuICBwcml2YXRlIGFjdGl2ZVBhdHRlcm46IG51bWJlcltdO1xyXG4gIHByaXZhdGUgcmVwZWF0OiBib29sZWFuO1xyXG4gIHByaXZhdGUgaW50ZW5zaXR5OiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBzaGFycG5lc3M6IG51bWJlcjtcclxuXHJcbiAgLy8gc2VuZHMgcmVxdWVzdHMgdG8gdGhlIGlPUyBhcHAgdG8gYmVnaW4vc3RvcCB2aWJyYXRpb25cclxuICBwcml2YXRlIHJlYWRvbmx5IHZpYnJhdGlvbk1hbmFnZXJpT1M6IFZpYnJhdGlvbk1hbmFnZXJpT1M7XHJcblxyXG4gIC8vIGN1cnJlbnQgaW5kZXggb2YgdGhlIGFjdGl2ZSB2aWJyYXRpb24gcGF0dGVyblxyXG4gIHByaXZhdGUgcGF0dGVybkluZGV4ID0gMDtcclxuXHJcbiAgLy8gY3VycmVudCBpbnRlcnZhbCB2YWx1ZSBvZiB0aGUgYWN0aXZlIHZpYnJhdGlvbiBwYXR0ZXJuXHJcbiAgcHJpdmF0ZSBwYXR0ZXJuVmFsdWUgPSAwO1xyXG5cclxuICAvLyBjdXJyZW50IGludGVydmFsIHZhbHVlIG9mIHRoZSBhY3RpdmUgdmlicmF0aW9uIHBhdHRlcm4sIGluIHNlY29uZHNcclxuICBwcml2YXRlIHZhbHVlVGltZSA9IDA7XHJcblxyXG4gIC8vIHdoZXRoZXIgd2UgYXJlIGN1cnJlbnRseSBydW5uaW5nIHRoZSB2aWJyYXRpb24gcGF0dGVyblxyXG4gIHByaXZhdGUgcnVubmluZ1BhdHRlcm4gPSBmYWxzZTtcclxuXHJcbiAgLy8gdGhlIHBhdHRlcm4gdGhhdCB3ZSBhcmUgZ29pbmcgdG8gdHJhbnNpdGlvbiB0byBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHBhdHRlcm5cclxuICBwcml2YXRlIHBlbmRpbmdQYXR0ZXJuOiBudW1iZXJbXTtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCB2aWJyYXRpb25NYW5hZ2VyaU9TOiBWaWJyYXRpb25NYW5hZ2VyaU9TLCBwcm92aWRlZE9wdGlvbnM6IENvbnRpbnVvdXNQYXR0ZXJuVmlicmF0aW9uQ29udHJvbGxlck9wdGlvbnMgKSB7XHJcblxyXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxDb250aW51b3VzUGF0dGVyblZpYnJhdGlvbkNvbnRyb2xsZXJPcHRpb25zPigpKCB7XHJcbiAgICAgIHJlcGVhdDogdHJ1ZSxcclxuICAgICAgc2hhcnBuZXNzOiAxLFxyXG4gICAgICBpbnRlbnNpdHk6IDEsXHJcbiAgICAgIGFjdGl2ZVBhdHRlcm46IFtdXHJcbiAgICB9LCBwcm92aWRlZE9wdGlvbnMgKTtcclxuXHJcbiAgICB0aGlzLnZpYnJhdGlvbk1hbmFnZXJpT1MgPSB2aWJyYXRpb25NYW5hZ2VyaU9TO1xyXG4gICAgdGhpcy5hY3RpdmVQYXR0ZXJuID0gb3B0aW9ucy5hY3RpdmVQYXR0ZXJuO1xyXG4gICAgdGhpcy5yZXBlYXQgPSBvcHRpb25zLnJlcGVhdDtcclxuICAgIHRoaXMuaW50ZW5zaXR5ID0gb3B0aW9ucy5pbnRlbnNpdHk7XHJcbiAgICB0aGlzLnNoYXJwbmVzcyA9IG9wdGlvbnMuc2hhcnBuZXNzO1xyXG4gICAgdGhpcy5wZW5kaW5nUGF0dGVybiA9IHRoaXMuYWN0aXZlUGF0dGVybjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0ZXAgZm9yd2FyZCBpbiB0aW1lLCB1cGRhdGVzIHBhdHRlcm5zLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGVwKCBkdDogbnVtYmVyICk6IHZvaWQge1xyXG4gICAgaWYgKCB0aGlzLnJ1bm5pbmdQYXR0ZXJuICkge1xyXG4gICAgICB0aGlzLnZhbHVlVGltZSArPSBkdDtcclxuXHJcbiAgICAgIGlmICggdGhpcy52YWx1ZVRpbWUgPj0gdGhpcy5wYXR0ZXJuVmFsdWUgKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZVRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMucGF0dGVybkluZGV4Kys7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5wYXR0ZXJuSW5kZXggPCB0aGlzLmFjdGl2ZVBhdHRlcm4ubGVuZ3RoICkge1xyXG4gICAgICAgICAgdGhpcy5wYXR0ZXJuVmFsdWUgPSB0aGlzLmFjdGl2ZVBhdHRlcm5bIHRoaXMucGF0dGVybkluZGV4IF07XHJcblxyXG4gICAgICAgICAgaWYgKCB0aGlzLnBhdHRlcm5JbmRleCAlIDIgPT09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBldmVuIGluZGV4LCBpbmRpY2F0aW5nICdvbicgdGltZSBmb3IgdmlicmF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMudmlicmF0aW9uTWFuYWdlcmlPUy52aWJyYXRlQ29udGludW91cygge1xyXG4gICAgICAgICAgICAgIGludGVuc2l0eTogdGhpcy5pbnRlbnNpdHksXHJcbiAgICAgICAgICAgICAgc2hhcnBuZXNzOiB0aGlzLnNoYXJwbmVzc1xyXG4gICAgICAgICAgICB9ICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIG9kZCBpbmRleCwgaW5kaWNhdGluZyAnb2ZmJyB0aW1lIGZvciB2aWJyYXRpb25cclxuICAgICAgICAgICAgdGhpcy52aWJyYXRpb25NYW5hZ2VyaU9TLnN0b3AoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIHRoaXMucmVwZWF0ICkge1xyXG5cclxuICAgICAgICAgIC8vIGJlZm9yZSBsb29waW5nIHRoZSBwYXR0ZXJuLCBjaGVjayB0byBzZWUgaWYgdGhlIHBhdHRlcm4gaGFzIGNoYW5nZWRcclxuICAgICAgICAgIGlmICggIV8uaXNFcXVhbCggdGhpcy5wZW5kaW5nUGF0dGVybiwgdGhpcy5hY3RpdmVQYXR0ZXJuICkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3QWN0aXZlUGF0dGVybiggdGhpcy5wZW5kaW5nUGF0dGVybiApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHJlc3RhcnQgdGhlIHBhdHRlcm4sIGFuZCBzdGFydCBhZ2FpbiBmcm9tIHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gbm90IGxvb3BpbmcsIHN0b3AgdmlicmF0aW9uIGF0IGVuZCBvZiBwYXR0ZXJuXHJcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zaXRpb24gZnJvbSB0aGUgcHJldmlvdXMgcGF0dGVybiB0byB0aGUgbmV4dCBwYXR0ZXJuLCB3aGljaCB3aWxsIHN0YXJ0IHRvIHBsYXkgd2hlbiBzdGFydCgpIGlzIGNhbGxlZC5cclxuICAgKi9cclxuICBwdWJsaWMgc2V0TmV3QWN0aXZlUGF0dGVybiggcGF0dGVybjogbnVtYmVyW10gKTogdm9pZCB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwYXR0ZXJuLmxlbmd0aCA+IDAsICdwYXR0ZXJuIG11c3QgaGF2ZSBzb21lIGxlbmd0aCcgKTtcclxuICAgIHRoaXMuYWN0aXZlUGF0dGVybiA9IHBhdHRlcm47XHJcblxyXG4gICAgLy8gcmVzZXQgdmFyaWFibGVzIHRyYWNraW5nIHdoZXJlIHdlIGFyZSBydW5uaW5nIHRoZSBwYXR0ZXJuLCB3ZSB3aWxsIHN0YXJ0IG92ZXIgd2hlbiB3ZSBzZXQgYSBuZXcgYWN0aXZlIHBhdHRlcm5cclxuICAgIHRoaXMucmVzZXRQYXR0ZXJuKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIG5ldyBwYXR0ZXJuIGZvciB0aGUgY29udHJvbGxlci4gSWYgd2UgYXJlIHJ1bm5pbmcsIHRoaXMgd2lsbCBiZSB0aGUgcGVuZGluZyBwYXR0ZXJuXHJcbiAgICogd2hpY2ggd2Ugd2lsbCByZXF1ZXN0IGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgcGF0dGVybiB0byBhdm9pZCBzdHV0dGVyIGR1cmluZyByYXBpZCBjaGFuZ2VzLlxyXG4gICAqIElmIGEgcGF0dGVybiBpcyBub3QgcnVubmluZywgdGhpcyB3aWxsIGJlIHNldCBhcyB0aGUgYWN0aXZlIHBhdHRlcm4gcmlnaHQgYXdheSwgYW5kIGNhbiBiZWdpblxyXG4gICAqIGFzcyBzb29uIGFzIHN0YXJ0KCkgaXMgY2FsbGVkLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRQYXR0ZXJuKCBwYXR0ZXJuOiBudW1iZXJbXSApOiB2b2lkIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHBhdHRlcm4ubGVuZ3RoID4gMCwgJ3BhdHRlcm4gbXVzdCBoYXZlIHNvbWUgdmFsdWVzJyApO1xyXG4gICAgdGhpcy5wZW5kaW5nUGF0dGVybiA9IHBhdHRlcm47XHJcblxyXG4gICAgaWYgKCAhdGhpcy5ydW5uaW5nUGF0dGVybiApIHtcclxuICAgICAgdGhpcy5zZXROZXdBY3RpdmVQYXR0ZXJuKCB0aGlzLnBlbmRpbmdQYXR0ZXJuICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIGludGVuc2l0eSBmb3IgdGhlIHZpYnJhdGlvbiBwYXR0ZXJuLCBmb3IgYm90aCB0aGUgYWN0aXZlIGFuZCBwZW5kaW5nIHBhdHRlcm5zLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRJbnRlbnNpdHkoIGludGVuc2l0eTogbnVtYmVyICk6IHZvaWQge1xyXG4gICAgdGhpcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHNoYXJwbmVzcyBmb3IgdGhlIHZpYnJhdGlvbiBwYXR0ZXJuLCBmb3IgYm90aCB0aGUgYWN0aXZlIGFuZCBwZW5kaW5nIHBhdHRlcm5zLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRTaGFycG5lc3MoIHNoYXJwbmVzczogbnVtYmVyICk6IHZvaWQge1xyXG4gICAgdGhpcy5zaGFycG5lc3MgPSBzaGFycG5lc3M7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgd2hldGhlciBvciBub3QgdGhlIGFjdGl2ZSBwYXR0ZXJuIHdpbGwgcmVwZWF0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRSZXBlYXQoIHJlcGVhdDogYm9vbGVhbiApOiB2b2lkIHtcclxuICAgIHRoaXMucmVwZWF0ID0gcmVwZWF0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdmlicmF0aW5nIHdpdGggdGhlIGFjdGl2ZSBwYXR0ZXJuLiBDYWxsaW5nIHRoaXMgd2lsbCByZXNldCB3aGVyZSB3ZSBhcmUgaW4gdGhlIGFjdGl2ZSB2aWJyYXRpb24gcGF0dGVybi5cclxuICAgKi9cclxuICBwdWJsaWMgc3RhcnQoKTogdm9pZCB7XHJcblxyXG4gICAgdGhpcy5ydW5uaW5nUGF0dGVybiA9IHRydWU7XHJcbiAgICB0aGlzLnJlc2V0UGF0dGVybigpO1xyXG5cclxuICAgIHRoaXMudmlicmF0aW9uTWFuYWdlcmlPUy52aWJyYXRlQ29udGludW91cygge1xyXG4gICAgICBpbnRlbnNpdHk6IHRoaXMuaW50ZW5zaXR5LFxyXG4gICAgICBzaGFycG5lc3M6IHRoaXMuc2hhcnBuZXNzXHJcbiAgICB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIGFsbCB2aWJyYXRpb24gYW5kIHBsYXkgb2YgdGhlIGFjdGl2ZSBwYXR0ZXJuIGlmIHdlIGFyZSBydW5uaW5nLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdG9wKCk6IHZvaWQge1xyXG4gICAgaWYgKCB0aGlzLnJ1bm5pbmdQYXR0ZXJuICkge1xyXG4gICAgICB0aGlzLnZpYnJhdGlvbk1hbmFnZXJpT1Muc3RvcCgpO1xyXG4gICAgICB0aGlzLnJ1bm5pbmdQYXR0ZXJuID0gZmFsc2U7XHJcbiAgICAgIHRoaXMucmVzZXRQYXR0ZXJuKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldCB0aGUgYWN0aXZlIHBhdHRlcm4sIGFuZCB3aGVyZSB3ZSBhcmUgaW4gaXRzIHBsYXl0aHJvdWdoLlxyXG4gICAqL1xyXG4gIHB1YmxpYyByZXNldFBhdHRlcm4oKTogdm9pZCB7XHJcbiAgICB0aGlzLnBhdHRlcm5JbmRleCA9IDA7XHJcbiAgICB0aGlzLnBhdHRlcm5WYWx1ZSA9IHRoaXMuYWN0aXZlUGF0dGVyblsgdGhpcy5wYXR0ZXJuSW5kZXggXTtcclxuICAgIHRoaXMudmFsdWVUaW1lID0gMDtcclxuICB9XHJcbn1cclxuXHJcbnRhcHBpLnJlZ2lzdGVyKCAnQ29udGludW91c1BhdHRlcm5WaWJyYXRpb25Db250cm9sbGVyJywgQ29udGludW91c1BhdHRlcm5WaWJyYXRpb25Db250cm9sbGVyICk7XHJcbmV4cG9ydCBkZWZhdWx0IENvbnRpbnVvdXNQYXR0ZXJuVmlicmF0aW9uQ29udHJvbGxlcjsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsU0FBUyxNQUFNLGlDQUFpQztBQUN2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