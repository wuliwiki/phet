// Copyright 2014-2023, University of Colorado Boulder

/**
 * View for the Velocity Sensor tool. Measures the velocity at the sensor's tip and shows it in the display box.
 * Also points a blue arrow along the direction of the velocity and the arrow length is proportional to the velocity.
 * Supports metric and english units.
 *
 * @author Siddhartha Chinthapally (Actual Concepts)
 */

import Multilink from '../../../../axon/js/Multilink.js';
import Bounds2 from '../../../../dot/js/Bounds2.js';
import Utils from '../../../../dot/js/Utils.js';
import { Shape } from '../../../../kite/js/imports.js';
import merge from '../../../../phet-core/js/merge.js';
import ArrowShape from '../../../../scenery-phet/js/ArrowShape.js';
import MathSymbols from '../../../../scenery-phet/js/MathSymbols.js';
import PhetFont from '../../../../scenery-phet/js/PhetFont.js';
import { DragListener, LinearGradient, Node, Path, Rectangle, Text } from '../../../../scenery/js/imports.js';
import Property from '../../../../axon/js/Property.js';
import fluidPressureAndFlow from '../../fluidPressureAndFlow.js';
import FluidPressureAndFlowStrings from '../../FluidPressureAndFlowStrings.js';
const ftPerSString = FluidPressureAndFlowStrings.ftPerS;
const mPerSString = FluidPressureAndFlowStrings.mPerS;
const speedString = FluidPressureAndFlowStrings.speed;
class VelocitySensorNode extends Node {
  /**
   * @param {ModelViewTransform2} modelViewTransform , Transform between model and view coordinate frames
   * @param {VelocitySensor} velocitySensor - model for the velocity sensor
   * @param {Property.<string>} measureUnitsProperty -- english/metric
   * @param {Property[]} linkedProperties - the set of properties which affect the sensor value
   * @param {Function} getVelocityAt - function to be called to get the velocity at the given model coords
   * @param {Bounds2} containerBounds - bounds of container for all velocity sensors, needed to reset to initial position
   * @param {Bounds2} dragBounds - bounds that define where the sensor may be dragged
   * @param {Object} [options] that can be passed to the underlying node
   */
  constructor(modelViewTransform, velocitySensor, measureUnitsProperty, linkedProperties, getVelocityAt, containerBounds, dragBounds, options) {
    options = merge({
      scale: 1,
      isIcon: false,
      // if just using as an icon, don't add listeners to it and whatnot
      initialPosition: null // TODO figure out a better way to reset the velocitySensor to have the position of the icon
    }, options);
    super({
      cursor: 'pointer',
      pickable: true
    });
    this.options = options; // @private
    this.velocitySensor = velocitySensor; // @private

    const rectangleWidth = 100;
    const rectangleHeight = 56;

    // adding outer rectangle
    const outerRectangle = new Rectangle(0, 0, rectangleWidth, rectangleHeight, 10, 10, {
      stroke: new LinearGradient(0, 0, 0, rectangleHeight).addColorStop(0, '#FFAD73').addColorStop(0.6, '#893D11'),
      fill: new LinearGradient(0, 0, 0, rectangleHeight).addColorStop(0, '#FFAD73').addColorStop(0.6, '#893D11')
    });
    this.addChild(outerRectangle);

    // second rectangle
    const innerRectangle = new Rectangle(2, 2, rectangleWidth - 4, rectangleHeight - 4, 10, 10, {
      fill: '#C5631E'
    });
    this.addChild(innerRectangle);

    // adding velocity meter title text
    const titleText = new Text(speedString, {
      fill: 'black',
      font: new PhetFont({
        size: 16,
        weight: 'normal'
      }),
      centerX: innerRectangle.centerX,
      top: innerRectangle.top + 2
    });
    this.addChild(titleText);

    // adding inner rectangle
    const innerMostRectangle = new Rectangle(10, 0, rectangleWidth - 30, rectangleHeight - 38, 5, 5, {
      stroke: 'white',
      lineWidth: 1,
      fill: '#ffffff',
      centerX: innerRectangle.centerX,
      top: titleText.bottom + 2
    });
    this.addChild(innerMostRectangle);

    // adding velocity measure label
    const labelText = new Text('', {
      fill: 'black',
      font: new PhetFont({
        size: 12,
        weight: 'bold'
      }),
      center: innerMostRectangle.center
    });
    this.addChild(labelText);
    const triangleWidth = 30;
    const triangleHeight = 16;

    // adding bottom triangle shape
    const outerTriangleShapeNode = new Path(new Shape().moveTo(innerRectangle.centerX - triangleWidth / 2, innerMostRectangle.rectY + 1).lineTo(innerRectangle.centerX, triangleHeight + innerMostRectangle.rectY + 1).lineTo(innerRectangle.centerX + triangleWidth / 2, innerMostRectangle.rectY + 1), {
      fill: new LinearGradient(0, 0, 0, 2 * rectangleHeight).addColorStop(0.0, '#FFAD73').addColorStop(0.1, '#C5631E'),
      top: outerRectangle.bottom - 1,
      stroke: '#8D4716'
    });
    this.addChild(outerTriangleShapeNode);
    const innerTriangleShapeNode = new Path(new Shape().moveTo(innerRectangle.centerX + 8 - triangleWidth / 2, innerMostRectangle.rectY + 1).lineTo(innerRectangle.centerX + 5, triangleHeight + innerMostRectangle.rectY - 4).lineTo(innerRectangle.centerX + triangleWidth / 2, innerMostRectangle.rectY + 1), {
      fill: '#C5631E',
      center: outerTriangleShapeNode.center,
      stroke: '#C5631E'
    });
    this.addChild(innerTriangleShapeNode);

    // arrow shape
    const arrowWidth = 6;
    this.arrowShape = new Path(new ArrowShape(0, 0, modelViewTransform.modelToViewDeltaX(velocitySensor.valueProperty.value.x), modelViewTransform.modelToViewDeltaY(velocitySensor.valueProperty.value.y)), {
      fill: 'blue'
    });
    this.addChild(this.arrowShape);
    velocitySensor.valueProperty.link(velocity => {
      this.arrowShape.setShape(new ArrowShape(0, 0, modelViewTransform.modelToViewDeltaX(velocitySensor.valueProperty.value.x), modelViewTransform.modelToViewDeltaY(velocitySensor.valueProperty.value.y), {
        tailWidth: arrowWidth,
        headWidth: 2 * arrowWidth,
        headHeight: 2 * arrowWidth
      }));

      // set the arrowShape path position so that the center of the tail coincides with the tip of the sensor
      if (this.arrowShape.bounds.isFinite()) {
        // if the velocity y component is positive then the arrow will face up,
        // so set the bottom of the arrow to the tip of the sensor
        if (velocity.y >= 0) {
          this.arrowShape.bottom = outerTriangleShapeNode.bottom + arrowWidth / 2 * Math.cos(Math.abs(velocity.angle));
        } else {
          // if the velocity y component is negative then the arrow will face down,
          // so set the top of the arrow to the tip of the sensor
          this.arrowShape.top = outerTriangleShapeNode.bottom - arrowWidth / 2 * Math.cos(Math.abs(velocity.angle));
        }

        // if the velocity x component is positive then the arrow will direct towards right
        // so set the left of the arrow to the tip of the sensor
        if (velocity.x > 0) {
          this.arrowShape.left = outerRectangle.centerX - arrowWidth / 2 * Math.sin(Math.abs(velocity.angle));
        } else if (velocity.x === 0) {
          this.arrowShape.left = outerRectangle.centerX - arrowWidth;
        } else {
          this.arrowShape.right = outerRectangle.centerX + arrowWidth / 2 * Math.sin(Math.abs(velocity.angle));
        }
      }
    });
    velocitySensor.isArrowVisibleProperty.linkAttribute(this.arrowShape, 'visible');
    const speedMeterDragBounds = dragBounds.withMaxX(dragBounds.maxX - rectangleWidth * options.scale);

    // @public - drag handler
    this.dragListener = new DragListener({
      positionProperty: velocitySensor.positionProperty,
      dragBoundsProperty: new Property(speedMeterDragBounds),
      useParentOffset: true,
      start: () => {
        this.moveToFront();
      },
      end: () => {
        // check intersection only with the outer rectangle.
        // Add a 5px tolerance. See https://github.com/phetsims/fluid-pressure-and-flow/issues/105
        if (containerBounds.intersectsBounds(Bounds2.rect(velocitySensor.positionProperty.value.x, velocitySensor.positionProperty.value.y, rectangleWidth, rectangleHeight).eroded(5))) {
          if (options.initialPosition) {
            velocitySensor.positionProperty.value = options.initialPosition;
            this.visible = false; // TODO does this want to be in all cases, not just for toolbox?
          } else {
            velocitySensor.positionProperty.reset();
          }
          this.moveToBack();
        }
      }
    });
    !options.isIcon && this.addInputListener(this.dragListener);
    velocitySensor.positionProperty.linkAttribute(this, 'translation');

    // update the value of the
    //TODO this listener is a little dangerous, signature relies on order of concat
    Multilink.multilink([velocitySensor.positionProperty].concat(linkedProperties), position => {
      velocitySensor.valueProperty.value = getVelocityAt(modelViewTransform.viewToModelX(position.x + rectangleWidth / 2 * options.scale), modelViewTransform.viewToModelY(position.y + (rectangleHeight + triangleHeight) * options.scale));
    });

    // Update the text when the value or units changes.
    // TODO is the positionProperty needed in this multilink?
    Multilink.multilink([velocitySensor.valueProperty, measureUnitsProperty, velocitySensor.positionProperty], (velocity, units, position) => {
      if (velocitySensor.positionProperty.initialValue.equals(position)) {
        labelText.string = MathSymbols.NO_VALUE;
      } else {
        labelText.string = units === 'metric' ? `${Utils.toFixed(velocity.magnitude, 1)} ${mPerSString}` : `${Utils.toFixed(velocity.magnitude * 3.28, 1)} ${ftPerSString}`;
      }
      labelText.center = innerMostRectangle.center;
    });
    velocitySensor.updateEmitter.addListener(() => {
      velocitySensor.valueProperty.value = getVelocityAt(modelViewTransform.viewToModelX(velocitySensor.positionProperty.value.x + rectangleWidth / 2 * options.scale), modelViewTransform.viewToModelY(velocitySensor.positionProperty.value.y + (rectangleHeight + triangleHeight) * options.scale));
    });

    // for visually inspecting the touch area
    this.touchArea = this.localBounds;
    this.mutate(options);
  }
}
fluidPressureAndFlow.register('VelocitySensorNode', VelocitySensorNode);
export default VelocitySensorNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNdWx0aWxpbmsiLCJCb3VuZHMyIiwiVXRpbHMiLCJTaGFwZSIsIm1lcmdlIiwiQXJyb3dTaGFwZSIsIk1hdGhTeW1ib2xzIiwiUGhldEZvbnQiLCJEcmFnTGlzdGVuZXIiLCJMaW5lYXJHcmFkaWVudCIsIk5vZGUiLCJQYXRoIiwiUmVjdGFuZ2xlIiwiVGV4dCIsIlByb3BlcnR5IiwiZmx1aWRQcmVzc3VyZUFuZEZsb3ciLCJGbHVpZFByZXNzdXJlQW5kRmxvd1N0cmluZ3MiLCJmdFBlclNTdHJpbmciLCJmdFBlclMiLCJtUGVyU1N0cmluZyIsIm1QZXJTIiwic3BlZWRTdHJpbmciLCJzcGVlZCIsIlZlbG9jaXR5U2Vuc29yTm9kZSIsImNvbnN0cnVjdG9yIiwibW9kZWxWaWV3VHJhbnNmb3JtIiwidmVsb2NpdHlTZW5zb3IiLCJtZWFzdXJlVW5pdHNQcm9wZXJ0eSIsImxpbmtlZFByb3BlcnRpZXMiLCJnZXRWZWxvY2l0eUF0IiwiY29udGFpbmVyQm91bmRzIiwiZHJhZ0JvdW5kcyIsIm9wdGlvbnMiLCJzY2FsZSIsImlzSWNvbiIsImluaXRpYWxQb3NpdGlvbiIsImN1cnNvciIsInBpY2thYmxlIiwicmVjdGFuZ2xlV2lkdGgiLCJyZWN0YW5nbGVIZWlnaHQiLCJvdXRlclJlY3RhbmdsZSIsInN0cm9rZSIsImFkZENvbG9yU3RvcCIsImZpbGwiLCJhZGRDaGlsZCIsImlubmVyUmVjdGFuZ2xlIiwidGl0bGVUZXh0IiwiZm9udCIsInNpemUiLCJ3ZWlnaHQiLCJjZW50ZXJYIiwidG9wIiwiaW5uZXJNb3N0UmVjdGFuZ2xlIiwibGluZVdpZHRoIiwiYm90dG9tIiwibGFiZWxUZXh0IiwiY2VudGVyIiwidHJpYW5nbGVXaWR0aCIsInRyaWFuZ2xlSGVpZ2h0Iiwib3V0ZXJUcmlhbmdsZVNoYXBlTm9kZSIsIm1vdmVUbyIsInJlY3RZIiwibGluZVRvIiwiaW5uZXJUcmlhbmdsZVNoYXBlTm9kZSIsImFycm93V2lkdGgiLCJhcnJvd1NoYXBlIiwibW9kZWxUb1ZpZXdEZWx0YVgiLCJ2YWx1ZVByb3BlcnR5IiwidmFsdWUiLCJ4IiwibW9kZWxUb1ZpZXdEZWx0YVkiLCJ5IiwibGluayIsInZlbG9jaXR5Iiwic2V0U2hhcGUiLCJ0YWlsV2lkdGgiLCJoZWFkV2lkdGgiLCJoZWFkSGVpZ2h0IiwiYm91bmRzIiwiaXNGaW5pdGUiLCJNYXRoIiwiY29zIiwiYWJzIiwiYW5nbGUiLCJsZWZ0Iiwic2luIiwicmlnaHQiLCJpc0Fycm93VmlzaWJsZVByb3BlcnR5IiwibGlua0F0dHJpYnV0ZSIsInNwZWVkTWV0ZXJEcmFnQm91bmRzIiwid2l0aE1heFgiLCJtYXhYIiwiZHJhZ0xpc3RlbmVyIiwicG9zaXRpb25Qcm9wZXJ0eSIsImRyYWdCb3VuZHNQcm9wZXJ0eSIsInVzZVBhcmVudE9mZnNldCIsInN0YXJ0IiwibW92ZVRvRnJvbnQiLCJlbmQiLCJpbnRlcnNlY3RzQm91bmRzIiwicmVjdCIsImVyb2RlZCIsInZpc2libGUiLCJyZXNldCIsIm1vdmVUb0JhY2siLCJhZGRJbnB1dExpc3RlbmVyIiwibXVsdGlsaW5rIiwiY29uY2F0IiwicG9zaXRpb24iLCJ2aWV3VG9Nb2RlbFgiLCJ2aWV3VG9Nb2RlbFkiLCJ1bml0cyIsImluaXRpYWxWYWx1ZSIsImVxdWFscyIsInN0cmluZyIsIk5PX1ZBTFVFIiwidG9GaXhlZCIsIm1hZ25pdHVkZSIsInVwZGF0ZUVtaXR0ZXIiLCJhZGRMaXN0ZW5lciIsInRvdWNoQXJlYSIsImxvY2FsQm91bmRzIiwibXV0YXRlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJWZWxvY2l0eVNlbnNvck5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTQtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVmlldyBmb3IgdGhlIFZlbG9jaXR5IFNlbnNvciB0b29sLiBNZWFzdXJlcyB0aGUgdmVsb2NpdHkgYXQgdGhlIHNlbnNvcidzIHRpcCBhbmQgc2hvd3MgaXQgaW4gdGhlIGRpc3BsYXkgYm94LlxyXG4gKiBBbHNvIHBvaW50cyBhIGJsdWUgYXJyb3cgYWxvbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdmVsb2NpdHkgYW5kIHRoZSBhcnJvdyBsZW5ndGggaXMgcHJvcG9ydGlvbmFsIHRvIHRoZSB2ZWxvY2l0eS5cclxuICogU3VwcG9ydHMgbWV0cmljIGFuZCBlbmdsaXNoIHVuaXRzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNpZGRoYXJ0aGEgQ2hpbnRoYXBhbGx5IChBY3R1YWwgQ29uY2VwdHMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IE11bHRpbGluayBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL011bHRpbGluay5qcyc7XHJcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCBBcnJvd1NoYXBlIGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9BcnJvd1NoYXBlLmpzJztcclxuaW1wb3J0IE1hdGhTeW1ib2xzIGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9NYXRoU3ltYm9scy5qcyc7XHJcbmltcG9ydCBQaGV0Rm9udCBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvUGhldEZvbnQuanMnO1xyXG5pbXBvcnQgeyBEcmFnTGlzdGVuZXIsIExpbmVhckdyYWRpZW50LCBOb2RlLCBQYXRoLCBSZWN0YW5nbGUsIFRleHQgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9Qcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBmbHVpZFByZXNzdXJlQW5kRmxvdyBmcm9tICcuLi8uLi9mbHVpZFByZXNzdXJlQW5kRmxvdy5qcyc7XHJcbmltcG9ydCBGbHVpZFByZXNzdXJlQW5kRmxvd1N0cmluZ3MgZnJvbSAnLi4vLi4vRmx1aWRQcmVzc3VyZUFuZEZsb3dTdHJpbmdzLmpzJztcclxuXHJcbmNvbnN0IGZ0UGVyU1N0cmluZyA9IEZsdWlkUHJlc3N1cmVBbmRGbG93U3RyaW5ncy5mdFBlclM7XHJcbmNvbnN0IG1QZXJTU3RyaW5nID0gRmx1aWRQcmVzc3VyZUFuZEZsb3dTdHJpbmdzLm1QZXJTO1xyXG5jb25zdCBzcGVlZFN0cmluZyA9IEZsdWlkUHJlc3N1cmVBbmRGbG93U3RyaW5ncy5zcGVlZDtcclxuXHJcbmNsYXNzIFZlbG9jaXR5U2Vuc29yTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge01vZGVsVmlld1RyYW5zZm9ybTJ9IG1vZGVsVmlld1RyYW5zZm9ybSAsIFRyYW5zZm9ybSBiZXR3ZWVuIG1vZGVsIGFuZCB2aWV3IGNvb3JkaW5hdGUgZnJhbWVzXHJcbiAgICogQHBhcmFtIHtWZWxvY2l0eVNlbnNvcn0gdmVsb2NpdHlTZW5zb3IgLSBtb2RlbCBmb3IgdGhlIHZlbG9jaXR5IHNlbnNvclxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHkuPHN0cmluZz59IG1lYXN1cmVVbml0c1Byb3BlcnR5IC0tIGVuZ2xpc2gvbWV0cmljXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eVtdfSBsaW5rZWRQcm9wZXJ0aWVzIC0gdGhlIHNldCBvZiBwcm9wZXJ0aWVzIHdoaWNoIGFmZmVjdCB0aGUgc2Vuc29yIHZhbHVlXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0VmVsb2NpdHlBdCAtIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB0byBnZXQgdGhlIHZlbG9jaXR5IGF0IHRoZSBnaXZlbiBtb2RlbCBjb29yZHNcclxuICAgKiBAcGFyYW0ge0JvdW5kczJ9IGNvbnRhaW5lckJvdW5kcyAtIGJvdW5kcyBvZiBjb250YWluZXIgZm9yIGFsbCB2ZWxvY2l0eSBzZW5zb3JzLCBuZWVkZWQgdG8gcmVzZXQgdG8gaW5pdGlhbCBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSB7Qm91bmRzMn0gZHJhZ0JvdW5kcyAtIGJvdW5kcyB0aGF0IGRlZmluZSB3aGVyZSB0aGUgc2Vuc29yIG1heSBiZSBkcmFnZ2VkXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIHVuZGVybHlpbmcgbm9kZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBtb2RlbFZpZXdUcmFuc2Zvcm0sIHZlbG9jaXR5U2Vuc29yLCBtZWFzdXJlVW5pdHNQcm9wZXJ0eSwgbGlua2VkUHJvcGVydGllcyxcclxuICAgICAgICAgICAgICAgZ2V0VmVsb2NpdHlBdCwgY29udGFpbmVyQm91bmRzLCBkcmFnQm91bmRzLCBvcHRpb25zICkge1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG4gICAgICBzY2FsZTogMSxcclxuICAgICAgaXNJY29uOiBmYWxzZSwgLy8gaWYganVzdCB1c2luZyBhcyBhbiBpY29uLCBkb24ndCBhZGQgbGlzdGVuZXJzIHRvIGl0IGFuZCB3aGF0bm90XHJcbiAgICAgIGluaXRpYWxQb3NpdGlvbjogbnVsbCAvLyBUT0RPIGZpZ3VyZSBvdXQgYSBiZXR0ZXIgd2F5IHRvIHJlc2V0IHRoZSB2ZWxvY2l0eVNlbnNvciB0byBoYXZlIHRoZSBwb3NpdGlvbiBvZiB0aGUgaWNvblxyXG4gICAgfSwgb3B0aW9ucyApO1xyXG5cclxuICAgIHN1cGVyKCB7IGN1cnNvcjogJ3BvaW50ZXInLCBwaWNrYWJsZTogdHJ1ZSB9ICk7XHJcblxyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsgLy8gQHByaXZhdGVcclxuICAgIHRoaXMudmVsb2NpdHlTZW5zb3IgPSB2ZWxvY2l0eVNlbnNvcjsgLy8gQHByaXZhdGVcclxuXHJcbiAgICBjb25zdCByZWN0YW5nbGVXaWR0aCA9IDEwMDtcclxuICAgIGNvbnN0IHJlY3RhbmdsZUhlaWdodCA9IDU2O1xyXG5cclxuICAgIC8vIGFkZGluZyBvdXRlciByZWN0YW5nbGVcclxuICAgIGNvbnN0IG91dGVyUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSggMCwgMCwgcmVjdGFuZ2xlV2lkdGgsIHJlY3RhbmdsZUhlaWdodCwgMTAsIDEwLCB7XHJcbiAgICAgIHN0cm9rZTogbmV3IExpbmVhckdyYWRpZW50KCAwLCAwLCAwLCByZWN0YW5nbGVIZWlnaHQgKS5hZGRDb2xvclN0b3AoIDAsICcjRkZBRDczJyApLmFkZENvbG9yU3RvcCggMC42LFxyXG4gICAgICAgICcjODkzRDExJyApLFxyXG4gICAgICBmaWxsOiBuZXcgTGluZWFyR3JhZGllbnQoIDAsIDAsIDAsIHJlY3RhbmdsZUhlaWdodCApLmFkZENvbG9yU3RvcCggMCwgJyNGRkFENzMnICkuYWRkQ29sb3JTdG9wKCAwLjYsICcjODkzRDExJyApXHJcbiAgICB9ICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCBvdXRlclJlY3RhbmdsZSApO1xyXG5cclxuICAgIC8vIHNlY29uZCByZWN0YW5nbGVcclxuICAgIGNvbnN0IGlubmVyUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSggMiwgMiwgcmVjdGFuZ2xlV2lkdGggLSA0LCByZWN0YW5nbGVIZWlnaHQgLSA0LCAxMCwgMTAsIHsgZmlsbDogJyNDNTYzMUUnIH0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIGlubmVyUmVjdGFuZ2xlICk7XHJcblxyXG4gICAgLy8gYWRkaW5nIHZlbG9jaXR5IG1ldGVyIHRpdGxlIHRleHRcclxuICAgIGNvbnN0IHRpdGxlVGV4dCA9IG5ldyBUZXh0KCBzcGVlZFN0cmluZyxcclxuICAgICAge1xyXG4gICAgICAgIGZpbGw6ICdibGFjaycsXHJcbiAgICAgICAgZm9udDogbmV3IFBoZXRGb250KCB7IHNpemU6IDE2LCB3ZWlnaHQ6ICdub3JtYWwnIH0gKSxcclxuICAgICAgICBjZW50ZXJYOiBpbm5lclJlY3RhbmdsZS5jZW50ZXJYLFxyXG4gICAgICAgIHRvcDogaW5uZXJSZWN0YW5nbGUudG9wICsgMlxyXG4gICAgICB9ICk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCB0aXRsZVRleHQgKTtcclxuXHJcbiAgICAvLyBhZGRpbmcgaW5uZXIgcmVjdGFuZ2xlXHJcbiAgICBjb25zdCBpbm5lck1vc3RSZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKCAxMCwgMCwgcmVjdGFuZ2xlV2lkdGggLSAzMCwgcmVjdGFuZ2xlSGVpZ2h0IC0gMzgsIDUsIDUsXHJcbiAgICAgIHtcclxuICAgICAgICBzdHJva2U6ICd3aGl0ZScsXHJcbiAgICAgICAgbGluZVdpZHRoOiAxLFxyXG4gICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICBjZW50ZXJYOiBpbm5lclJlY3RhbmdsZS5jZW50ZXJYLFxyXG4gICAgICAgIHRvcDogdGl0bGVUZXh0LmJvdHRvbSArIDJcclxuICAgICAgfSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggaW5uZXJNb3N0UmVjdGFuZ2xlICk7XHJcblxyXG4gICAgLy8gYWRkaW5nIHZlbG9jaXR5IG1lYXN1cmUgbGFiZWxcclxuICAgIGNvbnN0IGxhYmVsVGV4dCA9IG5ldyBUZXh0KCAnJyxcclxuICAgICAgeyBmaWxsOiAnYmxhY2snLCBmb250OiBuZXcgUGhldEZvbnQoIHsgc2l6ZTogMTIsIHdlaWdodDogJ2JvbGQnIH0gKSwgY2VudGVyOiBpbm5lck1vc3RSZWN0YW5nbGUuY2VudGVyIH0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIGxhYmVsVGV4dCApO1xyXG5cclxuICAgIGNvbnN0IHRyaWFuZ2xlV2lkdGggPSAzMDtcclxuICAgIGNvbnN0IHRyaWFuZ2xlSGVpZ2h0ID0gMTY7XHJcblxyXG4gICAgLy8gYWRkaW5nIGJvdHRvbSB0cmlhbmdsZSBzaGFwZVxyXG4gICAgY29uc3Qgb3V0ZXJUcmlhbmdsZVNoYXBlTm9kZSA9IG5ldyBQYXRoKCBuZXcgU2hhcGUoKVxyXG4gICAgICAubW92ZVRvKCBpbm5lclJlY3RhbmdsZS5jZW50ZXJYIC0gdHJpYW5nbGVXaWR0aCAvIDIsIGlubmVyTW9zdFJlY3RhbmdsZS5yZWN0WSArIDEgKVxyXG4gICAgICAubGluZVRvKCBpbm5lclJlY3RhbmdsZS5jZW50ZXJYLCB0cmlhbmdsZUhlaWdodCArIGlubmVyTW9zdFJlY3RhbmdsZS5yZWN0WSArIDEgKVxyXG4gICAgICAubGluZVRvKCBpbm5lclJlY3RhbmdsZS5jZW50ZXJYICsgdHJpYW5nbGVXaWR0aCAvIDIsIGlubmVyTW9zdFJlY3RhbmdsZS5yZWN0WSArIDEgKSwge1xyXG4gICAgICBmaWxsOiBuZXcgTGluZWFyR3JhZGllbnQoIDAsIDAsIDAsIDIgKiByZWN0YW5nbGVIZWlnaHQgKVxyXG4gICAgICAgIC5hZGRDb2xvclN0b3AoIDAuMCwgJyNGRkFENzMnICkuYWRkQ29sb3JTdG9wKCAwLjEsICcjQzU2MzFFJyApLCB0b3A6IG91dGVyUmVjdGFuZ2xlLmJvdHRvbSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSwgc3Ryb2tlOiAnIzhENDcxNidcclxuICAgIH0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIG91dGVyVHJpYW5nbGVTaGFwZU5vZGUgKTtcclxuXHJcbiAgICBjb25zdCBpbm5lclRyaWFuZ2xlU2hhcGVOb2RlID0gbmV3IFBhdGgoIG5ldyBTaGFwZSgpXHJcbiAgICAgIC5tb3ZlVG8oIGlubmVyUmVjdGFuZ2xlLmNlbnRlclggKyA4IC0gKCAoIHRyaWFuZ2xlV2lkdGggKSAvIDIgKSwgaW5uZXJNb3N0UmVjdGFuZ2xlLnJlY3RZICsgMSApXHJcbiAgICAgIC5saW5lVG8oIGlubmVyUmVjdGFuZ2xlLmNlbnRlclggKyA1LCAoIHRyaWFuZ2xlSGVpZ2h0ICkgKyBpbm5lck1vc3RSZWN0YW5nbGUucmVjdFkgLSA0IClcclxuICAgICAgLmxpbmVUbyggaW5uZXJSZWN0YW5nbGUuY2VudGVyWCArICggdHJpYW5nbGVXaWR0aCApIC8gMiwgaW5uZXJNb3N0UmVjdGFuZ2xlLnJlY3RZICsgMSApLCB7XHJcbiAgICAgIGZpbGw6ICcjQzU2MzFFJywgY2VudGVyOiBvdXRlclRyaWFuZ2xlU2hhcGVOb2RlLmNlbnRlciwgc3Ryb2tlOiAnI0M1NjMxRSdcclxuICAgIH0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIGlubmVyVHJpYW5nbGVTaGFwZU5vZGUgKTtcclxuXHJcbiAgICAvLyBhcnJvdyBzaGFwZVxyXG4gICAgY29uc3QgYXJyb3dXaWR0aCA9IDY7XHJcbiAgICB0aGlzLmFycm93U2hhcGUgPSBuZXcgUGF0aCggbmV3IEFycm93U2hhcGUoIDAsIDAsIG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhWCggdmVsb2NpdHlTZW5zb3IudmFsdWVQcm9wZXJ0eS52YWx1ZS54ICksXHJcbiAgICAgIG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhWSggdmVsb2NpdHlTZW5zb3IudmFsdWVQcm9wZXJ0eS52YWx1ZS55ICkgKSwgeyBmaWxsOiAnYmx1ZScgfSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggdGhpcy5hcnJvd1NoYXBlICk7XHJcblxyXG4gICAgdmVsb2NpdHlTZW5zb3IudmFsdWVQcm9wZXJ0eS5saW5rKCB2ZWxvY2l0eSA9PiB7XHJcbiAgICAgIHRoaXMuYXJyb3dTaGFwZS5zZXRTaGFwZSggbmV3IEFycm93U2hhcGUoIDAsIDAsIG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhWCggdmVsb2NpdHlTZW5zb3IudmFsdWVQcm9wZXJ0eS52YWx1ZS54ICksXHJcbiAgICAgICAgbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3RGVsdGFZKCB2ZWxvY2l0eVNlbnNvci52YWx1ZVByb3BlcnR5LnZhbHVlLnkgKSxcclxuICAgICAgICB7IHRhaWxXaWR0aDogYXJyb3dXaWR0aCwgaGVhZFdpZHRoOiAyICogYXJyb3dXaWR0aCwgaGVhZEhlaWdodDogMiAqIGFycm93V2lkdGggfSApICk7XHJcblxyXG4gICAgICAvLyBzZXQgdGhlIGFycm93U2hhcGUgcGF0aCBwb3NpdGlvbiBzbyB0aGF0IHRoZSBjZW50ZXIgb2YgdGhlIHRhaWwgY29pbmNpZGVzIHdpdGggdGhlIHRpcCBvZiB0aGUgc2Vuc29yXHJcbiAgICAgIGlmICggdGhpcy5hcnJvd1NoYXBlLmJvdW5kcy5pc0Zpbml0ZSgpICkge1xyXG4gICAgICAgIC8vIGlmIHRoZSB2ZWxvY2l0eSB5IGNvbXBvbmVudCBpcyBwb3NpdGl2ZSB0aGVuIHRoZSBhcnJvdyB3aWxsIGZhY2UgdXAsXHJcbiAgICAgICAgLy8gc28gc2V0IHRoZSBib3R0b20gb2YgdGhlIGFycm93IHRvIHRoZSB0aXAgb2YgdGhlIHNlbnNvclxyXG4gICAgICAgIGlmICggdmVsb2NpdHkueSA+PSAwICkge1xyXG4gICAgICAgICAgdGhpcy5hcnJvd1NoYXBlLmJvdHRvbSA9IG91dGVyVHJpYW5nbGVTaGFwZU5vZGUuYm90dG9tICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvd1dpZHRoIC8gMiAqIE1hdGguY29zKCBNYXRoLmFicyggdmVsb2NpdHkuYW5nbGUgKSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIC8vIGlmIHRoZSB2ZWxvY2l0eSB5IGNvbXBvbmVudCBpcyBuZWdhdGl2ZSB0aGVuIHRoZSBhcnJvdyB3aWxsIGZhY2UgZG93bixcclxuICAgICAgICAgIC8vIHNvIHNldCB0aGUgdG9wIG9mIHRoZSBhcnJvdyB0byB0aGUgdGlwIG9mIHRoZSBzZW5zb3JcclxuICAgICAgICAgIHRoaXMuYXJyb3dTaGFwZS50b3AgPSBvdXRlclRyaWFuZ2xlU2hhcGVOb2RlLmJvdHRvbSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3dXaWR0aCAvIDIgKiBNYXRoLmNvcyggTWF0aC5hYnMoIHZlbG9jaXR5LmFuZ2xlICkgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSB2ZWxvY2l0eSB4IGNvbXBvbmVudCBpcyBwb3NpdGl2ZSB0aGVuIHRoZSBhcnJvdyB3aWxsIGRpcmVjdCB0b3dhcmRzIHJpZ2h0XHJcbiAgICAgICAgLy8gc28gc2V0IHRoZSBsZWZ0IG9mIHRoZSBhcnJvdyB0byB0aGUgdGlwIG9mIHRoZSBzZW5zb3JcclxuICAgICAgICBpZiAoIHZlbG9jaXR5LnggPiAwICkge1xyXG4gICAgICAgICAgdGhpcy5hcnJvd1NoYXBlLmxlZnQgPSBvdXRlclJlY3RhbmdsZS5jZW50ZXJYIC0gYXJyb3dXaWR0aCAvIDIgKiBNYXRoLnNpbiggTWF0aC5hYnMoIHZlbG9jaXR5LmFuZ2xlICkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIHZlbG9jaXR5LnggPT09IDAgKSB7XHJcbiAgICAgICAgICB0aGlzLmFycm93U2hhcGUubGVmdCA9IG91dGVyUmVjdGFuZ2xlLmNlbnRlclggLSBhcnJvd1dpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuYXJyb3dTaGFwZS5yaWdodCA9IG91dGVyUmVjdGFuZ2xlLmNlbnRlclggKyBhcnJvd1dpZHRoIC8gMiAqIE1hdGguc2luKCBNYXRoLmFicyggdmVsb2NpdHkuYW5nbGUgKSApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxuICAgIHZlbG9jaXR5U2Vuc29yLmlzQXJyb3dWaXNpYmxlUHJvcGVydHkubGlua0F0dHJpYnV0ZSggdGhpcy5hcnJvd1NoYXBlLCAndmlzaWJsZScgKTtcclxuICAgIGNvbnN0IHNwZWVkTWV0ZXJEcmFnQm91bmRzID0gZHJhZ0JvdW5kcy53aXRoTWF4WCggZHJhZ0JvdW5kcy5tYXhYIC0gcmVjdGFuZ2xlV2lkdGggKiBvcHRpb25zLnNjYWxlICk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyAtIGRyYWcgaGFuZGxlclxyXG4gICAgdGhpcy5kcmFnTGlzdGVuZXIgPSBuZXcgRHJhZ0xpc3RlbmVyKCB7XHJcbiAgICAgICAgcG9zaXRpb25Qcm9wZXJ0eTogdmVsb2NpdHlTZW5zb3IucG9zaXRpb25Qcm9wZXJ0eSxcclxuICAgICAgICBkcmFnQm91bmRzUHJvcGVydHk6IG5ldyBQcm9wZXJ0eSggc3BlZWRNZXRlckRyYWdCb3VuZHMgKSxcclxuICAgICAgICB1c2VQYXJlbnRPZmZzZXQ6IHRydWUsXHJcbiAgICAgICAgc3RhcnQ6ICgpID0+IHtcclxuICAgICAgICAgIHRoaXMubW92ZVRvRnJvbnQoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlbmQ6ICgpID0+IHtcclxuICAgICAgICAgIC8vIGNoZWNrIGludGVyc2VjdGlvbiBvbmx5IHdpdGggdGhlIG91dGVyIHJlY3RhbmdsZS5cclxuICAgICAgICAgIC8vIEFkZCBhIDVweCB0b2xlcmFuY2UuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvZmx1aWQtcHJlc3N1cmUtYW5kLWZsb3cvaXNzdWVzLzEwNVxyXG4gICAgICAgICAgaWYgKCBjb250YWluZXJCb3VuZHMuaW50ZXJzZWN0c0JvdW5kcyggQm91bmRzMi5yZWN0KCB2ZWxvY2l0eVNlbnNvci5wb3NpdGlvblByb3BlcnR5LnZhbHVlLngsIHZlbG9jaXR5U2Vuc29yLnBvc2l0aW9uUHJvcGVydHkudmFsdWUueSxcclxuICAgICAgICAgICAgcmVjdGFuZ2xlV2lkdGgsIHJlY3RhbmdsZUhlaWdodCApLmVyb2RlZCggNSApICkgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMuaW5pdGlhbFBvc2l0aW9uICkge1xyXG4gICAgICAgICAgICAgIHZlbG9jaXR5U2Vuc29yLnBvc2l0aW9uUHJvcGVydHkudmFsdWUgPSBvcHRpb25zLmluaXRpYWxQb3NpdGlvbjtcclxuICAgICAgICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTsgLy8gVE9ETyBkb2VzIHRoaXMgd2FudCB0byBiZSBpbiBhbGwgY2FzZXMsIG5vdCBqdXN0IGZvciB0b29sYm94P1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIHZlbG9jaXR5U2Vuc29yLnBvc2l0aW9uUHJvcGVydHkucmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5tb3ZlVG9CYWNrKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9ICk7XHJcbiAgICAhb3B0aW9ucy5pc0ljb24gJiYgdGhpcy5hZGRJbnB1dExpc3RlbmVyKCB0aGlzLmRyYWdMaXN0ZW5lciApO1xyXG5cclxuICAgIHZlbG9jaXR5U2Vuc29yLnBvc2l0aW9uUHJvcGVydHkubGlua0F0dHJpYnV0ZSggdGhpcywgJ3RyYW5zbGF0aW9uJyApO1xyXG5cclxuICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgb2YgdGhlXHJcbiAgICAvL1RPRE8gdGhpcyBsaXN0ZW5lciBpcyBhIGxpdHRsZSBkYW5nZXJvdXMsIHNpZ25hdHVyZSByZWxpZXMgb24gb3JkZXIgb2YgY29uY2F0XHJcbiAgICBNdWx0aWxpbmsubXVsdGlsaW5rKCBbIHZlbG9jaXR5U2Vuc29yLnBvc2l0aW9uUHJvcGVydHkgXS5jb25jYXQoIGxpbmtlZFByb3BlcnRpZXMgKSwgcG9zaXRpb24gPT4ge1xyXG4gICAgICB2ZWxvY2l0eVNlbnNvci52YWx1ZVByb3BlcnR5LnZhbHVlID0gZ2V0VmVsb2NpdHlBdChcclxuICAgICAgICBtb2RlbFZpZXdUcmFuc2Zvcm0udmlld1RvTW9kZWxYKCBwb3NpdGlvbi54ICsgcmVjdGFuZ2xlV2lkdGggLyAyICogb3B0aW9ucy5zY2FsZSApLFxyXG4gICAgICAgIG1vZGVsVmlld1RyYW5zZm9ybS52aWV3VG9Nb2RlbFkoIHBvc2l0aW9uLnkgKyAoIHJlY3RhbmdsZUhlaWdodCArIHRyaWFuZ2xlSGVpZ2h0ICkgKiBvcHRpb25zLnNjYWxlICkgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIHRleHQgd2hlbiB0aGUgdmFsdWUgb3IgdW5pdHMgY2hhbmdlcy5cclxuICAgIC8vIFRPRE8gaXMgdGhlIHBvc2l0aW9uUHJvcGVydHkgbmVlZGVkIGluIHRoaXMgbXVsdGlsaW5rP1xyXG4gICAgTXVsdGlsaW5rLm11bHRpbGluayggWyB2ZWxvY2l0eVNlbnNvci52YWx1ZVByb3BlcnR5LCBtZWFzdXJlVW5pdHNQcm9wZXJ0eSwgdmVsb2NpdHlTZW5zb3IucG9zaXRpb25Qcm9wZXJ0eSBdLFxyXG4gICAgICAoIHZlbG9jaXR5LCB1bml0cywgcG9zaXRpb24gKSA9PiB7XHJcbiAgICAgICAgaWYgKCB2ZWxvY2l0eVNlbnNvci5wb3NpdGlvblByb3BlcnR5LmluaXRpYWxWYWx1ZS5lcXVhbHMoIHBvc2l0aW9uICkgKSB7XHJcbiAgICAgICAgICBsYWJlbFRleHQuc3RyaW5nID0gTWF0aFN5bWJvbHMuTk9fVkFMVUU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgbGFiZWxUZXh0LnN0cmluZyA9IHVuaXRzID09PSAnbWV0cmljJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke1V0aWxzLnRvRml4ZWQoIHZlbG9jaXR5Lm1hZ25pdHVkZSwgMSApfSAke21QZXJTU3RyaW5nfWAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtVdGlscy50b0ZpeGVkKCB2ZWxvY2l0eS5tYWduaXR1ZGUgKiAzLjI4LCAxICl9ICR7ZnRQZXJTU3RyaW5nfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhYmVsVGV4dC5jZW50ZXIgPSBpbm5lck1vc3RSZWN0YW5nbGUuY2VudGVyO1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgdmVsb2NpdHlTZW5zb3IudXBkYXRlRW1pdHRlci5hZGRMaXN0ZW5lciggKCkgPT4ge1xyXG4gICAgICB2ZWxvY2l0eVNlbnNvci52YWx1ZVByb3BlcnR5LnZhbHVlID0gZ2V0VmVsb2NpdHlBdChcclxuICAgICAgICBtb2RlbFZpZXdUcmFuc2Zvcm0udmlld1RvTW9kZWxYKCB2ZWxvY2l0eVNlbnNvci5wb3NpdGlvblByb3BlcnR5LnZhbHVlLnggKyByZWN0YW5nbGVXaWR0aCAvIDIgKiBvcHRpb25zLnNjYWxlICksXHJcbiAgICAgICAgbW9kZWxWaWV3VHJhbnNmb3JtLnZpZXdUb01vZGVsWSggdmVsb2NpdHlTZW5zb3IucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS55ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHJlY3RhbmdsZUhlaWdodCArIHRyaWFuZ2xlSGVpZ2h0ICkgKiBvcHRpb25zLnNjYWxlIClcclxuICAgICAgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBmb3IgdmlzdWFsbHkgaW5zcGVjdGluZyB0aGUgdG91Y2ggYXJlYVxyXG4gICAgdGhpcy50b3VjaEFyZWEgPSB0aGlzLmxvY2FsQm91bmRzO1xyXG5cclxuICAgIHRoaXMubXV0YXRlKCBvcHRpb25zICk7XHJcbiAgfVxyXG59XHJcblxyXG5mbHVpZFByZXNzdXJlQW5kRmxvdy5yZWdpc3RlciggJ1ZlbG9jaXR5U2Vuc29yTm9kZScsIFZlbG9jaXR5U2Vuc29yTm9kZSApO1xyXG5leHBvcnQgZGVmYXVsdCBWZWxvY2l0eVNlbnNvck5vZGU7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxTQUFTLE1BQU0sa0NBQWtDO0FBQ3hELE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsS0FBSyxNQUFNLDZCQUE2QjtBQUMvQyxTQUFTQyxLQUFLLFFBQVEsZ0NBQWdDO0FBQ3RELE9BQU9DLEtBQUssTUFBTSxtQ0FBbUM7QUFDckQsT0FBT0MsVUFBVSxNQUFNLDJDQUEyQztBQUNsRSxPQUFPQyxXQUFXLE1BQU0sNENBQTRDO0FBQ3BFLE9BQU9DLFFBQVEsTUFBTSx5Q0FBeUM7QUFD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