// Copyright 2013-2022, University of Colorado Boulder

/**
 * This node manages the precipitate that forms on the bottom of the beaker when the solution is saturated.
 * It assumes that the beaker is represented as a cylinder, with elliptical top and bottom.
 * Origin is at the upper-left corner of this cylinder.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */

import dotRandom from '../../../../dot/js/dotRandom.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import { Node, Rectangle } from '../../../../scenery/js/imports.js';
import molarity from '../../molarity.js';

// constants
const DEBUG_OUTPUT = false;
const PARTICLE_LENGTH = 5; // particles are square, this is the length of one side
const PARTICLES_PER_MOLE = 200; // number of particles to show per mol of saturation

class PrecipitateNode extends Node {
  /**
   * @param {MacroSolution} solution
   * @param {Dimension2} cylinderSize
   * @param {number} cylinderEndHeight
   * @param {number} maxPrecipitateAmount moles
   * @param {Tandem} tandem
   */
  constructor(solution, cylinderSize, cylinderEndHeight, maxPrecipitateAmount, tandem) {
    super({
      pickable: false,
      tandem: tandem
    });

    // Create the max number of particles that we'll need.
    const maxParticles = getNumberOfParticles(maxPrecipitateAmount);
    const particleNodes = [];
    for (let i = 0; i < maxParticles; i++) {
      particleNodes[i] = new Rectangle(0, 0, PARTICLE_LENGTH, PARTICLE_LENGTH, {
        rotation: dotRandom.nextDouble() * 2 * Math.PI
      });
      this.addChild(particleNodes[i]);
    }
    if (DEBUG_OUTPUT) {
      console.log(`PrecipitateNode: ${Utils.toFixed(maxPrecipitateAmount, 4)} mol => ${maxParticles} particles (max)`);
    }

    // Change color of all particles to match the solute, change position so it doesn't look predictable
    solution.soluteProperty.link(solute => {
      const fill = solute.particleColor;
      const stroke = solute.particleColor.darkerColor();
      particleNodes.forEach(node => {
        node.fill = fill;
        node.stroke = stroke;
        node.translation = getRandomOffset(node.width, node.height, cylinderSize, cylinderEndHeight);
      });
    });

    // Make particles visible to match the amount of precipitate.
    solution.precipitateAmountProperty.link(precipitateAmount => {
      const numberOfParticles = getNumberOfParticles(precipitateAmount);
      assert && assert(numberOfParticles <= particleNodes.length);
      for (let i = 0; i < particleNodes.length; i++) {
        particleNodes[i].visible = i < numberOfParticles;
      }
      if (DEBUG_OUTPUT) {
        console.log(`PrecipitateNode: ${Utils.toFixed(precipitateAmount, 4)} mol => ${numberOfParticles} particles`);
      }
    });
  }
}
molarity.register('PrecipitateNode', PrecipitateNode);

// Gets the number of particles that corresponds to some precipitate amount.
const getNumberOfParticles = precipitateAmount => {
  let numberOfParticles = Math.floor(PARTICLES_PER_MOLE * precipitateAmount);
  if (numberOfParticles === 0 && precipitateAmount > 0) {
    numberOfParticles = 1;
  }
  return numberOfParticles;
};

// Gets a random offset for a particle on the bottom of the beaker (which is an ellipse).
const getRandomOffset = (particleWidth, particleHeight, cylinderSize, cylinderEndHeight) => {
  const xMargin = particleWidth;
  const yMargin = particleHeight;
  const angle = dotRandom.nextDouble() * 2 * Math.PI;
  const p = getRandomPointInsideEllipse(angle, cylinderSize.width - 2 * xMargin, cylinderEndHeight - 2 * yMargin);
  const x = cylinderSize.width / 2 + p.x;
  const y = cylinderSize.height - p.y - yMargin / 2;
  return new Vector2(x, y);
};

// Gets a random point inside an ellipse, with origin at its center.
const getRandomPointInsideEllipse = (theta, width, height) => {
  // Generate a random point inside a circle of radius 1.
  // Since circle area is a function of radius^2, taking sqrt provides a uniform distribution.
  const x = Math.sqrt(dotRandom.nextDouble()) * Math.cos(theta);
  const y = Math.sqrt(dotRandom.nextDouble()) * Math.sin(theta);

  // Scale x and y to the dimensions of the ellipse
  return new Vector2(x * width / 2, y * height / 2);
};
export default PrecipitateNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3RSYW5kb20iLCJVdGlscyIsIlZlY3RvcjIiLCJOb2RlIiwiUmVjdGFuZ2xlIiwibW9sYXJpdHkiLCJERUJVR19PVVRQVVQiLCJQQVJUSUNMRV9MRU5HVEgiLCJQQVJUSUNMRVNfUEVSX01PTEUiLCJQcmVjaXBpdGF0ZU5vZGUiLCJjb25zdHJ1Y3RvciIsInNvbHV0aW9uIiwiY3lsaW5kZXJTaXplIiwiY3lsaW5kZXJFbmRIZWlnaHQiLCJtYXhQcmVjaXBpdGF0ZUFtb3VudCIsInRhbmRlbSIsInBpY2thYmxlIiwibWF4UGFydGljbGVzIiwiZ2V0TnVtYmVyT2ZQYXJ0aWNsZXMiLCJwYXJ0aWNsZU5vZGVzIiwiaSIsInJvdGF0aW9uIiwibmV4dERvdWJsZSIsIk1hdGgiLCJQSSIsImFkZENoaWxkIiwiY29uc29sZSIsImxvZyIsInRvRml4ZWQiLCJzb2x1dGVQcm9wZXJ0eSIsImxpbmsiLCJzb2x1dGUiLCJmaWxsIiwicGFydGljbGVDb2xvciIsInN0cm9rZSIsImRhcmtlckNvbG9yIiwiZm9yRWFjaCIsIm5vZGUiLCJ0cmFuc2xhdGlvbiIsImdldFJhbmRvbU9mZnNldCIsIndpZHRoIiwiaGVpZ2h0IiwicHJlY2lwaXRhdGVBbW91bnRQcm9wZXJ0eSIsInByZWNpcGl0YXRlQW1vdW50IiwibnVtYmVyT2ZQYXJ0aWNsZXMiLCJhc3NlcnQiLCJsZW5ndGgiLCJ2aXNpYmxlIiwicmVnaXN0ZXIiLCJmbG9vciIsInBhcnRpY2xlV2lkdGgiLCJwYXJ0aWNsZUhlaWdodCIsInhNYXJnaW4iLCJ5TWFyZ2luIiwiYW5nbGUiLCJwIiwiZ2V0UmFuZG9tUG9pbnRJbnNpZGVFbGxpcHNlIiwieCIsInkiLCJ0aGV0YSIsInNxcnQiLCJjb3MiLCJzaW4iXSwic291cmNlcyI6WyJQcmVjaXBpdGF0ZU5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTMtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVGhpcyBub2RlIG1hbmFnZXMgdGhlIHByZWNpcGl0YXRlIHRoYXQgZm9ybXMgb24gdGhlIGJvdHRvbSBvZiB0aGUgYmVha2VyIHdoZW4gdGhlIHNvbHV0aW9uIGlzIHNhdHVyYXRlZC5cclxuICogSXQgYXNzdW1lcyB0aGF0IHRoZSBiZWFrZXIgaXMgcmVwcmVzZW50ZWQgYXMgYSBjeWxpbmRlciwgd2l0aCBlbGxpcHRpY2FsIHRvcCBhbmQgYm90dG9tLlxyXG4gKiBPcmlnaW4gaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoaXMgY3lsaW5kZXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgQ2hyaXMgTWFsbGV5IChQaXhlbFpvb20sIEluYy4pXHJcbiAqL1xyXG5cclxuaW1wb3J0IGRvdFJhbmRvbSBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvZG90UmFuZG9tLmpzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgTm9kZSwgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IG1vbGFyaXR5IGZyb20gJy4uLy4uL21vbGFyaXR5LmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBERUJVR19PVVRQVVQgPSBmYWxzZTtcclxuY29uc3QgUEFSVElDTEVfTEVOR1RIID0gNTsgLy8gcGFydGljbGVzIGFyZSBzcXVhcmUsIHRoaXMgaXMgdGhlIGxlbmd0aCBvZiBvbmUgc2lkZVxyXG5jb25zdCBQQVJUSUNMRVNfUEVSX01PTEUgPSAyMDA7IC8vIG51bWJlciBvZiBwYXJ0aWNsZXMgdG8gc2hvdyBwZXIgbW9sIG9mIHNhdHVyYXRpb25cclxuXHJcbmNsYXNzIFByZWNpcGl0YXRlTm9kZSBleHRlbmRzIE5vZGUge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7TWFjcm9Tb2x1dGlvbn0gc29sdXRpb25cclxuICAgKiBAcGFyYW0ge0RpbWVuc2lvbjJ9IGN5bGluZGVyU2l6ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjeWxpbmRlckVuZEhlaWdodFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhQcmVjaXBpdGF0ZUFtb3VudCBtb2xlc1xyXG4gICAqIEBwYXJhbSB7VGFuZGVtfSB0YW5kZW1cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvciggc29sdXRpb24sIGN5bGluZGVyU2l6ZSwgY3lsaW5kZXJFbmRIZWlnaHQsIG1heFByZWNpcGl0YXRlQW1vdW50LCB0YW5kZW0gKSB7XHJcblxyXG4gICAgc3VwZXIoIHtcclxuICAgICAgcGlja2FibGU6IGZhbHNlLFxyXG4gICAgICB0YW5kZW06IHRhbmRlbVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgbWF4IG51bWJlciBvZiBwYXJ0aWNsZXMgdGhhdCB3ZSdsbCBuZWVkLlxyXG4gICAgY29uc3QgbWF4UGFydGljbGVzID0gZ2V0TnVtYmVyT2ZQYXJ0aWNsZXMoIG1heFByZWNpcGl0YXRlQW1vdW50ICk7XHJcbiAgICBjb25zdCBwYXJ0aWNsZU5vZGVzID0gW107XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBtYXhQYXJ0aWNsZXM7IGkrKyApIHtcclxuICAgICAgcGFydGljbGVOb2Rlc1sgaSBdID0gbmV3IFJlY3RhbmdsZSggMCwgMCwgUEFSVElDTEVfTEVOR1RILCBQQVJUSUNMRV9MRU5HVEgsIHtcclxuICAgICAgICByb3RhdGlvbjogZG90UmFuZG9tLm5leHREb3VibGUoKSAqIDIgKiBNYXRoLlBJXHJcbiAgICAgIH0gKTtcclxuICAgICAgdGhpcy5hZGRDaGlsZCggcGFydGljbGVOb2Rlc1sgaSBdICk7XHJcbiAgICB9XHJcbiAgICBpZiAoIERFQlVHX09VVFBVVCApIHtcclxuICAgICAgY29uc29sZS5sb2coIGBQcmVjaXBpdGF0ZU5vZGU6ICR7VXRpbHMudG9GaXhlZCggbWF4UHJlY2lwaXRhdGVBbW91bnQsIDQgKX0gbW9sID0+ICR7bWF4UGFydGljbGVzfSBwYXJ0aWNsZXMgKG1heClgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hhbmdlIGNvbG9yIG9mIGFsbCBwYXJ0aWNsZXMgdG8gbWF0Y2ggdGhlIHNvbHV0ZSwgY2hhbmdlIHBvc2l0aW9uIHNvIGl0IGRvZXNuJ3QgbG9vayBwcmVkaWN0YWJsZVxyXG4gICAgc29sdXRpb24uc29sdXRlUHJvcGVydHkubGluayggc29sdXRlID0+IHtcclxuICAgICAgY29uc3QgZmlsbCA9IHNvbHV0ZS5wYXJ0aWNsZUNvbG9yO1xyXG4gICAgICBjb25zdCBzdHJva2UgPSBzb2x1dGUucGFydGljbGVDb2xvci5kYXJrZXJDb2xvcigpO1xyXG4gICAgICBwYXJ0aWNsZU5vZGVzLmZvckVhY2goIG5vZGUgPT4ge1xyXG4gICAgICAgIG5vZGUuZmlsbCA9IGZpbGw7XHJcbiAgICAgICAgbm9kZS5zdHJva2UgPSBzdHJva2U7XHJcbiAgICAgICAgbm9kZS50cmFuc2xhdGlvbiA9IGdldFJhbmRvbU9mZnNldCggbm9kZS53aWR0aCwgbm9kZS5oZWlnaHQsIGN5bGluZGVyU2l6ZSwgY3lsaW5kZXJFbmRIZWlnaHQgKTtcclxuICAgICAgfSApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIE1ha2UgcGFydGljbGVzIHZpc2libGUgdG8gbWF0Y2ggdGhlIGFtb3VudCBvZiBwcmVjaXBpdGF0ZS5cclxuICAgIHNvbHV0aW9uLnByZWNpcGl0YXRlQW1vdW50UHJvcGVydHkubGluayggcHJlY2lwaXRhdGVBbW91bnQgPT4ge1xyXG4gICAgICBjb25zdCBudW1iZXJPZlBhcnRpY2xlcyA9IGdldE51bWJlck9mUGFydGljbGVzKCBwcmVjaXBpdGF0ZUFtb3VudCApO1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBudW1iZXJPZlBhcnRpY2xlcyA8PSBwYXJ0aWNsZU5vZGVzLmxlbmd0aCApO1xyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBwYXJ0aWNsZU5vZGVzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgIHBhcnRpY2xlTm9kZXNbIGkgXS52aXNpYmxlID0gKCBpIDwgbnVtYmVyT2ZQYXJ0aWNsZXMgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIERFQlVHX09VVFBVVCApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyggYFByZWNpcGl0YXRlTm9kZTogJHtVdGlscy50b0ZpeGVkKCBwcmVjaXBpdGF0ZUFtb3VudCwgNCApfSBtb2wgPT4gJHtudW1iZXJPZlBhcnRpY2xlc30gcGFydGljbGVzYCApO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2xhcml0eS5yZWdpc3RlciggJ1ByZWNpcGl0YXRlTm9kZScsIFByZWNpcGl0YXRlTm9kZSApO1xyXG5cclxuLy8gR2V0cyB0aGUgbnVtYmVyIG9mIHBhcnRpY2xlcyB0aGF0IGNvcnJlc3BvbmRzIHRvIHNvbWUgcHJlY2lwaXRhdGUgYW1vdW50LlxyXG5jb25zdCBnZXROdW1iZXJPZlBhcnRpY2xlcyA9IHByZWNpcGl0YXRlQW1vdW50ID0+IHtcclxuICBsZXQgbnVtYmVyT2ZQYXJ0aWNsZXMgPSBNYXRoLmZsb29yKCBQQVJUSUNMRVNfUEVSX01PTEUgKiBwcmVjaXBpdGF0ZUFtb3VudCApO1xyXG4gIGlmICggbnVtYmVyT2ZQYXJ0aWNsZXMgPT09IDAgJiYgcHJlY2lwaXRhdGVBbW91bnQgPiAwICkge1xyXG4gICAgbnVtYmVyT2ZQYXJ0aWNsZXMgPSAxO1xyXG4gIH1cclxuICByZXR1cm4gbnVtYmVyT2ZQYXJ0aWNsZXM7XHJcbn07XHJcblxyXG4vLyBHZXRzIGEgcmFuZG9tIG9mZnNldCBmb3IgYSBwYXJ0aWNsZSBvbiB0aGUgYm90dG9tIG9mIHRoZSBiZWFrZXIgKHdoaWNoIGlzIGFuIGVsbGlwc2UpLlxyXG5jb25zdCBnZXRSYW5kb21PZmZzZXQgPSAoIHBhcnRpY2xlV2lkdGgsIHBhcnRpY2xlSGVpZ2h0LCBjeWxpbmRlclNpemUsIGN5bGluZGVyRW5kSGVpZ2h0ICkgPT4ge1xyXG4gIGNvbnN0IHhNYXJnaW4gPSBwYXJ0aWNsZVdpZHRoO1xyXG4gIGNvbnN0IHlNYXJnaW4gPSBwYXJ0aWNsZUhlaWdodDtcclxuICBjb25zdCBhbmdsZSA9IGRvdFJhbmRvbS5uZXh0RG91YmxlKCkgKiAyICogTWF0aC5QSTtcclxuICBjb25zdCBwID0gZ2V0UmFuZG9tUG9pbnRJbnNpZGVFbGxpcHNlKCBhbmdsZSwgY3lsaW5kZXJTaXplLndpZHRoIC0gKCAyICogeE1hcmdpbiApLCBjeWxpbmRlckVuZEhlaWdodCAtICggMiAqIHlNYXJnaW4gKSApO1xyXG4gIGNvbnN0IHggPSAoIGN5bGluZGVyU2l6ZS53aWR0aCAvIDIgKSArIHAueDtcclxuICBjb25zdCB5ID0gY3lsaW5kZXJTaXplLmhlaWdodCAtIHAueSAtICggeU1hcmdpbiAvIDIgKTtcclxuICByZXR1cm4gbmV3IFZlY3RvcjIoIHgsIHkgKTtcclxufTtcclxuXHJcbi8vIEdldHMgYSByYW5kb20gcG9pbnQgaW5zaWRlIGFuIGVsbGlwc2UsIHdpdGggb3JpZ2luIGF0IGl0cyBjZW50ZXIuXHJcbmNvbnN0IGdldFJhbmRvbVBvaW50SW5zaWRlRWxsaXBzZSA9ICggdGhldGEsIHdpZHRoLCBoZWlnaHQgKSA9PiB7XHJcblxyXG4gIC8vIEdlbmVyYXRlIGEgcmFuZG9tIHBvaW50IGluc2lkZSBhIGNpcmNsZSBvZiByYWRpdXMgMS5cclxuICAvLyBTaW5jZSBjaXJjbGUgYXJlYSBpcyBhIGZ1bmN0aW9uIG9mIHJhZGl1c14yLCB0YWtpbmcgc3FydCBwcm92aWRlcyBhIHVuaWZvcm0gZGlzdHJpYnV0aW9uLlxyXG4gIGNvbnN0IHggPSBNYXRoLnNxcnQoIGRvdFJhbmRvbS5uZXh0RG91YmxlKCkgKSAqIE1hdGguY29zKCB0aGV0YSApO1xyXG4gIGNvbnN0IHkgPSBNYXRoLnNxcnQoIGRvdFJhbmRvbS5uZXh0RG91YmxlKCkgKSAqIE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuICAvLyBTY2FsZSB4IGFuZCB5IHRvIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBlbGxpcHNlXHJcbiAgcmV0dXJuIG5ldyBWZWN0b3IyKCB4ICogd2lkdGggLyAyLCB5ICogaGVpZ2h0IC8gMiApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUHJlY2lwaXRhdGVOb2RlOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsU0FBUyxNQUFNLGlDQUFpQztBQUN2RCxPQUFPQyxLQUFLLE1BQU0sNkJBQTZCO0FBQy9DLE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsU0FBU0MsSUFBSSxFQUFFQyxTQUFTLFFBQVEsbUNBQW1DO0FBQ25FLE9BQU9DLFFBQVEsTUFBTSxtQkFBbUI7O0FBRXhDO0FBQ0EsTUFBTUMsWUFBWSxHQUFHLEtBQUs7QUFDMUIsTUFBTUMsZUFBZSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzNCLE1BQU1DLGtCQUFrQixHQUFHLEdBQUcsQ0FBQyxDQUFDOztBQUVoQyxNQUFNQyxlQUFlLFNBQVNOLElBQUksQ0FBQztFQUNqQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFTyxXQUFXQSxDQUFFQyxRQUFRLEVBQUVDLFlBQVksRUFBRUMsaUJBQWlCLEVBQUVDLG9CQUFvQixFQUFFQyxNQUFNLEVBQUc7SUFFckYsS0FBSyxDQUFFO01BQ0xDLFFBQVEsRUFBRSxLQUFLO01BQ2ZELE1BQU0sRUFBRUE7SUFDVixDQUFFLENBQUM7O0lBRUg7SUFDQSxNQUFNRSxZQUFZLEdBQUdDLG9CQUFvQixDQUFFSixvQkFBcUIsQ0FBQztJQUNqRSxNQUFNSyxhQUFhLEdBQUcsRUFBRTtJQUN4QixLQUFNLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0gsWUFBWSxFQUFFRyxDQUFDLEVBQUUsRUFBRztNQUN2Q0QsYUFBYSxDQUFFQyxDQUFDLENBQUUsR0FBRyxJQUFJaEIsU0FBUyxDQUFFLENBQUMsRUFBRSxDQUFDLEVB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