// Copyright 2020-2023, University of Colorado Boulder

/**
 * A node that is a number line and that also shades the distance between number line points. The space between number
 * line points is only shaded when both point controllers are on the number line. No unlinking is required because all
 * instances of this number line are present for the lifetime of the simulation.
 *
 * @author Saurabh Totey
 */

import Multilink from '../../../../axon/js/Multilink.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import NLCConstants from '../../../../number-line-common/js/common/NLCConstants.js';
import SpatializedNumberLineNode from '../../../../number-line-common/js/common/view/SpatializedNumberLineNode.js';
import merge from '../../../../phet-core/js/merge.js';
import Orientation from '../../../../phet-core/js/Orientation.js';
import ArrowShape from '../../../../scenery-phet/js/ArrowShape.js';
import BackgroundNode from '../../../../scenery-phet/js/BackgroundNode.js';
import MathSymbolFont from '../../../../scenery-phet/js/MathSymbolFont.js';
import PhetFont from '../../../../scenery-phet/js/PhetFont.js';
import { Node, Path, RichText, Text } from '../../../../scenery/js/imports.js';
import numberLineDistance from '../../numberLineDistance.js';
import DistanceRepresentation from '../model/DistanceRepresentation.js';
import NLDConstants from '../NLDConstants.js';
const SHADING_COLOR = 'gray';
const SHADING_WIDTH = 8;
const ARROW_SHAPE_OPTIONS = {
  tailWidth: SHADING_WIDTH,
  headWidth: 20,
  headHeight: 20
};
const MAX_ARROW_HEAD_TO_ARROW_PROPORTION = 0.5;
const POINT_NAME_TEXT_OPTIONS = {
  maxWidth: 38,
  font: new MathSymbolFont(20),
  boundsMethod: 'accurate'
};
class DistanceShadedNumberLineNode extends SpatializedNumberLineNode {
  /**
   * @param {AbstractNLDBaseModel} model
   * @param {Object} [options]
   */
  constructor(model, options) {
    options = merge({
      offScaleIndicatorVerticalOffset: -120,
      offScaleIndicatorHorizontalOffset: -150,
      pointNameLabelOffsetFromHorizontalNumberLine: 37,
      pointNameLabelOffsetFromVerticalNumberLine: 45,
      distanceTextPadding: 50
    }, options);
    super(model.numberLine, options);

    // Create the Path that is the shading for the distance between point controllers.
    const distanceShadingPath = new Path(null, {
      stroke: null,
      fill: SHADING_COLOR,
      lineWidth: SHADING_WIDTH
    });
    this.addChild(distanceShadingPath);
    distanceShadingPath.moveToBack();

    // Create the distance label. maxWidth and font size determined empirically.
    const distanceText = new Text('', {
      maxWidth: 50,
      font: new PhetFont(28)
    });
    const distanceTextBackground = new BackgroundNode(distanceText, NLCConstants.LABEL_BACKGROUND_OPTIONS);
    this.addChild(distanceTextBackground);

    // Create text labels for the number line points that label them as x1, x2, y1, or y2.
    const pointNameText0 = new RichText(NLDConstants.X_1_STRING, POINT_NAME_TEXT_OPTIONS);
    const pointNameText1 = new RichText(NLDConstants.X_2_STRING, POINT_NAME_TEXT_OPTIONS);
    const pointNameBackground0 = new BackgroundNode(pointNameText0, NLCConstants.LABEL_BACKGROUND_OPTIONS);
    const pointNameBackground1 = new BackgroundNode(pointNameText1, NLCConstants.LABEL_BACKGROUND_OPTIONS);
    this.addChild(new Node({
      children: [pointNameBackground0, pointNameBackground1]
    }));
    model.pointControllerOne.isDraggingProperty.link(() => {
      pointNameBackground0.moveToFront();
    });
    model.pointControllerTwo.isDraggingProperty.link(() => {
      pointNameBackground1.moveToFront();
    });

    // Most of the number line's behaviour is handled in this multilink.
    Multilink.multilink([model.distanceLabelsVisibleProperty, model.numberLine.displayedRangeProperty, model.distanceRepresentationProperty, model.isPrimaryControllerSwappedProperty, model.numberLine.orientationProperty, model.pointValuesProperty, model.numberLine.centerPositionProperty // is only necessary for when listeners are shuffled
    ], (distanceLabelsVisible, displayedRange, distanceRepresentation, isPrimaryControllerSwapped, orientation, pointValues) => {
      // Get which strings to use for point names based on the number line orientation.
      // The strings are ordered based on isPrimaryControllerSwapped.
      const labelStrings = orientation === Orientation.VERTICAL ? [NLDConstants.Y_1_STRING, NLDConstants.Y_2_STRING] : [NLDConstants.X_1_STRING, NLDConstants.X_2_STRING];
      if (isPrimaryControllerSwapped) {
        const temp = labelStrings[0];
        labelStrings[0] = labelStrings[1];
        labelStrings[1] = temp;
      }
      pointNameText0.string = labelStrings[0];
      pointNameText1.string = labelStrings[1];
      pointNameBackground0.visible = pointValues[0] !== null && displayedRange.contains(pointValues[0]);
      pointNameBackground1.visible = pointValues[1] !== null && displayedRange.contains(pointValues[1]);

      // Position the texts.
      if (orientation === Orientation.HORIZONTAL) {
        pointNameBackground0.centerTop = model.numberLine.valueToModelPosition(pointValues[0] ? pointValues[0] : 0).plus(new Vector2(0, options.pointNameLabelOffsetFromHorizontalNumberLine));
        pointNameBackground1.centerTop = model.numberLine.valueToModelPosition(pointValues[1] ? pointValues[1] : 0).plus(new Vector2(0, options.pointNameLabelOffsetFromHorizontalNumberLine));
      } else {
        pointNameBackground0.leftCenter = model.numberLine.valueToModelPosition(pointValues[0] ? pointValues[0] : 0).plus(new Vector2(options.pointNameLabelOffsetFromVerticalNumberLine, 0));
        pointNameBackground1.leftCenter = model.numberLine.valueToModelPosition(pointValues[1] ? pointValues[1] : 0).plus(new Vector2(options.pointNameLabelOffsetFromVerticalNumberLine, 0));
      }

      // Stop here if both points aren't the number line: we cannot put any shading or distance label.
      if (!model.areBothPointControllersControllingOnNumberLine()) {
        distanceTextBackground.visible = false;
        distanceShadingPath.visible = false;
        return;
      }
      distanceTextBackground.visible = distanceLabelsVisible;
      distanceShadingPath.visible = true;

      // Get the endpoint positions in model-space of where the tips of the number line are.
      // This usually extends past the min and max values allowed on the number line because of the inset and arrows
      // on each end. The endpoint positions are needed in case a point is off the scale of the number line and the
      // shading needs to go all the way to the end of the number line.
      const insetSize = this.options.displayedRangeInset - this.options.arrowSize;
      const insetVector = model.numberLine.orientationProperty.value === Orientation.HORIZONTAL ? new Vector2(insetSize, 0) : new Vector2(0, -insetSize);
      const endPointPositionMin = model.numberLine.valueToModelPosition(displayedRange.min).minus(insetVector);
      const endPointPositionMax = model.numberLine.valueToModelPosition(displayedRange.max).plus(insetVector);

      // Get where on the number line the point controllers are.
      // We need both the number line values and their model positions for clamping purposes.
      const value0 = pointValues[0];
      const value1 = pointValues[1];
      let endPointPosition0 = model.numberLine.valueToModelPosition(value0);
      let endPointPosition1 = model.numberLine.valueToModelPosition(value1);

      // Clamp endPointPositions to be between endPointPositionMin and endPointPositionMax.
      // We cannot use Util.clamp because we are clamping when the values are out of the displayed range, but we are
      // clamping to the end point positions. For example, value0 can be greater than displayedRange.max while at the
      // same time endPointPosition0 can be less than endPointPositionMax thanks to the inset.
      if (value0 < displayedRange.min) {
        endPointPosition0 = endPointPositionMin;
      } else if (value0 > displayedRange.max) {
        endPointPosition0 = endPointPositionMax;
      }
      if (value1 < displayedRange.min) {
        endPointPosition1 = endPointPositionMin;
      } else if (value1 > displayedRange.max) {
        endPointPosition1 = endPointPositionMax;
      }

      // Make the shading shape between nodes.
      let shape = new Shape().moveToPoint(endPointPosition0).lineToPoint(endPointPosition1);
      distanceShadingPath.stroke = SHADING_COLOR;

      // Change the shading shape to an arrow if the distance type is directed and the arrow is pointing to a point
      // that is on the number line.
      if (distanceRepresentation === DistanceRepresentation.DIRECTED) {
        // Scale the arrow based on how close the point controllers are.
        // If the point controllers are too close, then the arrow might be too big and be distorted.
        // If the width of the arrow head is greater than MAX_ARROW_HEAD_TO_ARROW_PROPORTION, then the arrow is
        //  scaled down.
        // see #7
        let scale = 1;
        const arrowValueLength = Math.abs(model.numberLine.modelPositionToValue(endPointPosition1) - model.numberLine.modelPositionToValue(endPointPosition0));
        let arrowHeadValueLength = Math.abs(model.numberLine.modelPositionToValue(endPointPosition0) - model.numberLine.modelPositionToValue(new Vector2(endPointPosition0.x - ARROW_SHAPE_OPTIONS.headHeight, 0)));
        if (orientation === Orientation.VERTICAL) {
          arrowHeadValueLength = Math.abs(model.numberLine.modelPositionToValue(endPointPosition0) - model.numberLine.modelPositionToValue(new Vector2(0, endPointPosition0.y - ARROW_SHAPE_OPTIONS.headHeight)));
        }
        const headLengthToArrowLengthProportion = arrowHeadValueLength / arrowValueLength;
        if (headLengthToArrowLengthProportion > MAX_ARROW_HEAD_TO_ARROW_PROPORTION) {
          scale = MAX_ARROW_HEAD_TO_ARROW_PROPORTION / headLengthToArrowLengthProportion;
        }
        const scaledArrowShapeOptions = merge({}, ARROW_SHAPE_OPTIONS, {
          headHeight: ARROW_SHAPE_OPTIONS.headHeight * scale,
          headWidth: ARROW_SHAPE_OPTIONS.headWidth * scale,
          tailWidth: ARROW_SHAPE_OPTIONS.tailWidth * scale
        });

        // Only set the shape to the arrow shape if the point that the arrow points to is in the number line's range.
        // The stroke is removed so the tail of the arrow can have the correct width.
        if (isPrimaryControllerSwapped && displayedRange.min <= value0 && value0 <= displayedRange.max) {
          shape = new ArrowShape(endPointPosition1.x, endPointPosition1.y, endPointPosition0.x, endPointPosition0.y, scaledArrowShapeOptions);
          distanceShadingPath.stroke = null;
        } else if (!isPrimaryControllerSwapped && displayedRange.min <= value1 && value1 <= displayedRange.max) {
          shape = new ArrowShape(endPointPosition0.x, endPointPosition0.y, endPointPosition1.x, endPointPosition1.y, scaledArrowShapeOptions);
          distanceShadingPath.stroke = null;
        }
      }
      distanceShadingPath.shape = shape;

      // Calculates the difference to display.
      let displayedDifference = value1 - value0;
      if (isPrimaryControllerSwapped) {
        displayedDifference = -displayedDifference;
      }
      if (distanceRepresentation === DistanceRepresentation.ABSOLUTE) {
        displayedDifference = Math.abs(displayedDifference);
      }
      distanceText.string = `${Utils.roundSymmetric(displayedDifference)}`;

      // Position distance text.
      if (orientation === Orientation.HORIZONTAL) {
        distanceTextBackground.bottom = endPointPosition0.y - options.distanceTextPadding;
        distanceTextBackground.centerX = (endPointPosition1.x + endPointPosition0.x) / 2;
      } else {
        distanceTextBackground.right = endPointPosition0.x - options.distanceTextPadding;
        distanceTextBackground.centerY = (endPointPosition1.y + endPointPosition0.y) / 2;
      }
    });
  }
}
numberLineDistance.register('DistanceShadedNumberLineNode', DistanceShadedNumberLineNode);
export default DistanceShadedNumberLineNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNdWx0aWxpbmsiLCJVdGlscyIsIlZlY3RvcjIiLCJTaGFwZSIsIk5MQ0NvbnN0YW50cyIsIlNwYXRpYWxpemVkTnVtYmVyTGluZU5vZGUiLCJtZXJnZSIsIk9yaWVudGF0aW9uIiwiQXJyb3dTaGFwZSIsIkJhY2tncm91bmROb2RlIiwiTWF0aFN5bWJvbEZvbnQiLCJQaGV0Rm9udCIsIk5vZGUiLCJQYXRoIiwiUmljaFRleHQiLCJUZXh0IiwibnVtYmVyTGluZURpc3RhbmNlIiwiRGlzdGFuY2VSZXByZXNlbnRhdGlvbiIsIk5MRENvbnN0YW50cyIsIlNIQURJTkdfQ09MT1IiLCJTSEFESU5HX1dJRFRIIiwiQVJST1dfU0hBUEVfT1BUSU9OUyIsInRhaWxXaWR0aCIsImhlYWRXaWR0aCIsImhlYWRIZWlnaHQiLCJNQVhfQVJST1dfSEVBRF9UT19BUlJPV19QUk9QT1JUSU9OIiwiUE9JTlRfTkFNRV9URVhUX09QVElPTlMiLCJtYXhXaWR0aCIsImZvbnQiLCJib3VuZHNNZXRob2QiLCJEaXN0YW5jZVNoYWRlZE51bWJlckxpbmVOb2RlIiwiY29uc3RydWN0b3IiLCJtb2RlbCIsIm9wdGlvbnMiLCJvZmZTY2FsZUluZGljYXRvclZlcnRpY2FsT2Zmc2V0Iiwib2ZmU2NhbGVJbmRpY2F0b3JIb3Jpem9udGFsT2Zmc2V0IiwicG9pbnROYW1lTGFiZWxPZmZzZXRGcm9tSG9yaXpvbnRhbE51bWJlckxpbmUiLCJwb2ludE5hbWVMYWJlbE9mZnNldEZyb21WZXJ0aWNhbE51bWJlckxpbmUiLCJkaXN0YW5jZVRleHRQYWRkaW5nIiwibnVtYmVyTGluZSIsImRpc3RhbmNlU2hhZGluZ1BhdGgiLCJzdHJva2UiLCJmaWxsIiwibGluZVdpZHRoIiwiYWRkQ2hpbGQiLCJtb3ZlVG9CYWNrIiwiZGlzdGFuY2VUZXh0IiwiZGlzdGFuY2VUZXh0QmFja2dyb3VuZCIsIkxBQkVMX0JBQ0tHUk9VTkRfT1BUSU9OUyIsInBvaW50TmFtZVRleHQwIiwiWF8xX1NUUklORyIsInBvaW50TmFtZVRleHQxIiwiWF8yX1NUUklORyIsInBvaW50TmFtZUJhY2tncm91bmQwIiwicG9pbnROYW1lQmFja2dyb3VuZDEiLCJjaGlsZHJlbiIsInBvaW50Q29udHJvbGxlck9uZSIsImlzRHJhZ2dpbmdQcm9wZXJ0eSIsImxpbmsiLCJtb3ZlVG9Gcm9udCIsInBvaW50Q29udHJvbGxlclR3byIsIm11bHRpbGluayIsImRpc3RhbmNlTGFiZWxzVmlzaWJsZVByb3BlcnR5IiwiZGlzcGxheWVkUmFuZ2VQcm9wZXJ0eSIsImRpc3RhbmNlUmVwcmVzZW50YXRpb25Qcm9wZXJ0eSIsImlzUHJpbWFyeUNvbnRyb2xsZXJTd2FwcGVkUHJvcGVydHkiLCJvcmllbnRhdGlvblByb3BlcnR5IiwicG9pbnRWYWx1ZXNQcm9wZXJ0eSIsImNlbnRlclBvc2l0aW9uUHJvcGVydHkiLCJkaXN0YW5jZUxhYmVsc1Zpc2libGUiLCJkaXNwbGF5ZWRSYW5nZSIsImRpc3RhbmNlUmVwcmVzZW50YXRpb24iLCJpc1ByaW1hcnlDb250cm9sbGVyU3dhcHBlZCIsIm9yaWVudGF0aW9uIiwicG9pbnRWYWx1ZXMiLCJsYWJlbFN0cmluZ3MiLCJWRVJUSUNBTCIsIllfMV9TVFJJTkciLCJZXzJfU1RSSU5HIiwidGVtcCIsInN0cmluZyIsInZpc2libGUiLCJjb250YWlucyIsIkhPUklaT05UQUwiLCJjZW50ZXJUb3AiLCJ2YWx1ZVRvTW9kZWxQb3NpdGlvbiIsInBsdXMiLCJsZWZ0Q2VudGVyIiwiYXJlQm90aFBvaW50Q29udHJvbGxlcnNDb250cm9sbGluZ09uTnVtYmVyTGluZSIsImluc2V0U2l6ZSIsImRpc3BsYXllZFJhbmdlSW5zZXQiLCJhcnJvd1NpemUiLCJpbnNldFZlY3RvciIsInZhbHVlIiwiZW5kUG9pbnRQb3NpdGlvbk1pbiIsIm1pbiIsIm1pbnVzIiwiZW5kUG9pbnRQb3NpdGlvbk1heCIsIm1heCIsInZhbHVlMCIsInZhbHVlMSIsImVuZFBvaW50UG9zaXRpb24wIiwiZW5kUG9pbnRQb3NpdGlvbjEiLCJzaGFwZSIsIm1vdmVUb1BvaW50IiwibGluZVRvUG9pbnQiLCJESVJFQ1RFRCIsInNjYWxlIiwiYXJyb3dWYWx1ZUxlbmd0aCIsIk1hdGgiLCJhYnMiLCJtb2RlbFBvc2l0aW9uVG9WYWx1ZSIsImFycm93SGVhZFZhbHVlTGVuZ3RoIiwieCIsInkiLCJoZWFkTGVuZ3RoVG9BcnJvd0xlbmd0aFByb3BvcnRpb24iLCJzY2FsZWRBcnJvd1NoYXBlT3B0aW9ucyIsImRpc3BsYXllZERpZmZlcmVuY2UiLCJBQlNPTFVURSIsInJvdW5kU3ltbWV0cmljIiwiYm90dG9tIiwiY2VudGVyWCIsInJpZ2h0IiwiY2VudGVyWSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRGlzdGFuY2VTaGFkZWROdW1iZXJMaW5lTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMC0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBBIG5vZGUgdGhhdCBpcyBhIG51bWJlciBsaW5lIGFuZCB0aGF0IGFsc28gc2hhZGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIG51bWJlciBsaW5lIHBvaW50cy4gVGhlIHNwYWNlIGJldHdlZW4gbnVtYmVyXHJcbiAqIGxpbmUgcG9pbnRzIGlzIG9ubHkgc2hhZGVkIHdoZW4gYm90aCBwb2ludCBjb250cm9sbGVycyBhcmUgb24gdGhlIG51bWJlciBsaW5lLiBObyB1bmxpbmtpbmcgaXMgcmVxdWlyZWQgYmVjYXVzZSBhbGxcclxuICogaW5zdGFuY2VzIG9mIHRoaXMgbnVtYmVyIGxpbmUgYXJlIHByZXNlbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgc2ltdWxhdGlvbi5cclxuICpcclxuICogQGF1dGhvciBTYXVyYWJoIFRvdGV5XHJcbiAqL1xyXG5cclxuaW1wb3J0IE11bHRpbGluayBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL011bHRpbGluay5qcyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVXRpbHMuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IE5MQ0NvbnN0YW50cyBmcm9tICcuLi8uLi8uLi8uLi9udW1iZXItbGluZS1jb21tb24vanMvY29tbW9uL05MQ0NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBTcGF0aWFsaXplZE51bWJlckxpbmVOb2RlIGZyb20gJy4uLy4uLy4uLy4uL251bWJlci1saW5lLWNvbW1vbi9qcy9jb21tb24vdmlldy9TcGF0aWFsaXplZE51bWJlckxpbmVOb2RlLmpzJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCBPcmllbnRhdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvT3JpZW50YXRpb24uanMnO1xyXG5pbXBvcnQgQXJyb3dTaGFwZSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvQXJyb3dTaGFwZS5qcyc7XHJcbmltcG9ydCBCYWNrZ3JvdW5kTm9kZSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvQmFja2dyb3VuZE5vZGUuanMnO1xyXG5pbXBvcnQgTWF0aFN5bWJvbEZvbnQgZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS1waGV0L2pzL01hdGhTeW1ib2xGb250LmpzJztcclxuaW1wb3J0IFBoZXRGb250IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9QaGV0Rm9udC5qcyc7XHJcbmltcG9ydCB7IE5vZGUsIFBhdGgsIFJpY2hUZXh0LCBUZXh0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IG51bWJlckxpbmVEaXN0YW5jZSBmcm9tICcuLi8uLi9udW1iZXJMaW5lRGlzdGFuY2UuanMnO1xyXG5pbXBvcnQgRGlzdGFuY2VSZXByZXNlbnRhdGlvbiBmcm9tICcuLi9tb2RlbC9EaXN0YW5jZVJlcHJlc2VudGF0aW9uLmpzJztcclxuaW1wb3J0IE5MRENvbnN0YW50cyBmcm9tICcuLi9OTERDb25zdGFudHMuanMnO1xyXG5cclxuY29uc3QgU0hBRElOR19DT0xPUiA9ICdncmF5JztcclxuY29uc3QgU0hBRElOR19XSURUSCA9IDg7XHJcbmNvbnN0IEFSUk9XX1NIQVBFX09QVElPTlMgPSB7XHJcbiAgdGFpbFdpZHRoOiBTSEFESU5HX1dJRFRILFxyXG4gIGhlYWRXaWR0aDogMjAsXHJcbiAgaGVhZEhlaWdodDogMjBcclxufTtcclxuY29uc3QgTUFYX0FSUk9XX0hFQURfVE9fQVJST1dfUFJPUE9SVElPTiA9IDAuNTtcclxuY29uc3QgUE9JTlRfTkFNRV9URVhUX09QVElPTlMgPSB7IG1heFdpZHRoOiAzOCwgZm9udDogbmV3IE1hdGhTeW1ib2xGb250KCAyMCApLCBib3VuZHNNZXRob2Q6ICdhY2N1cmF0ZScgfTtcclxuXHJcbmNsYXNzIERpc3RhbmNlU2hhZGVkTnVtYmVyTGluZU5vZGUgZXh0ZW5kcyBTcGF0aWFsaXplZE51bWJlckxpbmVOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdE5MREJhc2VNb2RlbH0gbW9kZWxcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIG1vZGVsLCBvcHRpb25zICkge1xyXG4gICAgb3B0aW9ucyA9IG1lcmdlKCB7XHJcbiAgICAgIG9mZlNjYWxlSW5kaWNhdG9yVmVydGljYWxPZmZzZXQ6IC0xMjAsXHJcbiAgICAgIG9mZlNjYWxlSW5kaWNhdG9ySG9yaXpvbnRhbE9mZnNldDogLTE1MCxcclxuICAgICAgcG9pbnROYW1lTGFiZWxPZmZzZXRGcm9tSG9yaXpvbnRhbE51bWJlckxpbmU6IDM3LFxyXG4gICAgICBwb2ludE5hbWVMYWJlbE9mZnNldEZyb21WZXJ0aWNhbE51bWJlckxpbmU6IDQ1LFxyXG4gICAgICBkaXN0YW5jZVRleHRQYWRkaW5nOiA1MFxyXG4gICAgfSwgb3B0aW9ucyApO1xyXG4gICAgc3VwZXIoIG1vZGVsLm51bWJlckxpbmUsIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIFBhdGggdGhhdCBpcyB0aGUgc2hhZGluZyBmb3IgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnQgY29udHJvbGxlcnMuXHJcbiAgICBjb25zdCBkaXN0YW5jZVNoYWRpbmdQYXRoID0gbmV3IFBhdGgoIG51bGwsIHsgc3Ryb2tlOiBudWxsLCBmaWxsOiBTSEFESU5HX0NPTE9SLCBsaW5lV2lkdGg6IFNIQURJTkdfV0lEVEggfSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggZGlzdGFuY2VTaGFkaW5nUGF0aCApO1xyXG4gICAgZGlzdGFuY2VTaGFkaW5nUGF0aC5tb3ZlVG9CYWNrKCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHRoZSBkaXN0YW5jZSBsYWJlbC4gbWF4V2lkdGggYW5kIGZvbnQgc2l6ZSBkZXRlcm1pbmVkIGVtcGlyaWNhbGx5LlxyXG4gICAgY29uc3QgZGlzdGFuY2VUZXh0ID0gbmV3IFRleHQoICcnLCB7XHJcbiAgICAgIG1heFdpZHRoOiA1MCxcclxuICAgICAgZm9udDogbmV3IFBoZXRGb250KCAyOCApXHJcbiAgICB9ICk7XHJcbiAgICBjb25zdCBkaXN0YW5jZVRleHRCYWNrZ3JvdW5kID0gbmV3IEJhY2tncm91bmROb2RlKCBkaXN0YW5jZVRleHQsIE5MQ0NvbnN0YW50cy5MQUJFTF9CQUNLR1JPVU5EX09QVElPTlMgKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIGRpc3RhbmNlVGV4dEJhY2tncm91bmQgKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGV4dCBsYWJlbHMgZm9yIHRoZSBudW1iZXIgbGluZSBwb2ludHMgdGhhdCBsYWJlbCB0aGVtIGFzIHgxLCB4MiwgeTEsIG9yIHkyLlxyXG4gICAgY29uc3QgcG9pbnROYW1lVGV4dDAgPSBuZXcgUmljaFRleHQoIE5MRENvbnN0YW50cy5YXzFfU1RSSU5HLCBQT0lOVF9OQU1FX1RFWFRfT1BUSU9OUyApO1xyXG4gICAgY29uc3QgcG9pbnROYW1lVGV4dDEgPSBuZXcgUmljaFRleHQoIE5MRENvbnN0YW50cy5YXzJfU1RSSU5HLCBQT0lOVF9OQU1FX1RFWFRfT1BUSU9OUyApO1xyXG4gICAgY29uc3QgcG9pbnROYW1lQmFja2dyb3VuZDAgPSBuZXcgQmFja2dyb3VuZE5vZGUoIHBvaW50TmFtZVRleHQwLCBOTENDb25zdGFudHMuTEFCRUxfQkFDS0dST1VORF9PUFRJT05TICk7XHJcbiAgICBjb25zdCBwb2ludE5hbWVCYWNrZ3JvdW5kMSA9IG5ldyBCYWNrZ3JvdW5kTm9kZSggcG9pbnROYW1lVGV4dDEsIE5MQ0NvbnN0YW50cy5MQUJFTF9CQUNLR1JPVU5EX09QVElPTlMgKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIG5ldyBOb2RlKCB7XHJcbiAgICAgIGNoaWxkcmVuOiBbIHBvaW50TmFtZUJhY2tncm91bmQwLCBwb2ludE5hbWVCYWNrZ3JvdW5kMSBdXHJcbiAgICB9ICkgKTtcclxuICAgIG1vZGVsLnBvaW50Q29udHJvbGxlck9uZS5pc0RyYWdnaW5nUHJvcGVydHkubGluayggKCkgPT4geyBwb2ludE5hbWVCYWNrZ3JvdW5kMC5tb3ZlVG9Gcm9udCgpOyB9ICk7XHJcbiAgICBtb2RlbC5wb2ludENvbnRyb2xsZXJUd28uaXNEcmFnZ2luZ1Byb3BlcnR5LmxpbmsoICgpID0+IHsgcG9pbnROYW1lQmFja2dyb3VuZDEubW92ZVRvRnJvbnQoKTsgfSApO1xyXG5cclxuICAgIC8vIE1vc3Qgb2YgdGhlIG51bWJlciBsaW5lJ3MgYmVoYXZpb3VyIGlzIGhhbmRsZWQgaW4gdGhpcyBtdWx0aWxpbmsuXHJcbiAgICBNdWx0aWxpbmsubXVsdGlsaW5rKFxyXG4gICAgICBbXHJcbiAgICAgICAgbW9kZWwuZGlzdGFuY2VMYWJlbHNWaXNpYmxlUHJvcGVydHksXHJcbiAgICAgICAgbW9kZWwubnVtYmVyTGluZS5kaXNwbGF5ZWRSYW5nZVByb3BlcnR5LFxyXG4gICAgICAgIG1vZGVsLmRpc3RhbmNlUmVwcmVzZW50YXRpb25Qcm9wZXJ0eSxcclxuICAgICAgICBtb2RlbC5pc1ByaW1hcnlDb250cm9sbGVyU3dhcHBlZFByb3BlcnR5LFxyXG4gICAgICAgIG1vZGVsLm51bWJlckxpbmUub3JpZW50YXRpb25Qcm9wZXJ0eSxcclxuICAgICAgICBtb2RlbC5wb2ludFZhbHVlc1Byb3BlcnR5LFxyXG4gICAgICAgIG1vZGVsLm51bWJlckxpbmUuY2VudGVyUG9zaXRpb25Qcm9wZXJ0eSAvLyBpcyBvbmx5IG5lY2Vzc2FyeSBmb3Igd2hlbiBsaXN0ZW5lcnMgYXJlIHNodWZmbGVkXHJcbiAgICAgIF0sXHJcbiAgICAgICggZGlzdGFuY2VMYWJlbHNWaXNpYmxlLCBkaXNwbGF5ZWRSYW5nZSwgZGlzdGFuY2VSZXByZXNlbnRhdGlvbiwgaXNQcmltYXJ5Q29udHJvbGxlclN3YXBwZWQsIG9yaWVudGF0aW9uLCBwb2ludFZhbHVlcyApID0+IHtcclxuXHJcbiAgICAgICAgLy8gR2V0IHdoaWNoIHN0cmluZ3MgdG8gdXNlIGZvciBwb2ludCBuYW1lcyBiYXNlZCBvbiB0aGUgbnVtYmVyIGxpbmUgb3JpZW50YXRpb24uXHJcbiAgICAgICAgLy8gVGhlIHN0cmluZ3MgYXJlIG9yZGVyZWQgYmFzZWQgb24gaXNQcmltYXJ5Q29udHJvbGxlclN3YXBwZWQuXHJcbiAgICAgICAgY29uc3QgbGFiZWxTdHJpbmdzID0gKCBvcmllbnRhdGlvbiA9PT0gT3JpZW50YXRpb24uVkVSVElDQUwgKSA/XHJcbiAgICAgICAgICBbIE5MRENvbnN0YW50cy5ZXzFfU1RSSU5HLCBOTERDb25zdGFudHMuWV8yX1NUUklORyBdIDogWyBOTERDb25zdGFudHMuWF8xX1NUUklORywgTkxEQ29uc3RhbnRzLlhfMl9TVFJJTkcgXTtcclxuICAgICAgICBpZiAoIGlzUHJpbWFyeUNvbnRyb2xsZXJTd2FwcGVkICkge1xyXG4gICAgICAgICAgY29uc3QgdGVtcCA9IGxhYmVsU3RyaW5nc1sgMCBdO1xyXG4gICAgICAgICAgbGFiZWxTdHJpbmdzWyAwIF0gPSBsYWJlbFN0cmluZ3NbIDEgXTtcclxuICAgICAgICAgIGxhYmVsU3RyaW5nc1sgMSBdID0gdGVtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBvaW50TmFtZVRleHQwLnN0cmluZyA9IGxhYmVsU3RyaW5nc1sgMCBdO1xyXG4gICAgICAgIHBvaW50TmFtZVRleHQxLnN0cmluZyA9IGxhYmVsU3RyaW5nc1sgMSBdO1xyXG4gICAgICAgIHBvaW50TmFtZUJhY2tncm91bmQwLnZpc2libGUgPSBwb2ludFZhbHVlc1sgMCBdICE9PSBudWxsICYmIGRpc3BsYXllZFJhbmdlLmNvbnRhaW5zKCBwb2ludFZhbHVlc1sgMCBdICk7XHJcbiAgICAgICAgcG9pbnROYW1lQmFja2dyb3VuZDEudmlzaWJsZSA9IHBvaW50VmFsdWVzWyAxIF0gIT09IG51bGwgJiYgZGlzcGxheWVkUmFuZ2UuY29udGFpbnMoIHBvaW50VmFsdWVzWyAxIF0gKTtcclxuXHJcbiAgICAgICAgLy8gUG9zaXRpb24gdGhlIHRleHRzLlxyXG4gICAgICAgIGlmICggb3JpZW50YXRpb24gPT09IE9yaWVudGF0aW9uLkhPUklaT05UQUwgKSB7XHJcbiAgICAgICAgICBwb2ludE5hbWVCYWNrZ3JvdW5kMC5jZW50ZXJUb3AgPSBtb2RlbC5udW1iZXJMaW5lLnZhbHVlVG9Nb2RlbFBvc2l0aW9uKFxyXG4gICAgICAgICAgICBwb2ludFZhbHVlc1sgMCBdID8gcG9pbnRWYWx1ZXNbIDAgXSA6IDBcclxuICAgICAgICAgICkucGx1cyggbmV3IFZlY3RvcjIoIDAsIG9wdGlvbnMucG9pbnROYW1lTGFiZWxPZmZzZXRGcm9tSG9yaXpvbnRhbE51bWJlckxpbmUgKSApO1xyXG4gICAgICAgICAgcG9pbnROYW1lQmFja2dyb3VuZDEuY2VudGVyVG9wID0gbW9kZWwubnVtYmVyTGluZS52YWx1ZVRvTW9kZWxQb3NpdGlvbihcclxuICAgICAgICAgICAgcG9pbnRWYWx1ZXNbIDEgXSA/IHBvaW50VmFsdWVzWyAxIF0gOiAwXHJcbiAgICAgICAgICApLnBsdXMoIG5ldyBWZWN0b3IyKCAwLCBvcHRpb25zLnBvaW50TmFtZUxhYmVsT2Zmc2V0RnJvbUhvcml6b250YWxOdW1iZXJMaW5lICkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBwb2ludE5hbWVCYWNrZ3JvdW5kMC5sZWZ0Q2VudGVyID0gbW9kZWwubnVtYmVyTGluZS52YWx1ZVRvTW9kZWxQb3NpdGlvbihcclxuICAgICAgICAgICAgcG9pbnRWYWx1ZXNbIDAgXSA/IHBvaW50VmFsdWVzWyAwIF0gOiAwXHJcbiAgICAgICAgICApLnBsdXMoIG5ldyBWZWN0b3IyKCBvcHRpb25zLnBvaW50TmFtZUxhYmVsT2Zmc2V0RnJvbVZlcnRpY2FsTnVtYmVyTGluZSwgMCApICk7XHJcbiAgICAgICAgICBwb2ludE5hbWVCYWNrZ3JvdW5kMS5sZWZ0Q2VudGVyID0gbW9kZWwubnVtYmVyTGluZS52YWx1ZVRvTW9kZWxQb3NpdGlvbihcclxuICAgICAgICAgICAgcG9pbnRWYWx1ZXNbIDEgXSA/IHBvaW50VmFsdWVzWyAxIF0gOiAwXHJcbiAgICAgICAgICApLnBsdXMoIG5ldyBWZWN0b3IyKCBvcHRpb25zLnBvaW50TmFtZUxhYmVsT2Zmc2V0RnJvbVZlcnRpY2FsTnVtYmVyTGluZSwgMCApICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdG9wIGhlcmUgaWYgYm90aCBwb2ludHMgYXJlbid0IHRoZSBudW1iZXIgbGluZTogd2UgY2Fubm90IHB1dCBhbnkgc2hhZGluZyBvciBkaXN0YW5jZSBsYWJlbC5cclxuICAgICAgICBpZiAoICFtb2RlbC5hcmVCb3RoUG9pbnRDb250cm9sbGVyc0NvbnRyb2xsaW5nT25OdW1iZXJMaW5lKCkgKSB7XHJcbiAgICAgICAgICBkaXN0YW5jZVRleHRCYWNrZ3JvdW5kLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgIGRpc3RhbmNlU2hhZGluZ1BhdGgudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXN0YW5jZVRleHRCYWNrZ3JvdW5kLnZpc2libGUgPSBkaXN0YW5jZUxhYmVsc1Zpc2libGU7XHJcbiAgICAgICAgZGlzdGFuY2VTaGFkaW5nUGF0aC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBlbmRwb2ludCBwb3NpdGlvbnMgaW4gbW9kZWwtc3BhY2Ugb2Ygd2hlcmUgdGhlIHRpcHMgb2YgdGhlIG51bWJlciBsaW5lIGFyZS5cclxuICAgICAgICAvLyBUaGlzIHVzdWFsbHkgZXh0ZW5kcyBwYXN0IHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgYWxsb3dlZCBvbiB0aGUgbnVtYmVyIGxpbmUgYmVjYXVzZSBvZiB0aGUgaW5zZXQgYW5kIGFycm93c1xyXG4gICAgICAgIC8vIG9uIGVhY2ggZW5kLiBUaGUgZW5kcG9pbnQgcG9zaXRpb25zIGFyZSBuZWVkZWQgaW4gY2FzZSBhIHBvaW50IGlzIG9mZiB0aGUgc2NhbGUgb2YgdGhlIG51bWJlciBsaW5lIGFuZCB0aGVcclxuICAgICAgICAvLyBzaGFkaW5nIG5lZWRzIHRvIGdvIGFsbCB0aGUgd2F5IHRvIHRoZSBlbmQgb2YgdGhlIG51bWJlciBsaW5lLlxyXG4gICAgICAgIGNvbnN0IGluc2V0U2l6ZSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5ZWRSYW5nZUluc2V0IC0gdGhpcy5vcHRpb25zLmFycm93U2l6ZTtcclxuICAgICAgICBjb25zdCBpbnNldFZlY3RvciA9ICggbW9kZWwubnVtYmVyTGluZS5vcmllbnRhdGlvblByb3BlcnR5LnZhbHVlID09PSBPcmllbnRhdGlvbi5IT1JJWk9OVEFMICkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcjIoIGluc2V0U2l6ZSwgMCApIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IyKCAwLCAtaW5zZXRTaXplICk7XHJcbiAgICAgICAgY29uc3QgZW5kUG9pbnRQb3NpdGlvbk1pbiA9IG1vZGVsLm51bWJlckxpbmUudmFsdWVUb01vZGVsUG9zaXRpb24oIGRpc3BsYXllZFJhbmdlLm1pbiApLm1pbnVzKCBpbnNldFZlY3RvciApO1xyXG4gICAgICAgIGNvbnN0IGVuZFBvaW50UG9zaXRpb25NYXggPSBtb2RlbC5udW1iZXJMaW5lLnZhbHVlVG9Nb2RlbFBvc2l0aW9uKCBkaXNwbGF5ZWRSYW5nZS5tYXggKS5wbHVzKCBpbnNldFZlY3RvciApO1xyXG5cclxuICAgICAgICAvLyBHZXQgd2hlcmUgb24gdGhlIG51bWJlciBsaW5lIHRoZSBwb2ludCBjb250cm9sbGVycyBhcmUuXHJcbiAgICAgICAgLy8gV2UgbmVlZCBib3RoIHRoZSBudW1iZXIgbGluZSB2YWx1ZXMgYW5kIHRoZWlyIG1vZGVsIHBvc2l0aW9ucyBmb3IgY2xhbXBpbmcgcHVycG9zZXMuXHJcbiAgICAgICAgY29uc3QgdmFsdWUwID0gcG9pbnRWYWx1ZXNbIDAgXTtcclxuICAgICAgICBjb25zdCB2YWx1ZTEgPSBwb2ludFZhbHVlc1sgMSBdO1xyXG4gICAgICAgIGxldCBlbmRQb2ludFBvc2l0aW9uMCA9IG1vZGVsLm51bWJlckxpbmUudmFsdWVUb01vZGVsUG9zaXRpb24oIHZhbHVlMCApO1xyXG4gICAgICAgIGxldCBlbmRQb2ludFBvc2l0aW9uMSA9IG1vZGVsLm51bWJlckxpbmUudmFsdWVUb01vZGVsUG9zaXRpb24oIHZhbHVlMSApO1xyXG5cclxuICAgICAgICAvLyBDbGFtcCBlbmRQb2ludFBvc2l0aW9ucyB0byBiZSBiZXR3ZWVuIGVuZFBvaW50UG9zaXRpb25NaW4gYW5kIGVuZFBvaW50UG9zaXRpb25NYXguXHJcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBVdGlsLmNsYW1wIGJlY2F1c2Ugd2UgYXJlIGNsYW1waW5nIHdoZW4gdGhlIHZhbHVlcyBhcmUgb3V0IG9mIHRoZSBkaXNwbGF5ZWQgcmFuZ2UsIGJ1dCB3ZSBhcmVcclxuICAgICAgICAvLyBjbGFtcGluZyB0byB0aGUgZW5kIHBvaW50IHBvc2l0aW9ucy4gRm9yIGV4YW1wbGUsIHZhbHVlMCBjYW4gYmUgZ3JlYXRlciB0aGFuIGRpc3BsYXllZFJhbmdlLm1heCB3aGlsZSBhdCB0aGVcclxuICAgICAgICAvLyBzYW1lIHRpbWUgZW5kUG9pbnRQb3NpdGlvbjAgY2FuIGJlIGxlc3MgdGhhbiBlbmRQb2ludFBvc2l0aW9uTWF4IHRoYW5rcyB0byB0aGUgaW5zZXQuXHJcbiAgICAgICAgaWYgKCB2YWx1ZTAgPCBkaXNwbGF5ZWRSYW5nZS5taW4gKSB7XHJcbiAgICAgICAgICBlbmRQb2ludFBvc2l0aW9uMCA9IGVuZFBvaW50UG9zaXRpb25NaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCB2YWx1ZTAgPiBkaXNwbGF5ZWRSYW5nZS5tYXggKSB7XHJcbiAgICAgICAgICBlbmRQb2ludFBvc2l0aW9uMCA9IGVuZFBvaW50UG9zaXRpb25NYXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggdmFsdWUxIDwgZGlzcGxheWVkUmFuZ2UubWluICkge1xyXG4gICAgICAgICAgZW5kUG9pbnRQb3NpdGlvbjEgPSBlbmRQb2ludFBvc2l0aW9uTWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICggdmFsdWUxID4gZGlzcGxheWVkUmFuZ2UubWF4ICkge1xyXG4gICAgICAgICAgZW5kUG9pbnRQb3NpdGlvbjEgPSBlbmRQb2ludFBvc2l0aW9uTWF4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTWFrZSB0aGUgc2hhZGluZyBzaGFwZSBiZXR3ZWVuIG5vZGVzLlxyXG4gICAgICAgIGxldCBzaGFwZSA9IG5ldyBTaGFwZSgpLm1vdmVUb1BvaW50KCBlbmRQb2ludFBvc2l0aW9uMCApLmxpbmVUb1BvaW50KCBlbmRQb2ludFBvc2l0aW9uMSApO1xyXG4gICAgICAgIGRpc3RhbmNlU2hhZGluZ1BhdGguc3Ryb2tlID0gU0hBRElOR19DT0xPUjtcclxuXHJcbiAgICAgICAgLy8gQ2hhbmdlIHRoZSBzaGFkaW5nIHNoYXBlIHRvIGFuIGFycm93IGlmIHRoZSBkaXN0YW5jZSB0eXBlIGlzIGRpcmVjdGVkIGFuZCB0aGUgYXJyb3cgaXMgcG9pbnRpbmcgdG8gYSBwb2ludFxyXG4gICAgICAgIC8vIHRoYXQgaXMgb24gdGhlIG51bWJlciBsaW5lLlxyXG4gICAgICAgIGlmICggZGlzdGFuY2VSZXByZXNlbnRhdGlvbiA9PT0gRGlzdGFuY2VSZXByZXNlbnRhdGlvbi5ESVJFQ1RFRCApIHtcclxuXHJcbiAgICAgICAgICAvLyBTY2FsZSB0aGUgYXJyb3cgYmFzZWQgb24gaG93IGNsb3NlIHRoZSBwb2ludCBjb250cm9sbGVycyBhcmUuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcG9pbnQgY29udHJvbGxlcnMgYXJlIHRvbyBjbG9zZSwgdGhlbiB0aGUgYXJyb3cgbWlnaHQgYmUgdG9vIGJpZyBhbmQgYmUgZGlzdG9ydGVkLlxyXG4gICAgICAgICAgLy8gSWYgdGhlIHdpZHRoIG9mIHRoZSBhcnJvdyBoZWFkIGlzIGdyZWF0ZXIgdGhhbiBNQVhfQVJST1dfSEVBRF9UT19BUlJPV19QUk9QT1JUSU9OLCB0aGVuIHRoZSBhcnJvdyBpc1xyXG4gICAgICAgICAgLy8gIHNjYWxlZCBkb3duLlxyXG4gICAgICAgICAgLy8gc2VlICM3XHJcbiAgICAgICAgICBsZXQgc2NhbGUgPSAxO1xyXG4gICAgICAgICAgY29uc3QgYXJyb3dWYWx1ZUxlbmd0aCA9IE1hdGguYWJzKFxyXG4gICAgICAgICAgICBtb2RlbC5udW1iZXJMaW5lLm1vZGVsUG9zaXRpb25Ub1ZhbHVlKCBlbmRQb2ludFBvc2l0aW9uMSApIC0gbW9kZWwubnVtYmVyTGluZS5tb2RlbFBvc2l0aW9uVG9WYWx1ZSggZW5kUG9pbnRQb3NpdGlvbjAgKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGxldCBhcnJvd0hlYWRWYWx1ZUxlbmd0aCA9IE1hdGguYWJzKFxyXG4gICAgICAgICAgICBtb2RlbC5udW1iZXJMaW5lLm1vZGVsUG9zaXRpb25Ub1ZhbHVlKCBlbmRQb2ludFBvc2l0aW9uMCApXHJcbiAgICAgICAgICAgICAgLSBtb2RlbC5udW1iZXJMaW5lLm1vZGVsUG9zaXRpb25Ub1ZhbHVlKCBuZXcgVmVjdG9yMiggZW5kUG9pbnRQb3NpdGlvbjAueCAtIEFSUk9XX1NIQVBFX09QVElPTlMuaGVhZEhlaWdodCwgMCApIClcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBpZiAoIG9yaWVudGF0aW9uID09PSBPcmllbnRhdGlvbi5WRVJUSUNBTCApIHtcclxuICAgICAgICAgICAgYXJyb3dIZWFkVmFsdWVMZW5ndGggPSBNYXRoLmFicyhcclxuICAgICAgICAgICAgICBtb2RlbC5udW1iZXJMaW5lLm1vZGVsUG9zaXRpb25Ub1ZhbHVlKCBlbmRQb2ludFBvc2l0aW9uMCApXHJcbiAgICAgICAgICAgICAgLSBtb2RlbC5udW1iZXJMaW5lLm1vZGVsUG9zaXRpb25Ub1ZhbHVlKCBuZXcgVmVjdG9yMiggMCwgZW5kUG9pbnRQb3NpdGlvbjAueSAtIEFSUk9XX1NIQVBFX09QVElPTlMuaGVhZEhlaWdodCApIClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IGhlYWRMZW5ndGhUb0Fycm93TGVuZ3RoUHJvcG9ydGlvbiA9IGFycm93SGVhZFZhbHVlTGVuZ3RoIC8gYXJyb3dWYWx1ZUxlbmd0aDtcclxuICAgICAgICAgIGlmICggaGVhZExlbmd0aFRvQXJyb3dMZW5ndGhQcm9wb3J0aW9uID4gTUFYX0FSUk9XX0hFQURfVE9fQVJST1dfUFJPUE9SVElPTiApIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBNQVhfQVJST1dfSEVBRF9UT19BUlJPV19QUk9QT1JUSU9OIC8gaGVhZExlbmd0aFRvQXJyb3dMZW5ndGhQcm9wb3J0aW9uO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29uc3Qgc2NhbGVkQXJyb3dTaGFwZU9wdGlvbnMgPSBtZXJnZSgge30sIEFSUk9XX1NIQVBFX09QVElPTlMsIHtcclxuICAgICAgICAgICAgaGVhZEhlaWdodDogQVJST1dfU0hBUEVfT1BUSU9OUy5oZWFkSGVpZ2h0ICogc2NhbGUsXHJcbiAgICAgICAgICAgIGhlYWRXaWR0aDogQVJST1dfU0hBUEVfT1BUSU9OUy5oZWFkV2lkdGggKiBzY2FsZSxcclxuICAgICAgICAgICAgdGFpbFdpZHRoOiBBUlJPV19TSEFQRV9PUFRJT05TLnRhaWxXaWR0aCAqIHNjYWxlXHJcbiAgICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgICAgLy8gT25seSBzZXQgdGhlIHNoYXBlIHRvIHRoZSBhcnJvdyBzaGFwZSBpZiB0aGUgcG9pbnQgdGhhdCB0aGUgYXJyb3cgcG9pbnRzIHRvIGlzIGluIHRoZSBudW1iZXIgbGluZSdzIHJhbmdlLlxyXG4gICAgICAgICAgLy8gVGhlIHN0cm9rZSBpcyByZW1vdmVkIHNvIHRoZSB0YWlsIG9mIHRoZSBhcnJvdyBjYW4gaGF2ZSB0aGUgY29ycmVjdCB3aWR0aC5cclxuICAgICAgICAgIGlmICggaXNQcmltYXJ5Q29udHJvbGxlclN3YXBwZWQgJiYgZGlzcGxheWVkUmFuZ2UubWluIDw9IHZhbHVlMCAmJiB2YWx1ZTAgPD0gZGlzcGxheWVkUmFuZ2UubWF4ICkge1xyXG4gICAgICAgICAgICBzaGFwZSA9IG5ldyBBcnJvd1NoYXBlKCBlbmRQb2ludFBvc2l0aW9uMS54LCBlbmRQb2ludFBvc2l0aW9uMS55LCBlbmRQb2ludFBvc2l0aW9uMC54LCBlbmRQb2ludFBvc2l0aW9uMC55LCBzY2FsZWRBcnJvd1NoYXBlT3B0aW9ucyApO1xyXG4gICAgICAgICAgICBkaXN0YW5jZVNoYWRpbmdQYXRoLnN0cm9rZSA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmICggIWlzUHJpbWFyeUNvbnRyb2xsZXJTd2FwcGVkICYmIGRpc3BsYXllZFJhbmdlLm1pbiA8PSB2YWx1ZTEgJiYgdmFsdWUxIDw9IGRpc3BsYXllZFJhbmdlLm1heCApIHtcclxuICAgICAgICAgICAgc2hhcGUgPSBuZXcgQXJyb3dTaGFwZSggZW5kUG9pbnRQb3NpdGlvbjAueCwgZW5kUG9pbnRQb3NpdGlvbjAueSwgZW5kUG9pbnRQb3NpdGlvbjEueCwgZW5kUG9pbnRQb3NpdGlvbjEueSwgc2NhbGVkQXJyb3dTaGFwZU9wdGlvbnMgKTtcclxuICAgICAgICAgICAgZGlzdGFuY2VTaGFkaW5nUGF0aC5zdHJva2UgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGlzdGFuY2VTaGFkaW5nUGF0aC5zaGFwZSA9IHNoYXBlO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGVzIHRoZSBkaWZmZXJlbmNlIHRvIGRpc3BsYXkuXHJcbiAgICAgICAgbGV0IGRpc3BsYXllZERpZmZlcmVuY2UgPSB2YWx1ZTEgLSB2YWx1ZTA7XHJcbiAgICAgICAgaWYgKCBpc1ByaW1hcnlDb250cm9sbGVyU3dhcHBlZCApIHtcclxuICAgICAgICAgIGRpc3BsYXllZERpZmZlcmVuY2UgPSAtZGlzcGxheWVkRGlmZmVyZW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBkaXN0YW5jZVJlcHJlc2VudGF0aW9uID09PSBEaXN0YW5jZVJlcHJlc2VudGF0aW9uLkFCU09MVVRFICkge1xyXG4gICAgICAgICAgZGlzcGxheWVkRGlmZmVyZW5jZSA9IE1hdGguYWJzKCBkaXNwbGF5ZWREaWZmZXJlbmNlICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkaXN0YW5jZVRleHQuc3RyaW5nID0gYCR7VXRpbHMucm91bmRTeW1tZXRyaWMoIGRpc3BsYXllZERpZmZlcmVuY2UgKX1gO1xyXG5cclxuICAgICAgICAvLyBQb3NpdGlvbiBkaXN0YW5jZSB0ZXh0LlxyXG4gICAgICAgIGlmICggb3JpZW50YXRpb24gPT09IE9yaWVudGF0aW9uLkhPUklaT05UQUwgKSB7XHJcbiAgICAgICAgICBkaXN0YW5jZVRleHRCYWNrZ3JvdW5kLmJvdHRvbSA9IGVuZFBvaW50UG9zaXRpb24wLnkgLSBvcHRpb25zLmRpc3RhbmNlVGV4dFBhZGRpbmc7XHJcbiAgICAgICAgICBkaXN0YW5jZVRleHRCYWNrZ3JvdW5kLmNlbnRlclggPSAoIGVuZFBvaW50UG9zaXRpb24xLnggKyBlbmRQb2ludFBvc2l0aW9uMC54ICkgLyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGRpc3RhbmNlVGV4dEJhY2tncm91bmQucmlnaHQgPSBlbmRQb2ludFBvc2l0aW9uMC54IC0gb3B0aW9ucy5kaXN0YW5jZVRleHRQYWRkaW5nO1xyXG4gICAgICAgICAgZGlzdGFuY2VUZXh0QmFja2dyb3VuZC5jZW50ZXJZID0gKCBlbmRQb2ludFBvc2l0aW9uMS55ICsgZW5kUG9pbnRQb3NpdGlvbjAueSApIC8gMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbm51bWJlckxpbmVEaXN0YW5jZS5yZWdpc3RlciggJ0Rpc3RhbmNlU2hhZGVkTnVtYmVyTGluZU5vZGUnLCBEaXN0YW5jZVNoYWRlZE51bWJlckxpbmVOb2RlICk7XHJcbmV4cG9ydCBkZWZhdWx0IERpc3RhbmNlU2hhZGVkTnVtYmVyTGluZU5vZGU7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsU0FBUyxNQUFNLGtDQUFrQztBQUN4RCxPQUFPQyxLQUFLLE1BQU0sNkJBQTZCO0FBQy9DLE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsU0FBU0MsS0FBSyxRQUFRLGdDQUFnQztBQUN0RCxPQUFPQyxZQUFZLE1BQU0sMERBQTBEO0FBQ25GLE9BQU9DLHlCQUF5QixNQUFNLDRFQUE0RTtBQUNsSCxPQUFPQyxLQUFLLE1BQU0sbUNBQW1DO0FBQ3JELE9BQU9DLFdB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