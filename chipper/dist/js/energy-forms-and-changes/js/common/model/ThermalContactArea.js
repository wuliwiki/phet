// Copyright 2014-2020, University of Colorado Boulder

/**
 * A type that represents a 2D space that can come into contact with other thermal areas, leading to the exchange of
 * thermal energy. This is basically just a shape and a flag that indicates whether or not immersion can occur.
 *
 * @author John Blanco
 */

import Bounds2 from '../../../../dot/js/Bounds2.js';
import energyFormsAndChanges from '../../energyFormsAndChanges.js';

// threshold of distance for determining whether two areas are in contact
const TOUCH_DISTANCE_THRESHOLD = 0.001; // in meters

class ThermalContactArea extends Bounds2 {
  /**
   * @param {Bounds2} bounds
   * @param {boolean} supportsImmersion
   * @public
   */
  constructor(bounds, supportsImmersion) {
    super(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
    this.supportsImmersion = supportsImmersion;
  }

  /**
   * Get the amount of thermal contact that exists between this and another thermal area.  Since thermal contact
   * areas are 2D, the amount of contact is a 1D quantity.  For example, when a rectangle is sitting on top of
   * another that is the same width, the contact length is the width of the shared edge.
   * @param {ThermalContactArea} that -  other thermal contact area
   * @returns {number} - length of contact
   * @public
   */
  getThermalContactLength(that) {
    const xOverlap = getHorizontalOverlap(this, that);
    const yOverlap = getVerticalOverlap(this, that);
    let contactLength = 0;
    if (xOverlap > 0 && yOverlap > 0) {
      // One of the areas is overlapping another.  This should be an 'immersion' situation, i.e. one is all or
      // partially immersed in the other.
      if (this.supportsImmersion || that.supportsImmersion) {
        const immersionRect = this.intersection(that);
        contactLength = immersionRect.width * 2 + immersionRect.height * 2;
        if (immersionRect.width !== this.width && immersionRect.width !== that.width) {
          // not fully overlapping in X direction, so adjust contact length accordingly
          contactLength -= immersionRect.height;
        }
        if (immersionRect.height !== this.height && immersionRect.height !== that.height) {
          // not fully overlapping in Y direction, so adjust contact length accordingly
          contactLength -= immersionRect.width;
        }
      } else {

        // This shouldn't occur, but in practice it sometimes does due to floating point tolerances.  Print out an
        // error if a threshold is exceeded so that we can know that the value needs adjusting.  The threshold value
        // was determined by testing.
        // if ( yOverlap > 1E-6 && xOverlap > 1E-6 ) {
        //   console.warn( 'Double overlap detected in case where neither energy container supports immersion.  Ignoring.' );
        //   console.warn( 'yOverlap = ' + yOverlap );
        //   console.warn( 'xOverlap = ' + xOverlap );
        // }
      }
    } else if (xOverlap > 0 || yOverlap > 0) {
      // there is overlap in one dimension but not the other, so test to see if the two containers are touching
      if (xOverlap > 0 && Math.abs(this.maxY - that.minY) < TOUCH_DISTANCE_THRESHOLD || Math.abs(this.minY - that.maxY) < TOUCH_DISTANCE_THRESHOLD) {
        contactLength = xOverlap;
      } else if (yOverlap > 0 && Math.abs(this.maxX - that.minX) < TOUCH_DISTANCE_THRESHOLD || Math.abs(this.minX - that.maxX) < TOUCH_DISTANCE_THRESHOLD) {
        contactLength = xOverlap;
      }
    }
    return contactLength;
  }
}

/**
 * convenience method for determining overlap of rectangles in X dimension
 * @param {Rectangle} rectangle1
 * @param {Rectangle} rectangle2
 * @returns {number}
 */
const getHorizontalOverlap = (rectangle1, rectangle2) => {
  const lowestMax = Math.min(rectangle1.maxX, rectangle2.maxX);
  const highestMin = Math.max(rectangle1.minX, rectangle2.minX);
  return Math.max(lowestMax - highestMin, 0);
};

/**
 * convenience method for determining overlap of rectangles in Y dimension
 * @param {Rectangle} rectangle1
 * @param {Rectangle} rectangle2
 * @returns {number}
 */
const getVerticalOverlap = (rectangle1, rectangle2) => {
  const lowestMax = Math.min(rectangle1.maxY, rectangle2.maxY);
  const highestMin = Math.max(rectangle1.minY, rectangle2.minY);
  return Math.max(lowestMax - highestMin, 0);
};
energyFormsAndChanges.register('ThermalContactArea', ThermalContactArea);
export default ThermalContactArea;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiZW5lcmd5Rm9ybXNBbmRDaGFuZ2VzIiwiVE9VQ0hfRElTVEFOQ0VfVEhSRVNIT0xEIiwiVGhlcm1hbENvbnRhY3RBcmVhIiwiY29uc3RydWN0b3IiLCJib3VuZHMiLCJzdXBwb3J0c0ltbWVyc2lvbiIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJnZXRUaGVybWFsQ29udGFjdExlbmd0aCIsInRoYXQiLCJ4T3ZlcmxhcCIsImdldEhvcml6b250YWxPdmVybGFwIiwieU92ZXJsYXAiLCJnZXRWZXJ0aWNhbE92ZXJsYXAiLCJjb250YWN0TGVuZ3RoIiwiaW1tZXJzaW9uUmVjdCIsImludGVyc2VjdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwiTWF0aCIsImFicyIsInJlY3RhbmdsZTEiLCJyZWN0YW5nbGUyIiwibG93ZXN0TWF4IiwibWluIiwiaGlnaGVzdE1pbiIsIm1heCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiVGhlcm1hbENvbnRhY3RBcmVhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE0LTIwMjAsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEEgdHlwZSB0aGF0IHJlcHJlc2VudHMgYSAyRCBzcGFjZSB0aGF0IGNhbiBjb21lIGludG8gY29udGFjdCB3aXRoIG90aGVyIHRoZXJtYWwgYXJlYXMsIGxlYWRpbmcgdG8gdGhlIGV4Y2hhbmdlIG9mXHJcbiAqIHRoZXJtYWwgZW5lcmd5LiBUaGlzIGlzIGJhc2ljYWxseSBqdXN0IGEgc2hhcGUgYW5kIGEgZmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCBpbW1lcnNpb24gY2FuIG9jY3VyLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvXHJcbiAqL1xyXG5cclxuaW1wb3J0IEJvdW5kczIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL0JvdW5kczIuanMnO1xyXG5pbXBvcnQgZW5lcmd5Rm9ybXNBbmRDaGFuZ2VzIGZyb20gJy4uLy4uL2VuZXJneUZvcm1zQW5kQ2hhbmdlcy5qcyc7XHJcblxyXG4vLyB0aHJlc2hvbGQgb2YgZGlzdGFuY2UgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdHdvIGFyZWFzIGFyZSBpbiBjb250YWN0XHJcbmNvbnN0IFRPVUNIX0RJU1RBTkNFX1RIUkVTSE9MRCA9IDAuMDAxOyAvLyBpbiBtZXRlcnNcclxuXHJcbmNsYXNzIFRoZXJtYWxDb250YWN0QXJlYSBleHRlbmRzIEJvdW5kczIge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0JvdW5kczJ9IGJvdW5kc1xyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3VwcG9ydHNJbW1lcnNpb25cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGJvdW5kcywgc3VwcG9ydHNJbW1lcnNpb24gKSB7XHJcbiAgICBzdXBlciggYm91bmRzLm1pblgsIGJvdW5kcy5taW5ZLCBib3VuZHMubWF4WCwgYm91bmRzLm1heFkgKTtcclxuICAgIHRoaXMuc3VwcG9ydHNJbW1lcnNpb24gPSBzdXBwb3J0c0ltbWVyc2lvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgYW1vdW50IG9mIHRoZXJtYWwgY29udGFjdCB0aGF0IGV4aXN0cyBiZXR3ZWVuIHRoaXMgYW5kIGFub3RoZXIgdGhlcm1hbCBhcmVhLiAgU2luY2UgdGhlcm1hbCBjb250YWN0XHJcbiAgICogYXJlYXMgYXJlIDJELCB0aGUgYW1vdW50IG9mIGNvbnRhY3QgaXMgYSAxRCBxdWFudGl0eS4gIEZvciBleGFtcGxlLCB3aGVuIGEgcmVjdGFuZ2xlIGlzIHNpdHRpbmcgb24gdG9wIG9mXHJcbiAgICogYW5vdGhlciB0aGF0IGlzIHRoZSBzYW1lIHdpZHRoLCB0aGUgY29udGFjdCBsZW5ndGggaXMgdGhlIHdpZHRoIG9mIHRoZSBzaGFyZWQgZWRnZS5cclxuICAgKiBAcGFyYW0ge1RoZXJtYWxDb250YWN0QXJlYX0gdGhhdCAtICBvdGhlciB0aGVybWFsIGNvbnRhY3QgYXJlYVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gbGVuZ3RoIG9mIGNvbnRhY3RcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgZ2V0VGhlcm1hbENvbnRhY3RMZW5ndGgoIHRoYXQgKSB7XHJcblxyXG4gICAgY29uc3QgeE92ZXJsYXAgPSBnZXRIb3Jpem9udGFsT3ZlcmxhcCggdGhpcywgdGhhdCApO1xyXG4gICAgY29uc3QgeU92ZXJsYXAgPSBnZXRWZXJ0aWNhbE92ZXJsYXAoIHRoaXMsIHRoYXQgKTtcclxuXHJcbiAgICBsZXQgY29udGFjdExlbmd0aCA9IDA7XHJcbiAgICBpZiAoIHhPdmVybGFwID4gMCAmJiB5T3ZlcmxhcCA+IDAgKSB7XHJcblxyXG4gICAgICAvLyBPbmUgb2YgdGhlIGFyZWFzIGlzIG92ZXJsYXBwaW5nIGFub3RoZXIuICBUaGlzIHNob3VsZCBiZSBhbiAnaW1tZXJzaW9uJyBzaXR1YXRpb24sIGkuZS4gb25lIGlzIGFsbCBvclxyXG4gICAgICAvLyBwYXJ0aWFsbHkgaW1tZXJzZWQgaW4gdGhlIG90aGVyLlxyXG4gICAgICBpZiAoIHRoaXMuc3VwcG9ydHNJbW1lcnNpb24gfHwgdGhhdC5zdXBwb3J0c0ltbWVyc2lvbiApIHtcclxuICAgICAgICBjb25zdCBpbW1lcnNpb25SZWN0ID0gdGhpcy5pbnRlcnNlY3Rpb24oIHRoYXQgKTtcclxuICAgICAgICBjb250YWN0TGVuZ3RoID0gaW1tZXJzaW9uUmVjdC53aWR0aCAqIDIgKyBpbW1lcnNpb25SZWN0LmhlaWdodCAqIDI7XHJcbiAgICAgICAgaWYgKCBpbW1lcnNpb25SZWN0LndpZHRoICE9PSB0aGlzLndpZHRoICYmIGltbWVyc2lvblJlY3Qud2lkdGggIT09IHRoYXQud2lkdGggKSB7XHJcblxyXG4gICAgICAgICAgLy8gbm90IGZ1bGx5IG92ZXJsYXBwaW5nIGluIFggZGlyZWN0aW9uLCBzbyBhZGp1c3QgY29udGFjdCBsZW5ndGggYWNjb3JkaW5nbHlcclxuICAgICAgICAgIGNvbnRhY3RMZW5ndGggLT0gaW1tZXJzaW9uUmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggaW1tZXJzaW9uUmVjdC5oZWlnaHQgIT09IHRoaXMuaGVpZ2h0ICYmIGltbWVyc2lvblJlY3QuaGVpZ2h0ICE9PSB0aGF0LmhlaWdodCApIHtcclxuICAgICAgICAgIC8vIG5vdCBmdWxseSBvdmVybGFwcGluZyBpbiBZIGRpcmVjdGlvbiwgc28gYWRqdXN0IGNvbnRhY3QgbGVuZ3RoIGFjY29yZGluZ2x5XHJcbiAgICAgICAgICBjb250YWN0TGVuZ3RoIC09IGltbWVyc2lvblJlY3Qud2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBvY2N1ciwgYnV0IGluIHByYWN0aWNlIGl0IHNvbWV0aW1lcyBkb2VzIGR1ZSB0byBmbG9hdGluZyBwb2ludCB0b2xlcmFuY2VzLiAgUHJpbnQgb3V0IGFuXHJcbiAgICAgICAgLy8gZXJyb3IgaWYgYSB0aHJlc2hvbGQgaXMgZXhjZWVkZWQgc28gdGhhdCB3ZSBjYW4ga25vdyB0aGF0IHRoZSB2YWx1ZSBuZWVkcyBhZGp1c3RpbmcuICBUaGUgdGhyZXNob2xkIHZhbHVlXHJcbiAgICAgICAgLy8gd2FzIGRldGVybWluZWQgYnkgdGVzdGluZy5cclxuICAgICAgICAvLyBpZiAoIHlPdmVybGFwID4gMUUtNiAmJiB4T3ZlcmxhcCA+IDFFLTYgKSB7XHJcbiAgICAgICAgLy8gICBjb25zb2xlLndhcm4oICdEb3VibGUgb3ZlcmxhcCBkZXRlY3RlZCBpbiBjYXNlIHdoZXJlIG5laXRoZXIgZW5lcmd5IGNvbnRhaW5lciBzdXBwb3J0cyBpbW1lcnNpb24uICBJZ25vcmluZy4nICk7XHJcbiAgICAgICAgLy8gICBjb25zb2xlLndhcm4oICd5T3ZlcmxhcCA9ICcgKyB5T3ZlcmxhcCApO1xyXG4gICAgICAgIC8vICAgY29uc29sZS53YXJuKCAneE92ZXJsYXAgPSAnICsgeE92ZXJsYXAgKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCB4T3ZlcmxhcCA+IDAgfHwgeU92ZXJsYXAgPiAwICkge1xyXG5cclxuICAgICAgLy8gdGhlcmUgaXMgb3ZlcmxhcCBpbiBvbmUgZGltZW5zaW9uIGJ1dCBub3QgdGhlIG90aGVyLCBzbyB0ZXN0IHRvIHNlZSBpZiB0aGUgdHdvIGNvbnRhaW5lcnMgYXJlIHRvdWNoaW5nXHJcbiAgICAgIGlmICggeE92ZXJsYXAgPiAwICYmXHJcbiAgICAgICAgICAgTWF0aC5hYnMoIHRoaXMubWF4WSAtIHRoYXQubWluWSApIDwgVE9VQ0hfRElTVEFOQ0VfVEhSRVNIT0xEIHx8XHJcbiAgICAgICAgICAgTWF0aC5hYnMoIHRoaXMubWluWSAtIHRoYXQubWF4WSApIDwgVE9VQ0hfRElTVEFOQ0VfVEhSRVNIT0xEICkge1xyXG4gICAgICAgIGNvbnRhY3RMZW5ndGggPSB4T3ZlcmxhcDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICggeU92ZXJsYXAgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyggdGhpcy5tYXhYIC0gdGhhdC5taW5YICkgPCBUT1VDSF9ESVNUQU5DRV9USFJFU0hPTEQgfHxcclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKCB0aGlzLm1pblggLSB0aGF0Lm1heFggKSA8IFRPVUNIX0RJU1RBTkNFX1RIUkVTSE9MRCApIHtcclxuICAgICAgICBjb250YWN0TGVuZ3RoID0geE92ZXJsYXA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGFjdExlbmd0aDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGRldGVybWluaW5nIG92ZXJsYXAgb2YgcmVjdGFuZ2xlcyBpbiBYIGRpbWVuc2lvblxyXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdGFuZ2xlMVxyXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdGFuZ2xlMlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3QgZ2V0SG9yaXpvbnRhbE92ZXJsYXAgPSAoIHJlY3RhbmdsZTEsIHJlY3RhbmdsZTIgKSA9PiB7XHJcbiAgY29uc3QgbG93ZXN0TWF4ID0gTWF0aC5taW4oIHJlY3RhbmdsZTEubWF4WCwgcmVjdGFuZ2xlMi5tYXhYICk7XHJcbiAgY29uc3QgaGlnaGVzdE1pbiA9IE1hdGgubWF4KCByZWN0YW5nbGUxLm1pblgsIHJlY3RhbmdsZTIubWluWCApO1xyXG4gIHJldHVybiBNYXRoLm1heCggbG93ZXN0TWF4IC0gaGlnaGVzdE1pbiwgMCApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgZGV0ZXJtaW5pbmcgb3ZlcmxhcCBvZiByZWN0YW5nbGVzIGluIFkgZGltZW5zaW9uXHJcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUxXHJcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUyXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBnZXRWZXJ0aWNhbE92ZXJsYXAgPSAoIHJlY3RhbmdsZTEsIHJlY3RhbmdsZTIgKSA9PiB7XHJcbiAgY29uc3QgbG93ZXN0TWF4ID0gTWF0aC5taW4oIHJlY3RhbmdsZTEubWF4WSwgcmVjdGFuZ2xlMi5tYXhZICk7XHJcbiAgY29uc3QgaGlnaGVzdE1pbiA9IE1hdGgubWF4KCByZWN0YW5nbGUxLm1pblksIHJlY3RhbmdsZTIubWluWSApO1xyXG4gIHJldHVybiBNYXRoLm1heCggbG93ZXN0TWF4IC0gaGlnaGVzdE1pbiwgMCApO1xyXG59O1xyXG5cclxuZW5lcmd5Rm9ybXNBbmRDaGFuZ2VzLnJlZ2lzdGVyKCAnVGhlcm1hbENvbnRhY3RBcmVhJywgVGhlcm1hbENvbnRhY3RBcmVhICk7XHJcbmV4cG9ydCBkZWZhdWx0IFRoZXJtYWxDb250YWN0QXJlYTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLHFCQUFxQixNQUFNLGdDQUFnQzs7QUFFbEU7QUFDQSxNQUFNQyx3QkFBd0IsR0FBRyxLQUFLLENBQUMsQ0FBQzs7QUFFeEMsTUFBTUMsa0JBQWtCLFNBQVNILE9BQU8sQ0FBQztFQUV2QztBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0VJLFdBQVdBLENBQUVDLE1BQU0sRUFBRUMsaUJBQWlCLEVBQUc7SUFDdkMsS0FBSyxDQUFFRCxNQUFNLENBQUNFLElBQUksRUFBRUYsTUFBTSxDQUFDRyxJQUFJLEVBQUVILE1BQU0sQ0FBQ0ksSUFBSSxFQUFFSixNQUFNLENBQUNLLElBQUssQ0FBQztJQUMzRCxJQUFJLENBQUNKLGlCQUFpQixHQUFHQSxpQkFBaUI7RUFDNUM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFSyx1QkFBdUJBLENBQUVDLElBQUksRUFBRztJQUU5QixNQUFNQyxRQUFRLEdBQUdDLG9CQUFvQixDQUFFLElBQUksRUFBRUYsSUFBSyxDQUFDO0lBQ25ELE1BQU1HLFFBQVEsR0FBR0Msa0JBQWtCLENBQUUsSUFBSSxFQUFFSixJQUFLLENBQUM7SUFFakQsSUFBSUssYUFBYSxHQUFHLENBQUM7SUFDckIsSUFBS0osUUFBUSxHQUFHLENBQUMsSUFBSUUsUUFBUSxHQUFHLENBQUMsRUFBRztNQUVsQztNQUNBO01BQ0EsSUFBSyxJQUFJLENBQUNULGlCQUFpQixJQUFJTSxJQUFJLENBQUNOLGlCQUFpQixFQUFHO1FBQ3RELE1BQU1ZLGFBQWEsR0FBRyxJQUFJLENBQUNDLFlBQVksQ0FBRVAsSUFBSyxDQUFDO1FBQy9DSyxhQUFhLEdBQUdDLGFBQWEsQ0FBQ0UsS0FBSyxHQUFHLENBQUMsR0FBR0YsYUFBYSxDQUFDRyxNQUFNLEdBQUcsQ0FBQztRQUNsRSxJQUFLSCxhQUFhLENBQUNFLEtBQUssS0FBSyxJQUFJLENBQUNBLEtBQUssSUFBSUYsYUFBYSxDQUFDRSxLQUFLLEtBQUtSLElBQUksQ0FBQ1EsS0FBSyxFQUFHO1VBRTlFO1VBQ0FILGFBQWEsSUFBSUMsYUFBYSxDQUFDRyxNQUFNO1FBQ3ZDO1FBQ0EsSUFBS0gsYUFBYSxDQUFDRyxNQUFNLEtBQUssSUFBSSxDQUFDQSxNQUFNLElBQUlILGFBQWEsQ0FBQ0csTUFBTSxLQUFLVCxJQUFJLENBQUNTLE1BQU0sRUFBRztVQUNsRjtVQUNBSixhQUFhLElBQUlDLGFBQWEsQ0FBQ0UsS0FBSztRQUN0QztNQUNGLENBQUMsTUFDSTs7UUFFSDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO01BQUE7SUFFSixDQUFDLE1BQ0ksSUFBS1AsUUFBUSxHQUFHLENBQUMsSUFBSUUsUUFBUSxHQUFHLENBQUMsRUFBRztNQUV2QztNQUNBLElBQUtGLFFBQVEsR0FBRyxDQUFDLElBQ1pTLElBQUksQ0FBQ0MsR0FBRyxDQUFFLElBQUksQ0FBQ2IsSUFBSSxHQUFHRSxJQUFJLENBQUNKLElBQUssQ0FBQyxHQUFHTix3QkFBd0IsSUFDNURvQixJQUFJLENBQUNDLEdBQUcsQ0FBRSxJQUFJLENBQUNmLElBQUksR0FBR0ksSUFBSSxDQUFDRixJQUFLLENBQUMsR0FBR1Isd0JBQXdCLEVBQUc7UUFDbEVlLGFBQWEsR0FBR0osUUFBUTtNQUMxQixDQUFDLE1BQ0ksSUFBS0UsUUFBUSxHQUFHLENBQUMsSUFDWk8sSUFBSSxDQUFDQyxHQUFHLENBQUUsSUFBSSxDQUFDZCxJQUFJLEdBQUdHLElBQUksQ0FBQ0wsSUFBSyxDQUFDLEdBQUdMLHdCQUF3QixJQUM1RG9CLElBQUksQ0FBQ0MsR0FBRyxDQUFFLElBQUksQ0FBQ2hCLElBQUksR0FBR0ssSUFBSSxDQUFDSCxJQUFLLENBQUMsR0FBR1Asd0JBQXdCLEVBQUc7UUFDdkVlLGFBQWEsR0FBR0osUUFBUTtNQUMxQjtJQUNGO0lBRUEsT0FBT0ksYUFBYTtFQUN0QjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1ILG9CQUFvQixHQUFHQSxDQUFFVSxVQUFVLEVBQUVDLFVBQVUsS0FBTTtFQUN6RCxNQUFNQyxTQUFTLEdBQUdKLElBQUksQ0FBQ0ssR0FBRyxDQUFFSCxVQUFVLENBQUNmLElBQUksRUFBRWdCLFVBQVUsQ0FBQ2hCLElBQUssQ0FBQztFQUM5RCxNQUFNbUIsVUFBVSxHQUFHTixJQUFJLENBQUNPLEdBQUcsQ0FBRUwsVUFBVSxDQUFDakIsSUFBSSxFQUFFa0IsVUFBVSxDQUFDbEIsSUFBSyxDQUFDO0VBQy9ELE9BQU9lLElBQUksQ0FBQ08sR0FBRyxDQUFFSCxTQUFTLEdBQUdFLFVBQVUsRUFBRSxDQUFFLENBQUM7QUFDOUMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNWixrQkFBa0IsR0FBR0EsQ0FBRVEsVUFBVSxFQUFFQyxVQUFVLEtBQU07RUFDdkQsTUFBTUMsU0FBUyxHQUFHSixJQUFJLENBQUNLLEdBQUcsQ0FBRUgsVUFBVSxDQUFDZCxJQUFJLEVBQUVlLFVBQVUsQ0FBQ2YsSUFBSyxDQUFDO0VBQzlELE1BQU1rQixVQUFVLEdBQUdOLElBQUksQ0FBQ08sR0FBRyxDQUFFTCxVQUFVLENBQUNoQixJQUFJLEVBQUVpQixVQUFVLENBQUNqQixJQUFLLENBQUM7RUFDL0QsT0FBT2MsSUFBSSxDQUFDTyxHQUFHLENBQUVILFNBQVMsR0FBR0UsVUFBVSxFQUFFLENBQUUsQ0FBQztBQUM5QyxDQUFDO0FBRUQzQixxQkFBcUIsQ0FBQzZCLFFBQVEsQ0FBRSxvQkFBb0IsRUFBRTNCLGtCQUFtQixDQUFDO0FBQzFFLGVBQWVBLGtCQUFrQiJ9