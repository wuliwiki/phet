// Copyright 2014-2023, University of Colorado Boulder

/**
 * Base class for all model elements in the Energy Forms and Changes simulation that can be moved around by the user.
 * At the time of this writing, this includes blocks, beakers, burners, and thermometers.
 *
 * @author John Blanco
 */

import createObservableArray from '../../../../axon/js/createObservableArray.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import Vector2Property from '../../../../dot/js/Vector2Property.js';
import merge from '../../../../phet-core/js/merge.js';
import PhetioObject from '../../../../tandem/js/PhetioObject.js';
import Tandem from '../../../../tandem/js/Tandem.js';
import IOType from '../../../../tandem/js/types/IOType.js';
import ReferenceIO from '../../../../tandem/js/types/ReferenceIO.js';
import energyFormsAndChanges from '../../energyFormsAndChanges.js';
class ModelElement extends PhetioObject {
  /**
   * @param {Vector2} initialPosition
   * @param {Object} [options]
   */
  constructor(initialPosition, options) {
    options = merge({
      tandem: Tandem.REQUIRED,
      phetioType: ReferenceIO(IOType.ObjectIO),
      phetioState: false,
      positionPropertyOptions: {
        units: 'm',
        phetioHighFrequency: true,
        phetioDocumentation: 'the center-bottom position of the element'
      }
    }, options);
    super(options);

    // @public
    this.positionProperty = new Vector2Property(initialPosition, merge({
      hasListenerOrderDependencies: true,
      // TODO: https://github.com/phetsims/energy-forms-and-changes/issues/421
      tandem: options.tandem.createTandem('positionProperty')
    }, options.positionPropertyOptions));

    // @public (read-only)
    this.tandemName = options.tandem.name;

    // @public {HorizontalSurface|null} - The top surface of this model element, the value will be
    // null if other elements can't rest upon the surface.  Its position is updated when the model element is moved.
    this.topSurface = null;

    // @protected {HorizontalSurface|null} - The bottom surface of this model element, the value will be null if
    // this model element can't rest on another surface.
    this.bottomSurface = null;

    // @public (read-only) {ObservableArrayDef.<Bounds2>} - A list of bounds that are used for determining if this model
    // element is in a valid position, i.e. whether it is within the play area and is not overlapping other model
    // elements.  In many cases, this list will contain a single Bounds2 instance, e.g. for a block.  For more elaborate
    // shapes, like a beaker, it may contain several Bounds2 instances.  These bounds are defined relative to the
    // element's position, which by convention in this sim is at the center bottom of the model element.
    this.relativePositionTestingBoundsList = createObservableArray();

    // @public (read-only) {Bounds2[]} - The bounds from relativePositionTestingBoundsList translated to this element's
    // current position.  These are maintained so that they don't have to be recalculated every time we need to test if
    // model elements are overlapping one another.
    this.translatedPositionTestingBoundsList = [];

    // Watch the relative position list and add translated positions and now bounds instances are added.  This listener
    // should only be fired during constructor execution of sub-types, since the bounds list shouldn't be changing after
    // that.
    this.relativePositionTestingBoundsList.addItemAddedListener(positionTestingBounds => {
      this.translatedPositionTestingBoundsList.push(positionTestingBounds.shiftedXY(this.positionProperty.get().x, this.positionProperty.get().y));
    });

    // update the translated bounds when the position changes
    this.positionProperty.link(position => {
      this.translatedPositionTestingBoundsList = this.getBoundsListForPosition(position, this.translatedPositionTestingBoundsList);
    });

    // @public {Vector2} - compensation for evaluating positions of elements that have perspective in the view
    this.perspectiveCompensation = new Vector2(0, 0);
  }

  /**
   * method to test whether this element is stacked upon another, always false for non-movable model elements,
   * override as needed in descendant types
   * @param {ModelElement} element - model element to be checked
   * @returns {boolean}
   * @public
   */
  isStackedUpon(element) {
    return false;
  }

  /**
   * get the bounds list, which represents the model space occupied by this model element, translated to the supplied
   * position
   * @param {Vector2} position
   * @param {Bounds2[]} [boundsList] - can be provided to reduce memory allocations
   * @private
   */
  getBoundsListForPosition(position, boundsList) {
    // allocate a bounds list if not provided
    if (!boundsList) {
      boundsList = [];
      this.relativePositionTestingBoundsList.forEach(bounds => {
        boundsList.push(bounds.copy());
      });
    }

    // parameter checking
    assert && assert(boundsList.length === this.relativePositionTestingBoundsList.length, 'provided bounds list is not the correct size');
    for (let i = 0; i < boundsList.length; i++) {
      const relativeBounds = this.relativePositionTestingBoundsList.get(i);
      boundsList[i].setMinMax(relativeBounds.minX + position.x, relativeBounds.minY + position.y, relativeBounds.maxX + position.x, relativeBounds.maxY + position.y);
    }
    return boundsList;
  }

  /**
   * Reset the model element to its original state. Subclasses must add reset functionality for any state that they
   * add.
   * @public
   */
  reset() {
    this.positionProperty.reset();

    // note - the top and bottom surface Properties are NOT reset here since they are managed by sub-types
  }
}

energyFormsAndChanges.register('ModelElement', ModelElement);
export default ModelElement;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjcmVhdGVPYnNlcnZhYmxlQXJyYXkiLCJWZWN0b3IyIiwiVmVjdG9yMlByb3BlcnR5IiwibWVyZ2UiLCJQaGV0aW9PYmplY3QiLCJUYW5kZW0iLCJJT1R5cGUiLCJSZWZlcmVuY2VJTyIsImVuZXJneUZvcm1zQW5kQ2hhbmdlcyIsIk1vZGVsRWxlbWVudCIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbFBvc2l0aW9uIiwib3B0aW9ucyIsInRhbmRlbSIsIlJFUVVJUkVEIiwicGhldGlvVHlwZSIsIk9iamVjdElPIiwicGhldGlvU3RhdGUiLCJwb3NpdGlvblByb3BlcnR5T3B0aW9ucyIsInVuaXRzIiwicGhldGlvSGlnaEZyZXF1ZW5jeSIsInBoZXRpb0RvY3VtZW50YXRpb24iLCJwb3NpdGlvblByb3BlcnR5IiwiaGFzTGlzdGVuZXJPcmRlckRlcGVuZGVuY2llcyIsImNyZWF0ZVRhbmRlbSIsInRhbmRlbU5hbWUiLCJuYW1lIiwidG9wU3VyZmFjZSIsImJvdHRvbVN1cmZhY2UiLCJyZWxhdGl2ZVBvc2l0aW9uVGVzdGluZ0JvdW5kc0xpc3QiLCJ0cmFuc2xhdGVkUG9zaXRpb25UZXN0aW5nQm91bmRzTGlzdCIsImFkZEl0ZW1BZGRlZExpc3RlbmVyIiwicG9zaXRpb25UZXN0aW5nQm91bmRzIiwicHVzaCIsInNoaWZ0ZWRYWSIsImdldCIsIngiLCJ5IiwibGluayIsInBvc2l0aW9uIiwiZ2V0Qm91bmRzTGlzdEZvclBvc2l0aW9uIiwicGVyc3BlY3RpdmVDb21wZW5zYXRpb24iLCJpc1N0YWNrZWRVcG9uIiwiZWxlbWVudCIsImJvdW5kc0xpc3QiLCJmb3JFYWNoIiwiYm91bmRzIiwiY29weSIsImFzc2VydCIsImxlbmd0aCIsImkiLCJyZWxhdGl2ZUJvdW5kcyIsInNldE1pbk1heCIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJyZXNldCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiTW9kZWxFbGVtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE0LTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBtb2RlbCBlbGVtZW50cyBpbiB0aGUgRW5lcmd5IEZvcm1zIGFuZCBDaGFuZ2VzIHNpbXVsYXRpb24gdGhhdCBjYW4gYmUgbW92ZWQgYXJvdW5kIGJ5IHRoZSB1c2VyLlxyXG4gKiBBdCB0aGUgdGltZSBvZiB0aGlzIHdyaXRpbmcsIHRoaXMgaW5jbHVkZXMgYmxvY2tzLCBiZWFrZXJzLCBidXJuZXJzLCBhbmQgdGhlcm1vbWV0ZXJzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvXHJcbiAqL1xyXG5cclxuaW1wb3J0IGNyZWF0ZU9ic2VydmFibGVBcnJheSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL2NyZWF0ZU9ic2VydmFibGVBcnJheS5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IFZlY3RvcjJQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMlByb3BlcnR5LmpzJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCBQaGV0aW9PYmplY3QgZnJvbSAnLi4vLi4vLi4vLi4vdGFuZGVtL2pzL1BoZXRpb09iamVjdC5qcyc7XHJcbmltcG9ydCBUYW5kZW0gZnJvbSAnLi4vLi4vLi4vLi4vdGFuZGVtL2pzL1RhbmRlbS5qcyc7XHJcbmltcG9ydCBJT1R5cGUgZnJvbSAnLi4vLi4vLi4vLi4vdGFuZGVtL2pzL3R5cGVzL0lPVHlwZS5qcyc7XHJcbmltcG9ydCBSZWZlcmVuY2VJTyBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvUmVmZXJlbmNlSU8uanMnO1xyXG5pbXBvcnQgZW5lcmd5Rm9ybXNBbmRDaGFuZ2VzIGZyb20gJy4uLy4uL2VuZXJneUZvcm1zQW5kQ2hhbmdlcy5qcyc7XHJcblxyXG5jbGFzcyBNb2RlbEVsZW1lbnQgZXh0ZW5kcyBQaGV0aW9PYmplY3Qge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IGluaXRpYWxQb3NpdGlvblxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggaW5pdGlhbFBvc2l0aW9uLCBvcHRpb25zICkge1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG4gICAgICB0YW5kZW06IFRhbmRlbS5SRVFVSVJFRCxcclxuICAgICAgcGhldGlvVHlwZTogUmVmZXJlbmNlSU8oIElPVHlwZS5PYmplY3RJTyApLFxyXG4gICAgICBwaGV0aW9TdGF0ZTogZmFsc2UsXHJcbiAgICAgIHBvc2l0aW9uUHJvcGVydHlPcHRpb25zOiB7XHJcbiAgICAgICAgdW5pdHM6ICdtJyxcclxuICAgICAgICBwaGV0aW9IaWdoRnJlcXVlbmN5OiB0cnVlLFxyXG4gICAgICAgIHBoZXRpb0RvY3VtZW50YXRpb246ICd0aGUgY2VudGVyLWJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCdcclxuICAgICAgfVxyXG4gICAgfSwgb3B0aW9ucyApO1xyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gQHB1YmxpY1xyXG4gICAgdGhpcy5wb3NpdGlvblByb3BlcnR5ID0gbmV3IFZlY3RvcjJQcm9wZXJ0eSggaW5pdGlhbFBvc2l0aW9uLCBtZXJnZSgge1xyXG4gICAgICBoYXNMaXN0ZW5lck9yZGVyRGVwZW5kZW5jaWVzOiB0cnVlLCAvLyBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvZW5lcmd5LWZvcm1zLWFuZC1jaGFuZ2VzL2lzc3Vlcy80MjFcclxuICAgICAgdGFuZGVtOiBvcHRpb25zLnRhbmRlbS5jcmVhdGVUYW5kZW0oICdwb3NpdGlvblByb3BlcnR5JyApXHJcbiAgICB9LCBvcHRpb25zLnBvc2l0aW9uUHJvcGVydHlPcHRpb25zICkgKTtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpXHJcbiAgICB0aGlzLnRhbmRlbU5hbWUgPSBvcHRpb25zLnRhbmRlbS5uYW1lO1xyXG5cclxuICAgIC8vIEBwdWJsaWMge0hvcml6b250YWxTdXJmYWNlfG51bGx9IC0gVGhlIHRvcCBzdXJmYWNlIG9mIHRoaXMgbW9kZWwgZWxlbWVudCwgdGhlIHZhbHVlIHdpbGwgYmVcclxuICAgIC8vIG51bGwgaWYgb3RoZXIgZWxlbWVudHMgY2FuJ3QgcmVzdCB1cG9uIHRoZSBzdXJmYWNlLiAgSXRzIHBvc2l0aW9uIGlzIHVwZGF0ZWQgd2hlbiB0aGUgbW9kZWwgZWxlbWVudCBpcyBtb3ZlZC5cclxuICAgIHRoaXMudG9wU3VyZmFjZSA9IG51bGw7XHJcblxyXG4gICAgLy8gQHByb3RlY3RlZCB7SG9yaXpvbnRhbFN1cmZhY2V8bnVsbH0gLSBUaGUgYm90dG9tIHN1cmZhY2Ugb2YgdGhpcyBtb2RlbCBlbGVtZW50LCB0aGUgdmFsdWUgd2lsbCBiZSBudWxsIGlmXHJcbiAgICAvLyB0aGlzIG1vZGVsIGVsZW1lbnQgY2FuJ3QgcmVzdCBvbiBhbm90aGVyIHN1cmZhY2UuXHJcbiAgICB0aGlzLmJvdHRvbVN1cmZhY2UgPSBudWxsO1xyXG5cclxuICAgIC8vIEBwdWJsaWMgKHJlYWQtb25seSkge09ic2VydmFibGVBcnJheURlZi48Qm91bmRzMj59IC0gQSBsaXN0IG9mIGJvdW5kcyB0aGF0IGFyZSB1c2VkIGZvciBkZXRlcm1pbmluZyBpZiB0aGlzIG1vZGVsXHJcbiAgICAvLyBlbGVtZW50IGlzIGluIGEgdmFsaWQgcG9zaXRpb24sIGkuZS4gd2hldGhlciBpdCBpcyB3aXRoaW4gdGhlIHBsYXkgYXJlYSBhbmQgaXMgbm90IG92ZXJsYXBwaW5nIG90aGVyIG1vZGVsXHJcbiAgICAvLyBlbGVtZW50cy4gIEluIG1hbnkgY2FzZXMsIHRoaXMgbGlzdCB3aWxsIGNvbnRhaW4gYSBzaW5nbGUgQm91bmRzMiBpbnN0YW5jZSwgZS5nLiBmb3IgYSBibG9jay4gIEZvciBtb3JlIGVsYWJvcmF0ZVxyXG4gICAgLy8gc2hhcGVzLCBsaWtlIGEgYmVha2VyLCBpdCBtYXkgY29udGFpbiBzZXZlcmFsIEJvdW5kczIgaW5zdGFuY2VzLiAgVGhlc2UgYm91bmRzIGFyZSBkZWZpbmVkIHJlbGF0aXZlIHRvIHRoZVxyXG4gICAgLy8gZWxlbWVudCdzIHBvc2l0aW9uLCB3aGljaCBieSBjb252ZW50aW9uIGluIHRoaXMgc2ltIGlzIGF0IHRoZSBjZW50ZXIgYm90dG9tIG9mIHRoZSBtb2RlbCBlbGVtZW50LlxyXG4gICAgdGhpcy5yZWxhdGl2ZVBvc2l0aW9uVGVzdGluZ0JvdW5kc0xpc3QgPSBjcmVhdGVPYnNlcnZhYmxlQXJyYXkoKTtcclxuXHJcbiAgICAvLyBAcHVibGljIChyZWFkLW9ubHkpIHtCb3VuZHMyW119IC0gVGhlIGJvdW5kcyBmcm9tIHJlbGF0aXZlUG9zaXRpb25UZXN0aW5nQm91bmRzTGlzdCB0cmFuc2xhdGVkIHRvIHRoaXMgZWxlbWVudCdzXHJcbiAgICAvLyBjdXJyZW50IHBvc2l0aW9uLiAgVGhlc2UgYXJlIG1haW50YWluZWQgc28gdGhhdCB0aGV5IGRvbid0IGhhdmUgdG8gYmUgcmVjYWxjdWxhdGVkIGV2ZXJ5IHRpbWUgd2UgbmVlZCB0byB0ZXN0IGlmXHJcbiAgICAvLyBtb2RlbCBlbGVtZW50cyBhcmUgb3ZlcmxhcHBpbmcgb25lIGFub3RoZXIuXHJcbiAgICB0aGlzLnRyYW5zbGF0ZWRQb3NpdGlvblRlc3RpbmdCb3VuZHNMaXN0ID0gW107XHJcblxyXG4gICAgLy8gV2F0Y2ggdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGxpc3QgYW5kIGFkZCB0cmFuc2xhdGVkIHBvc2l0aW9ucyBhbmQgbm93IGJvdW5kcyBpbnN0YW5jZXMgYXJlIGFkZGVkLiAgVGhpcyBsaXN0ZW5lclxyXG4gICAgLy8gc2hvdWxkIG9ubHkgYmUgZmlyZWQgZHVyaW5nIGNvbnN0cnVjdG9yIGV4ZWN1dGlvbiBvZiBzdWItdHlwZXMsIHNpbmNlIHRoZSBib3VuZHMgbGlzdCBzaG91bGRuJ3QgYmUgY2hhbmdpbmcgYWZ0ZXJcclxuICAgIC8vIHRoYXQuXHJcbiAgICB0aGlzLnJlbGF0aXZlUG9zaXRpb25UZXN0aW5nQm91bmRzTGlzdC5hZGRJdGVtQWRkZWRMaXN0ZW5lciggcG9zaXRpb25UZXN0aW5nQm91bmRzID0+IHtcclxuICAgICAgdGhpcy50cmFuc2xhdGVkUG9zaXRpb25UZXN0aW5nQm91bmRzTGlzdC5wdXNoKFxyXG4gICAgICAgIHBvc2l0aW9uVGVzdGluZ0JvdW5kcy5zaGlmdGVkWFkoIHRoaXMucG9zaXRpb25Qcm9wZXJ0eS5nZXQoKS54LCB0aGlzLnBvc2l0aW9uUHJvcGVydHkuZ2V0KCkueSApXHJcbiAgICAgICk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gdXBkYXRlIHRoZSB0cmFuc2xhdGVkIGJvdW5kcyB3aGVuIHRoZSBwb3NpdGlvbiBjaGFuZ2VzXHJcbiAgICB0aGlzLnBvc2l0aW9uUHJvcGVydHkubGluayggcG9zaXRpb24gPT4ge1xyXG4gICAgICB0aGlzLnRyYW5zbGF0ZWRQb3NpdGlvblRlc3RpbmdCb3VuZHNMaXN0ID0gdGhpcy5nZXRCb3VuZHNMaXN0Rm9yUG9zaXRpb24oXHJcbiAgICAgICAgcG9zaXRpb24sXHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVkUG9zaXRpb25UZXN0aW5nQm91bmRzTGlzdFxyXG4gICAgICApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIEBwdWJsaWMge1ZlY3RvcjJ9IC0gY29tcGVuc2F0aW9uIGZvciBldmFsdWF0aW5nIHBvc2l0aW9ucyBvZiBlbGVtZW50cyB0aGF0IGhhdmUgcGVyc3BlY3RpdmUgaW4gdGhlIHZpZXdcclxuICAgIHRoaXMucGVyc3BlY3RpdmVDb21wZW5zYXRpb24gPSBuZXcgVmVjdG9yMiggMCwgMCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogbWV0aG9kIHRvIHRlc3Qgd2hldGhlciB0aGlzIGVsZW1lbnQgaXMgc3RhY2tlZCB1cG9uIGFub3RoZXIsIGFsd2F5cyBmYWxzZSBmb3Igbm9uLW1vdmFibGUgbW9kZWwgZWxlbWVudHMsXHJcbiAgICogb3ZlcnJpZGUgYXMgbmVlZGVkIGluIGRlc2NlbmRhbnQgdHlwZXNcclxuICAgKiBAcGFyYW0ge01vZGVsRWxlbWVudH0gZWxlbWVudCAtIG1vZGVsIGVsZW1lbnQgdG8gYmUgY2hlY2tlZFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBpc1N0YWNrZWRVcG9uKCBlbGVtZW50ICkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogZ2V0IHRoZSBib3VuZHMgbGlzdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgbW9kZWwgc3BhY2Ugb2NjdXBpZWQgYnkgdGhpcyBtb2RlbCBlbGVtZW50LCB0cmFuc2xhdGVkIHRvIHRoZSBzdXBwbGllZFxyXG4gICAqIHBvc2l0aW9uXHJcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSB7Qm91bmRzMltdfSBbYm91bmRzTGlzdF0gLSBjYW4gYmUgcHJvdmlkZWQgdG8gcmVkdWNlIG1lbW9yeSBhbGxvY2F0aW9uc1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZ2V0Qm91bmRzTGlzdEZvclBvc2l0aW9uKCBwb3NpdGlvbiwgYm91bmRzTGlzdCApIHtcclxuXHJcbiAgICAvLyBhbGxvY2F0ZSBhIGJvdW5kcyBsaXN0IGlmIG5vdCBwcm92aWRlZFxyXG4gICAgaWYgKCAhYm91bmRzTGlzdCApIHtcclxuICAgICAgYm91bmRzTGlzdCA9IFtdO1xyXG4gICAgICB0aGlzLnJlbGF0aXZlUG9zaXRpb25UZXN0aW5nQm91bmRzTGlzdC5mb3JFYWNoKCBib3VuZHMgPT4ge1xyXG4gICAgICAgIGJvdW5kc0xpc3QucHVzaCggYm91bmRzLmNvcHkoKSApO1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcGFyYW1ldGVyIGNoZWNraW5nXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KFxyXG4gICAgICBib3VuZHNMaXN0Lmxlbmd0aCA9PT0gdGhpcy5yZWxhdGl2ZVBvc2l0aW9uVGVzdGluZ0JvdW5kc0xpc3QubGVuZ3RoLFxyXG4gICAgICAncHJvdmlkZWQgYm91bmRzIGxpc3QgaXMgbm90IHRoZSBjb3JyZWN0IHNpemUnXHJcbiAgICApO1xyXG5cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGJvdW5kc0xpc3QubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgIGNvbnN0IHJlbGF0aXZlQm91bmRzID0gdGhpcy5yZWxhdGl2ZVBvc2l0aW9uVGVzdGluZ0JvdW5kc0xpc3QuZ2V0KCBpICk7XHJcbiAgICAgIGJvdW5kc0xpc3RbIGkgXS5zZXRNaW5NYXgoXHJcbiAgICAgICAgcmVsYXRpdmVCb3VuZHMubWluWCArIHBvc2l0aW9uLngsXHJcbiAgICAgICAgcmVsYXRpdmVCb3VuZHMubWluWSArIHBvc2l0aW9uLnksXHJcbiAgICAgICAgcmVsYXRpdmVCb3VuZHMubWF4WCArIHBvc2l0aW9uLngsXHJcbiAgICAgICAgcmVsYXRpdmVCb3VuZHMubWF4WSArIHBvc2l0aW9uLnlcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYm91bmRzTGlzdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSBtb2RlbCBlbGVtZW50IHRvIGl0cyBvcmlnaW5hbCBzdGF0ZS4gU3ViY2xhc3NlcyBtdXN0IGFkZCByZXNldCBmdW5jdGlvbmFsaXR5IGZvciBhbnkgc3RhdGUgdGhhdCB0aGV5XHJcbiAgICogYWRkLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICByZXNldCgpIHtcclxuICAgIHRoaXMucG9zaXRpb25Qcm9wZXJ0eS5yZXNldCgpO1xyXG5cclxuICAgIC8vIG5vdGUgLSB0aGUgdG9wIGFuZCBib3R0b20gc3VyZmFjZSBQcm9wZXJ0aWVzIGFyZSBOT1QgcmVzZXQgaGVyZSBzaW5jZSB0aGV5IGFyZSBtYW5hZ2VkIGJ5IHN1Yi10eXBlc1xyXG4gIH1cclxufVxyXG5cclxuZW5lcmd5Rm9ybXNBbmRDaGFuZ2VzLnJlZ2lzdGVyKCAnTW9kZWxFbGVtZW50JywgTW9kZWxFbGVtZW50ICk7XHJcbmV4cG9ydCBkZWZhdWx0IE1vZGVsRWxlbWVudDsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxxQkFBcUIsTUFBTSw4Q0FBOEM7QUFDaEYsT0FBT0MsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxPQUFPQyxlQUFlLE1BQU0sdUNBQXVDO0FBQ25FLE9BQU9DLEtBQUssTUFBTSxtQ0FBbUM7QUFDckQsT0FBT0MsWUFBWSxNQUFNLHVDQUF1QztBQUNoRSxPQUFPQyxNQUFNLE1BQU0saUNBQWlDO0FBQ3BELE9BQU9DLE1BQU0sTUFBTSx1Q0FBdUM7QUFDMUQsT0FBT0MsV0FBVyxNQUFNLDRDQUE0QztBQUNwRSxPQUFPQyxxQkFBcUIsTUFBTSxnQ0FBZ0M7QUFFbEUsTUFBTUMsWUFBWSxTQUFTTCxZQUFZLENBQUM7RUFFdEM7QUFDRjtBQUNBO0FBQ0E7RUFDRU0sV0FBV0EsQ0FBRUMsZUFBZSxFQUFFQyxPQUFPLEVBQUc7SUFFdENBLE9BQU8sR0FBR1QsS0FBSyxDQUFFO01BQ2ZVLE1BQU0sRUFBRVIsTUFBTSxDQUFDUyxRQUFRO01BQ3ZCQyxVQUFVLEVBQUVSLFdBQVcsQ0FBRUQsTUFBTSxDQUFDVSxRQUFTLENBQUM7TUFDMUNDLFdBQVcsRUFBRSxLQUFLO01BQ2xCQyx1QkFBdUIsRUFBRTtRQUN2QkMsS0FBSyxFQUFFLEdBQUc7UUFDVkMsbUJBQW1CLEVBQUUsSUFBSTtRQUN6QkMsbUJBQW1CLEVBQUU7TUFDdkI7SUFDRixDQUFDLEVBQUVULE9BQVEsQ0FBQztJQUVaLEtBQUssQ0FBRUEsT0FBUSxDQUFDOztJQUVoQjtJQUNBLElBQUksQ0FBQ1UsZ0JBQWdCLEdBQUcsSUFBSXBCLGVBQWUsQ0FBRVMsZUFBZSxFQUFF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