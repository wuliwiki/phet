// Copyright 2014-2022, University of Colorado Boulder

/**
 * Scenery node that represents a beaker in the view. This representation is split between a front node and a back
 * node, which must be separately added to the scene graph. This is done to allow a layering effect. Hence, this cannot
 * be added directly to the scene graph, and the client must add each layer separately.
 *
 * @author John Blanco
 * @author Andrew Adare
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import Matrix3 from '../../../../dot/js/Matrix3.js';
import Transform3 from '../../../../dot/js/Transform3.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import merge from '../../../../phet-core/js/merge.js';
import PhetFont from '../../../../scenery-phet/js/PhetFont.js';
import { Node, Path, Rectangle, RichText } from '../../../../scenery/js/imports.js';
import PhetioObject from '../../../../tandem/js/PhetioObject.js';
import Tandem from '../../../../tandem/js/Tandem.js';
import IOType from '../../../../tandem/js/types/IOType.js';
import ReferenceIO from '../../../../tandem/js/types/ReferenceIO.js';
import energyFormsAndChanges from '../../energyFormsAndChanges.js';
import EnergyFormsAndChangesStrings from '../../EnergyFormsAndChangesStrings.js';
import EnergyChunkContainerSliceNode from '../../intro/view/EnergyChunkContainerSliceNode.js';
import EFACConstants from '../EFACConstants.js';
import EFACQueryParameters from '../EFACQueryParameters.js';
import EnergyChunkNode from './EnergyChunkNode.js';
import PerspectiveWaterNode from './PerspectiveWaterNode.js';
const waterString = EnergyFormsAndChangesStrings.water;

// constants
const OUTLINE_COLOR = 'rgb( 160, 160, 160 )';
const PERSPECTIVE_PROPORTION = -EFACConstants.Z_TO_Y_OFFSET_MULTIPLIER;
const LABEL_FONT = new PhetFont(26);
const BEAKER_COLOR = 'rgba( 250, 250, 250, 0.39 )'; // alpha value chosen empirically
const NUMBER_OF_MINOR_TICKS_PER_MAJOR_TICK = 4; // number of minor ticks between each major tick. Generalize if needed.

class BeakerView extends PhetioObject {
  /**
   * @param {Beaker} beaker - model of a beaker
   * @param {Property.<boolean>} energyChunksVisibleProperty
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Object} [options]
   */
  constructor(beaker, energyChunksVisibleProperty, modelViewTransform, options) {
    options = merge({
      label: waterString,
      // phet-io
      tandem: Tandem.REQUIRED,
      phetioType: ReferenceIO(IOType.ObjectIO),
      phetioState: false
    }, options);
    super(options);

    // @private
    this.modelViewTransform = modelViewTransform;
    this.followPosition = true;

    // @public (read-only) {Node} - layer nodes, public so that they can be layered correctly by the screen view, see
    // the header comment for info about how these are used.
    this.frontNode = new Node();
    this.backNode = new Node();
    this.grabNode = new Node({
      cursor: 'pointer'
    });

    // control the Node properties of all three layers at once
    const visibleProperty = new BooleanProperty(true, {
      tandem: options.tandem.createTandem('visibleProperty')
    });
    visibleProperty.link(visible => {
      this.frontNode.visible = visible;
      this.backNode.visible = visible;
      this.grabNode.visible = visible;
    });

    // extract the scale transform from the MVT so that we can separate the shape from the position
    const scaleTransform = new Transform3(Matrix3.scaling(modelViewTransform.matrix.m00(), modelViewTransform.matrix.m11()));

    // get a Bounds2 object defining the beaker size and position in the view
    const beakerBounds = scaleTransform.transformShape(beaker.getUntransformedBounds());

    // Create the shapes for the top and bottom of the beaker.  These are ellipses in order to create a 3D-ish look.
    const ellipseHeight = beakerBounds.getWidth() * PERSPECTIVE_PROPORTION;
    const beakerHalfWidth = beakerBounds.width / 2;
    const beakerEllipseHalfHeight = ellipseHeight / 2;
    const topEllipse = new Shape().ellipse(beakerBounds.centerX, beakerBounds.minY, beakerHalfWidth, beakerEllipseHalfHeight, 0);
    const bottomEllipse = new Shape().ellipse(beakerBounds.centerX, beakerBounds.maxY, beakerHalfWidth, beakerEllipseHalfHeight, 0);

    // @private - Add the fluid.  It will adjust its size based on the fluid level.
    this.fluid = new PerspectiveWaterNode(beakerBounds, beaker.fluidProportionProperty, beaker.temperatureProperty, beaker.fluidBoilingPoint, beaker.fluidColor, beaker.steamColor);
    this.frontNode.addChild(this.fluid);

    // create and add the node for the body of the beaker
    const beakerBody = new Shape().moveTo(beakerBounds.minX, beakerBounds.minY) // Top left of the beaker body.
    .ellipticalArc(beakerBounds.centerX, beakerBounds.minY, beakerHalfWidth, beakerEllipseHalfHeight, 0, Math.PI, 0, true).lineTo(beakerBounds.maxX, beakerBounds.maxY) // Bottom right of the beaker body.
    .ellipticalArc(beakerBounds.centerX, beakerBounds.maxY, beakerHalfWidth, beakerEllipseHalfHeight, 0, 0, Math.PI, false).close();
    this.frontNode.addChild(new Path(beakerBody, {
      fill: BEAKER_COLOR,
      lineWidth: 3,
      stroke: OUTLINE_COLOR
    }));

    // vars used for drawing the tick marks
    const numberOfMajorTicks = Math.floor(beaker.height / beaker.majorTickMarkDistance);
    const numberOfTicks = numberOfMajorTicks * (NUMBER_OF_MINOR_TICKS_PER_MAJOR_TICK + 1); // total number of ticks
    const majorTickLengthAngle = 0.13 * Math.PI; // empirically determined
    const minorTickLengthAngle = majorTickLengthAngle / 2; // empirically determined
    const spaceBetweenEachTickMark = Math.abs(modelViewTransform.modelToViewDeltaY(beaker.majorTickMarkDistance) / (NUMBER_OF_MINOR_TICKS_PER_MAJOR_TICK + 1));

    // x-distance between the left edge of the beaker and the start of the ticks along an ellipse, in radians
    const xOriginAngle = 0.1 * Math.PI;
    let yPosition = beakerBounds.maxY;

    // create the tick marks shape
    const tickMarks = new Shape().moveTo(beakerBounds.minX, beakerBounds.maxY); // bottom left of the beaker body

    // draw the tick marks
    for (let tickIndex = 0; tickIndex < numberOfTicks; tickIndex++) {
      yPosition -= spaceBetweenEachTickMark;
      const startAngle = Math.PI - xOriginAngle;
      const tickLengthAngle = (tickIndex + 1) % (NUMBER_OF_MINOR_TICKS_PER_MAJOR_TICK + 1) === 0 ? majorTickLengthAngle : minorTickLengthAngle;
      const endAngle = startAngle - tickLengthAngle;
      tickMarks.newSubpath(); // don't connect the tick marks with additional lines
      tickMarks.ellipticalArc(beakerBounds.centerX, yPosition, beakerHalfWidth, beakerEllipseHalfHeight, 0, startAngle, endAngle, true);
    }

    // add the tick marks
    this.frontNode.addChild(new Path(tickMarks, {
      lineWidth: 1,
      stroke: 'black'
    }));

    // add the bottom ellipse
    this.backNode.addChild(new Path(bottomEllipse, {
      fill: BEAKER_COLOR,
      lineWidth: 3,
      stroke: OUTLINE_COLOR
    }));

    // Add the top ellipse.  It is behind the water for proper Z-order behavior.
    this.backNode.addChild(new Path(topEllipse, {
      fill: BEAKER_COLOR,
      stroke: OUTLINE_COLOR,
      lineWidth: 3
    }));

    // add a rectangle to the back that is invisible but allows the user to grab the beaker
    this.backNode.addChild(new Rectangle(beakerBounds, {
      fill: 'rgba( 0, 0, 0, 0 )'
    }));

    // Make the front and back nodes non-pickable so that the grab node can be used for grabbing. This makes it possible
    // to remove things from the beaker.
    this.frontNode.pickable = false;
    this.backNode.pickable = false;

    // add the label, positioning it just below the front, top water line
    const labelText = new RichText(options.label, {
      font: LABEL_FONT,
      maxWidth: beakerBounds.width * 0.7,
      // empirically determined to look nice
      tandem: options.tandem.createTandem('labelText'),
      phetioVisiblePropertyInstrumented: true
    });
    labelText.translation = new Vector2(beakerBounds.centerX - labelText.bounds.width / 2, beakerBounds.maxY - beakerBounds.height * beaker.fluidProportionProperty.value + topEllipse.bounds.height * 1.1);
    labelText.pickable = false;
    this.frontNode.addChild(labelText);

    // @protected {Node} - the layer where the contained energy chunk nodes will be placed
    this.energyChunkRootNode = new Node();
    this.backNode.addChild(this.energyChunkRootNode);

    // add the energy chunk container slice nodes to the energy chunk layer
    beaker.slices.forEach(slice => {
      this.energyChunkRootNode.addChild(new EnergyChunkContainerSliceNode(slice, modelViewTransform));
    });

    // Watch for coming and going of energy chunks that are approaching this model element and add/remove them as
    // needed.
    beaker.approachingEnergyChunks.addItemAddedListener(addedEnergyChunk => {
      const energyChunkNode = new EnergyChunkNode(addedEnergyChunk, modelViewTransform);
      this.energyChunkRootNode.addChild(energyChunkNode);
      const removalListener = removedEnergyChunk => {
        if (removedEnergyChunk === addedEnergyChunk) {
          this.energyChunkRootNode.removeChild(energyChunkNode);
          energyChunkNode.dispose();
          beaker.approachingEnergyChunks.removeItemRemovedListener(removalListener);
        }
      };
      beaker.approachingEnergyChunks.addItemRemovedListener(removalListener);
    });

    // add the node that can be used to grab and move the beaker
    const grabNodeShape = beakerBody;
    this.grabNode.addChild(new Path(grabNodeShape, {
      fill: 'rgba( 0, 0, 0, 0 )'
    })); // invisible, yet pickable
    this.grabNode.addChild(new Path(topEllipse, {
      fill: 'rgba( 0, 0, 0, 0 )'
    }));

    // if enabled (for debug), show the outline of the rectangle that represents the beaker's position in the model
    if (EFACQueryParameters.show2DBeakerBounds) {
      this.frontNode.addChild(new Rectangle(beakerBounds, {
        fill: 'red',
        stroke: 'lime',
        lineWidth: 2
      }));
    }

    // update the offset if and when the model position changes
    beaker.positionProperty.link(position => {
      if (this.followPosition) {
        const offset = modelViewTransform.modelToViewPosition(position);
        this.frontNode.translation = offset;
        this.backNode.translation = offset;
        this.grabNode.translation = offset;
      }

      // compensate the energy chunk layer so that the energy chunk nodes can handle their own positioning
      this.energyChunkRootNode.translation = modelViewTransform.modelToViewPosition(position).rotated(Math.PI);
    });

    // adjust the transparency of the water and label based on energy chunk visibility
    energyChunksVisibleProperty.link(energyChunksVisible => {
      labelText.opacity = energyChunksVisible ? 0.5 : 1;
      const opacity = EFACConstants.NOMINAL_WATER_OPACITY;
      this.fluid.opacity = energyChunksVisible ? opacity * 0.75 : opacity;
    });

    // reset this node if the beaker it represents gets reset
    beaker.resetInProgressProperty.lazyLink(resetInProgress => {
      // reset this view node at the end of the beaker's reset, since it should be in a reasonable state at that point
      if (!resetInProgress) {
        this.reset();
      }
    });
  }

  /**
   * @public
   */
  reset() {
    this.fluid.reset();
  }

  /**
   * step this view element
   * @param dt - time step, in seconds
   * @public
   */
  step(dt) {
    this.fluid.step(dt);
  }

  /**
   * set whether this node should follow its beaker position. this is useful for the case where its parent node is
   * handling its position
   * @param {boolean} followPosition
   * @public
   */
  setFollowPosition(followPosition) {
    this.followPosition = followPosition;
  }

  /**
   * moves all layers to the front of their respective node layers
   * @public
   */
  moveToFront() {
    this.backNode.moveToFront();
    this.frontNode.moveToFront();
    this.grabNode.moveToFront();
  }
}
energyFormsAndChanges.register('BeakerView', BeakerView);
export default BeakerView;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJNYXRyaXgzIiwiVHJhbnNmb3JtMyIsIlZlY3RvcjIiLCJTaGFwZSIsIm1lcmdlIiwiUGhldEZvbnQiLCJOb2RlIiwiUGF0aCIsIlJlY3RhbmdsZSIsIlJpY2hUZXh0IiwiUGhldGlvT2JqZWN0IiwiVGFuZGVtIiwiSU9UeXBlIiwiUmVmZXJlbmNlSU8iLCJlbmVyZ3lGb3Jtc0FuZENoYW5nZXMiLCJFbmVyZ3lGb3Jtc0FuZENoYW5nZXNTdHJpbmdzIiwiRW5lcmd5Q2h1bmtDb250YWluZXJTbGljZU5vZGUiLCJFRkFDQ29uc3RhbnRzIiwiRUZBQ1F1ZXJ5UGFyYW1ldGVycyIsIkVuZXJneUNodW5rTm9kZSIsIlBlcnNwZWN0aXZlV2F0ZXJOb2RlIiwid2F0ZXJTdHJpbmciLCJ3YXRlciIsIk9VVExJTkVfQ09MT1IiLCJQRVJTUEVDVElWRV9QUk9QT1JUSU9OIiwiWl9UT19ZX09GRlNFVF9NVUxUSVBMSUVSIiwiTEFCRUxfRk9OVCIsIkJFQUtFUl9DT0xPUiIsIk5VTUJFUl9PRl9NSU5PUl9USUNLU19QRVJfTUFKT1JfVElDSyIsIkJlYWtlclZpZXciLCJjb25zdHJ1Y3RvciIsImJlYWtlciIsImVuZXJneUNodW5rc1Zpc2libGVQcm9wZXJ0eSIsIm1vZGVsVmlld1RyYW5zZm9ybSIsIm9wdGlvbnMiLCJsYWJlbCIsInRhbmRlbSIsIlJFUVVJUkVEIiwicGhldGlvVHlwZSIsIk9iamVjdElPIiwicGhldGlvU3RhdGUiLCJmb2xsb3dQb3NpdGlvbiIsImZyb250Tm9kZSIsImJhY2tOb2RlIiwiZ3JhYk5vZGUiLCJjdXJzb3IiLCJ2aXNpYmxlUHJvcGVydHkiLCJjcmVhdGVUYW5kZW0iLCJsaW5rIiwidmlzaWJsZSIsInNjYWxlVHJhbnNmb3JtIiwic2NhbGluZyIsIm1hdHJpeCIsIm0wMCIsIm0xMSIsImJlYWtlckJvdW5kcyIsInRyYW5zZm9ybVNoYXBlIiwiZ2V0VW50cmFuc2Zvcm1lZEJvdW5kcyIsImVsbGlwc2VIZWlnaHQiLCJnZXRXaWR0aCIsImJlYWtlckhhbGZXaWR0aCIsIndpZHRoIiwiYmVha2VyRWxsaXBzZUhhbGZIZWlnaHQiLCJ0b3BFbGxpcHNlIiwiZWxsaXBzZSIsImNlbnRlclgiLCJtaW5ZIiwiYm90dG9tRWxsaXBzZSIsIm1heFkiLCJmbHVpZCIsImZsdWlkUHJvcG9ydGlvblByb3BlcnR5IiwidGVtcGVyYXR1cmVQcm9wZXJ0eSIsImZsdWlkQm9pbGluZ1BvaW50IiwiZmx1aWRDb2xvciIsInN0ZWFtQ29sb3IiLCJhZGRDaGlsZCIsImJlYWtlckJvZHkiLCJtb3ZlVG8iLCJtaW5YIiwiZWxsaXB0aWNhbEFyYyIsIk1hdGgiLCJQSSIsImxpbmVUbyIsIm1heFgiLCJjbG9zZSIsImZpbGwiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJudW1iZXJPZk1ham9yVGlja3MiLCJmbG9vciIsImhlaWdodCIsIm1ham9yVGlja01hcmtEaXN0YW5jZSIsIm51bWJlck9mVGlja3MiLCJtYWpvclRpY2tMZW5ndGhBbmdsZSIsIm1pbm9yVGlja0xlbmd0aEFuZ2xlIiwic3BhY2VCZXR3ZWVuRWFjaFRpY2tNYXJrIiwiYWJzIiwibW9kZWxUb1ZpZXdEZWx0YVkiLCJ4T3JpZ2luQW5nbGUiLCJ5UG9zaXRpb24iLCJ0aWNrTWFya3MiLCJ0aWNrSW5kZXgiLCJzdGFydEFuZ2xlIiwidGlja0xlbmd0aEFuZ2xlIiwiZW5kQW5nbGUiLCJuZXdTdWJwYXRoIiwicGlja2FibGUiLCJsYWJlbFRleHQiLCJmb250IiwibWF4V2lkdGgiLCJwaGV0aW9WaXNpYmxlUHJvcGVydHlJbnN0cnVtZW50ZWQiLCJ0cmFuc2xhdGlvbiIsImJvdW5kcyIsInZhbHVlIiwiZW5lcmd5Q2h1bmtSb290Tm9kZSIsInNsaWNlcyIsImZvckVhY2giLCJzbGljZSIsImFwcHJvYWNoaW5nRW5lcmd5Q2h1bmtzIiwiYWRkSXRlbUFkZGVkTGlzdGVuZXIiLCJhZGRlZEVuZXJneUNodW5rIiwiZW5lcmd5Q2h1bmtOb2RlIiwicmVtb3ZhbExpc3RlbmVyIiwicmVtb3ZlZEVuZXJneUNodW5rIiwicmVtb3ZlQ2hpbGQiLCJkaXNwb3NlIiwicmVtb3ZlSXRlbVJlbW92ZWRMaXN0ZW5lciIsImFkZEl0ZW1SZW1vdmVkTGlzdGVuZXIiLCJncmFiTm9kZVNoYXBlIiwic2hvdzJEQmVha2VyQm91bmRzIiwicG9zaXRpb25Qcm9wZXJ0eSIsInBvc2l0aW9uIiwib2Zmc2V0IiwibW9kZWxUb1ZpZXdQb3NpdGlvbiIsInJvdGF0ZWQiLCJlbmVyZ3lDaHVua3NWaXNpYmxlIiwib3BhY2l0eSIsIk5PTUlOQUxfV0FURVJfT1BBQ0lUWSIsInJlc2V0SW5Qcm9ncmVzc1Byb3BlcnR5IiwibGF6eUxpbmsiLCJyZXNldEluUHJvZ3Jlc3MiLCJyZXNldCIsInN0ZXAiLCJkdCIsInNldEZvbGxvd1Bvc2l0aW9uIiwibW92ZVRvRnJvbnQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkJlYWtlclZpZXcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTQtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogU2NlbmVyeSBub2RlIHRoYXQgcmVwcmVzZW50cyBhIGJlYWtlciBpbiB0aGUgdmlldy4gVGhpcyByZXByZXNlbnRhdGlvbiBpcyBzcGxpdCBiZXR3ZWVuIGEgZnJvbnQgbm9kZSBhbmQgYSBiYWNrXHJcbiAqIG5vZGUsIHdoaWNoIG11c3QgYmUgc2VwYXJhdGVseSBhZGRlZCB0byB0aGUgc2NlbmUgZ3JhcGguIFRoaXMgaXMgZG9uZSB0byBhbGxvdyBhIGxheWVyaW5nIGVmZmVjdC4gSGVuY2UsIHRoaXMgY2Fubm90XHJcbiAqIGJlIGFkZGVkIGRpcmVjdGx5IHRvIHRoZSBzY2VuZSBncmFwaCwgYW5kIHRoZSBjbGllbnQgbXVzdCBhZGQgZWFjaCBsYXllciBzZXBhcmF0ZWx5LlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvXHJcbiAqIEBhdXRob3IgQW5kcmV3IEFkYXJlXHJcbiAqL1xyXG5cclxuaW1wb3J0IEJvb2xlYW5Qcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL0Jvb2xlYW5Qcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBNYXRyaXgzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9NYXRyaXgzLmpzJztcclxuaW1wb3J0IFRyYW5zZm9ybTMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1RyYW5zZm9ybTMuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy9tZXJnZS5qcyc7XHJcbmltcG9ydCBQaGV0Rm9udCBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvUGhldEZvbnQuanMnO1xyXG5pbXBvcnQgeyBOb2RlLCBQYXRoLCBSZWN0YW5nbGUsIFJpY2hUZXh0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IFBoZXRpb09iamVjdCBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvUGhldGlvT2JqZWN0LmpzJztcclxuaW1wb3J0IFRhbmRlbSBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvVGFuZGVtLmpzJztcclxuaW1wb3J0IElPVHlwZSBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvSU9UeXBlLmpzJztcclxuaW1wb3J0IFJlZmVyZW5jZUlPIGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy90eXBlcy9SZWZlcmVuY2VJTy5qcyc7XHJcbmltcG9ydCBlbmVyZ3lGb3Jtc0FuZENoYW5nZXMgZnJvbSAnLi4vLi4vZW5lcmd5Rm9ybXNBbmRDaGFuZ2VzLmpzJztcclxuaW1wb3J0IEVuZXJneUZvcm1zQW5kQ2hhbmdlc1N0cmluZ3MgZnJvbSAnLi4vLi4vRW5lcmd5Rm9ybXNBbmRDaGFuZ2VzU3RyaW5ncy5qcyc7XHJcbmltcG9ydCBFbmVyZ3lDaHVua0NvbnRhaW5lclNsaWNlTm9kZSBmcm9tICcuLi8uLi9pbnRyby92aWV3L0VuZXJneUNodW5rQ29udGFpbmVyU2xpY2VOb2RlLmpzJztcclxuaW1wb3J0IEVGQUNDb25zdGFudHMgZnJvbSAnLi4vRUZBQ0NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBFRkFDUXVlcnlQYXJhbWV0ZXJzIGZyb20gJy4uL0VGQUNRdWVyeVBhcmFtZXRlcnMuanMnO1xyXG5pbXBvcnQgRW5lcmd5Q2h1bmtOb2RlIGZyb20gJy4vRW5lcmd5Q2h1bmtOb2RlLmpzJztcclxuaW1wb3J0IFBlcnNwZWN0aXZlV2F0ZXJOb2RlIGZyb20gJy4vUGVyc3BlY3RpdmVXYXRlck5vZGUuanMnO1xyXG5cclxuY29uc3Qgd2F0ZXJTdHJpbmcgPSBFbmVyZ3lGb3Jtc0FuZENoYW5nZXNTdHJpbmdzLndhdGVyO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IE9VVExJTkVfQ09MT1IgPSAncmdiKCAxNjAsIDE2MCwgMTYwICknO1xyXG5jb25zdCBQRVJTUEVDVElWRV9QUk9QT1JUSU9OID0gLUVGQUNDb25zdGFudHMuWl9UT19ZX09GRlNFVF9NVUxUSVBMSUVSO1xyXG5jb25zdCBMQUJFTF9GT05UID0gbmV3IFBoZXRGb250KCAyNiApO1xyXG5jb25zdCBCRUFLRVJfQ09MT1IgPSAncmdiYSggMjUwLCAyNTAsIDI1MCwgMC4zOSApJzsgLy8gYWxwaGEgdmFsdWUgY2hvc2VuIGVtcGlyaWNhbGx5XHJcbmNvbnN0IE5VTUJFUl9PRl9NSU5PUl9USUNLU19QRVJfTUFKT1JfVElDSyA9IDQ7IC8vIG51bWJlciBvZiBtaW5vciB0aWNrcyBiZXR3ZWVuIGVhY2ggbWFqb3IgdGljay4gR2VuZXJhbGl6ZSBpZiBuZWVkZWQuXHJcblxyXG5jbGFzcyBCZWFrZXJWaWV3IGV4dGVuZHMgUGhldGlvT2JqZWN0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtCZWFrZXJ9IGJlYWtlciAtIG1vZGVsIG9mIGEgYmVha2VyXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eS48Ym9vbGVhbj59IGVuZXJneUNodW5rc1Zpc2libGVQcm9wZXJ0eVxyXG4gICAqIEBwYXJhbSB7TW9kZWxWaWV3VHJhbnNmb3JtMn0gbW9kZWxWaWV3VHJhbnNmb3JtXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBiZWFrZXIsIGVuZXJneUNodW5rc1Zpc2libGVQcm9wZXJ0eSwgbW9kZWxWaWV3VHJhbnNmb3JtLCBvcHRpb25zICkge1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG4gICAgICBsYWJlbDogd2F0ZXJTdHJpbmcsXHJcblxyXG4gICAgICAvLyBwaGV0LWlvXHJcbiAgICAgIHRhbmRlbTogVGFuZGVtLlJFUVVJUkVELFxyXG4gICAgICBwaGV0aW9UeXBlOiBSZWZlcmVuY2VJTyggSU9UeXBlLk9iamVjdElPICksXHJcbiAgICAgIHBoZXRpb1N0YXRlOiBmYWxzZVxyXG4gICAgfSwgb3B0aW9ucyApO1xyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gQHByaXZhdGVcclxuICAgIHRoaXMubW9kZWxWaWV3VHJhbnNmb3JtID0gbW9kZWxWaWV3VHJhbnNmb3JtO1xyXG4gICAgdGhpcy5mb2xsb3dQb3NpdGlvbiA9IHRydWU7XHJcblxyXG4gICAgLy8gQHB1YmxpYyAocmVhZC1vbmx5KSB7Tm9kZX0gLSBsYXllciBub2RlcywgcHVibGljIHNvIHRoYXQgdGhleSBjYW4gYmUgbGF5ZXJlZCBjb3JyZWN0bHkgYnkgdGhlIHNjcmVlbiB2aWV3LCBzZWVcclxuICAgIC8vIHRoZSBoZWFkZXIgY29tbWVudCBmb3IgaW5mbyBhYm91dCBob3cgdGhlc2UgYXJlIHVzZWQuXHJcbiAgICB0aGlzLmZyb250Tm9kZSA9IG5ldyBOb2RlKCk7XHJcbiAgICB0aGlzLmJhY2tOb2RlID0gbmV3IE5vZGUoKTtcclxuICAgIHRoaXMuZ3JhYk5vZGUgPSBuZXcgTm9kZSggeyBjdXJzb3I6ICdwb2ludGVyJyB9ICk7XHJcblxyXG4gICAgLy8gY29udHJvbCB0aGUgTm9kZSBwcm9wZXJ0aWVzIG9mIGFsbCB0aHJlZSBsYXllcnMgYXQgb25jZVxyXG4gICAgY29uc3QgdmlzaWJsZVByb3BlcnR5ID0gbmV3IEJvb2xlYW5Qcm9wZXJ0eSggdHJ1ZSwge1xyXG4gICAgICB0YW5kZW06IG9wdGlvbnMudGFuZGVtLmNyZWF0ZVRhbmRlbSggJ3Zpc2libGVQcm9wZXJ0eScgKVxyXG4gICAgfSApO1xyXG4gICAgdmlzaWJsZVByb3BlcnR5LmxpbmsoIHZpc2libGUgPT4ge1xyXG4gICAgICB0aGlzLmZyb250Tm9kZS52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgdGhpcy5iYWNrTm9kZS52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgdGhpcy5ncmFiTm9kZS52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBleHRyYWN0IHRoZSBzY2FsZSB0cmFuc2Zvcm0gZnJvbSB0aGUgTVZUIHNvIHRoYXQgd2UgY2FuIHNlcGFyYXRlIHRoZSBzaGFwZSBmcm9tIHRoZSBwb3NpdGlvblxyXG4gICAgY29uc3Qgc2NhbGVUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtMyhcclxuICAgICAgTWF0cml4My5zY2FsaW5nKCBtb2RlbFZpZXdUcmFuc2Zvcm0ubWF0cml4Lm0wMCgpLCBtb2RlbFZpZXdUcmFuc2Zvcm0ubWF0cml4Lm0xMSgpIClcclxuICAgICk7XHJcblxyXG4gICAgLy8gZ2V0IGEgQm91bmRzMiBvYmplY3QgZGVmaW5pbmcgdGhlIGJlYWtlciBzaXplIGFuZCBwb3NpdGlvbiBpbiB0aGUgdmlld1xyXG4gICAgY29uc3QgYmVha2VyQm91bmRzID0gc2NhbGVUcmFuc2Zvcm0udHJhbnNmb3JtU2hhcGUoIGJlYWtlci5nZXRVbnRyYW5zZm9ybWVkQm91bmRzKCkgKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIHNoYXBlcyBmb3IgdGhlIHRvcCBhbmQgYm90dG9tIG9mIHRoZSBiZWFrZXIuICBUaGVzZSBhcmUgZWxsaXBzZXMgaW4gb3JkZXIgdG8gY3JlYXRlIGEgM0QtaXNoIGxvb2suXHJcbiAgICBjb25zdCBlbGxpcHNlSGVpZ2h0ID0gYmVha2VyQm91bmRzLmdldFdpZHRoKCkgKiBQRVJTUEVDVElWRV9QUk9QT1JUSU9OO1xyXG4gICAgY29uc3QgYmVha2VySGFsZldpZHRoID0gYmVha2VyQm91bmRzLndpZHRoIC8gMjtcclxuICAgIGNvbnN0IGJlYWtlckVsbGlwc2VIYWxmSGVpZ2h0ID0gZWxsaXBzZUhlaWdodCAvIDI7XHJcbiAgICBjb25zdCB0b3BFbGxpcHNlID0gbmV3IFNoYXBlKCkuZWxsaXBzZSggYmVha2VyQm91bmRzLmNlbnRlclgsIGJlYWtlckJvdW5kcy5taW5ZLCBiZWFrZXJIYWxmV2lkdGgsIGJlYWtlckVsbGlwc2VIYWxmSGVpZ2h0LCAwICk7XHJcbiAgICBjb25zdCBib3R0b21FbGxpcHNlID0gbmV3IFNoYXBlKCkuZWxsaXBzZSggYmVha2VyQm91bmRzLmNlbnRlclgsIGJlYWtlckJvdW5kcy5tYXhZLCBiZWFrZXJIYWxmV2lkdGgsIGJlYWtlckVsbGlwc2VIYWxmSGVpZ2h0LCAwICk7XHJcblxyXG4gICAgLy8gQHByaXZhdGUgLSBBZGQgdGhlIGZsdWlkLiAgSXQgd2lsbCBhZGp1c3QgaXRzIHNpemUgYmFzZWQgb24gdGhlIGZsdWlkIGxldmVsLlxyXG4gICAgdGhpcy5mbHVpZCA9IG5ldyBQZXJzcGVjdGl2ZVdhdGVyTm9kZShcclxuICAgICAgYmVha2VyQm91bmRzLFxyXG4gICAgICBiZWFrZXIuZmx1aWRQcm9wb3J0aW9uUHJvcGVydHksXHJcbiAgICAgIGJlYWtlci50ZW1wZXJhdHVyZVByb3BlcnR5LFxyXG4gICAgICBiZWFrZXIuZmx1aWRCb2lsaW5nUG9pbnQsXHJcbiAgICAgIGJlYWtlci5mbHVpZENvbG9yLFxyXG4gICAgICBiZWFrZXIuc3RlYW1Db2xvclxyXG4gICAgKTtcclxuICAgIHRoaXMuZnJvbnROb2RlLmFkZENoaWxkKCB0aGlzLmZsdWlkICk7XHJcblxyXG4gICAgLy8gY3JlYXRlIGFuZCBhZGQgdGhlIG5vZGUgZm9yIHRoZSBib2R5IG9mIHRoZSBiZWFrZXJcclxuICAgIGNvbnN0IGJlYWtlckJvZHkgPSBuZXcgU2hhcGUoKVxyXG4gICAgICAubW92ZVRvKCBiZWFrZXJCb3VuZHMubWluWCwgYmVha2VyQm91bmRzLm1pblkgKSAvLyBUb3AgbGVmdCBvZiB0aGUgYmVha2VyIGJvZHkuXHJcbiAgICAgIC5lbGxpcHRpY2FsQXJjKCBiZWFrZXJCb3VuZHMuY2VudGVyWCwgYmVha2VyQm91bmRzLm1pblksIGJlYWtlckhhbGZXaWR0aCwgYmVha2VyRWxsaXBzZUhhbGZIZWlnaHQsIDAsIE1hdGguUEksIDAsIHRydWUgKVxyXG4gICAgICAubGluZVRvKCBiZWFrZXJCb3VuZHMubWF4WCwgYmVha2VyQm91bmRzLm1heFkgKSAvLyBCb3R0b20gcmlnaHQgb2YgdGhlIGJlYWtlciBib2R5LlxyXG4gICAgICAuZWxsaXB0aWNhbEFyYyggYmVha2VyQm91bmRzLmNlbnRlclgsIGJlYWtlckJvdW5kcy5tYXhZLCBiZWFrZXJIYWxmV2lkdGgsIGJlYWtlckVsbGlwc2VIYWxmSGVpZ2h0LCAwLCAwLCBNYXRoLlBJLCBmYWxzZSApXHJcbiAgICAgIC5jbG9zZSgpO1xyXG5cclxuICAgIHRoaXMuZnJvbnROb2RlLmFkZENoaWxkKCBuZXcgUGF0aCggYmVha2VyQm9keSwge1xyXG4gICAgICBmaWxsOiBCRUFLRVJfQ09MT1IsXHJcbiAgICAgIGxpbmVXaWR0aDogMyxcclxuICAgICAgc3Ryb2tlOiBPVVRMSU5FX0NPTE9SXHJcbiAgICB9ICkgKTtcclxuXHJcbiAgICAvLyB2YXJzIHVzZWQgZm9yIGRyYXdpbmcgdGhlIHRpY2sgbWFya3NcclxuICAgIGNvbnN0IG51bWJlck9mTWFqb3JUaWNrcyA9IE1hdGguZmxvb3IoIGJlYWtlci5oZWlnaHQgLyBiZWFrZXIubWFqb3JUaWNrTWFya0Rpc3RhbmNlICk7XHJcbiAgICBjb25zdCBudW1iZXJPZlRpY2tzID0gbnVtYmVyT2ZNYWpvclRpY2tzICogKCBOVU1CRVJfT0ZfTUlOT1JfVElDS1NfUEVSX01BSk9SX1RJQ0sgKyAxICk7IC8vIHRvdGFsIG51bWJlciBvZiB0aWNrc1xyXG4gICAgY29uc3QgbWFqb3JUaWNrTGVuZ3RoQW5nbGUgPSAwLjEzICogTWF0aC5QSTsgLy8gZW1waXJpY2FsbHkgZGV0ZXJtaW5lZFxyXG4gICAgY29uc3QgbWlub3JUaWNrTGVuZ3RoQW5nbGUgPSBtYWpvclRpY2tMZW5ndGhBbmdsZSAvIDI7IC8vIGVtcGlyaWNhbGx5IGRldGVybWluZWRcclxuICAgIGNvbnN0IHNwYWNlQmV0d2VlbkVhY2hUaWNrTWFyayA9IE1hdGguYWJzKCBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdEZWx0YVkoIGJlYWtlci5tYWpvclRpY2tNYXJrRGlzdGFuY2UgKSAvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBOVU1CRVJfT0ZfTUlOT1JfVElDS1NfUEVSX01BSk9SX1RJQ0sgKyAxICkgKTtcclxuXHJcbiAgICAvLyB4LWRpc3RhbmNlIGJldHdlZW4gdGhlIGxlZnQgZWRnZSBvZiB0aGUgYmVha2VyIGFuZCB0aGUgc3RhcnQgb2YgdGhlIHRpY2tzIGFsb25nIGFuIGVsbGlwc2UsIGluIHJhZGlhbnNcclxuICAgIGNvbnN0IHhPcmlnaW5BbmdsZSA9IDAuMSAqIE1hdGguUEk7XHJcbiAgICBsZXQgeVBvc2l0aW9uID0gYmVha2VyQm91bmRzLm1heFk7XHJcblxyXG4gICAgLy8gY3JlYXRlIHRoZSB0aWNrIG1hcmtzIHNoYXBlXHJcbiAgICBjb25zdCB0aWNrTWFya3MgPSBuZXcgU2hhcGUoKS5tb3ZlVG8oIGJlYWtlckJvdW5kcy5taW5YLCBiZWFrZXJCb3VuZHMubWF4WSApOyAvLyBib3R0b20gbGVmdCBvZiB0aGUgYmVha2VyIGJvZHlcclxuXHJcbiAgICAvLyBkcmF3IHRoZSB0aWNrIG1hcmtzXHJcbiAgICBmb3IgKCBsZXQgdGlja0luZGV4ID0gMDsgdGlja0luZGV4IDwgbnVtYmVyT2ZUaWNrczsgdGlja0luZGV4KysgKSB7XHJcbiAgICAgIHlQb3NpdGlvbiAtPSBzcGFjZUJldHdlZW5FYWNoVGlja01hcms7XHJcbiAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBNYXRoLlBJIC0geE9yaWdpbkFuZ2xlO1xyXG4gICAgICBjb25zdCB0aWNrTGVuZ3RoQW5nbGUgPSAoIHRpY2tJbmRleCArIDEgKSAlICggTlVNQkVSX09GX01JTk9SX1RJQ0tTX1BFUl9NQUpPUl9USUNLICsgMSApID09PSAwID8gbWFqb3JUaWNrTGVuZ3RoQW5nbGUgOiBtaW5vclRpY2tMZW5ndGhBbmdsZTtcclxuICAgICAgY29uc3QgZW5kQW5nbGUgPSBzdGFydEFuZ2xlIC0gdGlja0xlbmd0aEFuZ2xlO1xyXG5cclxuICAgICAgdGlja01hcmtzLm5ld1N1YnBhdGgoKTsgLy8gZG9uJ3QgY29ubmVjdCB0aGUgdGljayBtYXJrcyB3aXRoIGFkZGl0aW9uYWwgbGluZXNcclxuICAgICAgdGlja01hcmtzLmVsbGlwdGljYWxBcmMoXHJcbiAgICAgICAgYmVha2VyQm91bmRzLmNlbnRlclgsXHJcbiAgICAgICAgeVBvc2l0aW9uLFxyXG4gICAgICAgIGJlYWtlckhhbGZXaWR0aCxcclxuICAgICAgICBiZWFrZXJFbGxpcHNlSGFsZkhlaWdodCxcclxuICAgICAgICAwLFxyXG4gICAgICAgIHN0YXJ0QW5nbGUsXHJcbiAgICAgICAgZW5kQW5nbGUsXHJcbiAgICAgICAgdHJ1ZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCB0aGUgdGljayBtYXJrc1xyXG4gICAgdGhpcy5mcm9udE5vZGUuYWRkQ2hpbGQoIG5ldyBQYXRoKCB0aWNrTWFya3MsIHtcclxuICAgICAgbGluZVdpZHRoOiAxLFxyXG4gICAgICBzdHJva2U6ICdibGFjaydcclxuICAgIH0gKSApO1xyXG5cclxuICAgIC8vIGFkZCB0aGUgYm90dG9tIGVsbGlwc2VcclxuICAgIHRoaXMuYmFja05vZGUuYWRkQ2hpbGQoIG5ldyBQYXRoKCBib3R0b21FbGxpcHNlLCB7XHJcbiAgICAgIGZpbGw6IEJFQUtFUl9DT0xPUixcclxuICAgICAgbGluZVdpZHRoOiAzLFxyXG4gICAgICBzdHJva2U6IE9VVExJTkVfQ09MT1JcclxuICAgIH0gKSApO1xyXG5cclxuICAgIC8vIEFkZCB0aGUgdG9wIGVsbGlwc2UuICBJdCBpcyBiZWhpbmQgdGhlIHdhdGVyIGZvciBwcm9wZXIgWi1vcmRlciBiZWhhdmlvci5cclxuICAgIHRoaXMuYmFja05vZGUuYWRkQ2hpbGQoIG5ldyBQYXRoKCB0b3BFbGxpcHNlLCB7XHJcbiAgICAgIGZpbGw6IEJFQUtFUl9DT0xPUixcclxuICAgICAgc3Ryb2tlOiBPVVRMSU5FX0NPTE9SLFxyXG4gICAgICBsaW5lV2lkdGg6IDNcclxuICAgIH0gKSApO1xyXG5cclxuICAgIC8vIGFkZCBhIHJlY3RhbmdsZSB0byB0aGUgYmFjayB0aGF0IGlzIGludmlzaWJsZSBidXQgYWxsb3dzIHRoZSB1c2VyIHRvIGdyYWIgdGhlIGJlYWtlclxyXG4gICAgdGhpcy5iYWNrTm9kZS5hZGRDaGlsZCggbmV3IFJlY3RhbmdsZSggYmVha2VyQm91bmRzLCB7XHJcbiAgICAgIGZpbGw6ICdyZ2JhKCAwLCAwLCAwLCAwICknXHJcbiAgICB9ICkgKTtcclxuXHJcbiAgICAvLyBNYWtlIHRoZSBmcm9udCBhbmQgYmFjayBub2RlcyBub24tcGlja2FibGUgc28gdGhhdCB0aGUgZ3JhYiBub2RlIGNhbiBiZSB1c2VkIGZvciBncmFiYmluZy4gVGhpcyBtYWtlcyBpdCBwb3NzaWJsZVxyXG4gICAgLy8gdG8gcmVtb3ZlIHRoaW5ncyBmcm9tIHRoZSBiZWFrZXIuXHJcbiAgICB0aGlzLmZyb250Tm9kZS5waWNrYWJsZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5iYWNrTm9kZS5waWNrYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIC8vIGFkZCB0aGUgbGFiZWwsIHBvc2l0aW9uaW5nIGl0IGp1c3QgYmVsb3cgdGhlIGZyb250LCB0b3Agd2F0ZXIgbGluZVxyXG4gICAgY29uc3QgbGFiZWxUZXh0ID0gbmV3IFJpY2hUZXh0KCBvcHRpb25zLmxhYmVsLCB7XHJcbiAgICAgIGZvbnQ6IExBQkVMX0ZPTlQsXHJcbiAgICAgIG1heFdpZHRoOiBiZWFrZXJCb3VuZHMud2lkdGggKiAwLjcsIC8vIGVtcGlyaWNhbGx5IGRldGVybWluZWQgdG8gbG9vayBuaWNlXHJcbiAgICAgIHRhbmRlbTogb3B0aW9ucy50YW5kZW0uY3JlYXRlVGFuZGVtKCAnbGFiZWxUZXh0JyApLFxyXG4gICAgICBwaGV0aW9WaXNpYmxlUHJvcGVydHlJbnN0cnVtZW50ZWQ6IHRydWVcclxuICAgIH0gKTtcclxuXHJcbiAgICBsYWJlbFRleHQudHJhbnNsYXRpb24gPSBuZXcgVmVjdG9yMihcclxuICAgICAgYmVha2VyQm91bmRzLmNlbnRlclggLSBsYWJlbFRleHQuYm91bmRzLndpZHRoIC8gMixcclxuICAgICAgYmVha2VyQm91bmRzLm1heFkgLSBiZWFrZXJCb3VuZHMuaGVpZ2h0ICogYmVha2VyLmZsdWlkUHJvcG9ydGlvblByb3BlcnR5LnZhbHVlICsgdG9wRWxsaXBzZS5ib3VuZHMuaGVpZ2h0ICogMS4xXHJcbiAgICApO1xyXG4gICAgbGFiZWxUZXh0LnBpY2thYmxlID0gZmFsc2U7XHJcbiAgICB0aGlzLmZyb250Tm9kZS5hZGRDaGlsZCggbGFiZWxUZXh0ICk7XHJcblxyXG4gICAgLy8gQHByb3RlY3RlZCB7Tm9kZX0gLSB0aGUgbGF5ZXIgd2hlcmUgdGhlIGNvbnRhaW5lZCBlbmVyZ3kgY2h1bmsgbm9kZXMgd2lsbCBiZSBwbGFjZWRcclxuICAgIHRoaXMuZW5lcmd5Q2h1bmtSb290Tm9kZSA9IG5ldyBOb2RlKCk7XHJcbiAgICB0aGlzLmJhY2tOb2RlLmFkZENoaWxkKCB0aGlzLmVuZXJneUNodW5rUm9vdE5vZGUgKTtcclxuXHJcbiAgICAvLyBhZGQgdGhlIGVuZXJneSBjaHVuayBjb250YWluZXIgc2xpY2Ugbm9kZXMgdG8gdGhlIGVuZXJneSBjaHVuayBsYXllclxyXG4gICAgYmVha2VyLnNsaWNlcy5mb3JFYWNoKCBzbGljZSA9PiB7XHJcbiAgICAgIHRoaXMuZW5lcmd5Q2h1bmtSb290Tm9kZS5hZGRDaGlsZCggbmV3IEVuZXJneUNodW5rQ29udGFpbmVyU2xpY2VOb2RlKCBzbGljZSwgbW9kZWxWaWV3VHJhbnNmb3JtICkgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBXYXRjaCBmb3IgY29taW5nIGFuZCBnb2luZyBvZiBlbmVyZ3kgY2h1bmtzIHRoYXQgYXJlIGFwcHJvYWNoaW5nIHRoaXMgbW9kZWwgZWxlbWVudCBhbmQgYWRkL3JlbW92ZSB0aGVtIGFzXHJcbiAgICAvLyBuZWVkZWQuXHJcbiAgICBiZWFrZXIuYXBwcm9hY2hpbmdFbmVyZ3lDaHVua3MuYWRkSXRlbUFkZGVkTGlzdGVuZXIoIGFkZGVkRW5lcmd5Q2h1bmsgPT4ge1xyXG4gICAgICBjb25zdCBlbmVyZ3lDaHVua05vZGUgPSBuZXcgRW5lcmd5Q2h1bmtOb2RlKCBhZGRlZEVuZXJneUNodW5rLCBtb2RlbFZpZXdUcmFuc2Zvcm0gKTtcclxuICAgICAgdGhpcy5lbmVyZ3lDaHVua1Jvb3ROb2RlLmFkZENoaWxkKCBlbmVyZ3lDaHVua05vZGUgKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlbW92YWxMaXN0ZW5lciA9IHJlbW92ZWRFbmVyZ3lDaHVuayA9PiB7XHJcbiAgICAgICAgaWYgKCByZW1vdmVkRW5lcmd5Q2h1bmsgPT09IGFkZGVkRW5lcmd5Q2h1bmsgKSB7XHJcbiAgICAgICAgICB0aGlzLmVuZXJneUNodW5rUm9vdE5vZGUucmVtb3ZlQ2hpbGQoIGVuZXJneUNodW5rTm9kZSApO1xyXG4gICAgICAgICAgZW5lcmd5Q2h1bmtOb2RlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgIGJlYWtlci5hcHByb2FjaGluZ0VuZXJneUNodW5rcy5yZW1vdmVJdGVtUmVtb3ZlZExpc3RlbmVyKCByZW1vdmFsTGlzdGVuZXIgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIGJlYWtlci5hcHByb2FjaGluZ0VuZXJneUNodW5rcy5hZGRJdGVtUmVtb3ZlZExpc3RlbmVyKCByZW1vdmFsTGlzdGVuZXIgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBhZGQgdGhlIG5vZGUgdGhhdCBjYW4gYmUgdXNlZCB0byBncmFiIGFuZCBtb3ZlIHRoZSBiZWFrZXJcclxuICAgIGNvbnN0IGdyYWJOb2RlU2hhcGUgPSBiZWFrZXJCb2R5O1xyXG4gICAgdGhpcy5ncmFiTm9kZS5hZGRDaGlsZCggbmV3IFBhdGgoIGdyYWJOb2RlU2hhcGUsIHtcclxuICAgICAgZmlsbDogJ3JnYmEoIDAsIDAsIDAsIDAgKSdcclxuICAgIH0gKSApOyAvLyBpbnZpc2libGUsIHlldCBwaWNrYWJsZVxyXG4gICAgdGhpcy5ncmFiTm9kZS5hZGRDaGlsZCggbmV3IFBhdGgoIHRvcEVsbGlwc2UsIHtcclxuICAgICAgZmlsbDogJ3JnYmEoIDAsIDAsIDAsIDAgKSdcclxuICAgIH0gKSApO1xyXG5cclxuICAgIC8vIGlmIGVuYWJsZWQgKGZvciBkZWJ1ZyksIHNob3cgdGhlIG91dGxpbmUgb2YgdGhlIHJlY3RhbmdsZSB0aGF0IHJlcHJlc2VudHMgdGhlIGJlYWtlcidzIHBvc2l0aW9uIGluIHRoZSBtb2RlbFxyXG4gICAgaWYgKCBFRkFDUXVlcnlQYXJhbWV0ZXJzLnNob3cyREJlYWtlckJvdW5kcyApIHtcclxuICAgICAgdGhpcy5mcm9udE5vZGUuYWRkQ2hpbGQoIG5ldyBSZWN0YW5nbGUoIGJlYWtlckJvdW5kcywge1xyXG4gICAgICAgIGZpbGw6ICdyZWQnLFxyXG4gICAgICAgIHN0cm9rZTogJ2xpbWUnLFxyXG4gICAgICAgIGxpbmVXaWR0aDogMlxyXG4gICAgICB9ICkgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGUgdGhlIG9mZnNldCBpZiBhbmQgd2hlbiB0aGUgbW9kZWwgcG9zaXRpb24gY2hhbmdlc1xyXG4gICAgYmVha2VyLnBvc2l0aW9uUHJvcGVydHkubGluayggcG9zaXRpb24gPT4ge1xyXG5cclxuICAgICAgaWYgKCB0aGlzLmZvbGxvd1Bvc2l0aW9uICkge1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1Bvc2l0aW9uKCBwb3NpdGlvbiApO1xyXG5cclxuICAgICAgICB0aGlzLmZyb250Tm9kZS50cmFuc2xhdGlvbiA9IG9mZnNldDtcclxuICAgICAgICB0aGlzLmJhY2tOb2RlLnRyYW5zbGF0aW9uID0gb2Zmc2V0O1xyXG4gICAgICAgIHRoaXMuZ3JhYk5vZGUudHJhbnNsYXRpb24gPSBvZmZzZXQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGNvbXBlbnNhdGUgdGhlIGVuZXJneSBjaHVuayBsYXllciBzbyB0aGF0IHRoZSBlbmVyZ3kgY2h1bmsgbm9kZXMgY2FuIGhhbmRsZSB0aGVpciBvd24gcG9zaXRpb25pbmdcclxuICAgICAgdGhpcy5lbmVyZ3lDaHVua1Jvb3ROb2RlLnRyYW5zbGF0aW9uID0gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3UG9zaXRpb24oIHBvc2l0aW9uICkucm90YXRlZCggTWF0aC5QSSApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIGFkanVzdCB0aGUgdHJhbnNwYXJlbmN5IG9mIHRoZSB3YXRlciBhbmQgbGFiZWwgYmFzZWQgb24gZW5lcmd5IGNodW5rIHZpc2liaWxpdHlcclxuICAgIGVuZXJneUNodW5rc1Zpc2libGVQcm9wZXJ0eS5saW5rKCBlbmVyZ3lDaHVua3NWaXNpYmxlID0+IHtcclxuICAgICAgbGFiZWxUZXh0Lm9wYWNpdHkgPSBlbmVyZ3lDaHVua3NWaXNpYmxlID8gMC41IDogMTtcclxuICAgICAgY29uc3Qgb3BhY2l0eSA9IEVGQUNDb25zdGFudHMuTk9NSU5BTF9XQVRFUl9PUEFDSVRZO1xyXG4gICAgICB0aGlzLmZsdWlkLm9wYWNpdHkgPSBlbmVyZ3lDaHVua3NWaXNpYmxlID8gb3BhY2l0eSAqIDAuNzUgOiBvcGFjaXR5O1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIHJlc2V0IHRoaXMgbm9kZSBpZiB0aGUgYmVha2VyIGl0IHJlcHJlc2VudHMgZ2V0cyByZXNldFxyXG4gICAgYmVha2VyLnJlc2V0SW5Qcm9ncmVzc1Byb3BlcnR5LmxhenlMaW5rKCByZXNldEluUHJvZ3Jlc3MgPT4ge1xyXG5cclxuICAgICAgLy8gcmVzZXQgdGhpcyB2aWV3IG5vZGUgYXQgdGhlIGVuZCBvZiB0aGUgYmVha2VyJ3MgcmVzZXQsIHNpbmNlIGl0IHNob3VsZCBiZSBpbiBhIHJlYXNvbmFibGUgc3RhdGUgYXQgdGhhdCBwb2ludFxyXG4gICAgICBpZiAoICFyZXNldEluUHJvZ3Jlc3MgKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcmVzZXQoKSB7XHJcbiAgICB0aGlzLmZsdWlkLnJlc2V0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBzdGVwIHRoaXMgdmlldyBlbGVtZW50XHJcbiAgICogQHBhcmFtIGR0IC0gdGltZSBzdGVwLCBpbiBzZWNvbmRzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHN0ZXAoIGR0ICkge1xyXG4gICAgdGhpcy5mbHVpZC5zdGVwKCBkdCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogc2V0IHdoZXRoZXIgdGhpcyBub2RlIHNob3VsZCBmb2xsb3cgaXRzIGJlYWtlciBwb3NpdGlvbi4gdGhpcyBpcyB1c2VmdWwgZm9yIHRoZSBjYXNlIHdoZXJlIGl0cyBwYXJlbnQgbm9kZSBpc1xyXG4gICAqIGhhbmRsaW5nIGl0cyBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9sbG93UG9zaXRpb25cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgc2V0Rm9sbG93UG9zaXRpb24oIGZvbGxvd1Bvc2l0aW9uICkge1xyXG4gICAgdGhpcy5mb2xsb3dQb3NpdGlvbiA9IGZvbGxvd1Bvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogbW92ZXMgYWxsIGxheWVycyB0byB0aGUgZnJvbnQgb2YgdGhlaXIgcmVzcGVjdGl2ZSBub2RlIGxheWVyc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBtb3ZlVG9Gcm9udCgpIHtcclxuICAgIHRoaXMuYmFja05vZGUubW92ZVRvRnJvbnQoKTtcclxuICAgIHRoaXMuZnJvbnROb2RlLm1vdmVUb0Zyb250KCk7XHJcbiAgICB0aGlzLmdyYWJOb2RlLm1vdmVUb0Zyb250KCk7XHJcbiAgfVxyXG59XHJcblxyXG5lbmVyZ3lGb3Jtc0FuZENoYW5nZXMucmVnaXN0ZXIoICdCZWFrZXJWaWV3JywgQmVha2VyVmlldyApO1xyXG5leHBvcnQgZGVmYXVsdCBCZWFrZXJWaWV3O1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsZUFBZSxNQUFNLHdDQUF3QztBQUNwRSxPQUFPQyxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLFVBQVUsTUFBTSxrQ0FBa0M7QUFDekQsT0FBT0MsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxTQUFTQyxLQUFLLFFBQVEsZ0NBQWdDO0FBQ3RELE9BQU9DLEtBQUssTUFBTSxtQ0FBbUM7QUFDckQsT0FBT0MsUUFBUSxNQUFNLHlDQUF5QztBQUM5RCxTQUFTQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxRQUFRLFFBQVEsbUNBQW1DO0FBQ25GLE9BQU9DLFlBQVksTUFBTSx1Q0FBdUM7QUFDaEUsT0FBT0MsTUFBTSxNQUFNLGlDQUFpQztBQUNwRCxPQUFPQyxNQUFNLE1BQU0sdUNBQXVDO0FBQzFELE9BQU9DLFdBQVcsTUFBTSw0Q0FBNEM7QUFDcEUsT0FBT0MscUJBQXFCLE1BQU0sZ0NBQWdDO0FBQ2xFLE9BQU9DLDRCQUE0QixNQUFNLHVDQUF1QztBQUNoRixPQUFPQyw2QkFBNkIsTUFBTSxtREFBbUQ7QUFDN0YsT0FBT0MsYUFBYSxNQUFNLHFCQUFxQjtBQUMvQyxPQUFPQyxtQkFBbUIsTUFBTSwyQkFBMkI7QUFDM0QsT0FBT0MsZUFBZSxNQUFNLHNCQUFzQjtBQUNsRCxPQUFPQyxvQkFBb0IsTUFBTSwyQkFBMkI7QUFFNUQsTUFBTUMsV0FBVyxHQUFHTiw0QkFBNEIsQ0FBQ08sS0FBSzs7QUFFdEQ7QUFDQSxNQUFNQyxhQUFhLEdBQUcsc0JBQXNCO0FBQzVDLE1BQU1DLHNCQUFzQixHQUFHLENBQUNQLGFBQWEsQ0FBQ1Esd0JBQXdCO0FBQ3RFLE1BQU1DLFVBQVUsR0FBRyxJQUFJckIsUUFBUSxDQUFFLEVBQUcsQ0FBQztBQUNyQyxNQUFNc0IsWUFBWSxHQUFHLDZCQUE2QixDQUFDLENBQUM7QUFDcEQsTUFBTUMsb0NBQW9DLEdBQUcsQ0FBQyxDQUFDLENBQUM7O0FBRWhELE1BQU1DLFVBQVUsU0FBU25CLFlBQVksQ0FBQztFQUVwQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRW9CLFdBQVdBLENBQUVDLE1BQU0sRUFBRUMsMkJBQTJCLEVBQUVDLGtCQUFrQixFQUFFQyxPQUFPLEVBQUc7SUFFOUVBLE9BQU8sR0FBRzlCLEtBQUssQ0FBRTtNQUNmK0IsS0FBSyxFQUFFZCxXQUFXO01BRWxCO01BQ0FlLE1BQU0sRUFBRXpCLE1BQU0sQ0FBQzBCLFFBQVE7TUFDdkJDLFVBQVUsRUFBRXpCLFdBQVcsQ0FBRUQsTUFBTSxDQUFDMkIsUUFBUyxDQUFDO01BQzFDQyxXQUFXLEVBQUU7SUFDZixDQUFDLEVBQUVOLE9BQVEsQ0FBQztJQUVaLEtBQUssQ0FBRUEsT0FBUSxDQUFDOztJQUVoQjtJQUNBLElBQUksQ0FBQ0Qsa0JBQWtCLEdBQUdBLGtCQUFrQjtJQUM1QyxJQUFJLENBQUNRLGNBQWMsR0FBRyxJQUFJOztJQUUxQjtJQUNBO0lBQ0EsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSXBDLElBQUksQ0FBQyxDQUFDO0lBQzNCLElBQUksQ0FBQ3FDLFFBQVEsR0FBRyxJQUFJckMsSUFBSSxDQUFDLENBQUM7SUFDMUIsSUFBSSxDQUFDc0MsUUFBUSxHQUFHLElBQUl0QyxJQUFJLENBQUU7TUFBRXVDLE1BQU0sRUFBRTtJQUFVLENBQUUsQ0FBQzs7SUFFakQ7SUFDQSxNQUFNQyxlQUFlLEdBQUcsSUFBSS9DLGVBQWUsQ0FBRSxJQUFJLEVBQUU7TUFDakRxQyxNQUFNLEVBQUVGLE9BQU8sQ0FBQ0UsTUFBTSxDQUFDVyxZQUFZLENBQUUsaUJBQWtCO0lBQ3pELENBQUUsQ0FBQztJQUNIRCxlQUFlLENBQUNFLElBQUksQ0FBRUMsT0FBTyxJQUFJO01BQy9CLElBQUksQ0FBQ1AsU0FBUyxDQUFDTyxPQUFPLEdBQUdBLE9BQU87TUFDaEMsSUFBSSxDQUFDTixRQUFRLENBQUNNLE9BQU8sR0FBR0EsT0FBTztNQUMvQixJQUFJLENBQUNMLFFBQVEsQ0FBQ0ssT0FBTyxHQUFHQSxPQUFPO0lBQ2pDLENBQUUsQ0FBQzs7SUFFSDtJQUNBLE1BQU1DLGNBQWMsR0FBRyxJQUFJakQsVUFBVSxDQUNuQ0QsT0FBTyxDQUFDbUQsT0FBTyxDQUFFbEIsa0JBQWtCLENBQUNtQixNQUFNLENBQUNDLEdBQUcsQ0FBQyxDQUFDLEVBQUVwQixrQkFBa0IsQ0FBQ21CLE1BQU0sQ0FBQ0UsR0FBRyxDQUFDLENBQUUsQ0FDcEYsQ0FBQzs7SUFFRDtJQUNBLE1BQU1DLFlBQVksR0FBR0wsY0FBYyxDQUFDTSxjQUFjLENBQUV6QixNQUFNLENBQUMwQixzQkFBc0IsQ0FBQyxDQUFFLENBQUM7O0lBRXJGO0lBQ0EsTUFBTUMsYUFBYSxHQUFHSCxZQUFZLENBQUNJLFFBQVEsQ0FBQyxDQUFDLEdBQUduQyxzQkFBc0I7SUFDdEUsTUFBTW9DLGVBQWUsR0FBR0wsWUFBWSxDQUFDTSxLQUFLLEdBQUcsQ0FBQztJQUM5QyxNQUFNQyx1QkFBdUIsR0FBR0osYUFBYSxHQUFHLENBQUM7SUFDakQsTUFBTUssVUFBVSxHQUFHLElBQUk1RCxLQUFLLENBQUMsQ0FBQyxDQUFDNkQsT0FBTyxDQUFFVCxZQUFZLENBQUNVLE9BQU8sRUFBRVYsWUFBWSxDQUFDVyxJQUFJLEVBQUVOLGVBQWUsRUFBRUUsdUJBQXVCLEVBQUUsQ0FBRSxDQUFDO0lBQzlILE1BQU1LLGFBQWEsR0FBRyxJQUFJaEUsS0FBSyxDQUFDLENBQUMsQ0FBQzZELE9BQU8sQ0FBRVQsWUFBWSxDQUFDVSxPQUFPLEVBQUVWLFlBQVksQ0FBQ2EsSUFBSSxFQUFFUixlQUFlLEVBQUVFLHVCQUF1QixFQUFFLENBQUUsQ0FBQzs7SUFFakk7SUFDQSxJQUFJLENBQUNPLEtBQUssR0FBRyxJQUFJakQsb0JBQW9CLENBQ25DbUMsWUFBWSxFQUNaeEIsTUFBTSxDQUFDdUMsdUJBQXVCLEVBQzlCdkMsTUFBTSxDQUFDd0MsbUJBQW1CLEVBQzFCeEMsTUFBTSxDQUFDeUMsaUJBQWlCLEVBQ3hCekMsTUFBTSxDQUFDMEMsVUFBVSxFQUNqQjFDLE1BQU0sQ0FBQzJDLFVBQ1QsQ0FBQztJQUNELElBQUksQ0FBQ2hDLFNBQVMsQ0FBQ2lDLFFBQVEsQ0FBRSxJQUFJLENBQUNOLEtBQU0sQ0FBQzs7SUFFckM7SUFDQSxNQUFNTyxVQUFVLEdBQUcsSUFBSXpFLEtBQUssQ0FBQyxDQUFDLENBQzNCMEUsTUFBTSxDQUFFdEIsWUFBWSxDQUFDdUIsSUFBSSxFQUFFdkIsWUFBWSxDQUFDVyxJQUFLLENBQUMsQ0FBQztJQUFBLENBQy9DYSxhQUFhLENBQUV4QixZQUFZLENBQUNVLE9BQU8sRUFBRVYsWUFBWSxDQUFDVyxJQUFJLEVBQUVOLGVBQWUsRUFBRUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFa0IsSUFBSSxDQUFDQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLElBQUssQ0FBQyxDQUN2SEMsTUFBTSxDQUFFM0IsWUFBWSxDQUFDNEIsSUFBSSxFQUFFNUIsWUFBWSxDQUFDYSxJQUFLLENBQUMsQ0FBQztJQUFBLENBQy9DVyxhQUFhLENBQUV4QixZQUFZLENBQUNVLE9BQU8sRUFBRVYsWUFBWSxDQUFDYSxJQUFJLEVBQUVSLGVBQWUsRUFBRUUsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRWtCLElBQUksQ0FBQ0MsRUFBRSxFQUFFLEtBQU0sQ0FBQyxDQUN4SEcsS0FBSyxDQUFDLENBQUM7SUFFVixJQUFJLENBQUMxQyxTQUFTLENBQUNpQyxRQUFRLENBQUUsSUFBSXBFLElBQUksQ0FBRXFFLFVBQVUsRUFBRTtNQUM3Q1MsSUFBSSxFQUFFMUQsWUFBWTtNQUNsQjJELFNBQVMsRUFBRSxDQUFDO01BQ1pDLE1BQU0sRUFBRWhFO0lBQ1YsQ0FBRSxDQUFFLENBQUM7O0lBRUw7SUFDQSxNQUFNaUUsa0JBQWtCLEdBQUdSLElBQUksQ0FBQ1MsS0FBSyxDQUFFMUQsTUFBTSxDQUFDMkQsTUFBTSxHQUFHM0QsTUFBTSxDQUFDNEQscUJBQXNCLENBQUM7SUFDckYsTUFBTUMsYUFBYSxHQUFHSixrQkFBa0IsSUFBSzVELG9DQUFvQyxHQUFHLENBQUMsQ0FBRSxDQUFDLENBQUM7SUFDekYsTUFBTWlFLG9CQUFvQixHQUFHLElBQUksR0FBR2IsSUFBSSxDQUFDQyxFQUFFLENBQUMsQ0FBQztJQUM3QyxNQUFNYSxvQkFBb0IsR0FBR0Qsb0JBQW9CLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdkQsTUFBTUUsd0JBQXdCLEdBQUdmLElBQUksQ0FBQ2dCLEdBQUcsQ0FBRS9ELGtCQUFrQixDQUFDZ0UsaUJBQWlCLENBQUVsRSxNQUFNLENBQUM0RCxxQkFBc0IsQ0FBQyxJQUNsRS9ELG9DQUFvQyxHQUFHLENBQUMsQ0FBRyxDQUFDOztJQUV6RjtJQUNBLE1BQU1zRSxZQUFZLEdBQUcsR0FBRyxHQUFHbEIsSUFBSSxDQUFDQyxFQUFFO0lBQ2xDLElBQUlrQixTQUFTLEdBQUc1QyxZQUFZLENBQUNhLElBQUk7O0lBRWpDO0lBQ0EsTUFBTWdDLFNBQVMsR0FBRyxJQUFJakcsS0FBSyxDQUFDLENBQUMsQ0FBQzBFLE1BQU0sQ0FBRXRCLFlBQVksQ0FBQ3VCLElBQUksRUFBRXZCLFlBQVksQ0FBQ2EsSUFBSyxDQUFDLENBQUMsQ0FBQzs7SUFFOUU7SUFDQSxLQUFNLElBQUlpQyxTQUFTLEdBQUcsQ0FBQyxFQUFFQSxTQUFTLEdBQUdULGFBQWEsRUFBRVMsU0FBUyxFQUFFLEVBQUc7TUFDaEVGLFNBQVMsSUFBSUosd0JBQXdCO01BQ3JDLE1BQU1PLFVBQVUsR0FBR3RCLElBQUksQ0FBQ0MsRUFBRSxHQUFHaUIsWUFBWTtNQUN6QyxNQUFNSyxlQUFlLEdBQUcsQ0FBRUYsU0FBUyxHQUFHLENBQUMsS0FBT3pFLG9DQUFvQyxHQUFHLENBQUMsQ0FBRSxLQUFLLENBQUMsR0FBR2lFLG9CQUFvQixHQUFHQyxvQkFBb0I7TUFDNUksTUFBTVUsUUFBUSxHQUFHRixVQUFVLEdBQUdDLGVBQWU7TUFFN0NILFNBQVMsQ0FBQ0ssVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ3hCTCxTQUFTLENBQUNyQixhQUFhLENBQ3JCeEIsWUFBWSxDQUFDVSxPQUFPLEVBQ3BCa0MsU0FBUyxFQUNUdkMsZUFBZSxFQUNmRSx1QkFBdUIsRUFDdkIsQ0FBQyxFQUNEd0MsVUFBVSxFQUNWRSxRQUFRLEVBQ1IsSUFDRixDQUFDO0lBQ0g7O0lBRUE7SUFDQSxJQUFJLENBQUM5RCxTQUFTLENBQUNpQyxRQUFRLENBQUUsSUFBSXBFLElBQUksQ0FBRTZGLFNBQVMsRUFBRTtNQUM1Q2QsU0FBUyxFQUFFLENBQUM7TUFDWkMsTUFBTSxFQUFFO0lBQ1YsQ0FBRSxDQUFFLENBQUM7O0lBRUw7SUFDQSxJQUFJLENBQUM1QyxRQUFRLENBQUNnQyxRQUFRLENBQUUsSUFBSXBFLElBQUksQ0FBRTRELGFBQWEsRUFBRTtNQUMvQ2tCLElBQUksRUFBRTFELFlBQVk7TUFDbEIyRCxTQUFTLEVBQUUsQ0FBQztNQUNaQyxNQUFNLEVBQUVoRTtJQUNWLENBQUUsQ0FBRSxDQUFDOztJQUVMO0lBQ0EsSUFBSSxDQUFDb0IsUUFBUSxDQUFDZ0MsUUFBUSxDQUFFLElBQUlwRSxJQUFJLENBQUV3RCxVQUFVLEVBQUU7TUFDNUNzQixJQUFJLEVBQUUxRCxZQUFZO01BQ2xCNEQsTUFBTSxFQUFFaEUsYUFBYTtNQUNyQitELFNBQVMsRUFBRTtJQUNiLENBQUUsQ0FBRSxDQUFDOztJQUVMO0lBQ0EsSUFBSSxDQUFDM0MsUUFBUSxDQUFDZ0MsUUFBUSxDQUFFLElBQUluRSxTQUFTLENBQUUrQyxZQUFZLEVBQUU7TUFDbkQ4QixJQUFJLEVBQUU7SUFDUixDQUFFLENBQUUsQ0FBQzs7SUFFTDtJQUNBO0lBQ0EsSUFBSSxDQUFDM0MsU0FBUyxDQUFDZ0UsUUFBUSxHQUFHLEtBQUs7SUFDL0IsSUFBSSxDQUFDL0QsUUFBUSxDQUFDK0QsUUFBUSxHQUFHLEtBQUs7O0lBRTlCO0lBQ0EsTUFBTUMsU0FBUyxHQUFHLElBQUlsRyxRQUFRLENBQUV5QixPQUFPLENBQUNDLEtBQUssRUFBRTtNQUM3Q3lFLElBQUksRUFBRWxGLFVBQVU7TUFDaEJtRixRQUFRLEVBQUV0RCxZQUFZLENBQUNNLEtBQUssR0FBRyxHQUFHO01BQUU7TUFDcEN6QixNQUFNLEVBQUVGLE9BQU8sQ0FBQ0UsTUFBTSxDQUFDVyxZQUFZLENBQUUsV0FBWSxDQUFDO01BQ2xEK0QsaUNBQWlDLEVBQUU7SUFDckMsQ0FBRSxDQUFDO0lBRUhILFNBQVMsQ0FBQ0ksV0FBVyxHQUFHLElBQUk3RyxPQUFPLENBQ2pDcUQsWUFBWSxDQUFDVSxPQUFPLEdBQUcwQyxTQUFTLENBQUNLLE1BQU0sQ0FBQ25ELEtBQUssR0FBRyxDQUFDLEVBQ2pETixZQUFZLENBQUNhLElBQUksR0FBR2IsWUFBWSxDQUFDbUMsTUFBTSxHQUFHM0QsTUFBTSxDQUFDdUMsdUJBQXVCLENBQUMyQyxLQUFLLEdBQUdsRCxVQUFVLENBQUNpRCxNQUFNLENBQUN0QixNQUFNLEdBQUcsR0FDOUcsQ0FBQztJQUNEaUIsU0FBUyxDQUFDRCxRQUFRLEdBQUcsS0FBSztJQUMxQixJQUFJLENBQUNoRSxTQUFTLENBQUNpQyxRQUFRLENBQUVnQyxTQUFVLENBQUM7O0lBRXBDO0lBQ0EsSUFBSSxDQUFDTyxtQkFBbUIsR0FBRyxJQUFJNUcsSUFBSSxDQUFDLENBQUM7SUFDckMsSUFBSSxDQUFDcUMsUUFBUSxDQUFDZ0MsUUFBUSxDQUFFLElBQUksQ0FBQ3VDLG1CQUFvQixDQUFDOztJQUVsRDtJQUNBbkYsTUFBTSxDQUFDb0YsTUFBTSxDQUFDQyxPQUFPLENBQUVDLEtBQUssSUFBSTtNQUM5QixJQUFJLENBQUNILG1CQUFtQixDQUFDdkMsUUFBUSxDQUFFLElBQUkzRCw2QkFBNkIsQ0FBRXFHLEtBQUssRUFBRXBGLGtCQUFtQixDQUFFLENBQUM7SUFDckcsQ0FBRSxDQUFDOztJQUVIO0lBQ0E7SUFDQUYsTUFBTSxDQUFDdUYsdUJBQXVCLENBQUNDLG9CQUFvQixDQUFFQyxnQkFBZ0IsSUFBSTtNQUN2RSxNQUFNQyxlQUFlLEdBQUcsSUFBSXRHLGVBQWUsQ0FBRXFHLGdCQUFnQixFQUFFdkYsa0JBQW1CLENBQUM7TUFDbkYsSUFBSSxDQUFDaUYsbUJBQW1CLENBQUN2QyxRQUFRLENBQUU4QyxlQUFnQixDQUFDO01BRXBELE1BQU1DLGVBQWUsR0FBR0Msa0JBQWtCLElBQUk7UUFDNUMsSUFBS0Esa0JBQWtCLEtBQUtILGdCQUFnQixFQUFHO1VBQzdDLElBQUksQ0FBQ04sbUJBQW1CLENBQUNVLFdBQVcsQ0FBRUgsZUFBZ0IsQ0FBQztVQUN2REEsZUFBZSxDQUFDSSxPQUFPLENBQUMsQ0FBQztVQUN6QjlGLE1BQU0sQ0FBQ3VGLHVCQUF1QixDQUFDUSx5QkFBeUIsQ0FBRUosZUFBZ0IsQ0FBQztRQUM3RTtNQUNGLENBQUM7TUFDRDNGLE1BQU0sQ0FBQ3VGLHVCQUF1QixDQUFDUyxzQkFBc0IsQ0FBRUwsZUFBZ0IsQ0FBQztJQUMxRSxDQUFFLENBQUM7O0lBRUg7SUFDQSxNQUFNTSxhQUFhLEdBQUdwRCxVQUFVO0lBQ2hDLElBQUksQ0FBQ2hDLFFBQVEsQ0FBQytCLFFBQVEsQ0FBRSxJQUFJcEUsSUFBSSxDQUFFeUgsYUFBYSxFQUFFO01BQy9DM0MsSUFBSSxFQUFFO0lBQ1IsQ0FBRSxDQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ1AsSUFBSSxDQUFDekMsUUFBUSxDQUFDK0IsUUFBUSxDQUFFLElBQUlwRSxJQUFJLENBQUV3RCxVQUFVLEVBQUU7TUFDNUNzQixJQUFJLEVBQUU7SUFDUixDQUFFLENBQUUsQ0FBQzs7SUFFTDtJQUNBLElBQUtuRSxtQkFBbUIsQ0FBQytHLGtCQUFrQixFQUFHO01BQzVDLElBQUksQ0FBQ3ZGLFNBQVMsQ0FBQ2lDLFFBQVEsQ0FBRSxJQUFJbkUsU0FBUyxDQUFFK0MsWUFBWSxFQUFFO1FBQ3BEOEIsSUFBSSxFQUFFLEtBQUs7UUFDWEUsTUFBTSxFQUFFLE1BQU07UUFDZEQsU0FBUyxFQUFFO01BQ2IsQ0FBRSxDQUFFLENBQUM7SUFDUDs7SUFFQTtJQUNBdkQsTUFBTSxDQUFDbUcsZ0JBQWdCLENBQUNsRixJQUFJLENBQUVtRixRQUFRLElBQUk7TUFFeEMsSUFBSyxJQUFJLENBQUMxRixjQUFjLEVBQUc7UUFDekIsTUFBTTJGLE1BQU0sR0FBR25HLGtCQUFrQixDQUFDb0csbUJBQW1CLENBQUVGLFFBQVMsQ0FBQztRQUVqRSxJQUFJLENBQUN6RixTQUFTLENBQUNxRSxXQUFXLEdBQUdxQixNQUFNO1FBQ25DLElBQUksQ0FBQ3pGLFFBQVEsQ0FBQ29FLFdBQVcsR0FBR3FCLE1BQU07UUFDbEMsSUFBSSxDQUFDeEYsUUFBUSxDQUFDbUUsV0FBVyxHQUFHcUIsTUFBTTtNQUNwQzs7TUFFQTtNQUNBLElBQUksQ0FBQ2xCLG1CQUFtQixDQUFDSCxXQUFXLEdBQUc5RSxrQkFBa0IsQ0FBQ29HLG1CQUFtQixDQUFFRixRQUFTLENBQUMsQ0FBQ0csT0FBTyxDQUFFdEQsSUFBSSxDQUFDQyxFQUFHLENBQUM7SUFDOUcsQ0FBRSxDQUFDOztJQUVIO0lBQ0FqRCwyQkFBMkIsQ0FBQ2dCLElBQUksQ0FBRXVGLG1CQUFtQixJQUFJO01BQ3ZENUIsU0FBUyxDQUFDNkIsT0FBTyxHQUFHRCxtQkFBbUIsR0FBRyxHQUFHLEdBQUcsQ0FBQztNQUNqRCxNQUFNQyxPQUFPLEdBQUd2SCxhQUFhLENBQUN3SCxxQkFBcUI7TUFDbkQsSUFBSSxDQUFDcEUsS0FBSyxDQUFDbUUsT0FBTyxHQUFHRCxtQkFBbUIsR0FBR0MsT0FBTyxHQUFHLElBQUksR0FBR0EsT0FBTztJQUNyRSxDQUFFLENBQUM7O0lBRUg7SUFDQXpHLE1BQU0sQ0FBQzJHLHVCQUF1QixDQUFDQyxRQUFRLENBQUVDLGVBQWUsSUFBSTtNQUUxRDtNQUNBLElBQUssQ0FBQ0EsZUFBZSxFQUFHO1FBQ3RCLElBQUksQ0FBQ0MsS0FBSyxDQUFDLENBQUM7TUFDZDtJQUNGLENBQUUsQ0FBQztFQUNMOztFQUVBO0FBQ0Y7QUFDQTtFQUNFQSxLQUFLQSxDQUFBLEVBQUc7SUFDTixJQUFJLENBQUN4RSxLQUFLLENBQUN3RSxLQUFLLENBQUMsQ0FBQztFQUNwQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0VDLElBQUlBLENBQUVDLEVBQUUsRUFBRztJQUNULElBQUksQ0FBQzFFLEtBQUssQ0FBQ3lFLElBQUksQ0FBRUMsRUFBRyxDQUFDO0VBQ3ZCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxpQkFBaUJBLENBQUV2RyxjQUFjLEVBQUc7SUFDbEMsSUFBSSxDQUFDQSxjQUFjLEdBQUdBLGNBQWM7RUFDdEM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRXdHLFdBQVdBLENBQUEsRUFBRztJQUNaLElBQUksQ0FBQ3RHLFFBQVEsQ0FBQ3NHLFdBQVcsQ0FBQyxDQUFDO0lBQzNCLElBQUksQ0FBQ3ZHLFNBQVMsQ0FBQ3VHLFdBQVcsQ0FBQyxDQUFDO0lBQzVCLElBQUksQ0FBQ3JHLFFBQVEsQ0FBQ3FHLFdBQVcsQ0FBQyxDQUFDO0VBQzdCO0FBQ0Y7QUFFQW5JLHFCQUFxQixDQUFDb0ksUUFBUSxDQUFFLFlBQVksRUFBRXJILFVBQVcsQ0FBQztBQUMxRCxlQUFlQSxVQUFVIn0=