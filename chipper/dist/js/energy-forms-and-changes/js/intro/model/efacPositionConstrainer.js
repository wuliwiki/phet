// Copyright 2019-2022, University of Colorado Boulder

/**
 * A singleton that encapsulates the information and algorithms necessary to constrain the motion of model elements such
 * that they can't be dragged through one another.
 *
 * @author John Blanco
 * @author Chris Klusendorf
 */

import Bounds2 from '../../../../dot/js/Bounds2.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import PhetioGroup from '../../../../tandem/js/PhetioGroup.js';
import energyFormsAndChanges from '../../energyFormsAndChanges.js';
import BeakerContainer from './BeakerContainer.js';
import Block from './Block.js';

// constants

// minimum distance allowed between two objects, used to prevent floating point issues
const MIN_INTER_ELEMENT_DISTANCE = 1E-9; // in meters

// reusable items, avoids allocations
const reusableBounds = Bounds2.NOTHING.copy();

// the main singleton object definition
const efacPositionConstrainer = {
  /**
   * Evaluate whether the provided model element can be moved to the provided position without overlapping with other
   * solid model elements. If overlap would occur, adjust the position to one that works. Note that this is not
   * very general due to a number of special requirements for the Energy Forms and Changes sim, so it would likely not
   * be easy to reuse.
   * @param {RectangularThermalMovableModelElement} modelElement - element whose position is being checked
   * @param {Vector2} proposedPosition - the position where the model element would like to go
   * @param {PhetioGroup.<BeakerContainer>} beakerGroup - the beakers that are present in the model
   * @param {PhetioGroup.<Block>} blockGroup - the blocks that are present in the model
   * @param {Bounds2} burnerBlockingRect - the space occupied by the burners in the model
   * @returns {Vector2} the original proposed position if valid, or alternative position if not
   * @public
   */
  constrainPosition: (modelElement, proposedPosition, beakerGroup, blockGroup, burnerBlockingRect) => {
    assert && assert(beakerGroup instanceof PhetioGroup, 'invalid beakerGroup');
    assert && assert(blockGroup instanceof PhetioGroup, 'invalid blockGroup');
    const modelElementPosition = modelElement.positionProperty.get();

    // calculate the proposed motion
    let allowedTranslation = Vector2.pool.create(proposedPosition.x - modelElementPosition.x, proposedPosition.y - modelElementPosition.y);

    // get the current composite bounds of the model element
    const modelElementBounds = modelElement.getCompositeBoundsForPosition(modelElementPosition, reusableBounds);

    // create bounds that use the perspective compensation that is necessary for evaluating burner interaction
    const modelElementBoundsWithSidePerspective = Bounds2.pool.create(modelElementBounds.minX - modelElement.perspectiveCompensation.x, modelElementBounds.minY, modelElementBounds.maxX + modelElement.perspectiveCompensation.x, modelElementBounds.maxY);

    // validate against burner boundaries
    allowedTranslation = determineAllowedTranslation(modelElementBoundsWithSidePerspective, burnerBlockingRect, allowedTranslation.x, allowedTranslation.y, true, allowedTranslation);

    // now check the model element's motion against each of the beakers
    beakerGroup.forEach(beaker => {
      if (beaker === modelElement) {
        // don't test against self
        return;
      }

      // get the bounds set that describes the shape of the beaker
      const beakerBoundsList = beaker.translatedPositionTestingBoundsList;

      // if the modelElement is a block, it has x and y perspective comp that need to be used
      const modelElementBoundsWithTopAndSidePerspective = Bounds2.pool.create(modelElementBounds.minX - modelElement.perspectiveCompensation.x, modelElementBounds.minY - modelElement.perspectiveCompensation.y, modelElementBounds.maxX + modelElement.perspectiveCompensation.x, modelElementBounds.maxY + modelElement.perspectiveCompensation.y);

      // don't restrict the motion based on the beaker if the beaker is on top of this model element
      if (!beaker.isStackedUpon(modelElement)) {
        // the code below assumes that the bounds list is in the order: left side, bottom, right side. this assertion
        // verifies that.
        assert && assert(beakerBoundsList[0].centerX < beakerBoundsList[1].centerX && beakerBoundsList[1].centerX < beakerBoundsList[2].centerX, 'beaker bounds list is out of order');
        allowedTranslation = determineAllowedTranslation(modelElementBoundsWithTopAndSidePerspective, beakerBoundsList[0], allowedTranslation.x, allowedTranslation.y, true, allowedTranslation);
        allowedTranslation = determineAllowedTranslation(modelElementBoundsWithSidePerspective, beakerBoundsList[1], allowedTranslation.x, allowedTranslation.y, true, allowedTranslation);
        allowedTranslation = determineAllowedTranslation(modelElementBoundsWithTopAndSidePerspective, beakerBoundsList[2], allowedTranslation.x, allowedTranslation.y, true, allowedTranslation);
      } else {
        // if beaker A is stacked on the current modelElement, get beaker B directly as otherBeaker because currently
        // there can't be more than two beakers. this will need to be generalized to check for each other beaker that is not
        // stacked on this modelElement if the time comes when more than two beakers can exist.
        const otherBeaker = beakerGroup.getElement(1 - beakerGroup.indexOf(beaker));

        // a second beaker may not exist
        if (otherBeaker) {
          // get the bounds of the other beaker and the bounds of the beaker stacked on top of this modelElement
          const otherBeakerBoundsList = otherBeaker.translatedPositionTestingBoundsList;
          const currentBeakerBounds = beaker.getBounds();
          allowedTranslation = determineAllowedTranslation(currentBeakerBounds, otherBeakerBoundsList[0], allowedTranslation.x, allowedTranslation.y, true, allowedTranslation);
          allowedTranslation = determineAllowedTranslation(currentBeakerBounds, otherBeakerBoundsList[1], allowedTranslation.x, allowedTranslation.y, true, allowedTranslation);
          allowedTranslation = determineAllowedTranslation(currentBeakerBounds, otherBeakerBoundsList[2], allowedTranslation.x, allowedTranslation.y, true, allowedTranslation);
        }
      }
      modelElementBoundsWithTopAndSidePerspective.freeToPool();
    });

    // now check the model element's motion against each of the blocks
    blockGroup.forEach(block => {
      if (block === modelElement) {
        // don't test against self
        return;
      }
      const blockBounds = block.getBounds();

      // Do not restrict the model element's motion in positive Y direction if the tested block is sitting on top of
      // the model element - the block will simply be lifted up.
      const isBlockStackedInBeaker = block.isStackedUpon(modelElement);
      if (modelElement instanceof Block) {
        allowedTranslation = determineAllowedTranslation(modelElement.getBounds(), blockBounds, allowedTranslation.x, allowedTranslation.y, !isBlockStackedInBeaker,
        // don't restrict in Y direction if this block is sitting in the beaker
        allowedTranslation);
      } else {
        // make sure this is a beaker before going any further
        assert && assert(modelElement instanceof BeakerContainer, 'unrecognized model element type');

        // Test to see if the beaker's motion needs to be constrained due to the block's position, but *don't* do this
        // if the block is sitting inside the beaker, since it will be dragged along with the beaker's motion.
        if (!isBlockStackedInBeaker) {
          // Use the perspective-compensated edge of the block instead of the model edge in order to simplify z-order
          // handling.
          const perspectiveBlockBounds = Bounds2.pool.create(blockBounds.minX - blockGroup.getElement(0).perspectiveCompensation.x, blockBounds.minY, blockBounds.maxX + blockGroup.getElement(0).perspectiveCompensation.x, blockBounds.maxY);

          // Clamp the translation of the beaker based on the test block's position.  This uses the sides of the beaker
          // and not it's outline so that the block can go inside.
          modelElement.translatedPositionTestingBoundsList.forEach(beakerEdgeBounds => {
            allowedTranslation = determineAllowedTranslation(beakerEdgeBounds, perspectiveBlockBounds, allowedTranslation.x, allowedTranslation.y, !isBlockStackedInBeaker, allowedTranslation);
          });
          perspectiveBlockBounds.freeToPool();
        }
      }
    });
    const newPosition = modelElementPosition.plus(allowedTranslation);

    // free reusable vectors and bounds
    allowedTranslation.freeToPool();
    modelElementBoundsWithSidePerspective.freeToPool();
    return newPosition;
  }
};

/**
 * Helper function to determine the portion of a proposed translation that may occur given a moving rectangle and a
 * stationary rectangle that can block the moving one.
 * @param {Bounds2} movingElementBounds
 * @param {Bounds2} stationaryElementBounds
 * @param {number} proposedTranslationX
 * @param {number} proposedTranslationY
 * @param {boolean} restrictPosY        Flag that controls whether the positive Y direction is restricted.  This
 *                                      is often set false if there is another model element on top of the one
 *                                      being tested.
 * @param {Vector2} [result] - optional vector to be reused
 * @returns {Vector2}
 */
function determineAllowedTranslation(movingElementBounds, stationaryElementBounds, proposedTranslationX, proposedTranslationY, restrictPosY, result) {
  result = result || new Vector2();

  // test for case where rectangles already overlap
  if (exclusiveIntersectsBounds(movingElementBounds, stationaryElementBounds) && restrictPosY) {
    // determine the motion in the X & Y directions that will "cure" the overlap
    let xOverlapCure = 0;
    if (movingElementBounds.maxX >= stationaryElementBounds.minX && movingElementBounds.minX <= stationaryElementBounds.minX) {
      xOverlapCure = stationaryElementBounds.minX - movingElementBounds.maxX;
    } else if (stationaryElementBounds.maxX >= movingElementBounds.minX && stationaryElementBounds.minX <= movingElementBounds.minX) {
      xOverlapCure = stationaryElementBounds.maxX - movingElementBounds.minX;
    }
    let yOverlapCure = 0;
    if (movingElementBounds.maxY >= stationaryElementBounds.minY && movingElementBounds.minY <= stationaryElementBounds.minY) {
      yOverlapCure = stationaryElementBounds.minY - movingElementBounds.maxY;
    } else if (stationaryElementBounds.maxY >= movingElementBounds.minY && stationaryElementBounds.minY <= movingElementBounds.minY) {
      yOverlapCure = stationaryElementBounds.maxY - movingElementBounds.minY;
    }

    // Something is wrong with algorithm if both values are zero, since overlap was detected by the "intersects"
    // method.
    assert && assert(!(xOverlapCure === 0 && yOverlapCure === 0), 'xOverlap and yOverlap should not both be zero');

    // return a vector with the smallest valid "cure" value, leaving the other translation value unchanged
    if (xOverlapCure !== 0 && Math.abs(xOverlapCure) < Math.abs(yOverlapCure)) {
      return result.setXY(xOverlapCure, proposedTranslationY);
    } else {
      return result.setXY(proposedTranslationX, yOverlapCure);
    }
  }
  let xTranslation = proposedTranslationX;
  let yTranslation = proposedTranslationY;
  const motionTestBounds = Bounds2.pool.fetch();

  // X direction
  if (proposedTranslationX > 0) {
    // check for collisions moving right
    motionTestBounds.setMinMax(movingElementBounds.maxX, movingElementBounds.minY, movingElementBounds.maxX + xTranslation, movingElementBounds.maxY);
    if (exclusiveIntersectsBounds(motionTestBounds, stationaryElementBounds)) {
      // collision detected, limit motion in this direction
      xTranslation = stationaryElementBounds.minX - movingElementBounds.maxX - MIN_INTER_ELEMENT_DISTANCE;
    }
  } else if (proposedTranslationX < 0) {
    // check for collisions moving left
    motionTestBounds.setMinMax(movingElementBounds.minX + xTranslation, movingElementBounds.minY, movingElementBounds.minX, movingElementBounds.maxY);
    if (exclusiveIntersectsBounds(motionTestBounds, stationaryElementBounds)) {
      // collision detected, limit motion in this direction
      xTranslation = stationaryElementBounds.maxX - movingElementBounds.minX + MIN_INTER_ELEMENT_DISTANCE;
    }
  }

  // Y direction.
  if (proposedTranslationY > 0 && restrictPosY) {
    // check for collisions moving up
    motionTestBounds.setMinMax(movingElementBounds.minX, movingElementBounds.maxY, movingElementBounds.maxX, movingElementBounds.maxY + yTranslation);
    if (exclusiveIntersectsBounds(motionTestBounds, stationaryElementBounds)) {
      // collision detected, limit motion
      yTranslation = stationaryElementBounds.minY - movingElementBounds.maxY - MIN_INTER_ELEMENT_DISTANCE;
    }
  } else if (proposedTranslationY < 0) {
    // check for collisions moving down
    motionTestBounds.setMinMax(movingElementBounds.minX, movingElementBounds.minY + yTranslation, movingElementBounds.maxX, movingElementBounds.minY);
    if (exclusiveIntersectsBounds(motionTestBounds, stationaryElementBounds)) {
      // collision detected, limit motion
      yTranslation = stationaryElementBounds.maxY - movingElementBounds.minY - MIN_INTER_ELEMENT_DISTANCE;
    }
  }
  return result.setXY(xTranslation, yTranslation);
}

/**
 * a version of Bounds2.intersectsBounds that doesn't count equal edges as intersection
 * @param {Bounds2} bounds1
 * @param {Bounds2} bounds2
 * @returns {boolean}
 * @public
 */
function exclusiveIntersectsBounds(bounds1, bounds2) {
  const minX = Math.max(bounds1.minX, bounds2.minX);
  const minY = Math.max(bounds1.minY, bounds2.minY);
  const maxX = Math.min(bounds1.maxX, bounds2.maxX);
  const maxY = Math.min(bounds1.maxY, bounds2.maxY);
  return maxX - minX > 0 && maxY - minY > 0;
}
energyFormsAndChanges.register('efacPositionConstrainer', efacPositionConstrainer);
export default efacPositionConstrainer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiVmVjdG9yMiIsIlBoZXRpb0dyb3VwIiwiZW5lcmd5Rm9ybXNBbmRDaGFuZ2VzIiwiQmVha2VyQ29udGFpbmVyIiwiQmxvY2siLCJNSU5fSU5URVJfRUxFTUVOVF9ESVNUQU5DRSIsInJldXNhYmxlQm91bmRzIiwiTk9USElORyIsImNvcHkiLCJlZmFjUG9zaXRpb25Db25zdHJhaW5lciIsImNvbnN0cmFpblBvc2l0aW9uIiwibW9kZWxFbGVtZW50IiwicHJvcG9zZWRQb3NpdGlvbiIsImJlYWtlckdyb3VwIiwiYmxvY2tHcm91cCIsImJ1cm5lckJsb2NraW5nUmVjdCIsImFzc2VydCIsIm1vZGVsRWxlbWVudFBvc2l0aW9uIiwicG9zaXRpb25Qcm9wZXJ0eSIsImdldCIsImFsbG93ZWRUcmFuc2xhdGlvbiIsInBvb2wiLCJjcmVhdGUiLCJ4IiwieSIsIm1vZGVsRWxlbWVudEJvdW5kcyIsImdldENvbXBvc2l0ZUJvdW5kc0ZvclBvc2l0aW9uIiwibW9kZWxFbGVtZW50Qm91bmRzV2l0aFNpZGVQZXJzcGVjdGl2ZSIsIm1pblgiLCJwZXJzcGVjdGl2ZUNvbXBlbnNhdGlvbiIsIm1pblkiLCJtYXhYIiwibWF4WSIsImRldGVybWluZUFsbG93ZWRUcmFuc2xhdGlvbiIsImZvckVhY2giLCJiZWFrZXIiLCJiZWFrZXJCb3VuZHNMaXN0IiwidHJhbnNsYXRlZFBvc2l0aW9uVGVzdGluZ0JvdW5kc0xpc3QiLCJtb2RlbEVsZW1lbnRCb3VuZHNXaXRoVG9wQW5kU2lkZVBlcnNwZWN0aXZlIiwiaXNTdGFja2VkVXBvbiIsImNlbnRlclgiLCJvdGhlckJlYWtlciIsImdldEVsZW1lbnQiLCJpbmRleE9mIiwib3RoZXJCZWFrZXJCb3VuZHNMaXN0IiwiY3VycmVudEJlYWtlckJvdW5kcyIsImdldEJvdW5kcyIsImZyZWVUb1Bvb2wiLCJibG9jayIsImJsb2NrQm91bmRzIiwiaXNCbG9ja1N0YWNrZWRJbkJlYWtlciIsInBlcnNwZWN0aXZlQmxvY2tCb3VuZHMiLCJiZWFrZXJFZGdlQm91bmRzIiwibmV3UG9zaXRpb24iLCJwbHVzIiwibW92aW5nRWxlbWVudEJvdW5kcyIsInN0YXRpb25hcnlFbGVtZW50Qm91bmRzIiwicHJvcG9zZWRUcmFuc2xhdGlvblgiLCJwcm9wb3NlZFRyYW5zbGF0aW9uWSIsInJlc3RyaWN0UG9zWSIsInJlc3VsdCIsImV4Y2x1c2l2ZUludGVyc2VjdHNCb3VuZHMiLCJ4T3ZlcmxhcEN1cmUiLCJ5T3ZlcmxhcEN1cmUiLCJNYXRoIiwiYWJzIiwic2V0WFkiLCJ4VHJhbnNsYXRpb24iLCJ5VHJhbnNsYXRpb24iLCJtb3Rpb25UZXN0Qm91bmRzIiwiZmV0Y2giLCJzZXRNaW5NYXgiLCJib3VuZHMxIiwiYm91bmRzMiIsIm1heCIsIm1pbiIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiZWZhY1Bvc2l0aW9uQ29uc3RyYWluZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSBzaW5nbGV0b24gdGhhdCBlbmNhcHN1bGF0ZXMgdGhlIGluZm9ybWF0aW9uIGFuZCBhbGdvcml0aG1zIG5lY2Vzc2FyeSB0byBjb25zdHJhaW4gdGhlIG1vdGlvbiBvZiBtb2RlbCBlbGVtZW50cyBzdWNoXHJcbiAqIHRoYXQgdGhleSBjYW4ndCBiZSBkcmFnZ2VkIHRocm91Z2ggb25lIGFub3RoZXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICogQGF1dGhvciBDaHJpcyBLbHVzZW5kb3JmXHJcbiAqL1xyXG5cclxuaW1wb3J0IEJvdW5kczIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL0JvdW5kczIuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBQaGV0aW9Hcm91cCBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvUGhldGlvR3JvdXAuanMnO1xyXG5pbXBvcnQgZW5lcmd5Rm9ybXNBbmRDaGFuZ2VzIGZyb20gJy4uLy4uL2VuZXJneUZvcm1zQW5kQ2hhbmdlcy5qcyc7XHJcbmltcG9ydCBCZWFrZXJDb250YWluZXIgZnJvbSAnLi9CZWFrZXJDb250YWluZXIuanMnO1xyXG5pbXBvcnQgQmxvY2sgZnJvbSAnLi9CbG9jay5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuXHJcbi8vIG1pbmltdW0gZGlzdGFuY2UgYWxsb3dlZCBiZXR3ZWVuIHR3byBvYmplY3RzLCB1c2VkIHRvIHByZXZlbnQgZmxvYXRpbmcgcG9pbnQgaXNzdWVzXHJcbmNvbnN0IE1JTl9JTlRFUl9FTEVNRU5UX0RJU1RBTkNFID0gMUUtOTsgLy8gaW4gbWV0ZXJzXHJcblxyXG4vLyByZXVzYWJsZSBpdGVtcywgYXZvaWRzIGFsbG9jYXRpb25zXHJcbmNvbnN0IHJldXNhYmxlQm91bmRzID0gQm91bmRzMi5OT1RISU5HLmNvcHkoKTtcclxuXHJcbi8vIHRoZSBtYWluIHNpbmdsZXRvbiBvYmplY3QgZGVmaW5pdGlvblxyXG5jb25zdCBlZmFjUG9zaXRpb25Db25zdHJhaW5lciA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRXZhbHVhdGUgd2hldGhlciB0aGUgcHJvdmlkZWQgbW9kZWwgZWxlbWVudCBjYW4gYmUgbW92ZWQgdG8gdGhlIHByb3ZpZGVkIHBvc2l0aW9uIHdpdGhvdXQgb3ZlcmxhcHBpbmcgd2l0aCBvdGhlclxyXG4gICAqIHNvbGlkIG1vZGVsIGVsZW1lbnRzLiBJZiBvdmVybGFwIHdvdWxkIG9jY3VyLCBhZGp1c3QgdGhlIHBvc2l0aW9uIHRvIG9uZSB0aGF0IHdvcmtzLiBOb3RlIHRoYXQgdGhpcyBpcyBub3RcclxuICAgKiB2ZXJ5IGdlbmVyYWwgZHVlIHRvIGEgbnVtYmVyIG9mIHNwZWNpYWwgcmVxdWlyZW1lbnRzIGZvciB0aGUgRW5lcmd5IEZvcm1zIGFuZCBDaGFuZ2VzIHNpbSwgc28gaXQgd291bGQgbGlrZWx5IG5vdFxyXG4gICAqIGJlIGVhc3kgdG8gcmV1c2UuXHJcbiAgICogQHBhcmFtIHtSZWN0YW5ndWxhclRoZXJtYWxNb3ZhYmxlTW9kZWxFbGVtZW50fSBtb2RlbEVsZW1lbnQgLSBlbGVtZW50IHdob3NlIHBvc2l0aW9uIGlzIGJlaW5nIGNoZWNrZWRcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHByb3Bvc2VkUG9zaXRpb24gLSB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIG1vZGVsIGVsZW1lbnQgd291bGQgbGlrZSB0byBnb1xyXG4gICAqIEBwYXJhbSB7UGhldGlvR3JvdXAuPEJlYWtlckNvbnRhaW5lcj59IGJlYWtlckdyb3VwIC0gdGhlIGJlYWtlcnMgdGhhdCBhcmUgcHJlc2VudCBpbiB0aGUgbW9kZWxcclxuICAgKiBAcGFyYW0ge1BoZXRpb0dyb3VwLjxCbG9jaz59IGJsb2NrR3JvdXAgLSB0aGUgYmxvY2tzIHRoYXQgYXJlIHByZXNlbnQgaW4gdGhlIG1vZGVsXHJcbiAgICogQHBhcmFtIHtCb3VuZHMyfSBidXJuZXJCbG9ja2luZ1JlY3QgLSB0aGUgc3BhY2Ugb2NjdXBpZWQgYnkgdGhlIGJ1cm5lcnMgaW4gdGhlIG1vZGVsXHJcbiAgICogQHJldHVybnMge1ZlY3RvcjJ9IHRoZSBvcmlnaW5hbCBwcm9wb3NlZCBwb3NpdGlvbiBpZiB2YWxpZCwgb3IgYWx0ZXJuYXRpdmUgcG9zaXRpb24gaWYgbm90XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGNvbnN0cmFpblBvc2l0aW9uOiAoIG1vZGVsRWxlbWVudCwgcHJvcG9zZWRQb3NpdGlvbiwgYmVha2VyR3JvdXAsIGJsb2NrR3JvdXAsIGJ1cm5lckJsb2NraW5nUmVjdCApID0+IHtcclxuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBiZWFrZXJHcm91cCBpbnN0YW5jZW9mIFBoZXRpb0dyb3VwLCAnaW52YWxpZCBiZWFrZXJHcm91cCcgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGJsb2NrR3JvdXAgaW5zdGFuY2VvZiBQaGV0aW9Hcm91cCwgJ2ludmFsaWQgYmxvY2tHcm91cCcgKTtcclxuXHJcbiAgICBjb25zdCBtb2RlbEVsZW1lbnRQb3NpdGlvbiA9IG1vZGVsRWxlbWVudC5wb3NpdGlvblByb3BlcnR5LmdldCgpO1xyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcHJvcG9zZWQgbW90aW9uXHJcbiAgICBsZXQgYWxsb3dlZFRyYW5zbGF0aW9uID0gVmVjdG9yMi5wb29sLmNyZWF0ZShcclxuICAgICAgcHJvcG9zZWRQb3NpdGlvbi54IC0gbW9kZWxFbGVtZW50UG9zaXRpb24ueCxcclxuICAgICAgcHJvcG9zZWRQb3NpdGlvbi55IC0gbW9kZWxFbGVtZW50UG9zaXRpb24ueVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBnZXQgdGhlIGN1cnJlbnQgY29tcG9zaXRlIGJvdW5kcyBvZiB0aGUgbW9kZWwgZWxlbWVudFxyXG4gICAgY29uc3QgbW9kZWxFbGVtZW50Qm91bmRzID0gbW9kZWxFbGVtZW50LmdldENvbXBvc2l0ZUJvdW5kc0ZvclBvc2l0aW9uKFxyXG4gICAgICBtb2RlbEVsZW1lbnRQb3NpdGlvbixcclxuICAgICAgcmV1c2FibGVCb3VuZHNcclxuICAgICk7XHJcblxyXG4gICAgLy8gY3JlYXRlIGJvdW5kcyB0aGF0IHVzZSB0aGUgcGVyc3BlY3RpdmUgY29tcGVuc2F0aW9uIHRoYXQgaXMgbmVjZXNzYXJ5IGZvciBldmFsdWF0aW5nIGJ1cm5lciBpbnRlcmFjdGlvblxyXG4gICAgY29uc3QgbW9kZWxFbGVtZW50Qm91bmRzV2l0aFNpZGVQZXJzcGVjdGl2ZSA9IEJvdW5kczIucG9vbC5jcmVhdGUoXHJcbiAgICAgIG1vZGVsRWxlbWVudEJvdW5kcy5taW5YIC0gbW9kZWxFbGVtZW50LnBlcnNwZWN0aXZlQ29tcGVuc2F0aW9uLngsXHJcbiAgICAgIG1vZGVsRWxlbWVudEJvdW5kcy5taW5ZLFxyXG4gICAgICBtb2RlbEVsZW1lbnRCb3VuZHMubWF4WCArIG1vZGVsRWxlbWVudC5wZXJzcGVjdGl2ZUNvbXBlbnNhdGlvbi54LFxyXG4gICAgICBtb2RlbEVsZW1lbnRCb3VuZHMubWF4WVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyB2YWxpZGF0ZSBhZ2FpbnN0IGJ1cm5lciBib3VuZGFyaWVzXHJcbiAgICBhbGxvd2VkVHJhbnNsYXRpb24gPSBkZXRlcm1pbmVBbGxvd2VkVHJhbnNsYXRpb24oXHJcbiAgICAgIG1vZGVsRWxlbWVudEJvdW5kc1dpdGhTaWRlUGVyc3BlY3RpdmUsXHJcbiAgICAgIGJ1cm5lckJsb2NraW5nUmVjdCxcclxuICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uLngsXHJcbiAgICAgIGFsbG93ZWRUcmFuc2xhdGlvbi55LFxyXG4gICAgICB0cnVlLFxyXG4gICAgICBhbGxvd2VkVHJhbnNsYXRpb25cclxuICAgICk7XHJcblxyXG4gICAgLy8gbm93IGNoZWNrIHRoZSBtb2RlbCBlbGVtZW50J3MgbW90aW9uIGFnYWluc3QgZWFjaCBvZiB0aGUgYmVha2Vyc1xyXG4gICAgYmVha2VyR3JvdXAuZm9yRWFjaCggYmVha2VyID0+IHtcclxuXHJcbiAgICAgIGlmICggYmVha2VyID09PSBtb2RlbEVsZW1lbnQgKSB7XHJcblxyXG4gICAgICAgIC8vIGRvbid0IHRlc3QgYWdhaW5zdCBzZWxmXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBnZXQgdGhlIGJvdW5kcyBzZXQgdGhhdCBkZXNjcmliZXMgdGhlIHNoYXBlIG9mIHRoZSBiZWFrZXJcclxuICAgICAgY29uc3QgYmVha2VyQm91bmRzTGlzdCA9IGJlYWtlci50cmFuc2xhdGVkUG9zaXRpb25UZXN0aW5nQm91bmRzTGlzdDtcclxuXHJcbiAgICAgIC8vIGlmIHRoZSBtb2RlbEVsZW1lbnQgaXMgYSBibG9jaywgaXQgaGFzIHggYW5kIHkgcGVyc3BlY3RpdmUgY29tcCB0aGF0IG5lZWQgdG8gYmUgdXNlZFxyXG4gICAgICBjb25zdCBtb2RlbEVsZW1lbnRCb3VuZHNXaXRoVG9wQW5kU2lkZVBlcnNwZWN0aXZlID0gQm91bmRzMi5wb29sLmNyZWF0ZShcclxuICAgICAgICBtb2RlbEVsZW1lbnRCb3VuZHMubWluWCAtIG1vZGVsRWxlbWVudC5wZXJzcGVjdGl2ZUNvbXBlbnNhdGlvbi54LFxyXG4gICAgICAgIG1vZGVsRWxlbWVudEJvdW5kcy5taW5ZIC0gbW9kZWxFbGVtZW50LnBlcnNwZWN0aXZlQ29tcGVuc2F0aW9uLnksXHJcbiAgICAgICAgbW9kZWxFbGVtZW50Qm91bmRzLm1heFggKyBtb2RlbEVsZW1lbnQucGVyc3BlY3RpdmVDb21wZW5zYXRpb24ueCxcclxuICAgICAgICBtb2RlbEVsZW1lbnRCb3VuZHMubWF4WSArIG1vZGVsRWxlbWVudC5wZXJzcGVjdGl2ZUNvbXBlbnNhdGlvbi55XHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBkb24ndCByZXN0cmljdCB0aGUgbW90aW9uIGJhc2VkIG9uIHRoZSBiZWFrZXIgaWYgdGhlIGJlYWtlciBpcyBvbiB0b3Agb2YgdGhpcyBtb2RlbCBlbGVtZW50XHJcbiAgICAgIGlmICggIWJlYWtlci5pc1N0YWNrZWRVcG9uKCBtb2RlbEVsZW1lbnQgKSApIHtcclxuXHJcbiAgICAgICAgLy8gdGhlIGNvZGUgYmVsb3cgYXNzdW1lcyB0aGF0IHRoZSBib3VuZHMgbGlzdCBpcyBpbiB0aGUgb3JkZXI6IGxlZnQgc2lkZSwgYm90dG9tLCByaWdodCBzaWRlLiB0aGlzIGFzc2VydGlvblxyXG4gICAgICAgIC8vIHZlcmlmaWVzIHRoYXQuXHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydChcclxuICAgICAgICBiZWFrZXJCb3VuZHNMaXN0WyAwIF0uY2VudGVyWCA8IGJlYWtlckJvdW5kc0xpc3RbIDEgXS5jZW50ZXJYICYmXHJcbiAgICAgICAgYmVha2VyQm91bmRzTGlzdFsgMSBdLmNlbnRlclggPCBiZWFrZXJCb3VuZHNMaXN0WyAyIF0uY2VudGVyWCxcclxuICAgICAgICAgICdiZWFrZXIgYm91bmRzIGxpc3QgaXMgb3V0IG9mIG9yZGVyJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGFsbG93ZWRUcmFuc2xhdGlvbiA9IGRldGVybWluZUFsbG93ZWRUcmFuc2xhdGlvbihcclxuICAgICAgICAgIG1vZGVsRWxlbWVudEJvdW5kc1dpdGhUb3BBbmRTaWRlUGVyc3BlY3RpdmUsXHJcbiAgICAgICAgICBiZWFrZXJCb3VuZHNMaXN0WyAwIF0sXHJcbiAgICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb24ueCxcclxuICAgICAgICAgIGFsbG93ZWRUcmFuc2xhdGlvbi55LFxyXG4gICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgIGFsbG93ZWRUcmFuc2xhdGlvblxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uID0gZGV0ZXJtaW5lQWxsb3dlZFRyYW5zbGF0aW9uKFxyXG4gICAgICAgICAgbW9kZWxFbGVtZW50Qm91bmRzV2l0aFNpZGVQZXJzcGVjdGl2ZSxcclxuICAgICAgICAgIGJlYWtlckJvdW5kc0xpc3RbIDEgXSxcclxuICAgICAgICAgIGFsbG93ZWRUcmFuc2xhdGlvbi54LFxyXG4gICAgICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uLnksXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb24gPSBkZXRlcm1pbmVBbGxvd2VkVHJhbnNsYXRpb24oXHJcbiAgICAgICAgICBtb2RlbEVsZW1lbnRCb3VuZHNXaXRoVG9wQW5kU2lkZVBlcnNwZWN0aXZlLFxyXG4gICAgICAgICAgYmVha2VyQm91bmRzTGlzdFsgMiBdLFxyXG4gICAgICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb24ueSxcclxuICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb25cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBpZiBiZWFrZXIgQSBpcyBzdGFja2VkIG9uIHRoZSBjdXJyZW50IG1vZGVsRWxlbWVudCwgZ2V0IGJlYWtlciBCIGRpcmVjdGx5IGFzIG90aGVyQmVha2VyIGJlY2F1c2UgY3VycmVudGx5XHJcbiAgICAgICAgLy8gdGhlcmUgY2FuJ3QgYmUgbW9yZSB0aGFuIHR3byBiZWFrZXJzLiB0aGlzIHdpbGwgbmVlZCB0byBiZSBnZW5lcmFsaXplZCB0byBjaGVjayBmb3IgZWFjaCBvdGhlciBiZWFrZXIgdGhhdCBpcyBub3RcclxuICAgICAgICAvLyBzdGFja2VkIG9uIHRoaXMgbW9kZWxFbGVtZW50IGlmIHRoZSB0aW1lIGNvbWVzIHdoZW4gbW9yZSB0aGFuIHR3byBiZWFrZXJzIGNhbiBleGlzdC5cclxuICAgICAgICBjb25zdCBvdGhlckJlYWtlciA9IGJlYWtlckdyb3VwLmdldEVsZW1lbnQoIDEgLSBiZWFrZXJHcm91cC5pbmRleE9mKCBiZWFrZXIgKSApO1xyXG5cclxuICAgICAgICAvLyBhIHNlY29uZCBiZWFrZXIgbWF5IG5vdCBleGlzdFxyXG4gICAgICAgIGlmICggb3RoZXJCZWFrZXIgKSB7XHJcblxyXG4gICAgICAgICAgLy8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIG90aGVyIGJlYWtlciBhbmQgdGhlIGJvdW5kcyBvZiB0aGUgYmVha2VyIHN0YWNrZWQgb24gdG9wIG9mIHRoaXMgbW9kZWxFbGVtZW50XHJcbiAgICAgICAgICBjb25zdCBvdGhlckJlYWtlckJvdW5kc0xpc3QgPSBvdGhlckJlYWtlci50cmFuc2xhdGVkUG9zaXRpb25UZXN0aW5nQm91bmRzTGlzdDtcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRCZWFrZXJCb3VuZHMgPSBiZWFrZXIuZ2V0Qm91bmRzKCk7XHJcblxyXG4gICAgICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uID0gZGV0ZXJtaW5lQWxsb3dlZFRyYW5zbGF0aW9uKFxyXG4gICAgICAgICAgICBjdXJyZW50QmVha2VyQm91bmRzLFxyXG4gICAgICAgICAgICBvdGhlckJlYWtlckJvdW5kc0xpc3RbIDAgXSxcclxuICAgICAgICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICAgIGFsbG93ZWRUcmFuc2xhdGlvbi55LFxyXG4gICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb25cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb24gPSBkZXRlcm1pbmVBbGxvd2VkVHJhbnNsYXRpb24oXHJcbiAgICAgICAgICAgIGN1cnJlbnRCZWFrZXJCb3VuZHMsXHJcbiAgICAgICAgICAgIG90aGVyQmVha2VyQm91bmRzTGlzdFsgMSBdLFxyXG4gICAgICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb24ueCxcclxuICAgICAgICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uLnksXHJcbiAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgIGFsbG93ZWRUcmFuc2xhdGlvblxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGFsbG93ZWRUcmFuc2xhdGlvbiA9IGRldGVybWluZUFsbG93ZWRUcmFuc2xhdGlvbihcclxuICAgICAgICAgICAgY3VycmVudEJlYWtlckJvdW5kcyxcclxuICAgICAgICAgICAgb3RoZXJCZWFrZXJCb3VuZHNMaXN0WyAyIF0sXHJcbiAgICAgICAgICAgIGFsbG93ZWRUcmFuc2xhdGlvbi54LFxyXG4gICAgICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb24ueSxcclxuICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbW9kZWxFbGVtZW50Qm91bmRzV2l0aFRvcEFuZFNpZGVQZXJzcGVjdGl2ZS5mcmVlVG9Qb29sKCk7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gbm93IGNoZWNrIHRoZSBtb2RlbCBlbGVtZW50J3MgbW90aW9uIGFnYWluc3QgZWFjaCBvZiB0aGUgYmxvY2tzXHJcbiAgICBibG9ja0dyb3VwLmZvckVhY2goIGJsb2NrID0+IHtcclxuXHJcbiAgICAgIGlmICggYmxvY2sgPT09IG1vZGVsRWxlbWVudCApIHtcclxuXHJcbiAgICAgICAgLy8gZG9uJ3QgdGVzdCBhZ2FpbnN0IHNlbGZcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGJsb2NrQm91bmRzID0gYmxvY2suZ2V0Qm91bmRzKCk7XHJcblxyXG4gICAgICAvLyBEbyBub3QgcmVzdHJpY3QgdGhlIG1vZGVsIGVsZW1lbnQncyBtb3Rpb24gaW4gcG9zaXRpdmUgWSBkaXJlY3Rpb24gaWYgdGhlIHRlc3RlZCBibG9jayBpcyBzaXR0aW5nIG9uIHRvcCBvZlxyXG4gICAgICAvLyB0aGUgbW9kZWwgZWxlbWVudCAtIHRoZSBibG9jayB3aWxsIHNpbXBseSBiZSBsaWZ0ZWQgdXAuXHJcbiAgICAgIGNvbnN0IGlzQmxvY2tTdGFja2VkSW5CZWFrZXIgPSBibG9jay5pc1N0YWNrZWRVcG9uKCBtb2RlbEVsZW1lbnQgKTtcclxuXHJcbiAgICAgIGlmICggbW9kZWxFbGVtZW50IGluc3RhbmNlb2YgQmxvY2sgKSB7XHJcblxyXG4gICAgICAgIGFsbG93ZWRUcmFuc2xhdGlvbiA9IGRldGVybWluZUFsbG93ZWRUcmFuc2xhdGlvbihcclxuICAgICAgICAgIG1vZGVsRWxlbWVudC5nZXRCb3VuZHMoKSxcclxuICAgICAgICAgIGJsb2NrQm91bmRzLFxyXG4gICAgICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb24ueSxcclxuICAgICAgICAgICFpc0Jsb2NrU3RhY2tlZEluQmVha2VyLCAvLyBkb24ndCByZXN0cmljdCBpbiBZIGRpcmVjdGlvbiBpZiB0aGlzIGJsb2NrIGlzIHNpdHRpbmcgaW4gdGhlIGJlYWtlclxyXG4gICAgICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoaXMgaXMgYSBiZWFrZXIgYmVmb3JlIGdvaW5nIGFueSBmdXJ0aGVyXHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggbW9kZWxFbGVtZW50IGluc3RhbmNlb2YgQmVha2VyQ29udGFpbmVyLCAndW5yZWNvZ25pemVkIG1vZGVsIGVsZW1lbnQgdHlwZScgKTtcclxuXHJcbiAgICAgICAgLy8gVGVzdCB0byBzZWUgaWYgdGhlIGJlYWtlcidzIG1vdGlvbiBuZWVkcyB0byBiZSBjb25zdHJhaW5lZCBkdWUgdG8gdGhlIGJsb2NrJ3MgcG9zaXRpb24sIGJ1dCAqZG9uJ3QqIGRvIHRoaXNcclxuICAgICAgICAvLyBpZiB0aGUgYmxvY2sgaXMgc2l0dGluZyBpbnNpZGUgdGhlIGJlYWtlciwgc2luY2UgaXQgd2lsbCBiZSBkcmFnZ2VkIGFsb25nIHdpdGggdGhlIGJlYWtlcidzIG1vdGlvbi5cclxuICAgICAgICBpZiAoICFpc0Jsb2NrU3RhY2tlZEluQmVha2VyICkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSB0aGUgcGVyc3BlY3RpdmUtY29tcGVuc2F0ZWQgZWRnZSBvZiB0aGUgYmxvY2sgaW5zdGVhZCBvZiB0aGUgbW9kZWwgZWRnZSBpbiBvcmRlciB0byBzaW1wbGlmeSB6LW9yZGVyXHJcbiAgICAgICAgICAvLyBoYW5kbGluZy5cclxuICAgICAgICAgIGNvbnN0IHBlcnNwZWN0aXZlQmxvY2tCb3VuZHMgPSBCb3VuZHMyLnBvb2wuY3JlYXRlKFxyXG4gICAgICAgICAgICBibG9ja0JvdW5kcy5taW5YIC0gYmxvY2tHcm91cC5nZXRFbGVtZW50KCAwICkucGVyc3BlY3RpdmVDb21wZW5zYXRpb24ueCxcclxuICAgICAgICAgICAgYmxvY2tCb3VuZHMubWluWSxcclxuICAgICAgICAgICAgYmxvY2tCb3VuZHMubWF4WCArIGJsb2NrR3JvdXAuZ2V0RWxlbWVudCggMCApLnBlcnNwZWN0aXZlQ29tcGVuc2F0aW9uLngsXHJcbiAgICAgICAgICAgIGJsb2NrQm91bmRzLm1heFlcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gQ2xhbXAgdGhlIHRyYW5zbGF0aW9uIG9mIHRoZSBiZWFrZXIgYmFzZWQgb24gdGhlIHRlc3QgYmxvY2sncyBwb3NpdGlvbi4gIFRoaXMgdXNlcyB0aGUgc2lkZXMgb2YgdGhlIGJlYWtlclxyXG4gICAgICAgICAgLy8gYW5kIG5vdCBpdCdzIG91dGxpbmUgc28gdGhhdCB0aGUgYmxvY2sgY2FuIGdvIGluc2lkZS5cclxuICAgICAgICAgIG1vZGVsRWxlbWVudC50cmFuc2xhdGVkUG9zaXRpb25UZXN0aW5nQm91bmRzTGlzdC5mb3JFYWNoKCBiZWFrZXJFZGdlQm91bmRzID0+IHtcclxuICAgICAgICAgICAgYWxsb3dlZFRyYW5zbGF0aW9uID0gZGV0ZXJtaW5lQWxsb3dlZFRyYW5zbGF0aW9uKFxyXG4gICAgICAgICAgICAgIGJlYWtlckVkZ2VCb3VuZHMsXHJcbiAgICAgICAgICAgICAgcGVyc3BlY3RpdmVCbG9ja0JvdW5kcyxcclxuICAgICAgICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb24ueCxcclxuICAgICAgICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb24ueSxcclxuICAgICAgICAgICAgICAhaXNCbG9ja1N0YWNrZWRJbkJlYWtlcixcclxuICAgICAgICAgICAgICBhbGxvd2VkVHJhbnNsYXRpb25cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICBwZXJzcGVjdGl2ZUJsb2NrQm91bmRzLmZyZWVUb1Bvb2woKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG1vZGVsRWxlbWVudFBvc2l0aW9uLnBsdXMoIGFsbG93ZWRUcmFuc2xhdGlvbiApO1xyXG5cclxuICAgIC8vIGZyZWUgcmV1c2FibGUgdmVjdG9ycyBhbmQgYm91bmRzXHJcbiAgICBhbGxvd2VkVHJhbnNsYXRpb24uZnJlZVRvUG9vbCgpO1xyXG4gICAgbW9kZWxFbGVtZW50Qm91bmRzV2l0aFNpZGVQZXJzcGVjdGl2ZS5mcmVlVG9Qb29sKCk7XHJcblxyXG4gICAgcmV0dXJuIG5ld1Bvc2l0aW9uO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSBwb3J0aW9uIG9mIGEgcHJvcG9zZWQgdHJhbnNsYXRpb24gdGhhdCBtYXkgb2NjdXIgZ2l2ZW4gYSBtb3ZpbmcgcmVjdGFuZ2xlIGFuZCBhXHJcbiAqIHN0YXRpb25hcnkgcmVjdGFuZ2xlIHRoYXQgY2FuIGJsb2NrIHRoZSBtb3Zpbmcgb25lLlxyXG4gKiBAcGFyYW0ge0JvdW5kczJ9IG1vdmluZ0VsZW1lbnRCb3VuZHNcclxuICogQHBhcmFtIHtCb3VuZHMyfSBzdGF0aW9uYXJ5RWxlbWVudEJvdW5kc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gcHJvcG9zZWRUcmFuc2xhdGlvblhcclxuICogQHBhcmFtIHtudW1iZXJ9IHByb3Bvc2VkVHJhbnNsYXRpb25ZXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVzdHJpY3RQb3NZICAgICAgICBGbGFnIHRoYXQgY29udHJvbHMgd2hldGhlciB0aGUgcG9zaXRpdmUgWSBkaXJlY3Rpb24gaXMgcmVzdHJpY3RlZC4gIFRoaXNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIG9mdGVuIHNldCBmYWxzZSBpZiB0aGVyZSBpcyBhbm90aGVyIG1vZGVsIGVsZW1lbnQgb24gdG9wIG9mIHRoZSBvbmVcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlaW5nIHRlc3RlZC5cclxuICogQHBhcmFtIHtWZWN0b3IyfSBbcmVzdWx0XSAtIG9wdGlvbmFsIHZlY3RvciB0byBiZSByZXVzZWRcclxuICogQHJldHVybnMge1ZlY3RvcjJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBkZXRlcm1pbmVBbGxvd2VkVHJhbnNsYXRpb24oIG1vdmluZ0VsZW1lbnRCb3VuZHMsIHN0YXRpb25hcnlFbGVtZW50Qm91bmRzLCBwcm9wb3NlZFRyYW5zbGF0aW9uWCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NlZFRyYW5zbGF0aW9uWSwgcmVzdHJpY3RQb3NZLCByZXN1bHQgKSB7XHJcblxyXG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cclxuICAvLyB0ZXN0IGZvciBjYXNlIHdoZXJlIHJlY3RhbmdsZXMgYWxyZWFkeSBvdmVybGFwXHJcbiAgaWYgKCBleGNsdXNpdmVJbnRlcnNlY3RzQm91bmRzKCBtb3ZpbmdFbGVtZW50Qm91bmRzLCBzdGF0aW9uYXJ5RWxlbWVudEJvdW5kcyApICYmIHJlc3RyaWN0UG9zWSApIHtcclxuXHJcbiAgICAvLyBkZXRlcm1pbmUgdGhlIG1vdGlvbiBpbiB0aGUgWCAmIFkgZGlyZWN0aW9ucyB0aGF0IHdpbGwgXCJjdXJlXCIgdGhlIG92ZXJsYXBcclxuICAgIGxldCB4T3ZlcmxhcEN1cmUgPSAwO1xyXG4gICAgaWYgKCBtb3ZpbmdFbGVtZW50Qm91bmRzLm1heFggPj0gc3RhdGlvbmFyeUVsZW1lbnRCb3VuZHMubWluWCAmJlxyXG4gICAgICAgICBtb3ZpbmdFbGVtZW50Qm91bmRzLm1pblggPD0gc3RhdGlvbmFyeUVsZW1lbnRCb3VuZHMubWluWCApIHtcclxuXHJcbiAgICAgIHhPdmVybGFwQ3VyZSA9IHN0YXRpb25hcnlFbGVtZW50Qm91bmRzLm1pblggLSBtb3ZpbmdFbGVtZW50Qm91bmRzLm1heFg7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggc3RhdGlvbmFyeUVsZW1lbnRCb3VuZHMubWF4WCA+PSBtb3ZpbmdFbGVtZW50Qm91bmRzLm1pblggJiZcclxuICAgICAgICAgICAgICBzdGF0aW9uYXJ5RWxlbWVudEJvdW5kcy5taW5YIDw9IG1vdmluZ0VsZW1lbnRCb3VuZHMubWluWCApIHtcclxuXHJcbiAgICAgIHhPdmVybGFwQ3VyZSA9IHN0YXRpb25hcnlFbGVtZW50Qm91bmRzLm1heFggLSBtb3ZpbmdFbGVtZW50Qm91bmRzLm1pblg7XHJcbiAgICB9XHJcbiAgICBsZXQgeU92ZXJsYXBDdXJlID0gMDtcclxuICAgIGlmICggbW92aW5nRWxlbWVudEJvdW5kcy5tYXhZID49IHN0YXRpb25hcnlFbGVtZW50Qm91bmRzLm1pblkgJiZcclxuICAgICAgICAgbW92aW5nRWxlbWVudEJvdW5kcy5taW5ZIDw9IHN0YXRpb25hcnlFbGVtZW50Qm91bmRzLm1pblkgKSB7XHJcblxyXG4gICAgICB5T3ZlcmxhcEN1cmUgPSBzdGF0aW9uYXJ5RWxlbWVudEJvdW5kcy5taW5ZIC0gbW92aW5nRWxlbWVudEJvdW5kcy5tYXhZO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIHN0YXRpb25hcnlFbGVtZW50Qm91bmRzLm1heFkgPj0gbW92aW5nRWxlbWVudEJvdW5kcy5taW5ZICYmXHJcbiAgICAgICAgICAgICAgc3RhdGlvbmFyeUVsZW1lbnRCb3VuZHMubWluWSA8PSBtb3ZpbmdFbGVtZW50Qm91bmRzLm1pblkgKSB7XHJcblxyXG4gICAgICB5T3ZlcmxhcEN1cmUgPSBzdGF0aW9uYXJ5RWxlbWVudEJvdW5kcy5tYXhZIC0gbW92aW5nRWxlbWVudEJvdW5kcy5taW5ZO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvbWV0aGluZyBpcyB3cm9uZyB3aXRoIGFsZ29yaXRobSBpZiBib3RoIHZhbHVlcyBhcmUgemVybywgc2luY2Ugb3ZlcmxhcCB3YXMgZGV0ZWN0ZWQgYnkgdGhlIFwiaW50ZXJzZWN0c1wiXHJcbiAgICAvLyBtZXRob2QuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KFxyXG4gICAgICAhKCB4T3ZlcmxhcEN1cmUgPT09IDAgJiYgeU92ZXJsYXBDdXJlID09PSAwICksXHJcbiAgICAgICd4T3ZlcmxhcCBhbmQgeU92ZXJsYXAgc2hvdWxkIG5vdCBib3RoIGJlIHplcm8nXHJcbiAgICApO1xyXG5cclxuICAgIC8vIHJldHVybiBhIHZlY3RvciB3aXRoIHRoZSBzbWFsbGVzdCB2YWxpZCBcImN1cmVcIiB2YWx1ZSwgbGVhdmluZyB0aGUgb3RoZXIgdHJhbnNsYXRpb24gdmFsdWUgdW5jaGFuZ2VkXHJcbiAgICBpZiAoIHhPdmVybGFwQ3VyZSAhPT0gMCAmJiBNYXRoLmFicyggeE92ZXJsYXBDdXJlICkgPCBNYXRoLmFicyggeU92ZXJsYXBDdXJlICkgKSB7XHJcbiAgICAgIHJldHVybiByZXN1bHQuc2V0WFkoIHhPdmVybGFwQ3VyZSwgcHJvcG9zZWRUcmFuc2xhdGlvblkgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gcmVzdWx0LnNldFhZKCBwcm9wb3NlZFRyYW5zbGF0aW9uWCwgeU92ZXJsYXBDdXJlICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsZXQgeFRyYW5zbGF0aW9uID0gcHJvcG9zZWRUcmFuc2xhdGlvblg7XHJcbiAgbGV0IHlUcmFuc2xhdGlvbiA9IHByb3Bvc2VkVHJhbnNsYXRpb25ZO1xyXG4gIGNvbnN0IG1vdGlvblRlc3RCb3VuZHMgPSBCb3VuZHMyLnBvb2wuZmV0Y2goKTtcclxuXHJcbiAgLy8gWCBkaXJlY3Rpb25cclxuICBpZiAoIHByb3Bvc2VkVHJhbnNsYXRpb25YID4gMCApIHtcclxuXHJcbiAgICAvLyBjaGVjayBmb3IgY29sbGlzaW9ucyBtb3ZpbmcgcmlnaHRcclxuICAgIG1vdGlvblRlc3RCb3VuZHMuc2V0TWluTWF4KFxyXG4gICAgICBtb3ZpbmdFbGVtZW50Qm91bmRzLm1heFgsXHJcbiAgICAgIG1vdmluZ0VsZW1lbnRCb3VuZHMubWluWSxcclxuICAgICAgbW92aW5nRWxlbWVudEJvdW5kcy5tYXhYICsgeFRyYW5zbGF0aW9uLFxyXG4gICAgICBtb3ZpbmdFbGVtZW50Qm91bmRzLm1heFlcclxuICAgICk7XHJcblxyXG4gICAgaWYgKCBleGNsdXNpdmVJbnRlcnNlY3RzQm91bmRzKCBtb3Rpb25UZXN0Qm91bmRzLCBzdGF0aW9uYXJ5RWxlbWVudEJvdW5kcyApICkge1xyXG5cclxuICAgICAgLy8gY29sbGlzaW9uIGRldGVjdGVkLCBsaW1pdCBtb3Rpb24gaW4gdGhpcyBkaXJlY3Rpb25cclxuICAgICAgeFRyYW5zbGF0aW9uID0gc3RhdGlvbmFyeUVsZW1lbnRCb3VuZHMubWluWCAtIG1vdmluZ0VsZW1lbnRCb3VuZHMubWF4WCAtIE1JTl9JTlRFUl9FTEVNRU5UX0RJU1RBTkNFO1xyXG4gICAgfVxyXG4gIH1cclxuICBlbHNlIGlmICggcHJvcG9zZWRUcmFuc2xhdGlvblggPCAwICkge1xyXG5cclxuICAgIC8vIGNoZWNrIGZvciBjb2xsaXNpb25zIG1vdmluZyBsZWZ0XHJcbiAgICBtb3Rpb25UZXN0Qm91bmRzLnNldE1pbk1heChcclxuICAgICAgbW92aW5nRWxlbWVudEJvdW5kcy5taW5YICsgeFRyYW5zbGF0aW9uLFxyXG4gICAgICBtb3ZpbmdFbGVtZW50Qm91bmRzLm1pblksXHJcbiAgICAgIG1vdmluZ0VsZW1lbnRCb3VuZHMubWluWCxcclxuICAgICAgbW92aW5nRWxlbWVudEJvdW5kcy5tYXhZXHJcbiAgICApO1xyXG5cclxuICAgIGlmICggZXhjbHVzaXZlSW50ZXJzZWN0c0JvdW5kcyggbW90aW9uVGVzdEJvdW5kcywgc3RhdGlvbmFyeUVsZW1lbnRCb3VuZHMgKSApIHtcclxuXHJcbiAgICAgIC8vIGNvbGxpc2lvbiBkZXRlY3RlZCwgbGltaXQgbW90aW9uIGluIHRoaXMgZGlyZWN0aW9uXHJcbiAgICAgIHhUcmFuc2xhdGlvbiA9IHN0YXRpb25hcnlFbGVtZW50Qm91bmRzLm1heFggLSBtb3ZpbmdFbGVtZW50Qm91bmRzLm1pblggKyBNSU5fSU5URVJfRUxFTUVOVF9ESVNUQU5DRTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFkgZGlyZWN0aW9uLlxyXG4gIGlmICggcHJvcG9zZWRUcmFuc2xhdGlvblkgPiAwICYmIHJlc3RyaWN0UG9zWSApIHtcclxuXHJcbiAgICAvLyBjaGVjayBmb3IgY29sbGlzaW9ucyBtb3ZpbmcgdXBcclxuICAgIG1vdGlvblRlc3RCb3VuZHMuc2V0TWluTWF4KFxyXG4gICAgICBtb3ZpbmdFbGVtZW50Qm91bmRzLm1pblgsXHJcbiAgICAgIG1vdmluZ0VsZW1lbnRCb3VuZHMubWF4WSxcclxuICAgICAgbW92aW5nRWxlbWVudEJvdW5kcy5tYXhYLFxyXG4gICAgICBtb3ZpbmdFbGVtZW50Qm91bmRzLm1heFkgKyB5VHJhbnNsYXRpb25cclxuICAgICk7XHJcblxyXG4gICAgaWYgKCBleGNsdXNpdmVJbnRlcnNlY3RzQm91bmRzKCBtb3Rpb25UZXN0Qm91bmRzLCBzdGF0aW9uYXJ5RWxlbWVudEJvdW5kcyApICkge1xyXG5cclxuICAgICAgLy8gY29sbGlzaW9uIGRldGVjdGVkLCBsaW1pdCBtb3Rpb25cclxuICAgICAgeVRyYW5zbGF0aW9uID0gc3RhdGlvbmFyeUVsZW1lbnRCb3VuZHMubWluWSAtIG1vdmluZ0VsZW1lbnRCb3VuZHMubWF4WSAtIE1JTl9JTlRFUl9FTEVNRU5UX0RJU1RBTkNFO1xyXG4gICAgfVxyXG4gIH1cclxuICBlbHNlIGlmICggcHJvcG9zZWRUcmFuc2xhdGlvblkgPCAwICkge1xyXG5cclxuICAgIC8vIGNoZWNrIGZvciBjb2xsaXNpb25zIG1vdmluZyBkb3duXHJcbiAgICBtb3Rpb25UZXN0Qm91bmRzLnNldE1pbk1heChcclxuICAgICAgbW92aW5nRWxlbWVudEJvdW5kcy5taW5YLFxyXG4gICAgICBtb3ZpbmdFbGVtZW50Qm91bmRzLm1pblkgKyB5VHJhbnNsYXRpb24sXHJcbiAgICAgIG1vdmluZ0VsZW1lbnRCb3VuZHMubWF4WCxcclxuICAgICAgbW92aW5nRWxlbWVudEJvdW5kcy5taW5ZXHJcbiAgICApO1xyXG5cclxuICAgIGlmICggZXhjbHVzaXZlSW50ZXJzZWN0c0JvdW5kcyggbW90aW9uVGVzdEJvdW5kcywgc3RhdGlvbmFyeUVsZW1lbnRCb3VuZHMgKSApIHtcclxuXHJcbiAgICAgIC8vIGNvbGxpc2lvbiBkZXRlY3RlZCwgbGltaXQgbW90aW9uXHJcbiAgICAgIHlUcmFuc2xhdGlvbiA9IHN0YXRpb25hcnlFbGVtZW50Qm91bmRzLm1heFkgLSBtb3ZpbmdFbGVtZW50Qm91bmRzLm1pblkgLSBNSU5fSU5URVJfRUxFTUVOVF9ESVNUQU5DRTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHQuc2V0WFkoIHhUcmFuc2xhdGlvbiwgeVRyYW5zbGF0aW9uICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBhIHZlcnNpb24gb2YgQm91bmRzMi5pbnRlcnNlY3RzQm91bmRzIHRoYXQgZG9lc24ndCBjb3VudCBlcXVhbCBlZGdlcyBhcyBpbnRlcnNlY3Rpb25cclxuICogQHBhcmFtIHtCb3VuZHMyfSBib3VuZHMxXHJcbiAqIEBwYXJhbSB7Qm91bmRzMn0gYm91bmRzMlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZXhjbHVzaXZlSW50ZXJzZWN0c0JvdW5kcyggYm91bmRzMSwgYm91bmRzMiApIHtcclxuICBjb25zdCBtaW5YID0gTWF0aC5tYXgoIGJvdW5kczEubWluWCwgYm91bmRzMi5taW5YICk7XHJcbiAgY29uc3QgbWluWSA9IE1hdGgubWF4KCBib3VuZHMxLm1pblksIGJvdW5kczIubWluWSApO1xyXG4gIGNvbnN0IG1heFggPSBNYXRoLm1pbiggYm91bmRzMS5tYXhYLCBib3VuZHMyLm1heFggKTtcclxuICBjb25zdCBtYXhZID0gTWF0aC5taW4oIGJvdW5kczEubWF4WSwgYm91bmRzMi5tYXhZICk7XHJcbiAgcmV0dXJuICggbWF4WCAtIG1pblggKSA+IDAgJiYgKCBtYXhZIC0gbWluWSA+IDAgKTtcclxufVxyXG5cclxuZW5lcmd5Rm9ybXNBbmRDaGFuZ2VzLnJlZ2lzdGVyKCAnZWZhY1Bvc2l0aW9uQ29uc3RyYWluZXInLCBlZmFjUG9zaXRpb25Db25zdHJhaW5lciApO1xyXG5leHBvcnQgZGVm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