// Copyright 2014-2023, University of Colorado Boulder

/**
 * Block that contains and exchanges thermal energy.  In the model, a block is two-dimensional, so its shape is
 * represented by a rectangle.
 *
 * @author John Blanco
 * @author Chris Klusendorf
 */

import Bounds2 from '../../../../dot/js/Bounds2.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import merge from '../../../../phet-core/js/merge.js';
import required from '../../../../phet-core/js/required.js';
import { Color } from '../../../../scenery/js/imports.js';
import Tandem from '../../../../tandem/js/Tandem.js';
import EnumerationIO from '../../../../tandem/js/types/EnumerationIO.js';
import IOType from '../../../../tandem/js/types/IOType.js';
import EFACConstants from '../../common/EFACConstants.js';
import EnergyChunkContainerSlice from '../../common/model/EnergyChunkContainerSlice.js';
import EnergyContainerCategory from '../../common/model/EnergyContainerCategory.js';
import HorizontalSurface from '../../common/model/HorizontalSurface.js';
import RectangularThermalMovableModelElement from '../../common/model/RectangularThermalMovableModelElement.js';
import energyFormsAndChanges from '../../energyFormsAndChanges.js';
import BlockType from './BlockType.js';

// constants
const NUM_ENERGY_CHUNK_SLICES = 4; // Number of slices where energy chunks may be placed.
const MAX_TEMPERATURE = 620; // in degrees Kelvin, see usage below for where the value comes from
const BLOCK_PERSPECTIVE_EXTENSION = EFACConstants.BLOCK_SURFACE_WIDTH * EFACConstants.BLOCK_PERSPECTIVE_EDGE_PROPORTION * Math.cos(EFACConstants.BLOCK_PERSPECTIVE_ANGLE) / 2;
const BlockTypeEnumerationIO = EnumerationIO(BlockType);

// TODO: use constants from EFAConstants, https://github.com/phetsims/energy-forms-and-changes/issues/420
const BLOCK_COMPOSITION = {};
BLOCK_COMPOSITION[BlockType.IRON] = {
  color: new Color(150, 150, 150),
  density: EFACConstants.IRON_DENSITY,
  specificHeat: EFACConstants.IRON_SPECIFIC_HEAT,
  energyContainerCategory: EnergyContainerCategory.IRON
};
BLOCK_COMPOSITION[BlockType.BRICK] = {
  color: new Color(223, 22, 12),
  density: EFACConstants.BRICK_DENSITY,
  specificHeat: EFACConstants.BRICK_SPECIFIC_HEAT,
  energyContainerCategory: EnergyContainerCategory.BRICK
};

// static data
let instanceCount = 0; // counter for creating unique IDs

class Block extends RectangularThermalMovableModelElement {
  /**
   * @param {Vector2} initialPosition
   * @param {Property} energyChunksVisibleProperty
   * @param {BlockType} blockType
   * @param {PhetioGroup} energyChunkGroup
   * optional for the parent
   * @param {Object} config
   */
  constructor(initialPosition, energyChunksVisibleProperty, blockType, energyChunkGroup, config) {
    config = merge({
      energyChunkWanderControllerGroup: required(config.energyChunkWanderControllerGroup),
      predistributedEnergyChunkConfigurations: ENERGY_CHUNK_PRESET_CONFIGURATIONS,
      // phet-io
      tandem: Tandem.REQUIRED,
      phetioDynamicElement: true,
      phetioType: Block.BlockIO,
      phetioDocumentation: 'block that can be of type iron or brick'
    }, config);
    super(initialPosition, EFACConstants.BLOCK_SURFACE_WIDTH, EFACConstants.BLOCK_SURFACE_WIDTH, Math.pow(EFACConstants.BLOCK_SURFACE_WIDTH, 3) * BLOCK_COMPOSITION[blockType].density, BLOCK_COMPOSITION[blockType].specificHeat, energyChunksVisibleProperty, energyChunkGroup, config);

    // @public (read-only) {String} - unique ID for this block
    this.id = `block-${instanceCount++}`;

    // @public
    this.blockType = blockType;

    // @public {number} - the z-index of this block in relation to other blocks. updated when a user interacts with any
    // block.
    this.zIndex = instanceCount;

    // add position test bounds (see definition in base class for more info)
    this.relativePositionTestingBoundsList.push(new Bounds2(-EFACConstants.BLOCK_SURFACE_WIDTH / 2, 0, EFACConstants.BLOCK_SURFACE_WIDTH / 2, EFACConstants.BLOCK_SURFACE_WIDTH));
    const rectangle = this.getBounds();

    // @public - see base class for description
    this.topSurface = new HorizontalSurface(new Vector2(initialPosition.x, rectangle.maxY), EFACConstants.BLOCK_SURFACE_WIDTH, this);

    // @public - see base class for description
    this.bottomSurface = new HorizontalSurface(new Vector2(initialPosition.x, rectangle.minY), EFACConstants.BLOCK_SURFACE_WIDTH, this);

    // update the top and bottom surfaces whenever the position changes
    this.positionProperty.link(position => {
      const currentBounds = this.getBounds();
      this.topSurface.positionProperty.value = new Vector2(position.x, currentBounds.maxY);
      this.bottomSurface.positionProperty.value = new Vector2(position.x, currentBounds.minY);
      this.thermalContactArea.set(currentBounds);
    });

    // add perspective information, used for validating positions
    this.perspectiveCompensation.setXY(BLOCK_PERSPECTIVE_EXTENSION, BLOCK_PERSPECTIVE_EXTENSION);
  }

  /**
   * @returns {Color}
   * @public
   */
  get color() {
    return BLOCK_COMPOSITION[this.blockType].color;
  }

  /**
   * @public
   * @returns {EnergyContainerCategory}
   */
  get energyContainerCategory() {
    return BLOCK_COMPOSITION[this.blockType].energyContainerCategory;
  }

  /**
   * @override
   * @public
   */
  addEnergyChunkSlices() {
    assert && assert(this.slices.length === 0); // make sure this method isn't being misused

    // the slices for the block are intended to match the projection used in the view
    const projectionToFront = EFACConstants.MAP_Z_TO_XY_OFFSET(EFACConstants.BLOCK_SURFACE_WIDTH / 2);
    const sliceWidth = EFACConstants.BLOCK_SURFACE_WIDTH / (NUM_ENERGY_CHUNK_SLICES - 1);
    const rectangle = this.getBounds();
    for (let i = 0; i < NUM_ENERGY_CHUNK_SLICES; i++) {
      const projectionOffsetVector = EFACConstants.MAP_Z_TO_XY_OFFSET(-i * sliceWidth);
      const sliceBounds = Bounds2.rect(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      sliceBounds.shiftXY(projectionToFront.x + projectionOffsetVector.x, projectionToFront.y + projectionOffsetVector.y);
      this.slices.push(new EnergyChunkContainerSlice(sliceBounds, -i * sliceWidth, this.positionProperty, {
        tandem: this.tandem.createTandem(`energyChunkContainerSlice${i}`)
      }));
    }
  }

  /**
   * This function originally existed primarily in support of boiling liquids, whose temperatures should not go up
   * after reaching a certain temperature.  In the context of a block, it is less meaningful in a true physical sense
   * (unless we're talking about the boiling point of iron I suppose).  However, it turns out to be useful to the sim
   * to set a max temperature beyond which the block will exchange energy with the air more quickly thus limiting how
   * hot it will get, because this effectively limits the number of energy chunks that can end up in the block.  So,
   * this method does return a positive value when the block is above a certain temperature, but this behavior is what
   * we often call "Hollywooding", since it doesn't do this for a real physical reason.  The max temperature values are
   * empirically determined to be higher than the value that maxes out the thermometers, and enough above that value
   * that two stacked blocks can both reach the max value shown on the thermometer if heated long enough.
   * @returns {number}
   * @public
   */
  getEnergyBeyondMaxTemperature() {
    return Math.max(this.energyProperty.value - MAX_TEMPERATURE * this.mass * this.specificHeat, 0);
  }
}

// Preset data used for fast addition and positioning of energy chunks during reset.  The data contains information
// about the energy chunk slices and energy chunks that are contained within a block of a specific size with a specific
// number of energy chunks.  If a match can be found, this data is used to quickly configure the block rather than
// using the much more expensive process of inserting and then distributing the energy chunks.  See
// https://github.com/phetsims/energy-forms-and-changes/issues/375.
const ENERGY_CHUNK_PRESET_CONFIGURATIONS = [
// iron block
{
  numberOfSlices: 4,
  totalSliceArea: 0.008100000000000001,
  numberOfEnergyChunks: 6,
  energyChunkPositionsBySlice: [[{
    positionX: -0.25640756950670235,
    positionY: 0.006850135040548302
  }], [{
    positionX: -0.2537531660345353,
    positionY: 0.02393321792569457
  }, {
    positionX: -0.23829971427184846,
    positionY: 0.009582482706072211
  }], [{
    positionX: -0.24358344197642037,
    positionY: 0.035369522321921996
  }, {
    positionX: -0.2282683630416627,
    positionY: 0.02098996529690959
  }], [{
    positionX: -0.22579080380196173,
    positionY: 0.038104769283249865
  }]]
},
// brick
{
  numberOfSlices: 4,
  totalSliceArea: 0.008099999999999998,
  numberOfEnergyChunks: 2,
  energyChunkPositionsBySlice: [[], [{
    positionX: -0.15231883878415728,
    positionY: 0.015189399553646257
  }], [{
    positionX: -0.13768266639921758,
    positionY: 0.029811817909006666
  }], []]
}];
Block.BlockIO = new IOType('BlockIO', {
  valueType: Block,
  toStateObject: block => ({
    blockType: BlockTypeEnumerationIO.toStateObject(block.blockType)
  }),
  stateSchema: {
    blockType: BlockTypeEnumerationIO
  }
});
energyFormsAndChanges.register('Block', Block);
export default Block;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiVmVjdG9yMiIsIm1lcmdlIiwicmVxdWlyZWQiLCJDb2xvciIsIlRhbmRlbSIsIkVudW1lcmF0aW9uSU8iLCJJT1R5cGUiLCJFRkFDQ29uc3RhbnRzIiwiRW5lcmd5Q2h1bmtDb250YWluZXJTbGljZSIsIkVuZXJneUNvbnRhaW5lckNhdGVnb3J5IiwiSG9yaXpvbnRhbFN1cmZhY2UiLCJSZWN0YW5ndWxhclRoZXJtYWxNb3ZhYmxlTW9kZWxFbGVtZW50IiwiZW5lcmd5Rm9ybXNBbmRDaGFuZ2VzIiwiQmxvY2tUeXBlIiwiTlVNX0VORVJHWV9DSFVOS19TTElDRVMiLCJNQVhfVEVNUEVSQVRVUkUiLCJCTE9DS19QRVJTUEVDVElWRV9FWFRFTlNJT04iLCJCTE9DS19TVVJGQUNFX1dJRFRIIiwiQkxPQ0tfUEVSU1BFQ1RJVkVfRURHRV9QUk9QT1JUSU9OIiwiTWF0aCIsImNvcyIsIkJMT0NLX1BFUlNQRUNUSVZFX0FOR0xFIiwiQmxvY2tUeXBlRW51bWVyYXRpb25JTyIsIkJMT0NLX0NPTVBPU0lUSU9OIiwiSVJPTiIsImNvbG9yIiwiZGVuc2l0eSIsIklST05fREVOU0lUWSIsInNwZWNpZmljSGVhdCIsIklST05fU1BFQ0lGSUNfSEVBVCIsImVuZXJneUNvbnRhaW5lckNhdGVnb3J5IiwiQlJJQ0siLCJCUklDS19ERU5TSVRZIiwiQlJJQ0tfU1BFQ0lGSUNfSEVBVCIsImluc3RhbmNlQ291bnQiLCJCbG9jayIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbFBvc2l0aW9uIiwiZW5lcmd5Q2h1bmtzVmlzaWJsZVByb3BlcnR5IiwiYmxvY2tUeXBlIiwiZW5lcmd5Q2h1bmtHcm91cCIsImNvbmZpZyIsImVuZXJneUNodW5rV2FuZGVyQ29udHJvbGxlckdyb3VwIiwicHJlZGlzdHJpYnV0ZWRFbmVyZ3lDaHVua0NvbmZpZ3VyYXRpb25zIiwiRU5FUkdZX0NIVU5LX1BSRVNFVF9DT05GSUdVUkFUSU9OUyIsInRhbmRlbSIsIlJFUVVJUkVEIiwicGhldGlvRHluYW1pY0VsZW1lbnQiLCJwaGV0aW9UeXBlIiwiQmxvY2tJTyIsInBoZXRpb0RvY3VtZW50YXRpb24iLCJwb3ciLCJpZCIsInpJbmRleCIsInJlbGF0aXZlUG9zaXRpb25UZXN0aW5nQm91bmRzTGlzdCIsInB1c2giLCJyZWN0YW5nbGUiLCJnZXRCb3VuZHMiLCJ0b3BTdXJmYWNlIiwieCIsIm1heFkiLCJib3R0b21TdXJmYWNlIiwibWluWSIsInBvc2l0aW9uUHJvcGVydHkiLCJsaW5rIiwicG9zaXRpb24iLCJjdXJyZW50Qm91bmRzIiwidmFsdWUiLCJ0aGVybWFsQ29udGFjdEFyZWEiLCJzZXQiLCJwZXJzcGVjdGl2ZUNvbXBlbnNhdGlvbiIsInNldFhZIiwiYWRkRW5lcmd5Q2h1bmtTbGljZXMiLCJhc3NlcnQiLCJzbGljZXMiLCJsZW5ndGgiLCJwcm9qZWN0aW9uVG9Gcm9udCIsIk1BUF9aX1RPX1hZX09GRlNFVCIsInNsaWNlV2lkdGgiLCJpIiwicHJvamVjdGlvbk9mZnNldFZlY3RvciIsInNsaWNlQm91bmRzIiwicmVjdCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInNoaWZ0WFkiLCJjcmVhdGVUYW5kZW0iLCJnZXRFbmVyZ3lCZXlvbmRNYXhUZW1wZXJhdHVyZSIsIm1heCIsImVuZXJneVByb3BlcnR5IiwibWFzcyIsIm51bWJlck9mU2xpY2VzIiwidG90YWxTbGljZUFyZWEiLCJudW1iZXJPZkVuZXJneUNodW5rcyIsImVuZXJneUNodW5rUG9zaXRpb25zQnlTbGljZSIsInBvc2l0aW9uWCIsInBvc2l0aW9uWSIsInZhbHVlVHlwZSIsInRvU3RhdGVPYmplY3QiLCJibG9jayIsInN0YXRlU2NoZW1hIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJCbG9jay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNC0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBCbG9jayB0aGF0IGNvbnRhaW5zIGFuZCBleGNoYW5nZXMgdGhlcm1hbCBlbmVyZ3kuICBJbiB0aGUgbW9kZWwsIGEgYmxvY2sgaXMgdHdvLWRpbWVuc2lvbmFsLCBzbyBpdHMgc2hhcGUgaXNcclxuICogcmVwcmVzZW50ZWQgYnkgYSByZWN0YW5nbGUuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICogQGF1dGhvciBDaHJpcyBLbHVzZW5kb3JmXHJcbiAqL1xyXG5cclxuaW1wb3J0IEJvdW5kczIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL0JvdW5kczIuanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgcmVxdWlyZWQgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL3JlcXVpcmVkLmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgVGFuZGVtIGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy9UYW5kZW0uanMnO1xyXG5pbXBvcnQgRW51bWVyYXRpb25JTyBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvRW51bWVyYXRpb25JTy5qcyc7XHJcbmltcG9ydCBJT1R5cGUgZnJvbSAnLi4vLi4vLi4vLi4vdGFuZGVtL2pzL3R5cGVzL0lPVHlwZS5qcyc7XHJcbmltcG9ydCBFRkFDQ29uc3RhbnRzIGZyb20gJy4uLy4uL2NvbW1vbi9FRkFDQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IEVuZXJneUNodW5rQ29udGFpbmVyU2xpY2UgZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL0VuZXJneUNodW5rQ29udGFpbmVyU2xpY2UuanMnO1xyXG5pbXBvcnQgRW5lcmd5Q29udGFpbmVyQ2F0ZWdvcnkgZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL0VuZXJneUNvbnRhaW5lckNhdGVnb3J5LmpzJztcclxuaW1wb3J0IEhvcml6b250YWxTdXJmYWNlIGZyb20gJy4uLy4uL2NvbW1vbi9tb2RlbC9Ib3Jpem9udGFsU3VyZmFjZS5qcyc7XHJcbmltcG9ydCBSZWN0YW5ndWxhclRoZXJtYWxNb3ZhYmxlTW9kZWxFbGVtZW50IGZyb20gJy4uLy4uL2NvbW1vbi9tb2RlbC9SZWN0YW5ndWxhclRoZXJtYWxNb3ZhYmxlTW9kZWxFbGVtZW50LmpzJztcclxuaW1wb3J0IGVuZXJneUZvcm1zQW5kQ2hhbmdlcyBmcm9tICcuLi8uLi9lbmVyZ3lGb3Jtc0FuZENoYW5nZXMuanMnO1xyXG5pbXBvcnQgQmxvY2tUeXBlIGZyb20gJy4vQmxvY2tUeXBlLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBOVU1fRU5FUkdZX0NIVU5LX1NMSUNFUyA9IDQ7IC8vIE51bWJlciBvZiBzbGljZXMgd2hlcmUgZW5lcmd5IGNodW5rcyBtYXkgYmUgcGxhY2VkLlxyXG5jb25zdCBNQVhfVEVNUEVSQVRVUkUgPSA2MjA7IC8vIGluIGRlZ3JlZXMgS2VsdmluLCBzZWUgdXNhZ2UgYmVsb3cgZm9yIHdoZXJlIHRoZSB2YWx1ZSBjb21lcyBmcm9tXHJcbmNvbnN0IEJMT0NLX1BFUlNQRUNUSVZFX0VYVEVOU0lPTiA9IEVGQUNDb25zdGFudHMuQkxPQ0tfU1VSRkFDRV9XSURUSCAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVGQUNDb25zdGFudHMuQkxPQ0tfUEVSU1BFQ1RJVkVfRURHRV9QUk9QT1JUSU9OICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jb3MoIEVGQUNDb25zdGFudHMuQkxPQ0tfUEVSU1BFQ1RJVkVfQU5HTEUgKSAvIDI7XHJcblxyXG5jb25zdCBCbG9ja1R5cGVFbnVtZXJhdGlvbklPID0gRW51bWVyYXRpb25JTyggQmxvY2tUeXBlICk7XHJcblxyXG4vLyBUT0RPOiB1c2UgY29uc3RhbnRzIGZyb20gRUZBQ29uc3RhbnRzLCBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvZW5lcmd5LWZvcm1zLWFuZC1jaGFuZ2VzL2lzc3Vlcy80MjBcclxuY29uc3QgQkxPQ0tfQ09NUE9TSVRJT04gPSB7fTtcclxuQkxPQ0tfQ09NUE9TSVRJT05bIEJsb2NrVHlwZS5JUk9OIF0gPSB7XHJcbiAgY29sb3I6IG5ldyBDb2xvciggMTUwLCAxNTAsIDE1MCApLFxyXG4gIGRlbnNpdHk6IEVGQUNDb25zdGFudHMuSVJPTl9ERU5TSVRZLFxyXG4gIHNwZWNpZmljSGVhdDogRUZBQ0NvbnN0YW50cy5JUk9OX1NQRUNJRklDX0hFQVQsXHJcbiAgZW5lcmd5Q29udGFpbmVyQ2F0ZWdvcnk6IEVuZXJneUNvbnRhaW5lckNhdGVnb3J5LklST05cclxufTtcclxuQkxPQ0tfQ09NUE9TSVRJT05bIEJsb2NrVHlwZS5CUklDSyBdID0ge1xyXG4gIGNvbG9yOiBuZXcgQ29sb3IoIDIyMywgMjIsIDEyICksXHJcbiAgZGVuc2l0eTogRUZBQ0NvbnN0YW50cy5CUklDS19ERU5TSVRZLFxyXG4gIHNwZWNpZmljSGVhdDogRUZBQ0NvbnN0YW50cy5CUklDS19TUEVDSUZJQ19IRUFULFxyXG4gIGVuZXJneUNvbnRhaW5lckNhdGVnb3J5OiBFbmVyZ3lDb250YWluZXJDYXRlZ29yeS5CUklDS1xyXG59O1xyXG5cclxuLy8gc3RhdGljIGRhdGFcclxubGV0IGluc3RhbmNlQ291bnQgPSAwOyAvLyBjb3VudGVyIGZvciBjcmVhdGluZyB1bmlxdWUgSURzXHJcblxyXG5jbGFzcyBCbG9jayBleHRlbmRzIFJlY3Rhbmd1bGFyVGhlcm1hbE1vdmFibGVNb2RlbEVsZW1lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IGluaXRpYWxQb3NpdGlvblxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHl9IGVuZXJneUNodW5rc1Zpc2libGVQcm9wZXJ0eVxyXG4gICAqIEBwYXJhbSB7QmxvY2tUeXBlfSBibG9ja1R5cGVcclxuICAgKiBAcGFyYW0ge1BoZXRpb0dyb3VwfSBlbmVyZ3lDaHVua0dyb3VwXHJcbiAgICogb3B0aW9uYWwgZm9yIHRoZSBwYXJlbnRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGluaXRpYWxQb3NpdGlvbixcclxuICAgICAgICAgICAgICAgZW5lcmd5Q2h1bmtzVmlzaWJsZVByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICBibG9ja1R5cGUsXHJcbiAgICAgICAgICAgICAgIGVuZXJneUNodW5rR3JvdXAsXHJcbiAgICAgICAgICAgICAgIGNvbmZpZyApIHtcclxuXHJcbiAgICBjb25maWcgPSBtZXJnZSgge1xyXG4gICAgICBlbmVyZ3lDaHVua1dhbmRlckNvbnRyb2xsZXJHcm91cDogcmVxdWlyZWQoIGNvbmZpZy5lbmVyZ3lDaHVua1dhbmRlckNvbnRyb2xsZXJHcm91cCApLFxyXG4gICAgICBwcmVkaXN0cmlidXRlZEVuZXJneUNodW5rQ29uZmlndXJhdGlvbnM6IEVORVJHWV9DSFVOS19QUkVTRVRfQ09ORklHVVJBVElPTlMsXHJcblxyXG4gICAgICAvLyBwaGV0LWlvXHJcbiAgICAgIHRhbmRlbTogVGFuZGVtLlJFUVVJUkVELFxyXG4gICAgICBwaGV0aW9EeW5hbWljRWxlbWVudDogdHJ1ZSxcclxuICAgICAgcGhldGlvVHlwZTogQmxvY2suQmxvY2tJTyxcclxuICAgICAgcGhldGlvRG9jdW1lbnRhdGlvbjogJ2Jsb2NrIHRoYXQgY2FuIGJlIG9mIHR5cGUgaXJvbiBvciBicmljaydcclxuICAgIH0sIGNvbmZpZyApO1xyXG5cclxuICAgIHN1cGVyKFxyXG4gICAgICBpbml0aWFsUG9zaXRpb24sXHJcbiAgICAgIEVGQUNDb25zdGFudHMuQkxPQ0tfU1VSRkFDRV9XSURUSCxcclxuICAgICAgRUZBQ0NvbnN0YW50cy5CTE9DS19TVVJGQUNFX1dJRFRILFxyXG4gICAgICBNYXRoLnBvdyggRUZBQ0NvbnN0YW50cy5CTE9DS19TVVJGQUNFX1dJRFRILCAzICkgKiBCTE9DS19DT01QT1NJVElPTlsgYmxvY2tUeXBlIF0uZGVuc2l0eSxcclxuICAgICAgQkxPQ0tfQ09NUE9TSVRJT05bIGJsb2NrVHlwZSBdLnNwZWNpZmljSGVhdCxcclxuICAgICAgZW5lcmd5Q2h1bmtzVmlzaWJsZVByb3BlcnR5LFxyXG4gICAgICBlbmVyZ3lDaHVua0dyb3VwLFxyXG4gICAgICBjb25maWdcclxuICAgICk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyAocmVhZC1vbmx5KSB7U3RyaW5nfSAtIHVuaXF1ZSBJRCBmb3IgdGhpcyBibG9ja1xyXG4gICAgdGhpcy5pZCA9IGBibG9jay0ke2luc3RhbmNlQ291bnQrK31gO1xyXG5cclxuICAgIC8vIEBwdWJsaWNcclxuICAgIHRoaXMuYmxvY2tUeXBlID0gYmxvY2tUeXBlO1xyXG5cclxuICAgIC8vIEBwdWJsaWMge251bWJlcn0gLSB0aGUgei1pbmRleCBvZiB0aGlzIGJsb2NrIGluIHJlbGF0aW9uIHRvIG90aGVyIGJsb2Nrcy4gdXBkYXRlZCB3aGVuIGEgdXNlciBpbnRlcmFjdHMgd2l0aCBhbnlcclxuICAgIC8vIGJsb2NrLlxyXG4gICAgdGhpcy56SW5kZXggPSBpbnN0YW5jZUNvdW50O1xyXG5cclxuICAgIC8vIGFkZCBwb3NpdGlvbiB0ZXN0IGJvdW5kcyAoc2VlIGRlZmluaXRpb24gaW4gYmFzZSBjbGFzcyBmb3IgbW9yZSBpbmZvKVxyXG4gICAgdGhpcy5yZWxhdGl2ZVBvc2l0aW9uVGVzdGluZ0JvdW5kc0xpc3QucHVzaCggbmV3IEJvdW5kczIoXHJcbiAgICAgIC1FRkFDQ29uc3RhbnRzLkJMT0NLX1NVUkZBQ0VfV0lEVEggLyAyLFxyXG4gICAgICAwLFxyXG4gICAgICBFRkFDQ29uc3RhbnRzLkJMT0NLX1NVUkZBQ0VfV0lEVEggLyAyLFxyXG4gICAgICBFRkFDQ29uc3RhbnRzLkJMT0NLX1NVUkZBQ0VfV0lEVEhcclxuICAgICkgKTtcclxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IHRoaXMuZ2V0Qm91bmRzKCk7XHJcblxyXG4gICAgLy8gQHB1YmxpYyAtIHNlZSBiYXNlIGNsYXNzIGZvciBkZXNjcmlwdGlvblxyXG4gICAgdGhpcy50b3BTdXJmYWNlID0gbmV3IEhvcml6b250YWxTdXJmYWNlKFxyXG4gICAgICBuZXcgVmVjdG9yMiggaW5pdGlhbFBvc2l0aW9uLngsIHJlY3RhbmdsZS5tYXhZICksXHJcbiAgICAgIEVGQUNDb25zdGFudHMuQkxPQ0tfU1VSRkFDRV9XSURUSCxcclxuICAgICAgdGhpc1xyXG4gICAgKTtcclxuXHJcbiAgICAvLyBAcHVibGljIC0gc2VlIGJhc2UgY2xhc3MgZm9yIGRlc2NyaXB0aW9uXHJcbiAgICB0aGlzLmJvdHRvbVN1cmZhY2UgPSBuZXcgSG9yaXpvbnRhbFN1cmZhY2UoXHJcbiAgICAgIG5ldyBWZWN0b3IyKCBpbml0aWFsUG9zaXRpb24ueCwgcmVjdGFuZ2xlLm1pblkgKSxcclxuICAgICAgRUZBQ0NvbnN0YW50cy5CTE9DS19TVVJGQUNFX1dJRFRILFxyXG4gICAgICB0aGlzXHJcbiAgICApO1xyXG5cclxuICAgIC8vIHVwZGF0ZSB0aGUgdG9wIGFuZCBib3R0b20gc3VyZmFjZXMgd2hlbmV2ZXIgdGhlIHBvc2l0aW9uIGNoYW5nZXNcclxuICAgIHRoaXMucG9zaXRpb25Qcm9wZXJ0eS5saW5rKCBwb3NpdGlvbiA9PiB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRCb3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xyXG4gICAgICB0aGlzLnRvcFN1cmZhY2UucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZSA9IG5ldyBWZWN0b3IyKCBwb3NpdGlvbi54LCBjdXJyZW50Qm91bmRzLm1heFkgKTtcclxuICAgICAgdGhpcy5ib3R0b21TdXJmYWNlLnBvc2l0aW9uUHJvcGVydHkudmFsdWUgPSBuZXcgVmVjdG9yMiggcG9zaXRpb24ueCwgY3VycmVudEJvdW5kcy5taW5ZICk7XHJcbiAgICAgIHRoaXMudGhlcm1hbENvbnRhY3RBcmVhLnNldCggY3VycmVudEJvdW5kcyApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIGFkZCBwZXJzcGVjdGl2ZSBpbmZvcm1hdGlvbiwgdXNlZCBmb3IgdmFsaWRhdGluZyBwb3NpdGlvbnNcclxuICAgIHRoaXMucGVyc3BlY3RpdmVDb21wZW5zYXRpb24uc2V0WFkoIEJMT0NLX1BFUlNQRUNUSVZFX0VYVEVOU0lPTiwgQkxPQ0tfUEVSU1BFQ1RJVkVfRVhURU5TSU9OICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Q29sb3J9XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGdldCBjb2xvcigpIHtcclxuICAgIHJldHVybiBCTE9DS19DT01QT1NJVElPTlsgdGhpcy5ibG9ja1R5cGUgXS5jb2xvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7RW5lcmd5Q29udGFpbmVyQ2F0ZWdvcnl9XHJcbiAgICovXHJcbiAgZ2V0IGVuZXJneUNvbnRhaW5lckNhdGVnb3J5KCkge1xyXG4gICAgcmV0dXJuIEJMT0NLX0NPTVBPU0lUSU9OWyB0aGlzLmJsb2NrVHlwZSBdLmVuZXJneUNvbnRhaW5lckNhdGVnb3J5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGFkZEVuZXJneUNodW5rU2xpY2VzKCkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5zbGljZXMubGVuZ3RoID09PSAwICk7IC8vIG1ha2Ugc3VyZSB0aGlzIG1ldGhvZCBpc24ndCBiZWluZyBtaXN1c2VkXHJcblxyXG4gICAgLy8gdGhlIHNsaWNlcyBmb3IgdGhlIGJsb2NrIGFyZSBpbnRlbmRlZCB0byBtYXRjaCB0aGUgcHJvamVjdGlvbiB1c2VkIGluIHRoZSB2aWV3XHJcbiAgICBjb25zdCBwcm9qZWN0aW9uVG9Gcm9udCA9IEVGQUNDb25zdGFudHMuTUFQX1pfVE9fWFlfT0ZGU0VUKCBFRkFDQ29uc3RhbnRzLkJMT0NLX1NVUkZBQ0VfV0lEVEggLyAyICk7XHJcbiAgICBjb25zdCBzbGljZVdpZHRoID0gRUZBQ0NvbnN0YW50cy5CTE9DS19TVVJGQUNFX1dJRFRIIC8gKCBOVU1fRU5FUkdZX0NIVU5LX1NMSUNFUyAtIDEgKTtcclxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IHRoaXMuZ2V0Qm91bmRzKCk7XHJcblxyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgTlVNX0VORVJHWV9DSFVOS19TTElDRVM7IGkrKyApIHtcclxuICAgICAgY29uc3QgcHJvamVjdGlvbk9mZnNldFZlY3RvciA9IEVGQUNDb25zdGFudHMuTUFQX1pfVE9fWFlfT0ZGU0VUKCAtaSAqIHNsaWNlV2lkdGggKTtcclxuICAgICAgY29uc3Qgc2xpY2VCb3VuZHMgPSBCb3VuZHMyLnJlY3QoIHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgcmVjdGFuZ2xlLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0ICk7XHJcbiAgICAgIHNsaWNlQm91bmRzLnNoaWZ0WFkoXHJcbiAgICAgICAgcHJvamVjdGlvblRvRnJvbnQueCArIHByb2plY3Rpb25PZmZzZXRWZWN0b3IueCxcclxuICAgICAgICBwcm9qZWN0aW9uVG9Gcm9udC55ICsgcHJvamVjdGlvbk9mZnNldFZlY3Rvci55XHJcbiAgICAgICk7XHJcblxyXG4gICAgICB0aGlzLnNsaWNlcy5wdXNoKCBuZXcgRW5lcmd5Q2h1bmtDb250YWluZXJTbGljZShcclxuICAgICAgICBzbGljZUJvdW5kcyxcclxuICAgICAgICAtaSAqIHNsaWNlV2lkdGgsXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvblByb3BlcnR5LCB7XHJcbiAgICAgICAgICB0YW5kZW06IHRoaXMudGFuZGVtLmNyZWF0ZVRhbmRlbSggYGVuZXJneUNodW5rQ29udGFpbmVyU2xpY2Uke2l9YCApXHJcbiAgICAgICAgfVxyXG4gICAgICApICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIG9yaWdpbmFsbHkgZXhpc3RlZCBwcmltYXJpbHkgaW4gc3VwcG9ydCBvZiBib2lsaW5nIGxpcXVpZHMsIHdob3NlIHRlbXBlcmF0dXJlcyBzaG91bGQgbm90IGdvIHVwXHJcbiAgICogYWZ0ZXIgcmVhY2hpbmcgYSBjZXJ0YWluIHRlbXBlcmF0dXJlLiAgSW4gdGhlIGNvbnRleHQgb2YgYSBibG9jaywgaXQgaXMgbGVzcyBtZWFuaW5nZnVsIGluIGEgdHJ1ZSBwaHlzaWNhbCBzZW5zZVxyXG4gICAqICh1bmxlc3Mgd2UncmUgdGFsa2luZyBhYm91dCB0aGUgYm9pbGluZyBwb2ludCBvZiBpcm9uIEkgc3VwcG9zZSkuICBIb3dldmVyLCBpdCB0dXJucyBvdXQgdG8gYmUgdXNlZnVsIHRvIHRoZSBzaW1cclxuICAgKiB0byBzZXQgYSBtYXggdGVtcGVyYXR1cmUgYmV5b25kIHdoaWNoIHRoZSBibG9jayB3aWxsIGV4Y2hhbmdlIGVuZXJneSB3aXRoIHRoZSBhaXIgbW9yZSBxdWlja2x5IHRodXMgbGltaXRpbmcgaG93XHJcbiAgICogaG90IGl0IHdpbGwgZ2V0LCBiZWNhdXNlIHRoaXMgZWZmZWN0aXZlbHkgbGltaXRzIHRoZSBudW1iZXIgb2YgZW5lcmd5IGNodW5rcyB0aGF0IGNhbiBlbmQgdXAgaW4gdGhlIGJsb2NrLiAgU28sXHJcbiAgICogdGhpcyBtZXRob2QgZG9lcyByZXR1cm4gYSBwb3NpdGl2ZSB2YWx1ZSB3aGVuIHRoZSBibG9jayBpcyBhYm92ZSBhIGNlcnRhaW4gdGVtcGVyYXR1cmUsIGJ1dCB0aGlzIGJlaGF2aW9yIGlzIHdoYXRcclxuICAgKiB3ZSBvZnRlbiBjYWxsIFwiSG9sbHl3b29kaW5nXCIsIHNpbmNlIGl0IGRvZXNuJ3QgZG8gdGhpcyBmb3IgYSByZWFsIHBoeXNpY2FsIHJlYXNvbi4gIFRoZSBtYXggdGVtcGVyYXR1cmUgdmFsdWVzIGFyZVxyXG4gICAqIGVtcGlyaWNhbGx5IGRldGVybWluZWQgdG8gYmUgaGlnaGVyIHRoYW4gdGhlIHZhbHVlIHRoYXQgbWF4ZXMgb3V0IHRoZSB0aGVybW9tZXRlcnMsIGFuZCBlbm91Z2ggYWJvdmUgdGhhdCB2YWx1ZVxyXG4gICAqIHRoYXQgdHdvIHN0YWNrZWQgYmxvY2tzIGNhbiBib3RoIHJlYWNoIHRoZSBtYXggdmFsdWUgc2hvd24gb24gdGhlIHRoZXJtb21ldGVyIGlmIGhlYXRlZCBsb25nIGVub3VnaC5cclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBnZXRFbmVyZ3lCZXlvbmRNYXhUZW1wZXJhdHVyZSgpIHtcclxuICAgIHJldHVybiBNYXRoLm1heCggdGhpcy5lbmVyZ3lQcm9wZXJ0eS52YWx1ZSAtICggTUFYX1RFTVBFUkFUVVJFICogdGhpcy5tYXNzICogdGhpcy5zcGVjaWZpY0hlYXQgKSwgMCApO1xyXG4gIH1cclxufVxyXG5cclxuLy8gUHJlc2V0IGRhdGEgdXNlZCBmb3IgZmFzdCBhZGRpdGlvbiBhbmQgcG9zaXRpb25pbmcgb2YgZW5lcmd5IGNodW5rcyBkdXJpbmcgcmVzZXQuICBUaGUgZGF0YSBjb250YWlucyBpbmZvcm1hdGlvblxyXG4vLyBhYm91dCB0aGUgZW5lcmd5IGNodW5rIHNsaWNlcyBhbmQgZW5lcmd5IGNodW5rcyB0aGF0IGFyZSBjb250YWluZWQgd2l0aGluIGEgYmxvY2sgb2YgYSBzcGVjaWZpYyBzaXplIHdpdGggYSBzcGVjaWZpY1xyXG4vLyBudW1iZXIgb2YgZW5lcmd5IGNodW5rcy4gIElmIGEgbWF0Y2ggY2FuIGJlIGZvdW5kLCB0aGlzIGRhdGEgaXMgdXNlZCB0byBxdWlja2x5IGNvbmZpZ3VyZSB0aGUgYmxvY2sgcmF0aGVyIHRoYW5cclxuLy8gdXNpbmcgdGhlIG11Y2ggbW9yZSBleHBlbnNpdmUgcHJvY2VzcyBvZiBpbnNlcnRpbmcgYW5kIHRoZW4gZGlzdHJpYnV0aW5nIHRoZSBlbmVyZ3kgY2h1bmtzLiAgU2VlXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9lbmVyZ3ktZm9ybXMtYW5kLWNoYW5nZXMvaXNzdWVzLzM3NS5cclxuY29uc3QgRU5FUkdZX0NIVU5LX1BSRVNFVF9DT05GSUdVUkFUSU9OUyA9IFtcclxuXHJcbiAgLy8gaXJvbiBibG9ja1xyXG4gIHtcclxuICAgIG51bWJlck9mU2xpY2VzOiA0LFxyXG4gICAgdG90YWxTbGljZUFyZWE6IDAuMDA4MTAwMDAwMDAwMDAwMDAxLFxyXG4gICAgbnVtYmVyT2ZFbmVyZ3lDaHVua3M6IDYsXHJcbiAgICBlbmVyZ3lDaHVua1Bvc2l0aW9uc0J5U2xpY2U6IFtcclxuICAgICAgW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIHBvc2l0aW9uWDogLTAuMjU2NDA3NTY5NTA2NzAyMzUsXHJcbiAgICAgICAgICBwb3NpdGlvblk6IDAuMDA2ODUwMTM1MDQwNTQ4MzAyXHJcbiAgICAgICAgfVxyXG4gICAgICBdLFxyXG4gICAgICBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcG9zaXRpb25YOiAtMC4yNTM3NTMxNjYwMzQ1MzUzLFxyXG4gICAgICAgICAgcG9zaXRpb25ZOiAwLjAyMzkzMzIxNzkyNTY5NDU3XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwb3NpdGlvblg6IC0wLjIzODI5OTcxNDI3MTg0ODQ2LFxyXG4gICAgICAgICAgcG9zaXRpb25ZOiAwLjAwOTU4MjQ4MjcwNjA3MjIxMVxyXG4gICAgICAgIH1cclxuICAgICAgXSxcclxuICAgICAgW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIHBvc2l0aW9uWDogLTAuMjQzNTgzNDQxOTc2NDIwMzcsXHJcbiAgICAgICAgICBwb3NpdGlvblk6IDAuMDM1MzY5NTIyMzIxOTIxOTk2XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwb3NpdGlvblg6IC0wLjIyODI2ODM2MzA0MTY2MjcsXHJcbiAgICAgICAgICBwb3NpdGlvblk6IDAuMDIwOTg5OTY1Mjk2OTA5NTlcclxuICAgICAgICB9XHJcbiAgICAgIF0sXHJcbiAgICAgIFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwb3NpdGlvblg6IC0wLjIyNTc5MDgwMzgwMTk2MTczLFxyXG4gICAgICAgICAgcG9zaXRpb25ZOiAwLjAzODEwNDc2OTI4MzI0OTg2NVxyXG4gICAgICAgIH1cclxuICAgICAgXVxyXG4gICAgXVxyXG4gIH0sXHJcblxyXG4gIC8vIGJyaWNrXHJcbiAge1xyXG4gICAgbnVtYmVyT2ZTbGljZXM6IDQsXHJcbiAgICB0b3RhbFNsaWNlQXJlYTogMC4wMDgwOTk5OTk5OTk5OTk5OTgsXHJcbiAgICBudW1iZXJPZkVuZXJneUNodW5rczogMixcclxuICAgIGVuZXJneUNodW5rUG9zaXRpb25zQnlTbGljZTogW1xyXG4gICAgICBbXSxcclxuICAgICAgW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIHBvc2l0aW9uWDogLTAuMTUyMzE4ODM4Nzg0MTU3MjgsXHJcbiAgICAgICAgICBwb3NpdGlvblk6IDAuMDE1MTg5Mzk5NTUzNjQ2MjU3XHJcbiAgICAgICAgfVxyXG4gICAgICBdLFxyXG4gICAgICBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcG9zaXRpb25YOiAtMC4xMzc2ODI2NjYzOTkyMTc1OCxcclxuICAgICAgICAgIHBvc2l0aW9uWTogMC4wMjk4MTE4MTc5MDkwMDY2NjZcclxuICAgICAgICB9XHJcbiAgICAgIF0sXHJcbiAgICAgIFtdXHJcbiAgICBdXHJcbiAgfVxyXG5dO1xyXG5cclxuQmxvY2suQmxvY2tJTyA9IG5ldyBJT1R5cGUoICdCbG9ja0lPJywge1xyXG4gIHZhbHVlVHlwZTogQmxvY2ssXHJcbiAgdG9TdGF0ZU9iamVjdDogYmxvY2sgPT4gKCB7IGJsb2NrVHlwZTogQmxvY2tUeXBlRW51bWVyYXRpb25JTy50b1N0YXRlT2JqZWN0KCBibG9jay5ibG9ja1R5cGUgKSB9ICksXHJcbiAgc3RhdGVTY2hlbWE6IHtcclxuICAgIGJsb2NrVHlwZTogQmxvY2tUeXBlRW51bWVyYXRpb25JT1xyXG4gIH1cclxufSApO1xyXG5cclxuZW5lcmd5Rm9ybXNBbmRDaGFuZ2VzLnJl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