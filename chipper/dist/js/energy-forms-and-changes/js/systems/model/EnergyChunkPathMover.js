// Copyright 2016-2023, University of Colorado Boulder

/**
 * a type that is used to move an energy chunk along a pre-defined path
 *
 * @author John Blanco
 * @author Andrew Adare
 * @author Chris Klusendorf (PhET Interactive Simulations)
 */

import dotRandom from '../../../../dot/js/dotRandom.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import merge from '../../../../phet-core/js/merge.js';
import PhetioObject from '../../../../tandem/js/PhetioObject.js';
import Tandem from '../../../../tandem/js/Tandem.js';
import ArrayIO from '../../../../tandem/js/types/ArrayIO.js';
import BooleanIO from '../../../../tandem/js/types/BooleanIO.js';
import IOType from '../../../../tandem/js/types/IOType.js';
import NumberIO from '../../../../tandem/js/types/NumberIO.js';
import ReferenceIO from '../../../../tandem/js/types/ReferenceIO.js';
import EFACConstants from '../../common/EFACConstants.js';
import EnergyChunk from '../../common/model/EnergyChunk.js';
import energyFormsAndChanges from '../../energyFormsAndChanges.js';
class EnergyChunkPathMover extends PhetioObject {
  /**
   * @param {EnergyChunk} energyChunk - energy chunk to be moved
   * @param {Vector2[]} path - points along energy chunk path
   * @param {number} speed - in meters per second
   * @param {Object} [options]
   */
  constructor(energyChunk, path, speed, options) {
    options = merge({
      // phet-io
      tandem: Tandem.REQUIRED,
      phetioType: EnergyChunkPathMover.EnergyChunkPathMoverIO,
      phetioDynamicElement: true
    }, options);

    // validate args
    assert && assert(energyChunk instanceof EnergyChunk, `energyChunk is not of correct type: ${energyChunk}`);
    assert && assert(path.length > 0, 'Path must have at least one point');
    assert && assert(speed >= 0, `speed must be a non-negative scalar. Received: ${speed}`);
    super(options);
    assert && Tandem.VALIDATION && this.isPhetioInstrumented() && assert(energyChunk.isPhetioInstrumented());

    // @public (read-only) {EnergyChunk}
    this.energyChunk = energyChunk;

    // @private
    this.path = path;
    this.speed = speed;
    this.pathFullyTraversed = false;
    this.nextPoint = path[0];
  }

  // @public (EnergyChunkPathMoverIO)
  toStateObject() {
    return {
      path: ArrayIO(Vector2.Vector2IO).toStateObject(this.path),
      speed: this.speed,
      pathFullyTraversed: this.pathFullyTraversed,
      nextPoint: Vector2.Vector2IO.toStateObject(this.nextPoint),
      energyChunkReference: ReferenceIO(EnergyChunk.EnergyChunkIO).toStateObject(this.energyChunk)
    };
  }

  // @public (EnergyChunkPathMoverIO)
  static stateObjectToCreateElementArguments(stateObject) {
    const energyChunk = ReferenceIO(EnergyChunk.EnergyChunkIO).fromStateObject(stateObject.energyChunkReference);
    const path = ArrayIO(Vector2.Vector2IO).fromStateObject(stateObject.path);
    return [energyChunk, path, stateObject.speed];
  }

  // @public (EnergyChunkPathMoverIO)
  applyState(stateObject) {
    this.pathFullyTraversed = stateObject.pathFullyTraversed;

    // Find the actual reference to the current nextPoint, not just a new instance of Vector2 with the same value, see https://github.com/phetsims/energy-forms-and-changes/issues/357
    for (let i = 0; i < this.path.length; i++) {
      const pathElement = this.path[i];
      if (stateObject.nextPoint.x === pathElement.x && stateObject.nextPoint.y === pathElement.y) {
        this.nextPoint = pathElement;
      }
    }
  }

  /**
   * advance chunk position along the path
   * @param  {number} dt - time step in seconds
   * @public
   */
  moveAlongPath(dt) {
    let distanceToTravel = dt * this.speed;
    while (distanceToTravel > 0 && !this.pathFullyTraversed) {
      const chunkPosition = this.energyChunk.positionProperty.get();
      assert && assert(chunkPosition instanceof Vector2, `Expected a Vector2, got this: ${chunkPosition}`);
      const distanceToNextPoint = chunkPosition.distance(this.nextPoint);
      if (distanceToTravel < distanceToNextPoint) {
        // the energy chunk will not reach the next destination point during this step, so just move that direction
        const phi = this.nextPoint.minus(this.energyChunk.positionProperty.get()).angle;
        const velocity = new Vector2(distanceToTravel, 0).rotated(phi);
        this.energyChunk.positionProperty.set(this.energyChunk.positionProperty.get().plus(velocity));
        distanceToTravel = 0; // no remaining distance
      } else {
        // arrived at next destination point
        distanceToTravel -= this.energyChunk.positionProperty.get().distance(this.nextPoint);
        this.energyChunk.positionProperty.set(this.nextPoint);
        if (this.nextPoint === this.path[this.path.length - 1]) {
          // the end of the path has been reached
          this.pathFullyTraversed = true;
        } else {
          const indexOfCurrentNextPoint = this.path.indexOf(this.nextPoint);
          assert && assert(indexOfCurrentNextPoint !== -1, 'This is likely a bug where nextPoint is a different Vector2 reference than on in this.path');
          assert && assert(indexOfCurrentNextPoint < this.path.length - 1, 'should not be the last point yet');

          // set the next destination point
          this.nextPoint = this.path[indexOfCurrentNextPoint + 1];
        }
      }
    }
  }

  /**
   * get the last point in the path that the energy chunk will follow
   * @returns {Vector2}
   * @public
   */
  getFinalDestination() {
    return this.path[this.path.length - 1];
  }

  /**
   * Create an energy chunk path entirely from offsets
   * @param parentPosition {Vector2} the position of the parent element that is creating the path
   * @param offsets {Vector2[]} offsets from the element position
   * @returns {Vector[]}
   * @public
   */
  static createPathFromOffsets(parentPosition, offsets) {
    const path = [];
    for (let i = 0; i < offsets.length; i++) {
      path.push(parentPosition.plus(offsets[i]));
    }
    return path;
  }

  /**
   * Create an energy chunk path for radiated energy chunks
   * @param startingPosition {Vector2} the starting position of the energy chunk
   * @param startingAngle {number} the angle (away from vertical) of the first segment in the path
   * @returns {Vector[]}
   * @public
   */
  static createRadiatedPath(startingPosition, startingAngle) {
    const path = [];
    const segmentLength = 0.06; // in meters. empirically determined to look nice and make it past the top of the beaker
    const verticalSegment = new Vector2(0, segmentLength);

    // calculate the first segment based on the desired starting angle
    const startingSegment = new Vector2(0, segmentLength).rotated(startingAngle);
    let currentPosition = startingPosition.plus(startingSegment);
    path.push(currentPosition);

    // add segments at random angles until the path gets close to the max height
    while (currentPosition.plus(verticalSegment).y < EFACConstants.SYSTEMS_SCREEN_ENERGY_CHUNK_MAX_TRAVEL_HEIGHT) {
      currentPosition = currentPosition.plus(verticalSegment.rotated((dotRandom.nextDouble() - 0.5) * Math.PI / 4));
      path.push(currentPosition);
    }

    // go straight up to the max height cutoff point
    const finalSegment = new Vector2(0, EFACConstants.SYSTEMS_SCREEN_ENERGY_CHUNK_MAX_TRAVEL_HEIGHT - currentPosition.y);
    currentPosition = currentPosition.plus(finalSegment);
    path.push(currentPosition);
    return path;
  }

  /**
   * Create a straight-line energy chunk path at a valid random angle
   * @param position {Vector2}
   * @param validAngles {Range} the range of possible angles to be randomly chosen
   * @returns {Vector[]}
   * @public
   */
  static createRandomStraightPath(position, validAngles) {
    const validRandomAngle = dotRandom.nextDouble() * (validAngles.max - validAngles.min) + validAngles.min;
    return this.createStraightPath(position, validRandomAngle);
  }

  /** Create a straight-line energy chunk path
   * @param position {Vector2} the position that the path is created from
   * @param angle {number} the angle of the path
   * @returns {Vector[]}
   * @public
   */
  static createStraightPath(position, angle) {
    const path = [];

    // calculate the travel segment based on how high the chunk should go
    const yDistance = EFACConstants.SYSTEMS_SCREEN_ENERGY_CHUNK_MAX_TRAVEL_HEIGHT - position.y;
    const xDistance = yDistance / Math.tan(angle) + position.x;
    path.push(new Vector2(xDistance, yDistance));
    return path;
  }
}
EnergyChunkPathMover.EnergyChunkPathMoverIO = new IOType('EnergyChunkPathMoverIO', {
  valueType: EnergyChunkPathMover,
  toStateObject: energyChunkPathMover => energyChunkPathMover.toStateObject(),
  stateObjectToCreateElementArguments: EnergyChunkPathMover.stateObjectToCreateElementArguments,
  applyState: (energyChunkPathMover, stateObject) => energyChunkPathMover.applyState(stateObject),
  stateSchema: {
    path: ArrayIO(Vector2.Vector2IO),
    speed: NumberIO,
    pathFullyTraversed: BooleanIO,
    nextPoint: Vector2.Vector2IO,
    energyChunkReference: ReferenceIO(EnergyChunk.EnergyChunkIO)
  }
});
energyFormsAndChanges.register('EnergyChunkPathMover', EnergyChunkPathMover);
export default EnergyChunkPathMover;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3RSYW5kb20iLCJWZWN0b3IyIiwibWVyZ2UiLCJQaGV0aW9PYmplY3QiLCJUYW5kZW0iLCJBcnJheUlPIiwiQm9vbGVhbklPIiwiSU9UeXBlIiwiTnVtYmVySU8iLCJSZWZlcmVuY2VJTyIsIkVGQUNDb25zdGFudHMiLCJFbmVyZ3lDaHVuayIsImVuZXJneUZvcm1zQW5kQ2hhbmdlcyIsIkVuZXJneUNodW5rUGF0aE1vdmVyIiwiY29uc3RydWN0b3IiLCJlbmVyZ3lDaHVuayIsInBhdGgiLCJzcGVlZCIsIm9wdGlvbnMiLCJ0YW5kZW0iLCJSRVFVSVJFRCIsInBoZXRpb1R5cGUiLCJFbmVyZ3lDaHVua1BhdGhNb3ZlcklPIiwicGhldGlvRHluYW1pY0VsZW1lbnQiLCJhc3NlcnQiLCJsZW5ndGgiLCJWQUxJREFUSU9OIiwiaXNQaGV0aW9JbnN0cnVtZW50ZWQiLCJwYXRoRnVsbHlUcmF2ZXJzZWQiLCJuZXh0UG9pbnQiLCJ0b1N0YXRlT2JqZWN0IiwiVmVjdG9yMklPIiwiZW5lcmd5Q2h1bmtSZWZlcmVuY2UiLCJFbmVyZ3lDaHVua0lPIiwic3RhdGVPYmplY3RUb0NyZWF0ZUVsZW1lbnRBcmd1bWVudHMiLCJzdGF0ZU9iamVjdCIsImZyb21TdGF0ZU9iamVjdCIsImFwcGx5U3RhdGUiLCJpIiwicGF0aEVsZW1lbnQiLCJ4IiwieSIsIm1vdmVBbG9uZ1BhdGgiLCJkdCIsImRpc3RhbmNlVG9UcmF2ZWwiLCJjaHVua1Bvc2l0aW9uIiwicG9zaXRpb25Qcm9wZXJ0eSIsImdldCIsImRpc3RhbmNlVG9OZXh0UG9pbnQiLCJkaXN0YW5jZSIsInBoaSIsIm1pbnVzIiwiYW5nbGUiLCJ2ZWxvY2l0eSIsInJvdGF0ZWQiLCJzZXQiLCJwbHVzIiwiaW5kZXhPZkN1cnJlbnROZXh0UG9pbnQiLCJpbmRleE9mIiwiZ2V0RmluYWxEZXN0aW5hdGlvbiIsImNyZWF0ZVBhdGhGcm9tT2Zmc2V0cyIsInBhcmVudFBvc2l0aW9uIiwib2Zmc2V0cyIsInB1c2giLCJjcmVhdGVSYWRpYXRlZFBhdGgiLCJzdGFydGluZ1Bvc2l0aW9uIiwic3RhcnRpbmdBbmdsZSIsInNlZ21lbnRMZW5ndGgiLCJ2ZXJ0aWNhbFNlZ21lbnQiLCJzdGFydGluZ1NlZ21lbnQiLCJjdXJyZW50UG9zaXRpb24iLCJTWVNURU1TX1NDUkVFTl9FTkVSR1lfQ0hVTktfTUFYX1RSQVZFTF9IRUlHSFQiLCJuZXh0RG91YmxlIiwiTWF0aCIsIlBJIiwiZmluYWxTZWdtZW50IiwiY3JlYXRlUmFuZG9tU3RyYWlnaHRQYXRoIiwicG9zaXRpb24iLCJ2YWxpZEFuZ2xlcyIsInZhbGlkUmFuZG9tQW5nbGUiLCJtYXgiLCJtaW4iLCJjcmVhdGVTdHJhaWdodFBhdGgiLCJ5RGlzdGFuY2UiLCJ4RGlzdGFuY2UiLCJ0YW4iLCJ2YWx1ZVR5cGUiLCJlbmVyZ3lDaHVua1BhdGhNb3ZlciIsInN0YXRlU2NoZW1hIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJFbmVyZ3lDaHVua1BhdGhNb3Zlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNi0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBhIHR5cGUgdGhhdCBpcyB1c2VkIHRvIG1vdmUgYW4gZW5lcmd5IGNodW5rIGFsb25nIGEgcHJlLWRlZmluZWQgcGF0aFxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvXHJcbiAqIEBhdXRob3IgQW5kcmV3IEFkYXJlXHJcbiAqIEBhdXRob3IgQ2hyaXMgS2x1c2VuZG9yZiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgZG90UmFuZG9tIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9kb3RSYW5kb20uanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgUGhldGlvT2JqZWN0IGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy9QaGV0aW9PYmplY3QuanMnO1xyXG5pbXBvcnQgVGFuZGVtIGZyb20gJy4uLy4uLy4uLy4uL3RhbmRlbS9qcy9UYW5kZW0uanMnO1xyXG5pbXBvcnQgQXJyYXlJTyBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvQXJyYXlJTy5qcyc7XHJcbmltcG9ydCBCb29sZWFuSU8gZnJvbSAnLi4vLi4vLi4vLi4vdGFuZGVtL2pzL3R5cGVzL0Jvb2xlYW5JTy5qcyc7XHJcbmltcG9ydCBJT1R5cGUgZnJvbSAnLi4vLi4vLi4vLi4vdGFuZGVtL2pzL3R5cGVzL0lPVHlwZS5qcyc7XHJcbmltcG9ydCBOdW1iZXJJTyBmcm9tICcuLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvTnVtYmVySU8uanMnO1xyXG5pbXBvcnQgUmVmZXJlbmNlSU8gZnJvbSAnLi4vLi4vLi4vLi4vdGFuZGVtL2pzL3R5cGVzL1JlZmVyZW5jZUlPLmpzJztcclxuaW1wb3J0IEVGQUNDb25zdGFudHMgZnJvbSAnLi4vLi4vY29tbW9uL0VGQUNDb25zdGFudHMuanMnO1xyXG5pbXBvcnQgRW5lcmd5Q2h1bmsgZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL0VuZXJneUNodW5rLmpzJztcclxuaW1wb3J0IGVuZXJneUZvcm1zQW5kQ2hhbmdlcyBmcm9tICcuLi8uLi9lbmVyZ3lGb3Jtc0FuZENoYW5nZXMuanMnO1xyXG5cclxuY2xhc3MgRW5lcmd5Q2h1bmtQYXRoTW92ZXIgZXh0ZW5kcyBQaGV0aW9PYmplY3Qge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0VuZXJneUNodW5rfSBlbmVyZ3lDaHVuayAtIGVuZXJneSBjaHVuayB0byBiZSBtb3ZlZFxyXG4gICAqIEBwYXJhbSB7VmVjdG9yMltdfSBwYXRoIC0gcG9pbnRzIGFsb25nIGVuZXJneSBjaHVuayBwYXRoXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkIC0gaW4gbWV0ZXJzIHBlciBzZWNvbmRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIGVuZXJneUNodW5rLCBwYXRoLCBzcGVlZCwgb3B0aW9ucyApIHtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuXHJcbiAgICAgIC8vIHBoZXQtaW9cclxuICAgICAgdGFuZGVtOiBUYW5kZW0uUkVRVUlSRUQsXHJcbiAgICAgIHBoZXRpb1R5cGU6IEVuZXJneUNodW5rUGF0aE1vdmVyLkVuZXJneUNodW5rUGF0aE1vdmVySU8sXHJcbiAgICAgIHBoZXRpb0R5bmFtaWNFbGVtZW50OiB0cnVlXHJcbiAgICB9LCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gdmFsaWRhdGUgYXJnc1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZW5lcmd5Q2h1bmsgaW5zdGFuY2VvZiBFbmVyZ3lDaHVuaywgYGVuZXJneUNodW5rIGlzIG5vdCBvZiBjb3JyZWN0IHR5cGU6ICR7ZW5lcmd5Q2h1bmt9YCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggcGF0aC5sZW5ndGggPiAwLCAnUGF0aCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50JyApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggc3BlZWQgPj0gMCwgYHNwZWVkIG11c3QgYmUgYSBub24tbmVnYXRpdmUgc2NhbGFyLiBSZWNlaXZlZDogJHtzcGVlZH1gICk7XHJcblxyXG4gICAgc3VwZXIoIG9wdGlvbnMgKTtcclxuXHJcbiAgICBhc3NlcnQgJiYgVGFuZGVtLlZBTElEQVRJT04gJiYgdGhpcy5pc1BoZXRpb0luc3RydW1lbnRlZCgpICYmIGFzc2VydCggZW5lcmd5Q2h1bmsuaXNQaGV0aW9JbnN0cnVtZW50ZWQoKSApO1xyXG5cclxuICAgIC8vIEBwdWJsaWMgKHJlYWQtb25seSkge0VuZXJneUNodW5rfVxyXG4gICAgdGhpcy5lbmVyZ3lDaHVuayA9IGVuZXJneUNodW5rO1xyXG5cclxuICAgIC8vIEBwcml2YXRlXHJcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xyXG4gICAgdGhpcy5wYXRoRnVsbHlUcmF2ZXJzZWQgPSBmYWxzZTtcclxuICAgIHRoaXMubmV4dFBvaW50ID0gcGF0aFsgMCBdO1xyXG4gIH1cclxuXHJcbiAgLy8gQHB1YmxpYyAoRW5lcmd5Q2h1bmtQYXRoTW92ZXJJTylcclxuICB0b1N0YXRlT2JqZWN0KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGF0aDogQXJyYXlJTyggVmVjdG9yMi5WZWN0b3IySU8gKS50b1N0YXRlT2JqZWN0KCB0aGlzLnBhdGggKSxcclxuICAgICAgc3BlZWQ6IHRoaXMuc3BlZWQsXHJcbiAgICAgIHBhdGhGdWxseVRyYXZlcnNlZDogdGhpcy5wYXRoRnVsbHlUcmF2ZXJzZWQsXHJcbiAgICAgIG5leHRQb2ludDogVmVjdG9yMi5WZWN0b3IySU8udG9TdGF0ZU9iamVjdCggdGhpcy5uZXh0UG9pbnQgKSxcclxuICAgICAgZW5lcmd5Q2h1bmtSZWZlcmVuY2U6IFJlZmVyZW5jZUlPKCBFbmVyZ3lDaHVuay5FbmVyZ3lDaHVua0lPICkudG9TdGF0ZU9iamVjdCggdGhpcy5lbmVyZ3lDaHVuayApXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gQHB1YmxpYyAoRW5lcmd5Q2h1bmtQYXRoTW92ZXJJTylcclxuICBzdGF0aWMgc3RhdGVPYmplY3RUb0NyZWF0ZUVsZW1lbnRBcmd1bWVudHMoIHN0YXRlT2JqZWN0ICkge1xyXG4gICAgY29uc3QgZW5lcmd5Q2h1bmsgPSBSZWZlcmVuY2VJTyggRW5lcmd5Q2h1bmsuRW5lcmd5Q2h1bmtJTyApLmZyb21TdGF0ZU9iamVjdCggc3RhdGVPYmplY3QuZW5lcmd5Q2h1bmtSZWZlcmVuY2UgKTtcclxuICAgIGNvbnN0IHBhdGggPSBBcnJheUlPKCBWZWN0b3IyLlZlY3RvcjJJTyApLmZyb21TdGF0ZU9iamVjdCggc3RhdGVPYmplY3QucGF0aCApO1xyXG4gICAgcmV0dXJuIFsgZW5lcmd5Q2h1bmssIHBhdGgsIHN0YXRlT2JqZWN0LnNwZWVkIF07XHJcbiAgfVxyXG5cclxuICAvLyBAcHVibGljIChFbmVyZ3lDaHVua1BhdGhNb3ZlcklPKVxyXG4gIGFwcGx5U3RhdGUoIHN0YXRlT2JqZWN0ICkge1xyXG4gICAgdGhpcy5wYXRoRnVsbHlUcmF2ZXJzZWQgPSBzdGF0ZU9iamVjdC5wYXRoRnVsbHlUcmF2ZXJzZWQ7XHJcblxyXG4gICAgLy8gRmluZCB0aGUgYWN0dWFsIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBuZXh0UG9pbnQsIG5vdCBqdXN0IGEgbmV3IGluc3RhbmNlIG9mIFZlY3RvcjIgd2l0aCB0aGUgc2FtZSB2YWx1ZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9lbmVyZ3ktZm9ybXMtYW5kLWNoYW5nZXMvaXNzdWVzLzM1N1xyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICBjb25zdCBwYXRoRWxlbWVudCA9IHRoaXMucGF0aFsgaSBdO1xyXG4gICAgICBpZiAoIHN0YXRlT2JqZWN0Lm5leHRQb2ludC54ID09PSBwYXRoRWxlbWVudC54ICYmIHN0YXRlT2JqZWN0Lm5leHRQb2ludC55ID09PSBwYXRoRWxlbWVudC55ICkge1xyXG4gICAgICAgIHRoaXMubmV4dFBvaW50ID0gcGF0aEVsZW1lbnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGFkdmFuY2UgY2h1bmsgcG9zaXRpb24gYWxvbmcgdGhlIHBhdGhcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR0IC0gdGltZSBzdGVwIGluIHNlY29uZHNcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgbW92ZUFsb25nUGF0aCggZHQgKSB7XHJcblxyXG4gICAgbGV0IGRpc3RhbmNlVG9UcmF2ZWwgPSBkdCAqIHRoaXMuc3BlZWQ7XHJcblxyXG4gICAgd2hpbGUgKCBkaXN0YW5jZVRvVHJhdmVsID4gMCAmJiAhdGhpcy5wYXRoRnVsbHlUcmF2ZXJzZWQgKSB7XHJcblxyXG4gICAgICBjb25zdCBjaHVua1Bvc2l0aW9uID0gdGhpcy5lbmVyZ3lDaHVuay5wb3NpdGlvblByb3BlcnR5LmdldCgpO1xyXG5cclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggY2h1bmtQb3NpdGlvbiBpbnN0YW5jZW9mIFZlY3RvcjIsIGBFeHBlY3RlZCBhIFZlY3RvcjIsIGdvdCB0aGlzOiAke2NodW5rUG9zaXRpb259YCApO1xyXG5cclxuICAgICAgY29uc3QgZGlzdGFuY2VUb05leHRQb2ludCA9IGNodW5rUG9zaXRpb24uZGlzdGFuY2UoIHRoaXMubmV4dFBvaW50ICk7XHJcblxyXG4gICAgICBpZiAoIGRpc3RhbmNlVG9UcmF2ZWwgPCBkaXN0YW5jZVRvTmV4dFBvaW50ICkge1xyXG5cclxuICAgICAgICAvLyB0aGUgZW5lcmd5IGNodW5rIHdpbGwgbm90IHJlYWNoIHRoZSBuZXh0IGRlc3RpbmF0aW9uIHBvaW50IGR1cmluZyB0aGlzIHN0ZXAsIHNvIGp1c3QgbW92ZSB0aGF0IGRpcmVjdGlvblxyXG4gICAgICAgIGNvbnN0IHBoaSA9IHRoaXMubmV4dFBvaW50Lm1pbnVzKCB0aGlzLmVuZXJneUNodW5rLnBvc2l0aW9uUHJvcGVydHkuZ2V0KCkgKS5hbmdsZTtcclxuICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IG5ldyBWZWN0b3IyKCBkaXN0YW5jZVRvVHJhdmVsLCAwICkucm90YXRlZCggcGhpICk7XHJcbiAgICAgICAgdGhpcy5lbmVyZ3lDaHVuay5wb3NpdGlvblByb3BlcnR5LnNldCggdGhpcy5lbmVyZ3lDaHVuay5wb3NpdGlvblByb3BlcnR5LmdldCgpLnBsdXMoIHZlbG9jaXR5ICkgKTtcclxuICAgICAgICBkaXN0YW5jZVRvVHJhdmVsID0gMDsgLy8gbm8gcmVtYWluaW5nIGRpc3RhbmNlXHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIGFycml2ZWQgYXQgbmV4dCBkZXN0aW5hdGlvbiBwb2ludFxyXG4gICAgICAgIGRpc3RhbmNlVG9UcmF2ZWwgLT0gdGhpcy5lbmVyZ3lDaHVuay5wb3NpdGlvblByb3BlcnR5LmdldCgpLmRpc3RhbmNlKCB0aGlzLm5leHRQb2ludCApO1xyXG4gICAgICAgIHRoaXMuZW5lcmd5Q2h1bmsucG9zaXRpb25Qcm9wZXJ0eS5zZXQoIHRoaXMubmV4dFBvaW50ICk7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5uZXh0UG9pbnQgPT09IHRoaXMucGF0aFsgdGhpcy5wYXRoLmxlbmd0aCAtIDEgXSApIHtcclxuXHJcbiAgICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBwYXRoIGhhcyBiZWVuIHJlYWNoZWRcclxuICAgICAgICAgIHRoaXMucGF0aEZ1bGx5VHJhdmVyc2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBjb25zdCBpbmRleE9mQ3VycmVudE5leHRQb2ludCA9IHRoaXMucGF0aC5pbmRleE9mKCB0aGlzLm5leHRQb2ludCApO1xyXG4gICAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggaW5kZXhPZkN1cnJlbnROZXh0UG9pbnQgIT09IC0xLFxyXG4gICAgICAgICAgICAnVGhpcyBpcyBsaWtlbHkgYSBidWcgd2hlcmUgbmV4dFBvaW50IGlzIGEgZGlmZmVyZW50IFZlY3RvcjIgcmVmZXJlbmNlIHRoYW4gb24gaW4gdGhpcy5wYXRoJyApO1xyXG4gICAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggaW5kZXhPZkN1cnJlbnROZXh0UG9pbnQgPCB0aGlzLnBhdGgubGVuZ3RoIC0gMSwgJ3Nob3VsZCBub3QgYmUgdGhlIGxhc3QgcG9pbnQgeWV0JyApO1xyXG5cclxuICAgICAgICAgIC8vIHNldCB0aGUgbmV4dCBkZXN0aW5hdGlvbiBwb2ludFxyXG4gICAgICAgICAgdGhpcy5uZXh0UG9pbnQgPSB0aGlzLnBhdGhbIGluZGV4T2ZDdXJyZW50TmV4dFBvaW50ICsgMSBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogZ2V0IHRoZSBsYXN0IHBvaW50IGluIHRoZSBwYXRoIHRoYXQgdGhlIGVuZXJneSBjaHVuayB3aWxsIGZvbGxvd1xyXG4gICAqIEByZXR1cm5zIHtWZWN0b3IyfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBnZXRGaW5hbERlc3RpbmF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGF0aFsgdGhpcy5wYXRoLmxlbmd0aCAtIDEgXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBlbmVyZ3kgY2h1bmsgcGF0aCBlbnRpcmVseSBmcm9tIG9mZnNldHNcclxuICAgKiBAcGFyYW0gcGFyZW50UG9zaXRpb24ge1ZlY3RvcjJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgcGFyZW50IGVsZW1lbnQgdGhhdCBpcyBjcmVhdGluZyB0aGUgcGF0aFxyXG4gICAqIEBwYXJhbSBvZmZzZXRzIHtWZWN0b3IyW119IG9mZnNldHMgZnJvbSB0aGUgZWxlbWVudCBwb3NpdGlvblxyXG4gICAqIEByZXR1cm5zIHtWZWN0b3JbXX1cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZVBhdGhGcm9tT2Zmc2V0cyggcGFyZW50UG9zaXRpb24sIG9mZnNldHMgKSB7XHJcbiAgICBjb25zdCBwYXRoID0gW107XHJcblxyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgcGF0aC5wdXNoKCBwYXJlbnRQb3NpdGlvbi5wbHVzKCBvZmZzZXRzWyBpIF0gKSApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXRoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGVuZXJneSBjaHVuayBwYXRoIGZvciByYWRpYXRlZCBlbmVyZ3kgY2h1bmtzXHJcbiAgICogQHBhcmFtIHN0YXJ0aW5nUG9zaXRpb24ge1ZlY3RvcjJ9IHRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiB0aGUgZW5lcmd5IGNodW5rXHJcbiAgICogQHBhcmFtIHN0YXJ0aW5nQW5nbGUge251bWJlcn0gdGhlIGFuZ2xlIChhd2F5IGZyb20gdmVydGljYWwpIG9mIHRoZSBmaXJzdCBzZWdtZW50IGluIHRoZSBwYXRoXHJcbiAgICogQHJldHVybnMge1ZlY3RvcltdfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlUmFkaWF0ZWRQYXRoKCBzdGFydGluZ1Bvc2l0aW9uLCBzdGFydGluZ0FuZ2xlICkge1xyXG4gICAgY29uc3QgcGF0aCA9IFtdO1xyXG4gICAgY29uc3Qgc2VnbWVudExlbmd0aCA9IDAuMDY7IC8vIGluIG1ldGVycy4gZW1waXJpY2FsbHkgZGV0ZXJtaW5lZCB0byBsb29rIG5pY2UgYW5kIG1ha2UgaXQgcGFzdCB0aGUgdG9wIG9mIHRoZSBiZWFrZXJcclxuICAgIGNvbnN0IHZlcnRpY2FsU2VnbWVudCA9IG5ldyBWZWN0b3IyKCAwLCBzZWdtZW50TGVuZ3RoICk7XHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBmaXJzdCBzZWdtZW50IGJhc2VkIG9uIHRoZSBkZXNpcmVkIHN0YXJ0aW5nIGFuZ2xlXHJcbiAgICBjb25zdCBzdGFydGluZ1NlZ21lbnQgPSBuZXcgVmVjdG9yMiggMCwgc2VnbWVudExlbmd0aCApLnJvdGF0ZWQoIHN0YXJ0aW5nQW5nbGUgKTtcclxuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSBzdGFydGluZ1Bvc2l0aW9uLnBsdXMoIHN0YXJ0aW5nU2VnbWVudCApO1xyXG4gICAgcGF0aC5wdXNoKCBjdXJyZW50UG9zaXRpb24gKTtcclxuXHJcbiAgICAvLyBhZGQgc2VnbWVudHMgYXQgcmFuZG9tIGFuZ2xlcyB1bnRpbCB0aGUgcGF0aCBnZXRzIGNsb3NlIHRvIHRoZSBtYXggaGVpZ2h0XHJcbiAgICB3aGlsZSAoIGN1cnJlbnRQb3NpdGlvbi5wbHVzKCB2ZXJ0aWNhbFNlZ21lbnQgKS55IDwgRUZBQ0NvbnN0YW50cy5TWVNURU1TX1NDUkVFTl9FTkVSR1lfQ0hVTktfTUFYX1RSQVZFTF9IRUlHSFQgKSB7XHJcbiAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbi5wbHVzKCB2ZXJ0aWNhbFNlZ21lbnQucm90YXRlZCggKCBkb3RSYW5kb20ubmV4dERvdWJsZSgpIC0gMC41ICkgKiBNYXRoLlBJIC8gNCApICk7XHJcbiAgICAgIHBhdGgucHVzaCggY3VycmVudFBvc2l0aW9uICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ28gc3RyYWlnaHQgdXAgdG8gdGhlIG1heCBoZWlnaHQgY3V0b2ZmIHBvaW50XHJcbiAgICBjb25zdCBmaW5hbFNlZ21lbnQgPSBuZXcgVmVjdG9yMiggMCwgRUZBQ0NvbnN0YW50cy5TWVNURU1TX1NDUkVFTl9FTkVSR1lfQ0hVTktfTUFYX1RSQVZFTF9IRUlHSFQgLSBjdXJyZW50UG9zaXRpb24ueSApO1xyXG4gICAgY3VycmVudFBvc2l0aW9uID0gY3VycmVudFBvc2l0aW9uLnBsdXMoIGZpbmFsU2VnbWVudCApO1xyXG4gICAgcGF0aC5wdXNoKCBjdXJyZW50UG9zaXRpb24gKTtcclxuXHJcbiAgICByZXR1cm4gcGF0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIHN0cmFpZ2h0LWxpbmUgZW5lcmd5IGNodW5rIHBhdGggYXQgYSB2YWxpZCByYW5kb20gYW5nbGVcclxuICAgKiBAcGFyYW0gcG9zaXRpb24ge1ZlY3RvcjJ9XHJcbiAgICogQHBhcmFtIHZhbGlkQW5nbGVzIHtSYW5nZX0gdGhlIHJhbmdlIG9mIHBvc3NpYmxlIGFuZ2xlcyB0byBiZSByYW5kb21seSBjaG9zZW5cclxuICAgKiBAcmV0dXJucyB7VmVjdG9yW119XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGVSYW5kb21TdHJhaWdodFBhdGgoIHBvc2l0aW9uLCB2YWxpZEFuZ2xlcyApIHtcclxuICAgIGNvbnN0IHZhbGlkUmFuZG9tQW5nbGUgPSBkb3RSYW5kb20ubmV4dERvdWJsZSgpICogKCB2YWxpZEFuZ2xlcy5tYXggLSB2YWxpZEFuZ2xlcy5taW4gKSArIHZhbGlkQW5nbGVzLm1pbjtcclxuICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0cmFpZ2h0UGF0aCggcG9zaXRpb24sIHZhbGlkUmFuZG9tQW5nbGUgKTtcclxuICB9XHJcblxyXG4gIC8qKiBDcmVhdGUgYSBzdHJhaWdodC1saW5lIGVuZXJneSBjaHVuayBwYXRoXHJcbiAgICogQHBhcmFtIHBvc2l0aW9uIHtWZWN0b3IyfSB0aGUgcG9zaXRpb24gdGhhdCB0aGUgcGF0aCBpcyBjcmVhdGVkIGZyb21cclxuICAgKiBAcGFyYW0gYW5nbGUge251bWJlcn0gdGhlIGFuZ2xlIG9mIHRoZSBwYXRoXHJcbiAgICogQHJldHVybnMge1ZlY3RvcltdfVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlU3RyYWlnaHRQYXRoKCBwb3NpdGlvbiwgYW5nbGUgKSB7XHJcbiAgICBjb25zdCBwYXRoID0gW107XHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0cmF2ZWwgc2VnbWVudCBiYXNlZCBvbiBob3cgaGlnaCB0aGUgY2h1bmsgc2hvdWxkIGdvXHJcbiAgICBjb25zdCB5RGlzdGFuY2UgPSBFRkFDQ29uc3RhbnRzLlNZU1RFTVNfU0NSRUVOX0VORVJHWV9DSFVOS19NQVhfVFJBVkVMX0hFSUdIVCAtIHBvc2l0aW9uLnk7XHJcbiAgICBjb25zdCB4RGlzdGFuY2UgPSB5RGlzdGFuY2UgLyBNYXRoLnRhbiggYW5nbGUgKSArIHBvc2l0aW9uLng7XHJcbiAgICBwYXRoLnB1c2goIG5ldyBWZWN0b3IyKCB4RGlzdGFuY2UsIHlEaXN0YW5jZSApICk7XHJcblxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbiAgfVxyXG59XHJcblxyXG5FbmVyZ3lDaHVua1BhdGhNb3Zlci5FbmVyZ3lDaHVua1BhdGhNb3ZlcklPID0gbmV3IElPVHlwZSggJ0VuZXJneUNodW5rUGF0aE1vdmVySU8nLCB7XHJcbiAgdmFsdWVUeXBlOiBFbmVyZ3lDaHVua1BhdGhNb3ZlcixcclxuICB0b1N0YXRlT2JqZWN0OiBlbmVyZ3lDaHVua1BhdGhNb3ZlciA9PiBlbmVyZ3lDaHVua1BhdGhNb3Zlci50b1N0YXRlT2JqZWN0KCksXHJcbiAgc3RhdGVPYmplY3RUb0NyZWF0ZUVsZW1lbnRBcmd1bWVudHM6IEVuZXJneUNodW5rUGF0aE1vdmVyLnN0YXRlT2JqZWN0VG9DcmVhdGVFbGVtZW50QXJndW1lbnRzLFxyXG4gIGFwcGx5U3RhdGU6ICggZW5lcmd5Q2h1bmtQYXRoTW92ZXIsIHN0YXRlT2JqZWN0ICkgPT4gZW5lcmd5Q2h1bmtQYXRoTW92ZXIuYXBwbHlTdGF0ZSggc3RhdGVPYmplY3QgKSxcclxuICBzdGF0ZVNjaGVtYToge1xyXG4gICAgcGF0aDogQXJyYXlJTyggVmVjdG9yMi5WZWN0b3IySU8gKSxcclxuICAgIHNwZWVkOiBOdW1iZXJJTyxcclxuICAgIHBhdGhGdWxseVRyYXZlcnNlZDogQm9vbGVhbklPLFxyXG4gICAgbmV4dFBvaW50OiBWZWN0b3IyLlZlY3RvcjJJTyxcclxuICAgIGVuZXJneUNodW5rUmVmZXJlbmNlOiBSZWZlcmVuY2VJTyggRW5lcmd5Q2h1bmsuRW5lcmd5Q2h1bmtJTyApXHJcbiAgfVxyXG59ICk7XHJcblxyXG5lbmVyZ3lGb3Jtc0FuZENoYW5nZXMucmVnaXN0ZXIoICdFbmVyZ3lDaHVua1BhdGhNb3ZlcicsIEVuZXJneUNodW5rUGF0aE1vdmVyICk7XHJcbmV4cG9ydCBkZWZhdWx0IEVuZXJneUNodW5rUGF0aE1vdmVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsU0FBUyxNQUFNLGlDQUFpQztBQUN2RCxPQUFPQyxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLEtBQUssTUFBTSxtQ0FBbUM7QUFDckQsT0FBT0MsWUFBWSxNQUFNLHVD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