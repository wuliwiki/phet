// Copyright 2019-2022, University of Colorado Boulder

/**
 * PlayAreaNode is the view representation of a single PlayArea, which appears in all screens of the 'Collision Lab'
 * simulation. PlayAreaNode was implemented to work for both 1D and 2D screens, so no sub-types are needed.
 *
 * PlayAreaNode draws all of the components that are related to the 'play area', including its background, grid, and
 * border. For the 1D screens, the grid is a series of tick-lines at the top of the PlayArea. When the PlayArea's
 * border reflects, it has a 'thicker' border (and vise versa when its border doesn't reflect).
 *
 * For the 'Collision Lab' sim, there is 1 PlayAreaNode for each screen and they are created at the start if the sim,
 * so they are never disposed.
 *
 * NOTE: Do not translate this node. It's origin must be at the origin of the view coordinate frame.
 *
 * @author Brandon Li
 */

import GridNode from '../../../../griddle/js/GridNode.js';
import { Shape } from '../../../../kite/js/imports.js';
import merge from '../../../../phet-core/js/merge.js';
import AssertUtils from '../../../../phetcommon/js/AssertUtils.js';
import ModelViewTransform2 from '../../../../phetcommon/js/view/ModelViewTransform2.js';
import { Node, Path, Rectangle } from '../../../../scenery/js/imports.js';
import collisionLab from '../../collisionLab.js';
import CollisionLabColors from '../CollisionLabColors.js';
import CollisionLabConstants from '../CollisionLabConstants.js';
import PlayArea from '../model/PlayArea.js';

// constants
const MINOR_GRIDLINE_SPACING = CollisionLabConstants.MINOR_GRIDLINE_SPACING; // In model units.
const MAJOR_GRIDLINE_SPACING = CollisionLabConstants.MAJOR_GRIDLINE_SPACING; // In model units.

class PlayAreaNode extends Node {
  /**
   * @param {PlayArea} playArea
   * @param {Property.<boolean>} gridVisibleProperty
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Object} [options]
   */
  constructor(playArea, gridVisibleProperty, modelViewTransform, options) {
    assert && assert(playArea instanceof PlayArea, `invalid playArea: ${playArea}`);
    assert && AssertUtils.assertPropertyOf(gridVisibleProperty, 'boolean');
    assert && assert(modelViewTransform instanceof ModelViewTransform2, `invalid modelViewTransform: ${modelViewTransform}`);
    options = merge({
      // grid
      majorGridLineWidth: 2,
      // {number} - the line-width of the major grid-lines, in view units.
      minorGridLineWidth: 1,
      // {number} - the line-width of the major grid-lines, in view units.

      // ticks
      majorTickLength: 0.09,
      // {number} - the vertical length of major tick-lines, in model units.
      minorTickLength: 0.06,
      // {number} - the vertical length of major tick-lines, in model units.
      tickLineWidth: 1,
      // {number} - the line-width of tick-lines, in view units.

      // border
      reflectingBorderLineWidth: 3,
      // {number} - the line-width of the border when the border doesn't reflect.
      nonReflectingBorderLineWidth: 1 // {number} - the line-width of the border when the border doesn't reflect.
    }, options);
    assert && assert(!options.children, 'PlayAreaNode sets children');

    //----------------------------------------------------------------------------------------

    // Convenience reference to the view-bounds of the PlayArea.
    const playAreaViewBounds = modelViewTransform.modelToViewBounds(playArea.bounds);

    // Create the background Rectangle, which appears behind the grid/ticks.
    const background = new Rectangle(playAreaViewBounds, {
      fill: CollisionLabColors.GRID_BACKGROUND
    });

    // Create the border Rectangle, which appears in front of the grid/ticks.
    const border = new Rectangle(playAreaViewBounds);

    // Observe when PlayArea's reflectingBorderProperty changes and update the appearance of the border. Link
    // is never unlinked since PlayAreaNodes are never disposed.
    playArea.reflectingBorderProperty.link(reflectingBorder => {
      // Update the line-width of the Border. The border's bounds is dilated so that it fully encapsulates the PlayArea.
      border.lineWidth = reflectingBorder ? options.reflectingBorderLineWidth : options.nonReflectingBorderLineWidth;
      border.rectBounds = playAreaViewBounds.dilated(border.lineWidth / 2);

      // Update the stroke color of the Border.
      border.stroke = reflectingBorder ? CollisionLabColors.REFLECTING_PLAY_AREA_BORDER : CollisionLabColors.NON_REFLECTING_PLAY_AREA_BORDER;
    });

    //----------------------------------------------------------------------------------------

    if (playArea.dimension === PlayArea.Dimension.TWO) {
      // Create the GridNode for 2D screens.
      const gridNode = new GridNode(playAreaViewBounds.width, playAreaViewBounds.height, {
        majorHorizontalLineSpacing: -modelViewTransform.modelToViewDeltaY(MAJOR_GRIDLINE_SPACING),
        majorVerticalLineSpacing: modelViewTransform.modelToViewDeltaX(MAJOR_GRIDLINE_SPACING),
        minorHorizontalLineSpacing: -modelViewTransform.modelToViewDeltaY(MINOR_GRIDLINE_SPACING),
        minorVerticalLineSpacing: modelViewTransform.modelToViewDeltaX(MINOR_GRIDLINE_SPACING),
        majorLineOptions: {
          lineWidth: options.majorGridLineWidth,
          stroke: CollisionLabColors.MAJOR_GRIDLINE_COLOR
        },
        minorLineOptions: {
          lineWidth: options.minorGridLineWidth,
          stroke: CollisionLabColors.MINOR_GRIDLINE_COLOR
        },
        center: playAreaViewBounds.center
      });

      // Observe when the gridVisibleProperty changes and update the visibility of the GridNode. Link is never unlinked
      // since PlayAreaNodes are never disposed.
      gridVisibleProperty.linkAttribute(gridNode, 'visible');

      // Set the children in the correct rendering order.
      options.children = [background, gridNode, border];
    } else {
      // For 1D screens, drag tick-lines at the top of the PlayArea.
      const minorTickLinesShape = new Shape();
      const majorTickLinesShape = new Shape();

      // Minor Tick lines
      for (let xValue = playArea.left; xValue <= playArea.right; xValue += MINOR_GRIDLINE_SPACING) {
        minorTickLinesShape.moveTo(xValue, playArea.top).verticalLineToRelative(-options.minorTickLength);
      }

      // Major Tick lines
      for (let xValue = playArea.left; xValue <= playArea.right; xValue += MAJOR_GRIDLINE_SPACING) {
        majorTickLinesShape.moveTo(xValue, playArea.top).verticalLineToRelative(-options.majorTickLength);
      }

      // Create the Paths for the minor and major Ticks.
      const minorTickLinesPath = new Path(modelViewTransform.modelToViewShape(minorTickLinesShape), {
        lineWidth: options.tickLineWidth,
        stroke: CollisionLabColors.TICK_LINE_COLOR
      });
      const majorTickLinesPath = new Path(modelViewTransform.modelToViewShape(majorTickLinesShape), {
        lineWidth: options.tickLineWidth,
        stroke: CollisionLabColors.TICK_LINE_COLOR
      });

      // Verify that the grid (ticks) are always visible in 1D screens.
      assert && playArea.gridVisibleProperty.link(gridVisible => assert(gridVisible, 'grids must be visible'));

      // Set the children in the correct rendering order.
      options.children = [background, minorTickLinesPath, majorTickLinesPath, border];
    }
    super(options);
  }
}
collisionLab.register('PlayAreaNode', PlayAreaNode);
export default PlayAreaNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJHcmlkTm9kZSIsIlNoYXBlIiwibWVyZ2UiLCJBc3NlcnRVdGlscyIsIk1vZGVsVmlld1RyYW5zZm9ybTIiLCJOb2RlIiwiUGF0aCIsIlJlY3RhbmdsZSIsImNvbGxpc2lvbkxhYiIsIkNvbGxpc2lvbkxhYkNvbG9ycyIsIkNvbGxpc2lvbkxhYkNvbnN0YW50cyIsIlBsYXlBcmVhIiwiTUlOT1JfR1JJRExJTkVfU1BBQ0lORyIsIk1BSk9SX0dSSURMSU5FX1NQQUNJTkciLCJQbGF5QXJlYU5vZGUiLCJjb25zdHJ1Y3RvciIsInBsYXlBcmVhIiwiZ3JpZFZpc2libGVQcm9wZXJ0eSIsIm1vZGVsVmlld1RyYW5zZm9ybSIsIm9wdGlvbnMiLCJhc3NlcnQiLCJhc3NlcnRQcm9wZXJ0eU9mIiwibWFqb3JHcmlkTGluZVdpZHRoIiwibWlub3JHcmlkTGluZVdpZHRoIiwibWFqb3JUaWNrTGVuZ3RoIiwibWlub3JUaWNrTGVuZ3RoIiwidGlja0xpbmVXaWR0aCIsInJlZmxlY3RpbmdCb3JkZXJMaW5lV2lkdGgiLCJub25SZWZsZWN0aW5nQm9yZGVyTGluZVdpZHRoIiwiY2hpbGRyZW4iLCJwbGF5QXJlYVZpZXdCb3VuZHMiLCJtb2RlbFRvVmlld0JvdW5kcyIsImJvdW5kcyIsImJhY2tncm91bmQiLCJmaWxsIiwiR1JJRF9CQUNLR1JPVU5EIiwiYm9yZGVyIiwicmVmbGVjdGluZ0JvcmRlclByb3BlcnR5IiwibGluayIsInJlZmxlY3RpbmdCb3JkZXIiLCJsaW5lV2lkdGgiLCJyZWN0Qm91bmRzIiwiZGlsYXRlZCIsInN0cm9rZSIsIlJFRkxFQ1RJTkdfUExBWV9BUkVBX0JPUkRFUiIsIk5PTl9SRUZMRUNUSU5HX1BMQVlfQVJFQV9CT1JERVIiLCJkaW1lbnNpb24iLCJEaW1lbnNpb24iLCJUV08iLCJncmlkTm9kZSIsIndpZHRoIiwiaGVpZ2h0IiwibWFqb3JIb3Jpem9udGFsTGluZVNwYWNpbmciLCJtb2RlbFRvVmlld0RlbHRhWSIsIm1ham9yVmVydGljYWxMaW5lU3BhY2luZyIsIm1vZGVsVG9WaWV3RGVsdGFYIiwibWlub3JIb3Jpem9udGFsTGluZVNwYWNpbmciLCJtaW5vclZlcnRpY2FsTGluZVNwYWNpbmciLCJtYWpvckxpbmVPcHRpb25zIiwiTUFKT1JfR1JJRExJTkVfQ09MT1IiLCJtaW5vckxpbmVPcHRpb25zIiwiTUlOT1JfR1JJRExJTkVfQ09MT1IiLCJjZW50ZXIiLCJsaW5rQXR0cmlidXRlIiwibWlub3JUaWNrTGluZXNTaGFwZSIsIm1ham9yVGlja0xpbmVzU2hhcGUiLCJ4VmFsdWUiLCJsZWZ0IiwicmlnaHQiLCJtb3ZlVG8iLCJ0b3AiLCJ2ZXJ0aWNhbExpbmVUb1JlbGF0aXZlIiwibWlub3JUaWNrTGluZXNQYXRoIiwibW9kZWxUb1ZpZXdTaGFwZSIsIlRJQ0tfTElORV9DT0xPUiIsIm1ham9yVGlja0xpbmVzUGF0aCIsImdyaWRWaXNpYmxlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJQbGF5QXJlYU5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTktMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogUGxheUFyZWFOb2RlIGlzIHRoZSB2aWV3IHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIFBsYXlBcmVhLCB3aGljaCBhcHBlYXJzIGluIGFsbCBzY3JlZW5zIG9mIHRoZSAnQ29sbGlzaW9uIExhYidcclxuICogc2ltdWxhdGlvbi4gUGxheUFyZWFOb2RlIHdhcyBpbXBsZW1lbnRlZCB0byB3b3JrIGZvciBib3RoIDFEIGFuZCAyRCBzY3JlZW5zLCBzbyBubyBzdWItdHlwZXMgYXJlIG5lZWRlZC5cclxuICpcclxuICogUGxheUFyZWFOb2RlIGRyYXdzIGFsbCBvZiB0aGUgY29tcG9uZW50cyB0aGF0IGFyZSByZWxhdGVkIHRvIHRoZSAncGxheSBhcmVhJywgaW5jbHVkaW5nIGl0cyBiYWNrZ3JvdW5kLCBncmlkLCBhbmRcclxuICogYm9yZGVyLiBGb3IgdGhlIDFEIHNjcmVlbnMsIHRoZSBncmlkIGlzIGEgc2VyaWVzIG9mIHRpY2stbGluZXMgYXQgdGhlIHRvcCBvZiB0aGUgUGxheUFyZWEuIFdoZW4gdGhlIFBsYXlBcmVhJ3NcclxuICogYm9yZGVyIHJlZmxlY3RzLCBpdCBoYXMgYSAndGhpY2tlcicgYm9yZGVyIChhbmQgdmlzZSB2ZXJzYSB3aGVuIGl0cyBib3JkZXIgZG9lc24ndCByZWZsZWN0KS5cclxuICpcclxuICogRm9yIHRoZSAnQ29sbGlzaW9uIExhYicgc2ltLCB0aGVyZSBpcyAxIFBsYXlBcmVhTm9kZSBmb3IgZWFjaCBzY3JlZW4gYW5kIHRoZXkgYXJlIGNyZWF0ZWQgYXQgdGhlIHN0YXJ0IGlmIHRoZSBzaW0sXHJcbiAqIHNvIHRoZXkgYXJlIG5ldmVyIGRpc3Bvc2VkLlxyXG4gKlxyXG4gKiBOT1RFOiBEbyBub3QgdHJhbnNsYXRlIHRoaXMgbm9kZS4gSXQncyBvcmlnaW4gbXVzdCBiZSBhdCB0aGUgb3JpZ2luIG9mIHRoZSB2aWV3IGNvb3JkaW5hdGUgZnJhbWUuXHJcbiAqXHJcbiAqIEBhdXRob3IgQnJhbmRvbiBMaVxyXG4gKi9cclxuXHJcbmltcG9ydCBHcmlkTm9kZSBmcm9tICcuLi8uLi8uLi8uLi9ncmlkZGxlL2pzL0dyaWROb2RlLmpzJztcclxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi8uLi8uLi8uLi9raXRlL2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lcmdlLmpzJztcclxuaW1wb3J0IEFzc2VydFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL3BoZXRjb21tb24vanMvQXNzZXJ0VXRpbHMuanMnO1xyXG5pbXBvcnQgTW9kZWxWaWV3VHJhbnNmb3JtMiBmcm9tICcuLi8uLi8uLi8uLi9waGV0Y29tbW9uL2pzL3ZpZXcvTW9kZWxWaWV3VHJhbnNmb3JtMi5qcyc7XHJcbmltcG9ydCB7IE5vZGUsIFBhdGgsIFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBjb2xsaXNpb25MYWIgZnJvbSAnLi4vLi4vY29sbGlzaW9uTGFiLmpzJztcclxuaW1wb3J0IENvbGxpc2lvbkxhYkNvbG9ycyBmcm9tICcuLi9Db2xsaXNpb25MYWJDb2xvcnMuanMnO1xyXG5pbXBvcnQgQ29sbGlzaW9uTGFiQ29uc3RhbnRzIGZyb20gJy4uL0NvbGxpc2lvbkxhYkNvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBQbGF5QXJlYSBmcm9tICcuLi9tb2RlbC9QbGF5QXJlYS5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgTUlOT1JfR1JJRExJTkVfU1BBQ0lORyA9IENvbGxpc2lvbkxhYkNvbnN0YW50cy5NSU5PUl9HUklETElORV9TUEFDSU5HOyAvLyBJbiBtb2RlbCB1bml0cy5cclxuY29uc3QgTUFKT1JfR1JJRExJTkVfU1BBQ0lORyA9IENvbGxpc2lvbkxhYkNvbnN0YW50cy5NQUpPUl9HUklETElORV9TUEFDSU5HOyAvLyBJbiBtb2RlbCB1bml0cy5cclxuXHJcbmNsYXNzIFBsYXlBcmVhTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1BsYXlBcmVhfSBwbGF5QXJlYVxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHkuPGJvb2xlYW4+fSBncmlkVmlzaWJsZVByb3BlcnR5XHJcbiAgICogQHBhcmFtIHtNb2RlbFZpZXdUcmFuc2Zvcm0yfSBtb2RlbFZpZXdUcmFuc2Zvcm1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIHBsYXlBcmVhLCBncmlkVmlzaWJsZVByb3BlcnR5LCBtb2RlbFZpZXdUcmFuc2Zvcm0sIG9wdGlvbnMgKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwbGF5QXJlYSBpbnN0YW5jZW9mIFBsYXlBcmVhLCBgaW52YWxpZCBwbGF5QXJlYTogJHtwbGF5QXJlYX1gICk7XHJcbiAgICBhc3NlcnQgJiYgQXNzZXJ0VXRpbHMuYXNzZXJ0UHJvcGVydHlPZiggZ3JpZFZpc2libGVQcm9wZXJ0eSwgJ2Jvb2xlYW4nICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBtb2RlbFZpZXdUcmFuc2Zvcm0gaW5zdGFuY2VvZiBNb2RlbFZpZXdUcmFuc2Zvcm0yLCBgaW52YWxpZCBtb2RlbFZpZXdUcmFuc2Zvcm06ICR7bW9kZWxWaWV3VHJhbnNmb3JtfWAgKTtcclxuXHJcbiAgICBvcHRpb25zID0gbWVyZ2UoIHtcclxuXHJcbiAgICAgIC8vIGdyaWRcclxuICAgICAgbWFqb3JHcmlkTGluZVdpZHRoOiAyLCAvLyB7bnVtYmVyfSAtIHRoZSBsaW5lLXdpZHRoIG9mIHRoZSBtYWpvciBncmlkLWxpbmVzLCBpbiB2aWV3IHVuaXRzLlxyXG4gICAgICBtaW5vckdyaWRMaW5lV2lkdGg6IDEsIC8vIHtudW1iZXJ9IC0gdGhlIGxpbmUtd2lkdGggb2YgdGhlIG1ham9yIGdyaWQtbGluZXMsIGluIHZpZXcgdW5pdHMuXHJcblxyXG4gICAgICAvLyB0aWNrc1xyXG4gICAgICBtYWpvclRpY2tMZW5ndGg6IDAuMDksIC8vIHtudW1iZXJ9IC0gdGhlIHZlcnRpY2FsIGxlbmd0aCBvZiBtYWpvciB0aWNrLWxpbmVzLCBpbiBtb2RlbCB1bml0cy5cclxuICAgICAgbWlub3JUaWNrTGVuZ3RoOiAwLjA2LCAvLyB7bnVtYmVyfSAtIHRoZSB2ZXJ0aWNhbCBsZW5ndGggb2YgbWFqb3IgdGljay1saW5lcywgaW4gbW9kZWwgdW5pdHMuXHJcbiAgICAgIHRpY2tMaW5lV2lkdGg6IDEsICAgICAgLy8ge251bWJlcn0gLSB0aGUgbGluZS13aWR0aCBvZiB0aWNrLWxpbmVzLCBpbiB2aWV3IHVuaXRzLlxyXG5cclxuICAgICAgLy8gYm9yZGVyXHJcbiAgICAgIHJlZmxlY3RpbmdCb3JkZXJMaW5lV2lkdGg6IDMsICAgLy8ge251bWJlcn0gLSB0aGUgbGluZS13aWR0aCBvZiB0aGUgYm9yZGVyIHdoZW4gdGhlIGJvcmRlciBkb2Vzbid0IHJlZmxlY3QuXHJcbiAgICAgIG5vblJlZmxlY3RpbmdCb3JkZXJMaW5lV2lkdGg6IDEgLy8ge251bWJlcn0gLSB0aGUgbGluZS13aWR0aCBvZiB0aGUgYm9yZGVyIHdoZW4gdGhlIGJvcmRlciBkb2Vzbid0IHJlZmxlY3QuXHJcblxyXG4gICAgfSwgb3B0aW9ucyApO1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICFvcHRpb25zLmNoaWxkcmVuLCAnUGxheUFyZWFOb2RlIHNldHMgY2hpbGRyZW4nICk7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLy8gQ29udmVuaWVuY2UgcmVmZXJlbmNlIHRvIHRoZSB2aWV3LWJvdW5kcyBvZiB0aGUgUGxheUFyZWEuXHJcbiAgICBjb25zdCBwbGF5QXJlYVZpZXdCb3VuZHMgPSBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdCb3VuZHMoIHBsYXlBcmVhLmJvdW5kcyApO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgYmFja2dyb3VuZCBSZWN0YW5nbGUsIHdoaWNoIGFwcGVhcnMgYmVoaW5kIHRoZSBncmlkL3RpY2tzLlxyXG4gICAgY29uc3QgYmFja2dyb3VuZCA9IG5ldyBSZWN0YW5nbGUoIHBsYXlBcmVhVmlld0JvdW5kcywgeyBmaWxsOiBDb2xsaXNpb25MYWJDb2xvcnMuR1JJRF9CQUNLR1JPVU5EIH0gKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIGJvcmRlciBSZWN0YW5nbGUsIHdoaWNoIGFwcGVhcnMgaW4gZnJvbnQgb2YgdGhlIGdyaWQvdGlja3MuXHJcbiAgICBjb25zdCBib3JkZXIgPSBuZXcgUmVjdGFuZ2xlKCBwbGF5QXJlYVZpZXdCb3VuZHMgKTtcclxuXHJcbiAgICAvLyBPYnNlcnZlIHdoZW4gUGxheUFyZWEncyByZWZsZWN0aW5nQm9yZGVyUHJvcGVydHkgY2hhbmdlcyBhbmQgdXBkYXRlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBib3JkZXIuIExpbmtcclxuICAgIC8vIGlzIG5ldmVyIHVubGlua2VkIHNpbmNlIFBsYXlBcmVhTm9kZXMgYXJlIG5ldmVyIGRpc3Bvc2VkLlxyXG4gICAgcGxheUFyZWEucmVmbGVjdGluZ0JvcmRlclByb3BlcnR5LmxpbmsoIHJlZmxlY3RpbmdCb3JkZXIgPT4ge1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBsaW5lLXdpZHRoIG9mIHRoZSBCb3JkZXIuIFRoZSBib3JkZXIncyBib3VuZHMgaXMgZGlsYXRlZCBzbyB0aGF0IGl0IGZ1bGx5IGVuY2Fwc3VsYXRlcyB0aGUgUGxheUFyZWEuXHJcbiAgICAgIGJvcmRlci5saW5lV2lkdGggPSByZWZsZWN0aW5nQm9yZGVyID8gb3B0aW9ucy5yZWZsZWN0aW5nQm9yZGVyTGluZVdpZHRoIDogb3B0aW9ucy5ub25SZWZsZWN0aW5nQm9yZGVyTGluZVdpZHRoO1xyXG4gICAgICBib3JkZXIucmVjdEJvdW5kcyA9IHBsYXlBcmVhVmlld0JvdW5kcy5kaWxhdGVkKCBib3JkZXIubGluZVdpZHRoIC8gMiApO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBzdHJva2UgY29sb3Igb2YgdGhlIEJvcmRlci5cclxuICAgICAgYm9yZGVyLnN0cm9rZSA9IHJlZmxlY3RpbmdCb3JkZXIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgQ29sbGlzaW9uTGFiQ29sb3JzLlJFRkxFQ1RJTkdfUExBWV9BUkVBX0JPUkRFUiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICBDb2xsaXNpb25MYWJDb2xvcnMuTk9OX1JFRkxFQ1RJTkdfUExBWV9BUkVBX0JPUkRFUjtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBpZiAoIHBsYXlBcmVhLmRpbWVuc2lvbiA9PT0gUGxheUFyZWEuRGltZW5zaW9uLlRXTyApIHtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgR3JpZE5vZGUgZm9yIDJEIHNjcmVlbnMuXHJcbiAgICAgIGNvbnN0IGdyaWROb2RlID0gbmV3IEdyaWROb2RlKCBwbGF5QXJlYVZpZXdCb3VuZHMud2lkdGgsIHBsYXlBcmVhVmlld0JvdW5kcy5oZWlnaHQsIHtcclxuICAgICAgICBtYWpvckhvcml6b250YWxMaW5lU3BhY2luZzogLW1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhWSggTUFKT1JfR1JJRExJTkVfU1BBQ0lORyApLFxyXG4gICAgICAgIG1ham9yVmVydGljYWxMaW5lU3BhY2luZzogbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3RGVsdGFYKCBNQUpPUl9HUklETElORV9TUEFDSU5HICksXHJcbiAgICAgICAgbWlub3JIb3Jpem9udGFsTGluZVNwYWNpbmc6IC1tb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdEZWx0YVkoIE1JTk9SX0dSSURMSU5FX1NQQUNJTkcgKSxcclxuICAgICAgICBtaW5vclZlcnRpY2FsTGluZVNwYWNpbmc6IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld0RlbHRhWCggTUlOT1JfR1JJRExJTkVfU1BBQ0lORyApLFxyXG4gICAgICAgIG1ham9yTGluZU9wdGlvbnM6IHtcclxuICAgICAgICAgIGxpbmVXaWR0aDogb3B0aW9ucy5tYWpvckdyaWRMaW5lV2lkdGgsXHJcbiAgICAgICAgICBzdHJva2U6IENvbGxpc2lvbkxhYkNvbG9ycy5NQUpPUl9HUklETElORV9DT0xPUlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWlub3JMaW5lT3B0aW9uczoge1xyXG4gICAgICAgICAgbGluZVdpZHRoOiBvcHRpb25zLm1pbm9yR3JpZExpbmVXaWR0aCxcclxuICAgICAgICAgIHN0cm9rZTogQ29sbGlzaW9uTGFiQ29sb3JzLk1JTk9SX0dSSURMSU5FX0NPTE9SXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjZW50ZXI6IHBsYXlBcmVhVmlld0JvdW5kcy5jZW50ZXJcclxuICAgICAgfSApO1xyXG5cclxuICAgICAgLy8gT2JzZXJ2ZSB3aGVuIHRoZSBncmlkVmlzaWJsZVByb3BlcnR5IGNoYW5nZXMgYW5kIHVwZGF0ZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgR3JpZE5vZGUuIExpbmsgaXMgbmV2ZXIgdW5saW5rZWRcclxuICAgICAgLy8gc2luY2UgUGxheUFyZWFOb2RlcyBhcmUgbmV2ZXIgZGlzcG9zZWQuXHJcbiAgICAgIGdyaWRWaXNpYmxlUHJvcGVydHkubGlua0F0dHJpYnV0ZSggZ3JpZE5vZGUsICd2aXNpYmxlJyApO1xyXG5cclxuICAgICAgLy8gU2V0IHRoZSBjaGlsZHJlbiBpbiB0aGUgY29ycmVjdCByZW5kZXJpbmcgb3JkZXIuXHJcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gPSBbXHJcbiAgICAgICAgYmFja2dyb3VuZCxcclxuICAgICAgICBncmlkTm9kZSxcclxuICAgICAgICBib3JkZXJcclxuICAgICAgXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgLy8gRm9yIDFEIHNjcmVlbnMsIGRyYWcgdGljay1saW5lcyBhdCB0aGUgdG9wIG9mIHRoZSBQbGF5QXJlYS5cclxuICAgICAgY29uc3QgbWlub3JUaWNrTGluZXNTaGFwZSA9IG5ldyBTaGFwZSgpO1xyXG4gICAgICBjb25zdCBtYWpvclRpY2tMaW5lc1NoYXBlID0gbmV3IFNoYXBlKCk7XHJcblxyXG4gICAgICAvLyBNaW5vciBUaWNrIGxpbmVzXHJcbiAgICAgIGZvciAoIGxldCB4VmFsdWUgPSBwbGF5QXJlYS5sZWZ0OyB4VmFsdWUgPD0gcGxheUFyZWEucmlnaHQ7IHhWYWx1ZSArPSBNSU5PUl9HUklETElORV9TUEFDSU5HICkge1xyXG4gICAgICAgIG1pbm9yVGlja0xpbmVzU2hhcGUubW92ZVRvKCB4VmFsdWUsIHBsYXlBcmVhLnRvcCApLnZlcnRpY2FsTGluZVRvUmVsYXRpdmUoIC1vcHRpb25zLm1pbm9yVGlja0xlbmd0aCApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNYWpvciBUaWNrIGxpbmVzXHJcbiAgICAgIGZvciAoIGxldCB4VmFsdWUgPSBwbGF5QXJlYS5sZWZ0OyB4VmFsdWUgPD0gcGxheUFyZWEucmlnaHQ7IHhWYWx1ZSArPSBNQUpPUl9HUklETElORV9TUEFDSU5HICkge1xyXG4gICAgICAgIG1ham9yVGlja0xpbmVzU2hhcGUubW92ZVRvKCB4VmFsdWUsIHBsYXlBcmVhLnRvcCApLnZlcnRpY2FsTGluZVRvUmVsYXRpdmUoIC1vcHRpb25zLm1ham9yVGlja0xlbmd0aCApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIFBhdGhzIGZvciB0aGUgbWlub3IgYW5kIG1ham9yIFRpY2tzLlxyXG4gICAgICBjb25zdCBtaW5vclRpY2tMaW5lc1BhdGggPSBuZXcgUGF0aCggbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3U2hhcGUoIG1pbm9yVGlja0xpbmVzU2hhcGUgKSwge1xyXG4gICAgICAgIGxpbmVXaWR0aDogb3B0aW9ucy50aWNrTGluZVdpZHRoLFxyXG4gICAgICAgIHN0cm9rZTogQ29sbGlzaW9uTGFiQ29sb3JzLlRJQ0tfTElORV9DT0xPUlxyXG4gICAgICB9ICk7XHJcbiAgICAgIGNvbnN0IG1ham9yVGlja0xpbmVzUGF0aCA9IG5ldyBQYXRoKCBtb2RlbFZpZXdUcmFuc2Zvcm0ubW9kZWxUb1ZpZXdTaGFwZSggbWFqb3JUaWNrTGluZXNTaGFwZSApLCB7XHJcbiAgICAgICAgbGluZVdpZHRoOiBvcHRpb25zLnRpY2tMaW5lV2lkdGgsXHJcbiAgICAgICAgc3Ryb2tlOiBDb2xsaXNpb25MYWJDb2xvcnMuVElDS19MSU5FX0NPTE9SXHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBncmlkICh0aWNrcykgYXJlIGFsd2F5cyB2aXNpYmxlIGluIDFEIHNjcmVlbnMuXHJcbiAgICAgIGFzc2VydCAmJiBwbGF5QXJlYS5ncmlkVmlzaWJsZVByb3BlcnR5LmxpbmsoIGdyaWRWaXNpYmxlID0+IGFzc2VydCggZ3JpZFZpc2libGUsICdncmlkcyBtdXN0IGJlIHZpc2libGUnICkgKTtcclxuXHJcbiAgICAgIC8vIFNldCB0aGUgY2hpbGRyZW4gaW4gdGhlIGNvcnJlY3QgcmVuZGVyaW5nIG9yZGVyLlxyXG4gICAgICBvcHRpb25zLmNoaWxkcmVuID0gW1xyXG4gICAgICAgIGJhY2tncm91bmQsXHJcbiAgICAgICAgbWlub3JUaWNrTGluZXNQYXRoLFxyXG4gICAgICAgIG1ham9yVGlja0xpbmVzUGF0aCxcclxuICAgICAgICBib3JkZXJcclxuICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBzdXBlciggb3B0aW9ucyApO1xyXG4gIH1cclxufVxyXG5cclxuY29sbGlzaW9uTGFiLnJlZ2lzdGVyKCAnUGxheUFyZWFOb2RlJywgUGxheUFyZWFOb2RlICk7XHJcbmV4cG9ydCBkZWZhdWx0IFBsYXlBcmVhTm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxRQUFRLE1BQU0sb0NBQW9DO0FBQ3pELFNBQVNDLEtBQUssUUFBUSxnQ0FBZ0M7QUFDdEQsT0FBT0MsS0FBSyxNQUFNLG1DQUFtQztBQUNyRCxPQUFPQyxXQUFXLE1BQU0sMENBQTBDO0FBQ2xFLE9BQU9DLG1CQUFtQixNQUFNLHVEQUF1RDtBQUN2RixTQUFTQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsU0FBUyxRQUFRLG1DQUFtQztBQUN6RSxPQUFPQyxZQUFZLE1BQU0sdUJBQXVCO0FBQ2hELE9BQU9DLGtCQUFrQixNQUFNLDBCQUEwQjtBQUN6RCxPQUFPQyxxQkFBcUIsTUFBTSw2QkFBNkI7QUFDL0QsT0FBT0MsUUFBUSxNQUFNLHNCQUFzQjs7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