// Copyright 2020, University of Colorado Boulder

/**
 * BallUtils is a collection of utility functions that are related to Balls.
 *
 * @author Brandon Li
 */

import Bounds2 from '../../../../dot/js/Bounds2.js';
import Range from '../../../../dot/js/Range.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import AssertUtils from '../../../../phetcommon/js/AssertUtils.js';
import collisionLab from '../../collisionLab.js';
import CollisionLabConstants from '../CollisionLabConstants.js';
import CollisionLabUtils from '../CollisionLabUtils.js';
import Ball from './Ball.js';
const BallUtils = {
  /**
   * Calculates the radius of a Ball. If the 'Constant Size' checkbox is checked, it uses the constant radius.
   * Otherwise, the radius is derived from the mass and the uniform density of the Ball.
   *
   * Derivation:
   *   Volume = 4/3 PI * Radius^3
   *     => Density = Mass / Volume = Mass / ( 4/3 PI * Radius^3 )
   *     => Radius = (3/4 * Mass / Density / PI ) ^ 1/3
   *
   * @public
   * @param {number} mass - mass of the Ball, in kg.
   * @param {boolean} isConstantSize - indicates if the 'Constant Size' checkbox is checked.
   * @returns {number} - in meters
   */
  calculateBallRadius(mass, isConstantSize = false) {
    assert && assert(typeof mass === 'number', `invalid mass: ${mass}`);
    assert && assert(typeof isConstantSize === 'boolean', `invalid isConstantSize: ${isConstantSize}`);
    return isConstantSize ? CollisionLabConstants.BALL_CONSTANT_RADIUS : (3 / 4 * mass / CollisionLabConstants.BALL_DEFAULT_DENSITY / Math.PI) ** (1 / 3);
  },
  /**
   * Computes the Bounds of the center-position of the Ball that satisfies the following invariants:
   *   (1) The Bounds of the PlayArea is eroded inwards such that the Ball is fully inside the PlayArea bounds.
   *   (2) The edge of the Bounds is eroded inwards further so that it is on an exact grid-line.
   *
   * This Bounds is used when the Ball is dragged with the grid visible to ensure that the Ball isn't snapped to a
   * grid-line that makes part of the Ball out of Bounds. Also used for position ranges in the Keypad.
   *
   * @public
   * @param {Bounds2} playAreaBounds - the bounds of the PlayArea.
   * @param {number} radius - the radius of the Ball, in meters.
   * @param {number} [gridLineSpacing] - spacing between grid-lines, in meters.
   * @returns {Bounds2}
   */
  getBallGridSafeConstrainedBounds(playAreaBounds, radius, gridLineSpacing = CollisionLabConstants.MINOR_GRIDLINE_SPACING) {
    assert && assert(playAreaBounds instanceof Bounds2, `invalid playAreaBounds: ${playAreaBounds}`);
    assert && assert(typeof radius === 'number' && radius > 0, `invalid radius: ${radius}`);

    // First get the constrainedBounds, which is the Bounds that ensures the Ball is completely inside the PlayArea. It
    // is eroded by the radius of the ball since the Bounds is the bounding-box of the center of the Ball.
    const constrainedBounds = playAreaBounds.eroded(radius);

    // Round the constrainedBounds inwards to the nearest grid-line to ensure that the Ball's center-position is bounded
    // on an exact grid-line AND is fully inside the PlayArea.
    return CollisionLabUtils.roundBoundsInToNearest(constrainedBounds, gridLineSpacing);
  },
  /**
   * Gets the editing Range of the Ball's center x-position, in meters. This range is for when the user changes the
   * x-position of the Ball in the KeypadDialog. It uses the grid-safe constrained Bounds of the Ball to give a
   * nicer-looking Range that still guarantees that the Ball is inside the PlayArea. See
   * https://github.com/phetsims/collision-lab/issues/72
   * @public
   *
   * @param {Ball} ball
   * @returns {Range} - in meters
   */
  getKeypadXPositionRange(ball) {
    assert && assert(ball instanceof Ball, `invalid ball: ${ball}`);

    // First get the grid-safe constrained Bounds of the Ball. See getBallGridSafeConstrainedBounds() for context.
    const gridSafeConstrainedBounds = BallUtils.getBallGridSafeConstrainedBounds(ball.playArea.bounds, ball.radiusProperty.value);

    // With the getBallGridSafeConstrainedBounds() computation, there are some floating-point inaccuracies to round off.
    const minX = Utils.toFixed(gridSafeConstrainedBounds.minX, CollisionLabConstants.DISPLAY_DECIMAL_PLACES);
    const maxX = Utils.toFixed(gridSafeConstrainedBounds.maxX, CollisionLabConstants.DISPLAY_DECIMAL_PLACES);
    return new Range(minX, maxX);
  },
  /**
   * Gets the editing Range of the Ball's center y-position, in meters. This range is for when the user changes the
   * y-position of the Ball in the KeypadDialog. It uses the grid-safe constrained Bounds of the Ball to give a
   * nicer-looking Range that still guarantees that the Ball is inside the PlayArea. See
   * https://github.com/phetsims/collision-lab/issues/72
   * @public
   *
   * @param {Ball} ball
   * @returns {Range} - in meters
   */
  getKeypadYPositionRange(ball) {
    assert && assert(ball instanceof Ball, `invalid ball: ${ball}`);

    // First get the grid-safe constrained Bounds of the Ball. See getBallGridSafeConstrainedBounds() for context.
    const gridSafeConstrainedBounds = BallUtils.getBallGridSafeConstrainedBounds(ball.playArea.bounds, ball.radiusProperty.value);

    // With the getBallGridSafeConstrainedBounds() computation, there are some floating-point inaccuracies to round off.
    const minY = Utils.toFixed(gridSafeConstrainedBounds.minY, CollisionLabConstants.DISPLAY_DECIMAL_PLACES);
    const maxY = Utils.toFixed(gridSafeConstrainedBounds.maxY, CollisionLabConstants.DISPLAY_DECIMAL_PLACES);
    return new Range(minY, maxY);
  },
  /**
   * Returns a boolean that indicates if the passed-in Balls are physically overlapping.
   * @public
   *
   * @param {Ball} ball1
   * @param {Ball} ball2
   * @returns {boolean}
   */
  areBallsOverlapping(ball1, ball2) {
    assert && assert(ball1 instanceof Ball, `invalid ball1: ${ball1}`);
    assert && assert(ball2 instanceof Ball, `invalid ball2: ${ball2}`);
    assert && assert(ball1 !== ball2, 'ball cannot overlap with itself');

    // Use a distance approach to detect if the Balls are physically overlapping.
    const distanceBetweenBalls = ball1.positionProperty.value.distance(ball2.positionProperty.value);
    const distanceThreshold = ball1.radiusProperty.value + ball2.radiusProperty.value;

    // If the distance between the Balls is less the sum of the radii, they are overlapping. For the 'collision lab'
    // simulation, if the distance between the Balls is exactly equal to the sum of their radii, which would mean that
    // the Balls are tangent to each other, they are NOT overlapping. This is mainly due to Balls after inelastic
    // collisions that are exactly next to each other but not necessarily colliding.
    return distanceBetweenBalls < distanceThreshold;
  },
  /**
   * Gets the closest Ball in the system that is overlapping with the passed-in Ball. If the passed-in Ball isn't
   * overlapping with any of the other Balls in the system, undefined is returned.
   * @public
   *
   * @param {Ball} ball
   * @param {ObservableArrayDef.<Ball>} balls - all the balls in the system
   * @returns {Ball|undefined}
   */
  getClosestOverlappingBall(ball, balls) {
    assert && assert(ball instanceof Ball, `invalid ball: ${ball}`);
    assert && assert(Array.isArray(balls)) && AssertUtils.assertArrayOf(balls, Ball);
    assert && assert(balls.includes(ball));

    // Filter the Balls array to get the Balls that are overlapping with the passed-in Ball.
    const overlappingBalls = balls.filter(otherBall => {
      return otherBall !== ball && BallUtils.areBallsOverlapping(ball, otherBall);
    });

    // Get the closest overlappingBall, which has the smallest distance to the passed-in Ball.
    return _.minBy(overlappingBalls, overlappingBall => ball.positionProperty.value.distance(overlappingBall.positionProperty.value));
  },
  /**
   * Moves the position of ball1 exactly next to ball2 in a given direction. Used for 'bumping' balls. See
   * https://github.com/phetsims/collision-lab/issues/100 for context.
   *
   * This method uses the directionVector, which is the vector from the center of the ball2 that points in the
   * direction of where to set ball1's position. Note that ball2's position is not mutated. The directionVector is
   * copied and its magnitude is set to the sum of the radii of ball1 and ball2 so that ball1 is adjacent to ball2.
   *
   * @public
   * @param {Ball} ball1 - Position is set.
   * @param {Ball} ball2 - Position not set.
   * @param {Vector2} directionVector - the vector from the center of the ball2 that points in the direction
   *                                    of where to set ball1's position. Won't be mutated.
   */
  moveBallNextToBall(ball1, ball2, directionVector) {
    assert && assert(ball1 instanceof Ball, `invalid ball1: ${ball1}`);
    assert && assert(ball2 instanceof Ball, `invalid ball2: ${ball2}`);
    assert && assert(directionVector instanceof Vector2, `invalid directionVector: ${directionVector}`);

    // Set the directionVector's magnitude to the sum of the radii of ball1 and ball2.
    // The ZERO_THRESHOLD is also added to add a infinitesimally small separation between the Balls.
    const scaledDirectionVector = directionVector.withMagnitude(ball2.radiusProperty.value + ball1.radiusProperty.value + CollisionLabConstants.ZERO_THRESHOLD);

    // Set ball1's position, which is the center of ball2 plus the scaledDirectionVector.
    ball1.positionProperty.value = scaledDirectionVector.add(ball2.positionProperty.value);

    // Sanity check to ensure that the Balls are adjacent to each other.
    assert && assert(!BallUtils.areBallsOverlapping(ball1, ball2));
  },
  /**
   * Gets the total Kinetic Energy of a collection of Balls. See https://en.wikipedia.org/wiki/Kinetic_energy.
   * @public
   *
   * @param {ObservableArrayDef.<Ball>} balls
   * @returns {number} - in Joules.
   */
  getTotalKineticEnergy(balls) {
    assert && assert(Array.isArray(balls)) && AssertUtils.assertArrayOf(balls, Ball);
    let totalKineticEnergy = 0;
    balls.forEach(ball => {
      // See See https://en.wikipedia.org/wiki/Kinetic_energy.
      totalKineticEnergy += 0.5 * ball.massProperty.value * ball.velocityProperty.value.magnitudeSquared; // K = 1/2*m*|v|^2
    });

    return totalKineticEnergy;
  }
};
collisionLab.register('BallUtils', BallUtils);
export default BallUtils;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiUmFuZ2UiLCJVdGlscyIsIlZlY3RvcjIiLCJBc3NlcnRVdGlscyIsImNvbGxpc2lvbkxhYiIsIkNvbGxpc2lvbkxhYkNvbnN0YW50cyIsIkNvbGxpc2lvbkxhYlV0aWxzIiwiQmFsbCIsIkJhbGxVdGlscyIsImNhbGN1bGF0ZUJhbGxSYWRpdXMiLCJtYXNzIiwiaXNDb25zdGFudFNpemUiLCJhc3NlcnQiLCJCQUxMX0NPTlNUQU5UX1JBRElVUyIsIkJBTExfREVGQVVMVF9ERU5TSVRZIiwiTWF0aCIsIlBJIiwiZ2V0QmFsbEdyaWRTYWZlQ29uc3RyYWluZWRCb3VuZHMiLCJwbGF5QXJlYUJvdW5kcyIsInJhZGl1cyIsImdyaWRMaW5lU3BhY2luZyIsIk1JTk9SX0dSSURMSU5FX1NQQUNJTkciLCJjb25zdHJhaW5lZEJvdW5kcyIsImVyb2RlZCIsInJvdW5kQm91bmRzSW5Ub05lYXJlc3QiLCJnZXRLZXlwYWRYUG9zaXRpb25SYW5nZSIsImJhbGwiLCJncmlkU2FmZUNvbnN0cmFpbmVkQm91bmRzIiwicGxheUFyZWEiLCJib3VuZHMiLCJyYWRpdXNQcm9wZXJ0eSIsInZhbHVlIiwibWluWCIsInRvRml4ZWQiLCJESVNQTEFZX0RFQ0lNQUxfUExBQ0VTIiwibWF4WCIsImdldEtleXBhZFlQb3NpdGlvblJhbmdlIiwibWluWSIsIm1heFkiLCJhcmVCYWxsc092ZXJsYXBwaW5nIiwiYmFsbDEiLCJiYWxsMiIsImRpc3RhbmNlQmV0d2VlbkJhbGxzIiwicG9zaXRpb25Qcm9wZXJ0eSIsImRpc3RhbmNlIiwiZGlzdGFuY2VUaHJlc2hvbGQiLCJnZXRDbG9zZXN0T3ZlcmxhcHBpbmdCYWxsIiwiYmFsbHMiLCJBcnJheSIsImlzQXJyYXkiLCJhc3NlcnRBcnJheU9mIiwiaW5jbHVkZXMiLCJvdmVybGFwcGluZ0JhbGxzIiwiZmlsdGVyIiwib3RoZXJCYWxsIiwiXyIsIm1pbkJ5Iiwib3ZlcmxhcHBpbmdCYWxsIiwibW92ZUJhbGxOZXh0VG9CYWxsIiwiZGlyZWN0aW9uVmVjdG9yIiwic2NhbGVkRGlyZWN0aW9uVmVjdG9yIiwid2l0aE1hZ25pdHVkZSIsIlpFUk9fVEhSRVNIT0xEIiwiYWRkIiwiZ2V0VG90YWxLaW5ldGljRW5lcmd5IiwidG90YWxLaW5ldGljRW5lcmd5IiwiZm9yRWFjaCIsIm1hc3NQcm9wZXJ0eSIsInZlbG9jaXR5UHJvcGVydHkiLCJtYWduaXR1ZGVTcXVhcmVkIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJCYWxsVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEJhbGxVdGlscyBpcyBhIGNvbGxlY3Rpb24gb2YgdXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBhcmUgcmVsYXRlZCB0byBCYWxscy5cclxuICpcclxuICogQGF1dGhvciBCcmFuZG9uIExpXHJcbiAqL1xyXG5cclxuaW1wb3J0IEJvdW5kczIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL0JvdW5kczIuanMnO1xyXG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1JhbmdlLmpzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IEFzc2VydFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL3BoZXRjb21tb24vanMvQXNzZXJ0VXRpbHMuanMnO1xyXG5pbXBvcnQgY29sbGlzaW9uTGFiIGZyb20gJy4uLy4uL2NvbGxpc2lvbkxhYi5qcyc7XHJcbmltcG9ydCBDb2xsaXNpb25MYWJDb25zdGFudHMgZnJvbSAnLi4vQ29sbGlzaW9uTGFiQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IENvbGxpc2lvbkxhYlV0aWxzIGZyb20gJy4uL0NvbGxpc2lvbkxhYlV0aWxzLmpzJztcclxuaW1wb3J0IEJhbGwgZnJvbSAnLi9CYWxsLmpzJztcclxuXHJcbmNvbnN0IEJhbGxVdGlscyA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgcmFkaXVzIG9mIGEgQmFsbC4gSWYgdGhlICdDb25zdGFudCBTaXplJyBjaGVja2JveCBpcyBjaGVja2VkLCBpdCB1c2VzIHRoZSBjb25zdGFudCByYWRpdXMuXHJcbiAgICogT3RoZXJ3aXNlLCB0aGUgcmFkaXVzIGlzIGRlcml2ZWQgZnJvbSB0aGUgbWFzcyBhbmQgdGhlIHVuaWZvcm0gZGVuc2l0eSBvZiB0aGUgQmFsbC5cclxuICAgKlxyXG4gICAqIERlcml2YXRpb246XHJcbiAgICogICBWb2x1bWUgPSA0LzMgUEkgKiBSYWRpdXNeM1xyXG4gICAqICAgICA9PiBEZW5zaXR5ID0gTWFzcyAvIFZvbHVtZSA9IE1hc3MgLyAoIDQvMyBQSSAqIFJhZGl1c14zIClcclxuICAgKiAgICAgPT4gUmFkaXVzID0gKDMvNCAqIE1hc3MgLyBEZW5zaXR5IC8gUEkgKSBeIDEvM1xyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNzIC0gbWFzcyBvZiB0aGUgQmFsbCwgaW4ga2cuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0NvbnN0YW50U2l6ZSAtIGluZGljYXRlcyBpZiB0aGUgJ0NvbnN0YW50IFNpemUnIGNoZWNrYm94IGlzIGNoZWNrZWQuXHJcbiAgICogQHJldHVybnMge251bWJlcn0gLSBpbiBtZXRlcnNcclxuICAgKi9cclxuICBjYWxjdWxhdGVCYWxsUmFkaXVzKCBtYXNzLCBpc0NvbnN0YW50U2l6ZSA9IGZhbHNlICkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdHlwZW9mIG1hc3MgPT09ICdudW1iZXInLCBgaW52YWxpZCBtYXNzOiAke21hc3N9YCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdHlwZW9mIGlzQ29uc3RhbnRTaXplID09PSAnYm9vbGVhbicsIGBpbnZhbGlkIGlzQ29uc3RhbnRTaXplOiAke2lzQ29uc3RhbnRTaXplfWAgKTtcclxuXHJcbiAgICByZXR1cm4gaXNDb25zdGFudFNpemUgP1xyXG4gICAgICAgICAgIENvbGxpc2lvbkxhYkNvbnN0YW50cy5CQUxMX0NPTlNUQU5UX1JBRElVUyA6XHJcbiAgICAgICAgICAgKCAzIC8gNCAqIG1hc3MgLyBDb2xsaXNpb25MYWJDb25zdGFudHMuQkFMTF9ERUZBVUxUX0RFTlNJVFkgLyBNYXRoLlBJICkgKiogKCAxIC8gMyApO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGVzIHRoZSBCb3VuZHMgb2YgdGhlIGNlbnRlci1wb3NpdGlvbiBvZiB0aGUgQmFsbCB0aGF0IHNhdGlzZmllcyB0aGUgZm9sbG93aW5nIGludmFyaWFudHM6XHJcbiAgICogICAoMSkgVGhlIEJvdW5kcyBvZiB0aGUgUGxheUFyZWEgaXMgZXJvZGVkIGlud2FyZHMgc3VjaCB0aGF0IHRoZSBCYWxsIGlzIGZ1bGx5IGluc2lkZSB0aGUgUGxheUFyZWEgYm91bmRzLlxyXG4gICAqICAgKDIpIFRoZSBlZGdlIG9mIHRoZSBCb3VuZHMgaXMgZXJvZGVkIGlud2FyZHMgZnVydGhlciBzbyB0aGF0IGl0IGlzIG9uIGFuIGV4YWN0IGdyaWQtbGluZS5cclxuICAgKlxyXG4gICAqIFRoaXMgQm91bmRzIGlzIHVzZWQgd2hlbiB0aGUgQmFsbCBpcyBkcmFnZ2VkIHdpdGggdGhlIGdyaWQgdmlzaWJsZSB0byBlbnN1cmUgdGhhdCB0aGUgQmFsbCBpc24ndCBzbmFwcGVkIHRvIGFcclxuICAgKiBncmlkLWxpbmUgdGhhdCBtYWtlcyBwYXJ0IG9mIHRoZSBCYWxsIG91dCBvZiBCb3VuZHMuIEFsc28gdXNlZCBmb3IgcG9zaXRpb24gcmFuZ2VzIGluIHRoZSBLZXlwYWQuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtCb3VuZHMyfSBwbGF5QXJlYUJvdW5kcyAtIHRoZSBib3VuZHMgb2YgdGhlIFBsYXlBcmVhLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSB0aGUgcmFkaXVzIG9mIHRoZSBCYWxsLCBpbiBtZXRlcnMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtncmlkTGluZVNwYWNpbmddIC0gc3BhY2luZyBiZXR3ZWVuIGdyaWQtbGluZXMsIGluIG1ldGVycy5cclxuICAgKiBAcmV0dXJucyB7Qm91bmRzMn1cclxuICAgKi9cclxuICBnZXRCYWxsR3JpZFNhZmVDb25zdHJhaW5lZEJvdW5kcyggcGxheUFyZWFCb3VuZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZExpbmVTcGFjaW5nID0gQ29sbGlzaW9uTGFiQ29uc3RhbnRzLk1JTk9SX0dSSURMSU5FX1NQQUNJTkcgKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwbGF5QXJlYUJvdW5kcyBpbnN0YW5jZW9mIEJvdW5kczIsIGBpbnZhbGlkIHBsYXlBcmVhQm91bmRzOiAke3BsYXlBcmVhQm91bmRzfWAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiByYWRpdXMgPT09ICdudW1iZXInICYmIHJhZGl1cyA+IDAsIGBpbnZhbGlkIHJhZGl1czogJHtyYWRpdXN9YCApO1xyXG5cclxuICAgIC8vIEZpcnN0IGdldCB0aGUgY29uc3RyYWluZWRCb3VuZHMsIHdoaWNoIGlzIHRoZSBCb3VuZHMgdGhhdCBlbnN1cmVzIHRoZSBCYWxsIGlzIGNvbXBsZXRlbHkgaW5zaWRlIHRoZSBQbGF5QXJlYS4gSXRcclxuICAgIC8vIGlzIGVyb2RlZCBieSB0aGUgcmFkaXVzIG9mIHRoZSBiYWxsIHNpbmNlIHRoZSBCb3VuZHMgaXMgdGhlIGJvdW5kaW5nLWJveCBvZiB0aGUgY2VudGVyIG9mIHRoZSBCYWxsLlxyXG4gICAgY29uc3QgY29uc3RyYWluZWRCb3VuZHMgPSBwbGF5QXJlYUJvdW5kcy5lcm9kZWQoIHJhZGl1cyApO1xyXG5cclxuICAgIC8vIFJvdW5kIHRoZSBjb25zdHJhaW5lZEJvdW5kcyBpbndhcmRzIHRvIHRoZSBuZWFyZXN0IGdyaWQtbGluZSB0byBlbnN1cmUgdGhhdCB0aGUgQmFsbCdzIGNlbnRlci1wb3NpdGlvbiBpcyBib3VuZGVkXHJcbiAgICAvLyBvbiBhbiBleGFjdCBncmlkLWxpbmUgQU5EIGlzIGZ1bGx5IGluc2lkZSB0aGUgUGxheUFyZWEuXHJcbiAgICByZXR1cm4gQ29sbGlzaW9uTGFiVXRpbHMucm91bmRCb3VuZHNJblRvTmVhcmVzdCggY29uc3RyYWluZWRCb3VuZHMsIGdyaWRMaW5lU3BhY2luZyApO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGVkaXRpbmcgUmFuZ2Ugb2YgdGhlIEJhbGwncyBjZW50ZXIgeC1wb3NpdGlvbiwgaW4gbWV0ZXJzLiBUaGlzIHJhbmdlIGlzIGZvciB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlXHJcbiAgICogeC1wb3NpdGlvbiBvZiB0aGUgQmFsbCBpbiB0aGUgS2V5cGFkRGlhbG9nLiBJdCB1c2VzIHRoZSBncmlkLXNhZmUgY29uc3RyYWluZWQgQm91bmRzIG9mIHRoZSBCYWxsIHRvIGdpdmUgYVxyXG4gICAqIG5pY2VyLWxvb2tpbmcgUmFuZ2UgdGhhdCBzdGlsbCBndWFyYW50ZWVzIHRoYXQgdGhlIEJhbGwgaXMgaW5zaWRlIHRoZSBQbGF5QXJlYS4gU2VlXHJcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NvbGxpc2lvbi1sYWIvaXNzdWVzLzcyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCYWxsfSBiYWxsXHJcbiAgICogQHJldHVybnMge1JhbmdlfSAtIGluIG1ldGVyc1xyXG4gICAqL1xyXG4gIGdldEtleXBhZFhQb3NpdGlvblJhbmdlKCBiYWxsICkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggYmFsbCBpbnN0YW5jZW9mIEJhbGwsIGBpbnZhbGlkIGJhbGw6ICR7YmFsbH1gICk7XHJcblxyXG4gICAgLy8gRmlyc3QgZ2V0IHRoZSBncmlkLXNhZmUgY29uc3RyYWluZWQgQm91bmRzIG9mIHRoZSBCYWxsLiBTZWUgZ2V0QmFsbEdyaWRTYWZlQ29uc3RyYWluZWRCb3VuZHMoKSBmb3IgY29udGV4dC5cclxuICAgIGNvbnN0IGdyaWRTYWZlQ29uc3RyYWluZWRCb3VuZHMgPSBCYWxsVXRpbHMuZ2V0QmFsbEdyaWRTYWZlQ29uc3RyYWluZWRCb3VuZHMoIGJhbGwucGxheUFyZWEuYm91bmRzLCBiYWxsLnJhZGl1c1Byb3BlcnR5LnZhbHVlICk7XHJcblxyXG4gICAgLy8gV2l0aCB0aGUgZ2V0QmFsbEdyaWRTYWZlQ29uc3RyYWluZWRCb3VuZHMoKSBjb21wdXRhdGlvbiwgdGhlcmUgYXJlIHNvbWUgZmxvYXRpbmctcG9pbnQgaW5hY2N1cmFjaWVzIHRvIHJvdW5kIG9mZi5cclxuICAgIGNvbnN0IG1pblggPSBVdGlscy50b0ZpeGVkKCBncmlkU2FmZUNvbnN0cmFpbmVkQm91bmRzLm1pblgsIENvbGxpc2lvbkxhYkNvbnN0YW50cy5ESVNQTEFZX0RFQ0lNQUxfUExBQ0VTICk7XHJcbiAgICBjb25zdCBtYXhYID0gVXRpbHMudG9GaXhlZCggZ3JpZFNhZmVDb25zdHJhaW5lZEJvdW5kcy5tYXhYLCBDb2xsaXNpb25MYWJDb25zdGFudHMuRElTUExBWV9ERUNJTUFMX1BMQUNFUyApO1xyXG5cclxuICAgIHJldHVybiBuZXcgUmFuZ2UoIG1pblgsIG1heFggKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBlZGl0aW5nIFJhbmdlIG9mIHRoZSBCYWxsJ3MgY2VudGVyIHktcG9zaXRpb24sIGluIG1ldGVycy4gVGhpcyByYW5nZSBpcyBmb3Igd2hlbiB0aGUgdXNlciBjaGFuZ2VzIHRoZVxyXG4gICAqIHktcG9zaXRpb24gb2YgdGhlIEJhbGwgaW4gdGhlIEtleXBhZERpYWxvZy4gSXQgdXNlcyB0aGUgZ3JpZC1zYWZlIGNvbnN0cmFpbmVkIEJvdW5kcyBvZiB0aGUgQmFsbCB0byBnaXZlIGFcclxuICAgKiBuaWNlci1sb29raW5nIFJhbmdlIHRoYXQgc3RpbGwgZ3VhcmFudGVlcyB0aGF0IHRoZSBCYWxsIGlzIGluc2lkZSB0aGUgUGxheUFyZWEuIFNlZVxyXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jb2xsaXNpb24tbGFiL2lzc3Vlcy83MlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QmFsbH0gYmFsbFxyXG4gICAqIEByZXR1cm5zIHtSYW5nZX0gLSBpbiBtZXRlcnNcclxuICAgKi9cclxuICBnZXRLZXlwYWRZUG9zaXRpb25SYW5nZSggYmFsbCApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGJhbGwgaW5zdGFuY2VvZiBCYWxsLCBgaW52YWxpZCBiYWxsOiAke2JhbGx9YCApO1xyXG5cclxuICAgIC8vIEZpcnN0IGdldCB0aGUgZ3JpZC1zYWZlIGNvbnN0cmFpbmVkIEJvdW5kcyBvZiB0aGUgQmFsbC4gU2VlIGdldEJhbGxHcmlkU2FmZUNvbnN0cmFpbmVkQm91bmRzKCkgZm9yIGNvbnRleHQuXHJcbiAgICBjb25zdCBncmlkU2FmZUNvbnN0cmFpbmVkQm91bmRzID0gQmFsbFV0aWxzLmdldEJhbGxHcmlkU2FmZUNvbnN0cmFpbmVkQm91bmRzKCBiYWxsLnBsYXlBcmVhLmJvdW5kcywgYmFsbC5yYWRpdXNQcm9wZXJ0eS52YWx1ZSApO1xyXG5cclxuICAgIC8vIFdpdGggdGhlIGdldEJhbGxHcmlkU2FmZUNvbnN0cmFpbmVkQm91bmRzKCkgY29tcHV0YXRpb24sIHRoZXJlIGFyZSBzb21lIGZsb2F0aW5nLXBvaW50IGluYWNjdXJhY2llcyB0byByb3VuZCBvZmYuXHJcbiAgICBjb25zdCBtaW5ZID0gVXRpbHMudG9GaXhlZCggZ3JpZFNhZmVDb25zdHJhaW5lZEJvdW5kcy5taW5ZLCBDb2xsaXNpb25MYWJDb25zdGFudHMuRElTUExBWV9ERUNJTUFMX1BMQUNFUyApO1xyXG4gICAgY29uc3QgbWF4WSA9IFV0aWxzLnRvRml4ZWQoIGdyaWRTYWZlQ29uc3RyYWluZWRCb3VuZHMubWF4WSwgQ29sbGlzaW9uTGFiQ29uc3RhbnRzLkRJU1BMQVlfREVDSU1BTF9QTEFDRVMgKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFJhbmdlKCBtaW5ZLCBtYXhZICk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIHBhc3NlZC1pbiBCYWxscyBhcmUgcGh5c2ljYWxseSBvdmVybGFwcGluZy5cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0JhbGx9IGJhbGwxXHJcbiAgICogQHBhcmFtIHtCYWxsfSBiYWxsMlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGFyZUJhbGxzT3ZlcmxhcHBpbmcoIGJhbGwxLCBiYWxsMiApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGJhbGwxIGluc3RhbmNlb2YgQmFsbCwgYGludmFsaWQgYmFsbDE6ICR7YmFsbDF9YCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggYmFsbDIgaW5zdGFuY2VvZiBCYWxsLCBgaW52YWxpZCBiYWxsMjogJHtiYWxsMn1gICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBiYWxsMSAhPT0gYmFsbDIsICdiYWxsIGNhbm5vdCBvdmVybGFwIHdpdGggaXRzZWxmJyApO1xyXG5cclxuICAgIC8vIFVzZSBhIGRpc3RhbmNlIGFwcHJvYWNoIHRvIGRldGVjdCBpZiB0aGUgQmFsbHMgYXJlIHBoeXNpY2FsbHkgb3ZlcmxhcHBpbmcuXHJcbiAgICBjb25zdCBkaXN0YW5jZUJldHdlZW5CYWxscyA9IGJhbGwxLnBvc2l0aW9uUHJvcGVydHkudmFsdWUuZGlzdGFuY2UoIGJhbGwyLnBvc2l0aW9uUHJvcGVydHkudmFsdWUgKTtcclxuICAgIGNvbnN0IGRpc3RhbmNlVGhyZXNob2xkID0gYmFsbDEucmFkaXVzUHJvcGVydHkudmFsdWUgKyBiYWxsMi5yYWRpdXNQcm9wZXJ0eS52YWx1ZTtcclxuXHJcbiAgICAvLyBJZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgQmFsbHMgaXMgbGVzcyB0aGUgc3VtIG9mIHRoZSByYWRpaSwgdGhleSBhcmUgb3ZlcmxhcHBpbmcuIEZvciB0aGUgJ2NvbGxpc2lvbiBsYWInXHJcbiAgICAvLyBzaW11bGF0aW9uLCBpZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgQmFsbHMgaXMgZXhhY3RseSBlcXVhbCB0byB0aGUgc3VtIG9mIHRoZWlyIHJhZGlpLCB3aGljaCB3b3VsZCBtZWFuIHRoYXRcclxuICAgIC8vIHRoZSBCYWxscyBhcmUgdGFuZ2VudCB0byBlYWNoIG90aGVyLCB0aGV5IGFyZSBOT1Qgb3ZlcmxhcHBpbmcuIFRoaXMgaXMgbWFpbmx5IGR1ZSB0byBCYWxscyBhZnRlciBpbmVsYXN0aWNcclxuICAgIC8vIGNvbGxpc2lvbnMgdGhhdCBhcmUgZXhhY3RseSBuZXh0IHRvIGVhY2ggb3RoZXIgYnV0IG5vdCBuZWNlc3NhcmlseSBjb2xsaWRpbmcuXHJcbiAgICByZXR1cm4gZGlzdGFuY2VCZXR3ZWVuQmFsbHMgPCBkaXN0YW5jZVRocmVzaG9sZDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBjbG9zZXN0IEJhbGwgaW4gdGhlIHN5c3RlbSB0aGF0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHBhc3NlZC1pbiBCYWxsLiBJZiB0aGUgcGFzc2VkLWluIEJhbGwgaXNuJ3RcclxuICAgKiBvdmVybGFwcGluZyB3aXRoIGFueSBvZiB0aGUgb3RoZXIgQmFsbHMgaW4gdGhlIHN5c3RlbSwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QmFsbH0gYmFsbFxyXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZUFycmF5RGVmLjxCYWxsPn0gYmFsbHMgLSBhbGwgdGhlIGJhbGxzIGluIHRoZSBzeXN0ZW1cclxuICAgKiBAcmV0dXJucyB7QmFsbHx1bmRlZmluZWR9XHJcbiAgICovXHJcbiAgZ2V0Q2xvc2VzdE92ZXJsYXBwaW5nQmFsbCggYmFsbCwgYmFsbHMgKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBiYWxsIGluc3RhbmNlb2YgQmFsbCwgYGludmFsaWQgYmFsbDogJHtiYWxsfWAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIEFycmF5LmlzQXJyYXkoIGJhbGxzICkgKSAmJiBBc3NlcnRVdGlscy5hc3NlcnRBcnJheU9mKCBiYWxscywgQmFsbCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggYmFsbHMuaW5jbHVkZXMoIGJhbGwgKSApO1xyXG5cclxuICAgIC8vIEZpbHRlciB0aGUgQmFsbHMgYXJyYXkgdG8gZ2V0IHRoZSBCYWxscyB0aGF0IGFyZSBvdmVybGFwcGluZyB3aXRoIHRoZSBwYXNzZWQtaW4gQmFsbC5cclxuICAgIGNvbnN0IG92ZXJsYXBwaW5nQmFsbHMgPSBiYWxscy5maWx0ZXIoIG90aGVyQmFsbCA9PiB7XHJcbiAgICAgIHJldHVybiBvdGhlckJhbGwgIT09IGJhbGwgJiYgQmFsbFV0aWxzLmFyZUJhbGxzT3ZlcmxhcHBpbmcoIGJhbGwsIG90aGVyQmFsbCApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIEdldCB0aGUgY2xvc2VzdCBvdmVybGFwcGluZ0JhbGwsIHdoaWNoIGhhcyB0aGUgc21hbGxlc3QgZGlzdGFuY2UgdG8gdGhlIHBhc3NlZC1pbiBCYWxsLlxyXG4gICAgcmV0dXJuIF8ubWluQnkoIG92ZXJsYXBwaW5nQmFsbHMsIG92ZXJsYXBwaW5nQmFsbCA9PiBiYWxsLnBvc2l0aW9uUHJvcGVydHkudmFsdWUuZGlzdGFuY2UoIG92ZXJsYXBwaW5nQmFsbC5wb3NpdGlvblByb3BlcnR5LnZhbHVlICkgKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBNb3ZlcyB0aGUgcG9zaXRpb24gb2YgYmFsbDEgZXhhY3RseSBuZXh0IHRvIGJhbGwyIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLiBVc2VkIGZvciAnYnVtcGluZycgYmFsbHMuIFNlZVxyXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jb2xsaXNpb24tbGFiL2lzc3Vlcy8xMDAgZm9yIGNvbnRleHQuXHJcbiAgICpcclxuICAgKiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBkaXJlY3Rpb25WZWN0b3IsIHdoaWNoIGlzIHRoZSB2ZWN0b3IgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBiYWxsMiB0aGF0IHBvaW50cyBpbiB0aGVcclxuICAgKiBkaXJlY3Rpb24gb2Ygd2hlcmUgdG8gc2V0IGJhbGwxJ3MgcG9zaXRpb24uIE5vdGUgdGhhdCBiYWxsMidzIHBvc2l0aW9uIGlzIG5vdCBtdXRhdGVkLiBUaGUgZGlyZWN0aW9uVmVjdG9yIGlzXHJcbiAgICogY29waWVkIGFuZCBpdHMgbWFnbml0dWRlIGlzIHNldCB0byB0aGUgc3VtIG9mIHRoZSByYWRpaSBvZiBiYWxsMSBhbmQgYmFsbDIgc28gdGhhdCBiYWxsMSBpcyBhZGphY2VudCB0byBiYWxsMi5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0JhbGx9IGJhbGwxIC0gUG9zaXRpb24gaXMgc2V0LlxyXG4gICAqIEBwYXJhbSB7QmFsbH0gYmFsbDIgLSBQb3NpdGlvbiBub3Qgc2V0LlxyXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gZGlyZWN0aW9uVmVjdG9yIC0gdGhlIHZlY3RvciBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGJhbGwyIHRoYXQgcG9pbnRzIGluIHRoZSBkaXJlY3Rpb25cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHdoZXJlIHRvIHNldCBiYWxsMSdzIHBvc2l0aW9uLiBXb24ndCBiZSBtdXRhdGVkLlxyXG4gICAqL1xyXG4gIG1vdmVCYWxsTmV4dFRvQmFsbCggYmFsbDEsIGJhbGwyLCBkaXJlY3Rpb25WZWN0b3IgKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBiYWxsMSBpbnN0YW5jZW9mIEJhbGwsIGBpbnZhbGlkIGJhbGwxOiAke2JhbGwxfWAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGJhbGwyIGluc3RhbmNlb2YgQmFsbCwgYGludmFsaWQgYmFsbDI6ICR7YmFsbDJ9YCApO1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggZGlyZWN0aW9uVmVjdG9yIGluc3RhbmNlb2YgVmVjdG9yMiwgYGludmFsaWQgZGlyZWN0aW9uVmVjdG9yOiAke2RpcmVjdGlvblZlY3Rvcn1gICk7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBkaXJlY3Rpb25WZWN0b3IncyBtYWduaXR1ZGUgdG8gdGhlIHN1bSBvZiB0aGUgcmFkaWkgb2YgYmFsbDEgYW5kIGJhbGwyLlxyXG4gICAgLy8gVGhlIFpFUk9fVEhSRVNIT0xEIGlzIGFsc28gYWRkZWQgdG8gYWRkIGEgaW5maW5pdGVzaW1hbGx5IHNtYWxsIHNlcGFyYXRpb24gYmV0d2VlbiB0aGUgQmFsbHMuXHJcbiAgICBjb25zdCBzY2FsZWREaXJlY3Rpb25WZWN0b3IgPSBkaXJlY3Rpb25WZWN0b3Iud2l0aE1hZ25pdHVkZSggYmFsbDIucmFkaXVzUHJvcGVydHkudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGJhbGwxLnJhZGl1c1Byb3BlcnR5LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBDb2xsaXNpb25MYWJDb25zdGFudHMuWkVST19USFJFU0hPTEQgKTtcclxuXHJcbiAgICAvLyBTZXQgYmFsbDEncyBwb3NpdGlvbiwgd2hpY2ggaXMgdGhlIGNlbnRlciBvZiBiYWxsMiBwbHVzIHRoZSBzY2FsZWREaXJlY3Rpb25WZWN0b3IuXHJcbiAgICBiYWxsMS5wb3NpdGlvblByb3BlcnR5LnZhbHVlID0gc2NhbGVkRGlyZWN0aW9uVmVjdG9yLmFkZCggYmFsbDIucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZSApO1xyXG5cclxuICAgIC8vIFNhbml0eSBjaGVjayB0byBlbnN1cmUgdGhhdCB0aGUgQmFsbHMgYXJlIGFkamFjZW50IHRvIGVhY2ggb3RoZXIuXHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhQmFsbFV0aWxzLmFyZUJhbGxzT3ZlcmxhcHBpbmcoIGJhbGwxLCBiYWxsMiApICk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgdG90YWwgS2luZXRpYyBFbmVyZ3kgb2YgYSBjb2xsZWN0aW9uIG9mIEJhbGxzLiBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2luZXRpY19lbmVyZ3kuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlQXJyYXlEZWYuPEJhbGw+fSBiYWxsc1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gaW4gSm91bGVzLlxyXG4gICAqL1xyXG4gIGdldFRvdGFsS2luZXRpY0VuZXJneSggYmFsbHMgKSB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBBcnJheS5pc0FycmF5KCBiYWxscyApICkgJiYgQXNzZXJ0VXRpbHMuYXNzZXJ0QXJyYXlPZiggYmFsbHMsIEJhbGwgKTtcclxuXHJcbiAgICBsZXQgdG90YWxLaW5ldGljRW5lcmd5ID0gMDtcclxuICAgIGJhbGxzLmZvckVhY2goIGJhbGwgPT4ge1xyXG5cclxuICAgICAgLy8gU2VlIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LaW5ldGljX2VuZXJneS5cclxuICAgICAgdG90YWxLaW5ldGljRW5lcmd5ICs9IDAuNSAqIGJhbGwubWFzc1Byb3BlcnR5LnZhbHVlICogYmFsbC52ZWxvY2l0eVByb3BlcnR5LnZhbHVlLm1hZ25pdHVkZVNxdWFyZWQ7IC8vIEsgPSAxLzIqbSp8dnxeMlxyXG4gICAgfSApO1xyXG4gICAgcmV0dXJuIHRvdGFsS2luZXRpY0VuZXJneTtcclxuICB9XHJcbn07XHJcblxyXG5jb2xsaXNpb25MYWIucmVnaXN0ZXIoICdCYWxsVXRpbHMnLCBCYWxsVXRpbHMgKTtcclxuZXhwb3J0IGRlZmF1bHQgQmFsbFV0aWxzOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLEtBQUssTUFBTSw2QkFBNkI7QUFDL0MsT0FBT0MsS0FBSyxNQUFNLDZCQUE2QjtBQUMvQyxPQUFPQyxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLFdBQVcsTUFBTSwwQ0FBMEM7QUFDbEUsT0FBT0MsWUFBWSxNQUFNLHVCQUF1QjtBQUNoRCxPQUFPQyxxQkFBcUIsTUFBTSw2QkFBNkI7QUFDL0QsT0FBT0MsaUJBQWlCLE1BQU0seUJBQXlCO0FBQ3ZELE9BQU9DLElBQUksTUFBTSxXQUFXO0FBRTVCLE1BQU1DLFNBQVMsR0FBRztFQUVoQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VDLG1CQUFtQkEsQ0FBRUMsSUFBSSxFQUFFQyxjQUFjLEdBQUcsS0FBSyxFQUFHO0lBQ2xEQyxNQUFNLElBQUlBLE1BQU0sQ0FBRSxPQUFPRixJQUFJLEtBQUssUUFBUSxFQUFHLGlCQUFnQkEsSUFBSyxFQUFFLENBQUM7SUFDckVFLE1BQU0sSUFBSUEsTUFBTSxDQUFFLE9BQU9ELGNBQWMsS0FBSyxTQUFTLEVBQUcsMkJBQTBCQSxjQUFlLEVBQUUsQ0FBQztJQUVwRyxPQUFPQSxjQUFjLEdBQ2ROLHFCQUFxQixDQUFDUSxvQkFBb0IsR0FDMUMsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHSCxJQUFJLEdBQUdMLHFCQUFxQixDQUFDUyxvQkFBb0IsR0FBR0MsSUFBSSxDQUFDQyxFQUFFLE1BQVEsQ0FBQyxHQUFHLENBQUMsQ0FBRTtFQUM3RixDQUFDO0VBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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