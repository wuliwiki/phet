// Copyright 2020, University of Colorado Boulder

/**
 * RotatingBallCluster is a data structure that represents a 'stuck' cluster of Balls, where each ball is rotating
 * around the center-of-mass of the cluster of Balls. As of now, there are no ball-to-cluster collisions, meaning
 * RotatingBallClusters are immutable (balls can't be added).
 *
 * Perfectly inelastic collisions that 'stick' are a new feature of the HTML5 version of the simulation. They happen
 * only for the 'Inelastic' screen. When a 'sticky' collision between balls occurs, InelasticCollisionEngine will
 * dynamically create a RotatingBallCluster instance, holding onto the balls involved in the rotation, the angular
 * velocity of the rotation, and the center of mass of the cluster.
 *
 * RotatingBallCluster is also responsible for 'stepping' (rotating) the position/velocity of the Balls on each
 * time-step. It is implemented by changing reference frames to the center of mass and applying the standard
 * uniform circular motion equations to compute the new velocity and position of each Ball. See:
 *   + https://en.wikipedia.org/wiki/Frame_of_reference
 *   + https://en.wikipedia.org/wiki/Circular_motion#Uniform_circular_motion
 *
 * @author Brandon Li
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import AssertUtils from '../../../../phetcommon/js/AssertUtils.js';
import collisionLab from '../../collisionLab.js';
import Ball from '../../common/model/Ball.js';
import BallState from '../../common/model/BallState.js';
import CenterOfMass from '../../common/model/CenterOfMass.js';
class RotatingBallCluster {
  /**
   * @param {Ball[]} balls - an array of the Balls within the rotating ball cluster.
   * @param {number} angularVelocity - the angular velocity of the rotation, in radians per second.
   * @param {CenterOfMass} centerOfMass - the center of mass of the cluster of balls.
   */
  constructor(balls, angularVelocity, centerOfMass) {
    assert && AssertUtils.assertArrayOf(balls, Ball);
    assert && assert(typeof angularVelocity === 'number', `invalid angularVelocity: ${angularVelocity}`);
    assert && assert(centerOfMass instanceof CenterOfMass, `invalid centerOfMass: ${centerOfMass}`);

    // @private {Ball[]} - reference to the passed-in balls.
    this.balls = balls;

    // @private {number} - reference to the passed-in angularVelocity.
    this.angularVelocity = angularVelocity;

    // @private {CenterOfMass} - reference to the passed-in centerOfMass.
    this.centerOfMass = centerOfMass;
  }

  /**
   * Gets the radius of the bounding circle of the entire RotatingBallCluster, in meters.
   * @public
   *
   * @returns {number}
   */
  getBoundingCircleRadius() {
    return Math.max(...this.balls.map(ball => ball.positionProperty.value.distance(this.centerOfMass.positionProperty.value) + ball.radiusProperty.value));
  }

  /**
   * Moves every Ball in the cluster by one time-step, 'rotating' each ball around the center-of-mass of the cluster.
   * @public
   *
   * @param {number} dt - time-delta in seconds.
   */
  step(dt) {
    assert && assert(typeof dt === 'number', `invalid dt: ${dt}`);

    // The angular displacement of each Ball relative to the center of mass.
    const changeInAngle = this.angularVelocity * dt;

    // Get the states of the Balls after the rotation occurs.
    const rotationStates = this.getSteppedRotationStates(dt);
    this.balls.forEach(ball => {
      // Set the state of each Ball.
      ball.setState(rotationStates.get(ball));

      // Rotate the balls around their centers to provide a more realistic rotation experience. See
      // https://github.com/phetsims/collision-lab/issues/87
      ball.rotationProperty.value += changeInAngle;
    });
  }

  /**
   * Creates BallStates that describe the state of each Ball after being 'rotated' for dt seconds. The position and
   * velocity of each Ball generally changes, but the mass does not. The position/velocity of each ball is calculated by
   * changing reference frames to the centerOfMass and applying standard uniform circular motion equations.
   * @public
   *
   * @param {number} dt - time-delta, in seconds.
   * @returns {Map.<Ball, BallState>} - maps Ball to a BallState instance.
   */
  getSteppedRotationStates(dt) {
    assert && assert(typeof dt === 'number', `invalid dt: ${dt}`);

    // The resulting Map that maps each Ball to a BallState instance.
    const ballToRotationStates = new Map();

    // The angular displacement of each Ball relative to the center of mass.
    const changeInAngle = this.angularVelocity * dt;

    // Compute the position/velocity of the center-of-mass **after** the rotation.
    const centerOfMassPosition = this.centerOfMass.velocityProperty.value.times(dt).add(this.centerOfMass.positionProperty.value);
    const centerOfMassVelocity = this.centerOfMass.velocityProperty.value;
    this.balls.forEach(ball => {
      // Get the position vector of the Ball, relative to the center of mass. This is a change in reference frames.
      const position = ball.positionProperty.value.minus(this.centerOfMass.positionProperty.value);

      // Rotate the position vector to apply uniform circular motion about the center of mass.
      position.rotate(changeInAngle);

      // Compute the velocity of Both balls after this step, relative to the center of mass. The velocity is the
      // cross product of the angular velocity (vector) and the position vector after the rotation. See
      // https://en.wikipedia.org/wiki/Circular_motion#Velocity.
      const velocity = new Vector2(-this.angularVelocity * position.y, this.angularVelocity * position.x);

      // Compute the position and velocity of the Balls back in the absolute reference frame, creating a BallState
      // instance to hold onto the vectors.
      const ballState = new BallState(position.add(centerOfMassPosition), velocity.add(centerOfMassVelocity), ball.massProperty.value);

      // Map each Ball to the BallState instance.
      ballToRotationStates.set(ball, ballState);
    });
    return ballToRotationStates;
  }
}
collisionLab.register('RotatingBallCluster', RotatingBallCluster);
export default RotatingBallCluster;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiQXNzZXJ0VXRpbHMiLCJjb2xsaXNpb25MYWIiLCJCYWxsIiwiQmFsbFN0YXRlIiwiQ2VudGVyT2ZNYXNzIiwiUm90YXRpbmdCYWxsQ2x1c3RlciIsImNvbnN0cnVjdG9yIiwiYmFsbHMiLCJhbmd1bGFyVmVsb2NpdHkiLCJjZW50ZXJPZk1hc3MiLCJhc3NlcnQiLCJhc3NlcnRBcnJheU9mIiwiZ2V0Qm91bmRpbmdDaXJjbGVSYWRpdXMiLCJNYXRoIiwibWF4IiwibWFwIiwiYmFsbCIsInBvc2l0aW9uUHJvcGVydHkiLCJ2YWx1ZSIsImRpc3RhbmNlIiwicmFkaXVzUHJvcGVydHkiLCJzdGVwIiwiZHQiLCJjaGFuZ2VJbkFuZ2xlIiwicm90YXRpb25TdGF0ZXMiLCJnZXRTdGVwcGVkUm90YXRpb25TdGF0ZXMiLCJmb3JFYWNoIiwic2V0U3RhdGUiLCJnZXQiLCJyb3RhdGlvblByb3BlcnR5IiwiYmFsbFRvUm90YXRpb25TdGF0ZXMiLCJNYXAiLCJjZW50ZXJPZk1hc3NQb3NpdGlvbiIsInZlbG9jaXR5UHJvcGVydHkiLCJ0aW1lcyIsImFkZCIsImNlbnRlck9mTWFzc1ZlbG9jaXR5IiwicG9zaXRpb24iLCJtaW51cyIsInJvdGF0ZSIsInZlbG9jaXR5IiwieSIsIngiLCJiYWxsU3RhdGUiLCJtYXNzUHJvcGVydHkiLCJzZXQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlJvdGF0aW5nQmFsbENsdXN0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjAsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFJvdGF0aW5nQmFsbENsdXN0ZXIgaXMgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IHJlcHJlc2VudHMgYSAnc3R1Y2snIGNsdXN0ZXIgb2YgQmFsbHMsIHdoZXJlIGVhY2ggYmFsbCBpcyByb3RhdGluZ1xyXG4gKiBhcm91bmQgdGhlIGNlbnRlci1vZi1tYXNzIG9mIHRoZSBjbHVzdGVyIG9mIEJhbGxzLiBBcyBvZiBub3csIHRoZXJlIGFyZSBubyBiYWxsLXRvLWNsdXN0ZXIgY29sbGlzaW9ucywgbWVhbmluZ1xyXG4gKiBSb3RhdGluZ0JhbGxDbHVzdGVycyBhcmUgaW1tdXRhYmxlIChiYWxscyBjYW4ndCBiZSBhZGRlZCkuXHJcbiAqXHJcbiAqIFBlcmZlY3RseSBpbmVsYXN0aWMgY29sbGlzaW9ucyB0aGF0ICdzdGljaycgYXJlIGEgbmV3IGZlYXR1cmUgb2YgdGhlIEhUTUw1IHZlcnNpb24gb2YgdGhlIHNpbXVsYXRpb24uIFRoZXkgaGFwcGVuXHJcbiAqIG9ubHkgZm9yIHRoZSAnSW5lbGFzdGljJyBzY3JlZW4uIFdoZW4gYSAnc3RpY2t5JyBjb2xsaXNpb24gYmV0d2VlbiBiYWxscyBvY2N1cnMsIEluZWxhc3RpY0NvbGxpc2lvbkVuZ2luZSB3aWxsXHJcbiAqIGR5bmFtaWNhbGx5IGNyZWF0ZSBhIFJvdGF0aW5nQmFsbENsdXN0ZXIgaW5zdGFuY2UsIGhvbGRpbmcgb250byB0aGUgYmFsbHMgaW52b2x2ZWQgaW4gdGhlIHJvdGF0aW9uLCB0aGUgYW5ndWxhclxyXG4gKiB2ZWxvY2l0eSBvZiB0aGUgcm90YXRpb24sIGFuZCB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgdGhlIGNsdXN0ZXIuXHJcbiAqXHJcbiAqIFJvdGF0aW5nQmFsbENsdXN0ZXIgaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgJ3N0ZXBwaW5nJyAocm90YXRpbmcpIHRoZSBwb3NpdGlvbi92ZWxvY2l0eSBvZiB0aGUgQmFsbHMgb24gZWFjaFxyXG4gKiB0aW1lLXN0ZXAuIEl0IGlzIGltcGxlbWVudGVkIGJ5IGNoYW5naW5nIHJlZmVyZW5jZSBmcmFtZXMgdG8gdGhlIGNlbnRlciBvZiBtYXNzIGFuZCBhcHBseWluZyB0aGUgc3RhbmRhcmRcclxuICogdW5pZm9ybSBjaXJjdWxhciBtb3Rpb24gZXF1YXRpb25zIHRvIGNvbXB1dGUgdGhlIG5ldyB2ZWxvY2l0eSBhbmQgcG9zaXRpb24gb2YgZWFjaCBCYWxsLiBTZWU6XHJcbiAqICAgKyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GcmFtZV9vZl9yZWZlcmVuY2VcclxuICogICArIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NpcmN1bGFyX21vdGlvbiNVbmlmb3JtX2NpcmN1bGFyX21vdGlvblxyXG4gKlxyXG4gKiBAYXV0aG9yIEJyYW5kb24gTGlcclxuICovXHJcblxyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBBc3NlcnRVdGlscyBmcm9tICcuLi8uLi8uLi8uLi9waGV0Y29tbW9uL2pzL0Fzc2VydFV0aWxzLmpzJztcclxuaW1wb3J0IGNvbGxpc2lvbkxhYiBmcm9tICcuLi8uLi9jb2xsaXNpb25MYWIuanMnO1xyXG5pbXBvcnQgQmFsbCBmcm9tICcuLi8uLi9jb21tb24vbW9kZWwvQmFsbC5qcyc7XHJcbmltcG9ydCBCYWxsU3RhdGUgZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL0JhbGxTdGF0ZS5qcyc7XHJcbmltcG9ydCBDZW50ZXJPZk1hc3MgZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL0NlbnRlck9mTWFzcy5qcyc7XHJcblxyXG5jbGFzcyBSb3RhdGluZ0JhbGxDbHVzdGVyIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtCYWxsW119IGJhbGxzIC0gYW4gYXJyYXkgb2YgdGhlIEJhbGxzIHdpdGhpbiB0aGUgcm90YXRpbmcgYmFsbCBjbHVzdGVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmd1bGFyVmVsb2NpdHkgLSB0aGUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgcm90YXRpb24sIGluIHJhZGlhbnMgcGVyIHNlY29uZC5cclxuICAgKiBAcGFyYW0ge0NlbnRlck9mTWFzc30gY2VudGVyT2ZNYXNzIC0gdGhlIGNlbnRlciBvZiBtYXNzIG9mIHRoZSBjbHVzdGVyIG9mIGJhbGxzLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBiYWxscywgYW5ndWxhclZlbG9jaXR5LCBjZW50ZXJPZk1hc3MgKSB7XHJcbiAgICBhc3NlcnQgJiYgQXNzZXJ0VXRpbHMuYXNzZXJ0QXJyYXlPZiggYmFsbHMsIEJhbGwgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBhbmd1bGFyVmVsb2NpdHkgPT09ICdudW1iZXInLCBgaW52YWxpZCBhbmd1bGFyVmVsb2NpdHk6ICR7YW5ndWxhclZlbG9jaXR5fWAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGNlbnRlck9mTWFzcyBpbnN0YW5jZW9mIENlbnRlck9mTWFzcywgYGludmFsaWQgY2VudGVyT2ZNYXNzOiAke2NlbnRlck9mTWFzc31gICk7XHJcblxyXG4gICAgLy8gQHByaXZhdGUge0JhbGxbXX0gLSByZWZlcmVuY2UgdG8gdGhlIHBhc3NlZC1pbiBiYWxscy5cclxuICAgIHRoaXMuYmFsbHMgPSBiYWxscztcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7bnVtYmVyfSAtIHJlZmVyZW5jZSB0byB0aGUgcGFzc2VkLWluIGFuZ3VsYXJWZWxvY2l0eS5cclxuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gYW5ndWxhclZlbG9jaXR5O1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtDZW50ZXJPZk1hc3N9IC0gcmVmZXJlbmNlIHRvIHRoZSBwYXNzZWQtaW4gY2VudGVyT2ZNYXNzLlxyXG4gICAgdGhpcy5jZW50ZXJPZk1hc3MgPSBjZW50ZXJPZk1hc3M7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSByYWRpdXMgb2YgdGhlIGJvdW5kaW5nIGNpcmNsZSBvZiB0aGUgZW50aXJlIFJvdGF0aW5nQmFsbENsdXN0ZXIsIGluIG1ldGVycy5cclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldEJvdW5kaW5nQ2lyY2xlUmFkaXVzKCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KCAuLi50aGlzLmJhbGxzLm1hcCggYmFsbCA9PiBiYWxsLnBvc2l0aW9uUHJvcGVydHkudmFsdWUuZGlzdGFuY2UoIHRoaXMuY2VudGVyT2ZNYXNzLnBvc2l0aW9uUHJvcGVydHkudmFsdWUgKSArIGJhbGwucmFkaXVzUHJvcGVydHkudmFsdWUgKSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZXMgZXZlcnkgQmFsbCBpbiB0aGUgY2x1c3RlciBieSBvbmUgdGltZS1zdGVwLCAncm90YXRpbmcnIGVhY2ggYmFsbCBhcm91bmQgdGhlIGNlbnRlci1vZi1tYXNzIG9mIHRoZSBjbHVzdGVyLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdCAtIHRpbWUtZGVsdGEgaW4gc2Vjb25kcy5cclxuICAgKi9cclxuICBzdGVwKCBkdCApIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBkdCA9PT0gJ251bWJlcicsIGBpbnZhbGlkIGR0OiAke2R0fWAgKTtcclxuXHJcbiAgICAvLyBUaGUgYW5ndWxhciBkaXNwbGFjZW1lbnQgb2YgZWFjaCBCYWxsIHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgIGNvbnN0IGNoYW5nZUluQW5nbGUgPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xyXG5cclxuICAgIC8vIEdldCB0aGUgc3RhdGVzIG9mIHRoZSBCYWxscyBhZnRlciB0aGUgcm90YXRpb24gb2NjdXJzLlxyXG4gICAgY29uc3Qgcm90YXRpb25TdGF0ZXMgPSB0aGlzLmdldFN0ZXBwZWRSb3RhdGlvblN0YXRlcyggZHQgKTtcclxuXHJcbiAgICB0aGlzLmJhbGxzLmZvckVhY2goIGJhbGwgPT4ge1xyXG5cclxuICAgICAgLy8gU2V0IHRoZSBzdGF0ZSBvZiBlYWNoIEJhbGwuXHJcbiAgICAgIGJhbGwuc2V0U3RhdGUoIHJvdGF0aW9uU3RhdGVzLmdldCggYmFsbCApICk7XHJcblxyXG4gICAgICAvLyBSb3RhdGUgdGhlIGJhbGxzIGFyb3VuZCB0aGVpciBjZW50ZXJzIHRvIHByb3ZpZGUgYSBtb3JlIHJlYWxpc3RpYyByb3RhdGlvbiBleHBlcmllbmNlLiBTZWVcclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NvbGxpc2lvbi1sYWIvaXNzdWVzLzg3XHJcbiAgICAgIGJhbGwucm90YXRpb25Qcm9wZXJ0eS52YWx1ZSArPSBjaGFuZ2VJbkFuZ2xlO1xyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBCYWxsU3RhdGVzIHRoYXQgZGVzY3JpYmUgdGhlIHN0YXRlIG9mIGVhY2ggQmFsbCBhZnRlciBiZWluZyAncm90YXRlZCcgZm9yIGR0IHNlY29uZHMuIFRoZSBwb3NpdGlvbiBhbmRcclxuICAgKiB2ZWxvY2l0eSBvZiBlYWNoIEJhbGwgZ2VuZXJhbGx5IGNoYW5nZXMsIGJ1dCB0aGUgbWFzcyBkb2VzIG5vdC4gVGhlIHBvc2l0aW9uL3ZlbG9jaXR5IG9mIGVhY2ggYmFsbCBpcyBjYWxjdWxhdGVkIGJ5XHJcbiAgICogY2hhbmdpbmcgcmVmZXJlbmNlIGZyYW1lcyB0byB0aGUgY2VudGVyT2ZNYXNzIGFuZCBhcHBseWluZyBzdGFuZGFyZCB1bmlmb3JtIGNpcmN1bGFyIG1vdGlvbiBlcXVhdGlvbnMuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR0IC0gdGltZS1kZWx0YSwgaW4gc2Vjb25kcy5cclxuICAgKiBAcmV0dXJucyB7TWFwLjxCYWxsLCBCYWxsU3RhdGU+fSAtIG1hcHMgQmFsbCB0byBhIEJhbGxTdGF0ZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBnZXRTdGVwcGVkUm90YXRpb25TdGF0ZXMoIGR0ICkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdHlwZW9mIGR0ID09PSAnbnVtYmVyJywgYGludmFsaWQgZHQ6ICR7ZHR9YCApO1xyXG5cclxuICAgIC8vIFRoZSByZXN1bHRpbmcgTWFwIHRoYXQgbWFwcyBlYWNoIEJhbGwgdG8gYSBCYWxsU3RhdGUgaW5zdGFuY2UuXHJcbiAgICBjb25zdCBiYWxsVG9Sb3RhdGlvblN0YXRlcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAvLyBUaGUgYW5ndWxhciBkaXNwbGFjZW1lbnQgb2YgZWFjaCBCYWxsIHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgIGNvbnN0IGNoYW5nZUluQW5nbGUgPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xyXG5cclxuICAgIC8vIENvbXB1dGUgdGhlIHBvc2l0aW9uL3ZlbG9jaXR5IG9mIHRoZSBjZW50ZXItb2YtbWFzcyAqKmFmdGVyKiogdGhlIHJvdGF0aW9uLlxyXG4gICAgY29uc3QgY2VudGVyT2ZNYXNzUG9zaXRpb24gPSB0aGlzLmNlbnRlck9mTWFzcy52ZWxvY2l0eVByb3BlcnR5LnZhbHVlLnRpbWVzKCBkdCApLmFkZCggdGhpcy5jZW50ZXJPZk1hc3MucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZSApO1xyXG4gICAgY29uc3QgY2VudGVyT2ZNYXNzVmVsb2NpdHkgPSB0aGlzLmNlbnRlck9mTWFzcy52ZWxvY2l0eVByb3BlcnR5LnZhbHVlO1xyXG5cclxuICAgIHRoaXMuYmFsbHMuZm9yRWFjaCggYmFsbCA9PiB7XHJcblxyXG4gICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIHZlY3RvciBvZiB0aGUgQmFsbCwgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzLiBUaGlzIGlzIGEgY2hhbmdlIGluIHJlZmVyZW5jZSBmcmFtZXMuXHJcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gYmFsbC5wb3NpdGlvblByb3BlcnR5LnZhbHVlLm1pbnVzKCB0aGlzLmNlbnRlck9mTWFzcy5wb3NpdGlvblByb3BlcnR5LnZhbHVlICk7XHJcblxyXG4gICAgICAvLyBSb3RhdGUgdGhlIHBvc2l0aW9uIHZlY3RvciB0byBhcHBseSB1bmlmb3JtIGNpcmN1bGFyIG1vdGlvbiBhYm91dCB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgIHBvc2l0aW9uLnJvdGF0ZSggY2hhbmdlSW5BbmdsZSApO1xyXG5cclxuICAgICAgLy8gQ29tcHV0ZSB0aGUgdmVsb2NpdHkgb2YgQm90aCBiYWxscyBhZnRlciB0aGlzIHN0ZXAsIHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcy4gVGhlIHZlbG9jaXR5IGlzIHRoZVxyXG4gICAgICAvLyBjcm9zcyBwcm9kdWN0IG9mIHRoZSBhbmd1bGFyIHZlbG9jaXR5ICh2ZWN0b3IpIGFuZCB0aGUgcG9zaXRpb24gdmVjdG9yIGFmdGVyIHRoZSByb3RhdGlvbi4gU2VlXHJcbiAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NpcmN1bGFyX21vdGlvbiNWZWxvY2l0eS5cclxuICAgICAgY29uc3QgdmVsb2NpdHkgPSBuZXcgVmVjdG9yMiggLXRoaXMuYW5ndWxhclZlbG9jaXR5ICogcG9zaXRpb24ueSwgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKiBwb3NpdGlvbi54ICk7XHJcblxyXG4gICAgICAvLyBDb21wdXRlIHRoZSBwb3NpdGlvbiBhbmQgdmVsb2NpdHkgb2YgdGhlIEJhbGxzIGJhY2sgaW4gdGhlIGFic29sdXRlIHJlZmVyZW5jZSBmcmFtZSwgY3JlYXRpbmcgYSBCYWxsU3RhdGVcclxuICAgICAgLy8gaW5zdGFuY2UgdG8gaG9sZCBvbnRvIHRoZSB2ZWN0b3JzLlxyXG4gICAgICBjb25zdCBiYWxsU3RhdGUgPSBuZXcgQmFsbFN0YXRlKFxyXG4gICAgICAgIHBvc2l0aW9uLmFkZCggY2VudGVyT2ZNYXNzUG9zaXRpb24gKSxcclxuICAgICAgICB2ZWxvY2l0eS5hZGQoIGNlbnRlck9mTWFzc1ZlbG9jaXR5ICksXHJcbiAgICAgICAgYmFsbC5tYXNzUHJvcGVydHkudmFsdWVcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIE1hcCBlYWNoIEJhbGwgdG8gdGhlIEJhbGxTdGF0ZSBpbnN0YW5jZS5cclxuICAgICAgYmFsbFRvUm90YXRpb25TdGF0ZXMuc2V0KCBiYWxsLCBiYWxsU3RhdGUgKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICByZXR1cm4gYmFsbFRvUm90YXRpb25TdGF0ZXM7XHJcbiAgfVxyXG59XHJcblxyXG5jb2xsaXNpb25MYWIucmVnaXN0ZXIoICdSb3RhdGluZ0JhbGxDbHVzdGVyJywgUm90YXRpbmdCYWxsQ2x1c3RlciApO1xyXG5leHBvcnQgZGVmYXVsdCBSb3RhdGluZ0JhbGxDbHVzdGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsV0FBVyxNQUFNLDBDQUEwQztBQUNsRSxPQUFPQyxZQUFZLE1BQU0sdUJBQXVCO0FBQ2hELE9BQU9DLElBQUksTUFBTSw0QkFBNEI7QUFDN0MsT0FBT0MsU0FBUyxNQUFNLGlDQUFpQztBQUN2RCxPQUFPQyxZQUFZLE1BQU0sb0NBQW9DO0FBRTdELE1BQU1DLG1CQUFtQixDQUFDO0VBRXhCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsV0FBV0EsQ0FBRUMsS0FBSyxFQUFFQyxlQUFlLEVBQUVDLFlBQVksRUFBRztJQUNsREMsTUFBTSxJQUFJVixXQUFXLENBQUNXLGFBQWEsQ0FBRUosS0FBSyxFQUFFTCxJQUFLLENBQUM7SUFDbERRLE1BQU0sSUFBSUEsTUFBTSxDQUFFLE9BQU9GLGVBQWUsS0FBSyxRQUFRLEVBQUcsNEJBQTJCQSxlQUFnQixFQUFFLENBQUM7SUFDdEdFLE1BQU0sSUFBSUEsTUFBTSxDQUFFRCxZQUFZLFlBQVlMLFlBQVksRUFBRyx5QkFBd0JLLFlBQWEsRUFBRSxDQUFDOztJQUVqRztJQUNBLElBQUksQ0FBQ0YsS0FBSyxHQUFHQSxLQUFLOztJQUVsQjtJQUNBLElBQUksQ0FBQ0MsZUFBZSxHQUFHQSxlQUFlOztJQUV0QztJQUNBLElBQUksQ0FBQ0MsWUFBWSxHQUFHQSxZQUFZO0VBQ2xDOztF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