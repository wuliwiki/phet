// Copyright 2018-2021, University of Colorado Boulder

/**
 * MagnetAutoSlideKeyboardListener is a keyboard listener that implement the "auto-slide" behavior, which is where the
 * user can press keys that will cause the magnet to translate horizontally until it hits an obstacle or the sim bounds.
 *
 * @author Michael Barlow (PhET Interactive Simulations)
 * @author John Blanco (PhET Interactive Simulations)
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import stepTimer from '../../../../axon/js/stepTimer.js';
import LinearFunction from '../../../../dot/js/LinearFunction.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import Vector2Property from '../../../../dot/js/Vector2Property.js';
import merge from '../../../../phet-core/js/merge.js';
import { KeyboardUtils } from '../../../../scenery/js/imports.js';
import faradaysLaw from '../../faradaysLaw.js';
import FaradaysLawConstants from '../FaradaysLawConstants.js';
import MagnetDirectionEnum from '../model/MagnetDirectionEnum.js';
import FaradaysLawAlertManager from './FaradaysLawAlertManager.js';

// constants
const {
  LEFT,
  RIGHT
} = MagnetDirectionEnum;
const HALF_MAGNET_WIDTH = FaradaysLawConstants.MAGNET_WIDTH / 2;
const HALF_MAGNET_HEIGHT = FaradaysLawConstants.MAGNET_HEIGHT / 2;

// event.code for the digit keys used
const KEY_CODE_DIGIT_1 = KeyboardUtils.KEY_1;
const KEY_CODE_DIGIT_2 = KeyboardUtils.KEY_2;
const KEY_CODE_DIGIT_3 = KeyboardUtils.KEY_3;

// list of key modifiers to check for and make sure are not pressed when handling these keys
const KEY_MODIFIER_LIST = ['Control', 'Alt'];
class MagnetAutoSlideKeyboardListener {
  constructor(model, options) {
    options = merge({
      // speeds, all in model coordinates per second
      slowSpeed: 90,
      // empirically determined such that the voltmeter doesn't peg when going through bigger coil
      mediumSpeed: 300,
      fastSpeed: 500,
      onKeyDown: _.noop,
      onKeyUp: _.noop
    }, options);
    const {
      mediumSpeed,
      slowSpeed,
      fastSpeed
    } = options;

    // {Map.<string, number>} - map of the auto-slide keys to a speed for each
    const keyToSpeedMap = new Map([[KEY_CODE_DIGIT_1, slowSpeed], [KEY_CODE_DIGIT_2, mediumSpeed], [KEY_CODE_DIGIT_3, fastSpeed]]);

    // Track the up/down state for each of the auto-slide keys.
    this.autoSlideKeyIsDownMap = new Map();
    for (const key of keyToSpeedMap.keys()) {
      this.autoSlideKeyIsDownMap.set(key, false);
    }

    // @public (read-only) - true when the magnet is being animated (moved) by this object
    this.isAnimatingProperty = new BooleanProperty(false);

    // @public (read-only) - the position where the magnet will head towards if and when this listener is fired
    this.slideTargetPositionProperty = new Vector2Property(Vector2.ZERO);

    // @private - speed at which translation of the magnet should occur
    this.translationSpeed = 0;

    // @private
    this.model = model;
    this._constrainedDragBounds = FaradaysLawConstants.LAYOUT_BOUNDS.erodedXY(HALF_MAGNET_WIDTH, HALF_MAGNET_HEIGHT);

    // closure to update the slide target position based on the current position and animation state
    const updateSlideTarget = () => {
      let preferredDirection;
      if (this.isAnimatingProperty.value) {
        // There is an animation in progress, so we want to reverse the direction.
        preferredDirection = model.magnet.positionProperty.value.x < this.slideTargetPositionProperty.value.x ? LEFT : RIGHT;
      } else {
        // The magnet is not currently sliding, so start it moving.  It will move towards the coils if there is room to
        // do so, otherwise it will move away from them.
        preferredDirection = model.magnet.positionProperty.value.x < FaradaysLawConstants.TOP_COIL_POSITION.x ? RIGHT : LEFT;
      }

      // convenience values
      const magnetXPosition = model.magnet.positionProperty.value.x;
      const maxXPosition = this._constrainedDragBounds.maxX;
      const minXPosition = this._constrainedDragBounds.minX;

      // Start with a translation that would take the magnet all the way to the right or left model bounds.
      let proposedTranslation = new Vector2(preferredDirection === RIGHT ? maxXPosition - magnetXPosition : minXPosition - magnetXPosition, 0);

      // Check whether the proposed translation is viable and, if not, determine what is.
      let allowableTranslation = model.checkProposedMagnetMotion(proposedTranslation);

      // If the allowable translation works out to be zero, it means that the magnet is up against an obstacle, so go
      // the other direction.
      if (allowableTranslation.magnitude === 0) {
        preferredDirection = preferredDirection === RIGHT ? LEFT : RIGHT;
        proposedTranslation = new Vector2(preferredDirection === RIGHT ? maxXPosition - magnetXPosition : minXPosition - magnetXPosition, 0);
        allowableTranslation = model.checkProposedMagnetMotion(proposedTranslation);
      }

      // Set the new target position.
      this.slideTargetPositionProperty.set(model.magnet.positionProperty.value.plus(allowableTranslation));
    };

    // To avoid odd behavior, stop any in-progress animations if the number of coils change.
    model.topCoilVisibleProperty.link(() => {
      if (this.isAnimatingProperty.value) {
        this.isAnimatingProperty.set(false);
        this.slideTargetPositionProperty.set(model.magnet.positionProperty.value);
      }
    });

    // key down handler
    this.keydown = event => {
      // check if the key is "modified"
      let keyModified = false;
      KEY_MODIFIER_LIST.forEach(modifierArg => {
        keyModified = keyModified || event.domEvent.getModifierState(modifierArg);
      });
      const key = KeyboardUtils.getEventCode(event.domEvent);
      if (keyToSpeedMap.has(key) && !keyModified) {
        // Skip the changes if this key is already down.
        if (!this.autoSlideKeyIsDownMap.get(key)) {
          // Mark this key as being down.
          this.autoSlideKeyIsDownMap.set(key, true);

          // Update the slide target.
          updateSlideTarget();

          // Initiate the animation.
          this.isAnimatingProperty.set(true);

          // Update the speed at which the magnet will move.
          this.translationSpeed = keyToSpeedMap.get(key);
        }
      } else if (this.isAnimatingProperty.value) {
        // Any key press that is not one of the auto-slide keys should stop the animation.
        this.isAnimatingProperty.set(false);
      }

      // Invoke the client-provided handler (this does nothing if the client didn't provide one).
      options.onKeyDown(event);
    };

    // function for mapping speed linearly, which is then used to map it to text for a11y
    const speedToText = new LinearFunction(0, fastSpeed, 0, 200, true);

    // key up handler
    this.keyup = event => {
      const releasedKey = event.domEvent.code;
      if (keyToSpeedMap.has(releasedKey)) {
        this.autoSlideKeyIsDownMap.set(releasedKey, false);
        const speedToTextValue = Utils.roundSymmetric(speedToText.evaluate(this.translationSpeed));
        const direction = this.model.magnet.positionProperty.value.x < this.slideTargetPositionProperty.value.x ? RIGHT : LEFT;
        FaradaysLawAlertManager.magnetSlidingAlert(speedToTextValue, direction);
      }

      // Invoke the client-provided handler (this does nothing if the client didn't provide one).
      options.onKeyUp(event);
    };

    // Handler for the case where the magnet is released from a11y focus.  If a key is down when the magnet is released,
    // subsequent key up messages won't be received, so we need to clear any keys that are down, see
    // https://github.com/phetsims/faradays-law/issues/214.
    this.released = () => {
      // Mark all keys as up.
      this.autoSlideKeyIsDownMap.forEach((value, key) => {
        this.autoSlideKeyIsDownMap.set(key, false);
      });

      // Make sure animation is off.
      this.isAnimatingProperty.set(false);
    };

    // Stop the animation if the user starts dragging the magnet.
    model.magnet.isDraggingProperty.link(isDragging => {
      if (isDragging) {
        this.isAnimatingProperty.set(false);
      }
    });

    // step the drag listener, must be removed in dispose
    const stepListener = this.step.bind(this);
    stepTimer.addListener(stepListener);

    // @private - called in dispose
    this._disposeKeyboardDragListener = () => {
      stepTimer.removeListener(stepListener);
    };
  }

  /**
   * @public
   * @param {number} dt - in seconds
   */
  step(dt) {
    // Determine whether any of the auto-slide keys are currently pressed.
    let autoSlideKeyPressed = false;
    for (const isKeyDown of this.autoSlideKeyIsDownMap.values()) {
      if (isKeyDown) {
        autoSlideKeyPressed = true;
      }
    }

    // If an animation is in progress and none of the auto-slide keys are pressed, move the magnet towards the target.
    if (this.isAnimatingProperty.value && !autoSlideKeyPressed) {
      const magnetPosition = this.model.magnet.positionProperty.value;
      if (!magnetPosition.equals(this.slideTargetPositionProperty.value)) {
        const deltaXToTarget = this.slideTargetPositionProperty.value.x - magnetPosition.x;
        let unconstrainedNewPosition;
        if (Math.abs(deltaXToTarget) <= dt * this.translationSpeed) {
          // The magnet is almost to the target position, so just move it there.
          unconstrainedNewPosition = this.slideTargetPositionProperty.value;
        } else {
          const distanceSign = deltaXToTarget < 0 ? -1 : 1;
          const deltaVector = new Vector2(distanceSign * this.translationSpeed * dt, 0);
          unconstrainedNewPosition = magnetPosition.plus(deltaVector);
        }

        // Make sure the new position doesn't put the magnet outside of the drag bounds.
        const constrainedNewPosition = this._constrainedDragBounds.closestPointTo(unconstrainedNewPosition);

        // Move the magnet.
        this.model.moveMagnetToPosition(constrainedNewPosition);
      }

      // If the magnet is now at the destination, clear the animation flag.
      if (magnetPosition.equals(this.slideTargetPositionProperty.value)) {
        this.isAnimatingProperty.set(false);
      }
    }
  }

  /**
   * @public
   */
  dispose() {
    this._disposeKeyboardDragListener();
  }
}
faradaysLaw.register('MagnetAutoSlideKeyboardListener', MagnetAutoSlideKeyboardListener);
export default MagnetAutoSlideKeyboardListener;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJzdGVwVGltZXIiLCJMaW5lYXJGdW5jdGlvbiIsIlV0aWxzIiwiVmVjdG9yMiIsIlZlY3RvcjJQcm9wZXJ0eSIsIm1lcmdlIiwiS2V5Ym9hcmRVdGlscyIsImZhcmFkYXlzTGF3IiwiRmFyYWRheXNMYXdDb25zdGFudHMiLCJNYWduZXREaXJlY3Rpb25FbnVtIiwiRmFyYWRheXNMYXdBbGVydE1hbmFnZXIiLCJMRUZUIiwiUklHSFQiLCJIQUxGX01BR05FVF9XSURUSCIsIk1BR05FVF9XSURUSCIsIkhBTEZfTUFHTkVUX0hFSUdIVCIsIk1BR05FVF9IRUlHSFQiLCJLRVlfQ09ERV9ESUdJVF8xIiwiS0VZXzEiLCJLRVlfQ09ERV9ESUdJVF8yIiwiS0VZXzIiLCJLRVlfQ09ERV9ESUdJVF8zIiwiS0VZXzMiLCJLRVlfTU9ESUZJRVJfTElTVCIsIk1hZ25ldEF1dG9TbGlkZUtleWJvYXJkTGlzdGVuZXIiLCJjb25zdHJ1Y3RvciIsIm1vZGVsIiwib3B0aW9ucyIsInNsb3dTcGVlZCIsIm1lZGl1bVNwZWVkIiwiZmFzdFNwZWVkIiwib25LZXlEb3duIiwiXyIsIm5vb3AiLCJvbktleVVwIiwia2V5VG9TcGVlZE1hcCIsIk1hcCIsImF1dG9TbGlkZUtleUlzRG93bk1hcCIsImtleSIsImtleXMiLCJzZXQiLCJpc0FuaW1hdGluZ1Byb3BlcnR5Iiwic2xpZGVUYXJnZXRQb3NpdGlvblByb3BlcnR5IiwiWkVSTyIsInRyYW5zbGF0aW9uU3BlZWQiLCJfY29uc3RyYWluZWREcmFnQm91bmRzIiwiTEFZT1VUX0JPVU5EUyIsImVyb2RlZFhZIiwidXBkYXRlU2xpZGVUYXJnZXQiLCJwcmVmZXJyZWREaXJlY3Rpb24iLCJ2YWx1ZSIsIm1hZ25ldCIsInBvc2l0aW9uUHJvcGVydHkiLCJ4IiwiVE9QX0NPSUxfUE9TSVRJT04iLCJtYWduZXRYUG9zaXRpb24iLCJtYXhYUG9zaXRpb24iLCJtYXhYIiwibWluWFBvc2l0aW9uIiwibWluWCIsInByb3Bvc2VkVHJhbnNsYXRpb24iLCJhbGxvd2FibGVUcmFuc2xhdGlvbiIsImNoZWNrUHJvcG9zZWRNYWduZXRNb3Rpb24iLCJtYWduaXR1ZGUiLCJwbHVzIiwidG9wQ29pbFZpc2libGVQcm9wZXJ0eSIsImxpbmsiLCJrZXlkb3duIiwiZXZlbnQiLCJrZXlNb2RpZmllZCIsImZvckVhY2giLCJtb2RpZmllckFyZyIsImRvbUV2ZW50IiwiZ2V0TW9kaWZpZXJTdGF0ZSIsImdldEV2ZW50Q29kZSIsImhhcyIsImdldCIsInNwZWVkVG9UZXh0Iiwia2V5dXAiLCJyZWxlYXNlZEtleSIsImNvZGUiLCJzcGVlZFRvVGV4dFZhbHVlIiwicm91bmRTeW1tZXRyaWMiLCJldmFsdWF0ZSIsImRpcmVjdGlvbiIsIm1hZ25ldFNsaWRpbmdBbGVydCIsInJlbGVhc2VkIiwiaXNEcmFnZ2luZ1Byb3BlcnR5IiwiaXNEcmFnZ2luZyIsInN0ZXBMaXN0ZW5lciIsInN0ZXAiLCJiaW5kIiwiYWRkTGlzdGVuZXIiLCJfZGlzcG9zZUtleWJvYXJkRHJhZ0xpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJkdCIsImF1dG9TbGlkZUtleVByZXNzZWQiLCJpc0tleURvd24iLCJ2YWx1ZXMiLCJtYWduZXRQb3NpdGlvbiIsImVxdWFscyIsImRlbHRhWFRvVGFyZ2V0IiwidW5jb25zdHJhaW5lZE5ld1Bvc2l0aW9uIiwiTWF0aCIsImFicyIsImRpc3RhbmNlU2lnbiIsImRlbHRhVmVjdG9yIiwiY29uc3RyYWluZWROZXdQb3NpdGlvbiIsImNsb3Nlc3RQb2ludFRvIiwibW92ZU1hZ25ldFRvUG9zaXRpb24iLCJkaXNwb3NlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJNYWduZXRBdXRvU2xpZGVLZXlib2FyZExpc3RlbmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4LTIwMjEsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIE1hZ25ldEF1dG9TbGlkZUtleWJvYXJkTGlzdGVuZXIgaXMgYSBrZXlib2FyZCBsaXN0ZW5lciB0aGF0IGltcGxlbWVudCB0aGUgXCJhdXRvLXNsaWRlXCIgYmVoYXZpb3IsIHdoaWNoIGlzIHdoZXJlIHRoZVxyXG4gKiB1c2VyIGNhbiBwcmVzcyBrZXlzIHRoYXQgd2lsbCBjYXVzZSB0aGUgbWFnbmV0IHRvIHRyYW5zbGF0ZSBob3Jpem9udGFsbHkgdW50aWwgaXQgaGl0cyBhbiBvYnN0YWNsZSBvciB0aGUgc2ltIGJvdW5kcy5cclxuICpcclxuICogQGF1dGhvciBNaWNoYWVsIEJhcmxvdyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICogQGF1dGhvciBKb2huIEJsYW5jbyAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgQm9vbGVhblByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvQm9vbGVhblByb3BlcnR5LmpzJztcclxuaW1wb3J0IHN0ZXBUaW1lciBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL3N0ZXBUaW1lci5qcyc7XHJcbmltcG9ydCBMaW5lYXJGdW5jdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvTGluZWFyRnVuY3Rpb24uanMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgVmVjdG9yMlByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL21lcmdlLmpzJztcclxuaW1wb3J0IHsgS2V5Ym9hcmRVdGlscyB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBmYXJhZGF5c0xhdyBmcm9tICcuLi8uLi9mYXJhZGF5c0xhdy5qcyc7XHJcbmltcG9ydCBGYXJhZGF5c0xhd0NvbnN0YW50cyBmcm9tICcuLi9GYXJhZGF5c0xhd0NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBNYWduZXREaXJlY3Rpb25FbnVtIGZyb20gJy4uL21vZGVsL01hZ25ldERpcmVjdGlvbkVudW0uanMnO1xyXG5pbXBvcnQgRmFyYWRheXNMYXdBbGVydE1hbmFnZXIgZnJvbSAnLi9GYXJhZGF5c0xhd0FsZXJ0TWFuYWdlci5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgeyBMRUZULCBSSUdIVCB9ID0gTWFnbmV0RGlyZWN0aW9uRW51bTtcclxuY29uc3QgSEFMRl9NQUdORVRfV0lEVEggPSBGYXJhZGF5c0xhd0NvbnN0YW50cy5NQUdORVRfV0lEVEggLyAyO1xyXG5jb25zdCBIQUxGX01BR05FVF9IRUlHSFQgPSBGYXJhZGF5c0xhd0NvbnN0YW50cy5NQUdORVRfSEVJR0hUIC8gMjtcclxuXHJcbi8vIGV2ZW50LmNvZGUgZm9yIHRoZSBkaWdpdCBrZXlzIHVzZWRcclxuY29uc3QgS0VZX0NPREVfRElHSVRfMSA9IEtleWJvYXJkVXRpbHMuS0VZXzE7XHJcbmNvbnN0IEtFWV9DT0RFX0RJR0lUXzIgPSBLZXlib2FyZFV0aWxzLktFWV8yO1xyXG5jb25zdCBLRVlfQ09ERV9ESUdJVF8zID0gS2V5Ym9hcmRVdGlscy5LRVlfMztcclxuXHJcbi8vIGxpc3Qgb2Yga2V5IG1vZGlmaWVycyB0byBjaGVjayBmb3IgYW5kIG1ha2Ugc3VyZSBhcmUgbm90IHByZXNzZWQgd2hlbiBoYW5kbGluZyB0aGVzZSBrZXlzXHJcbmNvbnN0IEtFWV9NT0RJRklFUl9MSVNUID0gWyAnQ29udHJvbCcsICdBbHQnIF07XHJcblxyXG5jbGFzcyBNYWduZXRBdXRvU2xpZGVLZXlib2FyZExpc3RlbmVyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoIG1vZGVsLCBvcHRpb25zICkge1xyXG4gICAgb3B0aW9ucyA9IG1lcmdlKCB7XHJcblxyXG4gICAgICAvLyBzcGVlZHMsIGFsbCBpbiBtb2RlbCBjb29yZGluYXRlcyBwZXIgc2Vjb25kXHJcbiAgICAgIHNsb3dTcGVlZDogOTAsIC8vIGVtcGlyaWNhbGx5IGRldGVybWluZWQgc3VjaCB0aGF0IHRoZSB2b2x0bWV0ZXIgZG9lc24ndCBwZWcgd2hlbiBnb2luZyB0aHJvdWdoIGJpZ2dlciBjb2lsXHJcbiAgICAgIG1lZGl1bVNwZWVkOiAzMDAsXHJcbiAgICAgIGZhc3RTcGVlZDogNTAwLFxyXG5cclxuICAgICAgb25LZXlEb3duOiBfLm5vb3AsXHJcbiAgICAgIG9uS2V5VXA6IF8ubm9vcFxyXG4gICAgfSwgb3B0aW9ucyApO1xyXG5cclxuICAgIGNvbnN0IHsgbWVkaXVtU3BlZWQsIHNsb3dTcGVlZCwgZmFzdFNwZWVkIH0gPSBvcHRpb25zO1xyXG5cclxuICAgIC8vIHtNYXAuPHN0cmluZywgbnVtYmVyPn0gLSBtYXAgb2YgdGhlIGF1dG8tc2xpZGUga2V5cyB0byBhIHNwZWVkIGZvciBlYWNoXHJcbiAgICBjb25zdCBrZXlUb1NwZWVkTWFwID0gbmV3IE1hcCggW1xyXG4gICAgICBbIEtFWV9DT0RFX0RJR0lUXzEsIHNsb3dTcGVlZCBdLFxyXG4gICAgICBbIEtFWV9DT0RFX0RJR0lUXzIsIG1lZGl1bVNwZWVkIF0sXHJcbiAgICAgIFsgS0VZX0NPREVfRElHSVRfMywgZmFzdFNwZWVkIF1cclxuICAgIF0gKTtcclxuXHJcbiAgICAvLyBUcmFjayB0aGUgdXAvZG93biBzdGF0ZSBmb3IgZWFjaCBvZiB0aGUgYXV0by1zbGlkZSBrZXlzLlxyXG4gICAgdGhpcy5hdXRvU2xpZGVLZXlJc0Rvd25NYXAgPSBuZXcgTWFwKCk7XHJcbiAgICBmb3IgKCBjb25zdCBrZXkgb2Yga2V5VG9TcGVlZE1hcC5rZXlzKCkgKSB7XHJcbiAgICAgIHRoaXMuYXV0b1NsaWRlS2V5SXNEb3duTWFwLnNldCgga2V5LCBmYWxzZSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBwdWJsaWMgKHJlYWQtb25seSkgLSB0cnVlIHdoZW4gdGhlIG1hZ25ldCBpcyBiZWluZyBhbmltYXRlZCAobW92ZWQpIGJ5IHRoaXMgb2JqZWN0XHJcbiAgICB0aGlzLmlzQW5pbWF0aW5nUHJvcGVydHkgPSBuZXcgQm9vbGVhblByb3BlcnR5KCBmYWxzZSApO1xyXG5cclxuICAgIC8vIEBwdWJsaWMgKHJlYWQtb25seSkgLSB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIG1hZ25ldCB3aWxsIGhlYWQgdG93YXJkcyBpZiBhbmQgd2hlbiB0aGlzIGxpc3RlbmVyIGlzIGZpcmVkXHJcbiAgICB0aGlzLnNsaWRlVGFyZ2V0UG9zaXRpb25Qcm9wZXJ0eSA9IG5ldyBWZWN0b3IyUHJvcGVydHkoIFZlY3RvcjIuWkVSTyApO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIC0gc3BlZWQgYXQgd2hpY2ggdHJhbnNsYXRpb24gb2YgdGhlIG1hZ25ldCBzaG91bGQgb2NjdXJcclxuICAgIHRoaXMudHJhbnNsYXRpb25TcGVlZCA9IDA7XHJcblxyXG4gICAgLy8gQHByaXZhdGVcclxuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgIHRoaXMuX2NvbnN0cmFpbmVkRHJhZ0JvdW5kcyA9IEZhcmFkYXlzTGF3Q29uc3RhbnRzLkxBWU9VVF9CT1VORFMuZXJvZGVkWFkoIEhBTEZfTUFHTkVUX1dJRFRILCBIQUxGX01BR05FVF9IRUlHSFQgKTtcclxuXHJcbiAgICAvLyBjbG9zdXJlIHRvIHVwZGF0ZSB0aGUgc2xpZGUgdGFyZ2V0IHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBhbmltYXRpb24gc3RhdGVcclxuICAgIGNvbnN0IHVwZGF0ZVNsaWRlVGFyZ2V0ID0gKCkgPT4ge1xyXG5cclxuICAgICAgbGV0IHByZWZlcnJlZERpcmVjdGlvbjtcclxuICAgICAgaWYgKCB0aGlzLmlzQW5pbWF0aW5nUHJvcGVydHkudmFsdWUgKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZXJlIGlzIGFuIGFuaW1hdGlvbiBpbiBwcm9ncmVzcywgc28gd2Ugd2FudCB0byByZXZlcnNlIHRoZSBkaXJlY3Rpb24uXHJcbiAgICAgICAgcHJlZmVycmVkRGlyZWN0aW9uID0gbW9kZWwubWFnbmV0LnBvc2l0aW9uUHJvcGVydHkudmFsdWUueCA8IHRoaXMuc2xpZGVUYXJnZXRQb3NpdGlvblByb3BlcnR5LnZhbHVlLnggP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIExFRlQgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJJR0hUO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBUaGUgbWFnbmV0IGlzIG5vdCBjdXJyZW50bHkgc2xpZGluZywgc28gc3RhcnQgaXQgbW92aW5nLiAgSXQgd2lsbCBtb3ZlIHRvd2FyZHMgdGhlIGNvaWxzIGlmIHRoZXJlIGlzIHJvb20gdG9cclxuICAgICAgICAvLyBkbyBzbywgb3RoZXJ3aXNlIGl0IHdpbGwgbW92ZSBhd2F5IGZyb20gdGhlbS5cclxuICAgICAgICBwcmVmZXJyZWREaXJlY3Rpb24gPSBtb2RlbC5tYWduZXQucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS54IDwgRmFyYWRheXNMYXdDb25zdGFudHMuVE9QX0NPSUxfUE9TSVRJT04ueCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUklHSFQgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIExFRlQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGNvbnZlbmllbmNlIHZhbHVlc1xyXG4gICAgICBjb25zdCBtYWduZXRYUG9zaXRpb24gPSBtb2RlbC5tYWduZXQucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS54O1xyXG4gICAgICBjb25zdCBtYXhYUG9zaXRpb24gPSB0aGlzLl9jb25zdHJhaW5lZERyYWdCb3VuZHMubWF4WDtcclxuICAgICAgY29uc3QgbWluWFBvc2l0aW9uID0gdGhpcy5fY29uc3RyYWluZWREcmFnQm91bmRzLm1pblg7XHJcblxyXG4gICAgICAvLyBTdGFydCB3aXRoIGEgdHJhbnNsYXRpb24gdGhhdCB3b3VsZCB0YWtlIHRoZSBtYWduZXQgYWxsIHRoZSB3YXkgdG8gdGhlIHJpZ2h0IG9yIGxlZnQgbW9kZWwgYm91bmRzLlxyXG4gICAgICBsZXQgcHJvcG9zZWRUcmFuc2xhdGlvbiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIHByZWZlcnJlZERpcmVjdGlvbiA9PT0gUklHSFQgPyBtYXhYUG9zaXRpb24gLSBtYWduZXRYUG9zaXRpb24gOiBtaW5YUG9zaXRpb24gLSBtYWduZXRYUG9zaXRpb24sXHJcbiAgICAgICAgMFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgcHJvcG9zZWQgdHJhbnNsYXRpb24gaXMgdmlhYmxlIGFuZCwgaWYgbm90LCBkZXRlcm1pbmUgd2hhdCBpcy5cclxuICAgICAgbGV0IGFsbG93YWJsZVRyYW5zbGF0aW9uID0gbW9kZWwuY2hlY2tQcm9wb3NlZE1hZ25ldE1vdGlvbiggcHJvcG9zZWRUcmFuc2xhdGlvbiApO1xyXG5cclxuICAgICAgLy8gSWYgdGhlIGFsbG93YWJsZSB0cmFuc2xhdGlvbiB3b3JrcyBvdXQgdG8gYmUgemVybywgaXQgbWVhbnMgdGhhdCB0aGUgbWFnbmV0IGlzIHVwIGFnYWluc3QgYW4gb2JzdGFjbGUsIHNvIGdvXHJcbiAgICAgIC8vIHRoZSBvdGhlciBkaXJlY3Rpb24uXHJcbiAgICAgIGlmICggYWxsb3dhYmxlVHJhbnNsYXRpb24ubWFnbml0dWRlID09PSAwICkge1xyXG4gICAgICAgIHByZWZlcnJlZERpcmVjdGlvbiA9IHByZWZlcnJlZERpcmVjdGlvbiA9PT0gUklHSFQgPyBMRUZUIDogUklHSFQ7XHJcbiAgICAgICAgcHJvcG9zZWRUcmFuc2xhdGlvbiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgcHJlZmVycmVkRGlyZWN0aW9uID09PSBSSUdIVCA/IG1heFhQb3NpdGlvbiAtIG1hZ25ldFhQb3NpdGlvbiA6IG1pblhQb3NpdGlvbiAtIG1hZ25ldFhQb3NpdGlvbixcclxuICAgICAgICAgIDBcclxuICAgICAgICApO1xyXG4gICAgICAgIGFsbG93YWJsZVRyYW5zbGF0aW9uID0gbW9kZWwuY2hlY2tQcm9wb3NlZE1hZ25ldE1vdGlvbiggcHJvcG9zZWRUcmFuc2xhdGlvbiApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZXQgdGhlIG5ldyB0YXJnZXQgcG9zaXRpb24uXHJcbiAgICAgIHRoaXMuc2xpZGVUYXJnZXRQb3NpdGlvblByb3BlcnR5LnNldCggbW9kZWwubWFnbmV0LnBvc2l0aW9uUHJvcGVydHkudmFsdWUucGx1cyggYWxsb3dhYmxlVHJhbnNsYXRpb24gKSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUbyBhdm9pZCBvZGQgYmVoYXZpb3IsIHN0b3AgYW55IGluLXByb2dyZXNzIGFuaW1hdGlvbnMgaWYgdGhlIG51bWJlciBvZiBjb2lscyBjaGFuZ2UuXHJcbiAgICBtb2RlbC50b3BDb2lsVmlzaWJsZVByb3BlcnR5LmxpbmsoICgpID0+IHtcclxuICAgICAgaWYgKCB0aGlzLmlzQW5pbWF0aW5nUHJvcGVydHkudmFsdWUgKSB7XHJcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZ1Byb3BlcnR5LnNldCggZmFsc2UgKTtcclxuICAgICAgICB0aGlzLnNsaWRlVGFyZ2V0UG9zaXRpb25Qcm9wZXJ0eS5zZXQoIG1vZGVsLm1hZ25ldC5wb3NpdGlvblByb3BlcnR5LnZhbHVlICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBrZXkgZG93biBoYW5kbGVyXHJcbiAgICB0aGlzLmtleWRvd24gPSBldmVudCA9PiB7XHJcblxyXG4gICAgICAvLyBjaGVjayBpZiB0aGUga2V5IGlzIFwibW9kaWZpZWRcIlxyXG4gICAgICBsZXQga2V5TW9kaWZpZWQgPSBmYWxzZTtcclxuICAgICAgS0VZX01PRElGSUVSX0xJU1QuZm9yRWFjaCggbW9kaWZpZXJBcmcgPT4ge1xyXG4gICAgICAgIGtleU1vZGlmaWVkID0ga2V5TW9kaWZpZWQgfHwgZXZlbnQuZG9tRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSggbW9kaWZpZXJBcmcgKTtcclxuICAgICAgfSApO1xyXG5cclxuICAgICAgY29uc3Qga2V5ID0gS2V5Ym9hcmRVdGlscy5nZXRFdmVudENvZGUoIGV2ZW50LmRvbUV2ZW50ICk7XHJcblxyXG4gICAgICBpZiAoIGtleVRvU3BlZWRNYXAuaGFzKCBrZXkgKSAmJiAha2V5TW9kaWZpZWQgKSB7XHJcblxyXG4gICAgICAgIC8vIFNraXAgdGhlIGNoYW5nZXMgaWYgdGhpcyBrZXkgaXMgYWxyZWFkeSBkb3duLlxyXG4gICAgICAgIGlmICggIXRoaXMuYXV0b1NsaWRlS2V5SXNEb3duTWFwLmdldCgga2V5ICkgKSB7XHJcblxyXG4gICAgICAgICAgLy8gTWFyayB0aGlzIGtleSBhcyBiZWluZyBkb3duLlxyXG4gICAgICAgICAgdGhpcy5hdXRvU2xpZGVLZXlJc0Rvd25NYXAuc2V0KCBrZXksIHRydWUgKTtcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNsaWRlIHRhcmdldC5cclxuICAgICAgICAgIHVwZGF0ZVNsaWRlVGFyZ2V0KCk7XHJcblxyXG4gICAgICAgICAgLy8gSW5pdGlhdGUgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmdQcm9wZXJ0eS5zZXQoIHRydWUgKTtcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNwZWVkIGF0IHdoaWNoIHRoZSBtYWduZXQgd2lsbCBtb3ZlLlxyXG4gICAgICAgICAgdGhpcy50cmFuc2xhdGlvblNwZWVkID0ga2V5VG9TcGVlZE1hcC5nZXQoIGtleSApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICggdGhpcy5pc0FuaW1hdGluZ1Byb3BlcnR5LnZhbHVlICkge1xyXG5cclxuICAgICAgICAvLyBBbnkga2V5IHByZXNzIHRoYXQgaXMgbm90IG9uZSBvZiB0aGUgYXV0by1zbGlkZSBrZXlzIHNob3VsZCBzdG9wIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZ1Byb3BlcnR5LnNldCggZmFsc2UgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW52b2tlIHRoZSBjbGllbnQtcHJvdmlkZWQgaGFuZGxlciAodGhpcyBkb2VzIG5vdGhpbmcgaWYgdGhlIGNsaWVudCBkaWRuJ3QgcHJvdmlkZSBvbmUpLlxyXG4gICAgICBvcHRpb25zLm9uS2V5RG93biggZXZlbnQgKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gZnVuY3Rpb24gZm9yIG1hcHBpbmcgc3BlZWQgbGluZWFybHksIHdoaWNoIGlzIHRoZW4gdXNlZCB0byBtYXAgaXQgdG8gdGV4dCBmb3IgYTExeVxyXG4gICAgY29uc3Qgc3BlZWRUb1RleHQgPSBuZXcgTGluZWFyRnVuY3Rpb24oIDAsIGZhc3RTcGVlZCwgMCwgMjAwLCB0cnVlICk7XHJcblxyXG4gICAgLy8ga2V5IHVwIGhhbmRsZXJcclxuICAgIHRoaXMua2V5dXAgPSBldmVudCA9PiB7XHJcblxyXG4gICAgICBjb25zdCByZWxlYXNlZEtleSA9IGV2ZW50LmRvbUV2ZW50LmNvZGU7XHJcblxyXG4gICAgICBpZiAoIGtleVRvU3BlZWRNYXAuaGFzKCByZWxlYXNlZEtleSApICkge1xyXG4gICAgICAgIHRoaXMuYXV0b1NsaWRlS2V5SXNEb3duTWFwLnNldCggcmVsZWFzZWRLZXksIGZhbHNlICk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNwZWVkVG9UZXh0VmFsdWUgPSBVdGlscy5yb3VuZFN5bW1ldHJpYyggc3BlZWRUb1RleHQuZXZhbHVhdGUoIHRoaXMudHJhbnNsYXRpb25TcGVlZCApICk7XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5tb2RlbC5tYWduZXQucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZS54IDwgdGhpcy5zbGlkZVRhcmdldFBvc2l0aW9uUHJvcGVydHkudmFsdWUueCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUklHSFQgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIExFRlQ7XHJcbiAgICAgICAgRmFyYWRheXNMYXdBbGVydE1hbmFnZXIubWFnbmV0U2xpZGluZ0FsZXJ0KCBzcGVlZFRvVGV4dFZhbHVlLCBkaXJlY3Rpb24gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW52b2tlIHRoZSBjbGllbnQtcHJvdmlkZWQgaGFuZGxlciAodGhpcyBkb2VzIG5vdGhpbmcgaWYgdGhlIGNsaWVudCBkaWRuJ3QgcHJvdmlkZSBvbmUpLlxyXG4gICAgICBvcHRpb25zLm9uS2V5VXAoIGV2ZW50ICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEhhbmRsZXIgZm9yIHRoZSBjYXNlIHdoZXJlIHRoZSBtYWduZXQgaXMgcmVsZWFzZWQgZnJvbSBhMTF5IGZvY3VzLiAgSWYgYSBrZXkgaXMgZG93biB3aGVuIHRoZSBtYWduZXQgaXMgcmVsZWFzZWQsXHJcbiAgICAvLyBzdWJzZXF1ZW50IGtleSB1cCBtZXNzYWdlcyB3b24ndCBiZSByZWNlaXZlZCwgc28gd2UgbmVlZCB0byBjbGVhciBhbnkga2V5cyB0aGF0IGFyZSBkb3duLCBzZWVcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9mYXJhZGF5cy1sYXcvaXNzdWVzLzIxNC5cclxuICAgIHRoaXMucmVsZWFzZWQgPSAoKSA9PiB7XHJcblxyXG4gICAgICAvLyBNYXJrIGFsbCBrZXlzIGFzIHVwLlxyXG4gICAgICB0aGlzLmF1dG9TbGlkZUtleUlzRG93bk1hcC5mb3JFYWNoKCAoIHZhbHVlLCBrZXkgKSA9PiB7XHJcbiAgICAgICAgdGhpcy5hdXRvU2xpZGVLZXlJc0Rvd25NYXAuc2V0KCBrZXksIGZhbHNlICk7XHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSBhbmltYXRpb24gaXMgb2ZmLlxyXG4gICAgICB0aGlzLmlzQW5pbWF0aW5nUHJvcGVydHkuc2V0KCBmYWxzZSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTdG9wIHRoZSBhbmltYXRpb24gaWYgdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYWduZXQuXHJcbiAgICBtb2RlbC5tYWduZXQuaXNEcmFnZ2luZ1Byb3BlcnR5LmxpbmsoIGlzRHJhZ2dpbmcgPT4ge1xyXG4gICAgICBpZiAoIGlzRHJhZ2dpbmcgKSB7XHJcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZ1Byb3BlcnR5LnNldCggZmFsc2UgKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIHN0ZXAgdGhlIGRyYWcgbGlzdGVuZXIsIG11c3QgYmUgcmVtb3ZlZCBpbiBkaXNwb3NlXHJcbiAgICBjb25zdCBzdGVwTGlzdGVuZXIgPSB0aGlzLnN0ZXAuYmluZCggdGhpcyApO1xyXG4gICAgc3RlcFRpbWVyLmFkZExpc3RlbmVyKCBzdGVwTGlzdGVuZXIgKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSAtIGNhbGxlZCBpbiBkaXNwb3NlXHJcbiAgICB0aGlzLl9kaXNwb3NlS2V5Ym9hcmREcmFnTGlzdGVuZXIgPSAoKSA9PiB7XHJcbiAgICAgIHN0ZXBUaW1lci5yZW1vdmVMaXN0ZW5lciggc3RlcExpc3RlbmVyICk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdCAtIGluIHNlY29uZHNcclxuICAgKi9cclxuICBzdGVwKCBkdCApIHtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbnkgb2YgdGhlIGF1dG8tc2xpZGUga2V5cyBhcmUgY3VycmVudGx5IHByZXNzZWQuXHJcbiAgICBsZXQgYXV0b1NsaWRlS2V5UHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgZm9yICggY29uc3QgaXNLZXlEb3duIG9mIHRoaXMuYXV0b1NsaWRlS2V5SXNEb3duTWFwLnZhbHVlcygpICkge1xyXG4gICAgICBpZiAoIGlzS2V5RG93biApIHtcclxuICAgICAgICBhdXRvU2xpZGVLZXlQcmVzc2VkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIGFuIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcyBhbmQgbm9uZSBvZiB0aGUgYXV0by1zbGlkZSBrZXlzIGFyZSBwcmVzc2VkLCBtb3ZlIHRoZSBtYWduZXQgdG93YXJkcyB0aGUgdGFyZ2V0LlxyXG4gICAgaWYgKCB0aGlzLmlzQW5pbWF0aW5nUHJvcGVydHkudmFsdWUgJiYgIWF1dG9TbGlkZUtleVByZXNzZWQgKSB7XHJcbiAgICAgIGNvbnN0IG1hZ25ldFBvc2l0aW9uID0gdGhpcy5tb2RlbC5tYWduZXQucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZTtcclxuICAgICAgaWYgKCAhbWFnbmV0UG9zaXRpb24uZXF1YWxzKCB0aGlzLnNsaWRlVGFyZ2V0UG9zaXRpb25Qcm9wZXJ0eS52YWx1ZSApICkge1xyXG5cclxuICAgICAgICBjb25zdCBkZWx0YVhUb1RhcmdldCA9IHRoaXMuc2xpZGVUYXJnZXRQb3NpdGlvblByb3BlcnR5LnZhbHVlLnggLSBtYWduZXRQb3NpdGlvbi54O1xyXG4gICAgICAgIGxldCB1bmNvbnN0cmFpbmVkTmV3UG9zaXRpb247XHJcbiAgICAgICAgaWYgKCBNYXRoLmFicyggZGVsdGFYVG9UYXJnZXQgKSA8PSBkdCAqIHRoaXMudHJhbnNsYXRpb25TcGVlZCApIHtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgbWFnbmV0IGlzIGFsbW9zdCB0byB0aGUgdGFyZ2V0IHBvc2l0aW9uLCBzbyBqdXN0IG1vdmUgaXQgdGhlcmUuXHJcbiAgICAgICAgICB1bmNvbnN0cmFpbmVkTmV3UG9zaXRpb24gPSB0aGlzLnNsaWRlVGFyZ2V0UG9zaXRpb25Qcm9wZXJ0eS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZVNpZ24gPSBkZWx0YVhUb1RhcmdldCA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgICBjb25zdCBkZWx0YVZlY3RvciA9IG5ldyBWZWN0b3IyKCBkaXN0YW5jZVNpZ24gKiB0aGlzLnRyYW5zbGF0aW9uU3BlZWQgKiBkdCwgMCApO1xyXG4gICAgICAgICAgdW5jb25zdHJhaW5lZE5ld1Bvc2l0aW9uID0gbWFnbmV0UG9zaXRpb24ucGx1cyggZGVsdGFWZWN0b3IgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmV3IHBvc2l0aW9uIGRvZXNuJ3QgcHV0IHRoZSBtYWduZXQgb3V0c2lkZSBvZiB0aGUgZHJhZyBib3VuZHMuXHJcbiAgICAgICAgY29uc3QgY29uc3RyYWluZWROZXdQb3NpdGlvbiA9IHRoaXMuX2NvbnN0cmFpbmVkRHJhZ0JvdW5kcy5jbG9zZXN0UG9pbnRUbyggdW5jb25zdHJhaW5lZE5ld1Bvc2l0aW9uICk7XHJcblxyXG4gICAgICAgIC8vIE1vdmUgdGhlIG1hZ25ldC5cclxuICAgICAgICB0aGlzLm1vZGVsLm1vdmVNYWduZXRUb1Bvc2l0aW9uKCBjb25zdHJhaW5lZE5ld1Bvc2l0aW9uICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHRoZSBtYWduZXQgaXMgbm93IGF0IHRoZSBkZXN0aW5hdGlvbiwgY2xlYXIgdGhlIGFuaW1hdGlvbiBmbGFnLlxyXG4gICAgICBpZiAoIG1hZ25ldFBvc2l0aW9uLmVxdWFscyggdGhpcy5zbGlkZVRhcmdldFBvc2l0aW9uUHJvcGVydHkudmFsdWUgKSApIHtcclxuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nUHJvcGVydHkuc2V0KCBmYWxzZSApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2VLZXlib2FyZERyYWdMaXN0ZW5lcigpO1xyXG4gIH1cclxufVxyXG5cclxuZmFyYWRheXNMYXcucmVnaXN0ZXIoICdNYWduZXRBdXRvU2xpZGVLZXlib2FyZExpc3RlbmVyJywgTWFnbmV0QXV0b1NsaWRlS2V5Ym9hcmRMaXN0ZW5lciApO1xyXG5leHBvcnQgZGVmYXVsdCBNYWduZXRBdXRvU2xpZGVLZXlib2FyZExpc3RlbmVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsZUFBZSxNQUFNLHdDQUF3QztBQUNwRSxPQUFPQyxTQUFTLE1BQU0sa0NBQWtDO0FBQ3hELE9BQU9DLGNBQWMsTUFBTSxzQ0FBc0M7QUFDakUsT0FBT0MsS0FBSyxNQUFNLDZCQUE2QjtBQUMvQyxPQUFPQyxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELE9BQU9DLGVBQWUsTUFBTSx1Q0FBdUM7QUFDbkUsT0FBT0MsS0FBSyxNQUFNLG1DQUFtQztBQUNyRCxTQUFTQyxhQUFhLFFBQVEsbUNBQW1DO0FBQ2pFLE9BQU9DLFdBQVcsTUFBTSxzQkFBc0I7QUFDOUMsT0FBT0Msb0JBQW9CLE1BQU0sNEJBQTRCO0FBQzdELE9BQU9DLG1CQUFtQixNQUFNLGlDQUFpQztBQUNqRSxPQUFPQyx1QkFBdUIsTUFBTSw4QkFBOEI7O0FBRWxFO0FBQ0EsTUFBTTtFQUFFQyxJQUFJO0VBQUVDO0FBQU0sQ0FBQyxHQUFHSCxtQkFBbUI7QUFDM0MsTUFBTUksaUJBQWlCLEdBQUdMLG9CQUFvQixDQUFDTSxZQUFZLEdBQUcsQ0FBQztBQUMvRCxNQUFNQyxrQkFBa0IsR0FBR1Asb0JBQW9CLENBQUNRLGFBQWEsR0FBRyxDQUFDOztBQUVqRTtBQUNBLE1BQU1DLGdCQUFnQixHQUFHWCxhQUFhLENBQUNZLEtBQUs7QUFDNUMsTUFBTUMsZ0JBQWdCLEdBQUdiLGFBQWEsQ0FBQ2MsS0FBSztBQUM1QyxNQUFNQyxnQkFBZ0IsR0FBR2YsYUFBYSxDQUFDZ0IsS0FBSzs7QUFFNUM7QUFDQSxNQUFNQyxpQkFBaUIsR0FBRyxDQUFFLFNBQVMsRUFBRSxLQUFLLENBQUU7QUFFOUMsTUFBTUMsK0JBQStCLENBQUM7RUFFcENDLFdBQVdBLENBQUVDLEtBQUssRUFBRUMsT0FBTyxFQUFHO0lBQzVCQSxPQUFPLEdB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