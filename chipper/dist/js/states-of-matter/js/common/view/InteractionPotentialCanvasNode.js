// Copyright 2015-2021, University of Colorado Boulder

/**
 * This type draws the interaction potential curve on a canvas.  This is done instead of using the Path node because
 * the curve requires numerous points and is therefore costly to render using a Path node.
 *
 * @author Chandrashekar Bemagoni (Actual Concepts)
 * @author John Blanco
 */

import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import ArrowShape from '../../../../scenery-phet/js/ArrowShape.js';
import { CanvasNode } from '../../../../scenery/js/imports.js';
import statesOfMatter from '../../statesOfMatter.js';

// constants
const AXIS_LINE_WIDTH = 1;
const AXES_ARROW_HEAD_HEIGHT = 8 * AXIS_LINE_WIDTH;
const SIGMA_HANDLE_OFFSET_PROPORTION = 0.08; // Position of handle as function of node width.
const EPSILON_LINE_WIDTH = 1;
class InteractionPotentialCanvasNode extends CanvasNode {
  /**
   * @param {PotentialGraphNode} potentialGraphNode
   * @param {Object} [options] that can be passed on to the underlying node
   */
  constructor(potentialGraphNode, options) {
    super(options);
    this.potentialGraph = potentialGraphNode; // @private

    // @private {number[]} - ror efficiency, pre-allocate the array that represents the Y positions of the curve.  The X
    // positions are the indexes into the array.
    this.curveYPositions = new Array(Utils.roundSymmetric(potentialGraphNode.graphWidth));

    // @private {Vector2} - reusable vector for positioning the epsilon arrow
    this.epsilonArrowStartPoint = new Vector2(0, 0);
  }

  /**
   * Paints the potential energy curve.
   * @param {CanvasRenderingContext2D} context
   * @public
   */
  paintCanvas(context) {
    context.beginPath();
    context.moveTo(0, 0);
    for (let i = 1; i < this.curveYPositions.length; i++) {
      const yPos = this.curveYPositions[i];
      if (yPos > 0 && yPos < this.potentialGraph.graphHeight) {
        // This point is on the graph, draw a line to it.
        context.lineTo(i + this.potentialGraph.graphXOrigin, yPos + AXES_ARROW_HEAD_HEIGHT);
      } else {
        // This line is off the graph - move to a good position from which to start or continue graphing.
        if (yPos < 0) {
          context.moveTo(i + 1 + this.potentialGraph.graphXOrigin, AXES_ARROW_HEAD_HEIGHT);
        } else {
          context.lineTo(i + this.potentialGraph.graphXOrigin, this.potentialGraph.graphHeight + AXES_ARROW_HEAD_HEIGHT);
        }
      }
    }
    context.strokeStyle = this.strokeColor;
    context.lineWidth = 2;
    context.stroke();
  }

  /**
   * @param {Color} color
   * @public
   */
  update(color) {
    this.strokeColor = color.toCSS();

    // Calculate the points that comprise the curve and record several key values along the way the will be used to
    // position the various arrows and labels.
    this.potentialGraph.graphMin.setXY(0, 0);
    this.potentialGraph.zeroCrossingPoint.setXY(0, 0);
    const sigmaHandleYPos = this.potentialGraph.getGraphHeight() / 2 - 2 * SIGMA_HANDLE_OFFSET_PROPORTION * this.potentialGraph.heightOfGraph;
    let sigmaHandleXPos = 0;
    const horizontalIndexMultiplier = this.potentialGraph.xRange / this.potentialGraph.graphWidth;
    let previousPotential = Number.POSITIVE_INFINITY;
    let previousYPos = Number.NEGATIVE_INFINITY;
    for (let i = 1; i < this.potentialGraph.graphWidth; i++) {
      const potential = this.potentialGraph.calculateLennardJonesPotential(i * horizontalIndexMultiplier);
      const yPos = this.potentialGraph.graphHeight / 2 - potential * this.potentialGraph.verticalScalingFactor;

      // Record the data that will be used in the paintCanvas method to render the curve.
      this.curveYPositions[i] = yPos;

      // Record the position of the min Y value since the epsilon arrow needs to be positioned near this point.
      if (yPos > this.potentialGraph.graphMin.y) {
        this.potentialGraph.graphMin.setXY(i, yPos);
      }

      // Record the point where the sigma resize handle should be positioned.
      if (yPos > sigmaHandleYPos && previousYPos < sigmaHandleYPos) {
        sigmaHandleXPos = i;
      }

      // Record the zero crossing point since the sigma arrow will need to use it to set its size and position.
      if (previousPotential > 0 && potential < 0) {
        this.potentialGraph.zeroCrossingPoint.setXY(i, this.potentialGraph.graphHeight / 2);
      }
      previousPotential = potential;
      previousYPos = yPos;
    }

    // Position the epsilon arrow, which is a vertical double-headed arrow between the bottom of the well and the x axis.
    this.epsilonArrowStartPoint.setXY(this.potentialGraph.graphMin.x, this.potentialGraph.graphHeight / 2);
    if (this.epsilonArrowStartPoint.distance(this.potentialGraph.graphMin) > 5) {
      this.potentialGraph.epsilonArrow.setVisible(true);
      const doubleHead = this.potentialGraph.graphMin.y <= this.potentialGraph.graphHeight || this.potentialGraph.graphMin.y - 10 < this.potentialGraph.graphHeight;
      const tailY = this.potentialGraph.graphMin.y > this.potentialGraph.graphHeight ? this.potentialGraph.graphHeight : this.potentialGraph.graphMin.y;
      this.potentialGraph.epsilonArrowShape = new ArrowShape(this.potentialGraph.graphMin.x, tailY, this.epsilonArrowStartPoint.x, this.epsilonArrowStartPoint.y, {
        doubleHead: doubleHead,
        headHeight: 5,
        headWidth: 6,
        tailWidth: 2
      });
      this.potentialGraph.epsilonArrow.setShape(this.potentialGraph.epsilonArrowShape);
    } else {
      // Don't show the arrow if there isn't enough space.
      this.potentialGraph.epsilonArrow.setVisible(false);
    }

    // Position the epsilon label.
    this.potentialGraph.epsilonLabel.left = this.potentialGraph.graphMin.x - 2;
    this.potentialGraph.epsilonLabel.bottom = this.potentialGraph.graphHeight / 2 - 2;

    // Position the arrow that depicts sigma, which is a horizontal double-headed arrow between the y axis and the
    // first point at which the potential crosses the x axis.
    this.potentialGraph.sigmaArrow.setTailAndTip(0, this.potentialGraph.graphHeight / 2, this.potentialGraph.zeroCrossingPoint.x, this.potentialGraph.zeroCrossingPoint.y);

    // Position the sigma label.
    this.potentialGraph.sigmaLabel.setTranslation(this.potentialGraph.zeroCrossingPoint.x / 2 - this.potentialGraph.sigmaLabel.width / 2, this.potentialGraph.graphHeight / 2 - this.potentialGraph.sigmaLabel.height / 3);

    // If the interaction potential graph includes a position marker, update its position in case the curve has moved.
    if (this.potentialGraph.positionMarker) {
      this.potentialGraph.setMarkerPosition(this.potentialGraph.markerDistance);
    }

    // Position the control handles if used.
    if (this.potentialGraph.epsilonControls.arrow) {
      const graphMin = this.potentialGraph.getGraphMin();
      this.potentialGraph.epsilonControls.line.setTranslation(graphMin.x, graphMin.y + EPSILON_LINE_WIDTH);
      this.potentialGraph.epsilonControls.arrow.setVisible(this.potentialGraph.interactionEnabled);
      this.potentialGraph.epsilonControls.line.setVisible(this.potentialGraph.interactionEnabled);
      this.potentialGraph.epsilonControls.arrow.centerX = this.potentialGraph.epsilonControls.line.right;
      this.potentialGraph.epsilonControls.arrow.centerY = this.potentialGraph.epsilonControls.line.centerY;
    }
    if (this.potentialGraph.sigmaControls.arrow) {
      this.potentialGraph.sigmaControls.arrow.centerX = sigmaHandleXPos;
      this.potentialGraph.sigmaControls.arrow.centerY = sigmaHandleYPos;
      this.potentialGraph.sigmaControls.arrow.setVisible(this.potentialGraph.interactionEnabled);
    }

    // indicate that this should be repainted during the next paint cycle
    this.invalidatePaint();
  }
}
statesOfMatter.register('InteractionPotentialCanvasNode', InteractionPotentialCanvasNode);
export default InteractionPotentialCanvasNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJVdGlscyIsIlZlY3RvcjIiLCJBcnJvd1NoYXBlIiwiQ2FudmFzTm9kZSIsInN0YXRlc09mTWF0dGVyIiwiQVhJU19MSU5FX1dJRFRIIiwiQVhFU19BUlJPV19IRUFEX0hFSUdIVCIsIlNJR01BX0hBTkRMRV9PRkZTRVRfUFJPUE9SVElPTiIsIkVQU0lMT05fTElORV9XSURUSCIsIkludGVyYWN0aW9uUG90ZW50aWFsQ2FudmFzTm9kZSIsImNvbnN0cnVjdG9yIiwicG90ZW50aWFsR3JhcGhOb2RlIiwib3B0aW9ucyIsInBvdGVudGlhbEdyYXBoIiwiY3VydmVZUG9zaXRpb25zIiwiQXJyYXkiLCJyb3VuZFN5bW1ldHJpYyIsImdyYXBoV2lkdGgiLCJlcHNpbG9uQXJyb3dTdGFydFBvaW50IiwicGFpbnRDYW52YXMiLCJjb250ZXh0IiwiYmVnaW5QYXRoIiwibW92ZVRvIiwiaSIsImxlbmd0aCIsInlQb3MiLCJncmFwaEhlaWdodCIsImxpbmVUbyIsImdyYXBoWE9yaWdpbiIsInN0cm9rZVN0eWxlIiwic3Ryb2tlQ29sb3IiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJ1cGRhdGUiLCJjb2xvciIsInRvQ1NTIiwiZ3JhcGhNaW4iLCJzZXRYWSIsInplcm9Dcm9zc2luZ1BvaW50Iiwic2lnbWFIYW5kbGVZUG9zIiwiZ2V0R3JhcGhIZWlnaHQiLCJoZWlnaHRPZkdyYXBoIiwic2lnbWFIYW5kbGVYUG9zIiwiaG9yaXpvbnRhbEluZGV4TXVsdGlwbGllciIsInhSYW5nZSIsInByZXZpb3VzUG90ZW50aWFsIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJwcmV2aW91c1lQb3MiLCJORUdBVElWRV9JTkZJTklUWSIsInBvdGVudGlhbCIsImNhbGN1bGF0ZUxlbm5hcmRKb25lc1BvdGVudGlhbCIsInZlcnRpY2FsU2NhbGluZ0ZhY3RvciIsInkiLCJ4IiwiZGlzdGFuY2UiLCJlcHNpbG9uQXJyb3ciLCJzZXRWaXNpYmxlIiwiZG91YmxlSGVhZCIsInRhaWxZIiwiZXBzaWxvbkFycm93U2hhcGUiLCJoZWFkSGVpZ2h0IiwiaGVhZFdpZHRoIiwidGFpbFdpZHRoIiwic2V0U2hhcGUiLCJlcHNpbG9uTGFiZWwiLCJsZWZ0IiwiYm90dG9tIiwic2lnbWFBcnJvdyIsInNldFRhaWxBbmRUaXAiLCJzaWdtYUxhYmVsIiwic2V0VHJhbnNsYXRpb24iLCJ3aWR0aCIsImhlaWdodCIsInBvc2l0aW9uTWFya2VyIiwic2V0TWFya2VyUG9zaXRpb24iLCJtYXJrZXJEaXN0YW5jZSIsImVwc2lsb25Db250cm9scyIsImFycm93IiwiZ2V0R3JhcGhNaW4iLCJsaW5lIiwiaW50ZXJhY3Rpb25FbmFibGVkIiwiY2VudGVyWCIsInJpZ2h0IiwiY2VudGVyWSIsInNpZ21hQ29udHJvbHMiLCJpbnZhbGlkYXRlUGFpbnQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIkludGVyYWN0aW9uUG90ZW50aWFsQ2FudmFzTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNS0yMDIxLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHR5cGUgZHJhd3MgdGhlIGludGVyYWN0aW9uIHBvdGVudGlhbCBjdXJ2ZSBvbiBhIGNhbnZhcy4gIFRoaXMgaXMgZG9uZSBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBQYXRoIG5vZGUgYmVjYXVzZVxyXG4gKiB0aGUgY3VydmUgcmVxdWlyZXMgbnVtZXJvdXMgcG9pbnRzIGFuZCBpcyB0aGVyZWZvcmUgY29zdGx5IHRvIHJlbmRlciB1c2luZyBhIFBhdGggbm9kZS5cclxuICpcclxuICogQGF1dGhvciBDaGFuZHJhc2hla2FyIEJlbWFnb25pIChBY3R1YWwgQ29uY2VwdHMpXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICovXHJcblxyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgQXJyb3dTaGFwZSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvQXJyb3dTaGFwZS5qcyc7XHJcbmltcG9ydCB7IENhbnZhc05vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgc3RhdGVzT2ZNYXR0ZXIgZnJvbSAnLi4vLi4vc3RhdGVzT2ZNYXR0ZXIuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IEFYSVNfTElORV9XSURUSCA9IDE7XHJcbmNvbnN0IEFYRVNfQVJST1dfSEVBRF9IRUlHSFQgPSA4ICogQVhJU19MSU5FX1dJRFRIO1xyXG5jb25zdCBTSUdNQV9IQU5ETEVfT0ZGU0VUX1BST1BPUlRJT04gPSAwLjA4OyAgLy8gUG9zaXRpb24gb2YgaGFuZGxlIGFzIGZ1bmN0aW9uIG9mIG5vZGUgd2lkdGguXHJcbmNvbnN0IEVQU0lMT05fTElORV9XSURUSCA9IDE7XHJcblxyXG5jbGFzcyBJbnRlcmFjdGlvblBvdGVudGlhbENhbnZhc05vZGUgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQb3RlbnRpYWxHcmFwaE5vZGV9IHBvdGVudGlhbEdyYXBoTm9kZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhhdCBjYW4gYmUgcGFzc2VkIG9uIHRvIHRoZSB1bmRlcmx5aW5nIG5vZGVcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggcG90ZW50aWFsR3JhcGhOb2RlLCBvcHRpb25zICkge1xyXG4gICAgc3VwZXIoIG9wdGlvbnMgKTtcclxuICAgIHRoaXMucG90ZW50aWFsR3JhcGggPSBwb3RlbnRpYWxHcmFwaE5vZGU7IC8vIEBwcml2YXRlXHJcblxyXG4gICAgLy8gQHByaXZhdGUge251bWJlcltdfSAtIHJvciBlZmZpY2llbmN5LCBwcmUtYWxsb2NhdGUgdGhlIGFycmF5IHRoYXQgcmVwcmVzZW50cyB0aGUgWSBwb3NpdGlvbnMgb2YgdGhlIGN1cnZlLiAgVGhlIFhcclxuICAgIC8vIHBvc2l0aW9ucyBhcmUgdGhlIGluZGV4ZXMgaW50byB0aGUgYXJyYXkuXHJcbiAgICB0aGlzLmN1cnZlWVBvc2l0aW9ucyA9IG5ldyBBcnJheSggVXRpbHMucm91bmRTeW1tZXRyaWMoIHBvdGVudGlhbEdyYXBoTm9kZS5ncmFwaFdpZHRoICkgKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7VmVjdG9yMn0gLSByZXVzYWJsZSB2ZWN0b3IgZm9yIHBvc2l0aW9uaW5nIHRoZSBlcHNpbG9uIGFycm93XHJcbiAgICB0aGlzLmVwc2lsb25BcnJvd1N0YXJ0UG9pbnQgPSBuZXcgVmVjdG9yMiggMCwgMCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFpbnRzIHRoZSBwb3RlbnRpYWwgZW5lcmd5IGN1cnZlLlxyXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHBhaW50Q2FudmFzKCBjb250ZXh0ICkge1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQubW92ZVRvKCAwLCAwICk7XHJcbiAgICBmb3IgKCBsZXQgaSA9IDE7IGkgPCB0aGlzLmN1cnZlWVBvc2l0aW9ucy5sZW5ndGg7IGkrKyApIHtcclxuXHJcbiAgICAgIGNvbnN0IHlQb3MgPSB0aGlzLmN1cnZlWVBvc2l0aW9uc1sgaSBdO1xyXG5cclxuICAgICAgaWYgKCAoIHlQb3MgPiAwICkgJiYgKCB5UG9zIDwgdGhpcy5wb3RlbnRpYWxHcmFwaC5ncmFwaEhlaWdodCApICkge1xyXG5cclxuICAgICAgICAvLyBUaGlzIHBvaW50IGlzIG9uIHRoZSBncmFwaCwgZHJhdyBhIGxpbmUgdG8gaXQuXHJcbiAgICAgICAgY29udGV4dC5saW5lVG8oIGkgKyB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoWE9yaWdpbiwgeVBvcyArIEFYRVNfQVJST1dfSEVBRF9IRUlHSFQgKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBsaW5lIGlzIG9mZiB0aGUgZ3JhcGggLSBtb3ZlIHRvIGEgZ29vZCBwb3NpdGlvbiBmcm9tIHdoaWNoIHRvIHN0YXJ0IG9yIGNvbnRpbnVlIGdyYXBoaW5nLlxyXG4gICAgICAgIGlmICggeVBvcyA8IDAgKSB7XHJcbiAgICAgICAgICBjb250ZXh0Lm1vdmVUbyggaSArIDEgKyB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoWE9yaWdpbiwgQVhFU19BUlJPV19IRUFEX0hFSUdIVCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGNvbnRleHQubGluZVRvKFxyXG4gICAgICAgICAgICBpICsgdGhpcy5wb3RlbnRpYWxHcmFwaC5ncmFwaFhPcmlnaW4sXHJcbiAgICAgICAgICAgIHRoaXMucG90ZW50aWFsR3JhcGguZ3JhcGhIZWlnaHQgKyBBWEVTX0FSUk9XX0hFQURfSEVJR0hUXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlQ29sb3I7XHJcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDI7XHJcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtDb2xvcn0gY29sb3JcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgdXBkYXRlKCBjb2xvciApIHtcclxuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBjb2xvci50b0NTUygpO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9pbnRzIHRoYXQgY29tcHJpc2UgdGhlIGN1cnZlIGFuZCByZWNvcmQgc2V2ZXJhbCBrZXkgdmFsdWVzIGFsb25nIHRoZSB3YXkgdGhlIHdpbGwgYmUgdXNlZCB0b1xyXG4gICAgLy8gcG9zaXRpb24gdGhlIHZhcmlvdXMgYXJyb3dzIGFuZCBsYWJlbHMuXHJcbiAgICB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoTWluLnNldFhZKCAwLCAwICk7XHJcbiAgICB0aGlzLnBvdGVudGlhbEdyYXBoLnplcm9Dcm9zc2luZ1BvaW50LnNldFhZKCAwLCAwICk7XHJcbiAgICBjb25zdCBzaWdtYUhhbmRsZVlQb3MgPSAoIHRoaXMucG90ZW50aWFsR3JhcGguZ2V0R3JhcGhIZWlnaHQoKSAvIDIgKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyICogU0lHTUFfSEFORExFX09GRlNFVF9QUk9QT1JUSU9OICogdGhpcy5wb3RlbnRpYWxHcmFwaC5oZWlnaHRPZkdyYXBoO1xyXG4gICAgbGV0IHNpZ21hSGFuZGxlWFBvcyA9IDA7XHJcbiAgICBjb25zdCBob3Jpem9udGFsSW5kZXhNdWx0aXBsaWVyID0gdGhpcy5wb3RlbnRpYWxHcmFwaC54UmFuZ2UgLyB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoV2lkdGg7XHJcbiAgICBsZXQgcHJldmlvdXNQb3RlbnRpYWwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICBsZXQgcHJldmlvdXNZUG9zID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG4gICAgZm9yICggbGV0IGkgPSAxOyBpIDwgdGhpcy5wb3RlbnRpYWxHcmFwaC5ncmFwaFdpZHRoOyBpKysgKSB7XHJcbiAgICAgIGNvbnN0IHBvdGVudGlhbCA9IHRoaXMucG90ZW50aWFsR3JhcGguY2FsY3VsYXRlTGVubmFyZEpvbmVzUG90ZW50aWFsKCBpICogaG9yaXpvbnRhbEluZGV4TXVsdGlwbGllciApO1xyXG4gICAgICBjb25zdCB5UG9zID0gKCAoIHRoaXMucG90ZW50aWFsR3JhcGguZ3JhcGhIZWlnaHQgLyAyICkgLSAoIHBvdGVudGlhbCAqIHRoaXMucG90ZW50aWFsR3JhcGgudmVydGljYWxTY2FsaW5nRmFjdG9yICkgKTtcclxuXHJcbiAgICAgIC8vIFJlY29yZCB0aGUgZGF0YSB0aGF0IHdpbGwgYmUgdXNlZCBpbiB0aGUgcGFpbnRDYW52YXMgbWV0aG9kIHRvIHJlbmRlciB0aGUgY3VydmUuXHJcbiAgICAgIHRoaXMuY3VydmVZUG9zaXRpb25zWyBpIF0gPSB5UG9zO1xyXG5cclxuICAgICAgLy8gUmVjb3JkIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWluIFkgdmFsdWUgc2luY2UgdGhlIGVwc2lsb24gYXJyb3cgbmVlZHMgdG8gYmUgcG9zaXRpb25lZCBuZWFyIHRoaXMgcG9pbnQuXHJcbiAgICAgIGlmICggeVBvcyA+IHRoaXMucG90ZW50aWFsR3JhcGguZ3JhcGhNaW4ueSApIHtcclxuICAgICAgICB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoTWluLnNldFhZKCBpLCB5UG9zICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlY29yZCB0aGUgcG9pbnQgd2hlcmUgdGhlIHNpZ21hIHJlc2l6ZSBoYW5kbGUgc2hvdWxkIGJlIHBvc2l0aW9uZWQuXHJcbiAgICAgIGlmICggeVBvcyA+IHNpZ21hSGFuZGxlWVBvcyAmJiBwcmV2aW91c1lQb3MgPCBzaWdtYUhhbmRsZVlQb3MgKSB7XHJcbiAgICAgICAgc2lnbWFIYW5kbGVYUG9zID0gaTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVjb3JkIHRoZSB6ZXJvIGNyb3NzaW5nIHBvaW50IHNpbmNlIHRoZSBzaWdtYSBhcnJvdyB3aWxsIG5lZWQgdG8gdXNlIGl0IHRvIHNldCBpdHMgc2l6ZSBhbmQgcG9zaXRpb24uXHJcbiAgICAgIGlmICggcHJldmlvdXNQb3RlbnRpYWwgPiAwICYmIHBvdGVudGlhbCA8IDAgKSB7XHJcbiAgICAgICAgdGhpcy5wb3RlbnRpYWxHcmFwaC56ZXJvQ3Jvc3NpbmdQb2ludC5zZXRYWSggaSwgdGhpcy5wb3RlbnRpYWxHcmFwaC5ncmFwaEhlaWdodCAvIDIgKTtcclxuICAgICAgfVxyXG4gICAgICBwcmV2aW91c1BvdGVudGlhbCA9IHBvdGVudGlhbDtcclxuICAgICAgcHJldmlvdXNZUG9zID0geVBvcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBQb3NpdGlvbiB0aGUgZXBzaWxvbiBhcnJvdywgd2hpY2ggaXMgYSB2ZXJ0aWNhbCBkb3VibGUtaGVhZGVkIGFycm93IGJldHdlZW4gdGhlIGJvdHRvbSBvZiB0aGUgd2VsbCBhbmQgdGhlIHggYXhpcy5cclxuICAgIHRoaXMuZXBzaWxvbkFycm93U3RhcnRQb2ludC5zZXRYWShcclxuICAgICAgdGhpcy5wb3RlbnRpYWxHcmFwaC5ncmFwaE1pbi54LFxyXG4gICAgICB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoSGVpZ2h0IC8gMlxyXG4gICAgKTtcclxuICAgIGlmICggdGhpcy5lcHNpbG9uQXJyb3dTdGFydFBvaW50LmRpc3RhbmNlKCB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoTWluICkgPiA1ICkge1xyXG4gICAgICB0aGlzLnBvdGVudGlhbEdyYXBoLmVwc2lsb25BcnJvdy5zZXRWaXNpYmxlKCB0cnVlICk7XHJcbiAgICAgIGNvbnN0IGRvdWJsZUhlYWQgPSB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoTWluLnkgPD0gdGhpcy5wb3RlbnRpYWxHcmFwaC5ncmFwaEhlaWdodCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3RlbnRpYWxHcmFwaC5ncmFwaE1pbi55IC0gMTAgPCB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoSGVpZ2h0O1xyXG4gICAgICBjb25zdCB0YWlsWSA9IHRoaXMucG90ZW50aWFsR3JhcGguZ3JhcGhNaW4ueSA+IHRoaXMucG90ZW50aWFsR3JhcGguZ3JhcGhIZWlnaHQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG90ZW50aWFsR3JhcGguZ3JhcGhIZWlnaHQgOiB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoTWluLnk7XHJcbiAgICAgIHRoaXMucG90ZW50aWFsR3JhcGguZXBzaWxvbkFycm93U2hhcGUgPSBuZXcgQXJyb3dTaGFwZShcclxuICAgICAgICB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoTWluLngsXHJcbiAgICAgICAgdGFpbFksXHJcbiAgICAgICAgdGhpcy5lcHNpbG9uQXJyb3dTdGFydFBvaW50LngsXHJcbiAgICAgICAgdGhpcy5lcHNpbG9uQXJyb3dTdGFydFBvaW50LnksXHJcbiAgICAgICAgeyBkb3VibGVIZWFkOiBkb3VibGVIZWFkLCBoZWFkSGVpZ2h0OiA1LCBoZWFkV2lkdGg6IDYsIHRhaWxXaWR0aDogMiB9XHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMucG90ZW50aWFsR3JhcGguZXBzaWxvbkFycm93LnNldFNoYXBlKCB0aGlzLnBvdGVudGlhbEdyYXBoLmVwc2lsb25BcnJvd1NoYXBlICk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gRG9uJ3Qgc2hvdyB0aGUgYXJyb3cgaWYgdGhlcmUgaXNuJ3QgZW5vdWdoIHNwYWNlLlxyXG4gICAgICB0aGlzLnBvdGVudGlhbEdyYXBoLmVwc2lsb25BcnJvdy5zZXRWaXNpYmxlKCBmYWxzZSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBvc2l0aW9uIHRoZSBlcHNpbG9uIGxhYmVsLlxyXG4gICAgdGhpcy5wb3RlbnRpYWxHcmFwaC5lcHNpbG9uTGFiZWwubGVmdCA9IHRoaXMucG90ZW50aWFsR3JhcGguZ3JhcGhNaW4ueCAtIDI7XHJcbiAgICB0aGlzLnBvdGVudGlhbEdyYXBoLmVwc2lsb25MYWJlbC5ib3R0b20gPSB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoSGVpZ2h0IC8gMiAtIDI7XHJcblxyXG4gICAgLy8gUG9zaXRpb24gdGhlIGFycm93IHRoYXQgZGVwaWN0cyBzaWdtYSwgd2hpY2ggaXMgYSBob3Jpem9udGFsIGRvdWJsZS1oZWFkZWQgYXJyb3cgYmV0d2VlbiB0aGUgeSBheGlzIGFuZCB0aGVcclxuICAgIC8vIGZpcnN0IHBvaW50IGF0IHdoaWNoIHRoZSBwb3RlbnRpYWwgY3Jvc3NlcyB0aGUgeCBheGlzLlxyXG4gICAgdGhpcy5wb3RlbnRpYWxHcmFwaC5zaWdtYUFycm93LnNldFRhaWxBbmRUaXAoXHJcbiAgICAgIDAsXHJcbiAgICAgIHRoaXMucG90ZW50aWFsR3JhcGguZ3JhcGhIZWlnaHQgLyAyLFxyXG4gICAgICB0aGlzLnBvdGVudGlhbEdyYXBoLnplcm9Dcm9zc2luZ1BvaW50LngsXHJcbiAgICAgIHRoaXMucG90ZW50aWFsR3JhcGguemVyb0Nyb3NzaW5nUG9pbnQueVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBQb3NpdGlvbiB0aGUgc2lnbWEgbGFiZWwuXHJcbiAgICB0aGlzLnBvdGVudGlhbEdyYXBoLnNpZ21hTGFiZWwuc2V0VHJhbnNsYXRpb24oXHJcbiAgICAgIHRoaXMucG90ZW50aWFsR3JhcGguemVyb0Nyb3NzaW5nUG9pbnQueCAvIDIgLSB0aGlzLnBvdGVudGlhbEdyYXBoLnNpZ21hTGFiZWwud2lkdGggLyAyLFxyXG4gICAgICB0aGlzLnBvdGVudGlhbEdyYXBoLmdyYXBoSGVpZ2h0IC8gMiAtIHRoaXMucG90ZW50aWFsR3JhcGguc2lnbWFMYWJlbC5oZWlnaHQgLyAzXHJcbiAgICApO1xyXG5cclxuICAgIC8vIElmIHRoZSBpbnRlcmFjdGlvbiBwb3RlbnRpYWwgZ3JhcGggaW5jbHVkZXMgYSBwb3NpdGlvbiBtYXJrZXIsIHVwZGF0ZSBpdHMgcG9zaXRpb24gaW4gY2FzZSB0aGUgY3VydmUgaGFzIG1vdmVkLlxyXG4gICAgaWYgKCB0aGlzLnBvdGVudGlhbEdyYXBoLnBvc2l0aW9uTWFya2VyICkge1xyXG4gICAgICB0aGlzLnBvdGVudGlhbEdyYXBoLnNldE1hcmtlclBvc2l0aW9uKCB0aGlzLnBvdGVudGlhbEdyYXBoLm1hcmtlckRpc3RhbmNlICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUG9zaXRpb24gdGhlIGNvbnRyb2wgaGFuZGxlcyBpZiB1c2VkLlxyXG4gICAgaWYgKCB0aGlzLnBvdGVudGlhbEdyYXBoLmVwc2lsb25Db250cm9scy5hcnJvdyApIHtcclxuICAgICAgY29uc3QgZ3JhcGhNaW4gPSB0aGlzLnBvdGVudGlhbEdyYXBoLmdldEdyYXBoTWluKCk7XHJcbiAgICAgIHRoaXMucG90ZW50aWFsR3JhcGguZXBzaWxvbkNvbnRyb2xzLmxpbmUuc2V0VHJhbnNsYXRpb24oIGdyYXBoTWluLngsIGdyYXBoTWluLnkgKyBFUFNJTE9OX0xJTkVfV0lEVEggKTtcclxuICAgICAgdGhpcy5wb3RlbnRpYWxHcmFwaC5lcHNpbG9uQ29udHJvbHMuYXJyb3cuc2V0VmlzaWJsZSggdGhpcy5wb3RlbnRpYWxHcmFwaC5pbnRlcmFjdGlvbkVuYWJsZWQgKTtcclxuICAgICAgdGhpcy5wb3RlbnRpYWxHcmFwaC5lcHNpbG9uQ29udHJvbHMubGluZS5zZXRWaXNpYmxlKCB0aGlzLnBvdGVudGlhbEdyYXBoLmludGVyYWN0aW9uRW5hYmxlZCApO1xyXG4gICAgICB0aGlzLnBvdGVudGlhbEdyYXBoLmVwc2lsb25Db250cm9scy5hcnJvdy5jZW50ZXJYID0gdGhpcy5wb3RlbnRpYWxHcmFwaC5lcHNpbG9uQ29udHJvbHMubGluZS5yaWdodDtcclxuICAgICAgdGhpcy5wb3RlbnRpYWxHcmFwaC5lcHNpbG9uQ29udHJvbHMuYXJyb3cuY2VudGVyWSA9IHRoaXMucG90ZW50aWFsR3JhcGguZXBzaWxvbkNvbnRyb2xzLmxpbmUuY2VudGVyWTtcclxuICAgIH1cclxuICAgIGlmICggdGhpcy5wb3RlbnRpYWxHcmFwaC5zaWdtYUNvbnRyb2xzLmFycm93ICkge1xyXG4gICAgICB0aGlzLnBvdGVudGlhbEdyYXBoLnNpZ21hQ29udHJvbHMuYXJyb3cuY2VudGVyWCA9IHNpZ21hSGFuZGxlWFBvcztcclxuICAgICAgdGhpcy5wb3RlbnRpYWxHcmFwaC5zaWdtYUNvbnRyb2xzLmFycm93LmNlbnRlclkgPSBzaWdtYUhhbmRsZVlQb3M7XHJcbiAgICAgIHRoaXMucG90ZW50aWFsR3JhcGguc2lnbWFDb250cm9scy5hcnJvdy5zZXRWaXNpYmxlKCB0aGlzLnBvdGVudGlhbEdyYXBoLmludGVyYWN0aW9uRW5hYmxlZCApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGluZGljYXRlIHRoYXQgdGhpcyBzaG91bGQgYmUgcmVwYWludGVkIGR1cmluZyB0aGUgbmV4dCBwYWludCBjeWNsZVxyXG4gICAgdGhpcy5pbnZhbGlkYXRlUGFpbnQoKTtcclxuICB9XHJcbn1cclxuXHJcbnN0YXRlc09mTWF0dGVyLnJlZ2lzdGVyKCAnSW50ZXJhY3Rpb25Qb3RlbnRpYWxDYW52YXNOb2RlJywgSW50ZXJhY3Rpb25Qb3RlbnRpYWxDYW52YXNOb2RlICk7XHJcbmV4cG9ydCBkZWZhdWx0IEludGVyYWN0aW9uUG90ZW50aWFsQ2FudmFzTm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLEtBQUssTUFBTSw2QkFBNkI7QUFDL0MsT0FBT0MsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxPQUFPQyxVQUFVLE1BQU0sMkNBQTJDO0FBQ2xFLFNBQVNDLFVBQVUsUUFBUSxtQ0FBbUM7QUFDOUQsT0FBT0MsY0FBYyxNQUFNLHlCQUF5Qjs7QUFFcEQ7QUFDQSxNQUFNQyxlQUFlLEdBQUcsQ0FBQztBQUN6QixNQUFNQyxzQkFBc0IsR0FBRyxDQUFDLEdBQUdELGVBQWU7QUFDbEQsTUFBTUUsOEJBQThCLEdBQUcsSUFBSSxDQUFDLENBQUU7QUFDOUMsTUFBTUMsa0JBQWtCLEdBQUcsQ0FBQztBQUU1QixNQUFNQyw4QkFBOEIsU0FBU04sVUFBVSxDQUFDO0VBRXREO0FBQ0Y7QUFDQTtBQUNBO0VBQ0VPLFdBQVdBLENBQUVDLGtCQUFrQixFQUFFQyxPQUFPLEVBQUc7SUFDekMsS0FBSyxDQUFFQSxPQUFRLENBQUM7SUFDaEIsSUFBSSxDQUFDQyxjQUFjLEdBQUdGLGtCQUFrQixDQUFDLENBQUM7O0lBRTFDO0lBQ0E7SUFDQSxJQUFJLENBQUNHLGVBQWUsR0FBRyxJQUFJQyxLQUFLLENBQUVmLEtBQUssQ0FBQ2dCLGNBQWMsQ0FBRUwsa0JBQWtCLENBQUNNLFVBQVcsQ0FBRSxDQUFDOztJQUV6RjtJQUNB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