// Copyright 2014-2021, University of Colorado Boulder

/**
 * Model for an isokinetic thermostat that controls the kinetic energy of a set of particles such that they remain at
 * a certain temperature.
 *
 * @author John Blanco
 * @author Aaron Davis
 * @author Siddhartha Chinthapally (Actual Concepts)
 */

import dotRandom from '../../../../../../dot/js/dotRandom.js';
import Vector2 from '../../../../../../dot/js/Vector2.js';
import IOType from '../../../../../../tandem/js/types/IOType.js';
import NumberIO from '../../../../../../tandem/js/types/NumberIO.js';
import statesOfMatter from '../../../../statesOfMatter.js';
import SOMConstants from '../../../SOMConstants.js';

// constants
const MIN_POST_ZERO_VELOCITY = 0.1; // min velocity when warming up from absolute zero, empirically determined
const MIN_X_VEL_WHEN_FALLING = 1.0; // a velocity below which x should not be scaled when falling,  empirically determined
const COMPENSATION_FACTOR = 0.9; // an empirically determined factor to help with drift compensation, see usage below

class IsokineticThermostat {
  /**
   * Constructor for the Isokinetic thermostat.
   * @param {MoleculeForceAndMotionDataSet} moleculeDataSet -  Data set on which operations will be performed.
   * @param {number} minTemperature - The temperature that should be considered absolute zero, below which motion should cease.
   */
  constructor(moleculeDataSet, minTemperature) {
    this.moleculeDataSet = moleculeDataSet; // @private

    // @public, target temperature in normalized model units
    this.targetTemperature = SOMConstants.INITIAL_TEMPERATURE;

    // @private, minimum temperature in normalized model units, below this is considered absolute 0
    this.minModelTemperature = minTemperature;

    // @private, previous scale factor from temperature adjust calculation
    this.previousTemperatureScaleFactor = 1;

    // @private {Vector2} - reusable vector used for calculating velocity changes
    this.previousParticleVelocity = new Vector2(0, 0);

    // @private {Vector2} - used to correct for a collective drift that can occur, see usage for details
    this.totalVelocityChangeThisStep = new Vector2(0, 0);
    this.accumulatedAverageVelocityChange = new Vector2(0, 0);
  }

  /**
   * @param {number} measuredTemperature - measured temperature of particles, in model units
   * @public
   */
  adjustTemperature(measuredTemperature) {
    let i;
    const numberOfParticles = this.moleculeDataSet.getNumberOfMolecules();

    // Calculate the scaling factor that will be used to adjust the temperature.
    let temperatureScaleFactor;
    if (this.targetTemperature > this.minModelTemperature) {
      temperatureScaleFactor = Math.sqrt(this.targetTemperature / measuredTemperature);
    } else {
      // The particles are at absolute zero, so stop all motion.
      temperatureScaleFactor = 0;
      this.accumulatedAverageVelocityChange.setXY(0, 0);
    }

    // Clear the vector the is used to sum velocity changes - it's only used in the 'normal' case.
    this.totalVelocityChangeThisStep.setXY(0, 0);

    // local vars for convenience and performance
    const moleculeVelocities = this.moleculeDataSet.moleculeVelocities;
    const moleculeRotationRates = this.moleculeDataSet.moleculeRotationRates;
    if (this.previousTemperatureScaleFactor !== 0 || temperatureScaleFactor === 0 || measuredTemperature > this.minModelTemperature) {
      // This is the 'normal' case, where the scale factor is used to adjust the energy of the particles.
      for (i = 0; i < numberOfParticles; i++) {
        const moleculeVelocity = moleculeVelocities[i];
        this.previousParticleVelocity.set(moleculeVelocity);
        if (moleculeVelocity.y < 0) {
          // The particle is falling.  To avoid unnatural looking behavior and to prevent particles from getting
          // suspended in midair at absolute zero, don't scale down the Y velocity.  However, to avoid a situation
          // where the particle is bouncing straight up and down, also stop scaling the X velocity when below a
          // certain temperature.
          if (Math.abs(moleculeVelocity.x) > MIN_X_VEL_WHEN_FALLING) {
            moleculeVelocity.x = moleculeVelocity.x * temperatureScaleFactor;
          }
        } else {
          // Scale both the x and y velocities.  This has a factor that compensates for drift that can occur if the
          // substance has a bit of velocity in one direction when this thermostat starts running.  Only the x
          // direction is compensated since the design team decided that the behavior in the y direction isn't
          // problematic. See https://github.com/phetsims/states-of-matter/issues/214 for more info and history.
          moleculeVelocity.setXY(moleculeVelocity.x * temperatureScaleFactor - this.accumulatedAverageVelocityChange.x * COMPENSATION_FACTOR, moleculeVelocity.y * temperatureScaleFactor);
        }

        // Scale the rotation rates (this has no effect in the monatomic case).
        moleculeRotationRates[i] *= temperatureScaleFactor;

        // Track the total of all velocity changes - used to correct for drift
        this.totalVelocityChangeThisStep.addXY(moleculeVelocity.x - this.previousParticleVelocity.x, moleculeVelocity.y - this.previousParticleVelocity.y);
      }
    } else {
      // The temperature has just risen above the minimum model temperature (essentially absolute zero), so we need
      // to make sure all particles have a reasonable amount of kinetic energy, otherwise some of them can appear to
      // get stuck on the bottom of the container since they have no energy to scale.  Only linear kinetic energy is
      // adjusted here, since it is simpler and seems to work.
      for (i = 0; i < numberOfParticles; i++) {
        let angle = dotRandom.nextDouble() * Math.PI;
        if (angle < 0) {
          angle += Math.PI;
        }
        moleculeVelocities[i].setPolar(MIN_POST_ZERO_VELOCITY, angle);
      }
    }

    // Save the scaling factor for next time.
    this.previousTemperatureScaleFactor = temperatureScaleFactor;

    // Accumulate the average velocity changes that have occurred, used for drift compensation.
    this.accumulatedAverageVelocityChange.addXY(this.totalVelocityChangeThisStep.x / numberOfParticles, this.totalVelocityChangeThisStep.y / numberOfParticles);
  }

  /**
   * clear the accumulated velocity bias, should be done when this thermostat starts being used for a number of steps
   * in a row
   * @public
   */
  clearAccumulatedBias() {
    this.accumulatedAverageVelocityChange.setXY(0, 0);
  }

  /**
   * Get an object that describes the current state, used to restore state using setState, used only for phet-io.
   * @public - for phet-io support only
   * @returns {Object}
   */
  toStateObject() {
    // Note: The moleculeDataSet is *not* included as part of the state because this is assumed to be a reference that
    // is shared with the model, and the model is responsible for updating its state during deserialization.

    return {
      targetTemperature: this.targetTemperature,
      minModelTemperature: this.minModelTemperature,
      previousTemperatureScaleFactor: this.previousTemperatureScaleFactor,
      previousParticleVelocity: this.previousParticleVelocity.toStateObject(),
      totalVelocityChangeThisStep: this.totalVelocityChangeThisStep.toStateObject(),
      accumulatedAverageVelocityChange: this.accumulatedAverageVelocityChange.toStateObject()
    };
  }

  /**
   * Set the state of this instance for phet-io.  This is used for phet-io, but not directly by the PhetioStateEngine -
   * it is instead called during explicit de-serialization.
   * @param {Object} stateObject - returned from toStateObject
   * @public
   */
  setState(stateObject) {
    // Note: The moleculeDataSet is *not* included as part of the state because this is assumed to be a reference that
    // is shared with the model, and the model is responsible for updating its state during deserialization.

    this.targetTemperature = stateObject.targetTemperature;
    this.minModelTemperature = stateObject.minModelTemperature;
    this.previousTemperatureScaleFactor = stateObject.previousTemperatureScaleFactor;
    this.previousParticleVelocity.set(stateObject.previousParticleVelocity);
    this.totalVelocityChangeThisStep.set(stateObject.totalVelocityChangeThisStep);
    this.accumulatedAverageVelocityChange.set(stateObject.accumulatedAverageVelocityChange);
  }
}

// @public
IsokineticThermostat.IsoKineticThermostatIO = new IOType('IsoKineticThermostatIO', {
  valueType: IsokineticThermostat,
  stateSchema: {
    targetTemperature: NumberIO,
    minModelTemperature: NumberIO,
    previousTemperatureScaleFactor: NumberIO,
    previousParticleVelocity: Vector2.Vector2IO,
    totalVelocityChangeThisStep: Vector2.Vector2IO,
    accumulatedAverageVelocityChange: Vector2.Vector2IO
  }
});
statesOfMatter.register('IsokineticThermostat', IsokineticThermostat);
export default IsokineticThermostat;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3RSYW5kb20iLCJWZWN0b3IyIiwiSU9UeXBlIiwiTnVtYmVySU8iLCJzdGF0ZXNPZk1hdHRlciIsIlNPTUNvbnN0YW50cyIsIk1JTl9QT1NUX1pFUk9fVkVMT0NJVFkiLCJNSU5fWF9WRUxfV0hFTl9GQUxMSU5HIiwiQ09NUEVOU0FUSU9OX0ZBQ1RPUiIsIklzb2tpbmV0aWNUaGVybW9zdGF0IiwiY29uc3RydWN0b3IiLCJtb2xlY3VsZURhdGFTZXQiLCJtaW5UZW1wZXJhdHVyZSIsInRhcmdldFRlbXBlcmF0dXJlIiwiSU5JVElBTF9URU1QRVJBVFVSRSIsIm1pbk1vZGVsVGVtcGVyYXR1cmUiLCJwcmV2aW91c1RlbXBlcmF0dXJlU2NhbGVGYWN0b3IiLCJwcmV2aW91c1BhcnRpY2xlVmVsb2NpdHkiLCJ0b3RhbFZlbG9jaXR5Q2hhbmdlVGhpc1N0ZXAiLCJhY2N1bXVsYXRlZEF2ZXJhZ2VWZWxvY2l0eUNoYW5nZSIsImFkanVzdFRlbXBlcmF0dXJlIiwibWVhc3VyZWRUZW1wZXJhdHVyZSIsImkiLCJudW1iZXJPZlBhcnRpY2xlcyIsImdldE51bWJlck9mTW9sZWN1bGVzIiwidGVtcGVyYXR1cmVTY2FsZUZhY3RvciIsIk1hdGgiLCJzcXJ0Iiwic2V0WFkiLCJtb2xlY3VsZVZlbG9jaXRpZXMiLCJtb2xlY3VsZVJvdGF0aW9uUmF0ZXMiLCJtb2xlY3VsZVZlbG9jaXR5Iiwic2V0IiwieSIsImFicyIsIngiLCJhZGRYWSIsImFuZ2xlIiwibmV4dERvdWJsZSIsIlBJIiwic2V0UG9sYXIiLCJjbGVhckFjY3VtdWxhdGVkQmlhcyIsInRvU3RhdGVPYmplY3QiLCJzZXRTdGF0ZSIsInN0YXRlT2JqZWN0IiwiSXNvS2luZXRpY1RoZXJtb3N0YXRJTyIsInZhbHVlVHlwZSIsInN0YXRlU2NoZW1hIiwiVmVjdG9yMklPIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJJc29raW5ldGljVGhlcm1vc3RhdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNC0yMDIxLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBNb2RlbCBmb3IgYW4gaXNva2luZXRpYyB0aGVybW9zdGF0IHRoYXQgY29udHJvbHMgdGhlIGtpbmV0aWMgZW5lcmd5IG9mIGEgc2V0IG9mIHBhcnRpY2xlcyBzdWNoIHRoYXQgdGhleSByZW1haW4gYXRcclxuICogYSBjZXJ0YWluIHRlbXBlcmF0dXJlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvaG4gQmxhbmNvXHJcbiAqIEBhdXRob3IgQWFyb24gRGF2aXNcclxuICogQGF1dGhvciBTaWRkaGFydGhhIENoaW50aGFwYWxseSAoQWN0dWFsIENvbmNlcHRzKVxyXG4gKi9cclxuXHJcbmltcG9ydCBkb3RSYW5kb20gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vZG90L2pzL2RvdFJhbmRvbS5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IElPVHlwZSBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvSU9UeXBlLmpzJztcclxuaW1wb3J0IE51bWJlcklPIGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL3RhbmRlbS9qcy90eXBlcy9OdW1iZXJJTy5qcyc7XHJcbmltcG9ydCBzdGF0ZXNPZk1hdHRlciBmcm9tICcuLi8uLi8uLi8uLi9zdGF0ZXNPZk1hdHRlci5qcyc7XHJcbmltcG9ydCBTT01Db25zdGFudHMgZnJvbSAnLi4vLi4vLi4vU09NQ29uc3RhbnRzLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBNSU5fUE9TVF9aRVJPX1ZFTE9DSVRZID0gMC4xOyAvLyBtaW4gdmVsb2NpdHkgd2hlbiB3YXJtaW5nIHVwIGZyb20gYWJzb2x1dGUgemVybywgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZFxyXG5jb25zdCBNSU5fWF9WRUxfV0hFTl9GQUxMSU5HID0gMS4wOyAvLyBhIHZlbG9jaXR5IGJlbG93IHdoaWNoIHggc2hvdWxkIG5vdCBiZSBzY2FsZWQgd2hlbiBmYWxsaW5nLCAgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZFxyXG5jb25zdCBDT01QRU5TQVRJT05fRkFDVE9SID0gMC45OyAvLyBhbiBlbXBpcmljYWxseSBkZXRlcm1pbmVkIGZhY3RvciB0byBoZWxwIHdpdGggZHJpZnQgY29tcGVuc2F0aW9uLCBzZWUgdXNhZ2UgYmVsb3dcclxuXHJcbmNsYXNzIElzb2tpbmV0aWNUaGVybW9zdGF0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBJc29raW5ldGljIHRoZXJtb3N0YXQuXHJcbiAgICogQHBhcmFtIHtNb2xlY3VsZUZvcmNlQW5kTW90aW9uRGF0YVNldH0gbW9sZWN1bGVEYXRhU2V0IC0gIERhdGEgc2V0IG9uIHdoaWNoIG9wZXJhdGlvbnMgd2lsbCBiZSBwZXJmb3JtZWQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblRlbXBlcmF0dXJlIC0gVGhlIHRlbXBlcmF0dXJlIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYWJzb2x1dGUgemVybywgYmVsb3cgd2hpY2ggbW90aW9uIHNob3VsZCBjZWFzZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggbW9sZWN1bGVEYXRhU2V0LCBtaW5UZW1wZXJhdHVyZSApIHtcclxuXHJcbiAgICB0aGlzLm1vbGVjdWxlRGF0YVNldCA9IG1vbGVjdWxlRGF0YVNldDsgLy8gQHByaXZhdGVcclxuXHJcbiAgICAvLyBAcHVibGljLCB0YXJnZXQgdGVtcGVyYXR1cmUgaW4gbm9ybWFsaXplZCBtb2RlbCB1bml0c1xyXG4gICAgdGhpcy50YXJnZXRUZW1wZXJhdHVyZSA9IFNPTUNvbnN0YW50cy5JTklUSUFMX1RFTVBFUkFUVVJFO1xyXG5cclxuICAgIC8vIEBwcml2YXRlLCBtaW5pbXVtIHRlbXBlcmF0dXJlIGluIG5vcm1hbGl6ZWQgbW9kZWwgdW5pdHMsIGJlbG93IHRoaXMgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSAwXHJcbiAgICB0aGlzLm1pbk1vZGVsVGVtcGVyYXR1cmUgPSBtaW5UZW1wZXJhdHVyZTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSwgcHJldmlvdXMgc2NhbGUgZmFjdG9yIGZyb20gdGVtcGVyYXR1cmUgYWRqdXN0IGNhbGN1bGF0aW9uXHJcbiAgICB0aGlzLnByZXZpb3VzVGVtcGVyYXR1cmVTY2FsZUZhY3RvciA9IDE7XHJcblxyXG4gICAgLy8gQHByaXZhdGUge1ZlY3RvcjJ9IC0gcmV1c2FibGUgdmVjdG9yIHVzZWQgZm9yIGNhbGN1bGF0aW5nIHZlbG9jaXR5IGNoYW5nZXNcclxuICAgIHRoaXMucHJldmlvdXNQYXJ0aWNsZVZlbG9jaXR5ID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7VmVjdG9yMn0gLSB1c2VkIHRvIGNvcnJlY3QgZm9yIGEgY29sbGVjdGl2ZSBkcmlmdCB0aGF0IGNhbiBvY2N1ciwgc2VlIHVzYWdlIGZvciBkZXRhaWxzXHJcbiAgICB0aGlzLnRvdGFsVmVsb2NpdHlDaGFuZ2VUaGlzU3RlcCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XHJcbiAgICB0aGlzLmFjY3VtdWxhdGVkQXZlcmFnZVZlbG9jaXR5Q2hhbmdlID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtZWFzdXJlZFRlbXBlcmF0dXJlIC0gbWVhc3VyZWQgdGVtcGVyYXR1cmUgb2YgcGFydGljbGVzLCBpbiBtb2RlbCB1bml0c1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBhZGp1c3RUZW1wZXJhdHVyZSggbWVhc3VyZWRUZW1wZXJhdHVyZSApIHtcclxuXHJcbiAgICBsZXQgaTtcclxuICAgIGNvbnN0IG51bWJlck9mUGFydGljbGVzID0gdGhpcy5tb2xlY3VsZURhdGFTZXQuZ2V0TnVtYmVyT2ZNb2xlY3VsZXMoKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHNjYWxpbmcgZmFjdG9yIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFkanVzdCB0aGUgdGVtcGVyYXR1cmUuXHJcbiAgICBsZXQgdGVtcGVyYXR1cmVTY2FsZUZhY3RvcjtcclxuICAgIGlmICggdGhpcy50YXJnZXRUZW1wZXJhdHVyZSA+IHRoaXMubWluTW9kZWxUZW1wZXJhdHVyZSApIHtcclxuICAgICAgdGVtcGVyYXR1cmVTY2FsZUZhY3RvciA9IE1hdGguc3FydCggdGhpcy50YXJnZXRUZW1wZXJhdHVyZSAvIG1lYXN1cmVkVGVtcGVyYXR1cmUgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgLy8gVGhlIHBhcnRpY2xlcyBhcmUgYXQgYWJzb2x1dGUgemVybywgc28gc3RvcCBhbGwgbW90aW9uLlxyXG4gICAgICB0ZW1wZXJhdHVyZVNjYWxlRmFjdG9yID0gMDtcclxuICAgICAgdGhpcy5hY2N1bXVsYXRlZEF2ZXJhZ2VWZWxvY2l0eUNoYW5nZS5zZXRYWSggMCwgMCApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsZWFyIHRoZSB2ZWN0b3IgdGhlIGlzIHVzZWQgdG8gc3VtIHZlbG9jaXR5IGNoYW5nZXMgLSBpdCdzIG9ubHkgdXNlZCBpbiB0aGUgJ25vcm1hbCcgY2FzZS5cclxuICAgIHRoaXMudG90YWxWZWxvY2l0eUNoYW5nZVRoaXNTdGVwLnNldFhZKCAwLCAwICk7XHJcblxyXG4gICAgLy8gbG9jYWwgdmFycyBmb3IgY29udmVuaWVuY2UgYW5kIHBlcmZvcm1hbmNlXHJcbiAgICBjb25zdCBtb2xlY3VsZVZlbG9jaXRpZXMgPSB0aGlzLm1vbGVjdWxlRGF0YVNldC5tb2xlY3VsZVZlbG9jaXRpZXM7XHJcbiAgICBjb25zdCBtb2xlY3VsZVJvdGF0aW9uUmF0ZXMgPSB0aGlzLm1vbGVjdWxlRGF0YVNldC5tb2xlY3VsZVJvdGF0aW9uUmF0ZXM7XHJcblxyXG4gICAgaWYgKCB0aGlzLnByZXZpb3VzVGVtcGVyYXR1cmVTY2FsZUZhY3RvciAhPT0gMCB8fFxyXG4gICAgICAgICB0ZW1wZXJhdHVyZVNjYWxlRmFjdG9yID09PSAwIHx8XHJcbiAgICAgICAgIG1lYXN1cmVkVGVtcGVyYXR1cmUgPiB0aGlzLm1pbk1vZGVsVGVtcGVyYXR1cmUgKSB7XHJcblxyXG4gICAgICAvLyBUaGlzIGlzIHRoZSAnbm9ybWFsJyBjYXNlLCB3aGVyZSB0aGUgc2NhbGUgZmFjdG9yIGlzIHVzZWQgdG8gYWRqdXN0IHRoZSBlbmVyZ3kgb2YgdGhlIHBhcnRpY2xlcy5cclxuICAgICAgZm9yICggaSA9IDA7IGkgPCBudW1iZXJPZlBhcnRpY2xlczsgaSsrICkge1xyXG5cclxuICAgICAgICBjb25zdCBtb2xlY3VsZVZlbG9jaXR5ID0gbW9sZWN1bGVWZWxvY2l0aWVzWyBpIF07XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c1BhcnRpY2xlVmVsb2NpdHkuc2V0KCBtb2xlY3VsZVZlbG9jaXR5ICk7XHJcblxyXG4gICAgICAgIGlmICggbW9sZWN1bGVWZWxvY2l0eS55IDwgMCApIHtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgcGFydGljbGUgaXMgZmFsbGluZy4gIFRvIGF2b2lkIHVubmF0dXJhbCBsb29raW5nIGJlaGF2aW9yIGFuZCB0byBwcmV2ZW50IHBhcnRpY2xlcyBmcm9tIGdldHRpbmdcclxuICAgICAgICAgIC8vIHN1c3BlbmRlZCBpbiBtaWRhaXIgYXQgYWJzb2x1dGUgemVybywgZG9uJ3Qgc2NhbGUgZG93biB0aGUgWSB2ZWxvY2l0eS4gIEhvd2V2ZXIsIHRvIGF2b2lkIGEgc2l0dWF0aW9uXHJcbiAgICAgICAgICAvLyB3aGVyZSB0aGUgcGFydGljbGUgaXMgYm91bmNpbmcgc3RyYWlnaHQgdXAgYW5kIGRvd24sIGFsc28gc3RvcCBzY2FsaW5nIHRoZSBYIHZlbG9jaXR5IHdoZW4gYmVsb3cgYVxyXG4gICAgICAgICAgLy8gY2VydGFpbiB0ZW1wZXJhdHVyZS5cclxuICAgICAgICAgIGlmICggTWF0aC5hYnMoIG1vbGVjdWxlVmVsb2NpdHkueCApID4gTUlOX1hfVkVMX1dIRU5fRkFMTElORyApIHtcclxuICAgICAgICAgICAgbW9sZWN1bGVWZWxvY2l0eS54ID0gbW9sZWN1bGVWZWxvY2l0eS54ICogdGVtcGVyYXR1cmVTY2FsZUZhY3RvcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gU2NhbGUgYm90aCB0aGUgeCBhbmQgeSB2ZWxvY2l0aWVzLiAgVGhpcyBoYXMgYSBmYWN0b3IgdGhhdCBjb21wZW5zYXRlcyBmb3IgZHJpZnQgdGhhdCBjYW4gb2NjdXIgaWYgdGhlXHJcbiAgICAgICAgICAvLyBzdWJzdGFuY2UgaGFzIGEgYml0IG9mIHZlbG9jaXR5IGluIG9uZSBkaXJlY3Rpb24gd2hlbiB0aGlzIHRoZXJtb3N0YXQgc3RhcnRzIHJ1bm5pbmcuICBPbmx5IHRoZSB4XHJcbiAgICAgICAgICAvLyBkaXJlY3Rpb24gaXMgY29tcGVuc2F0ZWQgc2luY2UgdGhlIGRlc2lnbiB0ZWFtIGRlY2lkZWQgdGhhdCB0aGUgYmVoYXZpb3IgaW4gdGhlIHkgZGlyZWN0aW9uIGlzbid0XHJcbiAgICAgICAgICAvLyBwcm9ibGVtYXRpYy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zdGF0ZXMtb2YtbWF0dGVyL2lzc3Vlcy8yMTQgZm9yIG1vcmUgaW5mbyBhbmQgaGlzdG9yeS5cclxuICAgICAgICAgIG1vbGVjdWxlVmVsb2NpdHkuc2V0WFkoXHJcbiAgICAgICAgICAgIG1vbGVjdWxlVmVsb2NpdHkueCAqIHRlbXBlcmF0dXJlU2NhbGVGYWN0b3IgLSB0aGlzLmFjY3VtdWxhdGVkQXZlcmFnZVZlbG9jaXR5Q2hhbmdlLnggKiBDT01QRU5TQVRJT05fRkFDVE9SLFxyXG4gICAgICAgICAgICBtb2xlY3VsZVZlbG9jaXR5LnkgKiB0ZW1wZXJhdHVyZVNjYWxlRmFjdG9yXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2NhbGUgdGhlIHJvdGF0aW9uIHJhdGVzICh0aGlzIGhhcyBubyBlZmZlY3QgaW4gdGhlIG1vbmF0b21pYyBjYXNlKS5cclxuICAgICAgICBtb2xlY3VsZVJvdGF0aW9uUmF0ZXNbIGkgXSAqPSB0ZW1wZXJhdHVyZVNjYWxlRmFjdG9yO1xyXG5cclxuICAgICAgICAvLyBUcmFjayB0aGUgdG90YWwgb2YgYWxsIHZlbG9jaXR5IGNoYW5nZXMgLSB1c2VkIHRvIGNvcnJlY3QgZm9yIGRyaWZ0XHJcbiAgICAgICAgdGhpcy50b3RhbFZlbG9jaXR5Q2hhbmdlVGhpc1N0ZXAuYWRkWFkoXHJcbiAgICAgICAgICBtb2xlY3VsZVZlbG9jaXR5LnggLSB0aGlzLnByZXZpb3VzUGFydGljbGVWZWxvY2l0eS54LFxyXG4gICAgICAgICAgbW9sZWN1bGVWZWxvY2l0eS55IC0gdGhpcy5wcmV2aW91c1BhcnRpY2xlVmVsb2NpdHkueVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgLy8gVGhlIHRlbXBlcmF0dXJlIGhhcyBqdXN0IHJpc2VuIGFib3ZlIHRoZSBtaW5pbXVtIG1vZGVsIHRlbXBlcmF0dXJlIChlc3NlbnRpYWxseSBhYnNvbHV0ZSB6ZXJvKSwgc28gd2UgbmVlZFxyXG4gICAgICAvLyB0byBtYWtlIHN1cmUgYWxsIHBhcnRpY2xlcyBoYXZlIGEgcmVhc29uYWJsZSBhbW91bnQgb2Yga2luZXRpYyBlbmVyZ3ksIG90aGVyd2lzZSBzb21lIG9mIHRoZW0gY2FuIGFwcGVhciB0b1xyXG4gICAgICAvLyBnZXQgc3R1Y2sgb24gdGhlIGJvdHRvbSBvZiB0aGUgY29udGFpbmVyIHNpbmNlIHRoZXkgaGF2ZSBubyBlbmVyZ3kgdG8gc2NhbGUuICBPbmx5IGxpbmVhciBraW5ldGljIGVuZXJneSBpc1xyXG4gICAgICAvLyBhZGp1c3RlZCBoZXJlLCBzaW5jZSBpdCBpcyBzaW1wbGVyIGFuZCBzZWVtcyB0byB3b3JrLlxyXG4gICAgICBmb3IgKCBpID0gMDsgaSA8IG51bWJlck9mUGFydGljbGVzOyBpKysgKSB7XHJcbiAgICAgICAgbGV0IGFuZ2xlID0gZG90UmFuZG9tLm5leHREb3VibGUoKSAqIE1hdGguUEk7XHJcbiAgICAgICAgaWYgKCBhbmdsZSA8IDAgKSB7XHJcbiAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtb2xlY3VsZVZlbG9jaXRpZXNbIGkgXS5zZXRQb2xhciggTUlOX1BPU1RfWkVST19WRUxPQ0lUWSwgYW5nbGUgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNhdmUgdGhlIHNjYWxpbmcgZmFjdG9yIGZvciBuZXh0IHRpbWUuXHJcbiAgICB0aGlzLnByZXZpb3VzVGVtcGVyYXR1cmVTY2FsZUZhY3RvciA9IHRlbXBlcmF0dXJlU2NhbGVGYWN0b3I7XHJcblxyXG4gICAgLy8gQWNjdW11bGF0ZSB0aGUgYXZlcmFnZSB2ZWxvY2l0eSBjaGFuZ2VzIHRoYXQgaGF2ZSBvY2N1cnJlZCwgdXNlZCBmb3IgZHJpZnQgY29tcGVuc2F0aW9uLlxyXG4gICAgdGhpcy5hY2N1bXVsYXRlZEF2ZXJhZ2VWZWxvY2l0eUNoYW5nZS5hZGRYWShcclxuICAgICAgdGhpcy50b3RhbFZlbG9jaXR5Q2hhbmdlVGhpc1N0ZXAueCAvIG51bWJlck9mUGFydGljbGVzLFxyXG4gICAgICB0aGlzLnRvdGFsVmVsb2NpdHlDaGFuZ2VUaGlzU3RlcC55IC8gbnVtYmVyT2ZQYXJ0aWNsZXNcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjbGVhciB0aGUgYWNjdW11bGF0ZWQgdmVsb2NpdHkgYmlhcywgc2hvdWxkIGJlIGRvbmUgd2hlbiB0aGlzIHRoZXJtb3N0YXQgc3RhcnRzIGJlaW5nIHVzZWQgZm9yIGEgbnVtYmVyIG9mIHN0ZXBzXHJcbiAgICogaW4gYSByb3dcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgY2xlYXJBY2N1bXVsYXRlZEJpYXMoKSB7XHJcbiAgICB0aGlzLmFjY3VtdWxhdGVkQXZlcmFnZVZlbG9jaXR5Q2hhbmdlLnNldFhZKCAwLCAwICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBjdXJyZW50IHN0YXRlLCB1c2VkIHRvIHJlc3RvcmUgc3RhdGUgdXNpbmcgc2V0U3RhdGUsIHVzZWQgb25seSBmb3IgcGhldC1pby5cclxuICAgKiBAcHVibGljIC0gZm9yIHBoZXQtaW8gc3VwcG9ydCBvbmx5XHJcbiAgICogQHJldHVybnMge09iamVjdH1cclxuICAgKi9cclxuICB0b1N0YXRlT2JqZWN0KCkge1xyXG5cclxuICAgIC8vIE5vdGU6IFRoZSBtb2xlY3VsZURhdGFTZXQgaXMgKm5vdCogaW5jbHVkZWQgYXMgcGFydCBvZiB0aGUgc3RhdGUgYmVjYXVzZSB0aGlzIGlzIGFzc3VtZWQgdG8gYmUgYSByZWZlcmVuY2UgdGhhdFxyXG4gICAgLy8gaXMgc2hhcmVkIHdpdGggdGhlIG1vZGVsLCBhbmQgdGhlIG1vZGVsIGlzIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZyBpdHMgc3RhdGUgZHVyaW5nIGRlc2VyaWFsaXphdGlvbi5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0YXJnZXRUZW1wZXJhdHVyZTogdGhpcy50YXJnZXRUZW1wZXJhdHVyZSxcclxuICAgICAgbWluTW9kZWxUZW1wZXJhdHVyZTogdGhpcy5taW5Nb2RlbFRlbXBlcmF0dXJlLFxyXG4gICAgICBwcmV2aW91c1RlbXBlcmF0dXJlU2NhbGVGYWN0b3I6IHRoaXMucHJldmlvdXNUZW1wZXJhdHVyZVNjYWxlRmFjdG9yLFxyXG4gICAgICBwcmV2aW91c1BhcnRpY2xlVmVsb2NpdHk6IHRoaXMucHJldmlvdXNQYXJ0aWNsZVZlbG9jaXR5LnRvU3RhdGVPYmplY3QoKSxcclxuICAgICAgdG90YWxWZWxvY2l0eUNoYW5nZVRoaXNTdGVwOiB0aGlzLnRvdGFsVmVsb2NpdHlDaGFuZ2VUaGlzU3RlcC50b1N0YXRlT2JqZWN0KCksXHJcbiAgICAgIGFjY3VtdWxhdGVkQXZlcmFnZVZlbG9jaXR5Q2hhbmdlOiB0aGlzLmFjY3VtdWxhdGVkQXZlcmFnZVZlbG9jaXR5Q2hhbmdlLnRvU3RhdGVPYmplY3QoKVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc3RhdGUgb2YgdGhpcyBpbnN0YW5jZSBmb3IgcGhldC1pby4gIFRoaXMgaXMgdXNlZCBmb3IgcGhldC1pbywgYnV0IG5vdCBkaXJlY3RseSBieSB0aGUgUGhldGlvU3RhdGVFbmdpbmUgLVxyXG4gICAqIGl0IGlzIGluc3RlYWQgY2FsbGVkIGR1cmluZyBleHBsaWNpdCBkZS1zZXJpYWxpemF0aW9uLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZU9iamVjdCAtIHJldHVybmVkIGZyb20gdG9TdGF0ZU9iamVjdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzZXRTdGF0ZSggc3RhdGVPYmplY3QgKSB7XHJcblxyXG4gICAgLy8gTm90ZTogVGhlIG1vbGVjdWxlRGF0YVNldCBpcyAqbm90KiBpbmNsdWRlZCBhcyBwYXJ0IG9mIHRoZSBzdGF0ZSBiZWNhdXNlIHRoaXMgaXMgYXNzdW1lZCB0byBiZSBhIHJlZmVyZW5jZSB0aGF0XHJcbiAgICAvLyBpcyBzaGFyZWQgd2l0aCB0aGUgbW9kZWwsIGFuZCB0aGUgbW9kZWwgaXMgcmVzcG9uc2libGUgZm9yIHVwZGF0aW5nIGl0cyBzdGF0ZSBkdXJpbmcgZGVzZXJpYWxpemF0aW9uLlxyXG5cclxuICAgIHRoaXMudGFyZ2V0VGVtcGVyYXR1cmUgPSBzdGF0ZU9iamVjdC50YXJnZXRUZW1wZXJhdHVyZTtcclxuICAgIHRoaXMubWluTW9kZWxUZW1wZXJhdHVyZSA9IHN0YXRlT2JqZWN0Lm1pbk1vZGVsVGVtcGVyYXR1cmU7XHJcbiAgICB0aGlzLnByZXZpb3VzVGVtcGVyYXR1cmVTY2FsZUZhY3RvciA9IHN0YXRlT2JqZWN0LnByZXZpb3VzVGVtcGVyYXR1cmVTY2FsZUZhY3RvcjtcclxuICAgIHRoaXMucHJldmlvdXNQYXJ0aWNsZVZlbG9jaXR5LnNldCggc3RhdGVPYmplY3QucHJldmlvdXNQYXJ0aWNsZVZlbG9jaXR5ICk7XHJcbiAgICB0aGlzLnRvdGFsVmVsb2NpdHlDaGFuZ2VUaGlzU3RlcC5zZXQoIHN0YXRlT2JqZWN0LnRvdGFsVmVsb2NpdHlDaGFuZ2VUaGlzU3RlcCApO1xyXG4gICAgdGhpcy5hY2N1bXVsYXRlZEF2ZXJhZ2VWZWxvY2l0eUNoYW5nZS5zZXQoIHN0YXRlT2JqZWN0LmFjY3VtdWxhdGVkQXZlcmFnZVZlbG9jaXR5Q2hhbmdlICk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBAcHVibGljXHJcbklzb2tpbmV0aWNUaGVybW9zdGF0Lklzb0tpbmV0aWNUaGVybW9zdGF0SU8gPSBuZXcgSU9UeXBlKCAnSXNvS2luZXRpY1RoZXJtb3N0YXRJTycsIHtcclxuICB2YWx1ZVR5cGU6IElzb2tpbmV0aWNUaGVybW9zdGF0LFxyXG4gIHN0YXRlU2NoZW1hOiB7XHJcbiAgICB0YXJnZXRUZW1wZXJhdHVyZTogTnVtYmVySU8sXHJcbiAgICBtaW5Nb2RlbFRlbXBlcmF0dXJlOiBOdW1iZXJJTyxcclxuICAgIHByZXZpb3VzVGVtcGVyYXR1cmVTY2FsZUZhY3RvcjogTnVtYmVySU8sXHJcbiAgICBwcmV2aW91c1BhcnRpY2xlVmVsb2NpdHk6IFZlY3RvcjIuVmVjdG9yMklPLFxyXG4gICAgdG90YWxWZWxvY2l0eUNoYW5nZVRoaXNTdGVwOiBWZWN0b3IyLlZlY3RvcjJJTyxcclxuICAgIGFjY3VtdWxhdGVkQXZlcmFnZVZlbG9jaXR5Q2hhbmdlOiBWZWN0b3IyLlZlY3RvcjJJT1xyXG4gIH1cclxufSApO1xyXG5cclxuc3RhdGVzT2ZNYXR0ZXIucmVnaXN0ZXIoICdJc29raW5ldGljVGhlcm1vc3RhdCcsIElzb2tpbmV0aWNUaGVybW9zdGF0ICk7XHJcbmV4cG9ydCBkZWZhdWx0IElzb2tpbmV0aWNUaGVybW9zdGF0OyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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