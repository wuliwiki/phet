// Copyright 2014-2021, University of Colorado Boulder

/**
 * Model for an Andersen Thermostat, which adjusts the velocity of all atoms/molecules in the system by the same amount
 * in order to get the overall system temperature to the desired set point.  There is a short Wikipedia entry for this
 * algorithm at https://en.wikipedia.org/wiki/Andersen_thermostat.
 *
 * @author John Blanco
 * @author Aaron Davis
 * @author Siddhartha Chinthapally (Actual Concepts)
 */

import dotRandom from '../../../../../../dot/js/dotRandom.js';
import Vector2 from '../../../../../../dot/js/Vector2.js';
import IOType from '../../../../../../tandem/js/types/IOType.js';
import NumberIO from '../../../../../../tandem/js/types/NumberIO.js';
import statesOfMatter from '../../../../statesOfMatter.js';
import SOMConstants from '../../../SOMConstants.js';

// constants
const PROPORTION_COMPENSATION_FACTOR = 0.25; // used for drift compensation, value empirically determined
const INTEGRAL_COMPENSATION_FACTOR = 0.5; // used for drift compensation, value empirically determined

class AndersenThermostat {
  /**
   * Constructor for the Andersen thermostat.
   * @param {MoleculeForceAndMotionDataSet} moleculeDataSet  - Data set on which operations will be performed.
   * @param {number} minTemperature  - The temperature that should be considered absolute zero, below which motion should cease
   */
  constructor(moleculeDataSet, minTemperature) {
    // @public target temperature in normalized model units
    this.targetTemperature = SOMConstants.INITIAL_TEMPERATURE;

    // @public minimum temperature in normalized model units, below this is considered absolute 0;
    this.minModelTemperature = minTemperature;

    // @private reference to the molecule data set
    this.moleculeDataSet = moleculeDataSet;

    // @private - pseudo-random number generator
    this.random = dotRandom;

    // @private {Vector2} - reusable vector used for calculating velocity changes
    this.previousParticleVelocity = new Vector2(0, 0);

    // @private {Vector2} - vectors used to correct for a collective drift that can occur
    this.totalVelocityChangePreviousStep = new Vector2(0, 0);
    this.totalVelocityChangeThisStep = new Vector2(0, 0);
    this.accumulatedAverageVelocityChange = new Vector2(0, 0);
  }

  /**
   * @public
   */
  adjustTemperature() {
    // A Note to Future Maintainers: This code was originally provided by Paul Beale of the University of Colorado and
    // converted into Java, and then JavaScript, by @jbphet. For many years, it had separate gamma values the X and Y
    // directions, but those values were always set to the same thing.  In early August of 2018, I (jbphet) refactored
    // this to have a single gamma value in order to reduce the number of calculations done and thus improve
    // performance.  If it's ever needed, separate values could be brought back for X and Y.

    let gamma;
    let temperature = this.targetTemperature;
    if (temperature > this.minModelTemperature) {
      // Use a values that will cause the molecules to stop moving pretty quickly if we are below the minimum
      // temperature, since we want to create the appearance of absolute zero.  Values were empirically determined.
      gamma = 0.999;
    } else {
      // Use a values that will cause the molecules to stop moving pretty quickly if we are below the minimum
      // temperature, since we want to create the appearance of absolute zero.  Values were empirically determined.
      gamma = 0.5;
      temperature = 0;
    }
    const massInverse = 1 / this.moleculeDataSet.moleculeMass;
    const inertiaInverse = 1 / this.moleculeDataSet.moleculeRotationalInertia;
    const scalingFactor = temperature * (1 - Math.pow(gamma, 2));
    const velocityScalingFactor = Math.sqrt(massInverse * scalingFactor);
    const rotationScalingFactor = Math.sqrt(inertiaInverse * scalingFactor);
    const numMolecules = this.moleculeDataSet.getNumberOfMolecules();

    // Calculate a compensation factor for any overall drift that is being added by this thermostat.  Without this,
    // we often see solids drifting to the left or right for no apparent reason.  Compensation is only done in the X
    // direction since the Y direction wasn't visually problematic.  For more information on this, please see
    // https://github.com/phetsims/states-of-matter-basics/issues/15.
    const xCompensation = -this.totalVelocityChangePreviousStep.x / numMolecules * PROPORTION_COMPENSATION_FACTOR - this.accumulatedAverageVelocityChange.x * INTEGRAL_COMPENSATION_FACTOR;

    // local vars for convenience and performance
    const moleculeVelocities = this.moleculeDataSet.moleculeVelocities;
    const moleculeRotationRates = this.moleculeDataSet.moleculeRotationRates;
    for (let i = 0; i < numMolecules; i++) {
      const moleculeVelocity = moleculeVelocities[i];
      this.previousParticleVelocity.set(moleculeVelocity);

      // Calculate the new x and y velocity for this particle.
      const xVel = moleculeVelocity.x * gamma + this.random.nextGaussian() * velocityScalingFactor + xCompensation;
      const yVel = moleculeVelocity.y * gamma + this.random.nextGaussian() * velocityScalingFactor;
      moleculeVelocity.setXY(xVel, yVel);
      moleculeRotationRates[i] = gamma * moleculeRotationRates[i] + this.random.nextGaussian() * rotationScalingFactor;
      this.totalVelocityChangeThisStep.addXY(xVel - this.previousParticleVelocity.x, yVel - this.previousParticleVelocity.y);
    }
    this.accumulatedAverageVelocityChange.addXY(this.totalVelocityChangeThisStep.x / numMolecules, this.totalVelocityChangeThisStep.y / numMolecules);
    this.totalVelocityChangePreviousStep.set(this.totalVelocityChangeThisStep);
  }

  /**
   * clear the accumulated velocity bias, should be done when this thermostat starts being used for a number of steps
   * in a row
   * @public
   */
  clearAccumulatedBias() {
    this.accumulatedAverageVelocityChange.setXY(0, 0);
    this.totalVelocityChangePreviousStep.setXY(0, 0);
  }

  /**
   * Get an object that describes the current state, used to restore state using setState, used only for phet-io.
   * @public - for phet-io support only
   * @returns {Object}
   */
  toStateObject() {
    // Note: The moleculeDataSet is *not* included as part of the state because this is assumed to be a reference that
    // is shared with the model, and the model is responsible for updating its state during deserialization.

    return {
      targetTemperature: this.targetTemperature,
      minModelTemperature: this.minModelTemperature,
      previousParticleVelocity: this.previousParticleVelocity.toStateObject(),
      totalVelocityChangePreviousStep: this.totalVelocityChangePreviousStep.toStateObject(),
      totalVelocityChangeThisStep: this.totalVelocityChangeThisStep.toStateObject(),
      accumulatedAverageVelocityChange: this.accumulatedAverageVelocityChange.toStateObject()
    };
  }

  /**
   * Set the state of this instance for phet-io.  This is used for phet-io, but not directly by the PhetioStateEngine -
   * it is instead called during explicit de-serialization.
   * @param {Object} stateObject - returned from toStateObject
   * @public
   */
  setState(stateObject) {
    // Note: The moleculeDataSet is *not* included as part of the state because this is assumed to be a reference that
    // is shared with the model, and the model is responsible for updating its state during deserialization.

    this.targetTemperature = stateObject.targetTemperature;
    this.minModelTemperature = stateObject.minModelTemperature;
    this.previousParticleVelocity.set(stateObject.previousParticleVelocity);
    this.totalVelocityChangePreviousStep.set(stateObject.totalVelocityChangePreviousStep);
    this.totalVelocityChangeThisStep.set(stateObject.totalVelocityChangeThisStep);
    this.accumulatedAverageVelocityChange.set(stateObject.accumulatedAverageVelocityChange);
  }
}

// @public
AndersenThermostat.AndersenThermostatIO = new IOType('AndersenThermostatIO', {
  valueType: AndersenThermostat,
  stateSchema: {
    targetTemperature: NumberIO,
    minModelTemperature: NumberIO,
    previousParticleVelocity: Vector2.Vector2IO,
    totalVelocityChangePreviousStep: Vector2.Vector2IO,
    totalVelocityChangeThisStep: Vector2.Vector2IO,
    accumulatedAverageVelocityChange: Vector2.Vector2IO
  }
});
statesOfMatter.register('AndersenThermostat', AndersenThermostat);
export default AndersenThermostat;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkb3RSYW5kb20iLCJWZWN0b3IyIiwiSU9UeXBlIiwiTnVtYmVySU8iLCJzdGF0ZXNPZk1hdHRlciIsIlNPTUNvbnN0YW50cyIsIlBST1BPUlRJT05fQ09NUEVOU0FUSU9OX0ZBQ1RPUiIsIklOVEVHUkFMX0NPTVBFTlNBVElPTl9GQUNUT1IiLCJBbmRlcnNlblRoZXJtb3N0YXQiLCJjb25zdHJ1Y3RvciIsIm1vbGVjdWxlRGF0YVNldCIsIm1pblRlbXBlcmF0dXJlIiwidGFyZ2V0VGVtcGVyYXR1cmUiLCJJTklUSUFMX1RFTVBFUkFUVVJFIiwibWluTW9kZWxUZW1wZXJhdHVyZSIsInJhbmRvbSIsInByZXZpb3VzUGFydGljbGVWZWxvY2l0eSIsInRvdGFsVmVsb2NpdHlDaGFuZ2VQcmV2aW91c1N0ZXAiLCJ0b3RhbFZlbG9jaXR5Q2hhbmdlVGhpc1N0ZXAiLCJhY2N1bXVsYXRlZEF2ZXJhZ2VWZWxvY2l0eUNoYW5nZSIsImFkanVzdFRlbXBlcmF0dXJlIiwiZ2FtbWEiLCJ0ZW1wZXJhdHVyZSIsIm1hc3NJbnZlcnNlIiwibW9sZWN1bGVNYXNzIiwiaW5lcnRpYUludmVyc2UiLCJtb2xlY3VsZVJvdGF0aW9uYWxJbmVydGlhIiwic2NhbGluZ0ZhY3RvciIsIk1hdGgiLCJwb3ciLCJ2ZWxvY2l0eVNjYWxpbmdGYWN0b3IiLCJzcXJ0Iiwicm90YXRpb25TY2FsaW5nRmFjdG9yIiwibnVtTW9sZWN1bGVzIiwiZ2V0TnVtYmVyT2ZNb2xlY3VsZXMiLCJ4Q29tcGVuc2F0aW9uIiwieCIsIm1vbGVjdWxlVmVsb2NpdGllcyIsIm1vbGVjdWxlUm90YXRpb25SYXRlcyIsImkiLCJtb2xlY3VsZVZlbG9jaXR5Iiwic2V0IiwieFZlbCIsIm5leHRHYXVzc2lhbiIsInlWZWwiLCJ5Iiwic2V0WFkiLCJhZGRYWSIsImNsZWFyQWNjdW11bGF0ZWRCaWFzIiwidG9TdGF0ZU9iamVjdCIsInNldFN0YXRlIiwic3RhdGVPYmplY3QiLCJBbmRlcnNlblRoZXJtb3N0YXRJTyIsInZhbHVlVHlwZSIsInN0YXRlU2NoZW1hIiwiVmVjdG9yMklPIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJBbmRlcnNlblRoZXJtb3N0YXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTQtMjAyMSwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogTW9kZWwgZm9yIGFuIEFuZGVyc2VuIFRoZXJtb3N0YXQsIHdoaWNoIGFkanVzdHMgdGhlIHZlbG9jaXR5IG9mIGFsbCBhdG9tcy9tb2xlY3VsZXMgaW4gdGhlIHN5c3RlbSBieSB0aGUgc2FtZSBhbW91bnRcclxuICogaW4gb3JkZXIgdG8gZ2V0IHRoZSBvdmVyYWxsIHN5c3RlbSB0ZW1wZXJhdHVyZSB0byB0aGUgZGVzaXJlZCBzZXQgcG9pbnQuICBUaGVyZSBpcyBhIHNob3J0IFdpa2lwZWRpYSBlbnRyeSBmb3IgdGhpc1xyXG4gKiBhbGdvcml0aG0gYXQgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQW5kZXJzZW5fdGhlcm1vc3RhdC5cclxuICpcclxuICogQGF1dGhvciBKb2huIEJsYW5jb1xyXG4gKiBAYXV0aG9yIEFhcm9uIERhdmlzXHJcbiAqIEBhdXRob3IgU2lkZGhhcnRoYSBDaGludGhhcGFsbHkgKEFjdHVhbCBDb25jZXB0cylcclxuICovXHJcblxyXG5pbXBvcnQgZG90UmFuZG9tIGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL2RvdC9qcy9kb3RSYW5kb20uanMnO1xyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBJT1R5cGUgZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vdGFuZGVtL2pzL3R5cGVzL0lPVHlwZS5qcyc7XHJcbmltcG9ydCBOdW1iZXJJTyBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi90YW5kZW0vanMvdHlwZXMvTnVtYmVySU8uanMnO1xyXG5pbXBvcnQgc3RhdGVzT2ZNYXR0ZXIgZnJvbSAnLi4vLi4vLi4vLi4vc3RhdGVzT2ZNYXR0ZXIuanMnO1xyXG5pbXBvcnQgU09NQ29uc3RhbnRzIGZyb20gJy4uLy4uLy4uL1NPTUNvbnN0YW50cy5qcyc7XHJcblxyXG4vLyBjb25zdGFudHNcclxuY29uc3QgUFJPUE9SVElPTl9DT01QRU5TQVRJT05fRkFDVE9SID0gMC4yNTsgLy8gdXNlZCBmb3IgZHJpZnQgY29tcGVuc2F0aW9uLCB2YWx1ZSBlbXBpcmljYWxseSBkZXRlcm1pbmVkXHJcbmNvbnN0IElOVEVHUkFMX0NPTVBFTlNBVElPTl9GQUNUT1IgPSAwLjU7IC8vIHVzZWQgZm9yIGRyaWZ0IGNvbXBlbnNhdGlvbiwgdmFsdWUgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZFxyXG5cclxuY2xhc3MgQW5kZXJzZW5UaGVybW9zdGF0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBBbmRlcnNlbiB0aGVybW9zdGF0LlxyXG4gICAqIEBwYXJhbSB7TW9sZWN1bGVGb3JjZUFuZE1vdGlvbkRhdGFTZXR9IG1vbGVjdWxlRGF0YVNldCAgLSBEYXRhIHNldCBvbiB3aGljaCBvcGVyYXRpb25zIHdpbGwgYmUgcGVyZm9ybWVkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5UZW1wZXJhdHVyZSAgLSBUaGUgdGVtcGVyYXR1cmUgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhYnNvbHV0ZSB6ZXJvLCBiZWxvdyB3aGljaCBtb3Rpb24gc2hvdWxkIGNlYXNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIG1vbGVjdWxlRGF0YVNldCwgbWluVGVtcGVyYXR1cmUgKSB7XHJcblxyXG4gICAgLy8gQHB1YmxpYyB0YXJnZXQgdGVtcGVyYXR1cmUgaW4gbm9ybWFsaXplZCBtb2RlbCB1bml0c1xyXG4gICAgdGhpcy50YXJnZXRUZW1wZXJhdHVyZSA9IFNPTUNvbnN0YW50cy5JTklUSUFMX1RFTVBFUkFUVVJFO1xyXG5cclxuICAgIC8vIEBwdWJsaWMgbWluaW11bSB0ZW1wZXJhdHVyZSBpbiBub3JtYWxpemVkIG1vZGVsIHVuaXRzLCBiZWxvdyB0aGlzIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgMDtcclxuICAgIHRoaXMubWluTW9kZWxUZW1wZXJhdHVyZSA9IG1pblRlbXBlcmF0dXJlO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHJlZmVyZW5jZSB0byB0aGUgbW9sZWN1bGUgZGF0YSBzZXRcclxuICAgIHRoaXMubW9sZWN1bGVEYXRhU2V0ID0gbW9sZWN1bGVEYXRhU2V0O1xyXG5cclxuICAgIC8vIEBwcml2YXRlIC0gcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXHJcbiAgICB0aGlzLnJhbmRvbSA9IGRvdFJhbmRvbTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7VmVjdG9yMn0gLSByZXVzYWJsZSB2ZWN0b3IgdXNlZCBmb3IgY2FsY3VsYXRpbmcgdmVsb2NpdHkgY2hhbmdlc1xyXG4gICAgdGhpcy5wcmV2aW91c1BhcnRpY2xlVmVsb2NpdHkgPSBuZXcgVmVjdG9yMiggMCwgMCApO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtWZWN0b3IyfSAtIHZlY3RvcnMgdXNlZCB0byBjb3JyZWN0IGZvciBhIGNvbGxlY3RpdmUgZHJpZnQgdGhhdCBjYW4gb2NjdXJcclxuICAgIHRoaXMudG90YWxWZWxvY2l0eUNoYW5nZVByZXZpb3VzU3RlcCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XHJcbiAgICB0aGlzLnRvdGFsVmVsb2NpdHlDaGFuZ2VUaGlzU3RlcCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XHJcbiAgICB0aGlzLmFjY3VtdWxhdGVkQXZlcmFnZVZlbG9jaXR5Q2hhbmdlID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBhZGp1c3RUZW1wZXJhdHVyZSgpIHtcclxuXHJcbiAgICAvLyBBIE5vdGUgdG8gRnV0dXJlIE1haW50YWluZXJzOiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgcHJvdmlkZWQgYnkgUGF1bCBCZWFsZSBvZiB0aGUgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBhbmRcclxuICAgIC8vIGNvbnZlcnRlZCBpbnRvIEphdmEsIGFuZCB0aGVuIEphdmFTY3JpcHQsIGJ5IEBqYnBoZXQuIEZvciBtYW55IHllYXJzLCBpdCBoYWQgc2VwYXJhdGUgZ2FtbWEgdmFsdWVzIHRoZSBYIGFuZCBZXHJcbiAgICAvLyBkaXJlY3Rpb25zLCBidXQgdGhvc2UgdmFsdWVzIHdlcmUgYWx3YXlzIHNldCB0byB0aGUgc2FtZSB0aGluZy4gIEluIGVhcmx5IEF1Z3VzdCBvZiAyMDE4LCBJIChqYnBoZXQpIHJlZmFjdG9yZWRcclxuICAgIC8vIHRoaXMgdG8gaGF2ZSBhIHNpbmdsZSBnYW1tYSB2YWx1ZSBpbiBvcmRlciB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBjYWxjdWxhdGlvbnMgZG9uZSBhbmQgdGh1cyBpbXByb3ZlXHJcbiAgICAvLyBwZXJmb3JtYW5jZS4gIElmIGl0J3MgZXZlciBuZWVkZWQsIHNlcGFyYXRlIHZhbHVlcyBjb3VsZCBiZSBicm91Z2h0IGJhY2sgZm9yIFggYW5kIFkuXHJcblxyXG4gICAgbGV0IGdhbW1hO1xyXG4gICAgbGV0IHRlbXBlcmF0dXJlID0gdGhpcy50YXJnZXRUZW1wZXJhdHVyZTtcclxuICAgIGlmICggdGVtcGVyYXR1cmUgPiB0aGlzLm1pbk1vZGVsVGVtcGVyYXR1cmUgKSB7XHJcblxyXG4gICAgICAvLyBVc2UgYSB2YWx1ZXMgdGhhdCB3aWxsIGNhdXNlIHRoZSBtb2xlY3VsZXMgdG8gc3RvcCBtb3ZpbmcgcHJldHR5IHF1aWNrbHkgaWYgd2UgYXJlIGJlbG93IHRoZSBtaW5pbXVtXHJcbiAgICAgIC8vIHRlbXBlcmF0dXJlLCBzaW5jZSB3ZSB3YW50IHRvIGNyZWF0ZSB0aGUgYXBwZWFyYW5jZSBvZiBhYnNvbHV0ZSB6ZXJvLiAgVmFsdWVzIHdlcmUgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZC5cclxuICAgICAgZ2FtbWEgPSAwLjk5OTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgICAgLy8gVXNlIGEgdmFsdWVzIHRoYXQgd2lsbCBjYXVzZSB0aGUgbW9sZWN1bGVzIHRvIHN0b3AgbW92aW5nIHByZXR0eSBxdWlja2x5IGlmIHdlIGFyZSBiZWxvdyB0aGUgbWluaW11bVxyXG4gICAgICAvLyB0ZW1wZXJhdHVyZSwgc2luY2Ugd2Ugd2FudCB0byBjcmVhdGUgdGhlIGFwcGVhcmFuY2Ugb2YgYWJzb2x1dGUgemVyby4gIFZhbHVlcyB3ZXJlIGVtcGlyaWNhbGx5IGRldGVybWluZWQuXHJcbiAgICAgIGdhbW1hID0gMC41O1xyXG4gICAgICB0ZW1wZXJhdHVyZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWFzc0ludmVyc2UgPSAxIC8gdGhpcy5tb2xlY3VsZURhdGFTZXQubW9sZWN1bGVNYXNzO1xyXG4gICAgY29uc3QgaW5lcnRpYUludmVyc2UgPSAxIC8gdGhpcy5tb2xlY3VsZURhdGFTZXQubW9sZWN1bGVSb3RhdGlvbmFsSW5lcnRpYTtcclxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSB0ZW1wZXJhdHVyZSAqICggMSAtIE1hdGgucG93KCBnYW1tYSwgMiApICk7XHJcbiAgICBjb25zdCB2ZWxvY2l0eVNjYWxpbmdGYWN0b3IgPSBNYXRoLnNxcnQoIG1hc3NJbnZlcnNlICogc2NhbGluZ0ZhY3RvciApO1xyXG4gICAgY29uc3Qgcm90YXRpb25TY2FsaW5nRmFjdG9yID0gTWF0aC5zcXJ0KCBpbmVydGlhSW52ZXJzZSAqIHNjYWxpbmdGYWN0b3IgKTtcclxuICAgIGNvbnN0IG51bU1vbGVjdWxlcyA9IHRoaXMubW9sZWN1bGVEYXRhU2V0LmdldE51bWJlck9mTW9sZWN1bGVzKCk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGEgY29tcGVuc2F0aW9uIGZhY3RvciBmb3IgYW55IG92ZXJhbGwgZHJpZnQgdGhhdCBpcyBiZWluZyBhZGRlZCBieSB0aGlzIHRoZXJtb3N0YXQuICBXaXRob3V0IHRoaXMsXHJcbiAgICAvLyB3ZSBvZnRlbiBzZWUgc29saWRzIGRyaWZ0aW5nIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IGZvciBubyBhcHBhcmVudCByZWFzb24uICBDb21wZW5zYXRpb24gaXMgb25seSBkb25lIGluIHRoZSBYXHJcbiAgICAvLyBkaXJlY3Rpb24gc2luY2UgdGhlIFkgZGlyZWN0aW9uIHdhc24ndCB2aXN1YWxseSBwcm9ibGVtYXRpYy4gIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoaXMsIHBsZWFzZSBzZWVcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9zdGF0ZXMtb2YtbWF0dGVyLWJhc2ljcy9pc3N1ZXMvMTUuXHJcbiAgICBjb25zdCB4Q29tcGVuc2F0aW9uID0gLXRoaXMudG90YWxWZWxvY2l0eUNoYW5nZVByZXZpb3VzU3RlcC54IC8gbnVtTW9sZWN1bGVzICogUFJPUE9SVElPTl9DT01QRU5TQVRJT05fRkFDVE9SIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY3VtdWxhdGVkQXZlcmFnZVZlbG9jaXR5Q2hhbmdlLnggKiBJTlRFR1JBTF9DT01QRU5TQVRJT05fRkFDVE9SO1xyXG5cclxuICAgIC8vIGxvY2FsIHZhcnMgZm9yIGNvbnZlbmllbmNlIGFuZCBwZXJmb3JtYW5jZVxyXG4gICAgY29uc3QgbW9sZWN1bGVWZWxvY2l0aWVzID0gdGhpcy5tb2xlY3VsZURhdGFTZXQubW9sZWN1bGVWZWxvY2l0aWVzO1xyXG4gICAgY29uc3QgbW9sZWN1bGVSb3RhdGlvblJhdGVzID0gdGhpcy5tb2xlY3VsZURhdGFTZXQubW9sZWN1bGVSb3RhdGlvblJhdGVzO1xyXG5cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IG51bU1vbGVjdWxlczsgaSsrICkge1xyXG4gICAgICBjb25zdCBtb2xlY3VsZVZlbG9jaXR5ID0gbW9sZWN1bGVWZWxvY2l0aWVzWyBpIF07XHJcbiAgICAgIHRoaXMucHJldmlvdXNQYXJ0aWNsZVZlbG9jaXR5LnNldCggbW9sZWN1bGVWZWxvY2l0eSApO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgeCBhbmQgeSB2ZWxvY2l0eSBmb3IgdGhpcyBwYXJ0aWNsZS5cclxuICAgICAgY29uc3QgeFZlbCA9IG1vbGVjdWxlVmVsb2NpdHkueCAqIGdhbW1hICsgdGhpcy5yYW5kb20ubmV4dEdhdXNzaWFuKCkgKiB2ZWxvY2l0eVNjYWxpbmdGYWN0b3IgKyB4Q29tcGVuc2F0aW9uO1xyXG4gICAgICBjb25zdCB5VmVsID0gbW9sZWN1bGVWZWxvY2l0eS55ICogZ2FtbWEgKyB0aGlzLnJhbmRvbS5uZXh0R2F1c3NpYW4oKSAqIHZlbG9jaXR5U2NhbGluZ0ZhY3RvcjtcclxuICAgICAgbW9sZWN1bGVWZWxvY2l0eS5zZXRYWSggeFZlbCwgeVZlbCApO1xyXG4gICAgICBtb2xlY3VsZVJvdGF0aW9uUmF0ZXNbIGkgXSA9IGdhbW1hICogbW9sZWN1bGVSb3RhdGlvblJhdGVzWyBpIF0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmFuZG9tLm5leHRHYXVzc2lhbigpICogcm90YXRpb25TY2FsaW5nRmFjdG9yO1xyXG4gICAgICB0aGlzLnRvdGFsVmVsb2NpdHlDaGFuZ2VUaGlzU3RlcC5hZGRYWShcclxuICAgICAgICB4VmVsIC0gdGhpcy5wcmV2aW91c1BhcnRpY2xlVmVsb2NpdHkueCxcclxuICAgICAgICB5VmVsIC0gdGhpcy5wcmV2aW91c1BhcnRpY2xlVmVsb2NpdHkueVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hY2N1bXVsYXRlZEF2ZXJhZ2VWZWxvY2l0eUNoYW5nZS5hZGRYWShcclxuICAgICAgdGhpcy50b3RhbFZlbG9jaXR5Q2hhbmdlVGhpc1N0ZXAueCAvIG51bU1vbGVjdWxlcyxcclxuICAgICAgdGhpcy50b3RhbFZlbG9jaXR5Q2hhbmdlVGhpc1N0ZXAueSAvIG51bU1vbGVjdWxlc1xyXG4gICAgKTtcclxuICAgIHRoaXMudG90YWxWZWxvY2l0eUNoYW5nZVByZXZpb3VzU3RlcC5zZXQoIHRoaXMudG90YWxWZWxvY2l0eUNoYW5nZVRoaXNTdGVwICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjbGVhciB0aGUgYWNjdW11bGF0ZWQgdmVsb2NpdHkgYmlhcywgc2hvdWxkIGJlIGRvbmUgd2hlbiB0aGlzIHRoZXJtb3N0YXQgc3RhcnRzIGJlaW5nIHVzZWQgZm9yIGEgbnVtYmVyIG9mIHN0ZXBzXHJcbiAgICogaW4gYSByb3dcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgY2xlYXJBY2N1bXVsYXRlZEJpYXMoKSB7XHJcbiAgICB0aGlzLmFjY3VtdWxhdGVkQXZlcmFnZVZlbG9jaXR5Q2hhbmdlLnNldFhZKCAwLCAwICk7XHJcbiAgICB0aGlzLnRvdGFsVmVsb2NpdHlDaGFuZ2VQcmV2aW91c1N0ZXAuc2V0WFkoIDAsIDAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGN1cnJlbnQgc3RhdGUsIHVzZWQgdG8gcmVzdG9yZSBzdGF0ZSB1c2luZyBzZXRTdGF0ZSwgdXNlZCBvbmx5IGZvciBwaGV0LWlvLlxyXG4gICAqIEBwdWJsaWMgLSBmb3IgcGhldC1pbyBzdXBwb3J0IG9ubHlcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIHRvU3RhdGVPYmplY3QoKSB7XHJcblxyXG4gICAgLy8gTm90ZTogVGhlIG1vbGVjdWxlRGF0YVNldCBpcyAqbm90KiBpbmNsdWRlZCBhcyBwYXJ0IG9mIHRoZSBzdGF0ZSBiZWNhdXNlIHRoaXMgaXMgYXNzdW1lZCB0byBiZSBhIHJlZmVyZW5jZSB0aGF0XHJcbiAgICAvLyBpcyBzaGFyZWQgd2l0aCB0aGUgbW9kZWwsIGFuZCB0aGUgbW9kZWwgaXMgcmVzcG9uc2libGUgZm9yIHVwZGF0aW5nIGl0cyBzdGF0ZSBkdXJpbmcgZGVzZXJpYWxpemF0aW9uLlxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRhcmdldFRlbXBlcmF0dXJlOiB0aGlzLnRhcmdldFRlbXBlcmF0dXJlLFxyXG4gICAgICBtaW5Nb2RlbFRlbXBlcmF0dXJlOiB0aGlzLm1pbk1vZGVsVGVtcGVyYXR1cmUsXHJcbiAgICAgIHByZXZpb3VzUGFydGljbGVWZWxvY2l0eTogdGhpcy5wcmV2aW91c1BhcnRpY2xlVmVsb2NpdHkudG9TdGF0ZU9iamVjdCgpLFxyXG4gICAgICB0b3RhbFZlbG9jaXR5Q2hhbmdlUHJldmlvdXNTdGVwOiB0aGlzLnRvdGFsVmVsb2NpdHlDaGFuZ2VQcmV2aW91c1N0ZXAudG9TdGF0ZU9iamVjdCgpLFxyXG4gICAgICB0b3RhbFZlbG9jaXR5Q2hhbmdlVGhpc1N0ZXA6IHRoaXMudG90YWxWZWxvY2l0eUNoYW5nZVRoaXNTdGVwLnRvU3RhdGVPYmplY3QoKSxcclxuICAgICAgYWNjdW11bGF0ZWRBdmVyYWdlVmVsb2NpdHlDaGFuZ2U6IHRoaXMuYWNjdW11bGF0ZWRBdmVyYWdlVmVsb2NpdHlDaGFuZ2UudG9TdGF0ZU9iamVjdCgpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBzdGF0ZSBvZiB0aGlzIGluc3RhbmNlIGZvciBwaGV0LWlvLiAgVGhpcyBpcyB1c2VkIGZvciBwaGV0LWlvLCBidXQgbm90IGRpcmVjdGx5IGJ5IHRoZSBQaGV0aW9TdGF0ZUVuZ2luZSAtXHJcbiAgICogaXQgaXMgaW5zdGVhZCBjYWxsZWQgZHVyaW5nIGV4cGxpY2l0IGRlLXNlcmlhbGl6YXRpb24uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlT2JqZWN0IC0gcmV0dXJuZWQgZnJvbSB0b1N0YXRlT2JqZWN0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHNldFN0YXRlKCBzdGF0ZU9iamVjdCApIHtcclxuXHJcbiAgICAvLyBOb3RlOiBUaGUgbW9sZWN1bGVEYXRhU2V0IGlzICpub3QqIGluY2x1ZGVkIGFzIHBhcnQgb2YgdGhlIHN0YXRlIGJlY2F1c2UgdGhpcyBpcyBhc3N1bWVkIHRvIGJlIGEgcmVmZXJlbmNlIHRoYXRcclxuICAgIC8vIGlzIHNoYXJlZCB3aXRoIHRoZSBtb2RlbCwgYW5kIHRoZSBtb2RlbCBpcyByZXNwb25zaWJsZSBmb3IgdXBkYXRpbmcgaXRzIHN0YXRlIGR1cmluZyBkZXNlcmlhbGl6YXRpb24uXHJcblxyXG4gICAgdGhpcy50YXJnZXRUZW1wZXJhdHVyZSA9IHN0YXRlT2JqZWN0LnRhcmdldFRlbXBlcmF0dXJlO1xyXG4gICAgdGhpcy5taW5Nb2RlbFRlbXBlcmF0dXJlID0gc3RhdGVPYmplY3QubWluTW9kZWxUZW1wZXJhdHVyZTtcclxuICAgIHRoaXMucHJldmlvdXNQYXJ0aWNsZVZlbG9jaXR5LnNldCggc3RhdGVPYmplY3QucHJldmlvdXNQYXJ0aWNsZVZlbG9jaXR5ICk7XHJcbiAgICB0aGlzLnRvdGFsVmVsb2NpdHlDaGFuZ2VQcmV2aW91c1N0ZXAuc2V0KCBzdGF0ZU9iamVjdC50b3RhbFZlbG9jaXR5Q2hhbmdlUHJldmlvdXNTdGVwICk7XHJcbiAgICB0aGlzLnRvdGFsVmVsb2NpdHlDaGFuZ2VUaGlzU3RlcC5zZXQoIHN0YXRlT2JqZWN0LnRvdGFsVmVsb2NpdHlDaGFuZ2VUaGlzU3RlcCApO1xyXG4gICAgdGhpcy5hY2N1bXVsYXRlZEF2ZXJhZ2VWZWxvY2l0eUNoYW5nZS5zZXQoIHN0YXRlT2JqZWN0LmFjY3VtdWxhdGVkQXZlcmFnZVZlbG9jaXR5Q2hhbmdlICk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBAcHVibGljXHJcbkFuZGVyc2VuVGhlcm1vc3RhdC5BbmRlcnNlblRoZXJtb3N0YXRJTyA9IG5ldyBJT1R5cGUoICdBbmRlcnNlblRoZXJtb3N0YXRJTycsIHtcclxuICB2YWx1ZVR5cGU6IEFuZGVyc2VuVGhlcm1vc3RhdCxcclxuICBzdGF0ZVNjaGVtYToge1xyXG4gICAgdGFyZ2V0VGVtcGVyYXR1cmU6IE51bWJlcklPLFxyXG4gICAgbWluTW9kZWxUZW1wZXJhdHVyZTogTnVtYmVySU8sXHJcbiAgICBwcmV2aW91c1BhcnRpY2xlVmVsb2NpdHk6IFZlY3RvcjIuVmVjdG9yMklPLFxyXG4gICAgdG90YWxWZWxvY2l0eUNoYW5nZVByZXZpb3VzU3RlcDogVmVjdG9yMi5WZWN0b3IySU8sXHJcbiAgICB0b3RhbFZlbG9jaXR5Q2hhbmdlVGhpc1N0ZXA6IFZlY3RvcjIuVmVjdG9yMklPLFxyXG4gICAgYWNjdW11bGF0ZWRBdmVyYWdlVmVsb2NpdHlDaGFuZ2U6IFZlY3RvcjIuVmVjdG9yMklPXHJcbiAgfVxyXG59ICk7XHJcblxyXG5zdGF0ZXNPZk1hdHRlci5yZWdpc3RlciggJ0FuZGVyc2VuVGhlcm1vc3RhdCcsIEFuZGVyc2VuVGhlcm1vc3RhdCApO1xyXG5leHBvcnQgZGVmYXVsdCBBbmRlcnNlblRoZXJtb3N0YXQ7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsU0FBUyxNQUFNLHVDQUF1QztBQUM3RCxPQUFPQyxPQUFPLE1BQU0scUNBQXFDO0FBQ3pELE9BQU9DLE1BQU0sTUFBTSw2Q0FBNkM7QUFDaEUsT0FBT0MsUUFBUSxNQUFNLCtDQUErQztBQUNwRSxPQUFPQyxjQUFjLE1BQU0sK0JBQStCO0FBQzFELE9BQU9DLFlBQVksTUFBTSwwQkFBMEI7O0FBRW5EO0FBQ0EsTUFBTUMsOEJBQThCLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDN0MsTUFBTUMsNEJBQTRCLEdBQUcsR0FBRyxDQUFDLENBQUM7O0FBRTFDLE1BQU1DLGtCQUFrQixDQUFDO0VBRXZCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsV0FBV0EsQ0FBRUMsZUFBZSxFQUFFQyxjQUFjLEVBQUc7SUFFN0M7SUFDQSxJQUFJLENBQUNDLGlCQUFpQixHQUFHUCxZQUFZLENBQUNRLG1CQUFtQjs7SUFFekQ7SUFDQSxJQUFJLENBQUNDLG1CQUFtQixHQUFHSCxjQUFjOztJQUV6QztJQUNBLElBQUksQ0FBQ0QsZUFBZSxHQUFHQSxlQUFlOztJQUV0QztJQUNBLElBQUksQ0FBQ0ssTUFBTSxHQUFH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