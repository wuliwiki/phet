// Copyright 2017-2022, University of Colorado Boulder

/**
 * A range label that displays a specific TermList along a line covering the range (with start/end ticks for every
 * partition)
 *
 * NOTE: This type is designed to be persistent, and will not need to release references to avoid memory leaks.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import Orientation from '../../../../phet-core/js/Orientation.js';
import { Line, Node, RichText } from '../../../../scenery/js/imports.js';
import areaModelCommon from '../../areaModelCommon.js';
import AreaModelCommonConstants from '../AreaModelCommonConstants.js';

// constants
const TICK_LENGTH = 10; // How long the tick marks are for the range labels

class RangeLabelNode extends Node {
  /**
   * @param {Property.<TermList|null>} termListProperty
   * @param {Orientation} orientation
   * @param {Property.<Array.<number>>} tickPositionsProperty - In view coordinates
   * @param {Property.<Color>} colorProperty
   * @param {boolean} isProportional - Whether the area is shown as proportional (instead of generic)
   */
  constructor(termListProperty, orientation, tickPositionsProperty, colorProperty, isProportional) {
    super();
    const rangeOffset = (isProportional ? AreaModelCommonConstants.PROPORTIONAL_RANGE_OFFSET : AreaModelCommonConstants.GENERIC_RANGE_OFFSET)[orientation.opposite.coordinate];
    const richText = new RichText('', {
      font: AreaModelCommonConstants.TOTAL_SIZE_READOUT_FONT,
      fill: colorProperty
    });

    // Constrain width on the left side (don't let it go out of the layout bounds)
    if (orientation === Orientation.VERTICAL) {
      const verticalRangeOffset = isProportional ? AreaModelCommonConstants.PROPORTIONAL_RANGE_OFFSET : AreaModelCommonConstants.GENERIC_RANGE_OFFSET;
      richText.maxWidth = AreaModelCommonConstants.MAIN_AREA_OFFSET.x + verticalRangeOffset.x - AreaModelCommonConstants.LAYOUT_SPACING;
    }

    // Update the label richText
    termListProperty.link(termList => {
      const hasTerms = termList !== null && termList.terms.length > 0;
      richText.visible = hasTerms;
      if (hasTerms) {
        richText.string = termList.toRichString();

        // Relative positioning
        if (orientation === Orientation.HORIZONTAL) {
          richText.centerBottom = Vector2.ZERO;
        } else {
          richText.rightCenter = Vector2.ZERO;
        }
      }
    });

    // Wrap our text in a label, so that we can handle positioning independent of bounds checks
    const textContainer = new Node({
      children: [richText]
    });
    this.addChild(textContainer);

    // Coordinate that doesn't change. Customized offsets added
    textContainer[orientation.opposite.coordinate] = rangeOffset + (orientation === Orientation.HORIZONTAL ? -3 : -5);

    // Our main line, that the tick marks will be off of
    const line = new Line({
      stroke: colorProperty
    });
    this.addChild(line);
    const ticks = [];

    // Update the layout
    tickPositionsProperty.link(tickPositions => {
      assert && assert(tickPositions.length === 0 || tickPositions.length >= 2);
      if (tickPositions.length === 0) {
        ticks.forEach(tick => {
          tick.visible = false;
        });
      } else {
        // Add any ticks that we need
        while (ticks.length < tickPositions.length) {
          const tick = new Line({
            y1: 0,
            y2: TICK_LENGTH / 2,
            stroke: colorProperty,
            rotation: orientation === Orientation.HORIZONTAL ? 0 : -Math.PI / 2
          });
          ticks.push(tick);
          this.addChild(tick);
        }
        ticks.forEach((tick, index) => {
          if (index < tickPositions.length) {
            tick.visible = true;
            tick.translation = orientation.toVector(tickPositions[index], rangeOffset, Vector2);

            // The first/last ticks should have a different length
            tick.y1 = index === 0 || index === tickPositions.length - 1 ? -TICK_LENGTH / 2 : 0;
          } else {
            tick.visible = false;
          }
        });
        const minPosition = tickPositions[0];
        const maxPosition = tickPositions[tickPositions.length - 1];
        line.p1 = orientation.toVector(minPosition, rangeOffset, Vector2);
        line.p2 = orientation.toVector(maxPosition, rangeOffset, Vector2);
        textContainer[orientation.coordinate] = (maxPosition + minPosition) / 2; // centered
      }
    });
  }
}

areaModelCommon.register('RangeLabelNode', RangeLabelNode);
export default RangeLabelNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiT3JpZW50YXRpb24iLCJMaW5lIiwiTm9kZSIsIlJpY2hUZXh0IiwiYXJlYU1vZGVsQ29tbW9uIiwiQXJlYU1vZGVsQ29tbW9uQ29uc3RhbnRzIiwiVElDS19MRU5HVEgiLCJSYW5nZUxhYmVsTm9kZSIsImNvbnN0cnVjdG9yIiwidGVybUxpc3RQcm9wZXJ0eSIsIm9yaWVudGF0aW9uIiwidGlja1Bvc2l0aW9uc1Byb3BlcnR5IiwiY29sb3JQcm9wZXJ0eSIsImlzUHJvcG9ydGlvbmFsIiwicmFuZ2VPZmZzZXQiLCJQUk9QT1JUSU9OQUxfUkFOR0VfT0ZGU0VUIiwiR0VORVJJQ19SQU5HRV9PRkZTRVQiLCJvcHBvc2l0ZSIsImNvb3JkaW5hdGUiLCJyaWNoVGV4dCIsImZvbnQiLCJUT1RBTF9TSVpFX1JFQURPVVRfRk9OVCIsImZpbGwiLCJWRVJUSUNBTCIsInZlcnRpY2FsUmFuZ2VPZmZzZXQiLCJtYXhXaWR0aCIsIk1BSU5fQVJFQV9PRkZTRVQiLCJ4IiwiTEFZT1VUX1NQQUNJTkciLCJsaW5rIiwidGVybUxpc3QiLCJoYXNUZXJtcyIsInRlcm1zIiwibGVuZ3RoIiwidmlzaWJsZSIsInN0cmluZyIsInRvUmljaFN0cmluZyIsIkhPUklaT05UQUwiLCJjZW50ZXJCb3R0b20iLCJaRVJPIiwicmlnaHRDZW50ZXIiLCJ0ZXh0Q29udGFpbmVyIiwiY2hpbGRyZW4iLCJhZGRDaGlsZCIsImxpbmUiLCJzdHJva2UiLCJ0aWNrcyIsInRpY2tQb3NpdGlvbnMiLCJhc3NlcnQiLCJmb3JFYWNoIiwidGljayIsInkxIiwieTIiLCJyb3RhdGlvbiIsIk1hdGgiLCJQSSIsInB1c2giLCJpbmRleCIsInRyYW5zbGF0aW9uIiwidG9WZWN0b3IiLCJtaW5Qb3NpdGlvbiIsIm1heFBvc2l0aW9uIiwicDEiLCJwMiIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiUmFuZ2VMYWJlbE5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTctMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSByYW5nZSBsYWJlbCB0aGF0IGRpc3BsYXlzIGEgc3BlY2lmaWMgVGVybUxpc3QgYWxvbmcgYSBsaW5lIGNvdmVyaW5nIHRoZSByYW5nZSAod2l0aCBzdGFydC9lbmQgdGlja3MgZm9yIGV2ZXJ5XHJcbiAqIHBhcnRpdGlvbilcclxuICpcclxuICogTk9URTogVGhpcyB0eXBlIGlzIGRlc2lnbmVkIHRvIGJlIHBlcnNpc3RlbnQsIGFuZCB3aWxsIG5vdCBuZWVkIHRvIHJlbGVhc2UgcmVmZXJlbmNlcyB0byBhdm9pZCBtZW1vcnkgbGVha3MuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cclxuICovXHJcblxyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCBPcmllbnRhdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvT3JpZW50YXRpb24uanMnO1xyXG5pbXBvcnQgeyBMaW5lLCBOb2RlLCBSaWNoVGV4dCB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBhcmVhTW9kZWxDb21tb24gZnJvbSAnLi4vLi4vYXJlYU1vZGVsQ29tbW9uLmpzJztcclxuaW1wb3J0IEFyZWFNb2RlbENvbW1vbkNvbnN0YW50cyBmcm9tICcuLi9BcmVhTW9kZWxDb21tb25Db25zdGFudHMuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IFRJQ0tfTEVOR1RIID0gMTA7IC8vIEhvdyBsb25nIHRoZSB0aWNrIG1hcmtzIGFyZSBmb3IgdGhlIHJhbmdlIGxhYmVsc1xyXG5cclxuY2xhc3MgUmFuZ2VMYWJlbE5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5LjxUZXJtTGlzdHxudWxsPn0gdGVybUxpc3RQcm9wZXJ0eVxyXG4gICAqIEBwYXJhbSB7T3JpZW50YXRpb259IG9yaWVudGF0aW9uXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eS48QXJyYXkuPG51bWJlcj4+fSB0aWNrUG9zaXRpb25zUHJvcGVydHkgLSBJbiB2aWV3IGNvb3JkaW5hdGVzXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eS48Q29sb3I+fSBjb2xvclByb3BlcnR5XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1Byb3BvcnRpb25hbCAtIFdoZXRoZXIgdGhlIGFyZWEgaXMgc2hvd24gYXMgcHJvcG9ydGlvbmFsIChpbnN0ZWFkIG9mIGdlbmVyaWMpXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIHRlcm1MaXN0UHJvcGVydHksIG9yaWVudGF0aW9uLCB0aWNrUG9zaXRpb25zUHJvcGVydHksIGNvbG9yUHJvcGVydHksIGlzUHJvcG9ydGlvbmFsICkge1xyXG5cclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgY29uc3QgcmFuZ2VPZmZzZXQgPSAoIGlzUHJvcG9ydGlvbmFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBBcmVhTW9kZWxDb21tb25Db25zdGFudHMuUFJPUE9SVElPTkFMX1JBTkdFX09GRlNFVFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogQXJlYU1vZGVsQ29tbW9uQ29uc3RhbnRzLkdFTkVSSUNfUkFOR0VfT0ZGU0VUIClbIG9yaWVudGF0aW9uLm9wcG9zaXRlLmNvb3JkaW5hdGUgXTtcclxuXHJcbiAgICBjb25zdCByaWNoVGV4dCA9IG5ldyBSaWNoVGV4dCggJycsIHtcclxuICAgICAgZm9udDogQXJlYU1vZGVsQ29tbW9uQ29uc3RhbnRzLlRPVEFMX1NJWkVfUkVBRE9VVF9GT05ULFxyXG4gICAgICBmaWxsOiBjb2xvclByb3BlcnR5XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gQ29uc3RyYWluIHdpZHRoIG9uIHRoZSBsZWZ0IHNpZGUgKGRvbid0IGxldCBpdCBnbyBvdXQgb2YgdGhlIGxheW91dCBib3VuZHMpXHJcbiAgICBpZiAoIG9yaWVudGF0aW9uID09PSBPcmllbnRhdGlvbi5WRVJUSUNBTCApIHtcclxuICAgICAgY29uc3QgdmVydGljYWxSYW5nZU9mZnNldCA9IGlzUHJvcG9ydGlvbmFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IEFyZWFNb2RlbENvbW1vbkNvbnN0YW50cy5QUk9QT1JUSU9OQUxfUkFOR0VfT0ZGU0VUXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IEFyZWFNb2RlbENvbW1vbkNvbnN0YW50cy5HRU5FUklDX1JBTkdFX09GRlNFVDtcclxuICAgICAgcmljaFRleHQubWF4V2lkdGggPSBBcmVhTW9kZWxDb21tb25Db25zdGFudHMuTUFJTl9BUkVBX09GRlNFVC54ICsgdmVydGljYWxSYW5nZU9mZnNldC54IC0gQXJlYU1vZGVsQ29tbW9uQ29uc3RhbnRzLkxBWU9VVF9TUEFDSU5HO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgbGFiZWwgcmljaFRleHRcclxuICAgIHRlcm1MaXN0UHJvcGVydHkubGluayggdGVybUxpc3QgPT4ge1xyXG5cclxuICAgICAgY29uc3QgaGFzVGVybXMgPSB0ZXJtTGlzdCAhPT0gbnVsbCAmJiB0ZXJtTGlzdC50ZXJtcy5sZW5ndGggPiAwO1xyXG5cclxuICAgICAgcmljaFRleHQudmlzaWJsZSA9IGhhc1Rlcm1zO1xyXG4gICAgICBpZiAoIGhhc1Rlcm1zICkge1xyXG4gICAgICAgIHJpY2hUZXh0LnN0cmluZyA9IHRlcm1MaXN0LnRvUmljaFN0cmluZygpO1xyXG5cclxuICAgICAgICAvLyBSZWxhdGl2ZSBwb3NpdGlvbmluZ1xyXG4gICAgICAgIGlmICggb3JpZW50YXRpb24gPT09IE9yaWVudGF0aW9uLkhPUklaT05UQUwgKSB7XHJcbiAgICAgICAgICByaWNoVGV4dC5jZW50ZXJCb3R0b20gPSBWZWN0b3IyLlpFUk87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmljaFRleHQucmlnaHRDZW50ZXIgPSBWZWN0b3IyLlpFUk87XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gV3JhcCBvdXIgdGV4dCBpbiBhIGxhYmVsLCBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgcG9zaXRpb25pbmcgaW5kZXBlbmRlbnQgb2YgYm91bmRzIGNoZWNrc1xyXG4gICAgY29uc3QgdGV4dENvbnRhaW5lciA9IG5ldyBOb2RlKCB7XHJcbiAgICAgIGNoaWxkcmVuOiBbIHJpY2hUZXh0IF1cclxuICAgIH0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIHRleHRDb250YWluZXIgKTtcclxuXHJcbiAgICAvLyBDb29yZGluYXRlIHRoYXQgZG9lc24ndCBjaGFuZ2UuIEN1c3RvbWl6ZWQgb2Zmc2V0cyBhZGRlZFxyXG4gICAgdGV4dENvbnRhaW5lclsgb3JpZW50YXRpb24ub3Bwb3NpdGUuY29vcmRpbmF0ZSBdID0gcmFuZ2VPZmZzZXQgKyAoIG9yaWVudGF0aW9uID09PSBPcmllbnRhdGlvbi5IT1JJWk9OVEFMID8gLTMgOiAtNSApO1xyXG5cclxuICAgIC8vIE91ciBtYWluIGxpbmUsIHRoYXQgdGhlIHRpY2sgbWFya3Mgd2lsbCBiZSBvZmYgb2ZcclxuICAgIGNvbnN0IGxpbmUgPSBuZXcgTGluZSgge1xyXG4gICAgICBzdHJva2U6IGNvbG9yUHJvcGVydHlcclxuICAgIH0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIGxpbmUgKTtcclxuXHJcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgbGF5b3V0XHJcbiAgICB0aWNrUG9zaXRpb25zUHJvcGVydHkubGluayggdGlja1Bvc2l0aW9ucyA9PiB7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHRpY2tQb3NpdGlvbnMubGVuZ3RoID09PSAwIHx8IHRpY2tQb3NpdGlvbnMubGVuZ3RoID49IDIgKTtcclxuXHJcbiAgICAgIGlmICggdGlja1Bvc2l0aW9ucy5sZW5ndGggPT09IDAgKSB7XHJcbiAgICAgICAgdGlja3MuZm9yRWFjaCggdGljayA9PiB7XHJcbiAgICAgICAgICB0aWNrLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9ICk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIEFkZCBhbnkgdGlja3MgdGhhdCB3ZSBuZWVkXHJcbiAgICAgICAgd2hpbGUgKCB0aWNrcy5sZW5ndGggPCB0aWNrUG9zaXRpb25zLmxlbmd0aCApIHtcclxuICAgICAgICAgIGNvbnN0IHRpY2sgPSBuZXcgTGluZSgge1xyXG4gICAgICAgICAgICB5MTogMCxcclxuICAgICAgICAgICAgeTI6IFRJQ0tfTEVOR1RIIC8gMixcclxuICAgICAgICAgICAgc3Ryb2tlOiBjb2xvclByb3BlcnR5LFxyXG4gICAgICAgICAgICByb3RhdGlvbjogb3JpZW50YXRpb24gPT09IE9yaWVudGF0aW9uLkhPUklaT05UQUwgPyAwIDogLU1hdGguUEkgLyAyXHJcbiAgICAgICAgICB9ICk7XHJcbiAgICAgICAgICB0aWNrcy5wdXNoKCB0aWNrICk7XHJcbiAgICAgICAgICB0aGlzLmFkZENoaWxkKCB0aWNrICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aWNrcy5mb3JFYWNoKCAoIHRpY2ssIGluZGV4ICkgPT4ge1xyXG4gICAgICAgICAgaWYgKCBpbmRleCA8IHRpY2tQb3NpdGlvbnMubGVuZ3RoICkge1xyXG4gICAgICAgICAgICB0aWNrLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aWNrLnRyYW5zbGF0aW9uID0gb3JpZW50YXRpb24udG9WZWN0b3IoIHRpY2tQb3NpdGlvbnNbIGluZGV4IF0sIHJhbmdlT2Zmc2V0LCBWZWN0b3IyICk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QvbGFzdCB0aWNrcyBzaG91bGQgaGF2ZSBhIGRpZmZlcmVudCBsZW5ndGhcclxuICAgICAgICAgICAgdGljay55MSA9ICggaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHRpY2tQb3NpdGlvbnMubGVuZ3RoIC0gMSApID8gLVRJQ0tfTEVOR1RIIC8gMiA6IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGljay52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgICAgICBjb25zdCBtaW5Qb3NpdGlvbiA9IHRpY2tQb3NpdGlvbnNbIDAgXTtcclxuICAgICAgICBjb25zdCBtYXhQb3NpdGlvbiA9IHRpY2tQb3NpdGlvbnNbIHRpY2tQb3NpdGlvbnMubGVuZ3RoIC0gMSBdO1xyXG5cclxuICAgICAgICBsaW5lLnAxID0gb3JpZW50YXRpb24udG9WZWN0b3IoIG1pblBvc2l0aW9uLCByYW5nZU9mZnNldCwgVmVjdG9yMiApO1xyXG4gICAgICAgIGxpbmUucDIgPSBvcmllbnRhdGlvbi50b1ZlY3RvciggbWF4UG9zaXRpb24sIHJhbmdlT2Zmc2V0LCBWZWN0b3IyICk7XHJcbiAgICAgICAgdGV4dENvbnRhaW5lclsgb3JpZW50YXRpb24uY29vcmRpbmF0ZSBdID0gKCBtYXhQb3NpdGlvbiArIG1pblBvc2l0aW9uICkgLyAyOyAvLyBjZW50ZXJlZFxyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcbiAgfVxyXG59XHJcblxyXG5hcmVhTW9kZWxDb21tb24ucmVnaXN0ZXIoICdSYW5nZUxhYmVsTm9kZScsIFJhbmdlTGFiZWxOb2RlICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSYW5nZUxhYmVsTm9kZTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsV0FBVyxNQUFNLHlDQUF5QztBQUNqRSxTQUFTQyxJQUFJLEVBQUVDLElBQUksRUFB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