// Copyright 2015-2022, University of Colorado Boulder

/**
 * Finds the intersection between a light ray and prism.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chandrashekar Bemagoni (Actual Concepts)
 */

import bendingLight from '../../bendingLight.js';
import Intersection from './Intersection.js';
class PrismIntersection {
  constructor() {
    assert && assert(false, 'should not be instantiated');
  }

  /**
   * @param edges - edges of the prism, or an empty array for a circle
   * @param arc - arc of the prism
   * @param center - center of the arc if prism contains arc otherwise null
   * @param coloredRay - light ray intersecting the prism
   */
  static getIntersections(edges, arc, center, coloredRay) {
    const intersections = [];
    let intersection;
    let unitNormal;
    if (edges.length !== 0) {
      edges.forEach(lineSegment => {
        // Get the intersection if there is one
        intersection = lineSegment.intersection(coloredRay.ray);
        if (intersection.length !== 0) {
          // Choose the normal vector that points the opposite direction of the incoming ray
          unitNormal = lineSegment.getEnd().minus(lineSegment.getStart()).rotate(+Math.PI / 2).normalize();

          // Angle between the normal and ray should not be greater than 90 degrees.
          // If angle is greater than 90 then reverse the direction of the normal.
          if (unitNormal.dot(coloredRay.directionUnitVector) > 0) {
            unitNormal.negate();
          }
          // Add to the array of intersections
          intersections.push(new Intersection(unitNormal, intersection[0].point));
        }
      });
    }
    if (arc !== null) {
      intersection = arc.intersection(coloredRay.ray);
      if (intersection.length !== 0) {
        unitNormal = intersection[0].point.minus(center).normalize();

        // Angle between the normal and ray should not be greater than 90 degrees.
        // If angle is greater than 90 then reverse the direction of the normal.
        if (unitNormal.dot(coloredRay.directionUnitVector) > 0) {
          unitNormal.negate();
        }
        // Add to the array of intersections
        intersections.push(new Intersection(unitNormal, intersection[0].point));
      }
    }
    return intersections;
  }
}
bendingLight.register('PrismIntersection', PrismIntersection);
export default PrismIntersection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJiZW5kaW5nTGlnaHQiLCJJbnRlcnNlY3Rpb24iLCJQcmlzbUludGVyc2VjdGlvbiIsImNvbnN0cnVjdG9yIiwiYXNzZXJ0IiwiZ2V0SW50ZXJzZWN0aW9ucyIsImVkZ2VzIiwiYXJjIiwiY2VudGVyIiwiY29sb3JlZFJheSIsImludGVyc2VjdGlvbnMiLCJpbnRlcnNlY3Rpb24iLCJ1bml0Tm9ybWFsIiwibGVuZ3RoIiwiZm9yRWFjaCIsImxpbmVTZWdtZW50IiwicmF5IiwiZ2V0RW5kIiwibWludXMiLCJnZXRTdGFydCIsInJvdGF0ZSIsIk1hdGgiLCJQSSIsIm5vcm1hbGl6ZSIsImRvdCIsImRpcmVjdGlvblVuaXRWZWN0b3IiLCJuZWdhdGUiLCJwdXNoIiwicG9pbnQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlByaXNtSW50ZXJzZWN0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEZpbmRzIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiBhIGxpZ2h0IHJheSBhbmQgcHJpc20uXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIFJlaWQgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqIEBhdXRob3IgQ2hhbmRyYXNoZWthciBCZW1hZ29uaSAoQWN0dWFsIENvbmNlcHRzKVxyXG4gKi9cclxuXHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgQXJjLCBMaW5lLCBTaGFwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBiZW5kaW5nTGlnaHQgZnJvbSAnLi4vLi4vYmVuZGluZ0xpZ2h0LmpzJztcclxuaW1wb3J0IENvbG9yZWRSYXkgZnJvbSAnLi9Db2xvcmVkUmF5LmpzJztcclxuaW1wb3J0IEludGVyc2VjdGlvbiBmcm9tICcuL0ludGVyc2VjdGlvbi5qcyc7XHJcblxyXG5jbGFzcyBQcmlzbUludGVyc2VjdGlvbiB7XHJcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIGZhbHNlLCAnc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQnICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gZWRnZXMgLSBlZGdlcyBvZiB0aGUgcHJpc20sIG9yIGFuIGVtcHR5IGFycmF5IGZvciBhIGNpcmNsZVxyXG4gICAqIEBwYXJhbSBhcmMgLSBhcmMgb2YgdGhlIHByaXNtXHJcbiAgICogQHBhcmFtIGNlbnRlciAtIGNlbnRlciBvZiB0aGUgYXJjIGlmIHByaXNtIGNvbnRhaW5zIGFyYyBvdGhlcndpc2UgbnVsbFxyXG4gICAqIEBwYXJhbSBjb2xvcmVkUmF5IC0gbGlnaHQgcmF5IGludGVyc2VjdGluZyB0aGUgcHJpc21cclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIGdldEludGVyc2VjdGlvbnMoIGVkZ2VzOiBMaW5lW10sIGFyYzogQXJjIHwgU2hhcGUgfCBudWxsLCBjZW50ZXI6IFZlY3RvcjIsIGNvbG9yZWRSYXk6IENvbG9yZWRSYXkgKTogSW50ZXJzZWN0aW9uW10ge1xyXG4gICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IFtdO1xyXG4gICAgbGV0IGludGVyc2VjdGlvbjtcclxuICAgIGxldCB1bml0Tm9ybWFsO1xyXG4gICAgaWYgKCBlZGdlcy5sZW5ndGggIT09IDAgKSB7XHJcbiAgICAgIGVkZ2VzLmZvckVhY2goIGxpbmVTZWdtZW50ID0+IHtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBpbnRlcnNlY3Rpb24gaWYgdGhlcmUgaXMgb25lXHJcbiAgICAgICAgaW50ZXJzZWN0aW9uID0gbGluZVNlZ21lbnQuaW50ZXJzZWN0aW9uKCBjb2xvcmVkUmF5LnJheSApO1xyXG4gICAgICAgIGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAvLyBDaG9vc2UgdGhlIG5vcm1hbCB2ZWN0b3IgdGhhdCBwb2ludHMgdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBvZiB0aGUgaW5jb21pbmcgcmF5XHJcbiAgICAgICAgICB1bml0Tm9ybWFsID0gbGluZVNlZ21lbnQuZ2V0RW5kKCkubWludXMoIGxpbmVTZWdtZW50LmdldFN0YXJ0KCkgKS5yb3RhdGUoICtNYXRoLlBJIC8gMiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgIC8vIEFuZ2xlIGJldHdlZW4gdGhlIG5vcm1hbCBhbmQgcmF5IHNob3VsZCBub3QgYmUgZ3JlYXRlciB0aGFuIDkwIGRlZ3JlZXMuXHJcbiAgICAgICAgICAvLyBJZiBhbmdsZSBpcyBncmVhdGVyIHRoYW4gOTAgdGhlbiByZXZlcnNlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG5vcm1hbC5cclxuICAgICAgICAgIGlmICggdW5pdE5vcm1hbC5kb3QoIGNvbG9yZWRSYXkuZGlyZWN0aW9uVW5pdFZlY3RvciApID4gMCApIHtcclxuICAgICAgICAgICAgdW5pdE5vcm1hbC5uZWdhdGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIEFkZCB0byB0aGUgYXJyYXkgb2YgaW50ZXJzZWN0aW9uc1xyXG4gICAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKCBuZXcgSW50ZXJzZWN0aW9uKCB1bml0Tm9ybWFsLCBpbnRlcnNlY3Rpb25bIDAgXS5wb2ludCApICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgICBpZiAoIGFyYyAhPT0gbnVsbCApIHtcclxuICAgICAgaW50ZXJzZWN0aW9uID0gYXJjLmludGVyc2VjdGlvbiggY29sb3JlZFJheS5yYXkgKTtcclxuICAgICAgaWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwICkge1xyXG5cclxuICAgICAgICB1bml0Tm9ybWFsID0gaW50ZXJzZWN0aW9uWyAwIF0ucG9pbnQubWludXMoIGNlbnRlciApLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAvLyBBbmdsZSBiZXR3ZWVuIHRoZSBub3JtYWwgYW5kIHJheSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiA5MCBkZWdyZWVzLlxyXG4gICAgICAgIC8vIElmIGFuZ2xlIGlzIGdyZWF0ZXIgdGhhbiA5MCB0aGVuIHJldmVyc2UgdGhlIGRpcmVjdGlvbiBvZiB0aGUgbm9ybWFsLlxyXG4gICAgICAgIGlmICggdW5pdE5vcm1hbC5kb3QoIGNvbG9yZWRSYXkuZGlyZWN0aW9uVW5pdFZlY3RvciApID4gMCApIHtcclxuICAgICAgICAgIHVuaXROb3JtYWwubmVnYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCB0byB0aGUgYXJyYXkgb2YgaW50ZXJzZWN0aW9uc1xyXG4gICAgICAgIGludGVyc2VjdGlvbnMucHVzaCggbmV3IEludGVyc2VjdGlvbiggdW5pdE5vcm1hbCwgaW50ZXJzZWN0aW9uWyAwIF0ucG9pbnQgKSApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XHJcbiAgfVxyXG59XHJcblxyXG5iZW5kaW5nTGlnaHQucmVnaXN0ZXIoICdQcmlzbUludGVyc2VjdGlvbicsIFByaXNtSW50ZXJzZWN0aW9uICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcmlzbUludGVyc2VjdGlvbjsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQSxPQUFPQSxZQUFZLE1BQU0sdUJBQXVCO0FBRWhELE9BQU9DLFlBQVksTUFBTSxtQkFBbUI7QUFFNUMsTUFBTUMsaUJBQWlCLENBQUM7RUFDZEMsV0FBV0EsQ0FBQSxFQUFHO0lBQ3BCQyxNQUFNLElBQUlBLE1BQU0sQ0FBRSxLQUFLLEVBQUUsNEJBQTZCLENBQUM7RUFDekQ7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBY0MsZ0JBQWdCQSxDQUFFQyxLQUFhLEVBQUVDLEdBQXVCLEVBQUVDLE1BQWUsRUFBRUMsVUFBc0IsRUFBbUI7SUFDaEksTUFBTUMsYUFBYSxHQUFHLEVBQUU7SUFDeEIsSUFBSUMsWUFBWTtJQUNoQixJQUFJQyxVQUFVO0lBQ2QsSUFBS04sS0FBSyxDQUFDTyxNQUFNLEtBQUssQ0FBQyxFQUFHO01BQ3hCUCxLQUFLLENBQUNRLE9BQU8sQ0FBRUMsV0FBVyxJQUFJO1FBRTVCO1FBQ0FKLFlBQVksR0FBR0ksV0FBVyxDQUFDSixZQUFZLENBQUVGLFVBQVUsQ0FBQ08sR0FBSSxDQUFDO1FBQ3pELElBQUtMLFlBQVksQ0FBQ0UsTUFBTSxLQUFLLENBQUMsRUFBRztVQUUvQjtVQUNBRCxVQUFVLEdBQUdHLFdBQVcsQ0FBQ0UsTUFBTSxDQUFDLENBQUMsQ0FBQ0MsS0FBSyxDQUFFSCxXQUFXLENBQUNJLFFBQVEsQ0FBQyxDQUFFLENBQUMsQ0FBQ0MsTUFBTSxDQUFFLENBQUNDLElBQUksQ0FBQ0MsRUFBRSxHQUFHLENBQUUsQ0FBQyxDQUFDQyxTQUFTLENBQUMsQ0FBQzs7VUFFcEc7VUFDQTtVQUNBLElBQUtYLFVBQVUsQ0FBQ1ksR0FBRyxDQUFFZixVQUFVLENBQUNnQixtQkFBb0IsQ0FBQyxHQUFHLENBQUMsRUFBRztZQUMxRGIsVUFBVSxDQUFDYyxNQUFNLENBQUMsQ0FBQztVQUNyQjtVQUNBO1VBQ0FoQixhQUFhLENBQUNpQixJQUFJLENBQUUsSUFBSTFCLFlBQVksQ0FBRVcsVUFBVSxFQUFFRCxZQUFZLENBQUUsQ0FBQyxDQUFFLENBQUNpQixLQUFNLENBQUUsQ0FBQztRQUMvRTtNQUNGLENBQUUsQ0FBQztJQUNMO0lBQ0EsSUFBS3JCLEdBQUcsS0FBSyxJQUFJLEVBQUc7TUFDbEJJLFlBQVksR0FBR0osR0FBRyxDQUFDSSxZQUFZLENBQUVGLFVBQVUsQ0FBQ08sR0FBSSxDQUFDO01BQ2pELElBQUtMLFlBQVksQ0FBQ0UsTUFBTSxLQUFLLENBQUMsRUFBRztRQUUvQkQsVUFBVSxHQUFHRCxZQUFZLENBQUUsQ0FBQyxDQUFFLENBQUNpQixLQUFLLENBQUNWLEtBQUssQ0FBRVYsTUFBTyxDQUFDLENBQUNlLFNBQVMsQ0FBQyxDQUFDOztRQUVoRTtRQUNBO1FBQ0EsSUFBS1gsVUFBVSxDQUFDWSxHQUFHLENBQUVmLFVBQVUsQ0FBQ2dCLG1CQUFvQixDQUFDLEdBQUcsQ0FBQyxFQUFHO1VBQzFEYixVQUFVLENBQUNjLE1BQU0sQ0FBQyxDQUFDO1FBQ3JCO1FBQ0E7UUFDQWhCLGFBQWEsQ0FBQ2lCLElBQUksQ0FBRSxJQUFJMUIsWUFBWSxDQUFFVyxVQUFVLEVBQUVELFlBQVksQ0FBRSxDQUFDLENBQUUsQ0FBQ2lCLEtBQU0sQ0FBRSxDQUFDO01BQy9FO0lBQ0Y7SUFFQSxPQUFPbEIsYUFBYTtFQUN0QjtBQUNGO0FBRUFWLFlBQVksQ0FBQzZCLFFBQVEsQ0FBRSxtQkFBbUIsRUFBRTNCLGlCQUFrQixDQUFDO0FBRS9ELGVBQWVBLGlCQUFpQiJ9