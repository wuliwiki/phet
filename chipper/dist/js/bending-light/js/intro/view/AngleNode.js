// Copyright 2015-2022, University of Colorado Boulder

/**
 * Shows the angles between the rays and the vertical when enabled.
 * Described in https://github.com/phetsims/bending-light/issues/174
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import Multilink from '../../../../axon/js/Multilink.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import { Line, Node, Path } from '../../../../scenery/js/imports.js';
import bendingLight from '../../bendingLight.js';
import AngleTextView from './AngleTextView.js';

// constants
const CIRCLE_RADIUS = 50; // radius of the circular arc in stage coordinates
const LINE_HEIGHT = 13;
const NUM_DIGITS = 1; // number of digits in the text readouts
const ROUNDING_FACTOR = 10; // Round to the nearest tenth
const BUMP_TO_SIDE_DISTANCE = 38; // How far to move the text to the side if it was in the way of the rays

// When there is total internal reflection, treat it as if it is a powerless ray for simplicity
// Also used if there is no reflected ray
const MOCK_ZERO_RAY = {
  getAngle: () => 0,
  powerFraction: 0
};
class AngleNode extends Node {
  /**
   * @param showAnglesProperty -
   * @param laserOnProperty -
   * @param showNormalProperty -
   * @param rays -
   * @param modelViewTransform
   * @param addStepListener -
   */
  constructor(showAnglesProperty, laserOnProperty, showNormalProperty, rays, modelViewTransform, addStepListener) {
    super();

    // Only show the AngleNode when it is selected via a checkbox and the laser is on
    Multilink.multilink([showAnglesProperty, laserOnProperty], (showAngles, laserOn) => {
      this.visible = showAngles && laserOn;
    });
    const createArcPath = () => new Path(null, {
      stroke: 'black',
      lineWidth: 1
    });
    const getOriginX = () => modelViewTransform.modelToViewX(0);
    const getOriginY = () => modelViewTransform.modelToViewY(0);

    // Show the top angles both with a single arc so it is continuous
    const upperArcPath = createArcPath();
    this.addChild(upperArcPath);
    const lowerArcPath = createArcPath();
    this.addChild(lowerArcPath);

    // Readout for the angle for the incoming light ray
    const incomingReadout = new AngleTextView();
    this.addChild(incomingReadout);

    // Readout for the angle for the reflected light ray, which will always read the same value as the
    // incoming light ray for physics reasons.
    const reflectedReadout = new AngleTextView();
    this.addChild(reflectedReadout);
    const refractedReadout = new AngleTextView();
    this.addChild(refractedReadout);

    // Helper function used to create the vertical line marker above and below the origin
    const createLine = y => new Line(getOriginX(), getOriginY() + y - LINE_HEIGHT / 2, getOriginX(), getOriginY() + y + LINE_HEIGHT / 2, {
      stroke: 'black',
      lineWidth: 1
    });
    const lowerMark = createLine(CIRCLE_RADIUS);
    const upperMark = createLine(-CIRCLE_RADIUS);

    // Only redraw when necessary to improve performance.
    let dirty = true;
    showNormalProperty.link(showNormal => {
      // Only show the top marker when the normal is not shown, since they would interfere if both shown together
      upperMark.visible = !showNormal;

      // Update the lower mark as well, Only visible when the bottom readout is visible *and* normals are not shown.
      dirty = true;
    });
    this.addChild(lowerMark);
    this.addChild(upperMark);
    const markDirty = () => {
      dirty = true;
    };
    rays.addItemAddedListener(markDirty);
    rays.addItemRemovedListener(markDirty);

    /**
     * Select the ray of the given type 'incident' | 'reflected', or null if there isn't one of that type
     */
    const getRay = type => {
      let selected = null;
      for (let i = 0; i < rays.length; i++) {
        const ray = rays[i];
        if (ray.rayType === type) {
          assert && assert(selected === null, 'multiple rays of the same type');
          selected = ray;
        }
      }
      if (selected === null) {
        return MOCK_ZERO_RAY;
      }
      return selected;
    };

    // Update the shape each frame
    addStepListener(() => {
      if (dirty) {
        // Get the rays from the model.  They must be specified in the following order.
        const incomingRay = getRay('incident');
        const reflectedRay = getRay('reflected');
        const refractedRay = getRay('transmitted');
        if (incomingRay === null && reflectedRay === null && refractedRay === null) {
          return;
        }
        const incomingAngleFromNormal = incomingRay.getAngle() + Math.PI / 2;
        const refractedAngleFromNormal = refractedRay.getAngle() + Math.PI / 2;
        const getShape = (angle, startAngle, endAngle, anticlockwise) => angle >= 1E-6 ? Shape.arc(getOriginX(), getOriginY(), CIRCLE_RADIUS, startAngle, endAngle, anticlockwise) : null;

        // Only show the incident angle when the ray is coming in at a shallow angle, see #288
        const isIncomingRayHorizontal = Math.abs(incomingRay.getAngle()) < 1E-6;

        // When the indices of refraction are equal, there is no reflected ray
        const showReflectedAngle = reflectedRay.powerFraction >= 1E-6 && !isIncomingRayHorizontal;
        upperArcPath.shape = getShape(incomingAngleFromNormal, Math.PI - incomingRay.getAngle(), showReflectedAngle ? -reflectedRay.getAngle() : -Math.PI / 2, false);
        lowerArcPath.shape = getShape(refractedAngleFromNormal, Math.PI / 2, Math.PI / 2 - refractedAngleFromNormal, true);
        const origin = new Vector2(getOriginX(), getOriginY());

        // send out a ray from the origin past the center of the angle to position the readout
        const incomingRayDegreesFromNormal = Utils.roundSymmetric(incomingAngleFromNormal * 180 / Math.PI * ROUNDING_FACTOR) / ROUNDING_FACTOR;
        const refractedRayDegreesFromNormal = Utils.roundSymmetric(refractedAngleFromNormal * 180 / Math.PI * ROUNDING_FACTOR) / ROUNDING_FACTOR;
        const incomingReadoutText = `${Utils.toFixed(incomingRayDegreesFromNormal, NUM_DIGITS)}\u00B0`;
        const createDirectionVector = angle => Vector2.createPolar(CIRCLE_RADIUS + LINE_HEIGHT + 5, angle);
        const incomingReadoutDirection = createDirectionVector(-Math.PI / 2 - incomingAngleFromNormal / 2);
        const reflectedReadoutDirection = createDirectionVector(-Math.PI / 2 + incomingAngleFromNormal / 2);
        const refractedReadoutDirection = createDirectionVector(+Math.PI / 2 - refractedAngleFromNormal / 2);
        incomingReadout.setAngleText(incomingReadoutText);

        // When the angle becomes too small, pop the text out so that it won't be obscured by the ray
        const angleThresholdToBumpToSide = 30; // degrees

        incomingReadout.center = origin.plus(incomingReadoutDirection).plusXY(incomingRayDegreesFromNormal >= angleThresholdToBumpToSide ? 0 : -BUMP_TO_SIDE_DISTANCE, 0);
        reflectedReadout.setAngleText(incomingReadoutText); // It's the same
        reflectedReadout.center = origin.plus(reflectedReadoutDirection).plusXY(incomingRayDegreesFromNormal >= angleThresholdToBumpToSide ? 0 : +BUMP_TO_SIDE_DISTANCE, 0);
        reflectedReadout.visible = showReflectedAngle;
        const refractedReadoutText = `${Utils.toFixed(refractedRayDegreesFromNormal, NUM_DIGITS)}\u00B0`;

        // Total internal reflection, or not a significant refracted ray (light coming horizontally)
        const showLowerAngle = refractedRay.powerFraction >= 1E-6 && !isIncomingRayHorizontal;
        refractedReadout.visible = showLowerAngle;
        lowerArcPath.visible = showLowerAngle;
        lowerMark.visible = !showNormalProperty.value && showLowerAngle;
        refractedReadout.setAngleText(refractedReadoutText);
        const bumpBottomReadout = refractedRayDegreesFromNormal >= angleThresholdToBumpToSide;
        refractedReadout.center = origin.plus(refractedReadoutDirection).plusXY(bumpBottomReadout ? 0 : +BUMP_TO_SIDE_DISTANCE, 0);
        dirty = false;
      }
    });
  }
}
bendingLight.register('AngleNode', AngleNode);
export default AngleNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNdWx0aWxpbmsiLCJVdGlscyIsIlZlY3RvcjIiLCJTaGFwZSIsIkxpbmUiLCJOb2RlIiwiUGF0aCIsImJlbmRpbmdMaWdodCIsIkFuZ2xlVGV4dFZpZXciLCJDSVJDTEVfUkFESVVTIiwiTElORV9IRUlHSFQiLCJOVU1fRElHSVRTIiwiUk9VTkRJTkdfRkFDVE9SIiwiQlVNUF9UT19TSURFX0RJU1RBTkNFIiwiTU9DS19aRVJPX1JBWSIsImdldEFuZ2xlIiwicG93ZXJGcmFjdGlvbiIsIkFuZ2xlTm9kZSIsImNvbnN0cnVjdG9yIiwic2hvd0FuZ2xlc1Byb3BlcnR5IiwibGFzZXJPblByb3BlcnR5Iiwic2hvd05vcm1hbFByb3BlcnR5IiwicmF5cyIsIm1vZGVsVmlld1RyYW5zZm9ybSIsImFkZFN0ZXBMaXN0ZW5lciIsIm11bHRpbGluayIsInNob3dBbmdsZXMiLCJsYXNlck9uIiwidmlzaWJsZSIsImNyZWF0ZUFyY1BhdGgiLCJzdHJva2UiLCJsaW5lV2lkdGgiLCJnZXRPcmlnaW5YIiwibW9kZWxUb1ZpZXdYIiwiZ2V0T3JpZ2luWSIsIm1vZGVsVG9WaWV3WSIsInVwcGVyQXJjUGF0aCIsImFkZENoaWxkIiwibG93ZXJBcmNQYXRoIiwiaW5jb21pbmdSZWFkb3V0IiwicmVmbGVjdGVkUmVhZG91dCIsInJlZnJhY3RlZFJlYWRvdXQiLCJjcmVhdGVMaW5lIiwieSIsImxvd2VyTWFyayIsInVwcGVyTWFyayIsImRpcnR5IiwibGluayIsInNob3dOb3JtYWwiLCJtYXJrRGlydHkiLCJhZGRJdGVtQWRkZWRMaXN0ZW5lciIsImFkZEl0ZW1SZW1vdmVkTGlzdGVuZXIiLCJnZXRSYXkiLCJ0eXBlIiwic2VsZWN0ZWQiLCJpIiwibGVuZ3RoIiwicmF5IiwicmF5VHlwZSIsImFzc2VydCIsImluY29taW5nUmF5IiwicmVmbGVjdGVkUmF5IiwicmVmcmFjdGVkUmF5IiwiaW5jb21pbmdBbmdsZUZyb21Ob3JtYWwiLCJNYXRoIiwiUEkiLCJyZWZyYWN0ZWRBbmdsZUZyb21Ob3JtYWwiLCJnZXRTaGFwZSIsImFuZ2xlIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiYW50aWNsb2Nrd2lzZSIsImFyYyIsImlzSW5jb21pbmdSYXlIb3Jpem9udGFsIiwiYWJzIiwic2hvd1JlZmxlY3RlZEFuZ2xlIiwic2hhcGUiLCJvcmlnaW4iLCJpbmNvbWluZ1JheURlZ3JlZXNGcm9tTm9ybWFsIiwicm91bmRTeW1tZXRyaWMiLCJyZWZyYWN0ZWRSYXlEZWdyZWVzRnJvbU5vcm1hbCIsImluY29taW5nUmVhZG91dFRleHQiLCJ0b0ZpeGVkIiwiY3JlYXRlRGlyZWN0aW9uVmVjdG9yIiwiY3JlYXRlUG9sYXIiLCJpbmNvbWluZ1JlYWRvdXREaXJlY3Rpb24iLCJyZWZsZWN0ZWRSZWFkb3V0RGlyZWN0aW9uIiwicmVmcmFjdGVkUmVhZG91dERpcmVjdGlvbiIsInNldEFuZ2xlVGV4dCIsImFuZ2xlVGhyZXNob2xkVG9CdW1wVG9TaWRlIiwiY2VudGVyIiwicGx1cyIsInBsdXNYWSIsInJlZnJhY3RlZFJlYWRvdXRUZXh0Iiwic2hvd0xvd2VyQW5nbGUiLCJ2YWx1ZSIsImJ1bXBCb3R0b21SZWFkb3V0IiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJBbmdsZU5vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogU2hvd3MgdGhlIGFuZ2xlcyBiZXR3ZWVuIHRoZSByYXlzIGFuZCB0aGUgdmVydGljYWwgd2hlbiBlbmFibGVkLlxyXG4gKiBEZXNjcmliZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2JlbmRpbmctbGlnaHQvaXNzdWVzLzE3NFxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKi9cclxuXHJcbmltcG9ydCB7IE9ic2VydmFibGVBcnJheSB9IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvY3JlYXRlT2JzZXJ2YWJsZUFycmF5LmpzJztcclxuaW1wb3J0IE11bHRpbGluayBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL011bHRpbGluay5qcyc7XHJcbmltcG9ydCBQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1Byb3BlcnR5LmpzJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9VdGlscy5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi8uLi8uLi8uLi9raXRlL2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgTW9kZWxWaWV3VHJhbnNmb3JtMiBmcm9tICcuLi8uLi8uLi8uLi9waGV0Y29tbW9uL2pzL3ZpZXcvTW9kZWxWaWV3VHJhbnNmb3JtMi5qcyc7XHJcbmltcG9ydCB7IExpbmUsIE5vZGUsIFBhdGggfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5L2pzL2ltcG9ydHMuanMnO1xyXG5pbXBvcnQgYmVuZGluZ0xpZ2h0IGZyb20gJy4uLy4uL2JlbmRpbmdMaWdodC5qcyc7XHJcbmltcG9ydCBMaWdodFJheSBmcm9tICcuLi8uLi9jb21tb24vbW9kZWwvTGlnaHRSYXkuanMnO1xyXG5pbXBvcnQgUmF5VHlwZUVudW0gZnJvbSAnLi4vLi4vY29tbW9uL21vZGVsL1JheVR5cGVFbnVtLmpzJztcclxuaW1wb3J0IEFuZ2xlVGV4dFZpZXcgZnJvbSAnLi9BbmdsZVRleHRWaWV3LmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBDSVJDTEVfUkFESVVTID0gNTA7IC8vIHJhZGl1cyBvZiB0aGUgY2lyY3VsYXIgYXJjIGluIHN0YWdlIGNvb3JkaW5hdGVzXHJcbmNvbnN0IExJTkVfSEVJR0hUID0gMTM7XHJcbmNvbnN0IE5VTV9ESUdJVFMgPSAxOyAvLyBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSB0ZXh0IHJlYWRvdXRzXHJcbmNvbnN0IFJPVU5ESU5HX0ZBQ1RPUiA9IDEwOyAvLyBSb3VuZCB0byB0aGUgbmVhcmVzdCB0ZW50aFxyXG5jb25zdCBCVU1QX1RPX1NJREVfRElTVEFOQ0UgPSAzODsgLy8gSG93IGZhciB0byBtb3ZlIHRoZSB0ZXh0IHRvIHRoZSBzaWRlIGlmIGl0IHdhcyBpbiB0aGUgd2F5IG9mIHRoZSByYXlzXHJcblxyXG50eXBlIFRMaWdodFJheSA9IHtcclxuICBnZXRBbmdsZTogKCkgPT4gbnVtYmVyO1xyXG4gIHBvd2VyRnJhY3Rpb246IG51bWJlcjtcclxufTtcclxuXHJcbi8vIFdoZW4gdGhlcmUgaXMgdG90YWwgaW50ZXJuYWwgcmVmbGVjdGlvbiwgdHJlYXQgaXQgYXMgaWYgaXQgaXMgYSBwb3dlcmxlc3MgcmF5IGZvciBzaW1wbGljaXR5XHJcbi8vIEFsc28gdXNlZCBpZiB0aGVyZSBpcyBubyByZWZsZWN0ZWQgcmF5XHJcbmNvbnN0IE1PQ0tfWkVST19SQVk6IFRMaWdodFJheSA9IHtcclxuICBnZXRBbmdsZTogKCkgPT4gMCxcclxuICBwb3dlckZyYWN0aW9uOiAwXHJcbn07XHJcblxyXG5jbGFzcyBBbmdsZU5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHNob3dBbmdsZXNQcm9wZXJ0eSAtXHJcbiAgICogQHBhcmFtIGxhc2VyT25Qcm9wZXJ0eSAtXHJcbiAgICogQHBhcmFtIHNob3dOb3JtYWxQcm9wZXJ0eSAtXHJcbiAgICogQHBhcmFtIHJheXMgLVxyXG4gICAqIEBwYXJhbSBtb2RlbFZpZXdUcmFuc2Zvcm1cclxuICAgKiBAcGFyYW0gYWRkU3RlcExpc3RlbmVyIC1cclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIHNob3dBbmdsZXNQcm9wZXJ0eTogUHJvcGVydHk8Ym9vbGVhbj4sIGxhc2VyT25Qcm9wZXJ0eTogUHJvcGVydHk8Ym9vbGVhbj4sIHNob3dOb3JtYWxQcm9wZXJ0eTogUHJvcGVydHk8Ym9vbGVhbj4sIHJheXM6IE9ic2VydmFibGVBcnJheTxMaWdodFJheT4sIG1vZGVsVmlld1RyYW5zZm9ybTogTW9kZWxWaWV3VHJhbnNmb3JtMixcclxuICAgICAgICAgICAgICAgICAgICAgIGFkZFN0ZXBMaXN0ZW5lcjogKCB4OiAoKSA9PiB2b2lkICkgPT4gdm9pZCApIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLy8gT25seSBzaG93IHRoZSBBbmdsZU5vZGUgd2hlbiBpdCBpcyBzZWxlY3RlZCB2aWEgYSBjaGVja2JveCBhbmQgdGhlIGxhc2VyIGlzIG9uXHJcbiAgICBNdWx0aWxpbmsubXVsdGlsaW5rKCBbIHNob3dBbmdsZXNQcm9wZXJ0eSwgbGFzZXJPblByb3BlcnR5IF0sICggc2hvd0FuZ2xlcywgbGFzZXJPbiApID0+IHtcclxuICAgICAgdGhpcy52aXNpYmxlID0gc2hvd0FuZ2xlcyAmJiBsYXNlck9uO1xyXG4gICAgfSApO1xyXG5cclxuICAgIGNvbnN0IGNyZWF0ZUFyY1BhdGggPSAoKSA9PiBuZXcgUGF0aCggbnVsbCwgeyBzdHJva2U6ICdibGFjaycsIGxpbmVXaWR0aDogMSB9ICk7XHJcblxyXG4gICAgY29uc3QgZ2V0T3JpZ2luWCA9ICgpID0+IG1vZGVsVmlld1RyYW5zZm9ybS5tb2RlbFRvVmlld1goIDAgKTtcclxuXHJcbiAgICBjb25zdCBnZXRPcmlnaW5ZID0gKCkgPT4gbW9kZWxWaWV3VHJhbnNmb3JtLm1vZGVsVG9WaWV3WSggMCApO1xyXG5cclxuICAgIC8vIFNob3cgdGhlIHRvcCBhbmdsZXMgYm90aCB3aXRoIGEgc2luZ2xlIGFyYyBzbyBpdCBpcyBjb250aW51b3VzXHJcbiAgICBjb25zdCB1cHBlckFyY1BhdGggPSBjcmVhdGVBcmNQYXRoKCk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCB1cHBlckFyY1BhdGggKTtcclxuXHJcbiAgICBjb25zdCBsb3dlckFyY1BhdGggPSBjcmVhdGVBcmNQYXRoKCk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCBsb3dlckFyY1BhdGggKTtcclxuXHJcbiAgICAvLyBSZWFkb3V0IGZvciB0aGUgYW5nbGUgZm9yIHRoZSBpbmNvbWluZyBsaWdodCByYXlcclxuICAgIGNvbnN0IGluY29taW5nUmVhZG91dCA9IG5ldyBBbmdsZVRleHRWaWV3KCk7XHJcbiAgICB0aGlzLmFkZENoaWxkKCBpbmNvbWluZ1JlYWRvdXQgKTtcclxuXHJcbiAgICAvLyBSZWFkb3V0IGZvciB0aGUgYW5nbGUgZm9yIHRoZSByZWZsZWN0ZWQgbGlnaHQgcmF5LCB3aGljaCB3aWxsIGFsd2F5cyByZWFkIHRoZSBzYW1lIHZhbHVlIGFzIHRoZVxyXG4gICAgLy8gaW5jb21pbmcgbGlnaHQgcmF5IGZvciBwaHlzaWNzIHJlYXNvbnMuXHJcbiAgICBjb25zdCByZWZsZWN0ZWRSZWFkb3V0ID0gbmV3IEFuZ2xlVGV4dFZpZXcoKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIHJlZmxlY3RlZFJlYWRvdXQgKTtcclxuXHJcbiAgICBjb25zdCByZWZyYWN0ZWRSZWFkb3V0ID0gbmV3IEFuZ2xlVGV4dFZpZXcoKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIHJlZnJhY3RlZFJlYWRvdXQgKTtcclxuXHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgdGhlIHZlcnRpY2FsIGxpbmUgbWFya2VyIGFib3ZlIGFuZCBiZWxvdyB0aGUgb3JpZ2luXHJcbiAgICBjb25zdCBjcmVhdGVMaW5lID0gKCB5OiBudW1iZXIgKSA9PiBuZXcgTGluZShcclxuICAgICAgZ2V0T3JpZ2luWCgpLCBnZXRPcmlnaW5ZKCkgKyB5IC0gTElORV9IRUlHSFQgLyAyLFxyXG4gICAgICBnZXRPcmlnaW5YKCksIGdldE9yaWdpblkoKSArIHkgKyBMSU5FX0hFSUdIVCAvIDIsIHtcclxuICAgICAgICBzdHJva2U6ICdibGFjaycsXHJcbiAgICAgICAgbGluZVdpZHRoOiAxXHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgbG93ZXJNYXJrID0gY3JlYXRlTGluZSggQ0lSQ0xFX1JBRElVUyApO1xyXG4gICAgY29uc3QgdXBwZXJNYXJrID0gY3JlYXRlTGluZSggLUNJUkNMRV9SQURJVVMgKTtcclxuXHJcbiAgICAvLyBPbmx5IHJlZHJhdyB3aGVuIG5lY2Vzc2FyeSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxyXG4gICAgbGV0IGRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICBzaG93Tm9ybWFsUHJvcGVydHkubGluayggc2hvd05vcm1hbCA9PiB7XHJcblxyXG4gICAgICAvLyBPbmx5IHNob3cgdGhlIHRvcCBtYXJrZXIgd2hlbiB0aGUgbm9ybWFsIGlzIG5vdCBzaG93biwgc2luY2UgdGhleSB3b3VsZCBpbnRlcmZlcmUgaWYgYm90aCBzaG93biB0b2dldGhlclxyXG4gICAgICB1cHBlck1hcmsudmlzaWJsZSA9ICFzaG93Tm9ybWFsO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBsb3dlciBtYXJrIGFzIHdlbGwsIE9ubHkgdmlzaWJsZSB3aGVuIHRoZSBib3R0b20gcmVhZG91dCBpcyB2aXNpYmxlICphbmQqIG5vcm1hbHMgYXJlIG5vdCBzaG93bi5cclxuICAgICAgZGlydHkgPSB0cnVlO1xyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMuYWRkQ2hpbGQoIGxvd2VyTWFyayApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggdXBwZXJNYXJrICk7XHJcblxyXG4gICAgY29uc3QgbWFya0RpcnR5ID0gKCkgPT4ge1xyXG4gICAgICBkaXJ0eSA9IHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHJheXMuYWRkSXRlbUFkZGVkTGlzdGVuZXIoIG1hcmtEaXJ0eSApO1xyXG4gICAgcmF5cy5hZGRJdGVtUmVtb3ZlZExpc3RlbmVyKCBtYXJrRGlydHkgKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCB0aGUgcmF5IG9mIHRoZSBnaXZlbiB0eXBlICdpbmNpZGVudCcgfCAncmVmbGVjdGVkJywgb3IgbnVsbCBpZiB0aGVyZSBpc24ndCBvbmUgb2YgdGhhdCB0eXBlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldFJheSA9ICggdHlwZTogUmF5VHlwZUVudW0gfCBudWxsICk6IFRMaWdodFJheSA9PiB7XHJcbiAgICAgIGxldCBzZWxlY3RlZCA9IG51bGw7XHJcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHJheXMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgY29uc3QgcmF5ID0gcmF5c1sgaSBdO1xyXG4gICAgICAgIGlmICggcmF5LnJheVR5cGUgPT09IHR5cGUgKSB7XHJcbiAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBzZWxlY3RlZCA9PT0gbnVsbCwgJ211bHRpcGxlIHJheXMgb2YgdGhlIHNhbWUgdHlwZScgKTtcclxuICAgICAgICAgIHNlbGVjdGVkID0gcmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIHNlbGVjdGVkID09PSBudWxsICkge1xyXG4gICAgICAgIHJldHVybiBNT0NLX1pFUk9fUkFZO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBzaGFwZSBlYWNoIGZyYW1lXHJcbiAgICBhZGRTdGVwTGlzdGVuZXIoICgpID0+IHtcclxuICAgICAgaWYgKCBkaXJ0eSApIHtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSByYXlzIGZyb20gdGhlIG1vZGVsLiAgVGhleSBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyLlxyXG4gICAgICAgIGNvbnN0IGluY29taW5nUmF5ID0gZ2V0UmF5KCAnaW5jaWRlbnQnICk7XHJcbiAgICAgICAgY29uc3QgcmVmbGVjdGVkUmF5ID0gZ2V0UmF5KCAncmVmbGVjdGVkJyApO1xyXG4gICAgICAgIGNvbnN0IHJlZnJhY3RlZFJheSA9IGdldFJheSggJ3RyYW5zbWl0dGVkJyApO1xyXG4gICAgICAgIGlmICggaW5jb21pbmdSYXkgPT09IG51bGwgJiYgcmVmbGVjdGVkUmF5ID09PSBudWxsICYmIHJlZnJhY3RlZFJheSA9PT0gbnVsbCApIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGluY29taW5nQW5nbGVGcm9tTm9ybWFsID0gaW5jb21pbmdSYXkuZ2V0QW5nbGUoKSArIE1hdGguUEkgLyAyO1xyXG4gICAgICAgIGNvbnN0IHJlZnJhY3RlZEFuZ2xlRnJvbU5vcm1hbCA9IHJlZnJhY3RlZFJheS5nZXRBbmdsZSgpICsgTWF0aC5QSSAvIDI7XHJcblxyXG4gICAgICAgIGNvbnN0IGdldFNoYXBlID0gKCBhbmdsZTogbnVtYmVyLCBzdGFydEFuZ2xlOiBudW1iZXIsIGVuZEFuZ2xlOiBudW1iZXIsIGFudGljbG9ja3dpc2U6IGJvb2xlYW4gKSA9PlxyXG4gICAgICAgICAgYW5nbGUgPj0gMUUtNiA/XHJcbiAgICAgICAgICBTaGFwZS5hcmMoXHJcbiAgICAgICAgICAgIGdldE9yaWdpblgoKSxcclxuICAgICAgICAgICAgZ2V0T3JpZ2luWSgpLFxyXG4gICAgICAgICAgICBDSVJDTEVfUkFESVVTLFxyXG4gICAgICAgICAgICBzdGFydEFuZ2xlLFxyXG4gICAgICAgICAgICBlbmRBbmdsZSxcclxuICAgICAgICAgICAgYW50aWNsb2Nrd2lzZVxyXG4gICAgICAgICAgKSA6XHJcbiAgICAgICAgICBudWxsO1xyXG5cclxuICAgICAgICAvLyBPbmx5IHNob3cgdGhlIGluY2lkZW50IGFuZ2xlIHdoZW4gdGhlIHJheSBpcyBjb21pbmcgaW4gYXQgYSBzaGFsbG93IGFuZ2xlLCBzZWUgIzI4OFxyXG4gICAgICAgIGNvbnN0IGlzSW5jb21pbmdSYXlIb3Jpem9udGFsID0gTWF0aC5hYnMoIGluY29taW5nUmF5LmdldEFuZ2xlKCkgKSA8IDFFLTY7XHJcblxyXG4gICAgICAgIC8vIFdoZW4gdGhlIGluZGljZXMgb2YgcmVmcmFjdGlvbiBhcmUgZXF1YWwsIHRoZXJlIGlzIG5vIHJlZmxlY3RlZCByYXlcclxuICAgICAgICBjb25zdCBzaG93UmVmbGVjdGVkQW5nbGUgPSByZWZsZWN0ZWRSYXkucG93ZXJGcmFjdGlvbiA+PSAxRS02ICYmICFpc0luY29taW5nUmF5SG9yaXpvbnRhbDtcclxuXHJcbiAgICAgICAgdXBwZXJBcmNQYXRoLnNoYXBlID0gZ2V0U2hhcGUoXHJcbiAgICAgICAgICBpbmNvbWluZ0FuZ2xlRnJvbU5vcm1hbCxcclxuICAgICAgICAgIE1hdGguUEkgLSBpbmNvbWluZ1JheS5nZXRBbmdsZSgpLFxyXG4gICAgICAgICAgc2hvd1JlZmxlY3RlZEFuZ2xlID8gLXJlZmxlY3RlZFJheS5nZXRBbmdsZSgpIDogLU1hdGguUEkgLyAyLFxyXG4gICAgICAgICAgZmFsc2UgKTtcclxuXHJcbiAgICAgICAgbG93ZXJBcmNQYXRoLnNoYXBlID0gZ2V0U2hhcGUoXHJcbiAgICAgICAgICByZWZyYWN0ZWRBbmdsZUZyb21Ob3JtYWwsXHJcbiAgICAgICAgICBNYXRoLlBJIC8gMixcclxuICAgICAgICAgIE1hdGguUEkgLyAyIC0gcmVmcmFjdGVkQW5nbGVGcm9tTm9ybWFsLFxyXG4gICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gbmV3IFZlY3RvcjIoIGdldE9yaWdpblgoKSwgZ2V0T3JpZ2luWSgpICk7XHJcblxyXG4gICAgICAgIC8vIHNlbmQgb3V0IGEgcmF5IGZyb20gdGhlIG9yaWdpbiBwYXN0IHRoZSBjZW50ZXIgb2YgdGhlIGFuZ2xlIHRvIHBvc2l0aW9uIHRoZSByZWFkb3V0XHJcbiAgICAgICAgY29uc3QgaW5jb21pbmdSYXlEZWdyZWVzRnJvbU5vcm1hbCA9IFV0aWxzLnJvdW5kU3ltbWV0cmljKFxyXG4gICAgICAgICAgaW5jb21pbmdBbmdsZUZyb21Ob3JtYWwgKiAxODAgLyBNYXRoLlBJICogUk9VTkRJTkdfRkFDVE9SXHJcbiAgICAgICAgKSAvIFJPVU5ESU5HX0ZBQ1RPUjtcclxuICAgICAgICBjb25zdCByZWZyYWN0ZWRSYXlEZWdyZWVzRnJvbU5vcm1hbCA9IFV0aWxzLnJvdW5kU3ltbWV0cmljKFxyXG4gICAgICAgICAgcmVmcmFjdGVkQW5nbGVGcm9tTm9ybWFsICogMTgwIC8gTWF0aC5QSSAqIFJPVU5ESU5HX0ZBQ1RPUlxyXG4gICAgICAgICkgLyBST1VORElOR19GQUNUT1I7XHJcbiAgICAgICAgY29uc3QgaW5jb21pbmdSZWFkb3V0VGV4dCA9IGAke1V0aWxzLnRvRml4ZWQoIGluY29taW5nUmF5RGVncmVlc0Zyb21Ob3JtYWwsIE5VTV9ESUdJVFMgKX1cXHUwMEIwYDtcclxuXHJcbiAgICAgICAgY29uc3QgY3JlYXRlRGlyZWN0aW9uVmVjdG9yID0gKCBhbmdsZTogbnVtYmVyICkgPT4gVmVjdG9yMi5jcmVhdGVQb2xhciggQ0lSQ0xFX1JBRElVUyArIExJTkVfSEVJR0hUICsgNSwgYW5nbGUgKTtcclxuICAgICAgICBjb25zdCBpbmNvbWluZ1JlYWRvdXREaXJlY3Rpb24gPSBjcmVhdGVEaXJlY3Rpb25WZWN0b3IoIC1NYXRoLlBJIC8gMiAtIGluY29taW5nQW5nbGVGcm9tTm9ybWFsIC8gMiApO1xyXG4gICAgICAgIGNvbnN0IHJlZmxlY3RlZFJlYWRvdXREaXJlY3Rpb24gPSBjcmVhdGVEaXJlY3Rpb25WZWN0b3IoIC1NYXRoLlBJIC8gMiArIGluY29taW5nQW5nbGVGcm9tTm9ybWFsIC8gMiApO1xyXG4gICAgICAgIGNvbnN0IHJlZnJhY3RlZFJlYWRvdXREaXJlY3Rpb24gPSBjcmVhdGVEaXJlY3Rpb25WZWN0b3IoICtNYXRoLlBJIC8gMiAtIHJlZnJhY3RlZEFuZ2xlRnJvbU5vcm1hbCAvIDIgKTtcclxuXHJcbiAgICAgICAgaW5jb21pbmdSZWFkb3V0LnNldEFuZ2xlVGV4dCggaW5jb21pbmdSZWFkb3V0VGV4dCApO1xyXG5cclxuICAgICAgICAvLyBXaGVuIHRoZSBhbmdsZSBiZWNvbWVzIHRvbyBzbWFsbCwgcG9wIHRoZSB0ZXh0IG91dCBzbyB0aGF0IGl0IHdvbid0IGJlIG9ic2N1cmVkIGJ5IHRoZSByYXlcclxuICAgICAgICBjb25zdCBhbmdsZVRocmVzaG9sZFRvQnVtcFRvU2lkZSA9IDMwOyAvLyBkZWdyZWVzXHJcblxyXG4gICAgICAgIGluY29taW5nUmVhZG91dC5jZW50ZXIgPSBvcmlnaW4ucGx1cyggaW5jb21pbmdSZWFkb3V0RGlyZWN0aW9uIClcclxuICAgICAgICAgIC5wbHVzWFkoIGluY29taW5nUmF5RGVncmVlc0Zyb21Ob3JtYWwgPj0gYW5nbGVUaHJlc2hvbGRUb0J1bXBUb1NpZGUgPyAwIDogLUJVTVBfVE9fU0lERV9ESVNUQU5DRSwgMCApO1xyXG5cclxuICAgICAgICByZWZsZWN0ZWRSZWFkb3V0LnNldEFuZ2xlVGV4dCggaW5jb21pbmdSZWFkb3V0VGV4dCApOyAvLyBJdCdzIHRoZSBzYW1lXHJcbiAgICAgICAgcmVmbGVjdGVkUmVhZG91dC5jZW50ZXIgPSBvcmlnaW4ucGx1cyggcmVmbGVjdGVkUmVhZG91dERpcmVjdGlvbiApXHJcbiAgICAgICAgICAucGx1c1hZKCBpbmNvbWluZ1JheURlZ3JlZXNGcm9tTm9ybWFsID49IGFuZ2xlVGhyZXNob2xkVG9CdW1wVG9TaWRlID8gMCA6ICtCVU1QX1RPX1NJREVfRElTVEFOQ0UsIDAgKTtcclxuXHJcbiAgICAgICAgcmVmbGVjdGVkUmVhZG91dC52aXNpYmxlID0gc2hvd1JlZmxlY3RlZEFuZ2xlO1xyXG5cclxuICAgICAgICBjb25zdCByZWZyYWN0ZWRSZWFkb3V0VGV4dCA9IGAke1V0aWxzLnRvRml4ZWQoIHJlZnJhY3RlZFJheURlZ3JlZXNGcm9tTm9ybWFsLCBOVU1fRElHSVRTICl9XFx1MDBCMGA7XHJcblxyXG4gICAgICAgIC8vIFRvdGFsIGludGVybmFsIHJlZmxlY3Rpb24sIG9yIG5vdCBhIHNpZ25pZmljYW50IHJlZnJhY3RlZCByYXkgKGxpZ2h0IGNvbWluZyBob3Jpem9udGFsbHkpXHJcbiAgICAgICAgY29uc3Qgc2hvd0xvd2VyQW5nbGUgPSByZWZyYWN0ZWRSYXkucG93ZXJGcmFjdGlvbiA+PSAxRS02ICYmICFpc0luY29taW5nUmF5SG9yaXpvbnRhbDtcclxuXHJcbiAgICAgICAgcmVmcmFjdGVkUmVhZG91dC52aXNpYmxlID0gc2hvd0xvd2VyQW5nbGU7XHJcbiAgICAgICAgbG93ZXJBcmNQYXRoLnZpc2libGUgPSBzaG93TG93ZXJBbmdsZTtcclxuICAgICAgICBsb3dlck1hcmsudmlzaWJsZSA9ICFzaG93Tm9ybWFsUHJvcGVydHkudmFsdWUgJiYgc2hvd0xvd2VyQW5nbGU7XHJcblxyXG4gICAgICAgIHJlZnJhY3RlZFJlYWRvdXQuc2V0QW5nbGVUZXh0KCByZWZyYWN0ZWRSZWFkb3V0VGV4dCApO1xyXG4gICAgICAgIGNvbnN0IGJ1bXBCb3R0b21SZWFkb3V0ID0gcmVmcmFjdGVkUmF5RGVncmVlc0Zyb21Ob3JtYWwgPj0gYW5nbGVUaHJlc2hvbGRUb0J1bXBUb1NpZGU7XHJcbiAgICAgICAgcmVmcmFjdGVkUmVhZG91dC5jZW50ZXIgPSBvcmlnaW4ucGx1cyggcmVmcmFjdGVkUmVhZG91dERpcmVjdGlvbiApXHJcbiAgICAgICAgICAucGx1c1hZKCBidW1wQm90dG9tUmVhZG91dCA/IDAgOiArQlVNUF9UT19TSURFX0RJU1RBTkNFLCAwICk7XHJcblxyXG4gICAgICAgIGRpcnR5ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuICB9XHJcbn1cclxuXHJcbmJlbmRpbmdMaWdodC5yZWdpc3RlciggJ0FuZ2xlTm9kZScsIEFuZ2xlTm9kZSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQW5nbGVOb2RlOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBLE9BQU9BLFNBQVMsTUFBTSxrQ0FBa0M7QUFFeEQsT0FBT0MsS0FBSyxNQUFNLDZCQUE2QjtBQUMvQyxPQUFPQyxPQUFPLE1BQU0sK0JBQStCO0FBQ25ELFNBQVNDLEtBQUssUUFBUSxnQ0FBZ0M7QUFFdEQsU0FBU0MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUksUUFBUSxtQ0FBbUM7QUFDcEUsT0FBT0MsWUFBWSxN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