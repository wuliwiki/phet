// Copyright 2015-2022, University of Colorado Boulder

/**
 * Node that shows the chart in the "more tools" screen intensity sensor.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chandrashekar Bemagoni (Actual Concepts)
 */

import createObservableArray from '../../../../axon/js/createObservableArray.js';
import Property from '../../../../axon/js/Property.js';
import Bounds2 from '../../../../dot/js/Bounds2.js';
import ModelViewTransform2 from '../../../../phetcommon/js/view/ModelViewTransform2.js';
import { Node } from '../../../../scenery/js/imports.js';
import bendingLight from '../../bendingLight.js';
import GridCanvasNode from './GridCanvasNode.js';
import SeriesCanvasNode from './SeriesCanvasNode.js';

// stroke dash parameters
const DASH_ON = 10;
const DASH_OFF = 5;
class SeriesNode extends Node {
  /**
   * Node for drawing the series of points.
   *
   * @param series - series of data points
   * @param modelViewTransformProperty - Transform between model and view coordinate
   *                                                                      frames
   * @param chartBounds - bounds of the chart node
   */
  constructor(series, modelViewTransformProperty, chartBounds) {
    super();

    // add series canvas
    const seriesCanvasNode = new SeriesCanvasNode(series.seriesProperty, modelViewTransformProperty, series.color.toCSS(), {
      // @ts-expect-error
      canvasBounds: chartBounds
    });
    this.addChild(seriesCanvasNode);

    // Update the series canvas for every change in series
    series.seriesProperty.link(() => seriesCanvasNode.step());
  }
}
class ChartNode extends Node {
  /**
   * @param chartBounds - bounds of the chart node
   * @param seriesArray - series of data points
   */
  constructor(chartBounds, seriesArray) {
    super();
    this.chartBounds = chartBounds; // (read-only)
    this.seriesArray = seriesArray; // (read-only)

    // read-only
    // Amount of time to show on the horizontal axis of the chart
    this.timeWidth = 72E-16; // (read-only)

    // Mapping from model (SI) to chart coordinates
    this.modelViewTransformProperty = new Property(ModelViewTransform2.createRectangleMapping(new Bounds2(0, -1, this.timeWidth, 1), chartBounds));

    // Add grid to the chart
    this.gridLines = createObservableArray(); // (read-only)
    this.gridCanvasNode = new GridCanvasNode(this.gridLines, this.modelViewTransformProperty, [DASH_ON, DASH_OFF], {
      // @ts-expect-error
      canvasBounds: chartBounds
    });
    this.addChild(this.gridCanvasNode);

    // Add nodes for the grid lines and series's
    seriesArray.forEach(series => this.addChild(new SeriesNode(series, this.modelViewTransformProperty, this.chartBounds)));
  }

  /**
   * @param time - simulation time
   */
  step(time) {
    this.simulationTimeChanged(time);
  }

  /**
   * Move over the view port as time passes
   * @param time - simulation time
   */
  simulationTimeChanged(time) {
    // Update the mapping from model to chart
    const minTime = time - this.timeWidth;
    this.modelViewTransformProperty.set(ModelViewTransform2.createRectangleMapping(new Bounds2(minTime, -1, minTime + this.timeWidth, 1), this.chartBounds));

    // Clear grid lines points and add them back in the new positions
    this.gridLines.clear();

    // Distance between vertical grid lines
    const verticalGridLineSpacing = this.timeWidth / 4;
    const verticalGridLineSpacingDelta = this.getDelta(verticalGridLineSpacing, time);

    // Add vertical grid lines
    for (let x = minTime - verticalGridLineSpacingDelta + verticalGridLineSpacing; x <= minTime + this.timeWidth; x += verticalGridLineSpacing) {
      this.addVerticalLine(x);
    }

    // Add one horizontal grid line
    const horizontalGridLineDelta = this.getDelta(this.modelViewTransformProperty.get().viewToModelDeltaX(DASH_ON + DASH_OFF), time);

    // Horizontal axis
    this.gridLines.push({
      x1: minTime,
      y1: 0,
      x2: minTime + this.timeWidth,
      y2: 0,
      lineDashOffset: this.modelViewTransformProperty.get().modelToViewDeltaX(horizontalGridLineDelta)
    });
    this.gridCanvasNode.step();

    // Remove any points that have gone outside of the time window, otherwise it is a memory leak
    this.seriesArray.forEach(series => series.keepLastSamples(minTime));
  }

  /**
   * Compute the phase offset so that grid lines appear to be moving at the right speed
   * @param verticalGridLineSpacing - space between vertical grid lines
   * @param time - simulation time
   */
  getDelta(verticalGridLineSpacing, time) {
    const totalNumPeriods = time / verticalGridLineSpacing;

    // for computing the phase so we make the right number of grid lines, just keep the fractional part
    return totalNumPeriods % 1 * verticalGridLineSpacing;
  }

  /**
   * Adds vertical lines to the grid
   * @param x - x coordinate of vertical grid lines
   */
  addVerticalLine(x) {
    // -1 to +1 is far enough since in model coordinates
    this.gridLines.push({
      x1: x,
      y1: -1,
      x2: x,
      y2: 1,
      lineDashOffset: 0
    });
  }
}
bendingLight.register('ChartNode', ChartNode);
export default ChartNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjcmVhdGVPYnNlcnZhYmxlQXJyYXkiLCJQcm9wZXJ0eSIsIkJvdW5kczIiLCJNb2RlbFZpZXdUcmFuc2Zvcm0yIiwiTm9kZSIsImJlbmRpbmdMaWdodCIsIkdyaWRDYW52YXNOb2RlIiwiU2VyaWVzQ2FudmFzTm9kZSIsIkRBU0hfT04iLCJEQVNIX09GRiIsIlNlcmllc05vZGUiLCJjb25zdHJ1Y3RvciIsInNlcmllcyIsIm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5IiwiY2hhcnRCb3VuZHMiLCJzZXJpZXNDYW52YXNOb2RlIiwic2VyaWVzUHJvcGVydHkiLCJjb2xvciIsInRvQ1NTIiwiY2FudmFzQm91bmRzIiwiYWRkQ2hpbGQiLCJsaW5rIiwic3RlcCIsIkNoYXJ0Tm9kZSIsInNlcmllc0FycmF5IiwidGltZVdpZHRoIiwiY3JlYXRlUmVjdGFuZ2xlTWFwcGluZyIsImdyaWRMaW5lcyIsImdyaWRDYW52YXNOb2RlIiwiZm9yRWFjaCIsInRpbWUiLCJzaW11bGF0aW9uVGltZUNoYW5nZWQiLCJtaW5UaW1lIiwic2V0IiwiY2xlYXIiLCJ2ZXJ0aWNhbEdyaWRMaW5lU3BhY2luZyIsInZlcnRpY2FsR3JpZExpbmVTcGFjaW5nRGVsdGEiLCJnZXREZWx0YSIsIngiLCJhZGRWZXJ0aWNhbExpbmUiLCJob3Jpem9udGFsR3JpZExpbmVEZWx0YSIsImdldCIsInZpZXdUb01vZGVsRGVsdGFYIiwicHVzaCIsIngxIiwieTEiLCJ4MiIsInkyIiwibGluZURhc2hPZmZzZXQiLCJtb2RlbFRvVmlld0RlbHRhWCIsImtlZXBMYXN0U2FtcGxlcyIsInRvdGFsTnVtUGVyaW9kcyIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQ2hhcnROb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE1LTIwMjIsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIE5vZGUgdGhhdCBzaG93cyB0aGUgY2hhcnQgaW4gdGhlIFwibW9yZSB0b29sc1wiIHNjcmVlbiBpbnRlbnNpdHkgc2Vuc29yLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKiBAYXV0aG9yIENoYW5kcmFzaGVrYXIgQmVtYWdvbmkgKEFjdHVhbCBDb25jZXB0cylcclxuICovXHJcblxyXG5pbXBvcnQgY3JlYXRlT2JzZXJ2YWJsZUFycmF5LCB7IE9ic2VydmFibGVBcnJheSB9IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvY3JlYXRlT2JzZXJ2YWJsZUFycmF5LmpzJztcclxuaW1wb3J0IFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgQm91bmRzMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvQm91bmRzMi5qcyc7XHJcbmltcG9ydCBNb2RlbFZpZXdUcmFuc2Zvcm0yIGZyb20gJy4uLy4uLy4uLy4uL3BoZXRjb21tb24vanMvdmlldy9Nb2RlbFZpZXdUcmFuc2Zvcm0yLmpzJztcclxuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBiZW5kaW5nTGlnaHQgZnJvbSAnLi4vLi4vYmVuZGluZ0xpZ2h0LmpzJztcclxuaW1wb3J0IFNlcmllcyBmcm9tICcuLi9tb2RlbC9TZXJpZXMuanMnO1xyXG5pbXBvcnQgR3JpZENhbnZhc05vZGUgZnJvbSAnLi9HcmlkQ2FudmFzTm9kZS5qcyc7XHJcbmltcG9ydCBTZXJpZXNDYW52YXNOb2RlIGZyb20gJy4vU2VyaWVzQ2FudmFzTm9kZS5qcyc7XHJcblxyXG4vLyBzdHJva2UgZGFzaCBwYXJhbWV0ZXJzXHJcbmNvbnN0IERBU0hfT04gPSAxMDtcclxuY29uc3QgREFTSF9PRkYgPSA1O1xyXG5cclxuY2xhc3MgU2VyaWVzTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvKipcclxuICAgKiBOb2RlIGZvciBkcmF3aW5nIHRoZSBzZXJpZXMgb2YgcG9pbnRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHNlcmllcyAtIHNlcmllcyBvZiBkYXRhIHBvaW50c1xyXG4gICAqIEBwYXJhbSBtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eSAtIFRyYW5zZm9ybSBiZXR3ZWVuIG1vZGVsIGFuZCB2aWV3IGNvb3JkaW5hdGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZXNcclxuICAgKiBAcGFyYW0gY2hhcnRCb3VuZHMgLSBib3VuZHMgb2YgdGhlIGNoYXJ0IG5vZGVcclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIHNlcmllczogU2VyaWVzLCBtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eTogUHJvcGVydHk8TW9kZWxWaWV3VHJhbnNmb3JtMj4sIGNoYXJ0Qm91bmRzOiBCb3VuZHMyICkge1xyXG5cclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLy8gYWRkIHNlcmllcyBjYW52YXNcclxuICAgIGNvbnN0IHNlcmllc0NhbnZhc05vZGUgPSBuZXcgU2VyaWVzQ2FudmFzTm9kZShcclxuICAgICAgc2VyaWVzLnNlcmllc1Byb3BlcnR5LFxyXG4gICAgICBtb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eSxcclxuICAgICAgc2VyaWVzLmNvbG9yLnRvQ1NTKCksIHtcclxuXHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgICAgIGNhbnZhc0JvdW5kczogY2hhcnRCb3VuZHNcclxuICAgICAgfVxyXG4gICAgKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIHNlcmllc0NhbnZhc05vZGUgKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIHNlcmllcyBjYW52YXMgZm9yIGV2ZXJ5IGNoYW5nZSBpbiBzZXJpZXNcclxuICAgIHNlcmllcy5zZXJpZXNQcm9wZXJ0eS5saW5rKCAoKSA9PiBzZXJpZXNDYW52YXNOb2RlLnN0ZXAoKSApO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgQ2hhcnROb2RlIGV4dGVuZHMgTm9kZSB7XHJcbiAgcHJpdmF0ZSBjaGFydEJvdW5kczogQm91bmRzMjtcclxuICBwcml2YXRlIHNlcmllc0FycmF5OiBTZXJpZXNbXTtcclxuICBwcml2YXRlIHRpbWVXaWR0aDogbnVtYmVyO1xyXG4gIHByaXZhdGUgbW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHk6IFByb3BlcnR5PE1vZGVsVmlld1RyYW5zZm9ybTI+O1xyXG4gIHByaXZhdGUgZ3JpZExpbmVzOiBPYnNlcnZhYmxlQXJyYXk8eyB4MTogbnVtYmVyOyB5MTogbnVtYmVyOyB4MjogbnVtYmVyOyB5MjogbnVtYmVyOyBsaW5lRGFzaE9mZnNldDogbnVtYmVyIH0+O1xyXG4gIHByaXZhdGUgZ3JpZENhbnZhc05vZGU6IEdyaWRDYW52YXNOb2RlO1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gY2hhcnRCb3VuZHMgLSBib3VuZHMgb2YgdGhlIGNoYXJ0IG5vZGVcclxuICAgKiBAcGFyYW0gc2VyaWVzQXJyYXkgLSBzZXJpZXMgb2YgZGF0YSBwb2ludHNcclxuICAgKi9cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIGNoYXJ0Qm91bmRzOiBCb3VuZHMyLCBzZXJpZXNBcnJheTogU2VyaWVzW10gKSB7XHJcblxyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuY2hhcnRCb3VuZHMgPSBjaGFydEJvdW5kczsgLy8gKHJlYWQtb25seSlcclxuICAgIHRoaXMuc2VyaWVzQXJyYXkgPSBzZXJpZXNBcnJheTsgLy8gKHJlYWQtb25seSlcclxuXHJcbiAgICAvLyByZWFkLW9ubHlcclxuICAgIC8vIEFtb3VudCBvZiB0aW1lIHRvIHNob3cgb24gdGhlIGhvcml6b250YWwgYXhpcyBvZiB0aGUgY2hhcnRcclxuICAgIHRoaXMudGltZVdpZHRoID0gNzJFLTE2OyAvLyAocmVhZC1vbmx5KVxyXG5cclxuICAgIC8vIE1hcHBpbmcgZnJvbSBtb2RlbCAoU0kpIHRvIGNoYXJ0IGNvb3JkaW5hdGVzXHJcbiAgICB0aGlzLm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5ID0gbmV3IFByb3BlcnR5KCBNb2RlbFZpZXdUcmFuc2Zvcm0yLmNyZWF0ZVJlY3RhbmdsZU1hcHBpbmcoIG5ldyBCb3VuZHMyKCAwLCAtMSwgdGhpcy50aW1lV2lkdGgsIDEgKSwgY2hhcnRCb3VuZHMgKSApO1xyXG5cclxuICAgIC8vIEFkZCBncmlkIHRvIHRoZSBjaGFydFxyXG4gICAgdGhpcy5ncmlkTGluZXMgPSBjcmVhdGVPYnNlcnZhYmxlQXJyYXkoKTsgLy8gKHJlYWQtb25seSlcclxuICAgIHRoaXMuZ3JpZENhbnZhc05vZGUgPSBuZXcgR3JpZENhbnZhc05vZGUoIHRoaXMuZ3JpZExpbmVzLCB0aGlzLm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5LCBbIERBU0hfT04sIERBU0hfT0ZGIF0sIHtcclxuXHJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgY2FudmFzQm91bmRzOiBjaGFydEJvdW5kc1xyXG4gICAgfSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggdGhpcy5ncmlkQ2FudmFzTm9kZSApO1xyXG5cclxuICAgIC8vIEFkZCBub2RlcyBmb3IgdGhlIGdyaWQgbGluZXMgYW5kIHNlcmllcydzXHJcbiAgICBzZXJpZXNBcnJheS5mb3JFYWNoKCBzZXJpZXMgPT4gdGhpcy5hZGRDaGlsZCggbmV3IFNlcmllc05vZGUoIHNlcmllcywgdGhpcy5tb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eSwgdGhpcy5jaGFydEJvdW5kcyApICkgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB0aW1lIC0gc2ltdWxhdGlvbiB0aW1lXHJcbiAgICovXHJcbiAgcHVibGljIHN0ZXAoIHRpbWU6IG51bWJlciApOiB2b2lkIHtcclxuICAgIHRoaXMuc2ltdWxhdGlvblRpbWVDaGFuZ2VkKCB0aW1lICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3ZlIG92ZXIgdGhlIHZpZXcgcG9ydCBhcyB0aW1lIHBhc3Nlc1xyXG4gICAqIEBwYXJhbSB0aW1lIC0gc2ltdWxhdGlvbiB0aW1lXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzaW11bGF0aW9uVGltZUNoYW5nZWQoIHRpbWU6IG51bWJlciApOiB2b2lkIHtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIG1hcHBpbmcgZnJvbSBtb2RlbCB0byBjaGFydFxyXG4gICAgY29uc3QgbWluVGltZSA9IHRpbWUgLSB0aGlzLnRpbWVXaWR0aDtcclxuICAgIHRoaXMubW9kZWxWaWV3VHJhbnNmb3JtUHJvcGVydHkuc2V0KCBNb2RlbFZpZXdUcmFuc2Zvcm0yLmNyZWF0ZVJlY3RhbmdsZU1hcHBpbmcoXHJcbiAgICAgIG5ldyBCb3VuZHMyKCBtaW5UaW1lLCAtMSwgbWluVGltZSArIHRoaXMudGltZVdpZHRoLCAxICksIHRoaXMuY2hhcnRCb3VuZHMgKSApO1xyXG5cclxuICAgIC8vIENsZWFyIGdyaWQgbGluZXMgcG9pbnRzIGFuZCBhZGQgdGhlbSBiYWNrIGluIHRoZSBuZXcgcG9zaXRpb25zXHJcbiAgICB0aGlzLmdyaWRMaW5lcy5jbGVhcigpO1xyXG5cclxuICAgIC8vIERpc3RhbmNlIGJldHdlZW4gdmVydGljYWwgZ3JpZCBsaW5lc1xyXG4gICAgY29uc3QgdmVydGljYWxHcmlkTGluZVNwYWNpbmcgPSB0aGlzLnRpbWVXaWR0aCAvIDQ7XHJcbiAgICBjb25zdCB2ZXJ0aWNhbEdyaWRMaW5lU3BhY2luZ0RlbHRhID0gdGhpcy5nZXREZWx0YSggdmVydGljYWxHcmlkTGluZVNwYWNpbmcsIHRpbWUgKTtcclxuXHJcbiAgICAvLyBBZGQgdmVydGljYWwgZ3JpZCBsaW5lc1xyXG4gICAgZm9yICggbGV0IHggPSBtaW5UaW1lIC0gdmVydGljYWxHcmlkTGluZVNwYWNpbmdEZWx0YSArIHZlcnRpY2FsR3JpZExpbmVTcGFjaW5nO1xyXG4gICAgICAgICAgeCA8PSBtaW5UaW1lICsgdGhpcy50aW1lV2lkdGg7IHggKz0gdmVydGljYWxHcmlkTGluZVNwYWNpbmcgKSB7XHJcbiAgICAgIHRoaXMuYWRkVmVydGljYWxMaW5lKCB4ICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIG9uZSBob3Jpem9udGFsIGdyaWQgbGluZVxyXG4gICAgY29uc3QgaG9yaXpvbnRhbEdyaWRMaW5lRGVsdGEgPSB0aGlzLmdldERlbHRhKFxyXG4gICAgICB0aGlzLm1vZGVsVmlld1RyYW5zZm9ybVByb3BlcnR5LmdldCgpLnZpZXdUb01vZGVsRGVsdGFYKCBEQVNIX09OICsgREFTSF9PRkYgKSwgdGltZSApO1xyXG5cclxuICAgIC8vIEhvcml6b250YWwgYXhpc1xyXG4gICAgdGhpcy5ncmlkTGluZXMucHVzaCgge1xyXG4gICAgICB4MTogbWluVGltZSwgeTE6IDAsXHJcbiAgICAgIHgyOiBtaW5UaW1lICsgdGhpcy50aW1lV2lkdGgsIHkyOiAwLFxyXG4gICAgICBsaW5lRGFzaE9mZnNldDogdGhpcy5tb2RlbFZpZXdUcmFuc2Zvcm1Qcm9wZXJ0eS5nZXQoKS5tb2RlbFRvVmlld0RlbHRhWCggaG9yaXpvbnRhbEdyaWRMaW5lRGVsdGEgKVxyXG4gICAgfSApO1xyXG4gICAgdGhpcy5ncmlkQ2FudmFzTm9kZS5zdGVwKCk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIGFueSBwb2ludHMgdGhhdCBoYXZlIGdvbmUgb3V0c2lkZSBvZiB0aGUgdGltZSB3aW5kb3csIG90aGVyd2lzZSBpdCBpcyBhIG1lbW9yeSBsZWFrXHJcbiAgICB0aGlzLnNlcmllc0FycmF5LmZvckVhY2goIHNlcmllcyA9PiBzZXJpZXMua2VlcExhc3RTYW1wbGVzKCBtaW5UaW1lICkgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgdGhlIHBoYXNlIG9mZnNldCBzbyB0aGF0IGdyaWQgbGluZXMgYXBwZWFyIHRvIGJlIG1vdmluZyBhdCB0aGUgcmlnaHQgc3BlZWRcclxuICAgKiBAcGFyYW0gdmVydGljYWxHcmlkTGluZVNwYWNpbmcgLSBzcGFjZSBiZXR3ZWVuIHZlcnRpY2FsIGdyaWQgbGluZXNcclxuICAgKiBAcGFyYW0gdGltZSAtIHNpbXVsYXRpb24gdGltZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0RGVsdGEoIHZlcnRpY2FsR3JpZExpbmVTcGFjaW5nOiBudW1iZXIsIHRpbWU6IG51bWJlciApOiBudW1iZXIge1xyXG4gICAgY29uc3QgdG90YWxOdW1QZXJpb2RzID0gdGltZSAvIHZlcnRpY2FsR3JpZExpbmVTcGFjaW5nO1xyXG5cclxuICAgIC8vIGZvciBjb21wdXRpbmcgdGhlIHBoYXNlIHNvIHdlIG1ha2UgdGhlIHJpZ2h0IG51bWJlciBvZiBncmlkIGxpbmVzLCBqdXN0IGtlZXAgdGhlIGZyYWN0aW9uYWwgcGFydFxyXG4gICAgcmV0dXJuICggdG90YWxOdW1QZXJpb2RzICUgMSApICogdmVydGljYWxHcmlkTGluZVNwYWNpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHZlcnRpY2FsIGxpbmVzIHRvIHRoZSBncmlkXHJcbiAgICogQHBhcmFtIHggLSB4IGNvb3JkaW5hdGUgb2YgdmVydGljYWwgZ3JpZCBsaW5lc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgYWRkVmVydGljYWxMaW5lKCB4OiBudW1iZXIgKTogdm9pZCB7XHJcblxyXG4gICAgLy8gLTEgdG8gKzEgaXMgZmFyIGVub3VnaCBzaW5jZSBpbiBtb2RlbCBjb29yZGluYXRlc1xyXG4gICAgdGhpcy5ncmlkTGluZXMucHVzaCgge1xyXG4gICAgICB4MTogeCwgeTE6IC0xLFxyXG4gICAgICB4MjogeCwgeTI6IDEsXHJcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwXHJcbiAgICB9ICk7XHJcbiAgfVxyXG59XHJcblxyXG5iZW5kaW5nTGlnaHQucmVnaXN0ZXIoICdDaGFydE5vZGUnLCBDaGFydE5vZGUgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENoYXJ0Tm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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