// Copyright 2015-2022, University of Colorado Boulder

/**
 * Sensor for wave values, reads the wave amplitude as a function of time and position. Two probes can be used to
 * compare values.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chandrashekar Bemagoni (Actual Concepts)
 */

import BooleanProperty from '../../../../axon/js/BooleanProperty.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import Vector2Property from '../../../../dot/js/Vector2Property.js';
import bendingLight from '../../bendingLight.js';
import DataPoint from './DataPoint.js';
import Probe from './Probe.js';
class WaveSensor {
  /**
   * @param probe1Value - function for getting data from a probe at the specified point
   * @param probe2Value - function for getting data from a probe at the specified point
   */
  constructor(probe1Value, probe2Value) {
    // Set the relative position of the probes and body in model coordinates (SI). These values for initial probe and
    // body positions were obtained by printing out actual values at runtime, then dragging the objects to a good
    // looking position. This amount of precision is unnecessary, but these values were just sampled directly.
    this.probe1 = new Probe(-0.00001932, -0.0000052);
    this.probe2 = new Probe(-0.0000198, -0.0000062);
    this.bodyPositionProperty = new Vector2Property(new Vector2(-0.0000172, -0.00000605));

    // in the play area
    this.enabledProperty = new BooleanProperty(false);

    // Function for getting data from a probe at the specified point
    this.probe1Value = probe1Value;
    this.probe2Value = probe2Value;
  }

  // create a copy for use in toolbox icons, etc.
  copy() {
    const waveSensor = new WaveSensor(v => {
      return {
        time: 0,
        magnitude: 0
      };
    }, v => {
      return {
        time: 0,
        magnitude: 0
      };
    });
    waveSensor.bodyPositionProperty.value = this.bodyPositionProperty.value;
    waveSensor.probe1.positionProperty.value = this.probe1.positionProperty.value;
    waveSensor.probe2.positionProperty.value = this.probe2.positionProperty.value;
    return waveSensor;
  }
  step() {
    this.simulationTimeChanged();
  }

  // Read samples from the probes when the simulation time changes
  simulationTimeChanged() {
    this.updateProbeSample(this.probe1, this.probe1Value);
    this.updateProbeSample(this.probe2, this.probe2Value);
  }

  /**
   * Read the value from the probe function. May be None if not intersecting a light ray
   * @param probe
   * @param probeValue - function for getting data from a probe at the specified point
   */
  updateProbeSample(probe, probeValue) {
    // Read the value from the probe function. May be None if not intersecting a light ray
    const result = probeValue(probe.positionProperty.get());
    if (result) {
      probe.addSample(new DataPoint(result.time, result.magnitude));
    }
  }

  /**
   */
  reset() {
    this.bodyPositionProperty.reset();
    this.enabledProperty.reset();
    this.probe1.reset();
    this.probe2.reset();
  }
}
bendingLight.register('WaveSensor', WaveSensor);
export default WaveSensor;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb29sZWFuUHJvcGVydHkiLCJWZWN0b3IyIiwiVmVjdG9yMlByb3BlcnR5IiwiYmVuZGluZ0xpZ2h0IiwiRGF0YVBvaW50IiwiUHJvYmUiLCJXYXZlU2Vuc29yIiwiY29uc3RydWN0b3IiLCJwcm9iZTFWYWx1ZSIsInByb2JlMlZhbHVlIiwicHJvYmUxIiwicHJvYmUyIiwiYm9keVBvc2l0aW9uUHJvcGVydHkiLCJlbmFibGVkUHJvcGVydHkiLCJjb3B5Iiwid2F2ZVNlbnNvciIsInYiLCJ0aW1lIiwibWFnbml0dWRlIiwidmFsdWUiLCJwb3NpdGlvblByb3BlcnR5Iiwic3RlcCIsInNpbXVsYXRpb25UaW1lQ2hhbmdlZCIsInVwZGF0ZVByb2JlU2FtcGxlIiwicHJvYmUiLCJwcm9iZVZhbHVlIiwicmVzdWx0IiwiZ2V0IiwiYWRkU2FtcGxlIiwicmVzZXQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIldhdmVTZW5zb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogU2Vuc29yIGZvciB3YXZlIHZhbHVlcywgcmVhZHMgdGhlIHdhdmUgYW1wbGl0dWRlIGFzIGEgZnVuY3Rpb24gb2YgdGltZSBhbmQgcG9zaXRpb24uIFR3byBwcm9iZXMgY2FuIGJlIHVzZWQgdG9cclxuICogY29tcGFyZSB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIFJlaWQgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqIEBhdXRob3IgQ2hhbmRyYXNoZWthciBCZW1hZ29uaSAoQWN0dWFsIENvbmNlcHRzKVxyXG4gKi9cclxuXHJcbmltcG9ydCBCb29sZWFuUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9Cb29sZWFuUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9Qcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9WZWN0b3IyLmpzJztcclxuaW1wb3J0IFZlY3RvcjJQcm9wZXJ0eSBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMlByb3BlcnR5LmpzJztcclxuaW1wb3J0IGJlbmRpbmdMaWdodCBmcm9tICcuLi8uLi9iZW5kaW5nTGlnaHQuanMnO1xyXG5pbXBvcnQgRGF0YVBvaW50IGZyb20gJy4vRGF0YVBvaW50LmpzJztcclxuaW1wb3J0IFByb2JlIGZyb20gJy4vUHJvYmUuanMnO1xyXG5cclxuY2xhc3MgV2F2ZVNlbnNvciB7XHJcbiAgcHVibGljIHByb2JlMTogUHJvYmU7XHJcbiAgcHVibGljIHByb2JlMjogUHJvYmU7XHJcbiAgcHVibGljIGJvZHlQb3NpdGlvblByb3BlcnR5OiBQcm9wZXJ0eTxWZWN0b3IyPjtcclxuICBwdWJsaWMgZW5hYmxlZFByb3BlcnR5OiBQcm9wZXJ0eTxib29sZWFuPjtcclxuICBwcml2YXRlIHByb2JlMVZhbHVlOiAoIHBvc2l0aW9uOiBWZWN0b3IyICkgPT4geyB0aW1lOiBudW1iZXI7IG1hZ25pdHVkZTogbnVtYmVyIH0gfCBudWxsO1xyXG4gIHByaXZhdGUgcHJvYmUyVmFsdWU6ICggcG9zaXRpb246IFZlY3RvcjIgKSA9PiB7IHRpbWU6IG51bWJlcjsgbWFnbml0dWRlOiBudW1iZXIgfSB8IG51bGw7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBwcm9iZTFWYWx1ZSAtIGZ1bmN0aW9uIGZvciBnZXR0aW5nIGRhdGEgZnJvbSBhIHByb2JlIGF0IHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgKiBAcGFyYW0gcHJvYmUyVmFsdWUgLSBmdW5jdGlvbiBmb3IgZ2V0dGluZyBkYXRhIGZyb20gYSBwcm9iZSBhdCB0aGUgc3BlY2lmaWVkIHBvaW50XHJcbiAgICovXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBwcm9iZTFWYWx1ZTogKCBwb3NpdGlvbjogVmVjdG9yMiApID0+IHsgdGltZTogbnVtYmVyOyBtYWduaXR1ZGU6IG51bWJlciB9IHwgbnVsbCwgcHJvYmUyVmFsdWU6ICggcG9zaXRpb246IFZlY3RvcjIgKSA9PiB7IHRpbWU6IG51bWJlcjsgbWFnbml0dWRlOiBudW1iZXIgfSB8IG51bGwgKSB7XHJcblxyXG4gICAgLy8gU2V0IHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgcHJvYmVzIGFuZCBib2R5IGluIG1vZGVsIGNvb3JkaW5hdGVzIChTSSkuIFRoZXNlIHZhbHVlcyBmb3IgaW5pdGlhbCBwcm9iZSBhbmRcclxuICAgIC8vIGJvZHkgcG9zaXRpb25zIHdlcmUgb2J0YWluZWQgYnkgcHJpbnRpbmcgb3V0IGFjdHVhbCB2YWx1ZXMgYXQgcnVudGltZSwgdGhlbiBkcmFnZ2luZyB0aGUgb2JqZWN0cyB0byBhIGdvb2RcclxuICAgIC8vIGxvb2tpbmcgcG9zaXRpb24uIFRoaXMgYW1vdW50IG9mIHByZWNpc2lvbiBpcyB1bm5lY2Vzc2FyeSwgYnV0IHRoZXNlIHZhbHVlcyB3ZXJlIGp1c3Qgc2FtcGxlZCBkaXJlY3RseS5cclxuICAgIHRoaXMucHJvYmUxID0gbmV3IFByb2JlKCAtMC4wMDAwMTkzMiwgLTAuMDAwMDA1MiApO1xyXG4gICAgdGhpcy5wcm9iZTIgPSBuZXcgUHJvYmUoIC0wLjAwMDAxOTgsIC0wLjAwMDAwNjIgKTtcclxuXHJcbiAgICB0aGlzLmJvZHlQb3NpdGlvblByb3BlcnR5ID0gbmV3IFZlY3RvcjJQcm9wZXJ0eSggbmV3IFZlY3RvcjIoIC0wLjAwMDAxNzIsIC0wLjAwMDAwNjA1ICkgKTtcclxuXHJcbiAgICAvLyBpbiB0aGUgcGxheSBhcmVhXHJcbiAgICB0aGlzLmVuYWJsZWRQcm9wZXJ0eSA9IG5ldyBCb29sZWFuUHJvcGVydHkoIGZhbHNlICk7XHJcblxyXG4gICAgLy8gRnVuY3Rpb24gZm9yIGdldHRpbmcgZGF0YSBmcm9tIGEgcHJvYmUgYXQgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAgdGhpcy5wcm9iZTFWYWx1ZSA9IHByb2JlMVZhbHVlO1xyXG4gICAgdGhpcy5wcm9iZTJWYWx1ZSA9IHByb2JlMlZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLy8gY3JlYXRlIGEgY29weSBmb3IgdXNlIGluIHRvb2xib3ggaWNvbnMsIGV0Yy5cclxuICBwdWJsaWMgY29weSgpOiBXYXZlU2Vuc29yIHtcclxuICAgIGNvbnN0IHdhdmVTZW5zb3IgPSBuZXcgV2F2ZVNlbnNvciggdiA9PiB7cmV0dXJuIHsgdGltZTogMCwgbWFnbml0dWRlOiAwIH07fSwgdiA9PiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGltZTogMCxcclxuICAgICAgICBtYWduaXR1ZGU6IDBcclxuICAgICAgfTtcclxuICAgIH0gKTtcclxuICAgIHdhdmVTZW5zb3IuYm9keVBvc2l0aW9uUHJvcGVydHkudmFsdWUgPSB0aGlzLmJvZHlQb3NpdGlvblByb3BlcnR5LnZhbHVlO1xyXG4gICAgd2F2ZVNlbnNvci5wcm9iZTEucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZSA9IHRoaXMucHJvYmUxLnBvc2l0aW9uUHJvcGVydHkudmFsdWU7XHJcbiAgICB3YXZlU2Vuc29yLnByb2JlMi5wb3NpdGlvblByb3BlcnR5LnZhbHVlID0gdGhpcy5wcm9iZTIucG9zaXRpb25Qcm9wZXJ0eS52YWx1ZTtcclxuICAgIHJldHVybiB3YXZlU2Vuc29yO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0ZXAoKTogdm9pZCB7XHJcbiAgICB0aGlzLnNpbXVsYXRpb25UaW1lQ2hhbmdlZCgpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVhZCBzYW1wbGVzIGZyb20gdGhlIHByb2JlcyB3aGVuIHRoZSBzaW11bGF0aW9uIHRpbWUgY2hhbmdlc1xyXG4gIHByaXZhdGUgc2ltdWxhdGlvblRpbWVDaGFuZ2VkKCk6IHZvaWQge1xyXG4gICAgdGhpcy51cGRhdGVQcm9iZVNhbXBsZSggdGhpcy5wcm9iZTEsIHRoaXMucHJvYmUxVmFsdWUgKTtcclxuICAgIHRoaXMudXBkYXRlUHJvYmVTYW1wbGUoIHRoaXMucHJvYmUyLCB0aGlzLnByb2JlMlZhbHVlICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9iZSBmdW5jdGlvbi4gTWF5IGJlIE5vbmUgaWYgbm90IGludGVyc2VjdGluZyBhIGxpZ2h0IHJheVxyXG4gICAqIEBwYXJhbSBwcm9iZVxyXG4gICAqIEBwYXJhbSBwcm9iZVZhbHVlIC0gZnVuY3Rpb24gZm9yIGdldHRpbmcgZGF0YSBmcm9tIGEgcHJvYmUgYXQgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAqL1xyXG4gIHByaXZhdGUgdXBkYXRlUHJvYmVTYW1wbGUoIHByb2JlOiBQcm9iZSwgcHJvYmVWYWx1ZTogKCBwb3NpdGlvbjogVmVjdG9yMiApID0+IHsgdGltZTogbnVtYmVyOyBtYWduaXR1ZGU6IG51bWJlciB9IHwgbnVsbCApOiB2b2lkIHtcclxuXHJcbiAgICAvLyBSZWFkIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9iZSBmdW5jdGlvbi4gTWF5IGJlIE5vbmUgaWYgbm90IGludGVyc2VjdGluZyBhIGxpZ2h0IHJheVxyXG4gICAgY29uc3QgcmVzdWx0ID0gcHJvYmVWYWx1ZSggcHJvYmUucG9zaXRpb25Qcm9wZXJ0eS5nZXQoKSApO1xyXG4gICAgaWYgKCByZXN1bHQgKSB7XHJcbiAgICAgIHByb2JlLmFkZFNhbXBsZSggbmV3IERhdGFQb2ludCggcmVzdWx0LnRpbWUsIHJlc3VsdC5tYWduaXR1ZGUgKSApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICovXHJcbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5ib2R5UG9zaXRpb25Qcm9wZXJ0eS5yZXNldCgpO1xyXG4gICAgdGhpcy5lbmFibGVkUHJvcGVydHkucmVzZXQoKTtcclxuICAgIHRoaXMucHJvYmUxLnJlc2V0KCk7XHJcbiAgICB0aGlzLnByb2JlMi5yZXNldCgpO1xyXG4gIH1cclxufVxyXG5cclxuYmVuZGluZ0xpZ2h0LnJlZ2lzdGVyKCAnV2F2ZVNlbnNvcicsIFdhdmVTZW5zb3IgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdhdmVTZW5zb3I7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxlQUFlLE1BQU0sd0NBQXdDO0FBRXBFLE9BQU9DLE9BQU8sTUFBTSwrQkFBK0I7QUFDbkQsT0FBT0MsZUFBZSxNQUFNLHVDQUF1QztBQUNuRSxPQUFPQyxZQUFZLE1BQU0sdUJBQXVCO0FBQ2hELE9BQU9DLFNBQVMsTUFBTSxnQkFBZ0I7QUFDdEMsT0FBT0MsS0FBSyxNQUFNLFlBQVk7QUFFOUIsTUFBTUMsVUFBVSxDQUFDO0VBUWY7QUFDRjtBQUNBO0FBQ0E7RUFDU0MsV0FBV0EsQ0FBRUMsV0FBZ0YsRUFBRUMsV0FBZ0YsRUFBRztJQUV2TDtJQUNBO0lBQ0E7SUFDQSxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJTCxLQUFLLENBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxTQUFVLENBQUM7SUFDbEQsSUFBSSxDQUFDTSxNQUFNLEdBQUcsSUFBSU4sS0FBSyxDQUFFLENBQUMsU0FBUyxFQUFFLENBQUMsU0FBVSxDQUFDO0lBRWpELElBQUksQ0FBQ08sb0JBQW9CLEdBQUcsSUFBSVYsZUFBZSxDQUFFLElBQUlELE9BQU8sQ0FBRSxDQUFDLFNBQVMsRUFBRSxDQUFDLFVBQVcsQ0FBRSxDQUFDOztJQUV6RjtJQUNBLElBQUksQ0FBQ1ksZUFBZSxHQUFHLElBQUliLGVBQWUsQ0FBRSxLQUFNLENBQUM7O0lBRW5EO0lBQ0EsSUFBSSxDQUFDUSxXQUFXLEdBQUdBLFdBQVc7SUFDOUIsSUFBSSxDQUFDQyxXQUFXLEdBQUdBLFdBQVc7RUFDaEM7O0VBRUE7RUFDT0ssSUFBSUEsQ0FBQSxFQUFlO0lBQ3hCLE1BQU1DLFVBQVUsR0FBRyxJQUFJVCxVQUFVLENBQUVVLENBQUMsSUFBSTtNQUFDLE9BQU87UUFBRUMsSUFBSSxFQUFFLENBQUM7UUFBRUMsU0FBUyxFQUFFO01BQUUsQ0FBQztJQUFDLENBQUMsRUFBRUYsQ0FBQyxJQUFJO01BQ2hGLE9BQU87UUFDTEMsSUFBSSxFQUFFLENBQUM7UUFDUEMsU0FBUyxFQUFFO01BQ2IsQ0FBQztJQUNILENBQUUsQ0FBQztJQUNISCxVQUFVLENBQUNILG9CQUFvQixDQUFDTyxLQUFLLEdBQUcsSUFBSSxDQUFDUCxvQkFBb0IsQ0FBQ08sS0FBSztJQUN2RUosVUFBVSxDQUFDTCxNQUFNLENBQUNVLGdCQUFnQixDQUFDRCxLQUFLLEdBQUcsSUFBSSxDQUFDVCxNQUFNLENBQUNVLGdCQUFnQixDQUFDRCxLQUFLO0lBQzdFSixVQUFVLENBQUNKLE1BQU0sQ0FBQ1MsZ0JBQWdCLENBQUNELEtBQUssR0FBRyxJQUFJLENBQUNSLE1BQU0sQ0FBQ1MsZ0JBQWdCLENBQUNELEtBQUs7SUFDN0UsT0FBT0osVUFBVTtFQUNuQjtFQUVPTSxJQUFJQSxDQUFBLEVBQVM7SUFDbEIsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQyxDQUFDO0VBQzlCOztFQUVBO0VBQ1FBLHFCQUFxQkEsQ0FBQSxFQUFTO0lBQ3BDLElBQUksQ0FBQ0MsaUJBQWlCLENBQUUsSUFBSSxDQUFDYixNQUFNLEVBQUUsSUFBSSxDQUFDRixXQUFZLENBQUM7SUFDdkQsSUFBSSxDQUFDZSxpQkFBaUIsQ0FBRSxJQUFJLENBQUNaLE1BQU0sRUFBRSxJQUFJLENBQUNGLFdBQVksQ0FBQztFQUN6RDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ1VjLGlCQUFpQkEsQ0FBRUMsS0FBWSxFQUFFQyxVQUErRSxFQUFTO0lBRS9IO0lBQ0EsTUFBTUMsTUFBTSxHQUFHRCxVQUFVLENBQUVELEtBQUssQ0FBQ0osZ0JBQWdCLENBQUNPLEdBQUcsQ0FBQyxDQUFFLENBQUM7SUFDekQsSUFBS0QsTUFBTSxFQUFHO01BQ1pGLEtBQUssQ0FBQ0ksU0FBUyxDQUFFLElBQUl4QixTQUFTLENBQUVzQixNQUFNLENBQUNULElBQUksRUFBRVMsTUFBTSxDQUFDUixTQUFVLENBQUUsQ0FBQztJQUNuRTtFQUNGOztFQUVBO0FBQ0Y7RUFDU1csS0FBS0EsQ0FBQSxFQUFTO0lBQ25CLElBQUksQ0FBQ2pCLG9CQUFvQixDQUFDaUIsS0FBSyxDQUFDLENBQUM7SUFDakMsSUFBSSxDQUFDaEIsZUFBZSxDQUFDZ0IsS0FBSyxDQUFDLENBQUM7SUFDNUIsSUFBSSxDQUFDbkIsTUFBTSxDQUFDbUIsS0FBSyxDQUFDLENBQUM7SUFDbkIsSUFBSSxDQUFDbEIsTUFBTSxDQUFDa0IsS0FBSyxDQUFDLENBQUM7RUFDckI7QUFDRjtBQUVBMUIsWUFBWSxDQUFDMkIsUUFBUSxDQUFFLFlBQVksRUFBRXhCLFVBQVcsQ0FBQztBQUVqRCxlQUFlQSxVQUFVIn0=