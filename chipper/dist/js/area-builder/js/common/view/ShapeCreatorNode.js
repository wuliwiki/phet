// Copyright 2014-2022, University of Colorado Boulder

/**
 * A Scenery node that can be clicked upon to create new movable shapes in the model.
 *
 * @author John Blanco
 */

import Property from '../../../../axon/js/Property.js';
import Bounds2 from '../../../../dot/js/Bounds2.js';
import ScreenView from '../../../../joist/js/ScreenView.js';
import merge from '../../../../phet-core/js/merge.js';
import { Color, DragListener, Node, Path } from '../../../../scenery/js/imports.js';
import areaBuilder from '../../areaBuilder.js';
import AreaBuilderSharedConstants from '../AreaBuilderSharedConstants.js';
import MovableShape from '../model/MovableShape.js';
import Grid from './Grid.js';

// constants
const BORDER_LINE_WIDTH = 1;
class ShapeCreatorNode extends Node {
  /**
   * @param {Shape} shape
   * @param {string|Color} color
   * @param {function(MovableShape)} addShapeToModel - A function for adding the created shape to the model
   * @param {Object} [options]
   */
  constructor(shape, color, addShapeToModel, options) {
    assert && assert(shape.bounds.minX === 0 && shape.bounds.minY === 0, 'Error: Shape is expected to be located at 0, 0');
    super({
      cursor: 'pointer'
    });
    options = merge({
      // Spacing of the grid, if any, that should be shown on the creator node.  Null indicates no grid.
      gridSpacing: null,
      // Max number of shapes that can be created by this node.
      creationLimit: Number.POSITIVE_INFINITY,
      // Drag bounds for the created shapes.
      shapeDragBounds: Bounds2.EVERYTHING,
      // This is a node that is or will be somewhere up the scene graph tree from this ShapeCreatorNode, doesn't move,
      // and whose parent has the coordinate frame needed to do the appropriate transformations when the a drag takes
      // place on this ShapeCreatorNode. This is needed in cases where the ShapeCreatorNode can be moved while a drag
      // of a created node is still in progress.  This can occur when the ShapeCreatorNode is placed on a carousel and
      // the sim is being used in a multi-touch environment.  See https://github.com/phetsims/area-builder/issues/95 for
      // more information.
      nonMovingAncestor: null
    }, options);

    // parameter check
    if (options.creationLimit < Number.POSITIVE_INFINITY && (shape.bounds.width !== AreaBuilderSharedConstants.UNIT_SQUARE_LENGTH || shape.bounds.height !== AreaBuilderSharedConstants.UNIT_SQUARE_LENGTH)) {
      // The ability to set a creation limit ONLY works for unit squares.  The reason for this is that non-unit shapes
      // are generally decomposed into unit squares when added to the placement board, so it's hard to track when they
      // get returned to their origin.  It would be possible to do this, but the requirements of the sim at the time of
      // this writing make it unnecessary.  So, if you're hitting this exception, the code may need to be revamped to
      // support creation limits for shapes that are not unit squares.
      throw new Error('Creation limit is only supported for unit squares.');
    }

    // Create the node that the user will click upon to add a model element to the view.
    const representation = new Path(shape, {
      fill: color,
      stroke: Color.toColor(color).colorUtilsDarker(AreaBuilderSharedConstants.PERIMETER_DARKEN_FACTOR),
      lineWidth: BORDER_LINE_WIDTH,
      lineJoin: 'round'
    });
    this.addChild(representation);

    // Add grid if specified.
    if (options.gridSpacing) {
      const gridNode = new Grid(representation.bounds.dilated(-BORDER_LINE_WIDTH), options.gridSpacing, {
        lineDash: [0, 3, 1, 0],
        stroke: 'black'
      });
      this.addChild(gridNode);
    }
    const createdCountProperty = new Property(0); // Used to track the number of shapes created and not returned.

    // If the created count exceeds the max, make this node invisible (which also makes it unusable).
    createdCountProperty.link(numCreated => {
      this.visible = numCreated < options.creationLimit;
    });

    // variables used by the drag handler
    let parentScreenView = null; // needed for coordinate transforms
    let movableShape;
    let dragOffset;

    // Adjust the drag bounds to compensate for the shape that that the entire shape will stay in bounds.
    const shapeDragBounds = options.shapeDragBounds.copy();
    shapeDragBounds.setMaxX(shapeDragBounds.maxX - shape.bounds.width);
    shapeDragBounds.setMaxY(shapeDragBounds.maxY - shape.bounds.height);

    // Enclose the drag bounds in a Property so that it can be used in the drag handler.
    const dragBoundsProperty = new Property(shapeDragBounds);

    // Add the listener that will allow the user to click on this and create a new shape, then position it in the model.
    const dragListener = new DragListener({
      dragBoundsProperty: dragBoundsProperty,
      targetNode: options.nonMovingAncestor,
      // Allow moving a finger (touch) across this node to interact with it
      allowTouchSnag: true,
      start: event => {
        if (!parentScreenView) {
          // Find the parent screen view by moving up the scene graph.
          let testNode = this.parents[0];
          while (testNode !== null) {
            if (testNode instanceof ScreenView) {
              parentScreenView = testNode;
              break;
            }
            testNode = testNode.parents[0]; // move up the scene graph by one level
          }

          assert && assert(parentScreenView, 'unable to find parent screen view');
        }

        // Determine the initial position of the new element as a function of the event position and this node's bounds.
        const upperLeftCornerGlobal = this.parentToGlobalPoint(this.leftTop);
        dragOffset = upperLeftCornerGlobal.minus(event.pointer.point);
        const initialPosition = parentScreenView.globalToLocalPoint(event.pointer.point.plus(dragOffset));

        // Create and add the new model element.
        movableShape = new MovableShape(shape, color, initialPosition);
        movableShape.userControlledProperty.set(true);
        addShapeToModel(movableShape);

        // If the creation count is limited, adjust the value and monitor the created shape for if/when it is returned.
        if (options.creationLimit < Number.POSITIVE_INFINITY) {
          // Use an IIFE to keep a reference of the movable shape in a closure.
          (() => {
            createdCountProperty.value++;
            const localRefToMovableShape = movableShape;
            localRefToMovableShape.returnedToOriginEmitter.addListener(function returnedToOriginListener() {
              if (!localRefToMovableShape.userControlledProperty.get()) {
                // The shape has been returned to its origin.
                createdCountProperty.value--;
                localRefToMovableShape.returnedToOriginEmitter.removeListener(returnedToOriginListener);
              }
            });
          })();
        }
      },
      drag: event => {
        assert && assert(movableShape, 'no movable shape for drag');
        movableShape.positionProperty.set(parentScreenView.globalToLocalPoint(event.pointer.point.plus(dragOffset)));
      },
      end: () => {
        movableShape.userControlledProperty.set(false);
        movableShape = null;
      }
    });
    this.addInputListener(dragListener);

    // Pass options through to parent.
    this.mutate(options);

    // @private
    this.disposeShapeCreatorNode = () => {
      dragListener.dispose();
    };
  }

  /**
   * release memory references
   * @public
   */
  dispose() {
    this.disposeShapeCreatorNode();
    super.dispose();
  }
}
areaBuilder.register('ShapeCreatorNode', ShapeCreatorNode);
export default ShapeCreatorNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQcm9wZXJ0eSIsIkJvdW5kczIiLCJTY3JlZW5WaWV3IiwibWVyZ2UiLCJDb2xvciIsIkRyYWdMaXN0ZW5lciIsIk5vZGUiLCJQYXRoIiwiYXJlYUJ1aWxkZXIiLCJBcmVhQnVpbGRlclNoYXJlZENvbnN0YW50cyIsIk1vdmFibGVTaGFwZSIsIkdyaWQiLCJCT1JERVJfTElORV9XSURUSCIsIlNoYXBlQ3JlYXRvck5vZGUiLCJjb25zdHJ1Y3RvciIsInNoYXBlIiwiY29sb3IiLCJhZGRTaGFwZVRvTW9kZWwiLCJvcHRpb25zIiwiYXNzZXJ0IiwiYm91bmRzIiwibWluWCIsIm1pblkiLCJjdXJzb3IiLCJncmlkU3BhY2luZyIsImNyZWF0aW9uTGltaXQiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsInNoYXBlRHJhZ0JvdW5kcyIsIkVWRVJZVEhJTkciLCJub25Nb3ZpbmdBbmNlc3RvciIsIndpZHRoIiwiVU5JVF9TUVVBUkVfTEVOR1RIIiwiaGVpZ2h0IiwiRXJyb3IiLCJyZXByZXNlbnRhdGlvbiIsImZpbGwiLCJzdHJva2UiLCJ0b0NvbG9yIiwiY29sb3JVdGlsc0RhcmtlciIsIlBFUklNRVRFUl9EQVJLRU5fRkFDVE9SIiwibGluZVdpZHRoIiwibGluZUpvaW4iLCJhZGRDaGlsZCIsImdyaWROb2RlIiwiZGlsYXRlZCIsImxpbmVEYXNoIiwiY3JlYXRlZENvdW50UHJvcGVydHkiLCJsaW5rIiwibnVtQ3JlYXRlZCIsInZpc2libGUiLCJwYXJlbnRTY3JlZW5WaWV3IiwibW92YWJsZVNoYXBlIiwiZHJhZ09mZnNldCIsImNvcHkiLCJzZXRNYXhYIiwibWF4WCIsInNldE1heFkiLCJtYXhZIiwiZHJhZ0JvdW5kc1Byb3BlcnR5IiwiZHJhZ0xpc3RlbmVyIiwidGFyZ2V0Tm9kZSIsImFsbG93VG91Y2hTbmFnIiwic3RhcnQiLCJldmVudCIsInRlc3ROb2RlIiwicGFyZW50cyIsInVwcGVyTGVmdENvcm5lckdsb2JhbCIsInBhcmVudFRvR2xvYmFsUG9pbnQiLCJsZWZ0VG9wIiwibWludXMiLCJwb2ludGVyIiwicG9pbnQiLCJpbml0aWFsUG9zaXRpb24iLCJnbG9iYWxUb0xvY2FsUG9pbnQiLCJwbHVzIiwidXNlckNvbnRyb2xsZWRQcm9wZXJ0eSIsInNldCIsInZhbHVlIiwibG9jYWxSZWZUb01vdmFibGVTaGFwZSIsInJldHVybmVkVG9PcmlnaW5FbWl0dGVyIiwiYWRkTGlzdGVuZXIiLCJyZXR1cm5lZFRvT3JpZ2luTGlzdGVuZXIiLCJnZXQiLCJyZW1vdmVMaXN0ZW5lciIsImRyYWciLCJwb3NpdGlvblByb3BlcnR5IiwiZW5kIiwiYWRkSW5wdXRMaXN0ZW5lciIsIm11dGF0ZSIsImRpc3Bvc2VTaGFwZUNyZWF0b3JOb2RlIiwiZGlzcG9zZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiU2hhcGVDcmVhdG9yTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNC0yMDIyLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBBIFNjZW5lcnkgbm9kZSB0aGF0IGNhbiBiZSBjbGlja2VkIHVwb24gdG8gY3JlYXRlIG5ldyBtb3ZhYmxlIHNoYXBlcyBpbiB0aGUgbW9kZWwuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICovXHJcblxyXG5pbXBvcnQgUHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9Qcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBCb3VuZHMyIGZyb20gJy4uLy4uLy4uLy4uL2RvdC9qcy9Cb3VuZHMyLmpzJztcclxuaW1wb3J0IFNjcmVlblZpZXcgZnJvbSAnLi4vLi4vLi4vLi4vam9pc3QvanMvU2NyZWVuVmlldy5qcyc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvbWVyZ2UuanMnO1xyXG5pbXBvcnQgeyBDb2xvciwgRHJhZ0xpc3RlbmVyLCBOb2RlLCBQYXRoIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IGFyZWFCdWlsZGVyIGZyb20gJy4uLy4uL2FyZWFCdWlsZGVyLmpzJztcclxuaW1wb3J0IEFyZWFCdWlsZGVyU2hhcmVkQ29uc3RhbnRzIGZyb20gJy4uL0FyZWFCdWlsZGVyU2hhcmVkQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IE1vdmFibGVTaGFwZSBmcm9tICcuLi9tb2RlbC9Nb3ZhYmxlU2hhcGUuanMnO1xyXG5pbXBvcnQgR3JpZCBmcm9tICcuL0dyaWQuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IEJPUkRFUl9MSU5FX1dJRFRIID0gMTtcclxuXHJcbmNsYXNzIFNoYXBlQ3JlYXRvck5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xDb2xvcn0gY29sb3JcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE1vdmFibGVTaGFwZSl9IGFkZFNoYXBlVG9Nb2RlbCAtIEEgZnVuY3Rpb24gZm9yIGFkZGluZyB0aGUgY3JlYXRlZCBzaGFwZSB0byB0aGUgbW9kZWxcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIHNoYXBlLCBjb2xvciwgYWRkU2hhcGVUb01vZGVsLCBvcHRpb25zICkge1xyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggc2hhcGUuYm91bmRzLm1pblggPT09IDAgJiYgc2hhcGUuYm91bmRzLm1pblkgPT09IDAsICdFcnJvcjogU2hhcGUgaXMgZXhwZWN0ZWQgdG8gYmUgbG9jYXRlZCBhdCAwLCAwJyApO1xyXG4gICAgc3VwZXIoIHsgY3Vyc29yOiAncG9pbnRlcicgfSApO1xyXG5cclxuICAgIG9wdGlvbnMgPSBtZXJnZSgge1xyXG5cclxuICAgICAgLy8gU3BhY2luZyBvZiB0aGUgZ3JpZCwgaWYgYW55LCB0aGF0IHNob3VsZCBiZSBzaG93biBvbiB0aGUgY3JlYXRvciBub2RlLiAgTnVsbCBpbmRpY2F0ZXMgbm8gZ3JpZC5cclxuICAgICAgZ3JpZFNwYWNpbmc6IG51bGwsXHJcblxyXG4gICAgICAvLyBNYXggbnVtYmVyIG9mIHNoYXBlcyB0aGF0IGNhbiBiZSBjcmVhdGVkIGJ5IHRoaXMgbm9kZS5cclxuICAgICAgY3JlYXRpb25MaW1pdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxyXG5cclxuICAgICAgLy8gRHJhZyBib3VuZHMgZm9yIHRoZSBjcmVhdGVkIHNoYXBlcy5cclxuICAgICAgc2hhcGVEcmFnQm91bmRzOiBCb3VuZHMyLkVWRVJZVEhJTkcsXHJcblxyXG4gICAgICAvLyBUaGlzIGlzIGEgbm9kZSB0aGF0IGlzIG9yIHdpbGwgYmUgc29tZXdoZXJlIHVwIHRoZSBzY2VuZSBncmFwaCB0cmVlIGZyb20gdGhpcyBTaGFwZUNyZWF0b3JOb2RlLCBkb2Vzbid0IG1vdmUsXHJcbiAgICAgIC8vIGFuZCB3aG9zZSBwYXJlbnQgaGFzIHRoZSBjb29yZGluYXRlIGZyYW1lIG5lZWRlZCB0byBkbyB0aGUgYXBwcm9wcmlhdGUgdHJhbnNmb3JtYXRpb25zIHdoZW4gdGhlIGEgZHJhZyB0YWtlc1xyXG4gICAgICAvLyBwbGFjZSBvbiB0aGlzIFNoYXBlQ3JlYXRvck5vZGUuIFRoaXMgaXMgbmVlZGVkIGluIGNhc2VzIHdoZXJlIHRoZSBTaGFwZUNyZWF0b3JOb2RlIGNhbiBiZSBtb3ZlZCB3aGlsZSBhIGRyYWdcclxuICAgICAgLy8gb2YgYSBjcmVhdGVkIG5vZGUgaXMgc3RpbGwgaW4gcHJvZ3Jlc3MuICBUaGlzIGNhbiBvY2N1ciB3aGVuIHRoZSBTaGFwZUNyZWF0b3JOb2RlIGlzIHBsYWNlZCBvbiBhIGNhcm91c2VsIGFuZFxyXG4gICAgICAvLyB0aGUgc2ltIGlzIGJlaW5nIHVzZWQgaW4gYSBtdWx0aS10b3VjaCBlbnZpcm9ubWVudC4gIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvYXJlYS1idWlsZGVyL2lzc3Vlcy85NSBmb3JcclxuICAgICAgLy8gbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAgbm9uTW92aW5nQW5jZXN0b3I6IG51bGxcclxuICAgIH0sIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBwYXJhbWV0ZXIgY2hlY2tcclxuICAgIGlmICggb3B0aW9ucy5jcmVhdGlvbkxpbWl0IDwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmXHJcbiAgICAgICAgICggc2hhcGUuYm91bmRzLndpZHRoICE9PSBBcmVhQnVpbGRlclNoYXJlZENvbnN0YW50cy5VTklUX1NRVUFSRV9MRU5HVEggfHxcclxuICAgICAgICAgICBzaGFwZS5ib3VuZHMuaGVpZ2h0ICE9PSBBcmVhQnVpbGRlclNoYXJlZENvbnN0YW50cy5VTklUX1NRVUFSRV9MRU5HVEggKSApIHtcclxuXHJcbiAgICAgIC8vIFRoZSBhYmlsaXR5IHRvIHNldCBhIGNyZWF0aW9uIGxpbWl0IE9OTFkgd29ya3MgZm9yIHVuaXQgc3F1YXJlcy4gIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCBub24tdW5pdCBzaGFwZXNcclxuICAgICAgLy8gYXJlIGdlbmVyYWxseSBkZWNvbXBvc2VkIGludG8gdW5pdCBzcXVhcmVzIHdoZW4gYWRkZWQgdG8gdGhlIHBsYWNlbWVudCBib2FyZCwgc28gaXQncyBoYXJkIHRvIHRyYWNrIHdoZW4gdGhleVxyXG4gICAgICAvLyBnZXQgcmV0dXJuZWQgdG8gdGhlaXIgb3JpZ2luLiAgSXQgd291bGQgYmUgcG9zc2libGUgdG8gZG8gdGhpcywgYnV0IHRoZSByZXF1aXJlbWVudHMgb2YgdGhlIHNpbSBhdCB0aGUgdGltZSBvZlxyXG4gICAgICAvLyB0aGlzIHdyaXRpbmcgbWFrZSBpdCB1bm5lY2Vzc2FyeS4gIFNvLCBpZiB5b3UncmUgaGl0dGluZyB0aGlzIGV4Y2VwdGlvbiwgdGhlIGNvZGUgbWF5IG5lZWQgdG8gYmUgcmV2YW1wZWQgdG9cclxuICAgICAgLy8gc3VwcG9ydCBjcmVhdGlvbiBsaW1pdHMgZm9yIHNoYXBlcyB0aGF0IGFyZSBub3QgdW5pdCBzcXVhcmVzLlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoICdDcmVhdGlvbiBsaW1pdCBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgdW5pdCBzcXVhcmVzLicgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIG5vZGUgdGhhdCB0aGUgdXNlciB3aWxsIGNsaWNrIHVwb24gdG8gYWRkIGEgbW9kZWwgZWxlbWVudCB0byB0aGUgdmlldy5cclxuICAgIGNvbnN0IHJlcHJlc2VudGF0aW9uID0gbmV3IFBhdGgoIHNoYXBlLCB7XHJcbiAgICAgIGZpbGw6IGNvbG9yLFxyXG4gICAgICBzdHJva2U6IENvbG9yLnRvQ29sb3IoIGNvbG9yICkuY29sb3JVdGlsc0RhcmtlciggQXJlYUJ1aWxkZXJTaGFyZWRDb25zdGFudHMuUEVSSU1FVEVSX0RBUktFTl9GQUNUT1IgKSxcclxuICAgICAgbGluZVdpZHRoOiBCT1JERVJfTElORV9XSURUSCxcclxuICAgICAgbGluZUpvaW46ICdyb3VuZCdcclxuICAgIH0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIHJlcHJlc2VudGF0aW9uICk7XHJcblxyXG4gICAgLy8gQWRkIGdyaWQgaWYgc3BlY2lmaWVkLlxyXG4gICAgaWYgKCBvcHRpb25zLmdyaWRTcGFjaW5nICkge1xyXG4gICAgICBjb25zdCBncmlkTm9kZSA9IG5ldyBHcmlkKCByZXByZXNlbnRhdGlvbi5ib3VuZHMuZGlsYXRlZCggLUJPUkRFUl9MSU5FX1dJRFRIICksIG9wdGlvbnMuZ3JpZFNwYWNpbmcsIHtcclxuICAgICAgICBsaW5lRGFzaDogWyAwLCAzLCAxLCAwIF0sXHJcbiAgICAgICAgc3Ryb2tlOiAnYmxhY2snXHJcbiAgICAgIH0gKTtcclxuICAgICAgdGhpcy5hZGRDaGlsZCggZ3JpZE5vZGUgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjcmVhdGVkQ291bnRQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eSggMCApOyAvLyBVc2VkIHRvIHRyYWNrIHRoZSBudW1iZXIgb2Ygc2hhcGVzIGNyZWF0ZWQgYW5kIG5vdCByZXR1cm5lZC5cclxuXHJcbiAgICAvLyBJZiB0aGUgY3JlYXRlZCBjb3VudCBleGNlZWRzIHRoZSBtYXgsIG1ha2UgdGhpcyBub2RlIGludmlzaWJsZSAod2hpY2ggYWxzbyBtYWtlcyBpdCB1bnVzYWJsZSkuXHJcbiAgICBjcmVhdGVkQ291bnRQcm9wZXJ0eS5saW5rKCBudW1DcmVhdGVkID0+IHtcclxuICAgICAgdGhpcy52aXNpYmxlID0gbnVtQ3JlYXRlZCA8IG9wdGlvbnMuY3JlYXRpb25MaW1pdDtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyB2YXJpYWJsZXMgdXNlZCBieSB0aGUgZHJhZyBoYW5kbGVyXHJcbiAgICBsZXQgcGFyZW50U2NyZWVuVmlldyA9IG51bGw7IC8vIG5lZWRlZCBmb3IgY29vcmRpbmF0ZSB0cmFuc2Zvcm1zXHJcbiAgICBsZXQgbW92YWJsZVNoYXBlO1xyXG4gICAgbGV0IGRyYWdPZmZzZXQ7XHJcblxyXG4gICAgLy8gQWRqdXN0IHRoZSBkcmFnIGJvdW5kcyB0byBjb21wZW5zYXRlIGZvciB0aGUgc2hhcGUgdGhhdCB0aGF0IHRoZSBlbnRpcmUgc2hhcGUgd2lsbCBzdGF5IGluIGJvdW5kcy5cclxuICAgIGNvbnN0IHNoYXBlRHJhZ0JvdW5kcyA9IG9wdGlvbnMuc2hhcGVEcmFnQm91bmRzLmNvcHkoKTtcclxuICAgIHNoYXBlRHJhZ0JvdW5kcy5zZXRNYXhYKCBzaGFwZURyYWdCb3VuZHMubWF4WCAtIHNoYXBlLmJvdW5kcy53aWR0aCApO1xyXG4gICAgc2hhcGVEcmFnQm91bmRzLnNldE1heFkoIHNoYXBlRHJhZ0JvdW5kcy5tYXhZIC0gc2hhcGUuYm91bmRzLmhlaWdodCApO1xyXG5cclxuICAgIC8vIEVuY2xvc2UgdGhlIGRyYWcgYm91bmRzIGluIGEgUHJvcGVydHkgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiB0aGUgZHJhZyBoYW5kbGVyLlxyXG4gICAgY29uc3QgZHJhZ0JvdW5kc1Byb3BlcnR5ID0gbmV3IFByb3BlcnR5KCBzaGFwZURyYWdCb3VuZHMgKTtcclxuXHJcbiAgICAvLyBBZGQgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBhbGxvdyB0aGUgdXNlciB0byBjbGljayBvbiB0aGlzIGFuZCBjcmVhdGUgYSBuZXcgc2hhcGUsIHRoZW4gcG9zaXRpb24gaXQgaW4gdGhlIG1vZGVsLlxyXG4gICAgY29uc3QgZHJhZ0xpc3RlbmVyID0gbmV3IERyYWdMaXN0ZW5lcigge1xyXG5cclxuICAgICAgZHJhZ0JvdW5kc1Byb3BlcnR5OiBkcmFnQm91bmRzUHJvcGVydHksXHJcbiAgICAgIHRhcmdldE5vZGU6IG9wdGlvbnMubm9uTW92aW5nQW5jZXN0b3IsXHJcblxyXG4gICAgICAvLyBBbGxvdyBtb3ZpbmcgYSBmaW5nZXIgKHRvdWNoKSBhY3Jvc3MgdGhpcyBub2RlIHRvIGludGVyYWN0IHdpdGggaXRcclxuICAgICAgYWxsb3dUb3VjaFNuYWc6IHRydWUsXHJcblxyXG4gICAgICBzdGFydDogZXZlbnQgPT4ge1xyXG4gICAgICAgIGlmICggIXBhcmVudFNjcmVlblZpZXcgKSB7XHJcblxyXG4gICAgICAgICAgLy8gRmluZCB0aGUgcGFyZW50IHNjcmVlbiB2aWV3IGJ5IG1vdmluZyB1cCB0aGUgc2NlbmUgZ3JhcGguXHJcbiAgICAgICAgICBsZXQgdGVzdE5vZGUgPSB0aGlzLnBhcmVudHNbIDAgXTtcclxuICAgICAgICAgIHdoaWxlICggdGVzdE5vZGUgIT09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIGlmICggdGVzdE5vZGUgaW5zdGFuY2VvZiBTY3JlZW5WaWV3ICkge1xyXG4gICAgICAgICAgICAgIHBhcmVudFNjcmVlblZpZXcgPSB0ZXN0Tm9kZTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZXN0Tm9kZSA9IHRlc3ROb2RlLnBhcmVudHNbIDAgXTsgLy8gbW92ZSB1cCB0aGUgc2NlbmUgZ3JhcGggYnkgb25lIGxldmVsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBwYXJlbnRTY3JlZW5WaWV3LCAndW5hYmxlIHRvIGZpbmQgcGFyZW50IHNjcmVlbiB2aWV3JyApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBuZXcgZWxlbWVudCBhcyBhIGZ1bmN0aW9uIG9mIHRoZSBldmVudCBwb3NpdGlvbiBhbmQgdGhpcyBub2RlJ3MgYm91bmRzLlxyXG4gICAgICAgIGNvbnN0IHVwcGVyTGVmdENvcm5lckdsb2JhbCA9IHRoaXMucGFyZW50VG9HbG9iYWxQb2ludCggdGhpcy5sZWZ0VG9wICk7XHJcbiAgICAgICAgZHJhZ09mZnNldCA9IHVwcGVyTGVmdENvcm5lckdsb2JhbC5taW51cyggZXZlbnQucG9pbnRlci5wb2ludCApO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxQb3NpdGlvbiA9IHBhcmVudFNjcmVlblZpZXcuZ2xvYmFsVG9Mb2NhbFBvaW50KCBldmVudC5wb2ludGVyLnBvaW50LnBsdXMoIGRyYWdPZmZzZXQgKSApO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCB0aGUgbmV3IG1vZGVsIGVsZW1lbnQuXHJcbiAgICAgICAgbW92YWJsZVNoYXBlID0gbmV3IE1vdmFibGVTaGFwZSggc2hhcGUsIGNvbG9yLCBpbml0aWFsUG9zaXRpb24gKTtcclxuICAgICAgICBtb3ZhYmxlU2hhcGUudXNlckNvbnRyb2xsZWRQcm9wZXJ0eS5zZXQoIHRydWUgKTtcclxuICAgICAgICBhZGRTaGFwZVRvTW9kZWwoIG1vdmFibGVTaGFwZSApO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgY3JlYXRpb24gY291bnQgaXMgbGltaXRlZCwgYWRqdXN0IHRoZSB2YWx1ZSBhbmQgbW9uaXRvciB0aGUgY3JlYXRlZCBzaGFwZSBmb3IgaWYvd2hlbiBpdCBpcyByZXR1cm5lZC5cclxuICAgICAgICBpZiAoIG9wdGlvbnMuY3JlYXRpb25MaW1pdCA8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSApIHtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgYW4gSUlGRSB0byBrZWVwIGEgcmVmZXJlbmNlIG9mIHRoZSBtb3ZhYmxlIHNoYXBlIGluIGEgY2xvc3VyZS5cclxuICAgICAgICAgICggKCkgPT4ge1xyXG4gICAgICAgICAgICBjcmVhdGVkQ291bnRQcm9wZXJ0eS52YWx1ZSsrO1xyXG4gICAgICAgICAgICBjb25zdCBsb2NhbFJlZlRvTW92YWJsZVNoYXBlID0gbW92YWJsZVNoYXBlO1xyXG4gICAgICAgICAgICBsb2NhbFJlZlRvTW92YWJsZVNoYXBlLnJldHVybmVkVG9PcmlnaW5FbWl0dGVyLmFkZExpc3RlbmVyKCBmdW5jdGlvbiByZXR1cm5lZFRvT3JpZ2luTGlzdGVuZXIoKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCAhbG9jYWxSZWZUb01vdmFibGVTaGFwZS51c2VyQ29udHJvbGxlZFByb3BlcnR5LmdldCgpICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzaGFwZSBoYXMgYmVlbiByZXR1cm5lZCB0byBpdHMgb3JpZ2luLlxyXG4gICAgICAgICAgICAgICAgY3JlYXRlZENvdW50UHJvcGVydHkudmFsdWUtLTtcclxuICAgICAgICAgICAgICAgIGxvY2FsUmVmVG9Nb3ZhYmxlU2hhcGUucmV0dXJuZWRUb09yaWdpbkVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIHJldHVybmVkVG9PcmlnaW5MaXN0ZW5lciApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgfSApKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgZHJhZzogZXZlbnQgPT4ge1xyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIG1vdmFibGVTaGFwZSwgJ25vIG1vdmFibGUgc2hhcGUgZm9yIGRyYWcnICk7XHJcbiAgICAgICAgbW92YWJsZVNoYXBlLnBvc2l0aW9uUHJvcGVydHkuc2V0KCBwYXJlbnRTY3JlZW5WaWV3Lmdsb2JhbFRvTG9jYWxQb2ludCggZXZlbnQucG9pbnRlci5wb2ludC5wbHVzKCBkcmFnT2Zmc2V0ICkgKSApO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgZW5kOiAoKSA9PiB7XHJcbiAgICAgICAgbW92YWJsZVNoYXBlLnVzZXJDb250cm9sbGVkUHJvcGVydHkuc2V0KCBmYWxzZSApO1xyXG4gICAgICAgIG1vdmFibGVTaGFwZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuICAgIHRoaXMuYWRkSW5wdXRMaXN0ZW5lciggZHJhZ0xpc3RlbmVyICk7XHJcblxyXG4gICAgLy8gUGFzcyBvcHRpb25zIHRocm91Z2ggdG8gcGFyZW50LlxyXG4gICAgdGhpcy5tdXRhdGUoIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy5kaXNwb3NlU2hhcGVDcmVhdG9yTm9kZSA9ICgpID0+IHtcclxuICAgICAgZHJhZ0xpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiByZWxlYXNlIG1lbW9yeSByZWZlcmVuY2VzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLmRpc3Bvc2VTaGFwZUNyZWF0b3JOb2RlKCk7XHJcbiAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG59XHJcblxyXG5hcmVhQnVpbGRlci5yZWdpc3RlciggJ1NoYXBlQ3JlYXRvck5vZGUnLCBTaGFwZUNyZWF0b3JOb2RlICk7XHJcbmV4cG9ydCBkZWZhdWx0IFNoYXBlQ3JlYXRvck5vZGU7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFFBQVEsTUFBTSxpQ0FBaUM7QUFDdEQsT0FBT0MsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxPQUFPQyxVQUFVLE1BQU0sb0NBQW9DO0FBQzNELE9B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