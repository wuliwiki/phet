// Copyright 2014-2023, University of Colorado Boulder

/**
 * A Scenery node that represents a shape that is defined by lists of perimeter points.  The perimeter points are
 * supplied in terms of external and internal perimeters.  This node also allows specification of a unit length that is
 * used to depict a grid on the shape, and can also show dimensions of the shape.
 *
 * @author John Blanco
 */

import Multilink from '../../../../axon/js/Multilink.js';
import Property from '../../../../axon/js/Property.js';
import Utils from '../../../../dot/js/Utils.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import PhetFont from '../../../../scenery-phet/js/PhetFont.js';
import { Node, Path, Text } from '../../../../scenery/js/imports.js';
import areaBuilder from '../../areaBuilder.js';
import Grid from './Grid.js';

// constants
const DIMENSION_LABEL_FONT = new PhetFont({
  size: 14
});
const COMPARISON_TOLERANCE = 1E-6;
class PerimeterShapeNode extends Node {
  /**
   * @param {Property.<PerimeterShape>} perimeterShapeProperty
   * @param {Bounds2} maxBounds
   * @param {number} unitSquareLength
   * @param {boolean} showDimensionsProperty
   * @param {boolean} showGridProperty
   * @param {Object} [options]
   */
  constructor(perimeterShapeProperty, maxBounds, unitSquareLength, showDimensionsProperty, showGridProperty, options) {
    super();
    const perimeterDefinesViableShapeProperty = new Property(false);

    // Set up the shape, edge, and grid, which will be updated as the perimeter changes.  The order in which these
    // are added is important for proper layering.
    const perimeterShapeNode = new Path(null);
    this.addChild(perimeterShapeNode);
    const grid = new Grid(maxBounds, unitSquareLength, {
      lineDash: [0, 3, 1, 0],
      // Tweaked to work well with unit size
      stroke: 'black'
    });
    this.addChild(grid);
    const perimeterNode = new Path(null, {
      lineWidth: 2
    });
    this.addChild(perimeterNode);
    const dimensionsLayer = new Node();
    this.addChild(dimensionsLayer);

    // Create a pool of text nodes that will be used to portray the dimension values.  This is done as a performance
    // optimization, since changing text nodes is more efficient that recreating them on each update.
    const textNodePool = [];
    function addDimensionLabelNode() {
      const textNode = new Text('', {
        font: DIMENSION_LABEL_FONT,
        centerX: maxBounds.centerX,
        centerY: maxBounds.centerY
      });
      textNode.visible = false;
      textNodePool.push(textNode);
      dimensionsLayer.addChild(textNode);
    }
    _.times(16, addDimensionLabelNode); // Initial size empirically chosen, can be adjusted if needed.

    // Define function for updating the appearance of the perimeter shape.
    function update() {
      let i;

      // Update the colors
      assert && assert(perimeterShapeProperty.value.fillColor || perimeterShapeProperty.value.edgeColor, 'PerimeterShape can\'t have null values for both the fill and the edge.');
      perimeterShapeNode.fill = perimeterShapeProperty.value.fillColor;
      perimeterNode.stroke = perimeterShapeProperty.value.edgeColor;

      // Define the shape of the outer perimeter.
      const mainShape = new Shape();
      perimeterShapeProperty.value.exteriorPerimeters.forEach(exteriorPerimeters => {
        mainShape.moveToPoint(exteriorPerimeters[0]);
        for (i = 1; i < exteriorPerimeters.length; i++) {
          mainShape.lineToPoint(exteriorPerimeters[i]);
        }
        mainShape.lineToPoint(exteriorPerimeters[0]);
        mainShape.close();
      });

      // Hide all dimension labels in the pool, they will be shown later if used.
      textNodePool.forEach(textNode => {
        textNode.visible = false;
      });

      // The resulting shape will be empty if there are no points in the external perimeter, so we need to check for that.
      if (!mainShape.bounds.isEmpty()) {
        // Make sure the shape fits within its specified bounds.
        assert && assert(maxBounds.containsBounds(mainShape.bounds));

        // Turn on visibility of the perimeter and the interior fill.
        perimeterShapeNode.visible = true;
        perimeterNode.visible = true;

        // Handling any interior perimeters, a.k.a. holes, in the shape.
        perimeterShapeProperty.value.interiorPerimeters.forEach(interiorPerimeter => {
          mainShape.moveToPoint(interiorPerimeter[0]);
          for (i = 1; i < interiorPerimeter.length; i++) {
            mainShape.lineToPoint(interiorPerimeter[i]);
          }
          mainShape.lineToPoint(interiorPerimeter[0]);
          mainShape.close();
        });
        perimeterShapeNode.setShape(mainShape);
        perimeterNode.setShape(mainShape);
        grid.clipArea = mainShape;

        // Add the dimension labels for the perimeters, but only if there is only 1 exterior perimeter (multiple
        // interior perimeters if fine).
        if (perimeterShapeProperty.value.exteriorPerimeters.length === 1) {
          // Create a list of the perimeters to be labeled.
          const perimetersToLabel = [];
          perimetersToLabel.push(perimeterShapeProperty.value.exteriorPerimeters[0]);
          perimeterShapeProperty.value.interiorPerimeters.forEach(interiorPerimeter => {
            perimetersToLabel.push(interiorPerimeter);
          });

          // Identify the segments in each of the perimeters, exterior and interior, to be labeled.
          const segmentLabelsInfo = [];
          perimetersToLabel.forEach(perimeterToLabel => {
            let segment = {
              startIndex: 0,
              endIndex: 0
            };
            do {
              segment = identifySegment(perimeterToLabel, segment.endIndex);
              // Only put labels on segments that have integer lengths.
              const segmentLabelInfo = {
                unitLength: perimeterToLabel[segment.startIndex].distance(perimeterToLabel[segment.endIndex]) / unitSquareLength,
                position: new Vector2((perimeterToLabel[segment.startIndex].x + perimeterToLabel[segment.endIndex].x) / 2, (perimeterToLabel[segment.startIndex].y + perimeterToLabel[segment.endIndex].y) / 2),
                edgeAngle: Math.atan2(perimeterToLabel[segment.endIndex].y - perimeterToLabel[segment.startIndex].y, perimeterToLabel[segment.endIndex].x - perimeterToLabel[segment.startIndex].x)
              };

              // Only include the labels that are integer values.
              if (Math.abs(Utils.roundSymmetric(segmentLabelInfo.unitLength) - segmentLabelInfo.unitLength) < COMPARISON_TOLERANCE) {
                segmentLabelInfo.unitLength = Utils.roundSymmetric(segmentLabelInfo.unitLength);
                segmentLabelsInfo.push(segmentLabelInfo);
              }
            } while (segment.endIndex !== 0);
          });

          // Make sure that there are enough labels in the pool.
          if (segmentLabelsInfo.length > textNodePool.length) {
            _.times(segmentLabelsInfo.length - textNodePool.length, addDimensionLabelNode);
          }

          // Get labels from the pool and place them on each segment, just outside of the shape.
          segmentLabelsInfo.forEach((segmentLabelInfo, segmentIndex) => {
            const dimensionLabel = textNodePool[segmentIndex];
            dimensionLabel.visible = true;
            dimensionLabel.string = segmentLabelInfo.unitLength;
            const labelPositionOffset = new Vector2(0, 0);
            // TODO: At the time of this writing there is an issue with Shape.containsPoint() that can make
            // containment testing unreliable if there is an edge on the same line as the containment test.  As a
            // workaround, the containment test offset is tweaked a little below.  Once this issue is fixed, the
            // label offset itself can be used for the test.  See https://github.com/phetsims/kite/issues/3.
            let containmentTestOffset;
            if (segmentLabelInfo.edgeAngle === 0 || segmentLabelInfo.edgeAngle === Math.PI) {
              // Label is on horizontal edge, so use height to determine offset.
              labelPositionOffset.setXY(0, dimensionLabel.height / 2);
              containmentTestOffset = labelPositionOffset.plusXY(1, 0);
            } else {
              // NOTE: Angled edges are not currently supported.
              // Label is on a vertical edge
              labelPositionOffset.setXY(dimensionLabel.width * 0.8, 0);
              containmentTestOffset = labelPositionOffset.plusXY(0, 1);
            }
            if (mainShape.containsPoint(segmentLabelInfo.position.plus(containmentTestOffset))) {
              // Flip the offset vector to keep the label outside of the shape.
              labelPositionOffset.rotate(Math.PI);
            }
            dimensionLabel.center = segmentLabelInfo.position.plus(labelPositionOffset);
          });
        }
        perimeterDefinesViableShapeProperty.value = true;
      } else {
        perimeterShapeNode.visible = false;
        perimeterNode.visible = false;
        perimeterDefinesViableShapeProperty.value = false;
      }
    }

    // Control visibility of the dimension indicators.
    showDimensionsProperty.linkAttribute(dimensionsLayer, 'visible');

    // Control visibility of the grid.
    Multilink.multilink([showGridProperty, perimeterDefinesViableShapeProperty], (showGrid, perimeterDefinesViableShape) => {
      grid.visible = showGrid && perimeterDefinesViableShape;
    });

    // Update the shape, grid, and dimensions if the perimeter shape itself changes.
    perimeterShapeProperty.link(() => {
      update();
    });

    // Pass options through to parent class.
    this.mutate(options);
  }
}

// Utility function for identifying a perimeter segment with no bends.
function identifySegment(perimeterPoints, startIndex) {
  // Parameter checking.
  if (startIndex >= perimeterPoints.length) {
    throw new Error('Illegal use of function for identifying perimeter segments.');
  }

  // Set up initial portion of segment.
  const segmentStartPoint = perimeterPoints[startIndex];
  let endIndex = (startIndex + 1) % perimeterPoints.length;
  let segmentEndPoint = perimeterPoints[endIndex];
  const previousAngle = Math.atan2(segmentEndPoint.y - segmentStartPoint.y, segmentEndPoint.x - segmentStartPoint.x);
  let segmentComplete = false;
  while (!segmentComplete && endIndex !== 0) {
    const candidatePoint = perimeterPoints[(endIndex + 1) % perimeterPoints.length];
    const angleToCandidatePoint = Math.atan2(candidatePoint.y - segmentEndPoint.y, candidatePoint.x - segmentEndPoint.x);
    if (previousAngle === angleToCandidatePoint) {
      // This point is an extension of the current segment.
      segmentEndPoint = candidatePoint;
      endIndex = (endIndex + 1) % perimeterPoints.length;
    } else {
      // This point isn't part of this segment.
      segmentComplete = true;
    }
  }
  return {
    startIndex: startIndex,
    endIndex: endIndex
  };
}
areaBuilder.register('PerimeterShapeNode', PerimeterShapeNode);
export default PerimeterShapeNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNdWx0aWxpbmsiLCJQcm9wZXJ0eSIsIlV0aWxzIiwiVmVjdG9yMiIsIlNoYXBlIiwiUGhldEZvbnQiLCJOb2RlIiwiUGF0aCIsIlRleHQiLCJhcmVhQnVpbGRlciIsIkdyaWQiLCJESU1FTlNJT05fTEFCRUxfRk9OVCIsInNpemUiLCJDT01QQVJJU09OX1RPTEVSQU5DRSIsIlBlcmltZXRlclNoYXBlTm9kZSIsImNvbnN0cnVjdG9yIiwicGVyaW1ldGVyU2hhcGVQcm9wZXJ0eSIsIm1heEJvdW5kcyIsInVuaXRTcXVhcmVMZW5ndGgiLCJzaG93RGltZW5zaW9uc1Byb3BlcnR5Iiwic2hvd0dyaWRQcm9wZXJ0eSIsIm9wdGlvbnMiLCJwZXJpbWV0ZXJEZWZpbmVzVmlhYmxlU2hhcGVQcm9wZXJ0eSIsInBlcmltZXRlclNoYXBlTm9kZSIsImFkZENoaWxkIiwiZ3JpZCIsImxpbmVEYXNoIiwic3Ryb2tlIiwicGVyaW1ldGVyTm9kZSIsImxpbmVXaWR0aCIsImRpbWVuc2lvbnNMYXllciIsInRleHROb2RlUG9vbCIsImFkZERpbWVuc2lvbkxhYmVsTm9kZSIsInRleHROb2RlIiwiZm9udCIsImNlbnRlclgiLCJjZW50ZXJZIiwidmlzaWJsZSIsInB1c2giLCJfIiwidGltZXMiLCJ1cGRhdGUiLCJpIiwiYXNzZXJ0IiwidmFsdWUiLCJmaWxsQ29sb3IiLCJlZGdlQ29sb3IiLCJmaWxsIiwibWFpblNoYXBlIiwiZXh0ZXJpb3JQZXJpbWV0ZXJzIiwiZm9yRWFjaCIsIm1vdmVUb1BvaW50IiwibGVuZ3RoIiwibGluZVRvUG9pbnQiLCJjbG9zZSIsImJvdW5kcyIsImlzRW1wdHkiLCJjb250YWluc0JvdW5kcyIsImludGVyaW9yUGVyaW1ldGVycyIsImludGVyaW9yUGVyaW1ldGVyIiwic2V0U2hhcGUiLCJjbGlwQXJlYSIsInBlcmltZXRlcnNUb0xhYmVsIiwic2VnbWVudExhYmVsc0luZm8iLCJwZXJpbWV0ZXJUb0xhYmVsIiwic2VnbWVudCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsImlkZW50aWZ5U2VnbWVudCIsInNlZ21lbnRMYWJlbEluZm8iLCJ1bml0TGVuZ3RoIiwiZGlzdGFuY2UiLCJwb3NpdGlvbiIsIngiLCJ5IiwiZWRnZUFuZ2xlIiwiTWF0aCIsImF0YW4yIiwiYWJzIiwicm91bmRTeW1tZXRyaWMiLCJzZWdtZW50SW5kZXgiLCJkaW1lbnNpb25MYWJlbCIsInN0cmluZyIsImxhYmVsUG9zaXRpb25PZmZzZXQiLCJjb250YWlubWVudFRlc3RPZmZzZXQiLCJQSSIsInNldFhZIiwiaGVpZ2h0IiwicGx1c1hZIiwid2lkdGgiLCJjb250YWluc1BvaW50IiwicGx1cyIsInJvdGF0ZSIsImNlbnRlciIsImxpbmtBdHRyaWJ1dGUiLCJtdWx0aWxpbmsiLCJzaG93R3JpZCIsInBlcmltZXRlckRlZmluZXNWaWFibGVTaGFwZSIsImxpbmsiLCJtdXRhdGUiLCJwZXJpbWV0ZXJQb2ludHMiLCJFcnJvciIsInNlZ21lbnRTdGFydFBvaW50Iiwic2VnbWVudEVuZFBvaW50IiwicHJldmlvdXNBbmdsZSIsInNlZ21lbnRDb21wbGV0ZSIsImNhbmRpZGF0ZVBvaW50IiwiYW5nbGVUb0NhbmRpZGF0ZVBvaW50IiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJQZXJpbWV0ZXJTaGFwZU5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTQtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogQSBTY2VuZXJ5IG5vZGUgdGhhdCByZXByZXNlbnRzIGEgc2hhcGUgdGhhdCBpcyBkZWZpbmVkIGJ5IGxpc3RzIG9mIHBlcmltZXRlciBwb2ludHMuICBUaGUgcGVyaW1ldGVyIHBvaW50cyBhcmVcclxuICogc3VwcGxpZWQgaW4gdGVybXMgb2YgZXh0ZXJuYWwgYW5kIGludGVybmFsIHBlcmltZXRlcnMuICBUaGlzIG5vZGUgYWxzbyBhbGxvd3Mgc3BlY2lmaWNhdGlvbiBvZiBhIHVuaXQgbGVuZ3RoIHRoYXQgaXNcclxuICogdXNlZCB0byBkZXBpY3QgYSBncmlkIG9uIHRoZSBzaGFwZSwgYW5kIGNhbiBhbHNvIHNob3cgZGltZW5zaW9ucyBvZiB0aGUgc2hhcGUuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9obiBCbGFuY29cclxuICovXHJcblxyXG5pbXBvcnQgTXVsdGlsaW5rIGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvTXVsdGlsaW5rLmpzJztcclxuaW1wb3J0IFByb3BlcnR5IGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1V0aWxzLmpzJztcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vZG90L2pzL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2tpdGUvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBQaGV0Rm9udCBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZXJ5LXBoZXQvanMvUGhldEZvbnQuanMnO1xyXG5pbXBvcnQgeyBOb2RlLCBQYXRoLCBUZXh0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IGFyZWFCdWlsZGVyIGZyb20gJy4uLy4uL2FyZWFCdWlsZGVyLmpzJztcclxuaW1wb3J0IEdyaWQgZnJvbSAnLi9HcmlkLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBESU1FTlNJT05fTEFCRUxfRk9OVCA9IG5ldyBQaGV0Rm9udCggeyBzaXplOiAxNCB9ICk7XHJcbmNvbnN0IENPTVBBUklTT05fVE9MRVJBTkNFID0gMUUtNjtcclxuXHJcbmNsYXNzIFBlcmltZXRlclNoYXBlTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5LjxQZXJpbWV0ZXJTaGFwZT59IHBlcmltZXRlclNoYXBlUHJvcGVydHlcclxuICAgKiBAcGFyYW0ge0JvdW5kczJ9IG1heEJvdW5kc1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB1bml0U3F1YXJlTGVuZ3RoXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBzaG93RGltZW5zaW9uc1Byb3BlcnR5XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBzaG93R3JpZFByb3BlcnR5XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBwZXJpbWV0ZXJTaGFwZVByb3BlcnR5LCBtYXhCb3VuZHMsIHVuaXRTcXVhcmVMZW5ndGgsIHNob3dEaW1lbnNpb25zUHJvcGVydHksIHNob3dHcmlkUHJvcGVydHksIG9wdGlvbnMgKSB7XHJcblxyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBjb25zdCBwZXJpbWV0ZXJEZWZpbmVzVmlhYmxlU2hhcGVQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eSggZmFsc2UgKTtcclxuXHJcbiAgICAvLyBTZXQgdXAgdGhlIHNoYXBlLCBlZGdlLCBhbmQgZ3JpZCwgd2hpY2ggd2lsbCBiZSB1cGRhdGVkIGFzIHRoZSBwZXJpbWV0ZXIgY2hhbmdlcy4gIFRoZSBvcmRlciBpbiB3aGljaCB0aGVzZVxyXG4gICAgLy8gYXJlIGFkZGVkIGlzIGltcG9ydGFudCBmb3IgcHJvcGVyIGxheWVyaW5nLlxyXG4gICAgY29uc3QgcGVyaW1ldGVyU2hhcGVOb2RlID0gbmV3IFBhdGgoIG51bGwgKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIHBlcmltZXRlclNoYXBlTm9kZSApO1xyXG4gICAgY29uc3QgZ3JpZCA9IG5ldyBHcmlkKCBtYXhCb3VuZHMsIHVuaXRTcXVhcmVMZW5ndGgsIHtcclxuICAgICAgbGluZURhc2g6IFsgMCwgMywgMSwgMCBdLCAvLyBUd2Vha2VkIHRvIHdvcmsgd2VsbCB3aXRoIHVuaXQgc2l6ZVxyXG4gICAgICBzdHJva2U6ICdibGFjaydcclxuICAgIH0gKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIGdyaWQgKTtcclxuICAgIGNvbnN0IHBlcmltZXRlck5vZGUgPSBuZXcgUGF0aCggbnVsbCwgeyBsaW5lV2lkdGg6IDIgfSApO1xyXG4gICAgdGhpcy5hZGRDaGlsZCggcGVyaW1ldGVyTm9kZSApO1xyXG4gICAgY29uc3QgZGltZW5zaW9uc0xheWVyID0gbmV3IE5vZGUoKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIGRpbWVuc2lvbnNMYXllciApO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIHBvb2wgb2YgdGV4dCBub2RlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBwb3J0cmF5IHRoZSBkaW1lbnNpb24gdmFsdWVzLiAgVGhpcyBpcyBkb25lIGFzIGEgcGVyZm9ybWFuY2VcclxuICAgIC8vIG9wdGltaXphdGlvbiwgc2luY2UgY2hhbmdpbmcgdGV4dCBub2RlcyBpcyBtb3JlIGVmZmljaWVudCB0aGF0IHJlY3JlYXRpbmcgdGhlbSBvbiBlYWNoIHVwZGF0ZS5cclxuICAgIGNvbnN0IHRleHROb2RlUG9vbCA9IFtdO1xyXG5cclxuICAgIGZ1bmN0aW9uIGFkZERpbWVuc2lvbkxhYmVsTm9kZSgpIHtcclxuICAgICAgY29uc3QgdGV4dE5vZGUgPSBuZXcgVGV4dCggJycsIHtcclxuICAgICAgICBmb250OiBESU1FTlNJT05fTEFCRUxfRk9OVCxcclxuICAgICAgICBjZW50ZXJYOiBtYXhCb3VuZHMuY2VudGVyWCxcclxuICAgICAgICBjZW50ZXJZOiBtYXhCb3VuZHMuY2VudGVyWVxyXG4gICAgICB9ICk7XHJcbiAgICAgIHRleHROb2RlLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgdGV4dE5vZGVQb29sLnB1c2goIHRleHROb2RlICk7XHJcbiAgICAgIGRpbWVuc2lvbnNMYXllci5hZGRDaGlsZCggdGV4dE5vZGUgKTtcclxuICAgIH1cclxuXHJcbiAgICBfLnRpbWVzKCAxNiwgYWRkRGltZW5zaW9uTGFiZWxOb2RlICk7IC8vIEluaXRpYWwgc2l6ZSBlbXBpcmljYWxseSBjaG9zZW4sIGNhbiBiZSBhZGp1c3RlZCBpZiBuZWVkZWQuXHJcblxyXG4gICAgLy8gRGVmaW5lIGZ1bmN0aW9uIGZvciB1cGRhdGluZyB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcGVyaW1ldGVyIHNoYXBlLlxyXG4gICAgZnVuY3Rpb24gdXBkYXRlKCkge1xyXG4gICAgICBsZXQgaTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgY29sb3JzXHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHBlcmltZXRlclNoYXBlUHJvcGVydHkudmFsdWUuZmlsbENvbG9yIHx8IHBlcmltZXRlclNoYXBlUHJvcGVydHkudmFsdWUuZWRnZUNvbG9yLFxyXG4gICAgICAgICdQZXJpbWV0ZXJTaGFwZSBjYW5cXCd0IGhhdmUgbnVsbCB2YWx1ZXMgZm9yIGJvdGggdGhlIGZpbGwgYW5kIHRoZSBlZGdlLicgKTtcclxuICAgICAgcGVyaW1ldGVyU2hhcGVOb2RlLmZpbGwgPSBwZXJpbWV0ZXJTaGFwZVByb3BlcnR5LnZhbHVlLmZpbGxDb2xvcjtcclxuICAgICAgcGVyaW1ldGVyTm9kZS5zdHJva2UgPSBwZXJpbWV0ZXJTaGFwZVByb3BlcnR5LnZhbHVlLmVkZ2VDb2xvcjtcclxuXHJcbiAgICAgIC8vIERlZmluZSB0aGUgc2hhcGUgb2YgdGhlIG91dGVyIHBlcmltZXRlci5cclxuICAgICAgY29uc3QgbWFpblNoYXBlID0gbmV3IFNoYXBlKCk7XHJcbiAgICAgIHBlcmltZXRlclNoYXBlUHJvcGVydHkudmFsdWUuZXh0ZXJpb3JQZXJpbWV0ZXJzLmZvckVhY2goIGV4dGVyaW9yUGVyaW1ldGVycyA9PiB7XHJcbiAgICAgICAgbWFpblNoYXBlLm1vdmVUb1BvaW50KCBleHRlcmlvclBlcmltZXRlcnNbIDAgXSApO1xyXG4gICAgICAgIGZvciAoIGkgPSAxOyBpIDwgZXh0ZXJpb3JQZXJpbWV0ZXJzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgbWFpblNoYXBlLmxpbmVUb1BvaW50KCBleHRlcmlvclBlcmltZXRlcnNbIGkgXSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYWluU2hhcGUubGluZVRvUG9pbnQoIGV4dGVyaW9yUGVyaW1ldGVyc1sgMCBdICk7XHJcbiAgICAgICAgbWFpblNoYXBlLmNsb3NlKCk7XHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICAgIC8vIEhpZGUgYWxsIGRpbWVuc2lvbiBsYWJlbHMgaW4gdGhlIHBvb2wsIHRoZXkgd2lsbCBiZSBzaG93biBsYXRlciBpZiB1c2VkLlxyXG4gICAgICB0ZXh0Tm9kZVBvb2wuZm9yRWFjaCggdGV4dE5vZGUgPT4geyB0ZXh0Tm9kZS52aXNpYmxlID0gZmFsc2U7IH0gKTtcclxuXHJcbiAgICAgIC8vIFRoZSByZXN1bHRpbmcgc2hhcGUgd2lsbCBiZSBlbXB0eSBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGluIHRoZSBleHRlcm5hbCBwZXJpbWV0ZXIsIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHRoYXQuXHJcbiAgICAgIGlmICggIW1haW5TaGFwZS5ib3VuZHMuaXNFbXB0eSgpICkge1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHNoYXBlIGZpdHMgd2l0aGluIGl0cyBzcGVjaWZpZWQgYm91bmRzLlxyXG4gICAgICAgIGFzc2VydCAmJiBhc3NlcnQoIG1heEJvdW5kcy5jb250YWluc0JvdW5kcyggbWFpblNoYXBlLmJvdW5kcyApICk7XHJcblxyXG4gICAgICAgIC8vIFR1cm4gb24gdmlzaWJpbGl0eSBvZiB0aGUgcGVyaW1ldGVyIGFuZCB0aGUgaW50ZXJpb3IgZmlsbC5cclxuICAgICAgICBwZXJpbWV0ZXJTaGFwZU5vZGUudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgcGVyaW1ldGVyTm9kZS52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxpbmcgYW55IGludGVyaW9yIHBlcmltZXRlcnMsIGEuay5hLiBob2xlcywgaW4gdGhlIHNoYXBlLlxyXG4gICAgICAgIHBlcmltZXRlclNoYXBlUHJvcGVydHkudmFsdWUuaW50ZXJpb3JQZXJpbWV0ZXJzLmZvckVhY2goIGludGVyaW9yUGVyaW1ldGVyID0+IHtcclxuICAgICAgICAgIG1haW5TaGFwZS5tb3ZlVG9Qb2ludCggaW50ZXJpb3JQZXJpbWV0ZXJbIDAgXSApO1xyXG4gICAgICAgICAgZm9yICggaSA9IDE7IGkgPCBpbnRlcmlvclBlcmltZXRlci5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgbWFpblNoYXBlLmxpbmVUb1BvaW50KCBpbnRlcmlvclBlcmltZXRlclsgaSBdICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBtYWluU2hhcGUubGluZVRvUG9pbnQoIGludGVyaW9yUGVyaW1ldGVyWyAwIF0gKTtcclxuICAgICAgICAgIG1haW5TaGFwZS5jbG9zZSgpO1xyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgcGVyaW1ldGVyU2hhcGVOb2RlLnNldFNoYXBlKCBtYWluU2hhcGUgKTtcclxuICAgICAgICBwZXJpbWV0ZXJOb2RlLnNldFNoYXBlKCBtYWluU2hhcGUgKTtcclxuXHJcbiAgICAgICAgZ3JpZC5jbGlwQXJlYSA9IG1haW5TaGFwZTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBkaW1lbnNpb24gbGFiZWxzIGZvciB0aGUgcGVyaW1ldGVycywgYnV0IG9ubHkgaWYgdGhlcmUgaXMgb25seSAxIGV4dGVyaW9yIHBlcmltZXRlciAobXVsdGlwbGVcclxuICAgICAgICAvLyBpbnRlcmlvciBwZXJpbWV0ZXJzIGlmIGZpbmUpLlxyXG4gICAgICAgIGlmICggcGVyaW1ldGVyU2hhcGVQcm9wZXJ0eS52YWx1ZS5leHRlcmlvclBlcmltZXRlcnMubGVuZ3RoID09PSAxICkge1xyXG5cclxuICAgICAgICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgdGhlIHBlcmltZXRlcnMgdG8gYmUgbGFiZWxlZC5cclxuICAgICAgICAgIGNvbnN0IHBlcmltZXRlcnNUb0xhYmVsID0gW107XHJcbiAgICAgICAgICBwZXJpbWV0ZXJzVG9MYWJlbC5wdXNoKCBwZXJpbWV0ZXJTaGFwZVByb3BlcnR5LnZhbHVlLmV4dGVyaW9yUGVyaW1ldGVyc1sgMCBdICk7XHJcbiAgICAgICAgICBwZXJpbWV0ZXJTaGFwZVByb3BlcnR5LnZhbHVlLmludGVyaW9yUGVyaW1ldGVycy5mb3JFYWNoKCBpbnRlcmlvclBlcmltZXRlciA9PiB7XHJcbiAgICAgICAgICAgIHBlcmltZXRlcnNUb0xhYmVsLnB1c2goIGludGVyaW9yUGVyaW1ldGVyICk7XHJcbiAgICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgICAgLy8gSWRlbnRpZnkgdGhlIHNlZ21lbnRzIGluIGVhY2ggb2YgdGhlIHBlcmltZXRlcnMsIGV4dGVyaW9yIGFuZCBpbnRlcmlvciwgdG8gYmUgbGFiZWxlZC5cclxuICAgICAgICAgIGNvbnN0IHNlZ21lbnRMYWJlbHNJbmZvID0gW107XHJcbiAgICAgICAgICBwZXJpbWV0ZXJzVG9MYWJlbC5mb3JFYWNoKCBwZXJpbWV0ZXJUb0xhYmVsID0+IHtcclxuICAgICAgICAgICAgbGV0IHNlZ21lbnQgPSB7IHN0YXJ0SW5kZXg6IDAsIGVuZEluZGV4OiAwIH07XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICBzZWdtZW50ID0gaWRlbnRpZnlTZWdtZW50KCBwZXJpbWV0ZXJUb0xhYmVsLCBzZWdtZW50LmVuZEluZGV4ICk7XHJcbiAgICAgICAgICAgICAgLy8gT25seSBwdXQgbGFiZWxzIG9uIHNlZ21lbnRzIHRoYXQgaGF2ZSBpbnRlZ2VyIGxlbmd0aHMuXHJcbiAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudExhYmVsSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIHVuaXRMZW5ndGg6IHBlcmltZXRlclRvTGFiZWxbIHNlZ21lbnQuc3RhcnRJbmRleCBdLmRpc3RhbmNlKCBwZXJpbWV0ZXJUb0xhYmVsWyBzZWdtZW50LmVuZEluZGV4IF0gKSAvIHVuaXRTcXVhcmVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogbmV3IFZlY3RvcjIoICggcGVyaW1ldGVyVG9MYWJlbFsgc2VnbWVudC5zdGFydEluZGV4IF0ueCArIHBlcmltZXRlclRvTGFiZWxbIHNlZ21lbnQuZW5kSW5kZXggXS54ICkgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAoIHBlcmltZXRlclRvTGFiZWxbIHNlZ21lbnQuc3RhcnRJbmRleCBdLnkgKyBwZXJpbWV0ZXJUb0xhYmVsWyBzZWdtZW50LmVuZEluZGV4IF0ueSApIC8gMiApLFxyXG4gICAgICAgICAgICAgICAgZWRnZUFuZ2xlOiBNYXRoLmF0YW4yKCBwZXJpbWV0ZXJUb0xhYmVsWyBzZWdtZW50LmVuZEluZGV4IF0ueSAtIHBlcmltZXRlclRvTGFiZWxbIHNlZ21lbnQuc3RhcnRJbmRleCBdLnksXHJcbiAgICAgICAgICAgICAgICAgIHBlcmltZXRlclRvTGFiZWxbIHNlZ21lbnQuZW5kSW5kZXggXS54IC0gcGVyaW1ldGVyVG9MYWJlbFsgc2VnbWVudC5zdGFydEluZGV4IF0ueFxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgIC8vIE9ubHkgaW5jbHVkZSB0aGUgbGFiZWxzIHRoYXQgYXJlIGludGVnZXIgdmFsdWVzLlxyXG4gICAgICAgICAgICAgIGlmICggTWF0aC5hYnMoIFV0aWxzLnJvdW5kU3ltbWV0cmljKCBzZWdtZW50TGFiZWxJbmZvLnVuaXRMZW5ndGggKSAtIHNlZ21lbnRMYWJlbEluZm8udW5pdExlbmd0aCApIDwgQ09NUEFSSVNPTl9UT0xFUkFOQ0UgKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50TGFiZWxJbmZvLnVuaXRMZW5ndGggPSBVdGlscy5yb3VuZFN5bW1ldHJpYyggc2VnbWVudExhYmVsSW5mby51bml0TGVuZ3RoICk7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50TGFiZWxzSW5mby5wdXNoKCBzZWdtZW50TGFiZWxJbmZvICk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlICggc2VnbWVudC5lbmRJbmRleCAhPT0gMCApO1xyXG4gICAgICAgICAgfSApO1xyXG5cclxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZXJlIGFyZSBlbm91Z2ggbGFiZWxzIGluIHRoZSBwb29sLlxyXG4gICAgICAgICAgaWYgKCBzZWdtZW50TGFiZWxzSW5mby5sZW5ndGggPiB0ZXh0Tm9kZVBvb2wubGVuZ3RoICkge1xyXG4gICAgICAgICAgICBfLnRpbWVzKCBzZWdtZW50TGFiZWxzSW5mby5sZW5ndGggLSB0ZXh0Tm9kZVBvb2wubGVuZ3RoLCBhZGREaW1lbnNpb25MYWJlbE5vZGUgKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBHZXQgbGFiZWxzIGZyb20gdGhlIHBvb2wgYW5kIHBsYWNlIHRoZW0gb24gZWFjaCBzZWdtZW50LCBqdXN0IG91dHNpZGUgb2YgdGhlIHNoYXBlLlxyXG4gICAgICAgICAgc2VnbWVudExhYmVsc0luZm8uZm9yRWFjaCggKCBzZWdtZW50TGFiZWxJbmZvLCBzZWdtZW50SW5kZXggKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbkxhYmVsID0gdGV4dE5vZGVQb29sWyBzZWdtZW50SW5kZXggXTtcclxuICAgICAgICAgICAgZGltZW5zaW9uTGFiZWwudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGRpbWVuc2lvbkxhYmVsLnN0cmluZyA9IHNlZ21lbnRMYWJlbEluZm8udW5pdExlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxQb3NpdGlvbk9mZnNldCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IEF0IHRoZSB0aW1lIG9mIHRoaXMgd3JpdGluZyB0aGVyZSBpcyBhbiBpc3N1ZSB3aXRoIFNoYXBlLmNvbnRhaW5zUG9pbnQoKSB0aGF0IGNhbiBtYWtlXHJcbiAgICAgICAgICAgIC8vIGNvbnRhaW5tZW50IHRlc3RpbmcgdW5yZWxpYWJsZSBpZiB0aGVyZSBpcyBhbiBlZGdlIG9uIHRoZSBzYW1lIGxpbmUgYXMgdGhlIGNvbnRhaW5tZW50IHRlc3QuICBBcyBhXHJcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQsIHRoZSBjb250YWlubWVudCB0ZXN0IG9mZnNldCBpcyB0d2Vha2VkIGEgbGl0dGxlIGJlbG93LiAgT25jZSB0aGlzIGlzc3VlIGlzIGZpeGVkLCB0aGVcclxuICAgICAgICAgICAgLy8gbGFiZWwgb2Zmc2V0IGl0c2VsZiBjYW4gYmUgdXNlZCBmb3IgdGhlIHRlc3QuICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2tpdGUvaXNzdWVzLzMuXHJcbiAgICAgICAgICAgIGxldCBjb250YWlubWVudFRlc3RPZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmICggc2VnbWVudExhYmVsSW5mby5lZGdlQW5nbGUgPT09IDAgfHwgc2VnbWVudExhYmVsSW5mby5lZGdlQW5nbGUgPT09IE1hdGguUEkgKSB7XHJcbiAgICAgICAgICAgICAgLy8gTGFiZWwgaXMgb24gaG9yaXpvbnRhbCBlZGdlLCBzbyB1c2UgaGVpZ2h0IHRvIGRldGVybWluZSBvZmZzZXQuXHJcbiAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbk9mZnNldC5zZXRYWSggMCwgZGltZW5zaW9uTGFiZWwuaGVpZ2h0IC8gMiApO1xyXG4gICAgICAgICAgICAgIGNvbnRhaW5tZW50VGVzdE9mZnNldCA9IGxhYmVsUG9zaXRpb25PZmZzZXQucGx1c1hZKCAxLCAwICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7IC8vIE5PVEU6IEFuZ2xlZCBlZGdlcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgICAgLy8gTGFiZWwgaXMgb24gYSB2ZXJ0aWNhbCBlZGdlXHJcbiAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbk9mZnNldC5zZXRYWSggZGltZW5zaW9uTGFiZWwud2lkdGggKiAwLjgsIDAgKTtcclxuICAgICAgICAgICAgICBjb250YWlubWVudFRlc3RPZmZzZXQgPSBsYWJlbFBvc2l0aW9uT2Zmc2V0LnBsdXNYWSggMCwgMSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggbWFpblNoYXBlLmNvbnRhaW5zUG9pbnQoIHNlZ21lbnRMYWJlbEluZm8ucG9zaXRpb24ucGx1cyggY29udGFpbm1lbnRUZXN0T2Zmc2V0ICkgKSApIHtcclxuICAgICAgICAgICAgICAvLyBGbGlwIHRoZSBvZmZzZXQgdmVjdG9yIHRvIGtlZXAgdGhlIGxhYmVsIG91dHNpZGUgb2YgdGhlIHNoYXBlLlxyXG4gICAgICAgICAgICAgIGxhYmVsUG9zaXRpb25PZmZzZXQucm90YXRlKCBNYXRoLlBJICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGltZW5zaW9uTGFiZWwuY2VudGVyID0gc2VnbWVudExhYmVsSW5mby5wb3NpdGlvbi5wbHVzKCBsYWJlbFBvc2l0aW9uT2Zmc2V0ICk7XHJcbiAgICAgICAgICB9ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBlcmltZXRlckRlZmluZXNWaWFibGVTaGFwZVByb3BlcnR5LnZhbHVlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBwZXJpbWV0ZXJTaGFwZU5vZGUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHBlcmltZXRlck5vZGUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHBlcmltZXRlckRlZmluZXNWaWFibGVTaGFwZVByb3BlcnR5LnZhbHVlID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb250cm9sIHZpc2liaWxpdHkgb2YgdGhlIGRpbWVuc2lvbiBpbmRpY2F0b3JzLlxyXG4gICAgc2hvd0RpbWVuc2lvbnNQcm9wZXJ0eS5saW5rQXR0cmlidXRlKCBkaW1lbnNpb25zTGF5ZXIsICd2aXNpYmxlJyApO1xyXG5cclxuICAgIC8vIENvbnRyb2wgdmlzaWJpbGl0eSBvZiB0aGUgZ3JpZC5cclxuICAgIE11bHRpbGluay5tdWx0aWxpbmsoIFsgc2hvd0dyaWRQcm9wZXJ0eSwgcGVyaW1ldGVyRGVmaW5lc1ZpYWJsZVNoYXBlUHJvcGVydHkgXSwgKCBzaG93R3JpZCwgcGVyaW1ldGVyRGVmaW5lc1ZpYWJsZVNoYXBlICkgPT4ge1xyXG4gICAgICBncmlkLnZpc2libGUgPSBzaG93R3JpZCAmJiBwZXJpbWV0ZXJEZWZpbmVzVmlhYmxlU2hhcGU7XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBzaGFwZSwgZ3JpZCwgYW5kIGRpbWVuc2lvbnMgaWYgdGhlIHBlcmltZXRlciBzaGFwZSBpdHNlbGYgY2hhbmdlcy5cclxuICAgIHBlcmltZXRlclNoYXBlUHJvcGVydHkubGluayggKCkgPT4ge1xyXG4gICAgICB1cGRhdGUoKTtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBQYXNzIG9wdGlvbnMgdGhyb3VnaCB0byBwYXJlbnQgY2xhc3MuXHJcbiAgICB0aGlzLm11dGF0ZSggb3B0aW9ucyApO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVXRpbGl0eSBmdW5jdGlvbiBmb3IgaWRlbnRpZnlpbmcgYSBwZXJpbWV0ZXIgc2VnbWVudCB3aXRoIG5vIGJlbmRzLlxyXG5mdW5jdGlvbiBpZGVudGlmeVNlZ21lbnQoIHBlcmltZXRlclBvaW50cywgc3RhcnRJbmRleCApIHtcclxuXHJcbiAgLy8gUGFyYW1ldGVyIGNoZWNraW5nLlxyXG4gIGlmICggc3RhcnRJbmRleCA+PSBwZXJpbWV0ZXJQb2ludHMubGVuZ3RoICkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCAnSWxsZWdhbCB1c2Ugb2YgZnVuY3Rpb24gZm9yIGlkZW50aWZ5aW5nIHBlcmltZXRlciBzZWdtZW50cy4nICk7XHJcbiAgfVxyXG5cclxuICAvLyBTZXQgdXAgaW5pdGlhbCBwb3J0aW9uIG9mIHNlZ21lbnQuXHJcbiAgY29uc3Qgc2VnbWVudFN0YXJ0UG9pbnQgPSBwZXJpbWV0ZXJQb2ludHNbIHN0YXJ0SW5kZXggXTtcclxuICBsZXQgZW5kSW5kZXggPSAoIHN0YXJ0SW5kZXggKyAxICkgJSBwZXJpbWV0ZXJQb2ludHMubGVuZ3RoO1xyXG4gIGxldCBzZWdtZW50RW5kUG9pbnQgPSBwZXJpbWV0ZXJQb2ludHNbIGVuZEluZGV4IF07XHJcbiAgY29uc3QgcHJldmlvdXNBbmdsZSA9IE1hdGguYXRhbjIoIHNlZ21lbnRFbmRQb2ludC55IC0gc2VnbWVudFN0YXJ0UG9pbnQueSwgc2VnbWVudEVuZFBvaW50LnggLSBzZWdtZW50U3RhcnRQb2ludC54ICk7XHJcbiAgbGV0IHNlZ21lbnRDb21wbGV0ZSA9IGZhbHNlO1xyXG5cclxuICB3aGlsZSAoICFzZWdtZW50Q29tcGxldGUgJiYgZW5kSW5kZXggIT09IDAgKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGVQb2ludCA9IHBlcmltZXRlclBvaW50c1sgKCBlbmRJbmRleCArIDEgKSAlIHBlcmltZXRlclBvaW50cy5sZW5ndGggXTtcclxuICAgIGNvbnN0IGFuZ2xlVG9DYW5kaWRhdGVQb2ludCA9IE1hdGguYXRhbjIoIGNhbmRpZGF0ZVBvaW50LnkgLSBzZWdtZW50RW5kUG9pbnQueSwgY2FuZGlkYXRlUG9pbnQueCAtIHNlZ21lbnRFbmRQb2ludC54ICk7XHJcbiAgICBpZiAoIHByZXZpb3VzQW5nbGUgPT09IGFuZ2xlVG9DYW5kaWRhdGVQb2ludCApIHtcclxuICAgICAgLy8gVGhpcyBwb2ludCBpcyBhbiBleHRlbnNpb24gb2YgdGhlIGN1cnJlbnQgc2VnbWVudC5cclxuICAgICAgc2VnbWVudEVuZFBvaW50ID0gY2FuZGlkYXRlUG9pbnQ7XHJcbiAgICAgIGVuZEluZGV4ID0gKCBlbmRJbmRleCArIDEgKSAlIHBlcmltZXRlclBvaW50cy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gVGhpcyBwb2ludCBpc24ndCBwYXJ0IG9mIHRoaXMgc2VnbWVudC5cclxuICAgICAgc2VnbWVudENvbXBsZXRlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzdGFydEluZGV4OiBzdGFydEluZGV4LFxyXG4gICAgZW5kSW5kZXg6IGVuZEluZGV4XHJcbiAgfTtcclxufVxyXG5cclxuYXJlYUJ1aWxkZXIucmVnaXN0ZXIoICdQZXJpbWV0ZXJTaGFwZU5vZGUnLCBQZXJpbWV0ZXJTaGFwZU5vZGUgKTtcclxuZXhwb3J0IGRlZmF1bHQgUGVyaW1ldGVyU2hhcGVOb2RlOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsU0FBUyxNQUFNLGtDQUFrQztBQUN4RCxPQUFPQyxRQUFRLE1BQU0saUNBQWlDO0FBQ3RELE9BQU9DLEtBQUssTUFBTSw2QkFBNkI7QUFDL0MsT0FBT0MsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxTQUFTQyxLQUFLLFFBQVEsZ0NBQWdDO0FBQ3RELE9BQU9DLFFBQVEsTUFBTSx5Q0FBeUM7QUFDOUQsU0FBU0MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUksUUFBUSxtQ0FBbUM7QUFDcEUsT0FBT0MsV0FBVyxNQUFNLHNCQUFzQjtBQUM5QyxPQUFPQyxJQUFJLE1BQU0sV0FBVzs7QUFFNUI7QUFDQSxNQUFNQyxvQkFBb0IsR0FBRyxJQUFJTixRQUFRLENBQUU7RUFBRU8sSUFBSSxFQUFFO0FBQUcsQ0FBRSxDQUFDO0FBQ3pELE1BQU1DLG9CQUFvQixHQUFHLElBQUk7QUFFakMsTUFBTUMsa0JBQWtCLFNBQVNSLElBQUksQ0FBQztFQUVwQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VTLFdBQVdBLENBQUVDLHNCQUFzQixFQUFFQyxTQUFTLEVBQUVDLGdCQUFnQixFQUFFQyxzQkFBc0IsRUFBRUMsZ0JBQWdCLEVBQUVDLE9BQU8sRUFBRztJQUVwSCxLQUFLLENBQUMsQ0FBQztJQUVQLE1BQU1DLG1DQUFtQyxHQUFHLElBQUlyQixRQUFRLENBQUUsS0FBTSxDQUFDOztJQUVqRTtJQUNBO0lBQ0EsTUFBTXNCLGtCQUFrQixHQUFHLElB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