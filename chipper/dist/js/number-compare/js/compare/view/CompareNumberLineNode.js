// Copyright 2021-2023, University of Colorado Boulder

/**
 * Class for a 'Compare Number Line' Node, which creates a number line with two dynamic points that represent the value
 * of the given left and right current numbers.
 *
 * @author Chris Klusendorf (PhET Interactive Simulations)
 */

import Vector2 from '../../../../dot/js/Vector2.js';
import { Shape } from '../../../../kite/js/imports.js';
import PhetFont from '../../../../scenery-phet/js/PhetFont.js';
import { Circle, Color, Node, Path, Text } from '../../../../scenery/js/imports.js';
import EnumerationValue from '../../../../phet-core/js/EnumerationValue.js';
import Enumeration from '../../../../phet-core/js/Enumeration.js';
import optionize from '../../../../phet-core/js/optionize.js';
import numberCompare from '../../numberCompare.js';
import NumberCompareColors from '../../common/NumberCompareColors.js';

// types

// constants
const INTEGERS_PER_MAJOR_TICK_MARK = 5; // the number of integers between two major tick marks

class CompareNumberLineNode extends Node {
  constructor(height, leftCurrentNumberProperty, rightCurrentNumberProperty, sumRange) {
    super();
    const pixelsPerTickMark = height / sumRange.max;

    // create and add the number line
    const numberLineNode = CompareNumberLineNode.getNumberLineNode(pixelsPerTickMark, sumRange);
    this.addChild(numberLineNode);

    // create and add an indicator for the leftCurrentNumberProperty
    const leftCurrentNumberIndicatorNode = CompareNumberLineNode.getCurrentNumberIndicatorNode(LeftRightDirection.LEFT, NumberCompareColors.purpleHighlightColorProperty);
    numberLineNode.addChild(leftCurrentNumberIndicatorNode);

    // create and add an indicator for the rightCurrentNumberProperty
    const rightCurrentNumberIndicatorNode = CompareNumberLineNode.getCurrentNumberIndicatorNode(LeftRightDirection.RIGHT, NumberCompareColors.orangeHighlightColorProperty);
    numberLineNode.addChild(rightCurrentNumberIndicatorNode);

    // update the leftCurrentNumberIndicatorNodes when leftCurrentNumberProperty changes
    leftCurrentNumberProperty.link(leftCurrentNumber => {
      leftCurrentNumberIndicatorNode.centerY = pixelsPerTickMark * -leftCurrentNumber;
    });

    // update the rightCurrentNumberIndicatorNodes when rightCurrentNumberProperty changes
    rightCurrentNumberProperty.link(rightCurrentNumber => {
      rightCurrentNumberIndicatorNode.centerY = pixelsPerTickMark * -rightCurrentNumber;
    });
  }

  /**
   * Draws a number line node in a vertical orientation with minor + major tick marks and number labels on the major
   * tick marks.
   *
   * @param pixelsPerTickMark
   * @param range - inclusive
   * @param [providedOptions]
   */
  static getNumberLineNode(pixelsPerTickMark, range, providedOptions) {
    const options = optionize()({
      includeLabels: true,
      minorLineWidth: 1,
      majorLineWidth: 2,
      minorTickMarkHalfLineLength: 9,
      majorTickMarkHalfLineLength: 16
    }, providedOptions);
    const numberLineDistance = range.getLength();

    // create the base vertical line
    const numberLineShape = new Shape().moveTo(0, 0).lineTo(0, -numberLineDistance * pixelsPerTickMark);
    const numberLineNode = new Path(numberLineShape, {
      stroke: Color.BLACK,
      lineWidth: options.minorLineWidth
    });

    // create tick marks at each integer on the number line, plus labels for the major tick marks
    for (let i = 0; i <= numberLineDistance; i++) {
      const isMajorTickMark = i % INTEGERS_PER_MAJOR_TICK_MARK === 0;
      const tickMarkHalfLength = isMajorTickMark ? options.majorTickMarkHalfLineLength : options.minorTickMarkHalfLineLength;

      // create and add a major or minor tick mark
      const tickMarkShape = new Shape().moveTo(-tickMarkHalfLength, -i * pixelsPerTickMark).lineTo(tickMarkHalfLength, -i * pixelsPerTickMark);
      const tickMarkNode = new Path(tickMarkShape, {
        stroke: Color.BLACK,
        lineWidth: isMajorTickMark ? options.majorLineWidth : options.minorLineWidth
      });
      numberLineNode.addChild(tickMarkNode);

      // create and add a label for a major tick mark
      if (options.includeLabels && isMajorTickMark) {
        const tickMarkLabel = new Text(i, {
          font: new PhetFont(12)
        });
        tickMarkLabel.right = tickMarkNode.left - 8;
        tickMarkLabel.centerY = tickMarkNode.centerY;
        numberLineNode.addChild(tickMarkLabel);
      }
    }
    return numberLineNode;
  }

  /**
   * Creates an indicator for the number line, which consists of a point with a triangle attached to it on the left or
   * right side.
   */
  static getCurrentNumberIndicatorNode(triangleSide, triangleColor) {
    const indicatorNode = new Node();

    // create the center point
    const pointRadius = 5;
    const pointNode = new Circle(pointRadius, {
      fill: Color.BLACK
    });

    // create and add the triangle on the left or right side
    const sign = triangleSide === LeftRightDirection.LEFT ? -1 : 1;
    const triangleOrigin = new Vector2(sign * (pointRadius - 1.5), 0); // empirically determined to overlap the point
    const triangleLongerSideLength = 20; // empirically determined
    const triangleShorterSideLength = triangleLongerSideLength * 0.8; // empirically determined
    const triangleShape = new Shape().moveToPoint(triangleOrigin).lineToRelative(sign * triangleLongerSideLength / Math.sqrt(2), -triangleShorterSideLength / 2).lineToRelative(0, triangleShorterSideLength).lineToPoint(triangleOrigin).close();
    const triangleNode = new Path(triangleShape, {
      fill: triangleColor
    });
    indicatorNode.addChild(triangleNode);
    indicatorNode.addChild(pointNode);
    return indicatorNode;
  }
  dispose() {
    assert && assert(false, 'dispose is not supported, exists for the lifetime of the sim');
    super.dispose();
  }
}

/**
 * Enumeration for specifying which side the triangle should go on for the indicator node above.
 */
class LeftRightDirection extends EnumerationValue {
  static LEFT = new LeftRightDirection();
  static RIGHT = new LeftRightDirection();
  static enumeration = new Enumeration(LeftRightDirection);
}
numberCompare.register('CompareNumberLineNode', CompareNumberLineNode);
export default CompareNumberLineNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJWZWN0b3IyIiwiU2hhcGUiLCJQaGV0Rm9udCIsIkNpcmNsZSIsIkNvbG9yIiwiTm9kZSIsIlBhdGgiLCJUZXh0IiwiRW51bWVyYXRpb25WYWx1ZSIsIkVudW1lcmF0aW9uIiwib3B0aW9uaXplIiwibnVtYmVyQ29tcGFyZSIsIk51bWJlckNvbXBhcmVDb2xvcnMiLCJJTlRFR0VSU19QRVJfTUFKT1JfVElDS19NQVJLIiwiQ29tcGFyZU51bWJlckxpbmVOb2RlIiwiY29uc3RydWN0b3IiLCJoZWlnaHQiLCJsZWZ0Q3VycmVudE51bWJlclByb3BlcnR5IiwicmlnaHRDdXJyZW50TnVtYmVyUHJvcGVydHkiLCJzdW1SYW5nZSIsInBpeGVsc1BlclRpY2tNYXJrIiwibWF4IiwibnVtYmVyTGluZU5vZGUiLCJnZXROdW1iZXJMaW5lTm9kZSIsImFkZENoaWxkIiwibGVmdEN1cnJlbnROdW1iZXJJbmRpY2F0b3JOb2RlIiwiZ2V0Q3VycmVudE51bWJlckluZGljYXRvck5vZGUiLCJMZWZ0UmlnaHREaXJlY3Rpb24iLCJMRUZUIiwicHVycGxlSGlnaGxpZ2h0Q29sb3JQcm9wZXJ0eSIsInJpZ2h0Q3VycmVudE51bWJlckluZGljYXRvck5vZGUiLCJSSUdIVCIsIm9yYW5nZUhpZ2hsaWdodENvbG9yUHJvcGVydHkiLCJsaW5rIiwibGVmdEN1cnJlbnROdW1iZXIiLCJjZW50ZXJZIiwicmlnaHRDdXJyZW50TnVtYmVyIiwicmFuZ2UiLCJwcm92aWRlZE9wdGlvbnMiLCJvcHRpb25zIiwiaW5jbHVkZUxhYmVscyIsIm1pbm9yTGluZVdpZHRoIiwibWFqb3JMaW5lV2lkdGgiLCJtaW5vclRpY2tNYXJrSGFsZkxpbmVMZW5ndGgiLCJtYWpvclRpY2tNYXJrSGFsZkxpbmVMZW5ndGgiLCJudW1iZXJMaW5lRGlzdGFuY2UiLCJnZXRMZW5ndGgiLCJudW1iZXJMaW5lU2hhcGUiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJCTEFDSyIsImxpbmVXaWR0aCIsImkiLCJpc01ham9yVGlja01hcmsiLCJ0aWNrTWFya0hhbGZMZW5ndGgiLCJ0aWNrTWFya1NoYXBlIiwidGlja01hcmtOb2RlIiwidGlja01hcmtMYWJlbCIsImZvbnQiLCJyaWdodCIsImxlZnQiLCJ0cmlhbmdsZVNpZGUiLCJ0cmlhbmdsZUNvbG9yIiwiaW5kaWNhdG9yTm9kZSIsInBvaW50UmFkaXVzIiwicG9pbnROb2RlIiwiZmlsbCIsInNpZ24iLCJ0cmlhbmdsZU9yaWdpbiIsInRyaWFuZ2xlTG9uZ2VyU2lkZUxlbmd0aCIsInRyaWFuZ2xlU2hvcnRlclNpZGVMZW5ndGgiLCJ0cmlhbmdsZVNoYXBlIiwibW92ZVRvUG9pbnQiLCJsaW5lVG9SZWxhdGl2ZSIsIk1hdGgiLCJzcXJ0IiwibGluZVRvUG9pbnQiLCJjbG9zZSIsInRyaWFuZ2xlTm9kZSIsImRpc3Bvc2UiLCJhc3NlcnQiLCJlbnVtZXJhdGlvbiIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiQ29tcGFyZU51bWJlckxpbmVOb2RlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjMsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciBhICdDb21wYXJlIE51bWJlciBMaW5lJyBOb2RlLCB3aGljaCBjcmVhdGVzIGEgbnVtYmVyIGxpbmUgd2l0aCB0d28gZHluYW1pYyBwb2ludHMgdGhhdCByZXByZXNlbnQgdGhlIHZhbHVlXHJcbiAqIG9mIHRoZSBnaXZlbiBsZWZ0IGFuZCByaWdodCBjdXJyZW50IG51bWJlcnMuXHJcbiAqXHJcbiAqIEBhdXRob3IgQ2hyaXMgS2x1c2VuZG9yZiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4va2l0ZS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IFBoZXRGb250IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9QaGV0Rm9udC5qcyc7XHJcbmltcG9ydCB7IENpcmNsZSwgQ29sb3IsIFRQYWludCwgTm9kZSwgUGF0aCwgVGV4dCB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBSYW5nZSBmcm9tICcuLi8uLi8uLi8uLi9kb3QvanMvUmFuZ2UuanMnO1xyXG5pbXBvcnQgRW51bWVyYXRpb25WYWx1ZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvRW51bWVyYXRpb25WYWx1ZS5qcyc7XHJcbmltcG9ydCBFbnVtZXJhdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvRW51bWVyYXRpb24uanMnO1xyXG5pbXBvcnQgVFJlYWRPbmx5UHJvcGVydHkgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9UUmVhZE9ubHlQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBvcHRpb25pemUgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL29wdGlvbml6ZS5qcyc7XHJcbmltcG9ydCBudW1iZXJDb21wYXJlIGZyb20gJy4uLy4uL251bWJlckNvbXBhcmUuanMnO1xyXG5pbXBvcnQgTnVtYmVyQ29tcGFyZUNvbG9ycyBmcm9tICcuLi8uLi9jb21tb24vTnVtYmVyQ29tcGFyZUNvbG9ycy5qcyc7XHJcblxyXG4vLyB0eXBlc1xyXG50eXBlIEdldE51bWJlckxpbmVOb2RlT3B0aW9ucyA9IHtcclxuICBpbmNsdWRlTGFiZWxzPzogYm9vbGVhbjtcclxuICBtaW5vckxpbmVXaWR0aD86IG51bWJlcjtcclxuICBtYWpvckxpbmVXaWR0aD86IG51bWJlcjtcclxuICBtaW5vclRpY2tNYXJrSGFsZkxpbmVMZW5ndGg/OiBudW1iZXI7XHJcbiAgbWFqb3JUaWNrTWFya0hhbGZMaW5lTGVuZ3RoPzogbnVtYmVyO1xyXG59O1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IElOVEVHRVJTX1BFUl9NQUpPUl9USUNLX01BUksgPSA1OyAvLyB0aGUgbnVtYmVyIG9mIGludGVnZXJzIGJldHdlZW4gdHdvIG1ham9yIHRpY2sgbWFya3NcclxuXHJcbmNsYXNzIENvbXBhcmVOdW1iZXJMaW5lTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIGhlaWdodDogbnVtYmVyLCBsZWZ0Q3VycmVudE51bWJlclByb3BlcnR5OiBUUmVhZE9ubHlQcm9wZXJ0eTxudW1iZXI+LFxyXG4gICAgICAgICAgICAgICByaWdodEN1cnJlbnROdW1iZXJQcm9wZXJ0eTogVFJlYWRPbmx5UHJvcGVydHk8bnVtYmVyPiwgc3VtUmFuZ2U6IFJhbmdlICkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBjb25zdCBwaXhlbHNQZXJUaWNrTWFyayA9IGhlaWdodCAvIHN1bVJhbmdlLm1heDtcclxuXHJcbiAgICAvLyBjcmVhdGUgYW5kIGFkZCB0aGUgbnVtYmVyIGxpbmVcclxuICAgIGNvbnN0IG51bWJlckxpbmVOb2RlID0gQ29tcGFyZU51bWJlckxpbmVOb2RlLmdldE51bWJlckxpbmVOb2RlKCBwaXhlbHNQZXJUaWNrTWFyaywgc3VtUmFuZ2UgKTtcclxuICAgIHRoaXMuYWRkQ2hpbGQoIG51bWJlckxpbmVOb2RlICk7XHJcblxyXG4gICAgLy8gY3JlYXRlIGFuZCBhZGQgYW4gaW5kaWNhdG9yIGZvciB0aGUgbGVmdEN1cnJlbnROdW1iZXJQcm9wZXJ0eVxyXG4gICAgY29uc3QgbGVmdEN1cnJlbnROdW1iZXJJbmRpY2F0b3JOb2RlID0gQ29tcGFyZU51bWJlckxpbmVOb2RlLmdldEN1cnJlbnROdW1iZXJJbmRpY2F0b3JOb2RlKFxyXG4gICAgICBMZWZ0UmlnaHREaXJlY3Rpb24uTEVGVCxcclxuICAgICAgTnVtYmVyQ29tcGFyZUNvbG9ycy5wdXJwbGVIaWdobGlnaHRDb2xvclByb3BlcnR5XHJcbiAgICApO1xyXG4gICAgbnVtYmVyTGluZU5vZGUuYWRkQ2hpbGQoIGxlZnRDdXJyZW50TnVtYmVySW5kaWNhdG9yTm9kZSApO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBhbmQgYWRkIGFuIGluZGljYXRvciBmb3IgdGhlIHJpZ2h0Q3VycmVudE51bWJlclByb3BlcnR5XHJcbiAgICBjb25zdCByaWdodEN1cnJlbnROdW1iZXJJbmRpY2F0b3JOb2RlID0gQ29tcGFyZU51bWJlckxpbmVOb2RlLmdldEN1cnJlbnROdW1iZXJJbmRpY2F0b3JOb2RlKFxyXG4gICAgICBMZWZ0UmlnaHREaXJlY3Rpb24uUklHSFQsXHJcbiAgICAgIE51bWJlckNvbXBhcmVDb2xvcnMub3JhbmdlSGlnaGxpZ2h0Q29sb3JQcm9wZXJ0eVxyXG4gICAgKTtcclxuICAgIG51bWJlckxpbmVOb2RlLmFkZENoaWxkKCByaWdodEN1cnJlbnROdW1iZXJJbmRpY2F0b3JOb2RlICk7XHJcblxyXG4gICAgLy8gdXBkYXRlIHRoZSBsZWZ0Q3VycmVudE51bWJlckluZGljYXRvck5vZGVzIHdoZW4gbGVmdEN1cnJlbnROdW1iZXJQcm9wZXJ0eSBjaGFuZ2VzXHJcbiAgICBsZWZ0Q3VycmVudE51bWJlclByb3BlcnR5LmxpbmsoIGxlZnRDdXJyZW50TnVtYmVyID0+IHtcclxuICAgICAgbGVmdEN1cnJlbnROdW1iZXJJbmRpY2F0b3JOb2RlLmNlbnRlclkgPSBwaXhlbHNQZXJUaWNrTWFyayAqIC1sZWZ0Q3VycmVudE51bWJlcjtcclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyB1cGRhdGUgdGhlIHJpZ2h0Q3VycmVudE51bWJlckluZGljYXRvck5vZGVzIHdoZW4gcmlnaHRDdXJyZW50TnVtYmVyUHJvcGVydHkgY2hhbmdlc1xyXG4gICAgcmlnaHRDdXJyZW50TnVtYmVyUHJvcGVydHkubGluayggcmlnaHRDdXJyZW50TnVtYmVyID0+IHtcclxuICAgICAgcmlnaHRDdXJyZW50TnVtYmVySW5kaWNhdG9yTm9kZS5jZW50ZXJZID0gcGl4ZWxzUGVyVGlja01hcmsgKiAtcmlnaHRDdXJyZW50TnVtYmVyO1xyXG4gICAgfSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhd3MgYSBudW1iZXIgbGluZSBub2RlIGluIGEgdmVydGljYWwgb3JpZW50YXRpb24gd2l0aCBtaW5vciArIG1ham9yIHRpY2sgbWFya3MgYW5kIG51bWJlciBsYWJlbHMgb24gdGhlIG1ham9yXHJcbiAgICogdGljayBtYXJrcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBwaXhlbHNQZXJUaWNrTWFya1xyXG4gICAqIEBwYXJhbSByYW5nZSAtIGluY2x1c2l2ZVxyXG4gICAqIEBwYXJhbSBbcHJvdmlkZWRPcHRpb25zXVxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgZ2V0TnVtYmVyTGluZU5vZGUoIHBpeGVsc1BlclRpY2tNYXJrOiBudW1iZXIsIHJhbmdlOiBSYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZE9wdGlvbnM/OiBHZXROdW1iZXJMaW5lTm9kZU9wdGlvbnMgKTogTm9kZSB7XHJcblxyXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbml6ZTxHZXROdW1iZXJMaW5lTm9kZU9wdGlvbnM+KCkoIHtcclxuICAgICAgaW5jbHVkZUxhYmVsczogdHJ1ZSxcclxuICAgICAgbWlub3JMaW5lV2lkdGg6IDEsXHJcbiAgICAgIG1ham9yTGluZVdpZHRoOiAyLFxyXG4gICAgICBtaW5vclRpY2tNYXJrSGFsZkxpbmVMZW5ndGg6IDksXHJcbiAgICAgIG1ham9yVGlja01hcmtIYWxmTGluZUxlbmd0aDogMTZcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG4gICAgY29uc3QgbnVtYmVyTGluZURpc3RhbmNlID0gcmFuZ2UuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgLy8gY3JlYXRlIHRoZSBiYXNlIHZlcnRpY2FsIGxpbmVcclxuICAgIGNvbnN0IG51bWJlckxpbmVTaGFwZSA9IG5ldyBTaGFwZSgpLm1vdmVUbyggMCwgMCApLmxpbmVUbyggMCwgLW51bWJlckxpbmVEaXN0YW5jZSAqIHBpeGVsc1BlclRpY2tNYXJrICk7XHJcbiAgICBjb25zdCBudW1iZXJMaW5lTm9kZSA9IG5ldyBQYXRoKCBudW1iZXJMaW5lU2hhcGUsIHtcclxuICAgICAgc3Ryb2tlOiBDb2xvci5CTEFDSyxcclxuICAgICAgbGluZVdpZHRoOiBvcHRpb25zLm1pbm9yTGluZVdpZHRoXHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gY3JlYXRlIHRpY2sgbWFya3MgYXQgZWFjaCBpbnRlZ2VyIG9uIHRoZSBudW1iZXIgbGluZSwgcGx1cyBsYWJlbHMgZm9yIHRoZSBtYWpvciB0aWNrIG1hcmtzXHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPD0gbnVtYmVyTGluZURpc3RhbmNlOyBpKysgKSB7XHJcbiAgICAgIGNvbnN0IGlzTWFqb3JUaWNrTWFyayA9IGkgJSBJTlRFR0VSU19QRVJfTUFKT1JfVElDS19NQVJLID09PSAwO1xyXG4gICAgICBjb25zdCB0aWNrTWFya0hhbGZMZW5ndGggPSBpc01ham9yVGlja01hcmsgPyBvcHRpb25zLm1ham9yVGlja01hcmtIYWxmTGluZUxlbmd0aCA6IG9wdGlvbnMubWlub3JUaWNrTWFya0hhbGZMaW5lTGVuZ3RoO1xyXG5cclxuICAgICAgLy8gY3JlYXRlIGFuZCBhZGQgYSBtYWpvciBvciBtaW5vciB0aWNrIG1hcmtcclxuICAgICAgY29uc3QgdGlja01hcmtTaGFwZSA9IG5ldyBTaGFwZSgpLm1vdmVUbyggLXRpY2tNYXJrSGFsZkxlbmd0aCwgLWkgKiBwaXhlbHNQZXJUaWNrTWFyayApXHJcbiAgICAgICAgLmxpbmVUbyggdGlja01hcmtIYWxmTGVuZ3RoLCAtaSAqIHBpeGVsc1BlclRpY2tNYXJrICk7XHJcbiAgICAgIGNvbnN0IHRpY2tNYXJrTm9kZSA9IG5ldyBQYXRoKCB0aWNrTWFya1NoYXBlLCB7XHJcbiAgICAgICAgc3Ryb2tlOiBDb2xvci5CTEFDSyxcclxuICAgICAgICBsaW5lV2lkdGg6IGlzTWFqb3JUaWNrTWFyayA/IG9wdGlvbnMubWFqb3JMaW5lV2lkdGggOiBvcHRpb25zLm1pbm9yTGluZVdpZHRoXHJcbiAgICAgIH0gKTtcclxuICAgICAgbnVtYmVyTGluZU5vZGUuYWRkQ2hpbGQoIHRpY2tNYXJrTm9kZSApO1xyXG5cclxuICAgICAgLy8gY3JlYXRlIGFuZCBhZGQgYSBsYWJlbCBmb3IgYSBtYWpvciB0aWNrIG1hcmtcclxuICAgICAgaWYgKCBvcHRpb25zLmluY2x1ZGVMYWJlbHMgJiYgaXNNYWpvclRpY2tNYXJrICkge1xyXG4gICAgICAgIGNvbnN0IHRpY2tNYXJrTGFiZWwgPSBuZXcgVGV4dCggaSwgeyBmb250OiBuZXcgUGhldEZvbnQoIDEyICkgfSApO1xyXG4gICAgICAgIHRpY2tNYXJrTGFiZWwucmlnaHQgPSB0aWNrTWFya05vZGUubGVmdCAtIDg7XHJcbiAgICAgICAgdGlja01hcmtMYWJlbC5jZW50ZXJZID0gdGlja01hcmtOb2RlLmNlbnRlclk7XHJcbiAgICAgICAgbnVtYmVyTGluZU5vZGUuYWRkQ2hpbGQoIHRpY2tNYXJrTGFiZWwgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudW1iZXJMaW5lTm9kZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5kaWNhdG9yIGZvciB0aGUgbnVtYmVyIGxpbmUsIHdoaWNoIGNvbnNpc3RzIG9mIGEgcG9pbnQgd2l0aCBhIHRyaWFuZ2xlIGF0dGFjaGVkIHRvIGl0IG9uIHRoZSBsZWZ0IG9yXHJcbiAgICogcmlnaHQgc2lkZS5cclxuICAgKi9cclxuICBwcml2YXRlIHN0YXRpYyBnZXRDdXJyZW50TnVtYmVySW5kaWNhdG9yTm9kZSggdHJpYW5nbGVTaWRlOiBMZWZ0UmlnaHREaXJlY3Rpb24sIHRyaWFuZ2xlQ29sb3I6IFRQYWludCApOiBOb2RlIHtcclxuICAgIGNvbnN0IGluZGljYXRvck5vZGUgPSBuZXcgTm9kZSgpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgY2VudGVyIHBvaW50XHJcbiAgICBjb25zdCBwb2ludFJhZGl1cyA9IDU7XHJcbiAgICBjb25zdCBwb2ludE5vZGUgPSBuZXcgQ2lyY2xlKCBwb2ludFJhZGl1cywgeyBmaWxsOiBDb2xvci5CTEFDSyB9ICk7XHJcblxyXG4gICAgLy8gY3JlYXRlIGFuZCBhZGQgdGhlIHRyaWFuZ2xlIG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGVcclxuICAgIGNvbnN0IHNpZ24gPSB0cmlhbmdsZVNpZGUgPT09IExlZnRSaWdodERpcmVjdGlvbi5MRUZUID8gLTEgOiAxO1xyXG4gICAgY29uc3QgdHJpYW5nbGVPcmlnaW4gPSBuZXcgVmVjdG9yMiggc2lnbiAqICggcG9pbnRSYWRpdXMgLSAxLjUgKSwgMCApOyAvLyBlbXBpcmljYWxseSBkZXRlcm1pbmVkIHRvIG92ZXJsYXAgdGhlIHBvaW50XHJcbiAgICBjb25zdCB0cmlhbmdsZUxvbmdlclNpZGVMZW5ndGggPSAyMDsgLy8gZW1waXJpY2FsbHkgZGV0ZXJtaW5lZFxyXG4gICAgY29uc3QgdHJpYW5nbGVTaG9ydGVyU2lkZUxlbmd0aCA9IHRyaWFuZ2xlTG9uZ2VyU2lkZUxlbmd0aCAqIDAuODsgLy8gZW1waXJpY2FsbHkgZGV0ZXJtaW5lZFxyXG4gICAgY29uc3QgdHJpYW5nbGVTaGFwZSA9IG5ldyBTaGFwZSgpXHJcbiAgICAgIC5tb3ZlVG9Qb2ludCggdHJpYW5nbGVPcmlnaW4gKVxyXG4gICAgICAubGluZVRvUmVsYXRpdmUoIHNpZ24gKiB0cmlhbmdsZUxvbmdlclNpZGVMZW5ndGggLyBNYXRoLnNxcnQoIDIgKSwgLXRyaWFuZ2xlU2hvcnRlclNpZGVMZW5ndGggLyAyIClcclxuICAgICAgLmxpbmVUb1JlbGF0aXZlKCAwLCB0cmlhbmdsZVNob3J0ZXJTaWRlTGVuZ3RoIClcclxuICAgICAgLmxpbmVUb1BvaW50KCB0cmlhbmdsZU9yaWdpbiApLmNsb3NlKCk7XHJcbiAgICBjb25zdCB0cmlhbmdsZU5vZGUgPSBuZXcgUGF0aCggdHJpYW5nbGVTaGFwZSwge1xyXG4gICAgICBmaWxsOiB0cmlhbmdsZUNvbG9yXHJcbiAgICB9ICk7XHJcbiAgICBpbmRpY2F0b3JOb2RlLmFkZENoaWxkKCB0cmlhbmdsZU5vZGUgKTtcclxuICAgIGluZGljYXRvck5vZGUuYWRkQ2hpbGQoIHBvaW50Tm9kZSApO1xyXG5cclxuICAgIHJldHVybiBpbmRpY2F0b3JOb2RlO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCBmYWxzZSwgJ2Rpc3Bvc2UgaXMgbm90IHN1cHBvcnRlZCwgZXhpc3RzIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbScgKTtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnVtZXJhdGlvbiBmb3Igc3BlY2lmeWluZyB3aGljaCBzaWRlIHRoZSB0cmlhbmdsZSBzaG91bGQgZ28gb24gZm9yIHRoZSBpbmRpY2F0b3Igbm9kZSBhYm92ZS5cclxuICovXHJcbmNsYXNzIExlZnRSaWdodERpcmVjdGlvbiBleHRlbmRzIEVudW1lcmF0aW9uVmFsdWUge1xyXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTEVGVCA9IG5ldyBMZWZ0UmlnaHREaXJlY3Rpb24oKTtcclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJJR0hUID0gbmV3IExlZnRSaWdodERpcmVjdGlvbigpO1xyXG5cclxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGVudW1lcmF0aW9uID0gbmV3IEVudW1lcmF0aW9uKCBMZWZ0UmlnaHREaXJlY3Rpb24gKTtcclxufVxyXG5cclxubnVtYmVyQ29tcGFyZS5yZWdpc3RlciggJ0NvbXBhcmVOdW1iZXJMaW5lTm9kZScsIENvbXBhcmVOdW1iZXJMaW5lTm9kZSApO1xyXG5leHBvcnQgZGVmYXVsdCBDb21wYXJlTnVtYmVyTGluZU5vZGU7Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsT0FBTyxNQUFNLCtCQUErQjtBQUNuRCxTQUFTQyxLQUFLLFFBQVEsZ0NBQWdDO0FBQ3RELE9BQU9DLFFBQVEsTUFBTSx5Q0FBeUM7QUFDOUQsU0FBU0MsTUFBTSxFQUFFQyxLQUFLLEVBQVVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLFFBQVEsbUNBQW1DO0FBRTNGLE9BQU9DLGdCQUFnQixNQUFNLDhDQUE4QztBQUMzRSxPQUFPQyxXQUFXLE1BQU0seUNBQXlDO0FBRWpFLE9BQU9DLFNBQVMsTUFBTSx1Q0FBdUM7QUFDN0QsT0FBT0MsYUFBYSxNQUFNLHdCQUF3QjtBQUNsRCxPQUFPQyxtQkFBbUIsTUFBTSxxQ0FBcUM7O0FBRXJFOztBQVNBO0FBQ0EsTUFBTUMsNEJBQTRCLEdBQUcsQ0FBQyxDQUFDLENBQUM7O0FBRXhDLE1BQU1DLHFCQUFxQixTQUFTVCxJQUFJLENBQUM7RUFFaENVLFdBQVdBLENBQUVDLE1BQWMsRUFBRUMseUJBQW9ELEVBQzNFQywwQkFBcUQsRUFBRUMsUUFBZSxFQUFHO0lBQ3BGLEtBQUssQ0FBQyxDQUFDO0lBRVAsTUFBTUMsaUJBQWlCLEdBQUdKLE1BQU0sR0FBR0csUUFBUSxDQUFDRSxHQUFHOztJQUUvQztJQUNBLE1BQU1DLGNBQWMsR0FBR1IscUJBQXFCLENBQUNTLGlCQUFpQixDQUFFSCxpQkFBaUIsRUFBRUQsUUFBUyxDQUFDO0lBQzdGLElBQUksQ0FBQ0ssUUFBUSxDQUFFRixjQUFlLENBQUM7O0lBRS9CO0lBQ0EsTUFBTUcsOEJBQThCLEdBQUdYLHFCQUFxQixDQUFDWSw2QkFBNkIsQ0FDeEZDLGtCQUFrQixDQUFDQyxJQUFJLEVBQ3ZCaEIsbUJBQW1CLENBQUNpQiw0QkFDdEIsQ0FBQztJQUNEUCxjQUFjLENBQUNFLFFBQVEsQ0FBRUMsOEJBQStCLENBQUM7O0lBRXpEO0lBQ0EsTUFBTUssK0JBQStCLEdBQUdoQixxQkFBcUIsQ0FBQ1ksNkJBQTZCLENBQ3pGQyxrQkFBa0IsQ0FBQ0ksS0FBSyxFQUN4Qm5CLG1CQUFtQixDQUFDb0IsNEJBQ3RCLENBQUM7SUFDRFYsY0FBYyxDQUFDRSxRQUFRLENBQUVNLCtCQUFnQyxDQUFDOztJQUUxRDtJQUNBYix5QkFBeUIsQ0FBQ2dCLElBQUksQ0FBRUMsaUJBQWlCLElBQUk7TUFDbkRULDhCQUE4QixDQUFDVSxPQUFPLEdBQUdmLGlCQUFpQixHQUFHLENBQUNjLGlCQUFpQjtJQUNqRixDQUFFLENBQUM7O0lBRUg7SUFDQWhCLDBCQUEwQixDQUFDZSxJQUFJLENBQUVHLGtCQUFrQixJQUFJO01BQ3JETiwrQkFBK0IsQ0FBQ0ssT0FBTyxHQUFHZixpQkFBaUIsR0FBRyxDQUFDZ0Isa0JBQWtCO0lBQ25GLENBQUUsQ0FBQztFQUNMOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxPQUFjYixpQkFBaUJBLENBQUVILGlCQUF5QixFQUFFaUIsS0FBWSxFQUN2Q0MsZUFBMEMsRUFBUztJQUVsRixNQUFNQyxPQUFPLEdBQUc3QixTQUFTLENBQTJCLENBQUMsQ0FBRTtNQUNyRDhCLGFBQWEsRUFBRSxJQUFJO01BQ25CQyxjQUFjLEVBQUUsQ0FBQztNQUNqQkMsY0FBYyxFQUFFLENBQUM7TUFDakJDLDJCQUEyQixFQUFFLENBQUM7TUFDOUJDLDJCQUEyQixFQUFFO0lBQy9CLENBQUMsRUFBRU4sZUFBZ0IsQ0FBQztJQUNwQixNQUFNTyxrQkFBa0IsR0FBR1IsS0FBSyxDQUFDUyxTQUFTLENBQUMsQ0FBQzs7SUFFNUM7SUFDQSxNQUFNQyxlQUFlLEdBQUcsSUFBSTlDLEtBQUssQ0FBQyxDQUFDLENBQUMrQyxNQUFNLENBQUUsQ0FBQyxFQUFFLENBQUUsQ0FBQyxDQUFDQyxNQUFNLENBQUUsQ0FBQyxFQUFFLENBQUNKLGtCQUFrQixHQUFHekIsaUJBQWtCLENBQUM7SUFDdkcsTUFBTUUsY0FBYyxHQUFHLElBQUloQixJQUFJLENBQUV5QyxlQUFlLEVBQUU7TUFDaERHLE1BQU0sRUFBRTlDLEtBQUssQ0FBQytDLEtBQUs7TUFDbkJDLFNBQVMsRUFBRWIsT0FBTyxDQUFDRTtJQUNyQixDQUFFLENBQUM7O0lBRUg7SUFDQSxLQUFNLElBQUlZLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsSUFBSVIsa0JBQWtCLEVBQUVRLENBQUMsRUFBRSxFQUFHO01BQzlDLE1BQU1DLGVBQWUsR0FBR0QsQ0FBQyxHQUFHeEMsNEJBQTRCLEtBQUssQ0FBQztNQUM5RCxNQUFNMEMsa0JBQWtCLEdBQUdELGVBQWUsR0FBR2YsT0FBTyxDQUFDSywyQkFBMkIsR0FBR0wsT0FBTyxDQUFDSSwyQkFBMkI7O01BRXRIO01BQ0EsTUFBTWEsYUFBYSxHQUFHLElBQUl2RCxLQUFLLENBQUMsQ0FBQyxDQUFDK0MsTUFBTSxDQUFFLENBQUNPLGtCQUFrQixFQUFFLENBQUNGLENBQUMsR0FBR2pDLGlCQUFrQixDQUFDLENBQ3BGNkIsTUFBTSxDQUFFTSxrQkFBa0IsRUFBRSxDQUFDRixDQUFDLEdBQUdqQyxpQkFBa0IsQ0FBQztNQUN2RCxNQUFNcUMsWUFBWSxHQUFHLElBQUluRCxJQUFJLENBQUVrRCxhQUFhLEVBQUU7UUFDNUNOLE1BQU0sRUFBRTlDLEtBQUssQ0FBQytDLEtBQUs7UUFDbkJDLFNBQVMsRUFBRUUsZUFBZSxHQUFHZixPQUFPLENBQUNHLGNBQWMsR0FBR0gsT0FBTyxDQUFDRTtNQUNoRSxDQUFFLENBQUM7TUFDSG5CLGNBQWMsQ0FBQ0UsUUFBUSxDQUFFaUMsWUFBYSxDQUFDOztNQUV2QztNQUNBLElBQUtsQixPQUFPLENBQUNDLGFBQWEsSUFBSWMsZUFBZSxFQUFHO1FBQzlDLE1BQU1JLGFBQWEsR0FBRyxJQUFJbkQsSUFBSSxDQUFFOEMsQ0FBQyxFQUFFO1VBQUVNLElBQUksRUFBRSxJQUFJekQsUUFBUSxDQUFFLEVBQUc7UUFBRSxDQUFFLENBQUM7UUFDakV3RCxhQUFhLENBQUNFLEtBQUssR0FBR0gsWUFBWSxDQUFDSSxJQUFJLEdBQUcsQ0FBQztRQUMzQ0gsYUFBYSxDQUFDdkIsT0FBTyxHQUFHc0IsWUFBWSxDQUFDdEIsT0FBTztRQUM1Q2IsY0FBYyxDQUFDRSxRQUFRLENBQUVrQyxhQUFjLENBQUM7TUFDMUM7SUFDRjtJQUVBLE9BQU9wQyxjQUFjO0VBQ3ZCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ0UsT0FBZUksNkJBQTZCQSxDQUFFb0MsWUFBZ0MsRUFBRUMsYUFBcUIsRUFBUztJQUM1RyxNQUFNQyxhQUFhLEdBQUcsSUFBSTNELElBQUksQ0FBQyxDQUFDOztJQUVoQztJQUNBLE1BQU00RCxXQUFXLEdBQUcsQ0FBQztJQUNyQixNQUFNQyxTQUFTLEdBQUcsSUFBSS9ELE1BQU0sQ0FBRThELFdBQVcsRUFBRTtNQUFFRSxJQUFJLEVBQUUvRCxLQUFLLENBQUMrQztJQUFNLENBQUUsQ0FBQzs7SUFFbEU7SUFDQSxNQUFNaUIsSUFBSSxHQUFHTixZQUFZLEtBQUtuQyxrQkFBa0IsQ0FBQ0MsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7SUFDOUQsTUFBTXlDLGNBQWMsR0FBRyxJQUFJckUsT0FBTyxDQUFFb0UsSUFBSSxJQUFLSCxXQUFXLEdBQUcsR0FBRyxDQUFFLEVBQUUsQ0FBRSxDQUFDLENBQUMsQ0FBQztJQUN2RSxNQUFNSyx3QkFBd0IsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNyQyxNQUFNQyx5QkFBeUIsR0FBR0Qsd0JBQXdCLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDbEUsTUFBTUUsYUFBYSxHQUFHLElBQUl2RSxLQUFLLENBQUMsQ0FBQyxDQUM5QndFLFdBQVcsQ0FBRUosY0FBZSxDQUFDLENBQzdCSyxjQUFjLENBQUVOLElBQUksR0FBR0Usd0JBQXdCLEdBQUdLLElBQUksQ0FBQ0MsSUFBSSxDQUFFLENBQUUsQ0FBQyxFQUFFLENBQUNMLHlCQUF5QixHQUFHLENBQUUsQ0FBQyxDQUNsR0csY0FBYyxDQUFFLENBQUMsRUFBRUgseUJBQTBCLENBQUMsQ0FDOUNNLFdBQVcsQ0FBRVIsY0FBZSxDQUFDLENBQUNTLEtBQUssQ0FBQyxDQUFDO0lBQ3hDLE1BQU1DLFlBQVksR0FBRyxJQUFJekUsSUFBSSxDQUFFa0UsYUFBYSxFQUFFO01BQzVDTCxJQUFJLEVBQUVKO0lBQ1IsQ0FBRSxDQUFDO0lBQ0hDLGFBQWEsQ0FBQ3hDLFFBQVEsQ0FBRXVELFlBQWEsQ0FBQztJQUN0Q2YsYUFBYSxDQUFDeEMsUUFBUSxDQUFFMEMsU0FBVSxDQUFDO0lBRW5DLE9BQU9GLGFBQWE7RUFDdEI7RUFFZ0JnQixPQUFPQSxDQUFBLEVBQVM7SUFDOUJDLE1BQU0sSUFBSUEsTUFBTSxDQUFFLEtBQUssRUFBRSw4REFBK0QsQ0FBQztJQUN6RixLQUFLLENBQUNELE9BQU8sQ0FBQyxDQUFDO0VBQ2pCO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTXJELGtCQUFrQixTQUFTbkIsZ0JBQWdCLENBQUM7RUFDaEQsT0FBdUJvQixJQUFJLEdBQUcsSUFBSUQsa0JBQWtCLENBQUMsQ0FBQztFQUN0RCxPQUF1QkksS0FBSyxHQUFHLElBQUlKLGtCQUFrQixDQUFDLENBQUM7RUFFdkQsT0FBdUJ1RCxXQUFXLEdBQUcsSUFBSXpFLFdBQVcsQ0FBRWtCLGtCQUFtQixDQUFDO0FBQzVFO0FBRUFoQixhQUFhLENBQUN3RSxRQUFRLENBQUUsdUJBQXVCLEVBQUVyRSxxQkFBc0IsQ0FBQztBQUN4RSxlQUFlQSxxQkFBcUIifQ==