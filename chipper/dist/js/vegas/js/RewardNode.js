// Copyright 2014-2022, University of Colorado Boulder

/**
 * Reward node that shows many nodes animating continuously, for fun!  Shown when a perfect score is achieved in a game.
 * You can also test this by running vegas/vegas_en.html and clicking on the "Reward" screen.
 * Note that the number of images falling is constant, so if the screen is stretched out vertically (tall thin window)
 * they will be less dense.
 *
 * There are two ways to run the animation step function.  The client code can manually call step(dt), or the client
 * code can pass in an Events instance that triggers events on 'step'. In the latter case, the listener will
 * automatically be removed when the animation is complete.
 *
 * For details about the development of the RewardNode, please see https://github.com/phetsims/vegas/issues/4
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import Bounds2 from '../../dot/js/Bounds2.js';
import dotRandom from '../../dot/js/dotRandom.js';
import ScreenView from '../../joist/js/ScreenView.js';
import getGlobal from '../../phet-core/js/getGlobal.js';
import optionize from '../../phet-core/js/optionize.js';
import FaceNode from '../../scenery-phet/js/FaceNode.js';
import StarNode from '../../scenery-phet/js/StarNode.js';
import { CanvasNode, Node, TransformTracker } from '../../scenery/js/imports.js';
import Tandem from '../../tandem/js/Tandem.js';
import vegas from './vegas.js';

// constants
const DEBUG_CANVAS_NODE_BOUNDS = false; // shows a gray rectangle for the CanvasNode to help ensure that its bounds are accurate
const MAX_SPEED = 200; // The maximum speed an image can fall in screen pixels per second.

// Data structure to hold a cached HTMLImageElement and its associated properties.
// Data structure that describes each individual image that you see animating.
export default class RewardNode extends CanvasNode {
  // See SelfOptions.nodes

  // See SelfOptions.scaleForResolution

  // Data structure for each cached image.

  // Data structure for each image that is draw in the reward. Set by initialize, so it's not readonly.

  // Bounds in which to render the canvas, which represents the full window. See below for how this is computed based
  // on ScreenView bounds and relative transforms. Set by initialize, so it's not readonly.
  // Will watch the transform of Nodes along the Trail to this Node so that we can update the canvasDisplayBounds
  // when the RewardNode or any of its ancestors has a change in transform. Set by initialize, so it's not readonly.
  // Set by initialize, so not readonly.
  // If you provide RewardNodeOptions.stepEmitter, it will call this method to drive animation
  // For PhET-iO brand only: make sure this Node is initialized when state is being set for PhET-iO
  constructor(providedOptions) {
    const options = optionize()({
      // SelfOptions
      nodes: null,
      scaleForResolution: 2,
      stepEmitter: null
    }, providedOptions);
    super(options);
    this.scaleForResolution = options.scaleForResolution;
    this.rewardImages = [];
    this.canvasDisplayBounds = new Bounds2(0, 0, 0, 0);
    this.transformTracker = null;
    this.isInitialized = false;
    this.stepEmitterListener = dt => this.step(dt);
    options.stepEmitter && options.stepEmitter.addListener(this.stepEmitterListener);

    // Use the provided Nodes, or create defaults.
    this.nodes = options.nodes || RewardNode.createRandomNodes([new FaceNode(40, {
      headStroke: 'black',
      headLineWidth: 1.5
    }), new StarNode()], 150);

    // For each unique Node, cache its rasterized image.
    this.cachedImages = _.uniq(this.nodes).map(node => {
      const cachedImage = {
        image: null,
        node: node,
        width: node.width,
        height: node.height
      };
      const parent = new Node({
        children: [node],
        scale: this.scaleForResolution
      });
      parent.toImage(image => {
        cachedImage.image = image;
        parent.dispose(); // not needed anymore, see https://github.com/phetsims/area-model-common/issues/128
      });

      return cachedImage;
    });
    this.initializer = () => this.initialize();
    Tandem.PHET_IO_ENABLED && phet.phetio.phetioEngine.phetioStateEngine.stateSetEmitter.addListener(this.initializer);
    this.disposeRewardNode = () => {
      options.stepEmitter && options.stepEmitter.removeListener(this.stepEmitterListener);
      this.transformTracker && this.transformTracker.dispose();
      Tandem.PHET_IO_ENABLED && phet.phetio.phetioEngine.phetioStateEngine.stateSetEmitter.removeListener(this.initializer);
    };
  }
  dispose() {
    this.disposeRewardNode();
    super.dispose();
  }

  /**
   * Paint the rewards on the canvas.
   */
  paintCanvas(context) {
    // If the debugging flag is on, show the bounds of the canvas
    if (DEBUG_CANVAS_NODE_BOUNDS) {
      const bounds = this.canvasDisplayBounds;

      // Fill the canvas with gray
      context.fillStyle = 'rgba(50,50,50,0.5)';
      context.fillRect(bounds.minX, bounds.minY, bounds.width, bounds.height);

      // Stroke the canvas border with blue
      context.strokeStyle = '#0000ff';
      context.lineWidth = 5;
      context.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height);
    }
    context.scale(1 / this.scaleForResolution, 1 / this.scaleForResolution);

    // Display the rewards.
    this.rewardImages.forEach(reward => {
      if (reward.cachedImage.image) {
        context.drawImage(reward.cachedImage.image, reward.x, reward.y);
      }
    });
  }

  /**
   * Finds the first parent that is a ScreenView, so we can listen for its transform,
   * see https://github.com/phetsims/vegas/issues/4
   */
  getScreenView() {
    return this.getUniqueTrail(node => node instanceof ScreenView).rootNode();
  }

  /**
   * Only initialize after being attached to the scene graph, since we must ascertain the local bounds are such that
   * they take up the global screen. Do not move the RewardNode in the scene graph after calling initialize.
   *
   * 1. Listen to the size of the scene/display.
   * 2. Record the trail between the scene and your CanvasNode, and
   * 3. Apply the inverse of that transform to the CanvasNode (whenever an ancestor's transform changes, or when the
   *    scene/display size changes).
   *
   * @jonathanolson said: For implementing now, I'd watch the iso transform, compute the inverse, and set bounds on
   * changes to be precise (since you need them anyways to draw).
   */
  initialize() {
    const display = getGlobal('phet.joist.display');
    if (!this.isInitialized && this.getUniqueTrail().length > 0) {
      const uniqueTrail = this.getUniqueTrail();
      const indexOfScreenView = uniqueTrail.nodes.indexOf(this.getScreenView());
      const trailFromScreenViewToThis = uniqueTrail.slice(indexOfScreenView);

      // Listen to the bounds of the scene, so the canvas can be resized if the window is reshaped.
      const updateBounds = () => {
        assert && assert(this.getUniqueTrail().equals(uniqueTrail), 'Do not move the RewardNode in the scene graph after calling initialize or the transformation may break.');

        // These bounds represent the full window relative to the scene. It is transformed by the inverse of the
        // ScreenView's matrix (globalToLocalBounds) because the RewardNode is meant to fill the ScreenView. RewardNode
        // nodes are placed within these bounds.
        this.canvasDisplayBounds = trailFromScreenViewToThis.globalToLocalBounds(display.bounds);
        const local = this.globalToLocalBounds(display.bounds);
        this.setCanvasBounds(local);
      };
      this.transformTracker = new TransformTracker(uniqueTrail);
      this.transformTracker.addListener(updateBounds);

      // Set the initial bounds.
      updateBounds();

      // Initialize, now that we have bounds.
      this.rewardImages = this.nodes.map(node => {
        // Find the cachedImage that corresponds to the node
        const cachedImage = _.find(this.cachedImages, cachedImage => cachedImage.node === node);
        const reward = {
          cachedImage: cachedImage,
          x: this.randomX(cachedImage.width),
          y: this.randomY(cachedImage.height),
          speed: (dotRandom.nextDouble() + 1) * MAX_SPEED
        };
        return reward;
      });
      this.isInitialized = true;
    }
  }

  /**
   * Selects a random X value for the image when it is created.
   */
  randomX(nodeWidth) {
    return (dotRandom.nextDouble() * this.canvasDisplayBounds.width + this.canvasDisplayBounds.left) * this.scaleForResolution - nodeWidth / 2;
  }

  /**
   * Selects a random Y value for the image when it is created, or when it goes back to the top of the screen.
   * This start about 1 second off the top of the screen
   */
  randomY(nodeHeight) {
    return this.canvasDisplayBounds.top - dotRandom.nextDouble() * this.canvasDisplayBounds.height * 2 - MAX_SPEED - nodeHeight;
  }

  /**
   * Animates the images.
   */
  step(dt) {
    this.initialize();
    const maxY = this.canvasDisplayBounds.height * this.scaleForResolution;

    // Move all images.
    this.rewardImages.forEach(reward => {
      // Move each image straight down at constant speed.
      reward.y += reward.speed * dt;

      // Move back to the top after the image falls off the bottom.
      if (reward.y > maxY) {
        reward.x = this.randomX(reward.cachedImage.width);
        reward.y = this.randomY(reward.cachedImage.height);
      }
    });
    this.invalidatePaint();
  }

  /**
   * Convenience factory method to create an array of the specified Nodes in an even distribution.
   */
  static createRandomNodes(nodes, count) {
    const array = [];
    for (let i = 0; i < count; i++) {
      array.push(nodes[i % nodes.length]);
    }
    return array;
  }
}
vegas.register('RewardNode', RewardNode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCb3VuZHMyIiwiZG90UmFuZG9tIiwiU2NyZWVuVmlldyIsImdldEdsb2JhbCIsIm9wdGlvbml6ZSIsIkZhY2VOb2RlIiwiU3Rhck5vZGUiLCJDYW52YXNOb2RlIiwiTm9kZSIsIlRyYW5zZm9ybVRyYWNrZXIiLCJUYW5kZW0iLCJ2ZWdhcyIsIkRFQlVHX0NBTlZBU19OT0RFX0JPVU5EUyIsIk1BWF9TUEVFRCIsIlJld2FyZE5vZGUiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJub2RlcyIsInNjYWxlRm9yUmVzb2x1dGlvbiIsInN0ZXBFbWl0dGVyIiwicmV3YXJkSW1hZ2VzIiwiY2FudmFzRGlzcGxheUJvdW5kcyIsInRyYW5zZm9ybVRyYWNrZXIiLCJpc0luaXRpYWxpemVkIiwic3RlcEVtaXR0ZXJMaXN0ZW5lciIsImR0Iiwic3RlcCIsImFkZExpc3RlbmVyIiwiY3JlYXRlUmFuZG9tTm9kZXMiLCJoZWFkU3Ryb2tlIiwiaGVhZExpbmVXaWR0aCIsImNhY2hlZEltYWdlcyIsIl8iLCJ1bmlxIiwibWFwIiwibm9kZSIsImNhY2hlZEltYWdlIiwiaW1hZ2UiLCJ3aWR0aCIsImhlaWdodCIsInBhcmVudCIsImNoaWxkcmVuIiwic2NhbGUiLCJ0b0ltYWdlIiwiZGlzcG9zZSIsImluaXRpYWxpemVyIiwiaW5pdGlhbGl6ZSIsIlBIRVRfSU9fRU5BQkxFRCIsInBoZXQiLCJwaGV0aW8iLCJwaGV0aW9FbmdpbmUiLCJwaGV0aW9TdGF0ZUVuZ2luZSIsInN0YXRlU2V0RW1pdHRlciIsImRpc3Bvc2VSZXdhcmROb2RlIiwicmVtb3ZlTGlzdGVuZXIiLCJwYWludENhbnZhcyIsImNvbnRleHQiLCJib3VuZHMiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsIm1pblgiLCJtaW5ZIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2VSZWN0IiwiZm9yRWFjaCIsInJld2FyZCIsImRyYXdJbWFnZSIsIngiLCJ5IiwiZ2V0U2NyZWVuVmlldyIsImdldFVuaXF1ZVRyYWlsIiwicm9vdE5vZGUiLCJkaXNwbGF5IiwibGVuZ3RoIiwidW5pcXVlVHJhaWwiLCJpbmRleE9mU2NyZWVuVmlldyIsImluZGV4T2YiLCJ0cmFpbEZyb21TY3JlZW5WaWV3VG9UaGlzIiwic2xpY2UiLCJ1cGRhdGVCb3VuZHMiLCJhc3NlcnQiLCJlcXVhbHMiLCJnbG9iYWxUb0xvY2FsQm91bmRzIiwibG9jYWwiLCJzZXRDYW52YXNCb3VuZHMiLCJmaW5kIiwicmFuZG9tWCIsInJhbmRvbVkiLCJzcGVlZCIsIm5leHREb3VibGUiLCJub2RlV2lkdGgiLCJsZWZ0Iiwibm9kZUhlaWdodCIsInRvcCIsIm1heFkiLCJpbnZhbGlkYXRlUGFpbnQiLCJjb3VudCIsImFycmF5IiwiaSIsInB1c2giLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlJld2FyZE5vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTQtMjAyMiwgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogUmV3YXJkIG5vZGUgdGhhdCBzaG93cyBtYW55IG5vZGVzIGFuaW1hdGluZyBjb250aW51b3VzbHksIGZvciBmdW4hICBTaG93biB3aGVuIGEgcGVyZmVjdCBzY29yZSBpcyBhY2hpZXZlZCBpbiBhIGdhbWUuXHJcbiAqIFlvdSBjYW4gYWxzbyB0ZXN0IHRoaXMgYnkgcnVubmluZyB2ZWdhcy92ZWdhc19lbi5odG1sIGFuZCBjbGlja2luZyBvbiB0aGUgXCJSZXdhcmRcIiBzY3JlZW4uXHJcbiAqIE5vdGUgdGhhdCB0aGUgbnVtYmVyIG9mIGltYWdlcyBmYWxsaW5nIGlzIGNvbnN0YW50LCBzbyBpZiB0aGUgc2NyZWVuIGlzIHN0cmV0Y2hlZCBvdXQgdmVydGljYWxseSAodGFsbCB0aGluIHdpbmRvdylcclxuICogdGhleSB3aWxsIGJlIGxlc3MgZGVuc2UuXHJcbiAqXHJcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyB0byBydW4gdGhlIGFuaW1hdGlvbiBzdGVwIGZ1bmN0aW9uLiAgVGhlIGNsaWVudCBjb2RlIGNhbiBtYW51YWxseSBjYWxsIHN0ZXAoZHQpLCBvciB0aGUgY2xpZW50XHJcbiAqIGNvZGUgY2FuIHBhc3MgaW4gYW4gRXZlbnRzIGluc3RhbmNlIHRoYXQgdHJpZ2dlcnMgZXZlbnRzIG9uICdzdGVwJy4gSW4gdGhlIGxhdHRlciBjYXNlLCB0aGUgbGlzdGVuZXIgd2lsbFxyXG4gKiBhdXRvbWF0aWNhbGx5IGJlIHJlbW92ZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlxyXG4gKlxyXG4gKiBGb3IgZGV0YWlscyBhYm91dCB0aGUgZGV2ZWxvcG1lbnQgb2YgdGhlIFJld2FyZE5vZGUsIHBsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3ZlZ2FzL2lzc3Vlcy80XHJcbiAqXHJcbiAqIEBhdXRob3IgU2FtIFJlaWQgKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IFRFbWl0dGVyIGZyb20gJy4uLy4uL2F4b24vanMvVEVtaXR0ZXIuanMnO1xyXG5pbXBvcnQgQm91bmRzMiBmcm9tICcuLi8uLi9kb3QvanMvQm91bmRzMi5qcyc7XHJcbmltcG9ydCBkb3RSYW5kb20gZnJvbSAnLi4vLi4vZG90L2pzL2RvdFJhbmRvbS5qcyc7XHJcbmltcG9ydCBTY3JlZW5WaWV3IGZyb20gJy4uLy4uL2pvaXN0L2pzL1NjcmVlblZpZXcuanMnO1xyXG5pbXBvcnQgZ2V0R2xvYmFsIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9nZXRHbG9iYWwuanMnO1xyXG5pbXBvcnQgb3B0aW9uaXplIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9vcHRpb25pemUuanMnO1xyXG5pbXBvcnQgRmFjZU5vZGUgZnJvbSAnLi4vLi4vc2NlbmVyeS1waGV0L2pzL0ZhY2VOb2RlLmpzJztcclxuaW1wb3J0IFN0YXJOb2RlIGZyb20gJy4uLy4uL3NjZW5lcnktcGhldC9qcy9TdGFyTm9kZS5qcyc7XHJcbmltcG9ydCB7IENhbnZhc05vZGUsIENhbnZhc05vZGVPcHRpb25zLCBEaXNwbGF5LCBOb2RlLCBUcmFuc2Zvcm1UcmFja2VyIH0gZnJvbSAnLi4vLi4vc2NlbmVyeS9qcy9pbXBvcnRzLmpzJztcclxuaW1wb3J0IFRhbmRlbSBmcm9tICcuLi8uLi90YW5kZW0vanMvVGFuZGVtLmpzJztcclxuaW1wb3J0IHZlZ2FzIGZyb20gJy4vdmVnYXMuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IERFQlVHX0NBTlZBU19OT0RFX0JPVU5EUyA9IGZhbHNlOyAvLyBzaG93cyBhIGdyYXkgcmVjdGFuZ2xlIGZvciB0aGUgQ2FudmFzTm9kZSB0byBoZWxwIGVuc3VyZSB0aGF0IGl0cyBib3VuZHMgYXJlIGFjY3VyYXRlXHJcbmNvbnN0IE1BWF9TUEVFRCA9IDIwMDsgLy8gVGhlIG1heGltdW0gc3BlZWQgYW4gaW1hZ2UgY2FuIGZhbGwgaW4gc2NyZWVuIHBpeGVscyBwZXIgc2Vjb25kLlxyXG5cclxuLy8gRGF0YSBzdHJ1Y3R1cmUgdG8gaG9sZCBhIGNhY2hlZCBIVE1MSW1hZ2VFbGVtZW50IGFuZCBpdHMgYXNzb2NpYXRlZCBwcm9wZXJ0aWVzLlxyXG50eXBlIENhY2hlZEltYWdlID0ge1xyXG5cclxuICAvLyBUaGUgaW1hZ2UgdG8gYmUgcmVuZGVyZWQgaW4gdGhlIGNhbnZhcywgdG8gYmUgZmlsbGVkIGluIGJ5IHRvSW1hZ2UgY2FsbGJhY2suXHJcbiAgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsO1xyXG5cclxuICAvLyBOb2RlIHRoYXQgdGhlIGNhY2hlZCBpbWFnZXMgaXMgYXNzb2NpYXRlZCB3aXRoXHJcbiAgbm9kZTogTm9kZTtcclxuXHJcbiAgLy8gV2lkdGggYW5kIGhlaWdodCBvZiB0aGUgYXNzb2NpYXRlZCBOb2RlLCBzbyB0aGF0IGltYWdlIGNhbiBiZSBwb3NpdGlvbmVkIGJlZm9yZSB0aGUgdG9JbWFnZSBjYWxsIGhhcyBjb21wbGV0ZWQuXHJcbiAgd2lkdGg6IG51bWJlcjtcclxuICBoZWlnaHQ6IG51bWJlcjtcclxufTtcclxuXHJcbi8vIERhdGEgc3RydWN0dXJlIHRoYXQgZGVzY3JpYmVzIGVhY2ggaW5kaXZpZHVhbCBpbWFnZSB0aGF0IHlvdSBzZWUgYW5pbWF0aW5nLlxyXG50eXBlIFJld2FyZEltYWdlID0ge1xyXG5cclxuICAvLyBEYXRhIHN0cnVjdHVyZSB0aGF0IGRlc2NyaWJlcyB0aGUgaW1hZ2UgdG8gcmVuZGVyXHJcbiAgY2FjaGVkSW1hZ2U6IENhY2hlZEltYWdlO1xyXG5cclxuICAvLyBDdXJyZW50IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIGltYWdlXHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuXHJcbiAgLy8gUmFuZG9tIHNwZWVkIGF0IHdoaWNoIHRvIGFuaW1hdGUgdGhlIGltYWdlXHJcbiAgc3BlZWQ6IG51bWJlcjtcclxufTtcclxuXHJcbnR5cGUgU2VsZk9wdGlvbnMgPSB7XHJcblxyXG4gIC8vIE5vZGVzIHRvIGFwcGVhciBpbiB0aGUgcmV3YXJkIG5vZGUuIFRoZXkgd2lsbCBiZSBjYWNoZWQgYXMgaW1hZ2VzIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXHJcbiAgLy8gSWYgbnVsbCwgdGhlbiBkZWZhdWx0IE5vZGVzIHdpbGwgYmUgY3JlYXRlZC5cclxuICBub2Rlcz86IE5vZGVbXSB8IG51bGw7XHJcblxyXG4gIC8vIFNjYWxlIHRoaW5ncyB1cCBmb3IgcmFzdGVyaXphdGlvbiwgdGhlbiBiYWNrIGRvd24gZm9yIHJlbmRlcmluZywgc28gdGhleSBoYXZlIG5pY2UgcXVhbGl0eSBvbiByZXRpbmEgZGlzcGxheXMuXHJcbiAgc2NhbGVGb3JSZXNvbHV0aW9uPzogbnVtYmVyO1xyXG5cclxuICAvLyBJZiB5b3UgcGFzcyBpbiBhIHN0ZXBFbWl0dGVyIHtFbWl0dGVyfSwgaXQgd2lsbCBkcml2ZSB0aGUgYW5pbWF0aW9uXHJcbiAgc3RlcEVtaXR0ZXI/OiBURW1pdHRlcjxbIG51bWJlciBdPiB8IG51bGw7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBSZXdhcmROb2RlT3B0aW9ucyA9IFNlbGZPcHRpb25zICYgQ2FudmFzTm9kZU9wdGlvbnM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXdhcmROb2RlIGV4dGVuZHMgQ2FudmFzTm9kZSB7XHJcblxyXG4gIC8vIFNlZSBTZWxmT3B0aW9ucy5ub2Rlc1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgbm9kZXM6IE5vZGVbXTtcclxuXHJcbiAgLy8gU2VlIFNlbGZPcHRpb25zLnNjYWxlRm9yUmVzb2x1dGlvblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgc2NhbGVGb3JSZXNvbHV0aW9uOiBudW1iZXI7XHJcblxyXG4gIC8vIERhdGEgc3RydWN0dXJlIGZvciBlYWNoIGNhY2hlZCBpbWFnZS5cclxuICBwcml2YXRlIHJlYWRvbmx5IGNhY2hlZEltYWdlczogQ2FjaGVkSW1hZ2VbXTtcclxuXHJcbiAgLy8gRGF0YSBzdHJ1Y3R1cmUgZm9yIGVhY2ggaW1hZ2UgdGhhdCBpcyBkcmF3IGluIHRoZSByZXdhcmQuIFNldCBieSBpbml0aWFsaXplLCBzbyBpdCdzIG5vdCByZWFkb25seS5cclxuICBwcml2YXRlIHJld2FyZEltYWdlczogUmV3YXJkSW1hZ2VbXTtcclxuXHJcbiAgLy8gQm91bmRzIGluIHdoaWNoIHRvIHJlbmRlciB0aGUgY2FudmFzLCB3aGljaCByZXByZXNlbnRzIHRoZSBmdWxsIHdpbmRvdy4gU2VlIGJlbG93IGZvciBob3cgdGhpcyBpcyBjb21wdXRlZCBiYXNlZFxyXG4gIC8vIG9uIFNjcmVlblZpZXcgYm91bmRzIGFuZCByZWxhdGl2ZSB0cmFuc2Zvcm1zLiBTZXQgYnkgaW5pdGlhbGl6ZSwgc28gaXQncyBub3QgcmVhZG9ubHkuXHJcbiAgcHJpdmF0ZSBjYW52YXNEaXNwbGF5Qm91bmRzOiBCb3VuZHMyO1xyXG5cclxuICAvLyBXaWxsIHdhdGNoIHRoZSB0cmFuc2Zvcm0gb2YgTm9kZXMgYWxvbmcgdGhlIFRyYWlsIHRvIHRoaXMgTm9kZSBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIGNhbnZhc0Rpc3BsYXlCb3VuZHNcclxuICAvLyB3aGVuIHRoZSBSZXdhcmROb2RlIG9yIGFueSBvZiBpdHMgYW5jZXN0b3JzIGhhcyBhIGNoYW5nZSBpbiB0cmFuc2Zvcm0uIFNldCBieSBpbml0aWFsaXplLCBzbyBpdCdzIG5vdCByZWFkb25seS5cclxuICBwcml2YXRlIHRyYW5zZm9ybVRyYWNrZXI6IFRyYW5zZm9ybVRyYWNrZXIgfCBudWxsO1xyXG5cclxuICAvLyBTZXQgYnkgaW5pdGlhbGl6ZSwgc28gbm90IHJlYWRvbmx5LlxyXG4gIHByaXZhdGUgaXNJbml0aWFsaXplZDogYm9vbGVhbjtcclxuXHJcbiAgLy8gSWYgeW91IHByb3ZpZGUgUmV3YXJkTm9kZU9wdGlvbnMuc3RlcEVtaXR0ZXIsIGl0IHdpbGwgY2FsbCB0aGlzIG1ldGhvZCB0byBkcml2ZSBhbmltYXRpb25cclxuICBwcml2YXRlIHJlYWRvbmx5IHN0ZXBFbWl0dGVyTGlzdGVuZXI6ICggZHQ6IG51bWJlciApID0+IHZvaWQ7XHJcblxyXG4gIC8vIEZvciBQaEVULWlPIGJyYW5kIG9ubHk6IG1ha2Ugc3VyZSB0aGlzIE5vZGUgaXMgaW5pdGlhbGl6ZWQgd2hlbiBzdGF0ZSBpcyBiZWluZyBzZXQgZm9yIFBoRVQtaU9cclxuICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxpemVyOiAoKSA9PiB2b2lkO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGRpc3Bvc2VSZXdhcmROb2RlOiAoKSA9PiB2b2lkO1xyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3IoIHByb3ZpZGVkT3B0aW9ucz86IFJld2FyZE5vZGVPcHRpb25zICkge1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25pemU8UmV3YXJkTm9kZU9wdGlvbnMsIFNlbGZPcHRpb25zLCBDYW52YXNOb2RlT3B0aW9ucz4oKSgge1xyXG5cclxuICAgICAgLy8gU2VsZk9wdGlvbnNcclxuICAgICAgbm9kZXM6IG51bGwsXHJcbiAgICAgIHNjYWxlRm9yUmVzb2x1dGlvbjogMixcclxuICAgICAgc3RlcEVtaXR0ZXI6IG51bGxcclxuICAgIH0sIHByb3ZpZGVkT3B0aW9ucyApO1xyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy5zY2FsZUZvclJlc29sdXRpb24gPSBvcHRpb25zLnNjYWxlRm9yUmVzb2x1dGlvbjtcclxuICAgIHRoaXMucmV3YXJkSW1hZ2VzID0gW107XHJcbiAgICB0aGlzLmNhbnZhc0Rpc3BsYXlCb3VuZHMgPSBuZXcgQm91bmRzMiggMCwgMCwgMCwgMCApO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1UcmFja2VyID0gbnVsbDtcclxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuc3RlcEVtaXR0ZXJMaXN0ZW5lciA9ICggZHQ6IG51bWJlciApID0+IHRoaXMuc3RlcCggZHQgKTtcclxuICAgIG9wdGlvbnMuc3RlcEVtaXR0ZXIgJiYgb3B0aW9ucy5zdGVwRW1pdHRlci5hZGRMaXN0ZW5lciggdGhpcy5zdGVwRW1pdHRlckxpc3RlbmVyICk7XHJcblxyXG4gICAgLy8gVXNlIHRoZSBwcm92aWRlZCBOb2Rlcywgb3IgY3JlYXRlIGRlZmF1bHRzLlxyXG4gICAgdGhpcy5ub2RlcyA9IG9wdGlvbnMubm9kZXMgfHwgUmV3YXJkTm9kZS5jcmVhdGVSYW5kb21Ob2RlcyggW1xyXG4gICAgICBuZXcgRmFjZU5vZGUoIDQwLCB7IGhlYWRTdHJva2U6ICdibGFjaycsIGhlYWRMaW5lV2lkdGg6IDEuNSB9ICksXHJcbiAgICAgIG5ldyBTdGFyTm9kZSgpXHJcbiAgICBdLCAxNTAgKTtcclxuXHJcbiAgICAvLyBGb3IgZWFjaCB1bmlxdWUgTm9kZSwgY2FjaGUgaXRzIHJhc3Rlcml6ZWQgaW1hZ2UuXHJcbiAgICB0aGlzLmNhY2hlZEltYWdlcyA9IF8udW5pcSggdGhpcy5ub2RlcyApLm1hcCggbm9kZSA9PiB7XHJcblxyXG4gICAgICBjb25zdCBjYWNoZWRJbWFnZTogQ2FjaGVkSW1hZ2UgPSB7XHJcbiAgICAgICAgaW1hZ2U6IG51bGwsXHJcbiAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICB3aWR0aDogbm9kZS53aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBwYXJlbnQgPSBuZXcgTm9kZSgge1xyXG4gICAgICAgIGNoaWxkcmVuOiBbIG5vZGUgXSxcclxuICAgICAgICBzY2FsZTogdGhpcy5zY2FsZUZvclJlc29sdXRpb25cclxuICAgICAgfSApO1xyXG5cclxuICAgICAgcGFyZW50LnRvSW1hZ2UoIGltYWdlID0+IHtcclxuICAgICAgICBjYWNoZWRJbWFnZS5pbWFnZSA9IGltYWdlO1xyXG4gICAgICAgIHBhcmVudC5kaXNwb3NlKCk7IC8vIG5vdCBuZWVkZWQgYW55bW9yZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9hcmVhLW1vZGVsLWNvbW1vbi9pc3N1ZXMvMTI4XHJcbiAgICAgIH0gKTtcclxuXHJcbiAgICAgIHJldHVybiBjYWNoZWRJbWFnZTtcclxuICAgIH0gKTtcclxuXHJcbiAgICB0aGlzLmluaXRpYWxpemVyID0gKCkgPT4gdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgICBUYW5kZW0uUEhFVF9JT19FTkFCTEVEICYmIHBoZXQucGhldGlvLnBoZXRpb0VuZ2luZS5waGV0aW9TdGF0ZUVuZ2luZS5zdGF0ZVNldEVtaXR0ZXIuYWRkTGlzdGVuZXIoIHRoaXMuaW5pdGlhbGl6ZXIgKTtcclxuXHJcbiAgICB0aGlzLmRpc3Bvc2VSZXdhcmROb2RlID0gKCkgPT4ge1xyXG4gICAgICBvcHRpb25zLnN0ZXBFbWl0dGVyICYmIG9wdGlvbnMuc3RlcEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoIHRoaXMuc3RlcEVtaXR0ZXJMaXN0ZW5lciApO1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybVRyYWNrZXIgJiYgdGhpcy50cmFuc2Zvcm1UcmFja2VyLmRpc3Bvc2UoKTtcclxuICAgICAgVGFuZGVtLlBIRVRfSU9fRU5BQkxFRCAmJiBwaGV0LnBoZXRpby5waGV0aW9FbmdpbmUucGhldGlvU3RhdGVFbmdpbmUuc3RhdGVTZXRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCB0aGlzLmluaXRpYWxpemVyICk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG92ZXJyaWRlIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLmRpc3Bvc2VSZXdhcmROb2RlKCk7XHJcbiAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYWludCB0aGUgcmV3YXJkcyBvbiB0aGUgY2FudmFzLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBwYWludENhbnZhcyggY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICk6IHZvaWQge1xyXG5cclxuICAgIC8vIElmIHRoZSBkZWJ1Z2dpbmcgZmxhZyBpcyBvbiwgc2hvdyB0aGUgYm91bmRzIG9mIHRoZSBjYW52YXNcclxuICAgIGlmICggREVCVUdfQ0FOVkFTX05PREVfQk9VTkRTICkge1xyXG4gICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmNhbnZhc0Rpc3BsYXlCb3VuZHM7XHJcblxyXG4gICAgICAvLyBGaWxsIHRoZSBjYW52YXMgd2l0aCBncmF5XHJcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoNTAsNTAsNTAsMC41KSc7XHJcbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoIGJvdW5kcy5taW5YLCBib3VuZHMubWluWSwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0ICk7XHJcblxyXG4gICAgICAvLyBTdHJva2UgdGhlIGNhbnZhcyBib3JkZXIgd2l0aCBibHVlXHJcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnIzAwMDBmZic7XHJcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gNTtcclxuICAgICAgY29udGV4dC5zdHJva2VSZWN0KCBib3VuZHMubWluWCwgYm91bmRzLm1pblksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRleHQuc2NhbGUoIDEgLyB0aGlzLnNjYWxlRm9yUmVzb2x1dGlvbiwgMSAvIHRoaXMuc2NhbGVGb3JSZXNvbHV0aW9uICk7XHJcblxyXG4gICAgLy8gRGlzcGxheSB0aGUgcmV3YXJkcy5cclxuICAgIHRoaXMucmV3YXJkSW1hZ2VzLmZvckVhY2goIHJld2FyZCA9PiB7XHJcbiAgICAgIGlmICggcmV3YXJkLmNhY2hlZEltYWdlLmltYWdlICkge1xyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCByZXdhcmQuY2FjaGVkSW1hZ2UuaW1hZ2UsIHJld2FyZC54LCByZXdhcmQueSApO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kcyB0aGUgZmlyc3QgcGFyZW50IHRoYXQgaXMgYSBTY3JlZW5WaWV3LCBzbyB3ZSBjYW4gbGlzdGVuIGZvciBpdHMgdHJhbnNmb3JtLFxyXG4gICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvdmVnYXMvaXNzdWVzLzRcclxuICAgKi9cclxuICBwcml2YXRlIGdldFNjcmVlblZpZXcoKTogTm9kZSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRVbmlxdWVUcmFpbCggbm9kZSA9PiBub2RlIGluc3RhbmNlb2YgU2NyZWVuVmlldyApLnJvb3ROb2RlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPbmx5IGluaXRpYWxpemUgYWZ0ZXIgYmVpbmcgYXR0YWNoZWQgdG8gdGhlIHNjZW5lIGdyYXBoLCBzaW5jZSB3ZSBtdXN0IGFzY2VydGFpbiB0aGUgbG9jYWwgYm91bmRzIGFyZSBzdWNoIHRoYXRcclxuICAgKiB0aGV5IHRha2UgdXAgdGhlIGdsb2JhbCBzY3JlZW4uIERvIG5vdCBtb3ZlIHRoZSBSZXdhcmROb2RlIGluIHRoZSBzY2VuZSBncmFwaCBhZnRlciBjYWxsaW5nIGluaXRpYWxpemUuXHJcbiAgICpcclxuICAgKiAxLiBMaXN0ZW4gdG8gdGhlIHNpemUgb2YgdGhlIHNjZW5lL2Rpc3BsYXkuXHJcbiAgICogMi4gUmVjb3JkIHRoZSB0cmFpbCBiZXR3ZWVuIHRoZSBzY2VuZSBhbmQgeW91ciBDYW52YXNOb2RlLCBhbmRcclxuICAgKiAzLiBBcHBseSB0aGUgaW52ZXJzZSBvZiB0aGF0IHRyYW5zZm9ybSB0byB0aGUgQ2FudmFzTm9kZSAod2hlbmV2ZXIgYW4gYW5jZXN0b3IncyB0cmFuc2Zvcm0gY2hhbmdlcywgb3Igd2hlbiB0aGVcclxuICAgKiAgICBzY2VuZS9kaXNwbGF5IHNpemUgY2hhbmdlcykuXHJcbiAgICpcclxuICAgKiBAam9uYXRoYW5vbHNvbiBzYWlkOiBGb3IgaW1wbGVtZW50aW5nIG5vdywgSSdkIHdhdGNoIHRoZSBpc28gdHJhbnNmb3JtLCBjb21wdXRlIHRoZSBpbnZlcnNlLCBhbmQgc2V0IGJvdW5kcyBvblxyXG4gICAqIGNoYW5nZXMgdG8gYmUgcHJlY2lzZSAoc2luY2UgeW91IG5lZWQgdGhlbSBhbnl3YXlzIHRvIGRyYXcpLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgaW5pdGlhbGl6ZSgpOiB2b2lkIHtcclxuXHJcbiAgICBjb25zdCBkaXNwbGF5OiBEaXNwbGF5ID0gZ2V0R2xvYmFsKCAncGhldC5qb2lzdC5kaXNwbGF5JyApO1xyXG5cclxuICAgIGlmICggIXRoaXMuaXNJbml0aWFsaXplZCAmJiB0aGlzLmdldFVuaXF1ZVRyYWlsKCkubGVuZ3RoID4gMCApIHtcclxuXHJcbiAgICAgIGNvbnN0IHVuaXF1ZVRyYWlsID0gdGhpcy5nZXRVbmlxdWVUcmFpbCgpO1xyXG4gICAgICBjb25zdCBpbmRleE9mU2NyZWVuVmlldyA9IHVuaXF1ZVRyYWlsLm5vZGVzLmluZGV4T2YoIHRoaXMuZ2V0U2NyZWVuVmlldygpICk7XHJcbiAgICAgIGNvbnN0IHRyYWlsRnJvbVNjcmVlblZpZXdUb1RoaXMgPSB1bmlxdWVUcmFpbC5zbGljZSggaW5kZXhPZlNjcmVlblZpZXcgKTtcclxuXHJcbiAgICAgIC8vIExpc3RlbiB0byB0aGUgYm91bmRzIG9mIHRoZSBzY2VuZSwgc28gdGhlIGNhbnZhcyBjYW4gYmUgcmVzaXplZCBpZiB0aGUgd2luZG93IGlzIHJlc2hhcGVkLlxyXG4gICAgICBjb25zdCB1cGRhdGVCb3VuZHMgPSAoKSA9PiB7XHJcbiAgICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdGhpcy5nZXRVbmlxdWVUcmFpbCgpLmVxdWFscyggdW5pcXVlVHJhaWwgKSxcclxuICAgICAgICAgICdEbyBub3QgbW92ZSB0aGUgUmV3YXJkTm9kZSBpbiB0aGUgc2NlbmUgZ3JhcGggYWZ0ZXIgY2FsbGluZyBpbml0aWFsaXplIG9yIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXkgYnJlYWsuJyApO1xyXG5cclxuICAgICAgICAvLyBUaGVzZSBib3VuZHMgcmVwcmVzZW50IHRoZSBmdWxsIHdpbmRvdyByZWxhdGl2ZSB0byB0aGUgc2NlbmUuIEl0IGlzIHRyYW5zZm9ybWVkIGJ5IHRoZSBpbnZlcnNlIG9mIHRoZVxyXG4gICAgICAgIC8vIFNjcmVlblZpZXcncyBtYXRyaXggKGdsb2JhbFRvTG9jYWxCb3VuZHMpIGJlY2F1c2UgdGhlIFJld2FyZE5vZGUgaXMgbWVhbnQgdG8gZmlsbCB0aGUgU2NyZWVuVmlldy4gUmV3YXJkTm9kZVxyXG4gICAgICAgIC8vIG5vZGVzIGFyZSBwbGFjZWQgd2l0aGluIHRoZXNlIGJvdW5kcy5cclxuICAgICAgICB0aGlzLmNhbnZhc0Rpc3BsYXlCb3VuZHMgPSB0cmFpbEZyb21TY3JlZW5WaWV3VG9UaGlzLmdsb2JhbFRvTG9jYWxCb3VuZHMoIGRpc3BsYXkuYm91bmRzICk7XHJcblxyXG4gICAgICAgIGNvbnN0IGxvY2FsID0gdGhpcy5nbG9iYWxUb0xvY2FsQm91bmRzKCBkaXNwbGF5LmJvdW5kcyApO1xyXG4gICAgICAgIHRoaXMuc2V0Q2FudmFzQm91bmRzKCBsb2NhbCApO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy50cmFuc2Zvcm1UcmFja2VyID0gbmV3IFRyYW5zZm9ybVRyYWNrZXIoIHVuaXF1ZVRyYWlsICk7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtVHJhY2tlci5hZGRMaXN0ZW5lciggdXBkYXRlQm91bmRzICk7XHJcblxyXG4gICAgICAvLyBTZXQgdGhlIGluaXRpYWwgYm91bmRzLlxyXG4gICAgICB1cGRhdGVCb3VuZHMoKTtcclxuXHJcbiAgICAgIC8vIEluaXRpYWxpemUsIG5vdyB0aGF0IHdlIGhhdmUgYm91bmRzLlxyXG4gICAgICB0aGlzLnJld2FyZEltYWdlcyA9IHRoaXMubm9kZXMubWFwKCBub2RlID0+IHtcclxuXHJcbiAgICAgICAgLy8gRmluZCB0aGUgY2FjaGVkSW1hZ2UgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgbm9kZVxyXG4gICAgICAgIGNvbnN0IGNhY2hlZEltYWdlID0gXy5maW5kKCB0aGlzLmNhY2hlZEltYWdlcywgY2FjaGVkSW1hZ2UgPT4gY2FjaGVkSW1hZ2Uubm9kZSA9PT0gbm9kZSApITtcclxuXHJcbiAgICAgICAgY29uc3QgcmV3YXJkOiBSZXdhcmRJbWFnZSA9IHtcclxuICAgICAgICAgIGNhY2hlZEltYWdlOiBjYWNoZWRJbWFnZSxcclxuICAgICAgICAgIHg6IHRoaXMucmFuZG9tWCggY2FjaGVkSW1hZ2Uud2lkdGggKSxcclxuICAgICAgICAgIHk6IHRoaXMucmFuZG9tWSggY2FjaGVkSW1hZ2UuaGVpZ2h0ICksXHJcbiAgICAgICAgICBzcGVlZDogKCBkb3RSYW5kb20ubmV4dERvdWJsZSgpICsgMSApICogTUFYX1NQRUVEXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJld2FyZDtcclxuICAgICAgfSApO1xyXG5cclxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdHMgYSByYW5kb20gWCB2YWx1ZSBmb3IgdGhlIGltYWdlIHdoZW4gaXQgaXMgY3JlYXRlZC5cclxuICAgKi9cclxuICBwcml2YXRlIHJhbmRvbVgoIG5vZGVXaWR0aDogbnVtYmVyICk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gKCBkb3RSYW5kb20ubmV4dERvdWJsZSgpICogdGhpcy5jYW52YXNEaXNwbGF5Qm91bmRzLndpZHRoICsgdGhpcy5jYW52YXNEaXNwbGF5Qm91bmRzLmxlZnQgKSAqXHJcbiAgICAgICAgICAgdGhpcy5zY2FsZUZvclJlc29sdXRpb24gLSBub2RlV2lkdGggLyAyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0cyBhIHJhbmRvbSBZIHZhbHVlIGZvciB0aGUgaW1hZ2Ugd2hlbiBpdCBpcyBjcmVhdGVkLCBvciB3aGVuIGl0IGdvZXMgYmFjayB0byB0aGUgdG9wIG9mIHRoZSBzY3JlZW4uXHJcbiAgICogVGhpcyBzdGFydCBhYm91dCAxIHNlY29uZCBvZmYgdGhlIHRvcCBvZiB0aGUgc2NyZWVuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSByYW5kb21ZKCBub2RlSGVpZ2h0OiBudW1iZXIgKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNhbnZhc0Rpc3BsYXlCb3VuZHMudG9wIC0gZG90UmFuZG9tLm5leHREb3VibGUoKSAqIHRoaXMuY2FudmFzRGlzcGxheUJvdW5kcy5oZWlnaHQgKiAyIC1cclxuICAgICAgICAgICBNQVhfU1BFRUQgLSBub2RlSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5pbWF0ZXMgdGhlIGltYWdlcy5cclxuICAgKi9cclxuICBwdWJsaWMgc3RlcCggZHQ6IG51bWJlciApOiB2b2lkIHtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgIGNvbnN0IG1heFkgPSB0aGlzLmNhbnZhc0Rpc3BsYXlCb3VuZHMuaGVpZ2h0ICogdGhpcy5zY2FsZUZvclJlc29sdXRpb247XHJcblxyXG4gICAgLy8gTW92ZSBhbGwgaW1hZ2VzLlxyXG4gICAgdGhpcy5yZXdhcmRJbWFnZXMuZm9yRWFjaCggcmV3YXJkID0+IHtcclxuXHJcbiAgICAgIC8vIE1vdmUgZWFjaCBpbWFnZSBzdHJhaWdodCBkb3duIGF0IGNvbnN0YW50IHNwZWVkLlxyXG4gICAgICByZXdhcmQueSArPSByZXdhcmQuc3BlZWQgKiBkdDtcclxuXHJcbiAgICAgIC8vIE1vdmUgYmFjayB0byB0aGUgdG9wIGFmdGVyIHRoZSBpbWFnZSBmYWxscyBvZmYgdGhlIGJvdHRvbS5cclxuICAgICAgaWYgKCByZXdhcmQueSA+IG1heFkgKSB7XHJcbiAgICAgICAgcmV3YXJkLnggPSB0aGlzLnJhbmRvbVgoIHJld2FyZC5jYWNoZWRJbWFnZS53aWR0aCApO1xyXG4gICAgICAgIHJld2FyZC55ID0gdGhpcy5yYW5kb21ZKCByZXdhcmQuY2FjaGVkSW1hZ2UuaGVpZ2h0ICk7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICB0aGlzLmludmFsaWRhdGVQYWludCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVuaWVuY2UgZmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGFuIGFycmF5IG9mIHRoZSBzcGVjaWZpZWQgTm9kZXMgaW4gYW4gZXZlbiBkaXN0cmlidXRpb24uXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVSYW5kb21Ob2Rlcyggbm9kZXM6IE5vZGVbXSwgY291bnQ6IG51bWJlciApOiBOb2RlW10ge1xyXG4gICAgY29uc3QgYXJyYXkgPSBbXTtcclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGNvdW50OyBpKysgKSB7XHJcbiAgICAgIGFycmF5LnB1c2goIG5vZGVzWyBpICUgbm9kZXMubGVuZ3RoIF0gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheTtcclxuICB9XHJcbn1cclxuXHJcbnZlZ2FzLnJlZ2lzdGVyKCAnUmV3YXJkTm9kZScsIFJld2FyZE5vZGUgKTsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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