// Copyright 2018-2023, University of Colorado Boulder

/**
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */

import StringUtils from '../../../../phetcommon/js/util/StringUtils.js';
import Alerter from '../../../../scenery-phet/js/accessibility/describers/Alerter.js';
import ResponsePacket from '../../../../utterance-queue/js/ResponsePacket.js';
import Utterance from '../../../../utterance-queue/js/Utterance.js';
import friction from '../../friction.js';
import FrictionStrings from '../../FrictionStrings.js';
import FrictionModel from '../model/FrictionModel.js';

// constants
const jigglingLessString = FrictionStrings.a11y.jiggle.jigglingLess;
const coolerString = FrictionStrings.a11y.temperature.cooler;
const nowCoolerString = FrictionStrings.a11y.temperature.nowCooler;
const lessString = FrictionStrings.a11y.jiggle.less;
const evenLessString = FrictionStrings.a11y.jiggle.evenLess;
const evenCoolerString = FrictionStrings.a11y.temperature.evenCooler;
const frictionIncreasingAtomsJigglingTemperatureFirstPatternString = FrictionStrings.a11y.frictionIncreasingAtomsJigglingTemperatureFirstPattern;
const frictionIncreasingAtomsJigglingTemperaturePatternString = FrictionStrings.a11y.frictionIncreasingAtomsJigglingTemperaturePattern;
const DECREASING = [{
  jiggle: lessString,
  temp: coolerString,
  firstTime: {
    jiggle: jigglingLessString,
    temp: coolerString
  }
}, {
  jiggle: lessString,
  temp: nowCoolerString
}, {
  jiggle: evenLessString,
  temp: evenCoolerString
}];

// From model, the amplitude value when the atoms shear off
const SHEARING_LIMIT = FrictionModel.MAGNIFIED_ATOMS_INFO.shearingLimit;

// How long in between each subsequent decreasing alert
const ALERT_TIME_DELAY = 3000;

// The amount of amplitude that the model must decrease from the last point where it was increasing. This value
// is to help with minor fluctuations as the model "cools" itself every step even while friction is generally increasing.
// In same units as FrictionModel's amplitude
const AMPLITUDE_DECREASING_THRESHOLD = 1;
class TemperatureDecreasingAlerter extends Alerter {
  /**
   * Responsible for alerting when the temperature decreases
   * @param {FrictionModel} model
   * @param {Object} [options]
   */
  constructor(model, options) {
    super(options);

    // decides whether or not this describer is enabled basically.
    // just manages whether or not we are checking to see if the threshold is increasing enough
    // @public
    this.tempDecreasing = false;

    // @private
    this.model = model;

    // @private
    // This keeps track of the time since the last decreasing alert was made
    this.timeOfLastAlert = 0;

    // zero indexed, so the first one is 0
    this.alertIndex = -1;

    // Keep track of the last highest amplitude when it was increasing. This value is reset everytime the oldAmplitude
    // is less that the new amplitude.
    // @private
    let lastAmplitudeWhenIncreasing = model.vibrationAmplitudeProperty.value;

    // Different alert for the very first decrease alert we have for the lifetime of the sim
    // @private
    this.firstAlert = true;

    // @private
    this.amplitudeListener = (amplitude, oldAmplitude) => {
      // if ever we increase amplitude, make it the new maximum to compare against when determining if we are "decreasing in temp"
      if (amplitude > oldAmplitude) {
        lastAmplitudeWhenIncreasing = amplitude;
      }

      // manage which way th temp is going
      this.tempDecreasing = lastAmplitudeWhenIncreasing - amplitude > AMPLITUDE_DECREASING_THRESHOLD;

      // we consider it "settled" at this threshold
      if (amplitude < FrictionModel.AMPLITUDE_SETTLED_THRESHOLD) {
        this.tempDecreasing = false;
      }

      // If we meet criteria, then alert that temp/amplitude is decreasing
      if (this.tempDecreasing &&
      // only if the temperature is decreasing
      amplitude > FrictionModel.AMPLITUDE_SETTLED_THRESHOLD &&
      // when amplitude is close enough to its settled state, don't alert anymore\
      amplitude < 0.8 * SHEARING_LIMIT &&
      // don't alert cooling unless cooler than shearing limit, plus 20% grace
      phet.joist.elapsedTime - this.timeOfLastAlert > ALERT_TIME_DELAY) {
        // If we have waited long enough
        this.alertDecrease();
      }

      // reset even without a new drag if we are settled.
      if (amplitude <= FrictionModel.AMPLITUDE_SETTLED_THRESHOLD) {
        this.alertIndex = -1; // reset
        this.timeOfLastAlert = 0; // immediately trigger the potential for an alert
      }
    };

    // @private
    this.utterance = new Utterance({
      predicate: () => this.tempDecreasing,
      alert: new ResponsePacket(),
      announcerOptions: {
        cancelOther: false
      }
    });

    // exists for the lifetime of the sim, no need to dispose
    this.model.vibrationAmplitudeProperty.link(this.amplitudeListener);
  }

  /**
   * Should be called when a drag starts
   * @public
   */
  startDrag() {
    this.alertIndex = -1; //reset
  }

  /**
   * @public
   */
  endDrag() {
    this.timeOfLastAlert = 0; // immediately trigger the potential for an alert
  }

  /**
   * @public
   */
  reset() {
    this.firstAlert = true;
  }

  /**
   * @private
   */
  alertDecrease() {
    this.alertIndex++;
    const currentAlertIndex = Math.min(this.alertIndex, DECREASING.length - 1);
    let alertObject = DECREASING[currentAlertIndex];
    let patternString = frictionIncreasingAtomsJigglingTemperaturePatternString;

    // Use the "first time" pattern string if it is the first time. Gracefully handle if there isn't a first time alert
    if (alertObject.firstTime && this.firstAlert) {
      patternString = frictionIncreasingAtomsJigglingTemperatureFirstPatternString;

      // use the fill in values for the first time
      alertObject = alertObject.firstTime;
    }
    this.utterance.alert.contextResponse = StringUtils.fillIn(patternString, {
      temperature: alertObject.temp,
      jigglingAmount: alertObject.jiggle
    });
    this.alert(this.utterance);

    // it's not the first time anymore
    this.firstAlert = false;
    this.timeOfLastAlert = phet.joist.elapsedTime;
  }
}
friction.register('TemperatureDecreasingAlerter', TemperatureDecreasingAlerter);
export default TemperatureDecreasingAlerter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTdHJpbmdVdGlscyIsIkFsZXJ0ZXIiLCJSZXNwb25zZVBhY2tldCIsIlV0dGVyYW5jZSIsImZyaWN0aW9uIiwiRnJpY3Rpb25TdHJpbmdzIiwiRnJpY3Rpb25Nb2RlbCIsImppZ2dsaW5nTGVzc1N0cmluZyIsImExMXkiLCJqaWdnbGUiLCJqaWdnbGluZ0xlc3MiLCJjb29sZXJTdHJpbmciLCJ0ZW1wZXJhdHVyZSIsImNvb2xlciIsIm5vd0Nvb2xlclN0cmluZyIsIm5vd0Nvb2xlciIsImxlc3NTdHJpbmciLCJsZXNzIiwiZXZlbkxlc3NTdHJpbmciLCJldmVuTGVzcyIsImV2ZW5Db29sZXJTdHJpbmciLCJldmVuQ29vbGVyIiwiZnJpY3Rpb25JbmNyZWFzaW5nQXRvbXNKaWdnbGluZ1RlbXBlcmF0dXJlRmlyc3RQYXR0ZXJuU3RyaW5nIiwiZnJpY3Rpb25JbmNyZWFzaW5nQXRvbXNKaWdnbGluZ1RlbXBlcmF0dXJlRmlyc3RQYXR0ZXJuIiwiZnJpY3Rpb25JbmNyZWFzaW5nQXRvbXNKaWdnbGluZ1RlbXBlcmF0dXJlUGF0dGVyblN0cmluZyIsImZyaWN0aW9uSW5jcmVhc2luZ0F0b21zSmlnZ2xpbmdUZW1wZXJhdHVyZVBhdHRlcm4iLCJERUNSRUFTSU5HIiwidGVtcCIsImZpcnN0VGltZSIsIlNIRUFSSU5HX0xJTUlUIiwiTUFHTklGSUVEX0FUT01TX0lORk8iLCJzaGVhcmluZ0xpbWl0IiwiQUxFUlRfVElNRV9ERUxBWSIsIkFNUExJVFVERV9ERUNSRUFTSU5HX1RIUkVTSE9MRCIsIlRlbXBlcmF0dXJlRGVjcmVhc2luZ0FsZXJ0ZXIiLCJjb25zdHJ1Y3RvciIsIm1vZGVsIiwib3B0aW9ucyIsInRlbXBEZWNyZWFzaW5nIiwidGltZU9mTGFzdEFsZXJ0IiwiYWxlcnRJbmRleCIsImxhc3RBbXBsaXR1ZGVXaGVuSW5jcmVhc2luZyIsInZpYnJhdGlvbkFtcGxpdHVkZVByb3BlcnR5IiwidmFsdWUiLCJmaXJzdEFsZXJ0IiwiYW1wbGl0dWRlTGlzdGVuZXIiLCJhbXBsaXR1ZGUiLCJvbGRBbXBsaXR1ZGUiLCJBTVBMSVRVREVfU0VUVExFRF9USFJFU0hPTEQiLCJwaGV0Iiwiam9pc3QiLCJlbGFwc2VkVGltZSIsImFsZXJ0RGVjcmVhc2UiLCJ1dHRlcmFuY2UiLCJwcmVkaWNhdGUiLCJhbGVydCIsImFubm91bmNlck9wdGlvbnMiLCJjYW5jZWxPdGhlciIsImxpbmsiLCJzdGFydERyYWciLCJlbmREcmFnIiwicmVzZXQiLCJjdXJyZW50QWxlcnRJbmRleCIsIk1hdGgiLCJtaW4iLCJsZW5ndGgiLCJhbGVydE9iamVjdCIsInBhdHRlcm5TdHJpbmciLCJjb250ZXh0UmVzcG9uc2UiLCJmaWxsSW4iLCJqaWdnbGluZ0Ftb3VudCIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiVGVtcGVyYXR1cmVEZWNyZWFzaW5nQWxlcnRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDIzLCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIE1pY2hhZWwgS2F1em1hbm4gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IFN0cmluZ1V0aWxzIGZyb20gJy4uLy4uLy4uLy4uL3BoZXRjb21tb24vanMvdXRpbC9TdHJpbmdVdGlscy5qcyc7XHJcbmltcG9ydCBBbGVydGVyIGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9hY2Nlc3NpYmlsaXR5L2Rlc2NyaWJlcnMvQWxlcnRlci5qcyc7XHJcbmltcG9ydCBSZXNwb25zZVBhY2tldCBmcm9tICcuLi8uLi8uLi8uLi91dHRlcmFuY2UtcXVldWUvanMvUmVzcG9uc2VQYWNrZXQuanMnO1xyXG5pbXBvcnQgVXR0ZXJhbmNlIGZyb20gJy4uLy4uLy4uLy4uL3V0dGVyYW5jZS1xdWV1ZS9qcy9VdHRlcmFuY2UuanMnO1xyXG5pbXBvcnQgZnJpY3Rpb24gZnJvbSAnLi4vLi4vZnJpY3Rpb24uanMnO1xyXG5pbXBvcnQgRnJpY3Rpb25TdHJpbmdzIGZyb20gJy4uLy4uL0ZyaWN0aW9uU3RyaW5ncy5qcyc7XHJcbmltcG9ydCBGcmljdGlvbk1vZGVsIGZyb20gJy4uL21vZGVsL0ZyaWN0aW9uTW9kZWwuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IGppZ2dsaW5nTGVzc1N0cmluZyA9IEZyaWN0aW9uU3RyaW5ncy5hMTF5LmppZ2dsZS5qaWdnbGluZ0xlc3M7XHJcbmNvbnN0IGNvb2xlclN0cmluZyA9IEZyaWN0aW9uU3RyaW5ncy5hMTF5LnRlbXBlcmF0dXJlLmNvb2xlcjtcclxuY29uc3Qgbm93Q29vbGVyU3RyaW5nID0gRnJpY3Rpb25TdHJpbmdzLmExMXkudGVtcGVyYXR1cmUubm93Q29vbGVyO1xyXG5jb25zdCBsZXNzU3RyaW5nID0gRnJpY3Rpb25TdHJpbmdzLmExMXkuamlnZ2xlLmxlc3M7XHJcbmNvbnN0IGV2ZW5MZXNzU3RyaW5nID0gRnJpY3Rpb25TdHJpbmdzLmExMXkuamlnZ2xlLmV2ZW5MZXNzO1xyXG5jb25zdCBldmVuQ29vbGVyU3RyaW5nID0gRnJpY3Rpb25TdHJpbmdzLmExMXkudGVtcGVyYXR1cmUuZXZlbkNvb2xlcjtcclxuXHJcbmNvbnN0IGZyaWN0aW9uSW5jcmVhc2luZ0F0b21zSmlnZ2xpbmdUZW1wZXJhdHVyZUZpcnN0UGF0dGVyblN0cmluZyA9IEZyaWN0aW9uU3RyaW5ncy5hMTF5LmZyaWN0aW9uSW5jcmVhc2luZ0F0b21zSmlnZ2xpbmdUZW1wZXJhdHVyZUZpcnN0UGF0dGVybjtcclxuY29uc3QgZnJpY3Rpb25JbmNyZWFzaW5nQXRvbXNKaWdnbGluZ1RlbXBlcmF0dXJlUGF0dGVyblN0cmluZyA9IEZyaWN0aW9uU3RyaW5ncy5hMTF5LmZyaWN0aW9uSW5jcmVhc2luZ0F0b21zSmlnZ2xpbmdUZW1wZXJhdHVyZVBhdHRlcm47XHJcblxyXG5jb25zdCBERUNSRUFTSU5HID0gW1xyXG4gIHtcclxuICAgIGppZ2dsZTogbGVzc1N0cmluZyxcclxuICAgIHRlbXA6IGNvb2xlclN0cmluZyxcclxuICAgIGZpcnN0VGltZToge1xyXG4gICAgICBqaWdnbGU6IGppZ2dsaW5nTGVzc1N0cmluZyxcclxuICAgICAgdGVtcDogY29vbGVyU3RyaW5nXHJcbiAgICB9XHJcbiAgfSxcclxuICB7XHJcbiAgICBqaWdnbGU6IGxlc3NTdHJpbmcsXHJcbiAgICB0ZW1wOiBub3dDb29sZXJTdHJpbmdcclxuICB9LFxyXG4gIHtcclxuICAgIGppZ2dsZTogZXZlbkxlc3NTdHJpbmcsXHJcbiAgICB0ZW1wOiBldmVuQ29vbGVyU3RyaW5nXHJcbiAgfVxyXG5dO1xyXG5cclxuLy8gRnJvbSBtb2RlbCwgdGhlIGFtcGxpdHVkZSB2YWx1ZSB3aGVuIHRoZSBhdG9tcyBzaGVhciBvZmZcclxuY29uc3QgU0hFQVJJTkdfTElNSVQgPSBGcmljdGlvbk1vZGVsLk1BR05JRklFRF9BVE9NU19JTkZPLnNoZWFyaW5nTGltaXQ7XHJcblxyXG4vLyBIb3cgbG9uZyBpbiBiZXR3ZWVuIGVhY2ggc3Vic2VxdWVudCBkZWNyZWFzaW5nIGFsZXJ0XHJcbmNvbnN0IEFMRVJUX1RJTUVfREVMQVkgPSAzMDAwO1xyXG5cclxuLy8gVGhlIGFtb3VudCBvZiBhbXBsaXR1ZGUgdGhhdCB0aGUgbW9kZWwgbXVzdCBkZWNyZWFzZSBmcm9tIHRoZSBsYXN0IHBvaW50IHdoZXJlIGl0IHdhcyBpbmNyZWFzaW5nLiBUaGlzIHZhbHVlXHJcbi8vIGlzIHRvIGhlbHAgd2l0aCBtaW5vciBmbHVjdHVhdGlvbnMgYXMgdGhlIG1vZGVsIFwiY29vbHNcIiBpdHNlbGYgZXZlcnkgc3RlcCBldmVuIHdoaWxlIGZyaWN0aW9uIGlzIGdlbmVyYWxseSBpbmNyZWFzaW5nLlxyXG4vLyBJbiBzYW1lIHVuaXRzIGFzIEZyaWN0aW9uTW9kZWwncyBhbXBsaXR1ZGVcclxuY29uc3QgQU1QTElUVURFX0RFQ1JFQVNJTkdfVEhSRVNIT0xEID0gMTtcclxuXHJcbmNsYXNzIFRlbXBlcmF0dXJlRGVjcmVhc2luZ0FsZXJ0ZXIgZXh0ZW5kcyBBbGVydGVyIHtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzcG9uc2libGUgZm9yIGFsZXJ0aW5nIHdoZW4gdGhlIHRlbXBlcmF0dXJlIGRlY3JlYXNlc1xyXG4gICAqIEBwYXJhbSB7RnJpY3Rpb25Nb2RlbH0gbW9kZWxcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIG1vZGVsLCBvcHRpb25zICkge1xyXG5cclxuICAgIHN1cGVyKCBvcHRpb25zICk7XHJcblxyXG4gICAgLy8gZGVjaWRlcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGRlc2NyaWJlciBpcyBlbmFibGVkIGJhc2ljYWxseS5cclxuICAgIC8vIGp1c3QgbWFuYWdlcyB3aGV0aGVyIG9yIG5vdCB3ZSBhcmUgY2hlY2tpbmcgdG8gc2VlIGlmIHRoZSB0aHJlc2hvbGQgaXMgaW5jcmVhc2luZyBlbm91Z2hcclxuICAgIC8vIEBwdWJsaWNcclxuICAgIHRoaXMudGVtcERlY3JlYXNpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG5cclxuICAgIC8vIEBwcml2YXRlXHJcbiAgICAvLyBUaGlzIGtlZXBzIHRyYWNrIG9mIHRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IGRlY3JlYXNpbmcgYWxlcnQgd2FzIG1hZGVcclxuICAgIHRoaXMudGltZU9mTGFzdEFsZXJ0ID0gMDtcclxuXHJcbiAgICAvLyB6ZXJvIGluZGV4ZWQsIHNvIHRoZSBmaXJzdCBvbmUgaXMgMFxyXG4gICAgdGhpcy5hbGVydEluZGV4ID0gLTE7XHJcblxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCBoaWdoZXN0IGFtcGxpdHVkZSB3aGVuIGl0IHdhcyBpbmNyZWFzaW5nLiBUaGlzIHZhbHVlIGlzIHJlc2V0IGV2ZXJ5dGltZSB0aGUgb2xkQW1wbGl0dWRlXHJcbiAgICAvLyBpcyBsZXNzIHRoYXQgdGhlIG5ldyBhbXBsaXR1ZGUuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgbGV0IGxhc3RBbXBsaXR1ZGVXaGVuSW5jcmVhc2luZyA9IG1vZGVsLnZpYnJhdGlvbkFtcGxpdHVkZVByb3BlcnR5LnZhbHVlO1xyXG5cclxuICAgIC8vIERpZmZlcmVudCBhbGVydCBmb3IgdGhlIHZlcnkgZmlyc3QgZGVjcmVhc2UgYWxlcnQgd2UgaGF2ZSBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBzaW1cclxuICAgIC8vIEBwcml2YXRlXHJcbiAgICB0aGlzLmZpcnN0QWxlcnQgPSB0cnVlO1xyXG5cclxuICAgIC8vIEBwcml2YXRlXHJcbiAgICB0aGlzLmFtcGxpdHVkZUxpc3RlbmVyID0gKCBhbXBsaXR1ZGUsIG9sZEFtcGxpdHVkZSApID0+IHtcclxuXHJcbiAgICAgIC8vIGlmIGV2ZXIgd2UgaW5jcmVhc2UgYW1wbGl0dWRlLCBtYWtlIGl0IHRoZSBuZXcgbWF4aW11bSB0byBjb21wYXJlIGFnYWluc3Qgd2hlbiBkZXRlcm1pbmluZyBpZiB3ZSBhcmUgXCJkZWNyZWFzaW5nIGluIHRlbXBcIlxyXG4gICAgICBpZiAoIGFtcGxpdHVkZSA+IG9sZEFtcGxpdHVkZSApIHtcclxuICAgICAgICBsYXN0QW1wbGl0dWRlV2hlbkluY3JlYXNpbmcgPSBhbXBsaXR1ZGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG1hbmFnZSB3aGljaCB3YXkgdGggdGVtcCBpcyBnb2luZ1xyXG4gICAgICB0aGlzLnRlbXBEZWNyZWFzaW5nID0gbGFzdEFtcGxpdHVkZVdoZW5JbmNyZWFzaW5nIC0gYW1wbGl0dWRlID4gQU1QTElUVURFX0RFQ1JFQVNJTkdfVEhSRVNIT0xEO1xyXG5cclxuICAgICAgLy8gd2UgY29uc2lkZXIgaXQgXCJzZXR0bGVkXCIgYXQgdGhpcyB0aHJlc2hvbGRcclxuICAgICAgaWYgKCBhbXBsaXR1ZGUgPCBGcmljdGlvbk1vZGVsLkFNUExJVFVERV9TRVRUTEVEX1RIUkVTSE9MRCApIHtcclxuICAgICAgICB0aGlzLnRlbXBEZWNyZWFzaW5nID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHdlIG1lZXQgY3JpdGVyaWEsIHRoZW4gYWxlcnQgdGhhdCB0ZW1wL2FtcGxpdHVkZSBpcyBkZWNyZWFzaW5nXHJcbiAgICAgIGlmICggdGhpcy50ZW1wRGVjcmVhc2luZyAmJiAvLyBvbmx5IGlmIHRoZSB0ZW1wZXJhdHVyZSBpcyBkZWNyZWFzaW5nXHJcbiAgICAgICAgICAgYW1wbGl0dWRlID4gRnJpY3Rpb25Nb2RlbC5BTVBMSVRVREVfU0VUVExFRF9USFJFU0hPTEQgJiYgLy8gd2hlbiBhbXBsaXR1ZGUgaXMgY2xvc2UgZW5vdWdoIHRvIGl0cyBzZXR0bGVkIHN0YXRlLCBkb24ndCBhbGVydCBhbnltb3JlXFxcclxuICAgICAgICAgICBhbXBsaXR1ZGUgPCAwLjggKiBTSEVBUklOR19MSU1JVCAmJiAvLyBkb24ndCBhbGVydCBjb29saW5nIHVubGVzcyBjb29sZXIgdGhhbiBzaGVhcmluZyBsaW1pdCwgcGx1cyAyMCUgZ3JhY2VcclxuICAgICAgICAgICBwaGV0LmpvaXN0LmVsYXBzZWRUaW1lIC0gdGhpcy50aW1lT2ZMYXN0QWxlcnQgPiBBTEVSVF9USU1FX0RFTEFZICkgeyAvLyBJZiB3ZSBoYXZlIHdhaXRlZCBsb25nIGVub3VnaFxyXG4gICAgICAgIHRoaXMuYWxlcnREZWNyZWFzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZXNldCBldmVuIHdpdGhvdXQgYSBuZXcgZHJhZyBpZiB3ZSBhcmUgc2V0dGxlZC5cclxuICAgICAgaWYgKCBhbXBsaXR1ZGUgPD0gRnJpY3Rpb25Nb2RlbC5BTVBMSVRVREVfU0VUVExFRF9USFJFU0hPTEQgKSB7XHJcbiAgICAgICAgdGhpcy5hbGVydEluZGV4ID0gLTE7IC8vIHJlc2V0XHJcbiAgICAgICAgdGhpcy50aW1lT2ZMYXN0QWxlcnQgPSAwOyAvLyBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSBwb3RlbnRpYWwgZm9yIGFuIGFsZXJ0XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gQHByaXZhdGVcclxuICAgIHRoaXMudXR0ZXJhbmNlID0gbmV3IFV0dGVyYW5jZSgge1xyXG4gICAgICBwcmVkaWNhdGU6ICgpID0+IHRoaXMudGVtcERlY3JlYXNpbmcsXHJcbiAgICAgIGFsZXJ0OiBuZXcgUmVzcG9uc2VQYWNrZXQoKSxcclxuICAgICAgYW5ub3VuY2VyT3B0aW9uczoge1xyXG4gICAgICAgIGNhbmNlbE90aGVyOiBmYWxzZVxyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gZXhpc3RzIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIHNpbSwgbm8gbmVlZCB0byBkaXNwb3NlXHJcbiAgICB0aGlzLm1vZGVsLnZpYnJhdGlvbkFtcGxpdHVkZVByb3BlcnR5LmxpbmsoIHRoaXMuYW1wbGl0dWRlTGlzdGVuZXIgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHN0YXJ0RHJhZygpIHtcclxuICAgIHRoaXMuYWxlcnRJbmRleCA9IC0xOyAvL3Jlc2V0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgZW5kRHJhZygpIHtcclxuICAgIHRoaXMudGltZU9mTGFzdEFsZXJ0ID0gMDsgLy8gaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgcG90ZW50aWFsIGZvciBhbiBhbGVydFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHJlc2V0KCkge1xyXG4gICAgdGhpcy5maXJzdEFsZXJ0ID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgYWxlcnREZWNyZWFzZSgpIHtcclxuICAgIHRoaXMuYWxlcnRJbmRleCsrO1xyXG4gICAgY29uc3QgY3VycmVudEFsZXJ0SW5kZXggPSBNYXRoLm1pbiggdGhpcy5hbGVydEluZGV4LCBERUNSRUFTSU5HLmxlbmd0aCAtIDEgKTtcclxuXHJcbiAgICBsZXQgYWxlcnRPYmplY3QgPSBERUNSRUFTSU5HWyBjdXJyZW50QWxlcnRJbmRleCBdO1xyXG5cclxuICAgIGxldCBwYXR0ZXJuU3RyaW5nID0gZnJpY3Rpb25JbmNyZWFzaW5nQXRvbXNKaWdnbGluZ1RlbXBlcmF0dXJlUGF0dGVyblN0cmluZztcclxuXHJcbiAgICAvLyBVc2UgdGhlIFwiZmlyc3QgdGltZVwiIHBhdHRlcm4gc3RyaW5nIGlmIGl0IGlzIHRoZSBmaXJzdCB0aW1lLiBHcmFjZWZ1bGx5IGhhbmRsZSBpZiB0aGVyZSBpc24ndCBhIGZpcnN0IHRpbWUgYWxlcnRcclxuICAgIGlmICggYWxlcnRPYmplY3QuZmlyc3RUaW1lICYmIHRoaXMuZmlyc3RBbGVydCApIHtcclxuICAgICAgcGF0dGVyblN0cmluZyA9IGZyaWN0aW9uSW5jcmVhc2luZ0F0b21zSmlnZ2xpbmdUZW1wZXJhdHVyZUZpcnN0UGF0dGVyblN0cmluZztcclxuXHJcbiAgICAgIC8vIHVzZSB0aGUgZmlsbCBpbiB2YWx1ZXMgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgIGFsZXJ0T2JqZWN0ID0gYWxlcnRPYmplY3QuZmlyc3RUaW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXR0ZXJhbmNlLmFsZXJ0LmNvbnRleHRSZXNwb25zZSA9IFN0cmluZ1V0aWxzLmZpbGxJbiggcGF0dGVyblN0cmluZywge1xyXG4gICAgICB0ZW1wZXJhdHVyZTogYWxlcnRPYmplY3QudGVtcCxcclxuICAgICAgamlnZ2xpbmdBbW91bnQ6IGFsZXJ0T2JqZWN0LmppZ2dsZVxyXG4gICAgfSApO1xyXG5cclxuICAgIHRoaXMuYWxlcnQoIHRoaXMudXR0ZXJhbmNlICk7XHJcblxyXG4gICAgLy8gaXQncyBub3QgdGhlIGZpcnN0IHRpbWUgYW55bW9yZVxyXG4gICAgdGhpcy5maXJzdEFsZXJ0ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy50aW1lT2ZMYXN0QWxlcnQgPSBwaGV0LmpvaXN0LmVsYXBzZWRUaW1lO1xyXG4gIH1cclxufVxyXG5cclxuZnJpY3Rpb24ucmVnaXN0ZXIoICdUZW1wZXJhdHVyZURlY3JlYXNpbmdBbGVydGVyJywgVGVtcGVyYXR1cmVEZWNyZWFzaW5nQWxlcnRlciApO1xyXG5leHBvcnQgZGVmYXVsdCBUZW1wZXJhdHVyZURlY3JlYXNpbmdBbGVydGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFdBQVcsTUFBTSwrQ0FBK0M7QUFDdkUsT0FBT0MsT0FBTyxNQUFNLGlFQUFpRTtBQUNyRixPQUFPQyxjQUFjLE1BQU0sa0RBQWtEO0FBQzdFLE9BQU9DLFNBQVMsTUFBTSw2Q0FBNkM7QUFDbkUsT0FBT0MsUUFBUSxNQUFNLG1CQUFtQjtBQUN4QyxPQUFPQyxlQUFlLE1BQU0sMEJBQTBCO0FBQ3RELE9BQU9DLGFBQWEsTUFBTSwyQkFBMkI7O0FBRXJEO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUdGLGVBQWUsQ0FBQ0csSUFBSSxDQUFDQyxNQUFNLENBQUNDLFlBQVk7QUFDbkUsTUFBTUMsWUFBWSxHQUFHTixlQUFlLENBQUNHLElBQUksQ0FBQ0ksV0FBVyxDQUFDQyxNQUFNO0FBQzVELE1BQU1DLGVBQWUsR0FBR1QsZUFBZSxDQUFDRyxJQUFJLENBQUNJLFdBQVcsQ0FBQ0csU0FBUztBQUNsRSxNQUFNQyxVQUFVLEdBQUdYLGVBQWUsQ0FBQ0csSUFBSSxDQUFDQyxNQUFNLENBQUNRLElBQUk7QUFDbkQsTUFBTUMsY0FBYyxHQUFHYixlQUFlLENBQUNHLElBQUksQ0FBQ0MsTUFBTSxDQUFDVSxRQUFRO0FBQzNELE1BQU1DLGdCQUFnQixHQUFHZixlQUFlLENBQUNHLElBQUksQ0FBQ0ksV0FBVyxDQUFDUyxVQUFVO0FBRXBFLE1BQU1DLDREQUE0RCxHQUFHakIsZUFBZSxDQUFDRyxJQUFJLENBQUNlLHNEQUFzRDtBQUNoSixNQUFNQyx1REFBdUQsR0FBR25CLGVBQWUsQ0FBQ0csSUFBSSxDQUFD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