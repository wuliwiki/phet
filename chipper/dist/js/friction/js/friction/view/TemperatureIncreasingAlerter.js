// Copyright 2018-2023, University of Colorado Boulder

/**
 * This singleton type is responsible for alerting all aria-live alerts that pertain to the model/amplitude/temperature
 * increasing.
 * The basic algorithm: There is a list of alerts, each later alert uses verbage describing a relatively hotter model.
 * Each time you alert, you move up in the list, such that the next alert will alert with hotter verbage.
 *
 * The alert index restarts if there is enough time in between drags, signifying the end of the "drag session"
 * A drag session can consist of more than one dragging instance, but is ended if the time between drags is greater than
 * the "DRAG_SESSION_THRESHOLD"
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */

import stepTimer from '../../../../axon/js/stepTimer.js';
import StringUtils from '../../../../phetcommon/js/util/StringUtils.js';
import Alerter from '../../../../scenery-phet/js/accessibility/describers/Alerter.js';
import { voicingUtteranceQueue } from '../../../../scenery/js/imports.js';
import ResponsePacket from '../../../../utterance-queue/js/ResponsePacket.js';
import Utterance from '../../../../utterance-queue/js/Utterance.js';
import friction from '../../friction.js';
import FrictionStrings from '../../FrictionStrings.js';
import FrictionModel from '../model/FrictionModel.js';

// constants
const moreString = FrictionStrings.a11y.temperature.more;
const fasterString = FrictionStrings.a11y.temperature.faster;
const nowHotterString = FrictionStrings.a11y.temperature.nowHotter;
const evenFasterString = FrictionStrings.a11y.temperature.evenFaster;
const warmerString = FrictionStrings.a11y.temperature.warmer;
const evenHotterString = FrictionStrings.a11y.temperature.evenHotter;
const superFastString = FrictionStrings.a11y.temperature.superFast;
const superHotString = FrictionStrings.a11y.temperature.superHot;
const frictionIncreasingAtomsJigglingTemperaturePatternString = FrictionStrings.a11y.frictionIncreasingAtomsJigglingTemperaturePattern;

// alert object for the Maximum temp alert
const MAX_TEMP_STRING = StringUtils.fillIn(frictionIncreasingAtomsJigglingTemperaturePatternString, {
  jigglingAmount: superFastString,
  temperature: superHotString
});

// @private - mutated based on if the "reset" hint should be added
const MAX_TEMP_RESPONSE_PACKET = new ResponsePacket({
  contextResponse: MAX_TEMP_STRING
});

// Threshold that must be reached from initial temp to new temp to alert that the temperature changed, in amplitude (see model for more info)
const TEMPERATURE_ALERT_THRESHOLD = 1.5;
const INCREASING = [{
  jiggle: moreString,
  temp: warmerString
}, {
  jiggle: fasterString,
  temp: nowHotterString
}, {
  jiggle: evenFasterString,
  temp: evenHotterString
}];

// From model, the amplitude value when the atoms shear off
const SHEARING_LIMIT = FrictionModel.MAGNIFIED_ATOMS_INFO.shearingLimit;

// how long to wait until we consider this newest drag of a different "drag session", such
// that the warming alert progression will start over back at "warmer" alerts.
// in ms
const DRAG_SESSION_THRESHOLD = 1000;

// in ms, time in between each warming/increasing alert
const WARMING_ALERT_TIME_DELAY = 500;
const MAX_TEMP_ALERT_TIME_DELAY = 3000;

// The amount of amplitude that the model must decrease from the last point where it was increasing. This value
// is to help determine if the temperature is no longer increasing, while alowing for minor fluctuation. In same units
// as FrictionModel's amplitude
const AMPLITUDE_DECREASING_THRESHOLD = 0.4;
class TemperatureIncreasingAlerter extends Alerter {
  /**
   * Responsible for alerting when the temperature increases
   * @param {FrictionModel} model
   * @param {Object} [options]
   */
  constructor(model, options) {
    super(options);

    // @private
    this.model = model;

    // @private
    // Keep track of the time that the last drag ended. This is helpful to see if a new drag is within the same
    // "drag session", meaning that the alertIndex doesn't reset back to the first alert.
    // Default value is such that restart will always occur on first drag.
    this.timeOfLastDrag = 0;

    // @private
    this.initialAmplitude = model.vibrationAmplitudeProperty.value;

    // zero indexed, so the first one is 0
    // @private
    this.alertIndex = -1;

    // @private {boolean} - don't alert too many alerts all at once, these flags are only switched after a timeout
    this.tooSoonForNextWarmingAlert = false;
    this.tooSoonForNextMaxTempAlert = false;

    // @private {boolean} - keep track of if the model is increasing or now, with a special threshold specific to the
    // needs of this warming alerter. By "increasing" it also means stays the same, or lowers just a bit before increasing again.
    this.amplitudeIncreasing = false;

    // @private
    this.maxTempUtterance = new Utterance({
      alert: MAX_TEMP_RESPONSE_PACKET,
      predicate: () => this.amplitudeIncreasing && model.vibrationAmplitudeProperty.value >= FrictionModel.THERMOMETER_MAX_TEMP,
      priority: Utterance.LOW_PRIORITY,
      announcerOptions: {
        // even though it is annoying to repeat these, it is better than hearing the beginning 10 times before hearing the actual alert.
        cancelSelf: false
      }
    });

    // @private
    this.temperatureJiggleUtterance = new Utterance({
      predicate: () => this.amplitudeIncreasing,
      alert: new ResponsePacket()
    });
    let localMaxima = 0;

    // @private
    this.amplitudeListener = (amplitude, oldAmplitude) => {
      if (amplitude > oldAmplitude) {
        localMaxima = amplitude;
      }
      this.amplitudeIncreasing = !(localMaxima - amplitude > AMPLITUDE_DECREASING_THRESHOLD);

      // the difference in amplitude has to be greater than the threshold to alert
      if (!this.tooSoonForNextWarmingAlert && amplitude < SHEARING_LIMIT && amplitude - this.initialAmplitude > TEMPERATURE_ALERT_THRESHOLD) {
        this.alertIncrease();
      } else if (!this.tooSoonForNextMaxTempAlert && amplitude >= FrictionModel.THERMOMETER_MAX_TEMP) {
        this.alertMaxTemp();
      }

      // reset even without a new drag if we are settled.
      if (amplitude <= FrictionModel.AMPLITUDE_SETTLED_THRESHOLD) {
        this.onDrag();
        this.initializeAlerts();
      }
    };

    // exists for the lifetime of the sim, no need to dispose
    this.model.vibrationAmplitudeProperty.link(this.amplitudeListener);
  }

  /**
   * Reset the data so that the warming alerts will start over
   * @private
   */
  initializeAlerts() {
    this.alertIndex = -1; // reset

    // Normally, capture the initial amplitude as temperature regions change. But if already at the max, then set
    // amplitude to a very different number, so that max-temp alerts can continue to fire.
    this.initialAmplitude = this.model.vibrationAmplitudeProperty.value > FrictionModel.THERMOMETER_MAX_TEMP ? this.model.vibrationAmplitudeProperty.initialValue : this.model.vibrationAmplitudeProperty.value;
  }

  // @public
  // triggered on every keydown/mousedown
  startDrag() {
    // If longer than threshold, treat as new "drag session"
    if (phet.joist.elapsedTime - this.timeOfLastDrag > DRAG_SESSION_THRESHOLD) {
      this.initializeAlerts();
    }
  }

  /**
   * Called by amplitude listener in addition to on drag for resetting drag time.
   * @public
   */
  onDrag() {
    this.timeOfLastDrag = phet.joist.elapsedTime;
  }

  // @public
  endDrag() {
    if (this.model.vibrationAmplitudeProperty.value >= FrictionModel.THERMOMETER_MAX_TEMP) {
      this.forEachUtteranceQueue(utteranceQueue => {
        utteranceQueue.hasUtterance(this.temperatureJiggleUtterance) && utteranceQueue.removeUtterance(this.temperatureJiggleUtterance);
      });
      voicingUtteranceQueue.hasUtterance(this.temperatureJiggleUtterance) && voicingUtteranceQueue.removeUtterance(this.temperatureJiggleUtterance);
    }
    this.timeOfLastDrag = phet.joist.elapsedTime;
  }

  // @private
  alertIncrease() {
    this.alertIndex++;
    const currentAlertIndex = Math.min(this.alertIndex, INCREASING.length - 1);
    const alertObject = INCREASING[currentAlertIndex];
    this.temperatureJiggleUtterance.alert.contextResponse = StringUtils.fillIn(frictionIncreasingAtomsJigglingTemperaturePatternString, {
      temperature: alertObject.temp,
      jigglingAmount: alertObject.jiggle
    });
    this.alert(this.temperatureJiggleUtterance);

    // reset the "initialAmplitude" to the current amplitude, because then it will take another whole threshold level to alert again
    this.initialAmplitude = this.model.vibrationAmplitudeProperty.value;

    // set to true to limit subsequent alerts firing rapidly
    this.tooSoonForNextWarmingAlert = true;
    stepTimer.setTimeout(() => {
      this.tooSoonForNextWarmingAlert = false;
    }, WARMING_ALERT_TIME_DELAY);
  }

  /**
   * Alert the maximum temperate alert, varied based on if it is the first time alerting.
   * @private
   */
  alertMaxTemp() {
    this.alert(this.maxTempUtterance);
    this.initialAmplitude = this.model.vibrationAmplitudeProperty.value;

    // set to true to limit subsequent alerts firing rapidly
    this.tooSoonForNextMaxTempAlert = true;
    stepTimer.setTimeout(() => {
      this.tooSoonForNextMaxTempAlert = false;
    }, MAX_TEMP_ALERT_TIME_DELAY);
  }

  /**
   * Reset the Describer
   * @public
   */
  reset() {
    this.temperatureJiggleUtterance.reset();
    this.maxTempUtterance.reset();
  }
}
friction.register('TemperatureIncreasingAlerter', TemperatureIncreasingAlerter);
export default TemperatureIncreasingAlerter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJzdGVwVGltZXIiLCJTdHJpbmdVdGlscyIsIkFsZXJ0ZXIiLCJ2b2ljaW5nVXR0ZXJhbmNlUXVldWUiLCJSZXNwb25zZVBhY2tldCIsIlV0dGVyYW5jZSIsImZyaWN0aW9uIiwiRnJpY3Rpb25TdHJpbmdzIiwiRnJpY3Rpb25Nb2RlbCIsIm1vcmVTdHJpbmciLCJhMTF5IiwidGVtcGVyYXR1cmUiLCJtb3JlIiwiZmFzdGVyU3RyaW5nIiwiZmFzdGVyIiwibm93SG90dGVyU3RyaW5nIiwibm93SG90dGVyIiwiZXZlbkZhc3RlclN0cmluZyIsImV2ZW5GYXN0ZXIiLCJ3YXJtZXJTdHJpbmciLCJ3YXJtZXIiLCJldmVuSG90dGVyU3RyaW5nIiwiZXZlbkhvdHRlciIsInN1cGVyRmFzdFN0cmluZyIsInN1cGVyRmFzdCIsInN1cGVySG90U3RyaW5nIiwic3VwZXJIb3QiLCJmcmljdGlvbkluY3JlYXNpbmdBdG9tc0ppZ2dsaW5nVGVtcGVyYXR1cmVQYXR0ZXJuU3RyaW5nIiwiZnJpY3Rpb25JbmNyZWFzaW5nQXRvbXNKaWdnbGluZ1RlbXBlcmF0dXJlUGF0dGVybiIsIk1BWF9URU1QX1NUUklORyIsImZpbGxJbiIsImppZ2dsaW5nQW1vdW50IiwiTUFYX1RFTVBfUkVTUE9OU0VfUEFDS0VUIiwiY29udGV4dFJlc3BvbnNlIiwiVEVNUEVSQVRVUkVfQUxFUlRfVEhSRVNIT0xEIiwiSU5DUkVBU0lORyIsImppZ2dsZSIsInRlbXAiLCJTSEVBUklOR19MSU1JVCIsIk1BR05JRklFRF9BVE9NU19JTkZPIiwic2hlYXJpbmdMaW1pdCIsIkRSQUdfU0VTU0lPTl9USFJFU0hPTEQiLCJXQVJNSU5HX0FMRVJUX1RJTUVfREVMQVkiLCJNQVhfVEVNUF9BTEVSVF9USU1FX0RFTEFZIiwiQU1QTElUVURFX0RFQ1JFQVNJTkdfVEhSRVNIT0xEIiwiVGVtcGVyYXR1cmVJbmNyZWFzaW5nQWxlcnRlciIsImNvbnN0cnVjdG9yIiwibW9kZWwiLCJvcHRpb25zIiwidGltZU9mTGFzdERyYWciLCJpbml0aWFsQW1wbGl0dWRlIiwidmlicmF0aW9uQW1wbGl0dWRlUHJvcGVydHkiLCJ2YWx1ZSIsImFsZXJ0SW5kZXgiLCJ0b29Tb29uRm9yTmV4dFdhcm1pbmdBbGVydCIsInRvb1Nvb25Gb3JOZXh0TWF4VGVtcEFsZXJ0IiwiYW1wbGl0dWRlSW5jcmVhc2luZyIsIm1heFRlbXBVdHRlcmFuY2UiLCJhbGVydCIsInByZWRpY2F0ZSIsIlRIRVJNT01FVEVSX01BWF9URU1QIiwicHJpb3JpdHkiLCJMT1dfUFJJT1JJVFkiLCJhbm5vdW5jZXJPcHRpb25zIiwiY2FuY2VsU2VsZiIsInRlbXBlcmF0dXJlSmlnZ2xlVXR0ZXJhbmNlIiwibG9jYWxNYXhpbWEiLCJhbXBsaXR1ZGVMaXN0ZW5lciIsImFtcGxpdHVkZSIsIm9sZEFtcGxpdHVkZSIsImFsZXJ0SW5jcmVhc2UiLCJhbGVydE1heFRlbXAiLCJBTVBMSVRVREVfU0VUVExFRF9USFJFU0hPTEQiLCJvbkRyYWciLCJpbml0aWFsaXplQWxlcnRzIiwibGluayIsImluaXRpYWxWYWx1ZSIsInN0YXJ0RHJhZyIsInBoZXQiLCJqb2lzdCIsImVsYXBzZWRUaW1lIiwiZW5kRHJhZyIsImZvckVhY2hVdHRlcmFuY2VRdWV1ZSIsInV0dGVyYW5jZVF1ZXVlIiwiaGFzVXR0ZXJhbmNlIiwicmVtb3ZlVXR0ZXJhbmNlIiwiY3VycmVudEFsZXJ0SW5kZXgiLCJNYXRoIiwibWluIiwibGVuZ3RoIiwiYWxlcnRPYmplY3QiLCJzZXRUaW1lb3V0IiwicmVzZXQiLCJyZWdpc3RlciJdLCJzb3VyY2VzIjpbIlRlbXBlcmF0dXJlSW5jcmVhc2luZ0FsZXJ0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTgtMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogVGhpcyBzaW5nbGV0b24gdHlwZSBpcyByZXNwb25zaWJsZSBmb3IgYWxlcnRpbmcgYWxsIGFyaWEtbGl2ZSBhbGVydHMgdGhhdCBwZXJ0YWluIHRvIHRoZSBtb2RlbC9hbXBsaXR1ZGUvdGVtcGVyYXR1cmVcclxuICogaW5jcmVhc2luZy5cclxuICogVGhlIGJhc2ljIGFsZ29yaXRobTogVGhlcmUgaXMgYSBsaXN0IG9mIGFsZXJ0cywgZWFjaCBsYXRlciBhbGVydCB1c2VzIHZlcmJhZ2UgZGVzY3JpYmluZyBhIHJlbGF0aXZlbHkgaG90dGVyIG1vZGVsLlxyXG4gKiBFYWNoIHRpbWUgeW91IGFsZXJ0LCB5b3UgbW92ZSB1cCBpbiB0aGUgbGlzdCwgc3VjaCB0aGF0IHRoZSBuZXh0IGFsZXJ0IHdpbGwgYWxlcnQgd2l0aCBob3R0ZXIgdmVyYmFnZS5cclxuICpcclxuICogVGhlIGFsZXJ0IGluZGV4IHJlc3RhcnRzIGlmIHRoZXJlIGlzIGVub3VnaCB0aW1lIGluIGJldHdlZW4gZHJhZ3MsIHNpZ25pZnlpbmcgdGhlIGVuZCBvZiB0aGUgXCJkcmFnIHNlc3Npb25cIlxyXG4gKiBBIGRyYWcgc2Vzc2lvbiBjYW4gY29uc2lzdCBvZiBtb3JlIHRoYW4gb25lIGRyYWdnaW5nIGluc3RhbmNlLCBidXQgaXMgZW5kZWQgaWYgdGhlIHRpbWUgYmV0d2VlbiBkcmFncyBpcyBncmVhdGVyIHRoYW5cclxuICogdGhlIFwiRFJBR19TRVNTSU9OX1RIUkVTSE9MRFwiXHJcbiAqXHJcbiAqIEBhdXRob3IgTWljaGFlbCBLYXV6bWFubiAoUGhFVCBJbnRlcmFjdGl2ZSBTaW11bGF0aW9ucylcclxuICovXHJcblxyXG5pbXBvcnQgc3RlcFRpbWVyIGZyb20gJy4uLy4uLy4uLy4uL2F4b24vanMvc3RlcFRpbWVyLmpzJztcclxuaW1wb3J0IFN0cmluZ1V0aWxzIGZyb20gJy4uLy4uLy4uLy4uL3BoZXRjb21tb24vanMvdXRpbC9TdHJpbmdVdGlscy5qcyc7XHJcbmltcG9ydCBBbGVydGVyIGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnktcGhldC9qcy9hY2Nlc3NpYmlsaXR5L2Rlc2NyaWJlcnMvQWxlcnRlci5qcyc7XHJcbmltcG9ydCB7IHZvaWNpbmdVdHRlcmFuY2VRdWV1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lcnkvanMvaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBSZXNwb25zZVBhY2tldCBmcm9tICcuLi8uLi8uLi8uLi91dHRlcmFuY2UtcXVldWUvanMvUmVzcG9uc2VQYWNrZXQuanMnO1xyXG5pbXBvcnQgVXR0ZXJhbmNlIGZyb20gJy4uLy4uLy4uLy4uL3V0dGVyYW5jZS1xdWV1ZS9qcy9VdHRlcmFuY2UuanMnO1xyXG5pbXBvcnQgZnJpY3Rpb24gZnJvbSAnLi4vLi4vZnJpY3Rpb24uanMnO1xyXG5pbXBvcnQgRnJpY3Rpb25TdHJpbmdzIGZyb20gJy4uLy4uL0ZyaWN0aW9uU3RyaW5ncy5qcyc7XHJcbmltcG9ydCBGcmljdGlvbk1vZGVsIGZyb20gJy4uL21vZGVsL0ZyaWN0aW9uTW9kZWwuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IG1vcmVTdHJpbmcgPSBGcmljdGlvblN0cmluZ3MuYTExeS50ZW1wZXJhdHVyZS5tb3JlO1xyXG5jb25zdCBmYXN0ZXJTdHJpbmcgPSBGcmljdGlvblN0cmluZ3MuYTExeS50ZW1wZXJhdHVyZS5mYXN0ZXI7XHJcbmNvbnN0IG5vd0hvdHRlclN0cmluZyA9IEZyaWN0aW9uU3RyaW5ncy5hMTF5LnRlbXBlcmF0dXJlLm5vd0hvdHRlcjtcclxuY29uc3QgZXZlbkZhc3RlclN0cmluZyA9IEZyaWN0aW9uU3RyaW5ncy5hMTF5LnRlbXBlcmF0dXJlLmV2ZW5GYXN0ZXI7XHJcbmNvbnN0IHdhcm1lclN0cmluZyA9IEZyaWN0aW9uU3RyaW5ncy5hMTF5LnRlbXBlcmF0dXJlLndhcm1lcjtcclxuY29uc3QgZXZlbkhvdHRlclN0cmluZyA9IEZyaWN0aW9uU3RyaW5ncy5hMTF5LnRlbXBlcmF0dXJlLmV2ZW5Ib3R0ZXI7XHJcblxyXG5jb25zdCBzdXBlckZhc3RTdHJpbmcgPSBGcmljdGlvblN0cmluZ3MuYTExeS50ZW1wZXJhdHVyZS5zdXBlckZhc3Q7XHJcbmNvbnN0IHN1cGVySG90U3RyaW5nID0gRnJpY3Rpb25TdHJpbmdzLmExMXkudGVtcGVyYXR1cmUuc3VwZXJIb3Q7XHJcblxyXG5jb25zdCBmcmljdGlvbkluY3JlYXNpbmdBdG9tc0ppZ2dsaW5nVGVtcGVyYXR1cmVQYXR0ZXJuU3RyaW5nID0gRnJpY3Rpb25TdHJpbmdzLmExMXkuZnJpY3Rpb25JbmNyZWFzaW5nQXRvbXNKaWdnbGluZ1RlbXBlcmF0dXJlUGF0dGVybjtcclxuXHJcbi8vIGFsZXJ0IG9iamVjdCBmb3IgdGhlIE1heGltdW0gdGVtcCBhbGVydFxyXG5jb25zdCBNQVhfVEVNUF9TVFJJTkcgPSBTdHJpbmdVdGlscy5maWxsSW4oIGZyaWN0aW9uSW5jcmVhc2luZ0F0b21zSmlnZ2xpbmdUZW1wZXJhdHVyZVBhdHRlcm5TdHJpbmcsIHtcclxuICBqaWdnbGluZ0Ftb3VudDogc3VwZXJGYXN0U3RyaW5nLFxyXG4gIHRlbXBlcmF0dXJlOiBzdXBlckhvdFN0cmluZ1xyXG59ICk7XHJcblxyXG4vLyBAcHJpdmF0ZSAtIG11dGF0ZWQgYmFzZWQgb24gaWYgdGhlIFwicmVzZXRcIiBoaW50IHNob3VsZCBiZSBhZGRlZFxyXG5jb25zdCBNQVhfVEVNUF9SRVNQT05TRV9QQUNLRVQgPSBuZXcgUmVzcG9uc2VQYWNrZXQoIHtcclxuICBjb250ZXh0UmVzcG9uc2U6IE1BWF9URU1QX1NUUklOR1xyXG59ICk7XHJcblxyXG4vLyBUaHJlc2hvbGQgdGhhdCBtdXN0IGJlIHJlYWNoZWQgZnJvbSBpbml0aWFsIHRlbXAgdG8gbmV3IHRlbXAgdG8gYWxlcnQgdGhhdCB0aGUgdGVtcGVyYXR1cmUgY2hhbmdlZCwgaW4gYW1wbGl0dWRlIChzZWUgbW9kZWwgZm9yIG1vcmUgaW5mbylcclxuY29uc3QgVEVNUEVSQVRVUkVfQUxFUlRfVEhSRVNIT0xEID0gMS41O1xyXG5cclxuY29uc3QgSU5DUkVBU0lORyA9IFtcclxuICB7XHJcbiAgICBqaWdnbGU6IG1vcmVTdHJpbmcsXHJcbiAgICB0ZW1wOiB3YXJtZXJTdHJpbmdcclxuICB9LFxyXG4gIHtcclxuICAgIGppZ2dsZTogZmFzdGVyU3RyaW5nLFxyXG4gICAgdGVtcDogbm93SG90dGVyU3RyaW5nXHJcbiAgfSxcclxuICB7XHJcbiAgICBqaWdnbGU6IGV2ZW5GYXN0ZXJTdHJpbmcsXHJcbiAgICB0ZW1wOiBldmVuSG90dGVyU3RyaW5nXHJcbiAgfVxyXG5dO1xyXG5cclxuLy8gRnJvbSBtb2RlbCwgdGhlIGFtcGxpdHVkZSB2YWx1ZSB3aGVuIHRoZSBhdG9tcyBzaGVhciBvZmZcclxuY29uc3QgU0hFQVJJTkdfTElNSVQgPSBGcmljdGlvbk1vZGVsLk1BR05JRklFRF9BVE9NU19JTkZPLnNoZWFyaW5nTGltaXQ7XHJcblxyXG4vLyBob3cgbG9uZyB0byB3YWl0IHVudGlsIHdlIGNvbnNpZGVyIHRoaXMgbmV3ZXN0IGRyYWcgb2YgYSBkaWZmZXJlbnQgXCJkcmFnIHNlc3Npb25cIiwgc3VjaFxyXG4vLyB0aGF0IHRoZSB3YXJtaW5nIGFsZXJ0IHByb2dyZXNzaW9uIHdpbGwgc3RhcnQgb3ZlciBiYWNrIGF0IFwid2FybWVyXCIgYWxlcnRzLlxyXG4vLyBpbiBtc1xyXG5jb25zdCBEUkFHX1NFU1NJT05fVEhSRVNIT0xEID0gMTAwMDtcclxuXHJcbi8vIGluIG1zLCB0aW1lIGluIGJldHdlZW4gZWFjaCB3YXJtaW5nL2luY3JlYXNpbmcgYWxlcnRcclxuY29uc3QgV0FSTUlOR19BTEVSVF9USU1FX0RFTEFZID0gNTAwO1xyXG5jb25zdCBNQVhfVEVNUF9BTEVSVF9USU1FX0RFTEFZID0gMzAwMDtcclxuXHJcbi8vIFRoZSBhbW91bnQgb2YgYW1wbGl0dWRlIHRoYXQgdGhlIG1vZGVsIG11c3QgZGVjcmVhc2UgZnJvbSB0aGUgbGFzdCBwb2ludCB3aGVyZSBpdCB3YXMgaW5jcmVhc2luZy4gVGhpcyB2YWx1ZVxyXG4vLyBpcyB0byBoZWxwIGRldGVybWluZSBpZiB0aGUgdGVtcGVyYXR1cmUgaXMgbm8gbG9uZ2VyIGluY3JlYXNpbmcsIHdoaWxlIGFsb3dpbmcgZm9yIG1pbm9yIGZsdWN0dWF0aW9uLiBJbiBzYW1lIHVuaXRzXHJcbi8vIGFzIEZyaWN0aW9uTW9kZWwncyBhbXBsaXR1ZGVcclxuY29uc3QgQU1QTElUVURFX0RFQ1JFQVNJTkdfVEhSRVNIT0xEID0gMC40O1xyXG5cclxuXHJcbmNsYXNzIFRlbXBlcmF0dXJlSW5jcmVhc2luZ0FsZXJ0ZXIgZXh0ZW5kcyBBbGVydGVyIHtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzcG9uc2libGUgZm9yIGFsZXJ0aW5nIHdoZW4gdGhlIHRlbXBlcmF0dXJlIGluY3JlYXNlc1xyXG4gICAqIEBwYXJhbSB7RnJpY3Rpb25Nb2RlbH0gbW9kZWxcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIG1vZGVsLCBvcHRpb25zICkge1xyXG4gICAgc3VwZXIoIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG5cclxuICAgIC8vIEBwcml2YXRlXHJcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSB0aW1lIHRoYXQgdGhlIGxhc3QgZHJhZyBlbmRlZC4gVGhpcyBpcyBoZWxwZnVsIHRvIHNlZSBpZiBhIG5ldyBkcmFnIGlzIHdpdGhpbiB0aGUgc2FtZVxyXG4gICAgLy8gXCJkcmFnIHNlc3Npb25cIiwgbWVhbmluZyB0aGF0IHRoZSBhbGVydEluZGV4IGRvZXNuJ3QgcmVzZXQgYmFjayB0byB0aGUgZmlyc3QgYWxlcnQuXHJcbiAgICAvLyBEZWZhdWx0IHZhbHVlIGlzIHN1Y2ggdGhhdCByZXN0YXJ0IHdpbGwgYWx3YXlzIG9jY3VyIG9uIGZpcnN0IGRyYWcuXHJcbiAgICB0aGlzLnRpbWVPZkxhc3REcmFnID0gMDtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy5pbml0aWFsQW1wbGl0dWRlID0gbW9kZWwudmlicmF0aW9uQW1wbGl0dWRlUHJvcGVydHkudmFsdWU7XHJcblxyXG4gICAgLy8gemVybyBpbmRleGVkLCBzbyB0aGUgZmlyc3Qgb25lIGlzIDBcclxuICAgIC8vIEBwcml2YXRlXHJcbiAgICB0aGlzLmFsZXJ0SW5kZXggPSAtMTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZSB7Ym9vbGVhbn0gLSBkb24ndCBhbGVydCB0b28gbWFueSBhbGVydHMgYWxsIGF0IG9uY2UsIHRoZXNlIGZsYWdzIGFyZSBvbmx5IHN3aXRjaGVkIGFmdGVyIGEgdGltZW91dFxyXG4gICAgdGhpcy50b29Tb29uRm9yTmV4dFdhcm1pbmdBbGVydCA9IGZhbHNlO1xyXG4gICAgdGhpcy50b29Tb29uRm9yTmV4dE1heFRlbXBBbGVydCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEBwcml2YXRlIHtib29sZWFufSAtIGtlZXAgdHJhY2sgb2YgaWYgdGhlIG1vZGVsIGlzIGluY3JlYXNpbmcgb3Igbm93LCB3aXRoIGEgc3BlY2lhbCB0aHJlc2hvbGQgc3BlY2lmaWMgdG8gdGhlXHJcbiAgICAvLyBuZWVkcyBvZiB0aGlzIHdhcm1pbmcgYWxlcnRlci4gQnkgXCJpbmNyZWFzaW5nXCIgaXQgYWxzbyBtZWFucyBzdGF5cyB0aGUgc2FtZSwgb3IgbG93ZXJzIGp1c3QgYSBiaXQgYmVmb3JlIGluY3JlYXNpbmcgYWdhaW4uXHJcbiAgICB0aGlzLmFtcGxpdHVkZUluY3JlYXNpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy5tYXhUZW1wVXR0ZXJhbmNlID0gbmV3IFV0dGVyYW5jZSgge1xyXG4gICAgICBhbGVydDogTUFYX1RFTVBfUkVTUE9OU0VfUEFDS0VULFxyXG4gICAgICBwcmVkaWNhdGU6ICgpID0+IHRoaXMuYW1wbGl0dWRlSW5jcmVhc2luZyAmJiBtb2RlbC52aWJyYXRpb25BbXBsaXR1ZGVQcm9wZXJ0eS52YWx1ZSA+PSBGcmljdGlvbk1vZGVsLlRIRVJNT01FVEVSX01BWF9URU1QLFxyXG4gICAgICBwcmlvcml0eTogVXR0ZXJhbmNlLkxPV19QUklPUklUWSxcclxuICAgICAgYW5ub3VuY2VyT3B0aW9uczoge1xyXG5cclxuICAgICAgICAvLyBldmVuIHRob3VnaCBpdCBpcyBhbm5veWluZyB0byByZXBlYXQgdGhlc2UsIGl0IGlzIGJldHRlciB0aGFuIGhlYXJpbmcgdGhlIGJlZ2lubmluZyAxMCB0aW1lcyBiZWZvcmUgaGVhcmluZyB0aGUgYWN0dWFsIGFsZXJ0LlxyXG4gICAgICAgIGNhbmNlbFNlbGY6IGZhbHNlXHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICAvLyBAcHJpdmF0ZVxyXG4gICAgdGhpcy50ZW1wZXJhdHVyZUppZ2dsZVV0dGVyYW5jZSA9IG5ldyBVdHRlcmFuY2UoIHtcclxuICAgICAgcHJlZGljYXRlOiAoKSA9PiB0aGlzLmFtcGxpdHVkZUluY3JlYXNpbmcsXHJcbiAgICAgIGFsZXJ0OiBuZXcgUmVzcG9uc2VQYWNrZXQoKVxyXG4gICAgfSApO1xyXG5cclxuICAgIGxldCBsb2NhbE1heGltYSA9IDA7XHJcblxyXG4gICAgLy8gQHByaXZhdGVcclxuICAgIHRoaXMuYW1wbGl0dWRlTGlzdGVuZXIgPSAoIGFtcGxpdHVkZSwgb2xkQW1wbGl0dWRlICkgPT4ge1xyXG5cclxuICAgICAgaWYgKCBhbXBsaXR1ZGUgPiBvbGRBbXBsaXR1ZGUgKSB7XHJcbiAgICAgICAgbG9jYWxNYXhpbWEgPSBhbXBsaXR1ZGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuYW1wbGl0dWRlSW5jcmVhc2luZyA9ICEoIGxvY2FsTWF4aW1hIC0gYW1wbGl0dWRlID4gQU1QTElUVURFX0RFQ1JFQVNJTkdfVEhSRVNIT0xEICk7XHJcblxyXG4gICAgICAvLyB0aGUgZGlmZmVyZW5jZSBpbiBhbXBsaXR1ZGUgaGFzIHRvIGJlIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xkIHRvIGFsZXJ0XHJcbiAgICAgIGlmICggIXRoaXMudG9vU29vbkZvck5leHRXYXJtaW5nQWxlcnQgJiYgYW1wbGl0dWRlIDwgU0hFQVJJTkdfTElNSVQgJiYgYW1wbGl0dWRlIC0gdGhpcy5pbml0aWFsQW1wbGl0dWRlID4gVEVNUEVSQVRVUkVfQUxFUlRfVEhSRVNIT0xEICkge1xyXG4gICAgICAgIHRoaXMuYWxlcnRJbmNyZWFzZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCAhdGhpcy50b29Tb29uRm9yTmV4dE1heFRlbXBBbGVydCAmJiBhbXBsaXR1ZGUgPj0gRnJpY3Rpb25Nb2RlbC5USEVSTU9NRVRFUl9NQVhfVEVNUCApIHtcclxuICAgICAgICB0aGlzLmFsZXJ0TWF4VGVtcCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZXNldCBldmVuIHdpdGhvdXQgYSBuZXcgZHJhZyBpZiB3ZSBhcmUgc2V0dGxlZC5cclxuICAgICAgaWYgKCBhbXBsaXR1ZGUgPD0gRnJpY3Rpb25Nb2RlbC5BTVBMSVRVREVfU0VUVExFRF9USFJFU0hPTEQgKSB7XHJcbiAgICAgICAgdGhpcy5vbkRyYWcoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVBbGVydHMoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBleGlzdHMgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgc2ltLCBubyBuZWVkIHRvIGRpc3Bvc2VcclxuICAgIHRoaXMubW9kZWwudmlicmF0aW9uQW1wbGl0dWRlUHJvcGVydHkubGluayggdGhpcy5hbXBsaXR1ZGVMaXN0ZW5lciApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIGRhdGEgc28gdGhhdCB0aGUgd2FybWluZyBhbGVydHMgd2lsbCBzdGFydCBvdmVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBpbml0aWFsaXplQWxlcnRzKCkge1xyXG4gICAgdGhpcy5hbGVydEluZGV4ID0gLTE7IC8vIHJlc2V0XHJcblxyXG4gICAgLy8gTm9ybWFsbHksIGNhcHR1cmUgdGhlIGluaXRpYWwgYW1wbGl0dWRlIGFzIHRlbXBlcmF0dXJlIHJlZ2lvbnMgY2hhbmdlLiBCdXQgaWYgYWxyZWFkeSBhdCB0aGUgbWF4LCB0aGVuIHNldFxyXG4gICAgLy8gYW1wbGl0dWRlIHRvIGEgdmVyeSBkaWZmZXJlbnQgbnVtYmVyLCBzbyB0aGF0IG1heC10ZW1wIGFsZXJ0cyBjYW4gY29udGludWUgdG8gZmlyZS5cclxuICAgIHRoaXMuaW5pdGlhbEFtcGxpdHVkZSA9IHRoaXMubW9kZWwudmlicmF0aW9uQW1wbGl0dWRlUHJvcGVydHkudmFsdWUgPiBGcmljdGlvbk1vZGVsLlRIRVJNT01FVEVSX01BWF9URU1QID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwudmlicmF0aW9uQW1wbGl0dWRlUHJvcGVydHkuaW5pdGlhbFZhbHVlIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwudmlicmF0aW9uQW1wbGl0dWRlUHJvcGVydHkudmFsdWU7XHJcbiAgfVxyXG5cclxuICAvLyBAcHVibGljXHJcbiAgLy8gdHJpZ2dlcmVkIG9uIGV2ZXJ5IGtleWRvd24vbW91c2Vkb3duXHJcbiAgc3RhcnREcmFnKCkge1xyXG5cclxuICAgIC8vIElmIGxvbmdlciB0aGFuIHRocmVzaG9sZCwgdHJlYXQgYXMgbmV3IFwiZHJhZyBzZXNzaW9uXCJcclxuICAgIGlmICggcGhldC5qb2lzdC5lbGFwc2VkVGltZSAtIHRoaXMudGltZU9mTGFzdERyYWcgPiBEUkFHX1NFU1NJT05fVEhSRVNIT0xEICkge1xyXG4gICAgICB0aGlzLmluaXRpYWxpemVBbGVydHMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCBieSBhbXBsaXR1ZGUgbGlzdGVuZXIgaW4gYWRkaXRpb24gdG8gb24gZHJhZyBmb3IgcmVzZXR0aW5nIGRyYWcgdGltZS5cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgb25EcmFnKCkge1xyXG4gICAgdGhpcy50aW1lT2ZMYXN0RHJhZyA9IHBoZXQuam9pc3QuZWxhcHNlZFRpbWU7XHJcbiAgfVxyXG5cclxuICAvLyBAcHVibGljXHJcbiAgZW5kRHJhZygpIHtcclxuICAgIGlmICggdGhpcy5tb2RlbC52aWJyYXRpb25BbXBsaXR1ZGVQcm9wZXJ0eS52YWx1ZSA+PSBGcmljdGlvbk1vZGVsLlRIRVJNT01FVEVSX01BWF9URU1QICkge1xyXG4gICAgICB0aGlzLmZvckVhY2hVdHRlcmFuY2VRdWV1ZSggdXR0ZXJhbmNlUXVldWUgPT4ge1xyXG4gICAgICAgIHV0dGVyYW5jZVF1ZXVlLmhhc1V0dGVyYW5jZSggdGhpcy50ZW1wZXJhdHVyZUppZ2dsZVV0dGVyYW5jZSApICYmIHV0dGVyYW5jZVF1ZXVlLnJlbW92ZVV0dGVyYW5jZSggdGhpcy50ZW1wZXJhdHVyZUppZ2dsZVV0dGVyYW5jZSApO1xyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICB2b2ljaW5nVXR0ZXJhbmNlUXVldWUuaGFzVXR0ZXJhbmNlKCB0aGlzLnRlbXBlcmF0dXJlSmlnZ2xlVXR0ZXJhbmNlICkgJiYgdm9pY2luZ1V0dGVyYW5jZVF1ZXVlLnJlbW92ZVV0dGVyYW5jZSggdGhpcy50ZW1wZXJhdHVyZUppZ2dsZVV0dGVyYW5jZSApO1xyXG4gICAgfVxyXG4gICAgdGhpcy50aW1lT2ZMYXN0RHJhZyA9IHBoZXQuam9pc3QuZWxhcHNlZFRpbWU7XHJcbiAgfVxyXG5cclxuICAvLyBAcHJpdmF0ZVxyXG4gIGFsZXJ0SW5jcmVhc2UoKSB7XHJcbiAgICB0aGlzLmFsZXJ0SW5kZXgrKztcclxuICAgIGNvbnN0IGN1cnJlbnRBbGVydEluZGV4ID0gTWF0aC5taW4oIHRoaXMuYWxlcnRJbmRleCwgSU5DUkVBU0lORy5sZW5ndGggLSAxICk7XHJcblxyXG4gICAgY29uc3QgYWxlcnRPYmplY3QgPSBJTkNSRUFTSU5HWyBjdXJyZW50QWxlcnRJbmRleCBdO1xyXG5cclxuICAgIHRoaXMudGVtcGVyYXR1cmVKaWdnbGVVdHRlcmFuY2UuYWxlcnQuY29udGV4dFJlc3BvbnNlID0gU3RyaW5nVXRpbHMuZmlsbEluKCBmcmljdGlvbkluY3JlYXNpbmdBdG9tc0ppZ2dsaW5nVGVtcGVyYXR1cmVQYXR0ZXJuU3RyaW5nLCB7XHJcbiAgICAgIHRlbXBlcmF0dXJlOiBhbGVydE9iamVjdC50ZW1wLFxyXG4gICAgICBqaWdnbGluZ0Ftb3VudDogYWxlcnRPYmplY3QuamlnZ2xlXHJcbiAgICB9ICk7XHJcblxyXG4gICAgdGhpcy5hbGVydCggdGhpcy50ZW1wZXJhdHVyZUppZ2dsZVV0dGVyYW5jZSApO1xyXG5cclxuICAgIC8vIHJlc2V0IHRoZSBcImluaXRpYWxBbXBsaXR1ZGVcIiB0byB0aGUgY3VycmVudCBhbXBsaXR1ZGUsIGJlY2F1c2UgdGhlbiBpdCB3aWxsIHRha2UgYW5vdGhlciB3aG9sZSB0aHJlc2hvbGQgbGV2ZWwgdG8gYWxlcnQgYWdhaW5cclxuICAgIHRoaXMuaW5pdGlhbEFtcGxpdHVkZSA9IHRoaXMubW9kZWwudmlicmF0aW9uQW1wbGl0dWRlUHJvcGVydHkudmFsdWU7XHJcblxyXG4gICAgLy8gc2V0IHRvIHRydWUgdG8gbGltaXQgc3Vic2VxdWVudCBhbGVydHMgZmlyaW5nIHJhcGlkbHlcclxuICAgIHRoaXMudG9vU29vbkZvck5leHRXYXJtaW5nQWxlcnQgPSB0cnVlO1xyXG4gICAgc3RlcFRpbWVyLnNldFRpbWVvdXQoICgpID0+IHsgdGhpcy50b29Tb29uRm9yTmV4dFdhcm1pbmdBbGVydCA9IGZhbHNlOyB9LCBXQVJNSU5HX0FMRVJUX1RJTUVfREVMQVkgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsZXJ0IHRoZSBtYXhpbXVtIHRlbXBlcmF0ZSBhbGVydCwgdmFyaWVkIGJhc2VkIG9uIGlmIGl0IGlzIHRoZSBmaXJzdCB0aW1lIGFsZXJ0aW5nLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgYWxlcnRNYXhUZW1wKCkge1xyXG4gICAgdGhpcy5hbGVydCggdGhpcy5tYXhUZW1wVXR0ZXJhbmNlICk7XHJcblxyXG4gICAgdGhpcy5pbml0aWFsQW1wbGl0dWRlID0gdGhpcy5tb2RlbC52aWJyYXRpb25BbXBsaXR1ZGVQcm9wZXJ0eS52YWx1ZTtcclxuXHJcbiAgICAvLyBzZXQgdG8gdHJ1ZSB0byBsaW1pdCBzdWJzZXF1ZW50IGFsZXJ0cyBmaXJpbmcgcmFwaWRseVxyXG4gICAgdGhpcy50b29Tb29uRm9yTmV4dE1heFRlbXBBbGVydCA9IHRydWU7XHJcbiAgICBzdGVwVGltZXIuc2V0VGltZW91dCggKCkgPT4geyB0aGlzLnRvb1Nvb25Gb3JOZXh0TWF4VGVtcEFsZXJ0ID0gZmFsc2U7IH0sIE1BWF9URU1QX0FMRVJUX1RJTUVfREVMQVkgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSBEZXNjcmliZXJcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcmVzZXQoKSB7XHJcbiAgICB0aGlzLnRlbXBlcmF0dXJlSmlnZ2xlVXR0ZXJhbmNlLnJlc2V0KCk7XHJcbiAgICB0aGlzLm1heFRlbXBVdHRlcmFuY2UucmVzZXQoKTtcclxuICB9XHJcbn1cclxuXHJcbmZyaWN0aW9uLnJlZ2lzdGVyKCAnVGVtcGVyYXR1cmVJbmNyZWFzaW5nQWxlcnRlcicsIFRlbXBlcmF0dXJlSW5jcmVhc2luZ0FsZXJ0ZXIgKTtcclxuZXhwb3J0IGRlZmF1bHQgVGVtcGVyYXR1cmVJbmNyZWFzaW5nQWxlcnRlcjsiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxTQUFTLE1BQU0sa0NBQWtDO0FBQ3hELE9BQU9DLFdBQVcsTUFBTSwrQ0FBK0M7QUFDdkUsT0FBT0MsT0FBTyxNQUFNLGlFQUFpRTtBQUNyRixTQUFTQyxxQkFBcUIsUUFBUSxtQ0FBbUM7QUFDekUsT0FBT0MsY0FBYyxNQUFNLGtEQUFrRDtBQUM3RSxPQUFPQyxTQUFTLE1BQU0sNkNBQTZDO0FBQ25FLE9BQU9DLFFBQVEsTUFBTSxtQkFBbUI7QUFDeEMsT0FBT0MsZUFBZSxNQUFNLDBCQUEwQjtBQUN0RCxPQUFPQyxhQUFhLE1BQU0sMkJBQTJCOztBQUVyRDtBQUNBLE1BQU1DLFVBQVUsR0FB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